{"version":3,"file":"5700.bundle.135f4111f048aa18b8a5.js","mappings":"kKA4GO,MAAMA,EAAgBA,CAACC,EAAMC,KAChC,MAAMC,EAAID,EAAQ,EAGZE,EAAMC,MAAMF,GAAGG,KAAK,GACpBC,EAAMF,MAAMG,KAAK,CAAEC,OAAQN,IAAK,IAAME,MAAMF,GAAGG,KAAK,KAG1D,IAAK,IAAII,EAAI,EAAGA,EAAIP,EAAGO,IAAK,CACxB,IAAK,IAAIC,EAAI,EAAGA,EAAIR,EAAGQ,IACnBJ,EAAIG,GAAGC,GAAKV,EAAKW,QAAO,CAACC,EAAKC,IAAsB,OAAZA,EAAMC,EAAaF,EAAMC,EAAME,IAAMN,EAAIC,GAAKE,GAAK,GAE/FT,EAAIM,GAAKT,EAAKW,QAAO,CAACC,EAAKC,IAAsB,OAAZA,EAAMC,EAAaF,EAAOC,EAAME,GAAKN,EAAKI,EAAMC,EAAIF,GAAK,EAClG,CAEAN,EAAIU,KAAKb,GAGT,MAAMc,EA9EV,SAA6BC,EAAQjB,GACjC,MAAMkB,EAAID,EAAOV,OAAS,EACpBS,EAAeb,MAAMH,GAE3B,IAAK,IAAIQ,EAAI,EAAGA,EAAIU,EAAGV,IAAK,CACxB,IAAIW,EAASX,EAEb,IAAK,IAAIC,EAAID,EAAI,EAAGC,EAAIS,EAAGT,IACnBW,KAAKC,IAAIJ,EAAOT,GAAGC,IAAMW,KAAKC,IAAIJ,EAAOT,GAAGW,MAC5CA,EAASV,GAKjB,IAAK,IAAIR,EAAIO,EAAGP,GAAKiB,EAAGjB,KACnBgB,EAAOhB,GAAGO,GAAIS,EAAOhB,GAAGkB,IAAW,CAACF,EAAOhB,GAAGkB,GAASF,EAAOhB,GAAGO,IAItE,IAAK,IAAIC,EAAID,EAAI,EAAGC,EAAIS,EAAGT,IACvB,IAAK,IAAIR,EAAIiB,EAAGjB,GAAKO,EAAGP,IAEpBgB,EAAOhB,GAAGQ,IAAOQ,EAAOhB,GAAGO,GAAKS,EAAOT,GAAGC,GAAMQ,EAAOT,GAAGA,EAGtE,CAGA,IAAK,IAAIC,EAAIS,EAAI,EAAGT,GAAK,EAAGA,IAAK,CAC7B,IAAIa,EAAQ,EACZ,IAAK,IAAIrB,EAAIQ,EAAI,EAAGR,EAAIiB,EAAGjB,IACvBqB,GAASL,EAAOhB,GAAGQ,GAAKO,EAAaf,GAGzCe,EAAaP,IAAMQ,EAAOC,GAAGT,GAAKa,GAASL,EAAOR,GAAGA,EACzD,CAEA,OAAOO,CACX,CAwCyBO,CAAoBlB,EAAKJ,GAAGuB,KAAIC,GAAKA,IAK1D,MAAO,CACHC,QAHaZ,GAAME,EAAaN,QAAO,CAACC,EAAKgB,EAAOC,IAAUjB,EAAOgB,EAAQb,GAAKc,GAAQ,GAI1FC,SAAU,IAAIb,GAAcc,UAC/B,E,eCnIL,MAEMC,EAAaA,CAACC,EAAGlB,EAAGmB,EAAK,QACnBD,EAAElB,EAAImB,GAAMD,EAAElB,IAAMmB,EAG1BC,EAAkBC,IACpB,MAAOC,EAAIC,GAAM,CAAC,EAAGF,GACfG,EAAUlB,KAAKmB,KAAK,EAAIJ,EAAQA,GACtC,MAAO,CAACC,EAAKE,EAASD,EAAKC,EAAQ,EAG1BE,EAAmBA,CAACR,EAAGlB,KAChC,MAAM2B,EAAeV,EAAWC,EAAGlB,GACnC,OAAOoB,EAAeO,EAAa,EASjCC,EAAoBA,CAACC,EAAIC,EAAIC,IACxBzB,KAAK0B,MAAMD,EAAIF,GAAM,EAAIE,GAAKD,GAGnCG,EAAyBA,CAACJ,EAAIC,EAAII,EAAMC,EAAMC,IACzC9B,KAAK0B,MAAMG,EAAON,GAAMO,EAAOD,GAAQD,GAAQ,EAAIE,GAAQN,GAMzDO,EAAsBA,CAACrC,EAAGsC,EAAgBC,EAAWC,KAE9D,IAAKC,EAAUC,GAnBYC,EAACzB,EAAGlB,KAC/B,MAAM2B,EAAeV,EAAWC,EAAGlB,GAEnC,OAAOoB,GADc,EAAIO,EACS,EAgBPgB,CAAgBL,EAAgBtC,GAK3D,MAAMD,EAAIuC,EAAetC,GACzB,IAAI4C,EAA6B,CAAC5C,EAAI6C,GAA0BJ,EAC9B1C,EAAI8C,GAA0BH,GAC5DI,EAA6B,CAAC9C,EAAI6C,GAA0BJ,EAC9B1C,EAAI8C,GAA0BH,GAE5DE,EAAS,IAAMN,EAAeM,EAAS,OACtCA,EAAUE,GAAY,CAACA,EAAUF,IACjCH,EAAUC,GAAY,EAAED,GAAWC,IAIxC,MAAMK,EAAiB,IACjBC,EAAY,IAAIC,aAAaF,EAAiBP,EAAEU,UAAU5D,MAAM,KACtE,IAAK,IAAI6D,EAAQ,EAAGA,EAAQX,EAAEU,SAAUC,IACpC,IAAK,IAAIzD,EAAI,EAAGA,EAAIqD,EAAgBrD,GAAK,EAAG,CACxC,MAAM0D,EAAKR,EAAS,GAAMlD,EAAI,EAAK+C,EAC7BY,EAAKT,EAAS,GAAMlD,EAAI,EAAKgD,EAC7BY,EAAKV,EAAS,IAAOlD,EAAI,GAAK,EAAK+C,EACnCc,EAAKX,EAAS,IAAOlD,EAAI,GAAK,EAAKgD,GAClCc,EAAKC,EAAKC,EAAKC,GAAO,CAACrD,KAAKsD,MAAMR,GAAK9C,KAAKsD,MAAMN,GAAKhD,KAAKsD,MAAMP,GAAK/C,KAAKsD,MAAML,IACzF,GAAIH,GAAM,GAAKC,GAAM,GAAKC,EAAKd,EAAEqB,YAAcN,EAAKf,EAAEsB,YAAa,CAC/D,MAAMC,GAAavB,EAAEwB,SAAWb,GAASX,EAAEyB,UAAYP,EAAMlB,EAAEqB,WAAaL,EAC5E,GAAIA,IAAQC,GAAOC,IAAQC,EAEvBX,EAAUG,EAAQJ,EAAiBrD,GAAK6C,EAAUwB,QAC/C,GAAIL,IAAQC,EAAK,CAEpB,MAAMO,EAAMV,EAAMC,GAAQ,EAAIL,EAAK,GAAKX,GAAaW,EAAK,EAAKX,EACzD0B,GAAa3B,EAAEwB,SAAWb,GAASX,EAAEyB,UAAYP,EAAMlB,EAAEqB,WAAaJ,EAC5ET,EAAUG,EAAQJ,EAAiBrD,GAAKkC,EAAkBW,EAAUwB,GAAYxB,EAAU4B,GAAYD,EAC1G,MAAO,GAAIV,IAAQC,EAAK,CAEpB,MAAMW,EAAMV,EAAMC,GAAQ,EAAIN,EAAK,GAAKX,GAAaW,EAAK,EAAKX,EACzDyB,GAAa3B,EAAEwB,SAAWb,GAASX,EAAEyB,UAAYN,EAAMnB,EAAEqB,WAAaL,EAC5ER,EAAUG,EAAQJ,EAAiBrD,GAAKkC,EAAkBW,EAAUwB,GAAYxB,EAAU4B,GAAYC,EAC1G,KAAO,CAEH,MAAMF,EAAMV,EAAMC,GAAQ,EAAIL,EAAK,GAAKX,GAAaW,EAAK,EAAKX,EACzD2B,EAAMV,EAAMC,GAAQ,EAAIN,EAAK,GAAKX,GAAaW,EAAK,EAAKX,EACzDyB,GAAa3B,EAAEwB,SAAWb,GAASX,EAAEyB,UAAYN,EAAMnB,EAAEqB,WAAaJ,EACtEY,EAAYH,EAAKE,GAChB5B,EAAEwB,SAAWb,GAASX,EAAEyB,UAAYP,EAAMlB,EAAEqB,WAAaJ,GACzDjB,EAAEwB,SAAWb,GAASX,EAAEyB,UAAYN,EAAMnB,EAAEqB,WAAaL,EAC1DrB,EAAO7B,KAAKgE,IAAIJ,EAAIE,GACpBhC,EAAO9B,KAAKiE,IAAIL,EAAIE,GAC1BpB,EAAUG,EAAQJ,EAAiBrD,GAAKuC,EAAuBM,EAAUwB,GAAYxB,EAAU4B,GAChC5B,EAAU8B,GAAYlC,EAAMC,EAC/F,CACJ,CACJ,CAaJ,MAVmC,CAC/BY,UAAWA,EACXwB,MAAOzB,EACP0B,OAAQjC,EAAEU,SACVwB,SAAU,CAAC9B,EAAUE,GACrB6B,UAAW,CAAClC,EAAUC,GACtBkC,YAAa,CAAC5E,EAAGD,GACjBiE,SAAUxB,EAAEwB,SAGM,ECjGpBa,EAAUC,EAAQ,MAClBC,EAAmBC,EAAAA,GAAKC,QAAQC,iBAwBtC,MAAMrC,EAAsB,GAUtBsC,EAAgBA,CAACC,EAAQC,IACpB,IAAIC,SAAQ,CAACC,EAASC,KACzBJ,EAAOK,QAAOC,UACV,MAAMC,EAAoB,IAAIC,EAAAA,EAAkBC,GAC1CC,EAAUH,EAAkBI,QAAQF,GACpCG,QAAYL,EAAkBM,SAASJ,EAAMC,GAC7CI,QAAgBP,EAAkBQ,WAAWH,EAAKF,EAAST,GA/B7E,IAAuBe,UAgCS,IAAMF,EAAQJ,QA/BnC,IAAIR,SAAQ,CAACC,EAASC,KACzB,MAAMa,EAAOA,KACT,MAAMC,EAASF,IACf,GAAIE,EACA,OAAOf,EAAQe,GAEfC,YAAW,IAAMF,KAAQ,GAC7B,EAEJA,GAAM,KAwBF,MAAM,iBAAEG,EAAgB,kBAAEC,EAAiB,eAAEC,GAAmBR,EAChEnB,EAAiB4B,iBAAiBb,EAAS,CACvCU,mBACAC,oBACAC,iBACAE,WAAYV,EAAQW,eAAiB,EAAIX,EAAQY,eAAiB,IAEtEvB,EAAQW,EAAQ,GAClB,IAIJa,EAAqBrB,MAAMsB,EAAUC,GAAgBC,mBAAkBC,mBAAmBC,KAC5F,MAAM,kBAAEC,EAAiB,wBAAEC,GAA4BH,EAAgBI,SAEvEC,EAAAA,mBAAmBC,aAAaT,GAChC,MAAMU,EAAoBL,EAAkBM,uBACtCC,EAAkB,CAACF,EAAkBA,EAAkBjI,OAAS,IAChEoI,EAAkB,CACpBC,YAAa,MACbb,aAAcA,EACdc,YAAa,QACbC,oBAAqB,CACjBC,OAAQ,WAGVC,EAAahB,EAAiBiB,iBAAiB,GASrD,aAP2Bb,EAAwBP,mBAC/Ca,EACAC,EACAK,EACAd,EAGe,EAwDjBgB,EAAUC,IACZ,IAAIC,EAAMD,EAAI5I,OACV8E,GAAOgE,IAEX,KAAOD,KACH/D,EAAM8D,EAAIC,GAAO/D,EAAM8D,EAAIC,GAAO/D,EAEtC,OAAOA,CAAG,EAoGRiE,EAAiBA,CAACxF,EAAWR,KAC/B,MAMMiG,EAvGaC,EAACL,EAAK7D,EAAOC,KAChC,MAAMkE,EAAgB,GACtB,IAAK,IAAIjJ,EAAI,EAAGA,EAAI8E,EAAO9E,IACvB,IAAK,IAAIC,EAAI,EAAGA,EAAI8E,EAAQ9E,IACxBgJ,EAAc1I,KAAKoI,EAAI1I,EAAI6E,EAAQ9E,IAG3C,OAAOiJ,CAAa,EAgGED,CAFK1F,EAAUtC,KAAIkI,GAASA,EA5NpB,KA4NwDA,GAAS,MAJxE/F,GAMkDL,EAAEU,UAE3E,IAAI2F,EAA2BxJ,MAAMG,KAAKiJ,GAAe/H,KAAI,CAACkI,EAAOE,KAAmB,MAAXF,EAAkB,KACxF,CAAE5I,EAAG8I,EAAMtG,EAAEU,SAAUnD,EAAGO,KAAKsD,MAAMkF,EAAMtG,EAAEU,aAAc6F,QAAOH,GAASA,IAGlF,IAAK,IAAII,EAAI,EAAGA,EAAIxG,EAAEU,SAAU8F,GAAK,GACjCH,EAAyB5I,KAAK,CAACD,EAAGgJ,EAAGjJ,EAAG8C,KAI5C,IAAIP,EAAiBtD,EAAc6J,EAA0B,GAGzDI,EAAiBjJ,GAAM6C,GAC3B,GAAIuF,EAAOK,IAAkB,MAASnG,EAAevB,SAASmI,MAAMN,GAAUO,MAAMP,KAAS,CAEzF,MAAMQ,EAAOX,EAAc7I,QAAO,CAAC0E,EAAK+E,EAAKP,IACvCA,EAAMtG,EAAEU,SAAWoB,IAAe,KAAR+E,EAAgBP,EAAMtG,EAAEU,SAAWoB,GAAMiE,KACnEe,EAAOb,EAAc7I,QAAO,CAAC2E,EAAK8E,EAAKP,IACvCA,EAAMtG,EAAEU,SAAWqB,IAAe,KAAR8E,EAAgBP,EAAMtG,EAAEU,SAAWqB,IAAOgE,KAC1EU,EA/CcM,EAACrI,EAAGkI,EAAME,IASpBnG,IACJ,MAAMqG,EAAc,GAAK,EAAIlJ,KAAKmJ,KAP3B,IAOsCtG,EAAQiG,KAC/CM,EAAe,GAAK,EAAIpJ,KAAKmJ,IAP5B,IAOsCtG,EAAQmG,KAGrD,OAF4BpI,EAAEiC,GAEDqG,EAAcE,EARpC3G,IASK,EAAIyG,GARTzG,IAQ8B,EAAI2G,EAAa,EAgCtCH,CAAcjH,EAAe1B,QAASwI,EAAME,EAChE,CAEA,OAAOL,CAAa,EA2JlBU,EAAsBjE,MAAMkE,EAA0BC,GAA4B1C,sBACpF,MAAM,2BACF2C,EAA0B,iBAC1BC,GACA5C,EAAgBI,SAEdyC,EAAYJ,EAASK,eACrBC,EAAaF,EAAUE,YACtBrG,EAAYC,EAAaqG,GAAKH,EAAUI,WACzCpG,EAAW1D,KAAKsD,MAAMsG,EAAWG,WAAWzB,GAAUA,GAAS,MAAQ/E,EAAaC,GACpFwG,EAAWhK,KAAKsD,MAAMsG,EAAWK,eAAe3B,GAAUA,GAAS,MAAQ/E,EAAaC,GAAe,EAEtG0G,EAAa,CAAC3G,WAAYA,EAAYC,YAAaA,EAAaG,UAAWJ,EAAaC,EAC3EE,SAAUA,EAAUd,SAAUoH,EAAWtG,GAEvDyG,EAzQgBC,EAACR,EAAY1H,KACnC,MAAMiI,EAAc,IAAIxH,aAAaT,EAAEqB,WAAarB,EAAEU,UAEtD,IAAK,IAAI/D,EAAI,EAAGA,EAAIqD,EAAEU,SAAU/D,IAC5B,IAAK,IAAIQ,EAAI,EAAGA,EAAI6C,EAAEqB,WAAYlE,IAAK,CAEnC,IAAIgL,GAAS,IACb,IAAK,IAAIjL,EAAI,EAAGA,EAAI8C,EAAEsB,YAAapE,IAAK,CACpC,MAAMkJ,EAAQsB,GAAY/K,EAAIqD,EAAEwB,UAAYxB,EAAEyB,UAAYtE,EAAI6C,EAAEsB,YAAcpE,GAC1EkJ,EAAQ+B,IACRA,EAAS/B,EAEjB,CACA6B,EAAYtL,EAAIqD,EAAEsB,YAAcnE,GAAKgL,CACzC,CAGJ,OAAOF,CAAW,EAwPEC,CAAkBR,EAAYM,GAG5CI,EAAiB/F,EAAQ4F,EAAa,IACrCI,UAAUC,EAAkBC,KAAKC,GAAeJ,EACjDK,EAAiBH,EAAiBI,QAAQ5K,KAAKiE,OAAOuG,IAEtDK,EAAiBnH,EAAW1D,KAAKsD,MAAMoH,EAAYX,WAAWzB,GAAUA,IAAUqC,IAAkBnH,GACpGsH,EAAiBpH,EAAW1D,KAAKsD,MAAMoH,EAAYT,eAAe3B,GAAUA,IAAUqC,IAAkBnH,GAAe,EAC7HuH,QAAQC,IAAI,qBAAsBH,EAAgBC,GAClDC,QAAQC,IAAI,YAAaR,GAGzB,MAAMS,EAhQeC,EAACtB,EAAYlG,EAAUsG,EAAU9H,KACtD,MAAMiJ,EAAgBnB,EAAWtG,EAE3BuH,EAAY,IAAItI,aAAaT,EAAEqB,WAAarB,EAAEsB,aAEpD,IAAK,IAAIpE,EAAI,EAAGA,EAAI8C,EAAEqB,WAAYnE,IAC9B,IAAK,IAAIC,EAAI,EAAGA,EAAI6C,EAAEsB,YAAanE,IAAK,CAEpC,IAAI+L,EAAS,EACb,IAAK,IAAIvM,EAAI,EAAGA,EAAIsM,EAAetM,IAC/BuM,GAAUxB,GAAYlG,EAAW7E,GAAKqD,EAAEyB,UAAYtE,EAAI6C,EAAEqB,WAAanE,GAE3E6L,EAAU5L,EAAI6C,EAAEqB,WAAanE,GAAKgM,EAASD,CAC/C,CAGJ,OAAOF,CAAS,EAgPEC,CAAiBtB,EAAYiB,EAAgBC,EAAgBZ,GAGzEmB,EAAgB9G,EAAQ0G,EAAW,IACnC,UAACV,EAAS,KAAEE,GAAQY,EACpBC,EAAgBf,EAAUK,QAAQ9C,EAAOyC,IAK/C,MAAMgB,EAxHKC,EAACC,EAAOvH,EAAOC,EAAQuH,KAClC,MAAM1F,EAAS,IAAIjH,MAAMmF,EAAQC,GAAQnF,MAAM,KAEzC2M,EAAWA,CAACjM,EAAGD,IAAMgM,EAAMhM,EAAIyE,EAAQxE,IAAM,EAEnD,IAAK,IAAIkM,EAAY,EAAGA,EAAYF,EAAYE,IAAa,CACzD,IAAK,IAAInM,EAAI,EAAGA,EAAI0E,EAAS,EAAG1E,IAC5B,IAAK,IAAIC,EAAI,EAAGA,EAAIwE,EAAQ,EAAGxE,IAAK,CAChC,MAAMmM,EAAY,CACdF,EAASjM,EAAI,EAAGD,EAAI,GAAIkM,EAASjM,EAAGD,EAAI,GAAIkM,EAASjM,EAAI,EAAGD,EAAI,GAChEkM,EAASjM,EAAI,EAAGD,GAAIkM,EAASjM,EAAGD,GAAIkM,EAASjM,EAAI,EAAGD,GACpDkM,EAASjM,EAAI,EAAGD,EAAI,GAAIkM,EAASjM,EAAGD,EAAI,GAAIkM,EAASjM,EAAI,EAAGD,EAAI,IAGpEuG,EAAOvG,EAAIyE,EAAQxE,GAAKM,KAAKiE,OAAO4H,EACxC,CAIJ,IAAK,IAAIzM,EAAI,EAAGA,EAAI8E,EAAQC,EAAQ/E,IAChCqM,EAAMrM,GAAK4G,EAAO5G,EAE1B,CAEA,OAAO4G,CAAM,EAgGiBwF,CAFTzM,MAAMG,KAAK+L,EAAU7K,KAAI,CAACkI,EAAOE,IAAQiC,EAAKjC,KAAS8C,EAAgBhD,GAAS,OAEhD/E,EAAYC,EAAa,GAQxEsI,EAnGgBC,EAACN,EAAOvH,EAAOC,KACrC,MAAM6H,EAAW,GACXC,EAAU,IAAIlN,MAAMmF,EAAQC,GAAQnF,MAAK,GAEzCkN,EAAgBC,IAClB,MAAMN,EAAY,GACZnM,EAAIyM,EAAQjI,EACZzE,EAAIO,KAAKsD,MAAM6I,EAAQjI,GAE7B,IAAK,IAAI9E,EAAIY,KAAKiE,IAAI,EAAGvE,EAAI,GAAIN,GAAKY,KAAKgE,IAAIE,EAAQ,EAAGxE,EAAI,GAAIN,IAC9D,IAAK,IAAIC,EAAIW,KAAKiE,IAAI,EAAGxE,EAAI,GAAIJ,GAAKW,KAAKgE,IAAIG,EAAS,EAAG1E,EAAI,GAAIJ,IAAK,CACpE,MAAM+M,EAAgB/M,EAAI6E,EAAQ9E,EAClCyM,EAAUlM,KAAKyM,EACnB,CAGJ,OAAOP,CAAS,EAGdQ,EAAiBA,CAACC,EAAYC,KAChC,MAAMC,EAAQ,CAACF,GAEf,KAAOE,EAAMrN,OAAS,GAAG,CACrB,MAAMsN,EAAeD,EAAME,QAE3B,IAAKT,EAAQQ,KAA0C,MAAzBhB,EAAMgB,GAAyB,CACzDR,EAAQQ,IAAgB,EACxBF,EAAQ5M,KAAK8M,GAEb,MAAMZ,EAAYK,EAAaO,GAE/B,IAAK,MAAML,KAAiBP,EACnBI,EAAQG,KAA4C,MAA1BX,EAAMW,IACjCI,EAAM7M,KAAKyM,EAGvB,CACJ,GAGJ,IAAK,IAAIhN,EAAI,EAAGA,EAAI8E,EAAQC,EAAQ/E,IAChC,IAAK6M,EAAQ7M,KAAoB,MAAdqM,EAAMrM,GAAc,CACnC,MAAMuN,EAAa,GACnBN,EAAejN,EAAGuN,GAClBX,EAASrM,KAAKgN,EAClB,CAGJ,OAAOX,CAAQ,EAmDSD,CAAkBR,EAAuBhI,EAAYC,GAC7EsI,EAAgBc,MAAK,CAACC,EAAKC,IAAQA,EAAI3N,OAAS0N,EAAI1N,SAEpD,MAAM4N,EAA0BjB,EAAgB,GAAG1L,KAAIhB,IAAK,CAAGM,EAAGN,EAAImE,EAAY9D,EAAGO,KAAKsD,MAAMlE,EAAImE,OAGpG,IACI3C,EADMlC,EAAcqO,EAAyB,GACrCzM,QAKRwI,EAAOyC,EAAsBjM,QAAO,CAAC0E,EAAK+E,EAAKP,IAC9CA,EAAMjF,EAAaS,IAAe,KAAR+E,EAAeP,EAAMjF,EAAaS,GAAMiE,KACnEe,EAAOuC,EAAsBjM,QAAO,CAAC2E,EAAK8E,EAAKP,IAC9CA,EAAMjF,EAAaU,IAAe,KAAR8E,EAAeP,EAAMjF,EAAaU,IAAOgE,KAIxE,MAAM+E,EAAgB,GAChBC,GAAQjE,EAAOF,IAASS,EAAmB,GACjD,IAAK,IAAI7J,EAAIoJ,EAAMpJ,EAAIsJ,EAldT,IAkd2BtJ,GAAKuN,EAC1CD,EAAcrN,KAAK,CAACD,EAAGkB,EAAElB,KAK7B,MAAMwN,EAAYC,EAAAA,iBAAAA,wBACd7D,EAAS8D,GACT9D,EAAS+D,mBAGPC,EAActN,KAAKuN,MAAMvD,EAAWtG,GAAY,GAAK,EACrD8J,EAAuBR,EAAc5M,KAAIqN,GAAM/D,EAAUA,UAAUgE,aAAa,CAACD,EAAG,GAAIA,EAAG,GAAIH,MAE/FK,EAAwBT,EAAUU,gBAAgB,iBACxD7C,QAAQC,IAAI,aAAckC,EAAWS,GACrC,MAAME,EAAaF,EAAsBG,yBAAyBxE,EAASyE,QAASP,EAChF,UAAW,kBAGTQ,EAAwBxE,EAA2ByE,gBAAgB,WACpEC,kBAAkBvP,KAAK,GAAGqP,sBACzBG,EAAiB1E,EAAiB2E,kBAAkBJ,GACpDK,EAAoC,IACnCF,EACHN,WAAY,CACRS,IAAKT,EAAWU,cAChBC,QAASL,GAAgBN,aAAc,IAK/C,OAFApE,EAAiBgF,iBAAiBT,GAClCvE,EAAiBiF,kBAAkBV,EAAuBK,GACnDR,EAAWU,aAAa,EAK7BI,EAAkBvJ,MAAMkE,EAA0BC,GACpDqF,kBACAhI,mBACAC,sBAGA,MAAM,kBACFE,EAAiB,2BACjByC,EAA0B,sBAC1BqF,EAAqB,iBACrBpF,GACA5C,EAAgBI,SAGd6H,EAAetF,EAA2ByE,gBAAgB,WAAWC,kBAAkBvP,KAAK,GAC5FqP,EAAwBc,EAAad,sBACrCe,EAAaD,EAAaE,OAG1Bb,EAAiB1E,EAAiB2E,kBAAkBJ,GACtDG,EAAec,WAAW/K,OAC1BuF,EAAiByF,mBAGrB,MAAMxF,EAAYJ,EAASK,eAAeD,UACpCyF,EAAwB1F,EAAiB2F,kBAAkBpB,EAAuBtE,IAEjFnG,EAAYC,EAAaqG,GAAKkF,EAAWjF,WAC1CF,EAAamF,EAAWM,gBACxB3L,EAAW1D,KAAKsD,MAAMsG,EAAWG,WAAWzB,GAAUA,GAAS,MAAQ/E,EAAaC,GAEpFZ,EADW5C,KAAKsD,MAAMsG,EAAWK,eAAe3B,GAAUA,GAAS,MAAQ/E,EAAaC,GAAe,EACjFE,EAE5B,IAAIwG,EAAa,CAAC3G,WAAYA,EAAYC,YAAaA,EAAaG,UAAWJ,EAAaC,EAC1EE,SAAUA,EAAUd,SAAUA,GAEhD,MACMhC,EADiBlC,EAAcyQ,EAAuB,GACnC7O,QAInBwI,EAAOqG,EAAsB,GAAGzP,EAChCsJ,EAAOmG,EAAsB5F,EAAmB,GAAG7J,EAQzD,IAAI4P,EAAa,CAACvN,EAAoBiH,EAAMpI,EAAGgJ,EAAYM,IAIvDxK,EAAIsJ,EACR,KAAOtJ,EAAIoJ,GAAM,CACbpJ,GAAK0B,EAAiBR,EAAGlB,GAAG,GAAK,EAEjC,MAAMgD,EAAYX,EAAoBrC,EAAGkB,EAAGgJ,EAAYM,GACxDoF,EAAW3P,KAAK+C,EACpB,CACA,IAAI6M,EAAgB,GACpB,IAAK,IAAInQ,EAAI,EAAGA,EAAIY,KAAKsD,MAAMgM,EAAWnQ,OAAS,GAAIC,IAAK,CACxD,IAAIsD,EAAY4M,EAAW,EAAIlQ,GAC/B,MAAMoQ,EAAoBxP,KAAKsD,MAAMZ,EAAUwB,MAAQ,GACvD,IAAIuL,EAAe,IAAI9M,aAAa6M,EAAoB5M,GAAU5D,KAAK,GACvE,IAAK,IAAIK,EAAI,EAAGA,EAAImQ,EAAoB5M,EAAUvD,IAC9CoQ,EAAapQ,IAAMiQ,EAAW,EAAIlQ,GAAGsD,UAAU,EAAIrD,GACnDoQ,EAAapQ,IAAMiQ,EAAW,EAAIlQ,EAAI,GAAGsD,UAAU,EAAIrD,GACvDoQ,EAAapQ,IAAMiQ,EAAW,EAAIlQ,GAAGsD,UAAU,EAAIrD,EAAI,GACvDoQ,EAAapQ,IAAMiQ,EAAW,EAAIlQ,EAAI,GAAGsD,UAAU,EAAIrD,EAAI,GAC3DoQ,EAAapQ,GAAKW,KAAKsD,MAAMmM,EAAapQ,GAAK,GAEnDqD,EAAUA,UAAY+M,EACtB/M,EAAUwB,MAAQsL,EAClBD,EAAc5P,KAAK+C,EACvB,CACA4M,EAAaC,EACb,MAAMG,EAAiBJ,EAAWnQ,OAClC4L,QAAQC,IAAI,kBAAmB0E,GAC/BxF,EAA2B,eAAIwF,EAe/B,MAAMC,EA/VsBC,EAACN,EAAYO,EAAM3N,KAC/C,MAAM4N,EAAiB9P,KAAKsD,MAAMpB,EAAEwN,eAvPb,GAwPjBK,EAAgB/P,KAAKsD,MAAMpB,EAAEU,SAvPb,GAyPtB,IAAIoN,EACS,aAATH,IAEAG,EAAqB,IAAIrN,aAAaT,EAAEwN,eAAiBxN,EAAEU,UAC3D0M,EAAWW,SAAQ,CAACvN,EAAW8F,KAC3B,MAAM0H,EAAiBhI,EAAexF,EAAUA,UAAWR,GAC3D,IAAK,IAAIW,EAAQ,EAAGA,EAAQX,EAAEU,SAAUC,IACpCmN,EAAmBxH,EAAMtG,EAAEU,SAAWC,GAASqN,EAAerN,EAClE,KAIR,MAAM8M,EAAuB,IAAI5Q,MAAM+Q,EAAiBC,GAAe/Q,KAAK,MAC5E,IAAK,IAAII,EAAI,EAAGA,EAAI0Q,EAAgB1Q,IAAK,CACrC,MAAMoJ,EAxQa,EAwQcpJ,EAC3BsD,EAAY4M,EAAW9G,IACtB2H,EAAmBC,GAAqB1N,EAAU0B,UAClDiM,EAAmBC,GAAqB5N,EAAU2B,UACnDkM,EAASvQ,KAAKiE,IAAIuE,EAAMgI,GAAgC,GACxDC,EAASzQ,KAAKgE,IAAIwE,EAAMgI,GAAgCtO,EAAEwN,eAAiB,GAEjF,IAAIgB,EACJ,GAAa,YAATb,EACAa,EAAcxI,EAAexF,EAAUA,UAAWR,QAE/C,GAAa,aAAT2N,EAAqB,CAC5B,IAAIc,EAAmB,GACvB,IAAK,IAAItR,EAAIkR,EAAQlR,GAAKoR,EAAQpR,GAnRhB,EAoRdsR,EAAiBhR,KAAK2P,EAAWlQ,GAAGsD,WAExC,MAAMkO,EAAe,IAAIjO,aAAaD,EAAUvD,QAChD,IAAK,IAAIE,EAAI,EAAGA,EAAIqD,EAAUvD,OAAQE,IAClCuR,EAAavR,GAAKyI,EAAO6I,EAAiBvQ,KAAIyQ,GAAmBA,EAAgBxR,MAErFqR,EAAcxI,EAAe0I,EAAc1O,EAC/C,CAEA,IAAK,IAAIwG,EAAI,EAAGA,EAAIqH,EAAerH,IAAK,CACpC,MAAM7F,EA/RQ,EA+RoB6F,EAElC,IAAIoI,EACJ,GAAa,aAATjB,EAAqB,CACrB,IAAIkB,EAAmB,GACvB,IAAK,IAAI1R,EAAIkR,EAAQlR,GAAKoR,EAAQpR,GAnSpB,EAoSV0R,EAAiBpR,KAAKqQ,EAAmB3Q,EAAI6C,EAAEU,SAAWC,IAE9DiO,EAAkBC,EAAiBzR,QAAO,CAAC0R,EAAGC,IAAMD,EAAIC,GAAG,GAAKF,EAAiB5R,MACrF,MACI2R,EAAkBJ,EAAY7N,GAE9BiO,EAAkB,EAClBA,EAAkB,EACXA,EAAkBvO,IACzBuO,EAAkBvO,GAEtB,MAAM7C,EAAIM,KAAKsD,MAAM6M,EAAkB,GAAKW,EAAkBT,GACxD5Q,EAAIO,KAAKsD,MAAM6M,EAAkB,GAAKW,EAAkBR,GAE9DX,EAAqBjH,EAAIoH,EAAiB1Q,GAAK,CAACM,EAAGA,EAAGD,EAAGA,EAAGyR,KAAMJ,EACtE,CACJ,CAEA,OAAOnB,CAAoB,EA6REC,CAAwBN,EAAY,WAAYpF,GACvE4F,EAAiB9P,KAAKsD,MAAMoM,EAtlBX,GAulBD1P,KAAKsD,MAAMV,EAtlBX,GAuqBtB,IAAIuO,EAA4B,IAAIxO,aAAa+M,EAAiB9M,GAAU5D,MAAM,KAIlF,IAAK,IAAII,EAAI,EAAGA,EAAIsQ,EAAgBtQ,IAAK,CACrC,IAAIsD,EAAY4M,EAAWI,EAAiBtQ,EAAI,GAChD,MAAO+Q,EAAmBC,GAAqB1N,EAAU0B,UAClDiM,EAAmBC,GAAqB5N,EAAU2B,UAIzD,IAAK,IAAIxB,EAAQ,EAAGA,EAAQD,EAAUC,IAAS,CAE3C,MAAMuO,EAAUzB,EAAqB3P,KAAKsD,MAAMT,EAprBlC,GAorB+DiN,EAC3B9P,KAAKsD,MAAMlE,EAtrB9C,KAurBRM,EAAGD,EAAGyR,GAAQ,CAACE,EAAQ1R,EAAG0R,EAAQ3R,EAAG2R,EAAQF,MAGpD,IAAI5O,EAAW,CAAC5C,EAAI2R,GAA6BhB,EACjC5Q,EAAI4R,GAA6Bf,GAIjD,MAAMgB,EAAoB,GAG1B,IAAK,IAAIzS,EAAI,EAAGA,EAxBDwS,GAwBqBxS,IAAK,CAC1BmB,KAAKsD,MAAMhB,EAAS,GAAKzD,EAAIwR,GAC7BrQ,KAAKsD,MAAMhB,EAAS,GAAKzD,EAAIyR,GADxC,MAGMiB,EAAQ1S,EAAImB,KAAKsD,MAAM4N,EAAOM,MAC9BC,EAAc/O,EAAUA,UAAUG,EAAQN,EAAsBgP,GAChEG,EAAwB1R,KAAKsD,OAAOmO,EAAc,KAAQ,IAAM,IAOjE5I,MAAM6I,IACPJ,EAAkB3R,KAAK,EAAI,IAAOK,KAAK2R,IAAID,EAAuB,GAE1E,CAIA,IAAIE,EAAaN,EAAkBhS,QAAO,CAAC0R,EAAGC,IAAMD,EAAIC,GAAG,GAI3DE,EAA0BzB,GAAkB9M,EAAWC,EAAQ,GAAKzD,GAAwB,KAAlB,EAAIwS,GAAoB,GAAK,GAC3G,CACJ,CAEA,IAAIC,EAAqB,IAAI9S,MAAM2Q,EAAiB9M,GAAU5D,MAAM,KACpE,MAAM8S,ECtsBH,SAAuBpI,EAAWxF,EAAOC,GAC5C,MAAM4N,EAAkBrI,EAAUsI,QAE5BC,EAAQ,GACRC,EAAgBC,GAASnS,KAAKmJ,KAAKgJ,GAAQ,IAAYF,KAAW,EAAIjS,KAAKoS,GAAKH,EAAQA,IACvFI,EAAIC,EAAIC,GAAM,CAACL,EAAa,GAAIA,EAAa,GAAIA,EAAa,IAE/DM,EAAS,CACX,CAACD,EAAID,EAAIC,GACT,CAACD,EAAID,EAAIC,GACT,CAACC,EAAID,EAAIC,IAEPE,EAAgB,GAAKJ,EAAK,EAAIC,EAAK,EAAIC,GAEvCG,EAAaF,EAAOrT,OACpBwT,EAAiB3S,KAAKsD,MAAMoP,EAAa,GAE/C,IAAK,IAAIjT,EAAIkT,EAAgBlT,EAAI0E,EAASwO,EAAgBlT,IACtD,IAAK,IAAIC,EAAIiT,EAAgBjT,EAAIwE,EAAQyO,EAAgBjT,IAAK,CAC1D,IAAIH,EAAM,EACV,IAAK,IAAIqT,EAAK,EAAGA,EAAKF,EAAYE,IAC9B,IAAK,IAAIC,EAAK,EAAGA,EAAKH,EAAYG,IAM9BtT,GAAOmK,GAJQjK,EAAImT,EAAKD,GACDzO,GAFRxE,EAAImT,EAAKF,IAKEH,EAAOI,GAAIC,GAK7CtT,GAAOkT,EAGPV,EAAgBtS,EAAIyE,EAAQxE,GAAKH,CACrC,CAGJ,OAAOwS,CACX,CD8pBmBe,CAAc3B,EAA2BzB,EAAgB9M,GAExE,IAAK,IAAIxD,EAAI,EAAGA,EAAIsQ,EAAiB9M,EAAUxD,IAAK,CAChD,MAAM2T,EAAS5B,EAA0B/R,GACnC4T,EAAUlB,EAAO1S,GACjB6T,EAAQ,GACdpB,EAAmBzS,GAAK6T,EAAQF,GAAU,EAAIE,IAAUF,EAASC,EACrE,CAyCA,IAAIE,EAAqB/B,EAIzB,MAAM3L,EAAUiE,EAAiB0J,YAAYnF,GACvCoF,EAAeC,EAAAA,SAAAA,IAAa,eAAgB7N,GAC5C8N,EAAmBD,EAAAA,SAAAA,IAAa,mBAAoB7N,GACpD+N,EAAsBF,EAAAA,SAAAA,IAAa,sBAAuB7N,GAEhE,IAAKgE,EAA2BgK,uBAAuB,WAOnD,YANA3E,EAAsB4E,KAAK,CACvBC,MAAO,6BACPC,QAAS,wBACTC,KAAM,QACNC,SAAU,MAIlB,MAAMC,EAAoB,CACtB3N,kBAAmBoN,EAAoBQ,kBAAoB,aAC3D7N,iBAAkBqN,EAAoBS,iBACtCC,cAAeX,EAAiBY,cAChCC,WAAYb,EAAiBc,WAC7BC,KAAMzR,EACN0R,QAAS5E,EACT6E,aAAcnB,EAAaoB,aAAa,GACxCC,YAAarB,EAAasB,YAAY,GACtCC,UAAWzB,GAET0B,OArtBiBxP,OAAMyP,GAAYjO,mBAAkBC,sBAC3D,MAAM9B,EAAiB,CACnB+P,gBAAiB,CACb3O,kBAAmB0O,EAAS1O,kBAC5BD,iBAAkB2O,EAAS3O,mBAG7B6O,QAAeC,EAAAA,EAAAA,GAAeH,GAC9B/P,GAASmQ,EAAAA,EAAAA,GAAYF,GACrBnP,QAAgBf,EAAcC,EAAQC,GACtC2B,EAAW,IAAI3H,MAAM8V,EAASP,SAAStV,KAAK4G,GAC5CkB,EAAoB9G,KAAK0B,MAAMmT,EAASP,QAAU,GAExD,aAD2B7N,EAAmBC,EAAU,QAAS,CAAEE,mBAAkBC,mBAAmBC,EACrF,EAwsBiBoO,CAAmBpB,EAAmB,CAAElN,mBAAkBC,oBAExFsO,EAAkB,CACpBhP,kBAAmBoN,EAAoBQ,kBAAoB,aAC3D7N,iBAAkBqN,EAAoBS,iBACtCC,cAAeX,EAAiBY,cAChCC,WAAYb,EAAiBc,WAC7BC,KAAMzR,EACN0R,QAAS/R,EACTgS,aAAcnB,EAAaoB,aAAa,GACxCC,YAAarB,EAAasB,YAAY,GACtCC,UAAWrF,EAAWlP,KAAIsC,GAAaA,EAAUA,aAG/C0S,OAtwB0BhQ,OAAMyP,GAAYjO,mBAAkBC,sBACpE,MAAMwO,EACc,CACZlP,kBAAmB0O,EAAS1O,kBAC5BD,iBAAkB2O,EAAS3O,iBAC3BE,eAAgBpG,KAAKsV,SAASC,SAAS,IAAIC,UAAU,EAAG,IACxDC,oBAAqBzV,KAAKsV,SAASC,SAAS,IAAIC,UAAU,EAAG,KAG/DE,EAAUb,EAASF,UAAUxV,OAC7B2H,EAAoB9G,KAAK0B,MAAMgU,EAAU,GAEzChP,QAAiB1B,QAAQ2Q,IAC3Bd,EAASF,UAAUvU,KAAIgF,MAAMwQ,EAAWC,KACpC,MAAMC,EAAsB,GAAGT,EAAwBjP,kBAAkByP,EAAS,IAC5E9Q,EAAiB,CACnB+P,gBAAiB,IACVO,EACHjP,eAAgB0P,EAChBtP,eAAgBqP,EAAS,EACzBE,qBAAsB,CAAE,EAAG,EAAG,GAAMF,KAItCd,QAAeC,EAAAA,EAAAA,GAAe,IAAKH,EAAUF,UAAWiB,IAAa,GACrE9Q,GAASmQ,EAAAA,EAAAA,GAAYF,GAG3B,aAFsBlQ,EAAcC,EAAQC,EAE9B,KAItB,aAD2B0B,EAAmBC,EAAU,SAAU,CAAEE,mBAAkBC,mBAAmBC,EACtF,EAsuBkBkP,CAA4Bb,EAAiB,CAAEvO,mBAAkBC,oBAEhGwH,EAAoC,CACtCR,WAAYM,EAAeN,WAC3BoI,sBAAuBb,EACvBR,sBAAuBA,EACvB3F,UAAW,CACP/K,MAAOwL,EACPvL,OAAQvB,GAEZ0M,WAAYA,GAEhB7F,EAAiBiF,kBAAkBV,EAAuBK,EAAkB,C,2CE92BhF,MAAM6H,EAAQ1R,EAAQ,OAEhBwQ,EAAiBA,CAACH,EAAUsB,GAAW,EAAOC,GAAa,KAC7D,MAAM,cACFnC,EAAa,WACbE,EACAE,KAAMgC,EACN/B,QAASgC,EACT/B,aAAcC,EACdC,YAAaC,EACbC,UAAW4B,GACX1B,EAGE2B,EAA+B,KAAlBvC,EAAuB,IAAIwC,WAAWF,GAAa,IAAIG,UAAUH,GAG9EI,EAAMT,EAAM,CAACG,EAAMC,IAGnBM,EAAeR,GAAgB5B,GAAgBE,EAC/CmC,EAAYrC,EAAe,IAAOE,EAAc,GAAK,EACrDoC,EAAYtC,EAAe,IAAOE,EAAc,GAAK,EAErDqC,EAAuBhO,IACzB,IAAIiO,EAAmBjO,EAcvB,OAZI6N,EAEII,EADAjO,GAAO8N,EACY,EACZ9N,EAAM+N,EACM,OAE8D,MAAzD/N,GAAOyL,EAAe,MAASE,EAAc,GAAK,KAErD,KAAlBT,IACP+C,EAAmC,KAAdjO,EAAM,KAAkB,GAAKoL,GAG/C6C,CAAgB,EAI3B,IAAK,IAAI5X,EAAI,EAAGA,EAAIiX,EAAMjX,IAAK,CAC3B,MAAM6X,EAAWd,EAAaE,EAAOjX,EAAI,EAAIA,EAC7C,IAAK,IAAIC,EAAI,EAAGA,EAAIiX,EAASjX,IAAK,CAC9B,MAAM0J,EAAMgO,EAAoBP,EAAWpX,EAAIkX,EAAUjX,IACzDsX,EAAIO,IAAID,EAAU5X,EAAG0J,EACzB,CACJ,CAEA,MAAO,CACHoO,OAAQR,EACRxS,OAAQkS,EACRnS,MAAOoS,EACPc,IAAK,MACR,EAGCnC,EAAeF,IACjB,MAAMsC,EAAgB,IAAIC,kBAAkBvC,EAAO7Q,MAAQ6Q,EAAO5Q,OAAS,GAC5D4Q,EAAOoC,OAAOxY,KACtBsR,SAAQ,CAAC/N,EAAG9C,KACfiY,EAAc,EAAIjY,GAAK8C,EACvBmV,EAAc,EAAIjY,EAAI,GAAK8C,EAC3BmV,EAAc,EAAIjY,EAAI,GAAK8C,EAC3BmV,EAAc,EAAIjY,EAAI,GAAK,GAAG,IAGlC,MAAM0F,EAASyS,SAASC,cAAc,UACtC1S,EAAOZ,MAAQ6Q,EAAO7Q,MACtBY,EAAOX,OAAS4Q,EAAO5Q,OACvB,MAAMsT,EAAU,IAAIC,UAAU,IAAIJ,kBAAkBD,GAAgBtC,EAAO7Q,MAAO6Q,EAAO5Q,QAGzF,OAFAW,EAAO6S,WAAW,MAAMC,aAAaH,EAAS,EAAG,GAE1C3S,CAAM,C","sources":["webpack:///../../../extensions/default/src/Panels/PanoramicUtils/computeDentalCurveUtils.js","webpack:///../../../extensions/default/src/Panels/PanoramicUtils/computeDentascansUtils.ts","webpack:///../../../extensions/default/src/Panels/PanoramicUtils/generatePanoramic.ts","webpack:///../../../extensions/default/src/Panels/PanoramicUtils/computePanoramicUtils.js","webpack:///../../../extensions/default/src/Panels/PanoramicUtils/pngUtils.js"],"sourcesContent":["const DEFAULT_OPTIONS = { order: 2, period: null };\n\n/**\n * Determine the coefficient of determination (r^2) of a fit from the observations\n * and predictions.\n *\n * @param {Array<Array<number>>} data - Pairs of observed x-y values\n * @param {Array<Array<number>>} results - Pairs of observed predicted x-y values\n *\n * @return {number} - The r^2 value, or NaN if one cannot be calculated.\n */\nfunction determinationCoefficient(data, results) {\n    const predictions = [];\n    const observations = [];\n\n    data.forEach((d, i) => {\n        if (d[1] !== null) {\n            observations.push(d);\n            predictions.push(results[i]);\n        }\n    });\n\n    const sum = observations.reduce((a, observation) => a + observation[1], 0);\n    const mean = sum / observations.length;\n\n    const ssyy = observations.reduce((a, observation) => {\n        const difference = observation[1] - mean;\n        return a + (difference * difference);\n    }, 0);\n\n    const sse = observations.reduce((accum, observation, index) => {\n        const prediction = predictions[index];\n        const residual = observation[1] - prediction[1];\n        return accum + (residual * residual);\n    }, 0);\n\n    return 1 - (sse / ssyy);\n}\n\n/**\n * Determine the solution of a system of linear equations A * x = b using\n * Gaussian elimination.\n *\n * @param {Array<Array<number>>} matrix - A 2-d matrix of data in row-major form [ A | b ]\n * @param {number} order - How many degrees to solve for\n *\n * @return {Array<number>} - Vector of normalized solution coefficients matrix (x)\n */\nfunction gaussianElimination(matrix, order) {\n    const n = matrix.length - 1;\n    const coefficients = Array(order);\n\n    for (let i = 0; i < n; i++) {\n        let maxRow = i;\n        // Find the pivot row\n        for (let j = i + 1; j < n; j++) {\n            if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][maxRow])) {\n                maxRow = j;\n            }\n        }\n\n        // Swap rows\n        for (let k = i; k <= n; k++) {\n            [matrix[k][i], matrix[k][maxRow]] = [matrix[k][maxRow], matrix[k][i]];\n        }\n\n        // Make upper triangular\n        for (let j = i + 1; j < n; j++) {\n            for (let k = n; k >= i; k--) {\n                // TODO divide by zero\n                matrix[k][j] -= (matrix[k][i] * matrix[i][j]) / matrix[i][i];\n            }\n        }\n    }\n\n    // Backward substitution\n    for (let j = n - 1; j >= 0; j--) {\n        let total = 0;\n        for (let k = j + 1; k < n; k++) {\n            total += matrix[k][j] * coefficients[k];\n        }\n\n        coefficients[j] = (matrix[n][j] - total) / matrix[j][j];\n    }\n\n    return coefficients;\n}\n\n/**\n * Round a number to a precision, specificed in number of decimal places\n *\n * @param {number} number - The number to round\n * @param {number} precision - The number of decimal places to round to:\n *                             > 0 means decimals, < 0 means powers of 10\n *\n *\n * @return {number} - The number, rounded\n */\nfunction round(number, precision) {\n    const factor = 10 ** precision;\n    return Math.round(number * factor) / factor;\n}\n\n/**\n * The set of all fitting methods\n *\n * @namespace\n */\nexport const polynomialLSF = (data, order) => {\n    const k = order + 1;\n\n    // Initialize matrices for lhs and rhs\n    const lhs = Array(k).fill(0);\n    const rhs = Array.from({ length: k }, () => Array(k).fill(0));\n\n    // Build the lhs and rhs matrices\n    for (let i = 0; i < k; i++) {\n        for (let j = 0; j < k; j++) {\n            rhs[i][j] = data.reduce((sum, point) => point.y !== null ? sum + point.x ** (i + j) : sum, 0);\n        }\n        lhs[i] = data.reduce((sum, point) => point.y !== null ? sum + (point.x ** i) * point.y : sum, 0);\n    }\n\n    rhs.push(lhs);\n\n    // Calculate coefficients using Gaussian elimination\n    const coefficients = gaussianElimination(rhs, k).map(v => v);\n\n    // Define prediction function\n    const predict = (x) => coefficients.reduce((sum, coeff, power) => sum + (coeff * x ** power), 0);\n\n    return {\n        predict,\n        equation: [...coefficients].reverse(),\n    };\n};\n","import {ImageVolume} from '@cornerstonejs/core'\nimport { Dentascan } from 'extensions/cornerstone/src/types/Panoramic';\n\nconst DENTASCAN_THICKNESS = 70;\n\nconst derivative = (f, x, dx = 1e-5) => {\n    return (f(x + dx) - f(x)) / dx;\n}\n\nconst getSlopeVector = (slope) => {\n    const [vx, vy] = [1, slope];\n    const vLength = Math.sqrt(1 + slope * slope);\n    return [vx / vLength, vy / vLength];\n}\n\nexport const getTangentVector = (f, x) => {\n    const tangentSlope = derivative(f, x);\n    return getSlopeVector(tangentSlope);\n}\n\nexport const getNormalVector = (f, x) => {\n    const tangentSlope = derivative(f, x);\n    const normalSlope = -1 / tangentSlope;\n    return getSlopeVector(normalSlope);\n}\n\nconst interpolatePoints = (v1, v2, t) => {\n    return Math.round(t * v1 + (1 - t) * v2);\n}\n\nconst interpolateThreePoints = (v1, v2, vMid, tMin, tMax) => {\n    return Math.round(tMin * v1 + (tMax - tMin) * vMid + (1 - tMax) * v2);\n}\n\n// Get dentascan section at abscissa i for a polynomial fitting curve lsf.\n// Length of normal is dentascanThickness\n// Dicom of the dentascan desired is defined by its dicomDimensions and its scalarData\nexport const getDentascanSection = (x, lsfDentalCurve, dicomData, p) => {\n    // Get normalized vector of normal at x\n    let [vxNormal, vyNormal] = getNormalVector(lsfDentalCurve, x);\n\n    // In order to prevent having a flipped normal vector,\n    // we need to determine if minPoint lies inside or outside the curve\n    // We want minPoint to be the outer point and maxPoint to be the inner point\n    const y = lsfDentalCurve(x);\n    let minPoint: [number, number] = [x - DENTASCAN_THICKNESS / 2 * vxNormal,\n                                      y - DENTASCAN_THICKNESS / 2 * vyNormal];\n    let maxPoint: [number, number] = [x + DENTASCAN_THICKNESS / 2 * vxNormal,\n                                      y + DENTASCAN_THICKNESS / 2 * vyNormal];\n    // Swap minPoint and maxPoint and invert normal vectors if minPoint is inner\n    if (minPoint[1] >= lsfDentalCurve(minPoint[0])) {\n        [minPoint, maxPoint] = [maxPoint, minPoint];\n        [vxNormal, vyNormal] = [-vxNormal, -vyNormal];\n    }\n\n    // Get values of point along normal between min and max\n    const dentascanWidth = 2 * DENTASCAN_THICKNESS; // Anti-Aliasing\n    const dentascan = new Float32Array(dentascanWidth * p.nbLayers).fill(-1000);\n    for (let layer = 0; layer < p.nbLayers; layer++) {\n        for (let i = 0; i < dentascanWidth; i += 1) {\n            const xi = minPoint[0] + (i / 2) * vxNormal;\n            const yi = minPoint[1] + (i / 2) * vyNormal;\n            const xj = minPoint[0] + ((i + 1) / 2) * vxNormal;\n            const yj = minPoint[1] + ((i + 1) / 2) * vyNormal;\n            const [pxi, pxj, pyi, pyj] = [Math.floor(xi), Math.floor(xj), Math.floor(yi), Math.floor(yj)]\n            if (xi >= 0 && yi >= 0 && xj < p.layerWidth && yj < p.layerHeight) {\n                const dicomIdxI = (p.minLayer + layer) * p.layerSize + pyi * p.layerWidth + pxi;\n                if (pxi === pxj && pyi === pyj) {\n                    // Same pixel\n                    dentascan[layer * dentascanWidth + i] = dicomData[dicomIdxI];\n                } else if (pyi === pyj) {\n                    // Horizontal interpolation\n                    const tx = (pxi < pxj) ? (1 - xi % 1) / vxNormal : -(xi % 1) / vxNormal; // Ratio of segment within pxi\n                    const dicomIdxJ = (p.minLayer + layer) * p.layerSize + pyi * p.layerWidth + pxj;\n                    dentascan[layer * dentascanWidth + i] = interpolatePoints(dicomData[dicomIdxI], dicomData[dicomIdxJ], tx);\n                } else if (pxi === pxj) {\n                    // Vertical interpolation\n                    const ty = (pyi < pyj) ? (1 - yi % 1) / vyNormal : -(yi % 1) / vyNormal; // Ratio of segment within pyi\n                    const dicomIdxJ = (p.minLayer + layer) * p.layerSize + pyj * p.layerWidth + pxi;\n                    dentascan[layer * dentascanWidth + i] = interpolatePoints(dicomData[dicomIdxI], dicomData[dicomIdxJ], ty);\n                } else {\n                    // Diagonal interpolation\n                    const tx = (pxi < pxj) ? (1 - xi % 1) / vxNormal : -(xi % 1) / vxNormal;\n                    const ty = (pyi < pyj) ? (1 - yi % 1) / vyNormal : -(yi % 1) / vyNormal;\n                    const dicomIdxJ = (p.minLayer + layer) * p.layerSize + pyj * p.layerWidth + pxj;\n                    const dicomIdxK = tx < ty\n                        ? (p.minLayer + layer) * p.layerSize + pyi * p.layerWidth + pxj\n                        : (p.minLayer + layer) * p.layerSize + pyj * p.layerWidth + pxi;\n                    const tMin = Math.min(tx, ty);\n                    const tMax = Math.max(tx, ty);\n                    dentascan[layer * dentascanWidth + i] = interpolateThreePoints(dicomData[dicomIdxI], dicomData[dicomIdxJ],\n                                                                                   dicomData[dicomIdxK], tMin, tMax);\n                }\n            }\n        }\n    }\n\n    const dentascanObject: Dentascan = {\n        dentascan: dentascan,\n        width: dentascanWidth,\n        height: p.nbLayers,\n        interval: [minPoint, maxPoint],\n        direction: [vxNormal, vyNormal],\n        middlePoint: [x, y],\n        minLayer: p.minLayer,\n    };\n\n    return dentascanObject;\n}","import {DicomMetadataStore, OHIF} from '@ohif/core';\nimport {ToolGroupManager} from '@cornerstonejs/tools';\nimport {applySmoothing, blurPanoramic, cubicSplineInterpolation, sharpen} from './computePanoramicUtils.js'\nimport FileLoaderService from '../../../../../platform/app/src/routes/Local/fileLoaderService.js'\nimport {dcmbufferToPng, pngToCanvas} from './pngUtils.js'\nimport {polynomialLSF} from './computeDentalCurveUtils.js'\nimport {PanoramicState} from '../../../../cornerstone/src/types/Panoramic'\nimport {metaData, VolumeViewport} from '@cornerstonejs/core'\nimport {getTangentVector, getDentascanSection} from './computeDentascansUtils'\n\nconst skmeans = require('skmeans');\nconst metadataProvider = OHIF.classes.MetadataProvider;\n\ninterface BASE_POINT {\n    pointA: number[];\n    pointB: number[];\n    vectordirection: number[];\n    computeDentalCurve: boolean;\n}\n\nfunction waitCondition(condition) {\n    return new Promise((resolve, reject) => {\n        const wait = () => {\n            const result = condition();\n            if (result) {\n                return resolve(result);\n            } else {\n                setTimeout(() => wait(), 50);\n            }\n        }\n        wait();\n    });\n}\n\n// TODO: These should be a function parameter\nconst DENTASCAN_THICKNESS = 70;\nconst DENTAL_CURVE_THICKNESS = 40;\nconst DENTASCAN_THRESHOLD_VALUE = 1100\nconst AIP_THRESHOLD_VALUE = 70;\nconst TOLERANCE = 0.01;\nconst DENTAL_CURVES_STEP = 1;\nconst AXIAL_CURVES_STEP = 1;\nconst DENTAL_CURVE_AIP_STEP = 2;\nconst DENTAL_CURVE_AIP_THICKNESS = 40;\n\nconst createDataset = (canvas, datasetOptions) => {\n    return new Promise((resolve, reject) => {\n        canvas.toBlob(async(blob) => {\n            const fileLoaderService = new FileLoaderService(blob);\n            const imageId = fileLoaderService.addFile(blob);\n            const img = await fileLoaderService.loadFile(blob, imageId);\n            const dataset = await fileLoaderService.getDataset(img, imageId, datasetOptions);\n            await waitCondition(() => dataset.imageId);\n\n            const { StudyInstanceUID, SeriesInstanceUID, SOPInstanceUID } = dataset;\n            metadataProvider.addImageIdToUIDs(imageId, {\n                StudyInstanceUID,\n                SeriesInstanceUID,\n                SOPInstanceUID,\n                frameIndex: dataset.NumberOfFrames > 1 ? dataset.InstanceNumber : 1,\n            });\n            resolve(dataset);\n        });\n    });\n}\n\nconst createViewportData = async(datasets, viewportType, { extensionManager, servicesManager }, initialImageIndex?) => {\n    const { displaySetService, cornerstoneCacheService } = servicesManager.services;\n\n    DicomMetadataStore.addInstances(datasets);\n    const activeDisplaySets = displaySetService.getActiveDisplaySets();\n    const displaySetAdded = [activeDisplaySets[activeDisplaySets.length - 1]];\n    const viewportOptions = {\n        toolGroupId: 'mpr',\n        viewportType: viewportType,\n        orientation: 'axial',\n        initialImageOptions: {\n            preset: 'middle',\n        },\n    };\n    const dataSource = extensionManager.getDataSources()[0];\n\n    const viewportData = await cornerstoneCacheService.createViewportData(\n        displaySetAdded,\n        viewportOptions,\n        dataSource,\n        initialImageIndex\n    );\n\n    return viewportData;\n}\n\nconst loadMultipleBlobsInViewport = async(metadata, { extensionManager, servicesManager }) => {\n    const options = {\n        prefilledValues:{\n            SeriesInstanceUID: metadata.SeriesInstanceUID,\n            StudyInstanceUID: metadata.StudyInstanceUID,\n            SOPInstanceUID: Math.random().toString(36).substring(2, 10),\n            FrameOfReferenceUID: Math.random().toString(36).substring(2, 10)\n        }\n    };\n    const nbBlobs = metadata.PixelData.length;\n    const initialImageIndex = Math.round(nbBlobs / 2);\n\n    const datasets = await Promise.all(\n        metadata.PixelData.map(async(layerData, layerI) => {\n            const layerSopInstanceUID = `${options.prefilledValues.SOPInstanceUID}.${layerI + 1}`;\n            const datasetOptions = {\n                prefilledValues: {\n                    ...options.prefilledValues,\n                    SOPInstanceUID: layerSopInstanceUID,\n                    InstanceNumber: layerI + 1,\n                    ImagePositionPatient: [ 0, 0, 0.4 * layerI]\n                }\n            };\n\n            const pngBuf = await dcmbufferToPng({ ...metadata, PixelData: layerData }, true);\n            const canvas = pngToCanvas(pngBuf);\n            const dataset = await createDataset(canvas, datasetOptions);\n\n            return dataset;\n        })\n    );\n    const viewportData = await createViewportData(datasets, 'volume', { extensionManager, servicesManager }, initialImageIndex);\n    return viewportData;\n}\n\nconst loadBlobInViewport = async(metadata, { extensionManager, servicesManager }) => {\n    const datasetOptions = {\n        prefilledValues: {\n            SeriesInstanceUID: metadata.SeriesInstanceUID,\n            StudyInstanceUID: metadata.StudyInstanceUID\n        }\n    }\n    const pngBuf = await dcmbufferToPng(metadata);\n    const canvas = pngToCanvas(pngBuf);\n    const dataset = await createDataset(canvas, datasetOptions);\n    const datasets = new Array(metadata.Columns).fill(dataset);\n    const initialImageIndex = Math.round(metadata.Columns / 2);\n    const viewportData = await createViewportData(datasets, 'stack', { extensionManager, servicesManager }, initialImageIndex);\n    return viewportData;\n}\n\n//____________________________ FOR PANORAMIC COMPUTATION _________________________//\n\nconst getMax = (arr) => {\n    let len = arr.length;\n    let max = -Infinity;\n\n    while (len--) {\n        max = arr[len] > max ? arr[len] : max;\n    }\n    return max;\n}\n\n// Width becomes height, and height becomes width\nconst transposeImage = (arr, width, height) => {\n    const transposedArr = [];\n    for (let i = 0; i < width; i++) {\n        for (let j = 0; j < height; j++) {\n            transposedArr.push(arr[j * width + i]);\n        }\n    }\n    return transposedArr;\n}\n\n// Returns the scalar data projected on the sagittal axis, using the max of values along X axis\nconst getSagittalDataMax = (scalarData, p) => {\n    const sagittalData = new Float32Array(p.layerHeight * p.nbLayers);\n    // Iterate over Y and Z axes\n    for (let k = 0; k < p.nbLayers; k++) {\n        for (let j = 0; j < p.layerHeight; j++) {\n            // Store max value along axis in sagittalData\n            let maxVal = -Infinity;\n            for (let i = 0; i < p.layerWidth; i++) {\n                const value = scalarData[(k + p.minLayer) * p.layerSize + j * p.layerWidth + i];\n                if (value > maxVal) {\n                    maxVal = value;\n                }\n            }\n            sagittalData[k * p.layerHeight + j] = maxVal;\n        }\n    }\n\n    return sagittalData;\n}\n\n// Returns the scalar data projected on the coronal axis, using the max of values along X axis\nconst getCoronalDataMax = (scalarData, p) => {\n    const coronalData = new Float32Array(p.layerWidth * p.nbLayers);\n    // Iterate over Y and Z axes\n    for (let k = 0; k < p.nbLayers; k++) {\n        for (let j = 0; j < p.layerWidth; j++) {\n            // Store max value along axis in coronalData\n            let maxVal = -Infinity;\n            for (let i = 0; i < p.layerHeight; i++) {\n                const value = scalarData[(k + p.minLayer) * p.layerSize + j * p.layerHeight + i];\n                if (value > maxVal) {\n                    maxVal = value;\n                }\n            }\n            coronalData[k * p.layerHeight + j] = maxVal;\n        }\n    }\n\n    return coronalData;\n}\n\n// Returns the scalar data projected on the axial axis,\n// using the mean values along Z axis between minLayer and maxLayer\nconst getAxialDataMean = (scalarData, minLayer, maxLayer, p) => {\n    const nbToothLayers = maxLayer - minLayer;\n\n    const axialData = new Float32Array(p.layerWidth * p.layerHeight);\n    // Iterate over X and Y axes\n    for (let i = 0; i < p.layerWidth; i++) {\n        for (let j = 0; j < p.layerHeight; j++) {\n            // Store average value along axis in axialData\n            let sumVal = 0;\n            for (let k = 0; k < nbToothLayers; k++) {\n                sumVal += scalarData[(minLayer + k) * p.layerSize + j * p.layerWidth + i];\n            }\n            axialData[j * p.layerWidth + i] = sumVal / nbToothLayers;\n        }\n    }\n\n    return axialData;\n}\n\n// I want to ensure that the polynomial does not diverge beyond the teeth zone.\n// The goal is to smooth out and converge the polynomial on the center outside the given interval while\n// preserving its original behavior within the interval [minX, maxX].\n// To achieve this, I use a modified function incorporating two sigmoid functions.\nconst getDentalLiss = (f, minX, maxX) => {\n    const dentascanWidth = DENTASCAN_THICKNESS;\n    // a1 and a2 are smoothing parameters.\n    const a1 = 0.1;\n    const a2 = 0.1;\n    // c0 is the convergence on -inf, and c1 and +inf\n    const c0 = dentascanWidth / 2;\n    const c1 = dentascanWidth / 2;\n\n    return (layer) => {\n        const sigmoidLeft = 1 / (1 + Math.exp(-a1 * (layer - minX)));\n        const sigmoidRight = 1 / (1 + Math.exp(a2 * (layer - maxX)));\n        const originalDentalValue = f(layer);\n\n        return originalDentalValue * sigmoidLeft * sigmoidRight\n            + c0 * (1 - sigmoidLeft) + c1 * (1 - sigmoidRight);\n    }\n}\n\nconst getDentalCurve = (dentascan, p) => {\n    const dentascanWidth = DENTASCAN_THICKNESS;\n\n    // Compute dental curve\n    // Dentascan is thresholded to get only bone area\n    const binarizedDentascan = dentascan.map(value => value > DENTASCAN_THRESHOLD_VALUE ? value : -1000)\n    // Transposed so that w => h and h => w. This allows us to LSF with a curve represented by an order 3 equation\n    const transposedBin = transposeImage(binarizedDentascan, dentascanWidth, p.nbLayers)\n    // Get the indexes of teeth zone and keep only indexes that are teeth (!= -1000)\n    let transposedOnlyTeethIndex = Array.from(transposedBin).map((value, idx) => value === -1000 ? null\n        : ({ x: idx % p.nbLayers, y: Math.floor(idx / p.nbLayers) })).filter(value => value);\n\n    // Add points along the center of the dentascan to reduce the deformation of the curve\n    for (let l = 0; l < p.nbLayers; l += 10) {\n        transposedOnlyTeethIndex.push({x: l, y: DENTASCAN_THICKNESS / 2});\n    }\n\n    // Curve fitting on a degree 3 polynomial\n    let lsfDentalCurve = polynomialLSF(transposedOnlyTeethIndex, 3);\n    // TODO order should depend on error for the curve fitting\n\n    let lsfDentalLiss = (x) => DENTASCAN_THICKNESS / 2;\n    if (getMax(transposedBin) > -1000 && !lsfDentalCurve.equation.some((value) => isNaN(value))) {\n        // minX and maxX where value is not -1000\n        const minX = transposedBin.reduce((min, val, idx) =>\n            ((idx % p.nbLayers < min && val != -1000) ? idx % p.nbLayers : min), Infinity);\n        const maxX = transposedBin.reduce((max, val, idx) =>\n            ((idx % p.nbLayers > max && val != -1000) ? idx % p.nbLayers : max), -Infinity);\n        lsfDentalLiss = getDentalLiss(lsfDentalCurve.predict, minX, maxX);\n    }\n\n    return lsfDentalLiss;\n}\n\nconst getDentalCurvesPointsXY = (dentascans, mode, p) => {\n    const nbDentalCurves = Math.floor(p.panoramicWidth / DENTAL_CURVES_STEP);\n    const nbAxialCurves = Math.floor(p.nbLayers / AXIAL_CURVES_STEP);\n\n    let dentalCurvesPoints;\n    if (mode === 'curveAIP') {\n        // Precompute the values\n        dentalCurvesPoints = new Float32Array(p.panoramicWidth * p.nbLayers);\n        dentascans.forEach((dentascan, idx) => {\n            const dentascanCurve = getDentalCurve(dentascan.dentascan, p);\n            for (let layer = 0; layer < p.nbLayers; layer++) {\n                dentalCurvesPoints[idx * p.nbLayers + layer] = dentascanCurve(layer);\n            }\n        });\n    }\n\n    const dentalCurvesPointsXY = new Array(nbDentalCurves * nbAxialCurves).fill(null);\n    for (let i = 0; i < nbDentalCurves; i++) {\n        const idx = DENTAL_CURVES_STEP * i;\n        const dentascan = dentascans[idx];\n        const [dentascanMinPoint, dentascanMaxPoint] = dentascan.interval;\n        const [dentascanVxNormal, dentascanVyNormal] = dentascan.direction;\n        const idxInf = Math.max(idx - DENTAL_CURVE_AIP_THICKNESS / 2, 0);\n        const idxSup = Math.min(idx + DENTAL_CURVE_AIP_THICKNESS / 2, p.panoramicWidth - 1);\n\n        let dentalCurve;\n        if (mode === 'default') {\n            dentalCurve = getDentalCurve(dentascan.dentascan, p);\n\n        } else if (mode === 'valueMIP') {\n            let dentascansForMIP = [];\n            for (let j = idxInf; j <= idxSup; j += DENTAL_CURVE_AIP_STEP) {\n                dentascansForMIP.push(dentascans[i].dentascan);\n            }\n            const dentascanMIP = new Float32Array(dentascan.length);\n            for (let j = 0; j < dentascan.length; j++) {\n                dentascanMIP[j] = getMax(dentascansForMIP.map(dentascanScalar => dentascanScalar[j]));\n            }\n            dentalCurve = getDentalCurve(dentascanMIP, p);\n        }\n\n        for (let l = 0; l < nbAxialCurves; l++) {\n            const layer = AXIAL_CURVES_STEP * l;\n\n            let xPosInDentascan;\n            if (mode === 'curveAIP') {\n                let xPosInDentascans = [];\n                for (let j = idxInf; j <= idxSup; j += DENTAL_CURVE_AIP_STEP) {\n                    xPosInDentascans.push(dentalCurvesPoints[j * p.nbLayers + layer]);\n                }\n                xPosInDentascan = xPosInDentascans.reduce((a, b) => a + b, 0) / xPosInDentascans.length;\n            } else { // default or valueMIP\n                xPosInDentascan = dentalCurve(layer);\n            }\n            if (xPosInDentascan < 0) {\n                xPosInDentascan = 0;\n            } else if (xPosInDentascan > DENTASCAN_THICKNESS) {\n                xPosInDentascan = DENTASCAN_THICKNESS;\n            }\n            const x = Math.floor(dentascanMinPoint[0] + xPosInDentascan * dentascanVxNormal);\n            const y = Math.floor(dentascanMinPoint[1] + xPosInDentascan * dentascanVyNormal);\n\n            dentalCurvesPointsXY[l * nbDentalCurves + i] = {x: x, y: y, xpos: xPosInDentascan};\n        }\n    }\n\n    return dentalCurvesPointsXY;\n}\n\n// Dilate bone zone to eventually fill disconnections in dental zone\nconst dilate = (image, width, height, iterations) => {\n    const result = new Array(width * height).fill(-1000);\n\n    const getPixel = (x, y) => image[y * width + x] || 0;\n\n    for (let iteration = 0; iteration < iterations; iteration++) {\n        for (let y = 1; y < height - 1; y++) {\n            for (let x = 1; x < width - 1; x++) {\n                const neighbors = [\n                    getPixel(x - 1, y - 1), getPixel(x, y - 1), getPixel(x + 1, y - 1),\n                    getPixel(x - 1, y), getPixel(x, y), getPixel(x + 1, y),\n                    getPixel(x - 1, y + 1), getPixel(x, y + 1), getPixel(x + 1, y + 1)\n                ];\n\n                result[y * width + x] = Math.max(...neighbors);\n            }\n        }\n\n        // Mettre à jour l'image pour la prochaine itération\n        for (let i = 0; i < width * height; i++) {\n            image[i] = result[i];\n        }\n    }\n\n    return result;\n}\n\n// TODO O(2n) algorithm\n// Get spatial clusters in binarized image (groups of pixels connected between them)\nconst spatialClustering = (image, width, height) => {\n    const clusters = [];\n    const visited = new Array(width * height).fill(false);\n\n    const getNeighbors = (index) => {\n        const neighbors = [];\n        const x = index % width;\n        const y = Math.floor(index / width);\n\n        for (let i = Math.max(0, x - 1); i <= Math.min(width - 1, x + 1); i++) {\n            for (let j = Math.max(0, y - 1); j <= Math.min(height - 1, y + 1); j++) {\n                const neighborIndex = j * width + i;\n                neighbors.push(neighborIndex);\n            }\n        }\n\n        return neighbors;\n    };\n\n    const exploreCluster = (startIndex, cluster) => {\n        const queue = [startIndex];\n\n        while (queue.length > 0) {\n            const currentIndex = queue.shift();\n\n            if (!visited[currentIndex] && image[currentIndex] !== -1000) {\n                visited[currentIndex] = true;\n                cluster.push(currentIndex);\n\n                const neighbors = getNeighbors(currentIndex);\n\n                for (const neighborIndex of neighbors) {\n                    if (!visited[neighborIndex] && image[neighborIndex] !== -1000) {\n                        queue.push(neighborIndex);\n                    }\n                }\n            }\n        }\n    };\n\n    for (let i = 0; i < width * height; i++) {\n        if (!visited[i] && image[i] !== -1000) {\n            const newCluster = [];\n            exploreCluster(i, newCluster);\n            clusters.push(newCluster);\n        }\n    }\n\n    return clusters;\n}\n\n// Computation of panoramic control points, which are points in the dental curve\n// from where panoramic will be computed\nconst createControlPoints = async(viewport: VolumeViewport, numberBasePoints: number, { servicesManager }) => {\n    const {\n        cornerstoneViewportService,\n        panoramicService,\n    } = servicesManager.services;\n\n    const imageData = viewport.getImageData();\n    const scalarData = imageData.scalarData;\n    const [layerWidth, layerHeight, _] = imageData.dimensions;\n    const minLayer = Math.floor(scalarData.findIndex((value) => value > -1000) / layerWidth / layerHeight);\n    const maxLayer = Math.floor(scalarData.findLastIndex((value) => value > -1000) / layerWidth / layerHeight) + 1;\n    // Ignore rows with empty data\n     const parameters = {layerWidth: layerWidth, layerHeight: layerHeight, layerSize: layerWidth * layerHeight,\n                        minLayer: minLayer, nbLayers: maxLayer - minLayer, };\n\n    const coronalData = getCoronalDataMax(scalarData, parameters);\n\n    // We select the highest value cluster on coronal view with a K-means++\n    const skMeansCoronal = skmeans(coronalData, 6);\n    const {centroids:centroidsCoronal, idxs:idxsCoronal} = skMeansCoronal\n    const idxsMaxCoronal = centroidsCoronal.indexOf(Math.max(...centroidsCoronal))\n    // Find minimal and maximal layer where one pixel is not -1000\n    const minTissueLayer = minLayer + Math.floor(idxsCoronal.findIndex((value) => value === idxsMaxCoronal) / layerHeight);\n    const maxTissueLayer = minLayer + Math.floor(idxsCoronal.findLastIndex((value) => value === idxsMaxCoronal) / layerHeight) + 1;\n    console.log('MINLAYER, MAXLAYER', minTissueLayer, maxTissueLayer);\n    console.log('CENTROIDS', centroidsCoronal);\n    // TODO assert minLayer !== maxLayer\n\n    const axialData = getAxialDataMean(scalarData, minTissueLayer, maxTissueLayer, parameters);\n\n    // K-means++ in AIP axial image data to isolate bone / jaw zone\n    const skMeansResult = skmeans(axialData, 5);\n    const {centroids, idxs} = skMeansResult\n    const maxClusterIdx = centroids.indexOf(getMax(centroids))\n\n    // Binarize array between max cluster (highest values meaning bone pixels) and other\n    let binarizedArray = Array.from(axialData.map((value, idx) => idxs[idx] === maxClusterIdx ? value : -1000));\n\n    const binarizedArrayDilated = dilate(binarizedArray, layerWidth, layerHeight, 5);\n\n    // Find equation of polynomial going through dental zone with the use of the biggest spatial cluster\n    // corresponding to our dental zone\n    /* const binarizedIdx = binarizedArray.map((value, idx) => value != -1000? idx: -1000);\n    const filteredIdx = binarizedIdx.filter((value) => value != -1000);\n    const binarizedXy = Array.from(filteredIdx).map(i => ({ x: i % layerWidth, y: Math.floor(i / layerWidth) }));*/\n\n    const spatialClusters = spatialClustering(binarizedArrayDilated, layerWidth, layerHeight);\n    spatialClusters.sort((sc1, sc2) => sc2.length - sc1.length);\n    // Indexes of biggest spatial cluster as X and Y values\n    const biggestSpatialClusterXy = spatialClusters[0].map(i => ({ x: i % layerWidth, y: Math.floor(i / layerWidth) }));\n\n    // LSF method to get best fitting parabola along pixels in square\n    let lsf = polynomialLSF(biggestSpatialClusterXy, 2);\n    let f = lsf.predict;\n\n    // Find minimum and maximum of our binarized to determine where panoramic should start and where should end\n    // We want control points to start at right and left jaw, so we don't use biggestCluster in this case\n    // since it corresponds to the dental zone, not jaws\n    let minX = binarizedArrayDilated.reduce((min, val, idx) =>\n        (idx % layerWidth < min && val != -1000 ? idx % layerWidth : min), Infinity);\n    let maxX = binarizedArrayDilated.reduce((max, val, idx) =>\n        (idx % layerWidth > max && val != -1000 ? idx % layerWidth : max), -Infinity);\n\n    // Compute control points : points that determine piecewise linear curve function through f\n    // They are also the points drawn in Viewport so that user can modify if the curve is not correct\n    const controlPoints = [];\n    const step = (maxX - minX) / (numberBasePoints - 1);\n    for (let x = minX; x < maxX + TOLERANCE; x += step) {\n        controlPoints.push([x, f(x)]);\n    }\n\n    // Draw these control points in front on Viewport so that user can move them\n    // Get ArrowAnnotate instance in order to create new interpolated annotation\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\n        viewport.id,\n        viewport.renderingEngineId\n    );\n    // Transpose control points from volume basis to viewport canvas basis\n    const middleLayer = Math.ceil((maxLayer - minLayer) / 2) - 1;\n    const controlPointsInWorld = controlPoints.map(cp => imageData.imageData.indexToWorld([cp[0], cp[1], middleLayer]));\n\n    const arrowAnnotateInstance = toolGroup.getToolInstance('ArrowAnnotate');\n    console.log('Tool Group', toolGroup, arrowAnnotateInstance);\n    const annotation = arrowAnnotateInstance.addNewAnnotationWithMode(viewport.element, controlPointsInWorld,\n        'movable', 'rgb(0, 255, 0)');\n\n    // Hide annotation if not enabled\n    const displaySetInstanceUID = cornerstoneViewportService.getViewportInfo('default')\n        .getViewportData().data[0].displaySetInstanceUID;\n    const panoramicState = panoramicService.getPanoramicState(displaySetInstanceUID);\n    const newPanoramicState: PanoramicState = {\n        ...panoramicState,\n        annotation: {\n            uid: annotation.annotationUID,\n            visible: panoramicState?.annotation || false\n        }\n    };\n    panoramicService.addDisplaySetUID(displaySetInstanceUID);\n    panoramicService.setPanoramicState(displaySetInstanceUID, newPanoramicState);\n    return annotation.annotationUID;\n}\n\n// Control points that can be changed in front will be re-used to compute\n// A new dental curve thus a new panoramic\nconst createPanoramic = async(viewport: VolumeViewport, numberBasePoints: number, {\n    commandsManager,\n    extensionManager,\n    servicesManager\n}) => {\n    // @ts-ignore\n    const {\n        displaySetService,\n        cornerstoneViewportService,\n        uiNotificationService,\n        panoramicService,\n    } = servicesManager.services;\n\n    // Get control points\n    const viewportData = cornerstoneViewportService.getViewportInfo('default').getViewportData().data[0];\n    const displaySetInstanceUID = viewportData.displaySetInstanceUID;\n    const volumeData = viewportData.volume;\n\n    // If user is asking to regenerate panoramic and there already is one for this serie, delete the previous one\n    const panoramicState = panoramicService.getPanoramicState(displaySetInstanceUID);\n    if (panoramicState.panoramic?.width) {\n        panoramicService._deletePanoramic();\n    }\n\n    const imageData = viewport.getImageData().imageData;\n    const controlPointsInVolume = panoramicService._getControlPoints(displaySetInstanceUID, imageData);\n\n    const [layerWidth, layerHeight, _] = volumeData.dimensions;\n    const scalarData = volumeData.getScalarData();\n    const minLayer = Math.floor(scalarData.findIndex((value) => value > -1000) / layerWidth / layerHeight);\n    const maxLayer = Math.floor(scalarData.findLastIndex((value) => value > -1000) / layerWidth / layerHeight) + 1;\n    const nbLayers = maxLayer - minLayer;\n\n    let parameters = {layerWidth: layerWidth, layerHeight: layerHeight, layerSize: layerWidth * layerHeight,\n                      minLayer: minLayer, nbLayers: nbLayers};\n    // LSF method to get best fitting parabola along basePoints\n    const lsfDentalCurve = polynomialLSF(controlPointsInVolume, 6);\n    const f = lsfDentalCurve.predict;\n\n    // For now we just have control points\n    // We need to regenerate base points, which are equitably distributed points between mix and max control points\n    const minX = controlPointsInVolume[0].x;\n    const maxX = controlPointsInVolume[numberBasePoints - 1].x;\n\n    // Iteration on normals to determine width of panoramic and array of offsets\n    // On each index representing a basePoints, the value represents the width value on the panoramic\n    // from where the corresponding basePoint begins.\n    // TODO\n\n    // Precompute nb steps\n    let dentascans = [getDentascanSection(maxX, f, scalarData, parameters)];\n\n    // Compute panoramicWidth and build dentascans\n    // Dentascans need to be stored from right to left to be in the correct order\n    let x = maxX;\n    while (x > minX) {\n        x -= getTangentVector(f, x)[0] / 2; // Anti-Aliasing\n\n        const dentascan = getDentascanSection(x, f, scalarData, parameters);\n        dentascans.push(dentascan);\n    }\n    let newDentascans = [];\n    for (let i = 0; i < Math.floor(dentascans.length / 2); i++) {\n        let dentascan = dentascans[2 * i];\n        const newDentascanWidth = Math.floor(dentascan.width / 2);\n        let newDentascan = new Float32Array(newDentascanWidth * nbLayers).fill(0);\n        for (let j = 0; j < newDentascanWidth * nbLayers; j++) {\n            newDentascan[j] += dentascans[2 * i].dentascan[2 * j];\n            newDentascan[j] += dentascans[2 * i + 1].dentascan[2 * j];\n            newDentascan[j] += dentascans[2 * i].dentascan[2 * j + 1];\n            newDentascan[j] += dentascans[2 * i + 1].dentascan[2 * j + 1];\n            newDentascan[j] = Math.floor(newDentascan[j] / 4);\n        }\n        dentascan.dentascan = newDentascan;\n        dentascan.width = newDentascanWidth;\n        newDentascans.push(dentascan);\n    }\n    dentascans = newDentascans;\n    const panoramicWidth = dentascans.length;\n    console.log('PANORAMIC WIDTH', panoramicWidth)\n    parameters['panoramicWidth'] = panoramicWidth;\n\n    /*const [a, b, c] = lsfDentalCurve.equation;\n    const dfdx = a * x + b;\n    const fl = Math.sqrt(1 + dfdx * dfdx);\n    const flPrim = (x) => 1/(2*a)*(fl*dfdx + Math.log(fl+dfdx));\n    const panoramicWidth = flPrim(maxX) - flPrim(minX);*/ // TODO\n\n    // This promise take a base point and an offset\n    // It computes the dentascan corresponding to the offset and finishes\n    // This needs to be separated from buildPanoramicPromise as we will do a transformation on\n    // the dentascan curves consisting in recalculating the curves.\n    // TODO\n\n    // Compute the value of each dentascan at each layer in order to compute axial curves of each layer\n    const dentalCurvesPointsXY = getDentalCurvesPointsXY(dentascans, 'curveAIP', parameters);\n    const nbDentalCurves = Math.floor(panoramicWidth / DENTAL_CURVES_STEP);\n    const nbAxialCurves = Math.floor(nbLayers / AXIAL_CURVES_STEP);\n\n    //let axialCurvesPoints = new Array(nbAxialCurves * panoramicWidth).fill(null);\n    // Convert an array of long curves points to an array of axial curves points.\n    // The value inside newScalarData contains the x coordinate of the curve\n    for (let l = 0; l < nbAxialCurves; l++) {\n        break;\n        const layer = 1 * l;\n        const [inf, sup] = [Math.max(0, l), l + 1];\n        const coordinatesSlice = dentascanCurvesPoints.slice(inf * nbDentalCurves, sup * nbDentalCurves).filter(value => value);\n        const axialCurve = polynomialLSF(coordinatesSlice, 6);\n        // TODO\n        for (let i = 0; i < panoramicWidth; i++) {\n            const dentascan = dentascans[panoramicWidth - i - 1];\n            const middlePoint = dentascan.middlePoint;\n            // We want to find the point where an axial curve crosses a dental segment\n            // Having ax²+bx+c the curve of the axial curve and dx + e the curve of the segment,\n            // This is solved by solving the equation ax² + (b-d)x + (c-e) = 0\n            // Which admits two roots: -(b-d)-sqrt(delta)/2a and -(b-d)+sqrt(delta)/2a where delta is (b-d)²-4a(c-e)\n            /*let [a_, b_, c_] = axialCurve.equation; // TODO\n            const [d_, e_] = dentascan.equation;\n            let xyAxial = null;\n            if (a_ != 0) {\n                const [a, b, c] = [a_, b_ - d_, c_ - e_];\n                const delta = b*b - 4*a*c;\n                if (delta > 0) {\n                    // Two roots\n                    const root1 = (-b - Math.sqrt(delta)) / (2*a);\n                    const root2 = (-b + Math.sqrt(delta)) / (2*a);\n                    if (Math.abs(root1 - middlePoint[0]) < Math.abs(root2 - middlePoint[0])) {\n                        xyAxial = [root1, axialCurve.predict(root1)];\n                    } else {\n                        xyAxial = [root2, axialCurve.predict(root2)];\n                    }\n                } else if (delta === 0) {\n                    const root = -b / (2*a)\n                    xyAxial = [root, axialCurve.predict(root)];\n                }\n\n            }*//* else {\n                const root = (e_ - c_) - (b_ - d_);\n                xyAxial = [root, axialCurve.predict(root)];\n            }*/ // TODO\n            const [minX, minY] = dentascan.interval[0];\n            let xyAxial = null;\n            let costAxial = layerHeight; // Big value;\n            for (let i = 0; i < dentascan.width; i++) {\n                const x = minX + i * dentascan.direction[0];\n                const yAxial = axialCurve.predict(x);\n                const yDental = minY + i * dentascan.direction[1];\n\n                const cost = Math.abs(yAxial - yDental);\n                if (cost < costAxial) {\n                    costAxial = cost;\n                    xyAxial = [x, yAxial];\n                }\n            }\n            if (xyAxial) {\n                let xPosInDentascan = Math.floor(DENTASCAN_THICKNESS / 2\n                                                    + (xyAxial[0] - middlePoint[0]) / dentascan.direction[0]);\n                const yPosInDentascan = layer;\n\n                if (xPosInDentascan < 0) {\n                    xPosInDentascan = 0;\n                }\n                if (xPosInDentascan > DENTASCAN_THICKNESS) {\n                    xPosInDentascan = DENTASCAN_THICKNESS;\n                }\n                // Image is transposed\n                // TODO : handle sigmoid curve on new dental curve\n                axialCurvesPoints[i * nbAxialCurves + l] = {x: yPosInDentascan, y: xPosInDentascan};\n            }\n        }\n    } // TODO\n\n    // This promise take a base point and an offset\n    // It fills panoramicArray from basePoint to next basePoint\n    // Offset as explained earlier is the starting width of the base point\n    // TODO\n\n    // Init panoramic array\n    let panoramicNormalsIterative = new Float32Array(panoramicWidth * nbLayers).fill(-1000)\n\n    const panoramicDepth = DENTAL_CURVE_THICKNESS + 1;\n    // From start of base point to start of other base point, incremented by vector direction between those two points\n    for (let i = 0; i < panoramicWidth; i++) {\n        let dentascan = dentascans[panoramicWidth - i - 1];\n        const [dentascanMinPoint, dentascanMaxPoint] = dentascan.interval;\n        const [dentascanVxNormal, dentascanVyNormal] = dentascan.direction;\n\n        //const coordinatesSlice = axialCurvesPoints.slice(i * nbAxialCurves, (i + 1) * nbAxialCurves).filter(value => value);\n        //const dentalCurve = polynomialLSF(coordinatesSlice, 3);\n        for (let layer = 0; layer < nbLayers; layer++) {\n            // TODO\n            const pointXY = dentalCurvesPointsXY[Math.floor(layer / AXIAL_CURVES_STEP) * nbDentalCurves\n                                                            + Math.floor(i / DENTAL_CURVES_STEP)];\n            const [x, y, xpos] = [pointXY.x, pointXY.y, pointXY.xpos];\n\n            // Get min and max point along normal of dentalCurve which length between the two is DENTAL_CURVE_THICKNESS\n            let minPoint = [x - DENTAL_CURVE_THICKNESS / 2 * dentascanVxNormal,\n                            y - DENTAL_CURVE_THICKNESS / 2 * dentascanVyNormal];\n            let maxPoint = [x + DENTAL_CURVE_THICKNESS / 2 * dentascanVxNormal,\n                            y + DENTAL_CURVE_THICKNESS / 2 * dentascanVyNormal];\n\n            const valuesAlongNormal = [];\n\n            // Get values of point along normal between min and max\n            for (let k = 0; k < panoramicDepth; k++) {\n                const xk = Math.floor(minPoint[0] + k * dentascanVxNormal);\n                const yk = Math.floor(minPoint[1] + k * dentascanVyNormal);\n                // TODO Values are now picked from the dentascans instead of being picked from the volume, so that anti-aliasing is applied.\n                const xposk = k + Math.floor(xpos - panoramicDepth / 2);\n                const scalarValue = dentascan.dentascan[layer * DENTASCAN_THICKNESS + xposk];\n                const scalarValueNormalized = Math.floor((scalarValue + 1000) / 16) / 255;\n                //let scalarValue = Math.floor((scalarData[layer * layerSize + yk * layerWidth + xk] + 1000) / 16) / 255;\n                //let scalarValue = (scalarData[layer * layerSize + yk * layerWidth + xk] + 1000) / 16;\n                //if (scalarValue >= 50) {\n                    //valuesAlongNormal.push(Math.exp(scalarValue / S));\n\n                // Take data along normal vector where x and y are valid coordinates\n                if (!isNaN(scalarValueNormalized)) {\n                    valuesAlongNormal.push(1 - 0.15 * Math.pow(scalarValueNormalized, 3));\n                }\n            }\n\n            // Add mean of all values as value in panoramic result\n            // TODO\n            let absorption = valuesAlongNormal.reduce((a, b) => a * b, 1);\n            //let mean = valuesAlongNormal.reduce((a, b) => a + b, 0) / valuesAlongNormal.length;\n            //const max = getMax(valuesAlongNormal);\n            //panoramicNormalsIterative[panoramicWidth * (nbLayers - layer - 1) + i] = S * Math.log(mean) * 16 - 1000;\n            panoramicNormalsIterative[panoramicWidth * (nbLayers - layer - 1) + i] = (1 - absorption) * 255 * 16 - 1000;\n        }\n    }\n    // Post processing\n    let panoramicProcessed = new Array(panoramicWidth * nbLayers).fill(-1000);\n    const gImage = blurPanoramic(panoramicNormalsIterative, panoramicWidth, nbLayers);\n\n    for (let i = 0; i < panoramicWidth * nbLayers; i++) {\n        const image0 = panoramicNormalsIterative[i];\n        const gImage0 = gImage[i];\n        const alpha = 0.9;\n        panoramicProcessed[i] = alpha * image0 + (1 - alpha) * (image0 - gImage0);\n    }\n    /*const oldMin = Math.min(...panoramicNormalsIterative);\n    const oldMax = Math.max(...panoramicNormalsIterative);\n    const newMin = Math.min(...panoramicProcessed);\n    const newMax = Math.max(...panoramicProcessed);\n    const scalingFactor = (oldMax - oldMin) / (newMax - newMin);\n\n\n    // Rescale values\n    for (let i = 0; i < panoramicWidth * nbLayers; i++) {\n        panoramicProcessed[i] = Math.round((panoramicProcessed[i] - newMin) * scalingFactor + oldMin);\n    }\n\n    // Array at start is filled with false\n    // When a promise at a specific basePoint is done, its index goes to true\n    // This array allows us to track state of the promises to display progress bar in front\n\n    // Recursive function to execute promises in array\n    // When promise at index x is done, update doneArray by putting true value and wait a bit\n    // to call recursively function of x + 1 index.\n\n    // Update progress value in front-end by getting each 250ms the number of true values in doneArray\n    // THIS WORKS ONLY WHEN PARENT FUNCTION IS CALLED WITH debug = false\n    const waitUntilArrayDone = (start) => {\n        return new Promise<void>((resolve, reject) => {\n            const waitForArray = (start) => {\n                const completed = doneArray.filter(el => el).length\n                const progress = (start + Math.round((completed * 100) / 2 / basePoints.length))\n                setProcessingPourcent(progress)\n                if (completed === basePoints.length) {\n                    return resolve();\n                } else {\n                    setTimeout(() => waitForArray(start), 50)\n                }\n            }\n            waitForArray(start)\n        })\n    }\n    // Wait until panoramic is completed\n    await waitUntilArrayDone(0)*/\n\n    let sharpenedPanoramic = panoramicNormalsIterative;//sharpen(panoramicNormalsIterative, panoramicWidth, nbLayers)\n    //sharpenedPanoramic = applySmoothing(sharpenedPanoramic, panoramicWidth, nbLayers)\n\n    // Display panoramic in OHIF Viewport\n    const imageId = panoramicService._getImageId(displaySetInstanceUID);\n    const voiLutModule = metaData.get('voiLutModule', imageId);\n    const imagePixelModule = metaData.get('imagePixelModule', imageId);\n    const generalSeriesModule = metaData.get('generalSeriesModule', imageId);\n\n    if (!cornerstoneViewportService.getCornerstoneViewport('default')) {\n        uiNotificationService.show({\n            title: `Panoramic Generation Error`,\n            message: `No viewport detected.`,\n            type: 'error',\n            duration: 3000,\n        });\n        return;\n    }\n    const panoramicMetadata = {\n        SeriesInstanceUID: generalSeriesModule.seriesInstanceUID + '.panoramic',\n        StudyInstanceUID: generalSeriesModule.studyInstanceUID,\n        BitsAllocated: imagePixelModule.bitsAllocated,\n        BitsStored: imagePixelModule.bitsStored,\n        Rows: nbLayers,\n        Columns: panoramicWidth,\n        WindowCenter: voiLutModule.windowCenter[0],\n        WindowWidth: voiLutModule.windowWidth[0],\n        PixelData: sharpenedPanoramic\n    };\n    const panoramicViewportData = await loadBlobInViewport(panoramicMetadata, { extensionManager, servicesManager });\n\n    const dentascanObject = {\n        SeriesInstanceUID: generalSeriesModule.seriesInstanceUID + '.dentascan',\n        StudyInstanceUID: generalSeriesModule.studyInstanceUID,\n        BitsAllocated: imagePixelModule.bitsAllocated,\n        BitsStored: imagePixelModule.bitsStored,\n        Rows: nbLayers,\n        Columns: DENTASCAN_THICKNESS,\n        WindowCenter: voiLutModule.windowCenter[0],\n        WindowWidth: voiLutModule.windowWidth[0],\n        PixelData: dentascans.map(dentascan => dentascan.dentascan) // TODO\n    };\n\n    const dentascansViewportData = await loadMultipleBlobsInViewport(dentascanObject, { extensionManager, servicesManager });\n\n    const newPanoramicState: PanoramicState = {\n        annotation: panoramicState.annotation,\n        dentascanViewportData: dentascansViewportData,\n        panoramicViewportData: panoramicViewportData,\n        panoramic: {\n            width: panoramicWidth,\n            height: nbLayers\n        },\n        dentascans: dentascans,\n    }\n    panoramicService.setPanoramicState(displaySetInstanceUID, newPanoramicState);\n}\n\nexport { createControlPoints, createPanoramic };\n","export function antiAlias(imageData, width, height, intensity) {\n    const resultImageData = imageData.slice();\n\n    for (let y = 1; y < height - 1; y++) {\n        for (let x = 1; x < width - 1; x++) {\n            const index = y * width + x;\n            const gray =\n                (imageData[(y - 1) * width + x - 1] * intensity +\n                    imageData[(y - 1) * width + x] * intensity +\n                    imageData[(y - 1) * width + x + 1] * intensity +\n                    imageData[y * width + x - 1] * intensity +\n                    imageData[y * width + x] +\n                    imageData[y * width + x + 1] * intensity +\n                    imageData[(y + 1) * width + x - 1] * intensity +\n                    imageData[(y + 1) * width + x] * intensity +\n                    imageData[(y + 1) * width + x + 1] * intensity) /\n                1 + intensity * 8;\n\n            // Mettre à jour la valeur de pixel dans l'image résultante\n            resultImageData[index] = gray;\n        }\n    }\n\n    return resultImageData;\n}\n\nexport function sharpen(imageData, width, height) {\n    // Créer une copie de l'image pour ne pas modifier l'original\n    const resultImageData = imageData.slice();\n\n    // Matrice de renforcement\n    const sharpenMatrix = [\n        [0, -1, 0],\n        [-1, 5, -1],\n        [0, -1, 0],\n    ];\n\n    const matrixSize = 3; // Taille de la matrice (3x3)\n\n    for (let y = 1; y < height - 1; y++) {\n        for (let x = 1; x < width - 1; x++) {\n            let sum = 0;\n\n            // Appliquer la matrice de renforcement aux pixels voisins\n            for (let i = 0; i < matrixSize; i++) {\n                for (let j = 0; j < matrixSize; j++) {\n                    const pixelX = x + j - 1;\n                    const pixelY = y + i - 1;\n                    const index = pixelY * width + pixelX;\n                    sum += imageData[index] * sharpenMatrix[i][j];\n                }\n            }\n\n            // S'assurer que la valeur est dans la plage [0, 255]\n            sum = Math.min(32767, Math.max(-32768, sum));\n\n            // Mettre à jour la valeur de pixel dans l'image résultante\n            const index = y * width + x;\n            resultImageData[index] = sum;\n        }\n    }\n\n    return resultImageData;\n}\n\nexport function blurPanoramic(imageData, width, height) {\n    const resultImageData = imageData.slice();\n\n    const sigma = 0.8;\n    const gaussianBlur = (dist) => Math.exp(-dist / (2 * sigma * sigma)) / (2 * Math.PI * sigma * sigma);\n    const [g0, g1, g2] = [gaussianBlur(0), gaussianBlur(1), gaussianBlur(2)];\n\n    const kernel = [\n        [g2, g1, g2],\n        [g1, g0, g1],\n        [g2, g1, g2],\n    ];\n    const normalizeCoef = 1 / (g0 + 4 * g1 + 4 * g2);\n\n    const kernelSize = kernel.length;\n    const halfKernelSize = Math.floor(kernelSize / 2);\n\n    for (let y = halfKernelSize; y < height - halfKernelSize; y++) {\n        for (let x = halfKernelSize; x < width - halfKernelSize; x++) {\n            let sum = 0;\n            for (let ky = 0; ky < kernelSize; ky++) {\n                for (let kx = 0; kx < kernelSize; kx++) {\n                    const pixelX = x + kx - halfKernelSize;\n                    const pixelY = y + ky - halfKernelSize;\n                    const index = pixelY * width + pixelX;\n\n                    // Appliquer le noyau de convolution au pixel.\n                    sum += imageData[index] * kernel[ky][kx];\n                }\n            }\n\n            // Normaliser la somme en fonction de l'intensité.\n            sum *= normalizeCoef;\n\n            // Mettre à jour la valeur du pixel dans l'image résultante.\n            resultImageData[y * width + x] = sum;\n        }\n    }\n\n    return resultImageData;\n}\n\nexport function applySmoothing(imageData, width, height) {\n    const resultImageData = imageData.slice();\n\n    const kernel = [\n        [0, 1, 0],\n        [0, 1, 0],\n        [0, 1, 0],\n    ]; // Noyau de convolution simple pour l'adoucissement.\n\n    const kernelSize = kernel.length;\n    const halfKernelSize = Math.floor(kernelSize / 2);\n\n    for (let y = halfKernelSize; y < height - halfKernelSize; y++) {\n        for (let x = halfKernelSize; x < width - halfKernelSize; x++) {\n            let sum = 0;\n\n            for (let ky = 0; ky < kernelSize; ky++) {\n                for (let kx = 0; kx < kernelSize; kx++) {\n                    const pixelX = x + kx - halfKernelSize;\n                    const pixelY = y + ky - halfKernelSize;\n                    const index = pixelY * width + pixelX;\n\n                    // Appliquer le noyau de convolution au pixel.\n                    sum += imageData[index] * kernel[ky][kx];\n                }\n            }\n\n            // Normaliser la somme en fonction de l'intensité.\n            sum /= 3;\n\n            // Mettre à jour la valeur du pixel dans l'image résultante.\n            resultImageData[y * width + x] = sum;\n        }\n    }\n\n    return resultImageData;\n}\n\nexport function calculateNormalCurve(curve, ind, nbNormals) {\n    const norm = [];\n\n    if (curve.length <= 1 || ind < 0 || ind >= curve.length) {\n        // Gestion des cas spéciaux où la normale ne peut pas être calculée\n        return norm;\n    }\n\n    // Coordonnées du point \"p\"\n    const [px, py] = curve[ind];\n\n    // Calcul des tangentes aux points voisins\n    let [tx, ty] = [0, 0]; // Tangente au point \"p\"\n\n    if (ind > 10) {\n        const [prevX, prevY] = curve[ind - 10];\n        tx += px - prevX;\n        ty += py - prevY;\n    }\n\n    if (ind < curve.length - 10) {\n        const [nextX, nextY] = curve[ind + 10];\n        tx += nextX - px;\n        ty += nextY - py;\n    }\n\n    // Calcul de la normale (perpendiculaire à la tangente)\n    const magnitude = Math.sqrt(tx * tx + ty * ty);\n    if (magnitude === 0) {\n        // Gestion du cas où la tangente est nulle (point isolé)\n        return norm;\n    }\n\n    const nx = -ty / magnitude; // Composante x de la normale\n    const ny = tx / magnitude; // Composante y de la normale\n\n    // Ajout du point \"p\" dans \"norm\"\n    norm.push([px, py]);\n\n    const stepSize = magnitude / (nbNormals / 2); // nbNormals points au total, y compris \"p\"\n    let currentX = px - nx * magnitude;\n    let currentY = py - ny * magnitude;\n\n    // Calcul des points équidistants sur la normale\n    for (let i = 0; i < nbNormals; i++) {\n        currentX += nx * stepSize;\n        currentY += ny * stepSize;\n        norm.push([currentX, currentY]);\n    }\n\n    return norm;\n}\n\nexport function cubicSplineInterpolation(arr, x) {\n    const n = arr.length;\n    let i = 0;\n\n    if (x >= arr[n - 1][0]) {\n        i = n - 2;\n    } else {\n        while (x > arr[i + 1][0]) {\n            i++;\n        }\n    }\n\n    const x1 = arr[i][0];\n    const x2 = arr[Math.min(i + 1, n - 1)][0];\n\n    const y0 = arr[Math.max(i - 1, 0)][1];\n    const y1 = arr[i][1];\n    const y2 = arr[Math.min(i + 1, n - 1)][1];\n    const y3 = arr[Math.min(i + 2, n - 1)][1];\n\n    const t = (x - x1) / (x2 - x1);\n    const t2 = t * t;\n    const t3 = t * t2;\n\n    const a = -0.5 * y0 + 1.5 * y1 - 1.5 * y2 + 0.5 * y3;\n    const b = y0 - 2.5 * y1 + 2 * y2 - 0.5 * y3;\n    const c = -0.5 * y0 + 0.5 * y2;\n    const d = y1;\n\n    const y = a * t3 + b * t2 + c * t + d;\n\n    return [x, y];\n}\n\nfunction linearInterpolationCoefficients(point1, point2) {\n    const [x1, y1] = point1;\n    const [x2, y2] = point2;\n\n    if (x1 === x2) {\n        throw new Error('Les deux points doivent avoir des coordonnées x différentes pour l\\'interpolation linéaire.');\n    }\n\n    const a = (y2 - y1) / (x2 - x1);\n    const b = y1 - a * x1;\n\n    return [Math.round(a), Math.round(b)];\n}\n\n//Complete cubic spline interpolation in order to have linear interpolation in the beginning and in the end of the curve\nfunction completeInterpolation(interpolatedPoints, xMax){\n    const [a0, b0] = linearInterpolationCoefficients(interpolatedPoints[0], interpolatedPoints[10])\n    const [a1, b1] = linearInterpolationCoefficients(interpolatedPoints[interpolatedPoints.length - 10], interpolatedPoints[interpolatedPoints.length - 1])\n    const stepBegin = interpolatedPoints[0][0] / (xMax / 3)\n    const stepEnd = (xMax - interpolatedPoints[interpolatedPoints.length - 1][0]) / (xMax / 3)\n    for(let x = 0; x < interpolatedPoints[0][0]; x += stepBegin){\n        interpolatedPoints.push([x, a0 * x + b0])\n    }\n    interpolatedPoints.sort((a, b) => a[0] - b[0]);\n\n    for(let x = interpolatedPoints[interpolatedPoints.length - 1][0] + stepEnd; x < xMax; x += stepEnd){\n        interpolatedPoints.push([x, a1 * x + b1])\n    }\n\n    return  interpolatedPoints.map(p => {\n        return [p[0], p[1], 0]\n    })\n}\n","const zeros = require('zeros')\n\nconst dcmbufferToPng = (metadata, invertRows=false, useWindowing=true) => {\n    const {\n        BitsAllocated,\n        BitsStored,\n        Rows: rows,\n        Columns: columns,\n        WindowCenter: windowCenter,\n        WindowWidth: windowWidth,\n        PixelData: pixelData\n    } = metadata;\n\n    // Create the appropriate pixel array based on BitsAllocated\n    const pixelArray = BitsAllocated === 16 ? new Int16Array(pixelData) : new Int8Array(pixelData);\n\n    // Initialize the result array\n    const res = zeros([rows, columns]);\n\n    // Precompute windowing values if they exist\n    const hasWindowing = useWindowing && windowCenter && windowWidth;\n    const windowMin = windowCenter - 0.5 - (windowWidth - 1) / 2;\n    const windowMax = windowCenter - 0.5 + (windowWidth - 1) / 2;\n\n    const transformPixelValue = (val) => {\n        let transformedValue = val;\n\n        if (hasWindowing) {\n            if (val <= windowMin) {\n                transformedValue = 0;\n            } else if (val > windowMax) {\n                transformedValue = 255;\n            } else {\n                transformedValue = ~~(((val - (windowCenter - 0.5)) / (windowWidth - 1) + 0.5) * 255);\n            }\n        } else if (BitsAllocated === 16) {\n            transformedValue = ((val + 1000) * 2 ** 8) / 2 ** BitsStored;\n        }\n\n        return transformedValue;\n    };\n\n    // Loop through pixels and populate `res`\n    for (let i = 0; i < rows; i++) {\n        const rowIndex = invertRows ? rows - i - 1 : i;\n        for (let j = 0; j < columns; j++) {\n            const val = transformPixelValue(pixelArray[i * columns + j]);\n            res.set(rowIndex, j, val);\n        }\n    }\n\n    return {\n        buffer: res,\n        height: rows,\n        width: columns,\n        ext: 'png',\n    };\n};\n\nconst pngToCanvas = (pngBuf) => {\n    const coloredBuffer = new Uint8ClampedArray(pngBuf.width * pngBuf.height * 4);\n    const buffer = pngBuf.buffer.data;\n    buffer.forEach((p, i) => {\n        coloredBuffer[4 * i] = p;\n        coloredBuffer[4 * i + 1] = p;\n        coloredBuffer[4 * i + 2] = p;\n        coloredBuffer[4 * i + 3] = 255;\n    });\n\n    const canvas = document.createElement('canvas');\n    canvas.width = pngBuf.width;\n    canvas.height = pngBuf.height;\n    const imgData = new ImageData(new Uint8ClampedArray(coloredBuffer), pngBuf.width, pngBuf.height);\n    canvas.getContext('2d').putImageData(imgData, 0, 0);\n\n    return canvas;\n}\n\nexport { dcmbufferToPng, pngToCanvas };\n"],"names":["polynomialLSF","data","order","k","lhs","Array","fill","rhs","from","length","i","j","reduce","sum","point","y","x","push","coefficients","matrix","n","maxRow","Math","abs","total","gaussianElimination","map","v","predict","coeff","power","equation","reverse","derivative","f","dx","getSlopeVector","slope","vx","vy","vLength","sqrt","getTangentVector","tangentSlope","interpolatePoints","v1","v2","t","round","interpolateThreePoints","vMid","tMin","tMax","getDentascanSection","lsfDentalCurve","dicomData","p","vxNormal","vyNormal","getNormalVector","minPoint","DENTASCAN_THICKNESS","maxPoint","dentascanWidth","dentascan","Float32Array","nbLayers","layer","xi","yi","xj","yj","pxi","pxj","pyi","pyj","floor","layerWidth","layerHeight","dicomIdxI","minLayer","layerSize","tx","dicomIdxJ","ty","dicomIdxK","min","max","width","height","interval","direction","middlePoint","skmeans","require","metadataProvider","OHIF","classes","MetadataProvider","createDataset","canvas","datasetOptions","Promise","resolve","reject","toBlob","async","fileLoaderService","FileLoaderService","blob","imageId","addFile","img","loadFile","dataset","getDataset","condition","wait","result","setTimeout","StudyInstanceUID","SeriesInstanceUID","SOPInstanceUID","addImageIdToUIDs","frameIndex","NumberOfFrames","InstanceNumber","createViewportData","datasets","viewportType","extensionManager","servicesManager","initialImageIndex","displaySetService","cornerstoneCacheService","services","DicomMetadataStore","addInstances","activeDisplaySets","getActiveDisplaySets","displaySetAdded","viewportOptions","toolGroupId","orientation","initialImageOptions","preset","dataSource","getDataSources","getMax","arr","len","Infinity","getDentalCurve","transposedBin","transposeImage","transposedArr","value","transposedOnlyTeethIndex","idx","filter","l","lsfDentalLiss","some","isNaN","minX","val","maxX","getDentalLiss","sigmoidLeft","exp","sigmoidRight","createControlPoints","viewport","numberBasePoints","cornerstoneViewportService","panoramicService","imageData","getImageData","scalarData","_","dimensions","findIndex","maxLayer","findLastIndex","parameters","coronalData","getCoronalDataMax","maxVal","skMeansCoronal","centroids","centroidsCoronal","idxs","idxsCoronal","idxsMaxCoronal","indexOf","minTissueLayer","maxTissueLayer","console","log","axialData","getAxialDataMean","nbToothLayers","sumVal","skMeansResult","maxClusterIdx","binarizedArrayDilated","dilate","image","iterations","getPixel","iteration","neighbors","spatialClusters","spatialClustering","clusters","visited","getNeighbors","index","neighborIndex","exploreCluster","startIndex","cluster","queue","currentIndex","shift","newCluster","sort","sc1","sc2","biggestSpatialClusterXy","controlPoints","step","toolGroup","ToolGroupManager","id","renderingEngineId","middleLayer","ceil","controlPointsInWorld","cp","indexToWorld","arrowAnnotateInstance","getToolInstance","annotation","addNewAnnotationWithMode","element","displaySetInstanceUID","getViewportInfo","getViewportData","panoramicState","getPanoramicState","newPanoramicState","uid","annotationUID","visible","addDisplaySetUID","setPanoramicState","createPanoramic","commandsManager","uiNotificationService","viewportData","volumeData","volume","panoramic","_deletePanoramic","controlPointsInVolume","_getControlPoints","getScalarData","dentascans","newDentascans","newDentascanWidth","newDentascan","panoramicWidth","dentalCurvesPointsXY","getDentalCurvesPointsXY","mode","nbDentalCurves","nbAxialCurves","dentalCurvesPoints","forEach","dentascanCurve","dentascanMinPoint","dentascanMaxPoint","dentascanVxNormal","dentascanVyNormal","idxInf","DENTAL_CURVE_AIP_THICKNESS","idxSup","dentalCurve","dentascansForMIP","dentascanMIP","dentascanScalar","xPosInDentascan","xPosInDentascans","a","b","xpos","panoramicNormalsIterative","pointXY","DENTAL_CURVE_THICKNESS","valuesAlongNormal","xposk","panoramicDepth","scalarValue","scalarValueNormalized","pow","absorption","panoramicProcessed","gImage","resultImageData","slice","sigma","gaussianBlur","dist","PI","g0","g1","g2","kernel","normalizeCoef","kernelSize","halfKernelSize","ky","kx","blurPanoramic","image0","gImage0","alpha","sharpenedPanoramic","_getImageId","voiLutModule","metaData","imagePixelModule","generalSeriesModule","getCornerstoneViewport","show","title","message","type","duration","panoramicMetadata","seriesInstanceUID","studyInstanceUID","BitsAllocated","bitsAllocated","BitsStored","bitsStored","Rows","Columns","WindowCenter","windowCenter","WindowWidth","windowWidth","PixelData","panoramicViewportData","metadata","prefilledValues","pngBuf","dcmbufferToPng","pngToCanvas","loadBlobInViewport","dentascanObject","dentascansViewportData","options","random","toString","substring","FrameOfReferenceUID","nbBlobs","all","layerData","layerI","layerSopInstanceUID","ImagePositionPatient","loadMultipleBlobsInViewport","dentascanViewportData","zeros","invertRows","useWindowing","rows","columns","pixelData","pixelArray","Int16Array","Int8Array","res","hasWindowing","windowMin","windowMax","transformPixelValue","transformedValue","rowIndex","set","buffer","ext","coloredBuffer","Uint8ClampedArray","document","createElement","imgData","ImageData","getContext","putImageData"],"sourceRoot":""}