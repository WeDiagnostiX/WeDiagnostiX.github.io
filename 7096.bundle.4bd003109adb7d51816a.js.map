{"version":3,"file":"7096.bundle.4bd003109adb7d51816a.js","mappings":";4iDAuBA,SAASA,EAAmBC,GAE1B,IADA,IAAMC,EAAM,IAAIC,WAAWF,EAAIG,QACtBC,EAAI,EAAGC,EAAIL,EAAIG,OAAQC,EAAIC,EAAGD,IACrCH,EAAIG,GAAKJ,EAAIM,WAAWF,GAE1B,OAAOH,EA2BT,SAASM,EAAcC,EAASC,GAAmB,IAAZC,EAAS,UAAH,6CAAG,EAC9C,GAAIA,EAASD,EAAMN,OAASK,EAAQL,OAClC,OAAO,EAIT,IADA,IAAIQ,EAAQD,EACHN,EAAI,EAAGA,EAAIK,EAAMN,OAAQC,IAAK,CACrC,GAAIK,EAAML,KAAOI,EAAQG,GACvB,OAAO,EAGTA,GAAS,EAEX,OAAO,EAUT,SAASC,EAAUJ,EAASC,GAAoC,IAA7BC,EAAS,UAAH,6CAAG,EAAGG,EAAe,uCACxDC,EAAeN,EAAQL,OACvBU,IACFC,EAAeC,KAAKC,IAAIN,EAASG,EAAiBL,EAAQL,SAG5D,IAAK,IAAIC,EAAIM,EAAQN,EAAIU,EAAcV,IAIrC,GAAII,EAAQJ,KAAOK,EAAM,IACnBF,EAAcC,EAASC,EAAOL,GAChC,OAAOA,EAKb,OAAQ,EAoCV,SAASa,EACPC,GAGA,IAFAC,EAAW,UAAH,6CA9BV,WACE,SAASC,IACP,OAAOL,KAAKM,MAA4B,OAArB,EAAIN,KAAKO,WACzBC,SAAS,IACTC,UAAU,GAEf,MAAO,GAAP,OAAUJ,IAAOA,IAAI,YAAIA,IAAI,YAAIA,IAAI,YAAIA,IAAI,YAAIA,KAAI,OAAGA,KAAI,OAAGA,KAwBpDK,GAGLC,EAAoB,iBAAH,OAFT,UAAH,6CAAG,qBAGRC,EAAS,SAAH,OAAYR,EAAQ,eAAOO,EAAiB,YAClDE,EAAS,SAAH,OAAYT,EAAQ,MAC1BU,EAAc9B,EAAmB4B,GACjCG,EAAc/B,EAAmB6B,GACjCG,EAAeF,EAAY1B,OAC3B6B,EAAeF,EAAY3B,OAE7BA,EAAS,EAGP8B,EAAgBf,EAASgB,KAAI,SAAAC,GACjC,IAAMC,EAAe,IAAIlC,WAAWiC,GAC9BE,EAAgBD,EAAajC,OAInC,OAFAA,GAAU4B,EAAeM,EAAgBL,EAElCI,KAIHE,EAAiB,IAAIpC,WAAWC,GAGtCmC,EAAeC,IAAIV,EAAa,GAGhC,IAAIW,EAAW,EAUf,OATAP,EAAcQ,SAAQ,SAAAL,GACpBE,EAAeC,IAAIV,EAAaW,GAChCF,EAAeC,IAAIH,EAAcI,EAAWT,GAE5CS,GAAYT,EAAeK,EAAajC,UAG1CmC,EAAeC,IAAIT,EAAaU,GAEzB,CACLE,KAAMJ,EAAeK,OACrBxB,SAAAA,GAUJ,SAASyB,EAAgBC,GAEvB,IAAMrC,EAAUsC,YAAYC,OAAOF,GAAYA,EAAW,IAAI3C,WAAW2C,GAQnEG,EAAYjD,EAAmB,YAC/BkD,EAAcrC,EAAUJ,EAASwC,EAAW,EAJ1B,KAKxB,IAAqB,IAAjBC,EACF,MAAM,IAAIC,MAAM,iDAGlB,IAAMvB,EAhMR,SAA4B1B,GAG1B,IAHkD,IAAnBS,EAAS,UAAH,6CAAG,EAClCyC,GAD0C,yCACrBlD,EAAIE,OAASO,EACpCV,EAAM,GACDI,EAAIM,EAAQN,EAAIM,EAASyC,EAAW/C,IAC3CJ,GAAOoD,OAAOC,aAAapD,EAAIG,IAEjC,OAAOJ,EA0LQsD,CAAmB9C,EAAS,EAAGyC,GACxCM,EAtKR,SAA0B5B,GAGxB,IAFA,IAAM6B,EAAQ7B,EAAO8B,MAAM,QAElBrD,EAAI,EAAGA,EAAIoD,EAAMrD,OAAQC,IAChC,GAA8B,OAA1BoD,EAAMpD,GAAGsD,OAAO,EAAG,GACrB,OAAOF,EAAMpD,GAIjB,OAAO,KA6JgBuD,CAAiBhC,GACxC,IAAK4B,EACH,MAAM,IAAIL,MAAM,wDAYlB,IATA,IAOIU,EAPEzC,EAAWpB,EAAmBwD,GAC9BM,EAAiB1C,EAAShB,OAC1B2D,EAAa,GAEfpD,EAASmD,GAKa,IAAnBD,IAMkB,KAHvBA,EAAgBhD,EAAUJ,EAASW,EAAUT,KAHlB,CAU3B,IAAMqD,EAAmBnD,EACvBJ,EACAwC,EACAtC,EArCoB,KAwCtB,IAA0B,IAAtBqD,EACF,MAAM,IAAIb,MAAM,4CAElBxC,EAASqD,EAAmBf,EAAU7C,OAGtC,IACMuC,EAAOG,EAASmB,MAAMtD,EAAQkD,EADd,GAItBE,EAAWG,KAAKvB,GAIhBhC,EAASkD,EAAgBC,EAG3B,OAAOC,ECvPT,SAASI,EAASC,GAChB,MAAsB,WAAf,EAAOA,IAA4B,OAARA,EAGpC,SAASC,EAAcD,GACrB,OAAmC,IAA5BE,OAAOC,KAAKH,GAAKhE,QAAgBgE,EAAII,cAAgBF,0BAqB9D,IAAMG,EAAiB,SAAAC,GAAM,OAAIA,EAAO,IAElCC,EAAa,CACjBC,MAAO,oBACPC,WAAY,yBACZC,aAAc,2BACdC,IAAK,kBACLC,KAAM,aACNC,IAAK,aAOHC,EAAW,WAAO,EC3CtB,ICQMC,EAAM,CACVC,eFoDkB,WAiBlB,WAAYC,gGAAS,SACnBC,KAAKC,QAAUF,EAAQG,IAClBF,KAAKC,SACRE,QAAQC,MAAM,sEAGZ,aAAcL,IAChBC,KAAKK,SAAWN,EAAQM,SAClB,aAAcN,GAClBI,QAAQC,MACN,8DAGJJ,KAAKM,SAAWP,EAAQO,UAGtB,kBAAmBP,GACrBH,EAAS,+BAAD,OAAgCG,EAAQQ,gBAChDP,KAAKQ,QAAU,GAAH,OAAMR,KAAKC,QAAO,YAAIF,EAAQQ,gBAE1CP,KAAKQ,QAAUR,KAAKC,QAGlB,kBAAmBF,GACrBH,EAAS,+BAAD,OAAgCG,EAAQU,gBAChDT,KAAKU,QAAU,GAAH,OAAMV,KAAKC,QAAO,YAAIF,EAAQU,gBAE1CT,KAAKU,QAAUV,KAAKC,QAGlB,kBAAmBF,GACrBH,EAAS,+BAAD,OAAgCG,EAAQY,gBAChDX,KAAKY,QAAU,GAAH,OAAMZ,KAAKC,QAAO,YAAIF,EAAQY,gBAE1CX,KAAKY,QAAUZ,KAAKC,QAGlBF,EAAQc,YACVjB,EAAS,iBAAkBG,EAAQc,YACnCb,KAAKa,YAAoC,IAAvBd,EAAQc,WAAsB,uBAAyBd,EAAQc,YAEjFb,KAAKa,WAAa,GAGhB,iBAAkBd,IACpBC,KAAKc,aAAef,EAAQe,cAI9Bd,KAAKe,QAAUhB,EAAQgB,SAAW,CAAC,EAGnCf,KAAKgB,iBAAmBjB,EAAQiB,kBAAqB,aAGrDhB,KAAKiB,SAA8B,IAApBlB,EAAQkB,QAEvBjB,KAAKkB,SAASnB,EAAQoB,iBA+3BvB,SA13BD,sCAOsD,IAA7CC,EAAa,UAAH,8CAAUC,EAAmB,UAAH,6CAAG,KAC9CrB,KAAKoB,aAAeA,EACpBxB,EAAWyB,GAAoBD,EAAajB,QAAQmB,IAAM,WAAO,KAGnE,gCAME,OAAOtB,KAAKoB,cAGd,gCAKWH,GACTjB,KAAKiB,QAAUA,KAGjB,kCAME,OAAOjB,KAAKiB,WACb,mBAaD,eAYaf,EAAKqB,GAAoC,WAA5BR,EAAU,UAAH,6CAAG,CAAC,EAAGhB,EAAU,UAAH,6CAAG,CAAC,EACzCiB,EAAmChB,KAAnCgB,iBAAkBF,EAAiBd,KAAjBc,aAE1B,OAAO,IAAIU,SAAQ,SAACC,EAASC,GAC3B,IAAIC,EAAU5B,EAAQ4B,QAAU5B,EAAQ4B,QAAU,IAAIC,eAEtDD,EAAQE,KAAKN,EAAQrB,GAAK,GACtB,iBAAkBH,IACpB4B,EAAQG,aAAe/B,EAAQ+B,cAGV,WAAnB,EAAOf,IACT/B,OAAOC,KAAK8B,GAAS3D,SAAQ,SAAA2E,GAC3BJ,EAAQK,iBAAiBD,EAAKhB,EAAQgB,OAM1C,IAmE2BE,EAnErBC,EAAc,EAAKnB,QAgEzB,GA/DA/B,OAAOC,KAAKiD,GAAa9E,SAAQ,SAAA2E,GAC/BJ,EAAQK,iBAAiBD,EAAKG,EAAYH,OAI5CJ,EAAQQ,YAAc,WACpBvC,EAAS,mBAAoBM,IAI/ByB,EAAQS,UAAY,WAClBxC,EAAS,oBAIX+B,EAAQU,mBAAqB,WAC3B,GAA2B,IAAvBV,EAAQW,WACV,GAAuB,MAAnBX,EAAQY,OAAgB,CAC1B,IAAMC,EAAcb,EAAQc,kBAAkB,gBAG1CD,IAAqD,IAAtCA,EAAYE,QAAQ,aACrCjB,EAAQlE,EAAgBoE,EAAQnE,WACE,gBAAzBmE,EAAQG,aACjBL,EAAQ,CAACE,EAAQnE,WAEjBiE,EAAQE,EAAQnE,eAEb,GAAuB,MAAnBmE,EAAQY,OACb,EAAKtB,SACPd,QAAQwC,KAAK,mCAAoChB,GAEnDF,EAAQE,EAAQnE,eACX,GAAuB,MAAnBmE,EAAQY,OACb,EAAKtB,SACPd,QAAQwC,KAAK,+BAAgChB,GAE/CF,EAAQ,QACH,CACL,IAAMrB,EAAQ,IAAIvC,MAAM,kBACxBuC,EAAMuB,QAAUA,EAChBvB,EAAM5C,SAAWmE,EAAQnE,SACzB4C,EAAMmC,OAASZ,EAAQY,OACnB,EAAKtB,UACPd,QAAQC,MAAM,mBAAoBuB,GAClCxB,QAAQC,MAAMA,GACdD,QAAQC,MAAMA,EAAM5C,WAGtBwD,EAAiBZ,GAEjBsB,EAAOtB,KAMT,qBAAsBL,GACgB,mBAA7BA,EAAQ6C,mBACjBjB,EAAQkB,WAAa9C,EAAQ6C,kBAI7B9B,GAnRV,SAA8BA,GAC5B,IAAMgC,EACJC,MAAMC,QAAQlC,IACdA,EAAamC,OACX,SAAAC,GAAW,MACc,mBAAhBA,GAAqD,IAAvBA,EAAYpI,UAUvD,OAPKgI,GACH3C,QAAQwC,KACN,kHAKGG,EAoQiBK,CAAqBrC,GAAe,CACtD,IAAMsC,EAAkBpE,OAAOqE,OAAO,CAAC,EAAGtC,EAAS,EAAKA,SAClDuC,EAAW,CAAE/B,OAAAA,EAAQrB,IAAAA,EAAKa,QAASqC,GAGnCG,GAFmBtB,EAEanB,EAFA,SAAA0C,GAAI,OACxCvB,EAAUwB,QAAO,SAACC,EAAOC,GAAE,OAAKA,EAAGD,EAAOJ,KAAWE,KAEvD7B,EAAU4B,EAAa5B,GAIrB,oBAAqB5B,GACnBA,EAAQ6D,kBACVjC,EAAQiC,iBAAkB,GAI1B,SAAU7D,EACZ4B,EAAQkC,KAAK9D,EAAQ1C,MAErBsE,EAAQkC,aAKd,8BAUS3D,EAAKa,EAASe,EAAcc,EAAkBgB,GACrD,OAAO5D,KAAK8D,aAAa5D,EAAK,MAAOa,EAAS,CAC5Ce,aAAAA,EACAc,iBAAAA,EACAgB,gBAAAA,OAIJ,6CAUwB1D,GAAqD,IAAhD6D,EAAS,UAAH,6CAAG,CAAC,EAAGnB,EAAgB,uCAAEgB,EAAe,uCACrEI,EAAqB9D,EAEH,WAAlB,EAAO6D,KACJhF,EAAcgF,KACjBC,GAAsBlE,EAAemE,sBAAsBF,KAG/D,IAAMhD,EAAU,CAAEmD,OAAQ7E,EAAWE,YAErC,OAAOS,KAAKmE,SACVH,EACAjD,EAHmB,OAKnB6B,EACAgB,MAIJ,4CAUuB1D,GAAqD,IAAhD6D,EAAS,UAAH,6CAAG,CAAC,EAAGnB,EAAgB,uCAAEgB,EAAe,uCACpEI,EAAqB9D,EAEH,WAAlB,EAAO6D,KACJhF,EAAcgF,KACjBC,GAAsBlE,EAAemE,sBAAsBF,KAG/D,IAAMhD,EAAU,CAAEmD,OAAQ7E,EAAWI,KAErC,OAAOO,KAAKmE,SACVH,EACAjD,EAHmB,OAKnB6B,EACAgB,MAIJ,mCAYE1D,EACAkE,GAIA,IAHAL,EAAS,UAAH,6CAAG,CAAC,EACVnB,EAAgB,uCAChBgB,EAAe,uCAEXI,EAAqB9D,EAEH,WAAlB,EAAO6D,KACJhF,EAAcgF,KACjBC,GAAsBlE,EAAemE,sBAAsBF,KAI/D,IAaMhD,EAAU,CAAEmD,OAJapE,EAAeuE,6BAC5CD,EAV0B,CAC1B,SACA,UACA,aACA,YACA,YACA,eASF,OAAOpE,KAAKmE,SACVH,EACAjD,EAHmB,cAKnB6B,EACAgB,MAIJ,kCAYE1D,EACAkE,GAIA,IAHAL,EAAS,UAAH,6CAAG,CAAC,EACVnB,EAAgB,uCAChBgB,EAAe,uCAEXI,EAAqB9D,EAEH,WAAlB,EAAO6D,KACJhF,EAAcgF,KACjBC,GAAsBlE,EAAemE,sBAAsBF,KAI/D,IAaMhD,EAAU,CAAEmD,OAJapE,EAAeuE,6BAC5CD,EAV0B,CAC1B,QACA,SACA,YACA,aACA,WACA,cASF,OAAOpE,KAAKmE,SACVH,EACAjD,EAHmB,cAKnB6B,EACAgB,MAIJ,mCAYE1D,EACAkE,GAIA,IAHAL,EAAS,UAAH,6CAAG,CAAC,EACVnB,EAAgB,uCAChBgB,EAAe,uCAEXI,EAAqB9D,EAEH,WAAlB,EAAO6D,KACJhF,EAAcgF,KACjBC,GAAsBlE,EAAemE,sBAAsBF,KAI/D,IAYMhD,EAAU,CAAEmD,OAJapE,EAAeuE,6BAC5CD,EAT0B,CAC1B,SACA,UACA,aACA,YACA,gBASF,OAAOpE,KAAKmE,SACVH,EACAjD,EAHmB,cAKnB6B,EACAgB,MAIJ,6BA0BA,eAcE1D,EACAkE,EACAE,EACAP,GAIA,IAEIQ,EAJJ3B,EAAgB,uCAChBgB,EAAe,uCAET7C,EAAU,CAAC,EAkCjB,OAtCW,UAAH,8CAONwD,EAAsB,CACpB,aACA,YACA,YACA,cAGFA,EAAsB,CACpB,sBAAuB,CAAC,qBACxB,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAAe,aAC1C,yBAA0B,CAAC,cAAe,aAC1C,yBAA0B,CAAC,aAC3B,yBAA0B,CAAC,aAC3B,yBAA0B,CAAC,aAC3B,yBAA0B,CAAC,cAGzBD,IACFvD,EAAQyD,MAAQ1E,EAAe2E,4BAA4BH,KAI/DvD,EAAQmD,OAASpE,EAAe4E,sCAC9BN,EACAG,GAGKvE,KAAKmE,SAASjE,EAAKa,EAAS,cAAe6B,EAAkBgB,MAGtE,4CAcE1D,EACAkE,EACAE,EACAP,GAIA,IAEIQ,EAJJ3B,EAAgB,uCAChBgB,EAAe,uCAET7C,EAAU,CAAC,EA+BjB,OAnCW,UAAH,8CAONwD,EAAsB,CACpB,SACA,UACA,cACA,YACA,eAGFA,EAAsB,CACpB,0BAA2B,CAAC,eAC5B,0BAA2B,CAAC,eAC5B,0BAA2B,CAAC,aAC5B,0BAA2B,CAAC,aAC5B,0BAA2B,CAAC,aAC5B,0BAA2B,CAAC,aAC5B,0BAA2B,CAAC,cAG1BD,IACFvD,EAAQyD,MAAQ1E,EAAe2E,4BAA4BH,KAI/DvD,EAAQmD,OAASpE,EAAe4E,sCAC9BN,EACAG,GAGKvE,KAAKmE,SAASjE,EAAKa,EAAS,cAAe6B,EAAkBgB,MAGtE,uDAaE1D,EACAkE,EACAL,EACAnB,EACAgB,GAEA,IAAM7C,EAAU,CAAC,EACX4D,EAAmB,oBACnBJ,EAAsB,CAC1B,sBAAuB,CAACI,GACxB,sBAAuB,CAACA,GACxB,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,0BAA2B,CAACA,GAC5B,0BAA2B,CAACA,GAC5B,0BAA2B,CAACA,GAC5B,0BAA2B,CAACA,GAC5B,0BAA2B,CAACA,GAC5B,0BAA2B,CAACA,GAC5B,0BAA2B,CAACA,IAG1BC,EAAuBR,EAU3B,OATKA,IACHQ,EAAuB,CAAC,CAAEC,UAAWF,KAGvC5D,EAAQmD,OAASpE,EAAe4E,sCAC9BE,EACAL,GAGKvE,KAAKmE,SAASjE,EAAKa,EAAS,cAAe6B,EAAkBgB,MAGtE,6DAeE1D,EACAkE,EACAE,EACAP,EACAnB,EACAgB,GAEA,IAAM7C,EAAU,CAAC,EAEXwD,EAAsB,CAC1B,sBAAuB,EAAIvF,OAAO8F,OAAOzF,KAGvCuF,EAAuBR,EAc3B,OAbKA,IACHQ,EAAuB,CAAC,CAAEC,UAPH,8BAUrBP,IACFvD,EAAQyD,MAAQ1E,EAAe2E,4BAA4BH,IAG7DvD,EAAQmD,OAASpE,EAAe4E,sCAC9BE,EACAL,GAGKvE,KAAKmE,SAASjE,EAAKa,EAAS,cAAe6B,EAAkBgB,MAGtE,+BAYU1D,EAAKa,EAAS1D,EAAMuF,EAAkBgB,EAAiBjC,GAC/D,OAAO3B,KAAK8D,aAAa5D,EAAK,OAAQa,EAAS,CAC7C1D,KAAAA,EACAuF,iBAAAA,EACAgB,gBAAAA,EACAjC,QAAAA,OAIJ,8CAUyBzB,EAAK7C,EAAMuF,EAAkBgB,GACpD,IAAM7C,EAAU,CAAE,eAAgB1B,EAAWE,YAC7C,OAAOS,KAAK+E,UACV7E,EACAa,EACA1D,EACAuF,EACAgB,MAIJ,uBAsNA,iBAO+B,IAAd7D,EAAU,UAAH,6CAAG,CAAC,EAC1BH,EAAS,sBACT,IAAIgE,GAAkB,EAClB1D,EAAM,GAAH,OAAMF,KAAKQ,QAAO,YASzB,MARI,gBAAiBT,IACnBG,GAAOJ,EAAemE,sBAAsBlE,EAAQiF,cAElD,oBAAqBjF,GACnBA,EAAQ6D,kBACVA,EAAkB7D,EAAQ6D,iBAGvB5D,KAAKiF,wBAAwB/E,EAAK,CAAC,GAAG,EAAO0D,MAGtD,2CAQsB7D,GACpB,KAAM,qBAAsBA,GAC1B,MAAM,IAAIlC,MACR,kEAGJ+B,EAAS,8BAAD,OAA+BG,EAAQmF,mBAC/C,IAAMhF,EAAM,GAAH,OAAMF,KAAKU,QAAO,oBAAYX,EAAQmF,iBAAgB,aAC3DtB,GAAkB,EAMtB,MALI,oBAAqB7D,GACnBA,EAAQ6D,kBACVA,EAAkB7D,EAAQ6D,iBAGvB5D,KAAKiF,wBAAwB/E,EAAK,CAAC,GAAG,EAAO0D,MAGtD,uCAQ8B,IAAd7D,EAAU,UAAH,6CAAG,CAAC,EACrBG,EAAMF,KAAKQ,QACX,qBAAsBT,IACxBH,EAAS,0BAAD,OAA2BG,EAAQmF,mBAC3ChF,GAAO,YAAJ,OAAgBH,EAAQmF,mBAE7BhF,GAAO,UACH,gBAAiBH,IACnBG,GAAOJ,EAAemE,sBAAsBlE,EAAQiF,cAEtD,IAAIpB,GAAkB,EAMtB,MALI,oBAAqB7D,GACnBA,EAAQ6D,kBACVA,EAAkB7D,EAAQ6D,iBAGvB5D,KAAKiF,wBAAwB/E,EAAK,CAAC,GAAG,EAAO0D,MAGtD,4CASuB7D,GACrB,KAAM,qBAAsBA,GAC1B,MAAM,IAAIlC,MACR,mEAGJ,KAAM,sBAAuBkC,GAC3B,MAAM,IAAIlC,MACR,oEAIJ+B,EAAS,+BAAD,OAAgCG,EAAQoF,oBAChD,IAAMjF,EAAM,GAAH,OAAMF,KAAKU,QAAO,oBAAYX,EAAQmF,iBAAgB,mBAAWnF,EAAQoF,kBAAiB,aAC/FvB,GAAkB,EAMtB,MALI,oBAAqB7D,GACnBA,EAAQ6D,kBACVA,EAAkB7D,EAAQ6D,iBAGvB5D,KAAKiF,wBAAwB/E,EAAK,CAAC,GAAG,EAAO0D,MAGtD,0CASiC,IAAd7D,EAAU,UAAH,6CAAG,CAAC,EACxBG,EAAMF,KAAKQ,QACXoD,GAAkB,EAyBtB,MAxBI,qBAAsB7D,GACxBG,GAAO,YAAJ,OAAgBH,EAAQmF,kBACvB,sBAAuBnF,GACzBH,EAAS,kCAAD,OAC4BG,EAAQoF,oBAE5CjF,GAAO,WAAJ,OAAeH,EAAQoF,oBAE1BvF,EAAS,iCAAD,OAC2BG,EAAQmF,oBAI7CtF,EAAS,wBAEXM,GAAO,aACH,gBAAiBH,IACnBG,GAAOJ,EAAemE,sBAAsBlE,EAAQiF,cAElD,oBAAqBjF,GACnBA,EAAQ6D,kBACVA,EAAkB7D,EAAQ6D,iBAGvB5D,KAAKiF,wBAAwB/E,EAAK,CAAC,GAAG,EAAO0D,MAGtD,6CAQwB7D,GACtB,KAAM,qBAAsBA,GAC1B,MAAM,IAAIlC,MAAM,mCAElB,KAAM,sBAAuBkC,GAC3B,MAAM,IAAIlC,MAAM,oCAElB,KAAM,mBAAoBkC,GACxB,MAAM,IAAIlC,MAAM,iCAGlB,IAAM2E,EAAczC,EAAQyC,aAAenD,EAAWC,MAChD8F,EAAiBrF,EAAQqF,gBAAkB,IAC3CrB,EAAS,GAEfA,EAAOnF,KAAK,oBACZmF,EAAOnF,KAAK,YAAD,OAAamB,EAAQmF,mBAChCnB,EAAOnF,KAAK,aAAD,OAAcmB,EAAQoF,oBACjCpB,EAAOnF,KAAK,aAAD,OAAcmB,EAAQsF,iBACjCtB,EAAOnF,KAAK,eAAD,OAAgB4D,IAC3BuB,EAAOnF,KAAK,kBAAD,OAAmBwG,IAE9B,IAAME,EAAcvB,EAAOwB,KAAK,KAEhC,MAAO,GAAP,OAAUvF,KAAKU,QAAO,YAAI4E,MAG5B,8CASyBvF,GACvB,KAAM,qBAAsBA,GAC1B,MAAM,IAAIlC,MACR,qEAGJ,KAAM,sBAAuBkC,GAC3B,MAAM,IAAIlC,MACR,sEAGJ,KAAM,mBAAoBkC,GACxB,MAAM,IAAIlC,MACR,mEAGJ+B,EAAS,iCAAD,OAAkCG,EAAQsF,iBAClD,IAAMnF,EAAM,GAAH,OAAMF,KAAKU,QAAO,oBAAYX,EAAQmF,iBAAgB,mBAAWnF,EAAQoF,kBAAiB,sBAAcpF,EAAQsF,eAAc,aACnIzB,GAAkB,EAMtB,MALI,oBAAqB7D,GACnBA,EAAQ6D,kBACVA,EAAkB7D,EAAQ6D,iBAGvB5D,KAAKiF,wBAAwB/E,EAAK,CAAC,GAAG,EAAO0D,MAGtD,4CASuB7D,GACrB,KAAM,qBAAsBA,GAC1B,MAAM,IAAIlC,MACR,mEAGJ,KAAM,sBAAuBkC,GAC3B,MAAM,IAAIlC,MACR,oEAGJ,KAAM,mBAAoBkC,GACxB,MAAM,IAAIlC,MACR,iEAGJ,KAAM,iBAAkBkC,GACtB,MAAM,IAAIlC,MACR,+DAGJ+B,EAAS,mBAAD,OACaG,EAAQyF,aAAatJ,WAAU,wBAChD6D,EAAQsF,iBAGZ,IAAMnF,EAAM,GAAH,OAAMF,KAAKU,QAAO,oBAAYX,EAAQmF,iBAAgB,mBAC7DnF,EAAQoF,kBAAiB,sBAEzBpF,EAAQsF,eAAc,mBACbtF,EAAQyF,aAAatJ,YAExBkI,EAAerE,EAAfqE,WACJR,GAAkB,EAClB,oBAAqB7D,GACnBA,EAAQ6D,kBACVA,EAAkB7D,EAAQ6D,iBAI9B,IAAIhB,GAAmB,EAKvB,GAJI,qBAAsB7C,IACxB6C,EAAmB7C,EAAQ6C,mBAGxBwB,EACH,OAAOpE,KAAKyF,wCACVvF,GACA,GACA,GACA,EACA0C,EACAgB,GAKJ,GADyB9D,EAAe4F,qBAAqBtB,GACxCtJ,OAAS,EAAG,CAM/B,IAiBMiG,EAAU,CACdmD,OAAQpE,EAAe4E,sCACrBN,EAnBwB,CAC1B,sBAAuB,CAAC,4BACxB,sBAAuB,CAAC,qBACxB,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAAe,aAC1C,yBAA0B,CAAC,cAAe,aAC1C,yBAA0B,CAAC,aAC3B,yBAA0B,CAAC,aAC3B,yBAA0B,CAAC,aAC3B,yBAA0B,CAAC,aAC3B,0BAA2B,CAAC,aAC5B,0BAA2B,CAAC,gBAS9B,OAAOpE,KAAKmE,SAASjE,EAAKa,EAAS,cAAe6B,EAAkBgB,GAGtE,IAAM+B,EAAkB7F,EAAe8F,oBAAoBxB,GAE3D,GAAIuB,EAAgBE,WAAW,eAC7B,OAAO7F,KAAKyF,wCACVvF,EACAkE,GACA,GACA,EACAxB,EACAgB,GAGJ,GAAI+B,EAAgBE,WAAW,SAC7B,OAAO7F,KAAK8F,uBACV5F,EACAkE,GACA,GACA,GACA,EACAxB,EACAgB,GAGJ,GAAI+B,EAAgBE,WAAW,SAC7B,OAAO7F,KAAK+F,uBACV7F,EACAkE,GACA,GACA,GACA,EACAxB,EACAgB,GAIJ,MAAM,IAAI/F,MAAM,cAAD,OACC8H,EAAe,kDAUjC,8CAWyB5F,GACvB,KAAM,qBAAsBA,GAC1B,MAAM,IAAIlC,MACR,qEAGJ,KAAM,sBAAuBkC,GAC3B,MAAM,IAAIlC,MACR,sEAGJ,KAAM,mBAAoBkC,GACxB,MAAM,IAAIlC,MACR,mEAIJ,IAAIqC,EAAM,GAAH,OAAMF,KAAKU,QAAO,oBAAYX,EAAQmF,iBAAgB,mBAAWnF,EAAQoF,kBAAiB,sBAAcpF,EAAQsF,eAAc,aAE7HjB,EAA4BrE,EAA5BqE,WAAYY,EAAgBjF,EAAhBiF,YAEhBpB,GAAkB,EAClB,oBAAqB7D,GACnBA,EAAQ6D,kBACVA,EAAkB7D,EAAQ6D,iBAI9B,IAAIhB,GAAmB,EAKvB,GAJI,qBAAsB7C,IACxB6C,EAAmB7C,EAAQ6C,mBAGxBwB,EAKH,OAHIY,IACF9E,GAAOJ,EAAemE,sBAAsBe,IAEvChF,KAAKmE,SACVjE,EAnBY,CAAC,EAcM,cAQnB0C,EACAgB,GAIJ,IAAM+B,EAAkB7F,EAAe8F,oBAAoBxB,GAC3D,GAAIuB,EAAgBE,WAAW,SAC7B,OAAO7F,KAAKgG,cACV9F,EACAkE,EACAY,EACApC,EACAgB,GAGJ,GAAI+B,EAAgBE,WAAW,SAC7B,OAAO7F,KAAKiG,cACV/F,EACAkE,EACAY,EACApC,EACAgB,GAGJ,GAAI+B,EAAgBE,WAAW,QAC7B,OAAO7F,KAAKkG,aACVhG,EACAkE,EACAY,EACApC,EACAgB,GAGJ,GAAI+B,IAAoBtG,EAAWI,IACjC,OAAOO,KAAKmG,uBACVjG,EACA8E,EACApC,EACAgB,GAIJ,MAAM,IAAI/F,MACR,qBAAc8H,EAAe,sBAC3B,0CAIN,+CAW0B5F,GACxB,KAAM,qBAAsBA,GAC1B,MAAM,IAAIlC,MACR,qEAGJ,KAAM,sBAAuBkC,GAC3B,MAAM,IAAIlC,MACR,sEAGJ,KAAM,mBAAoBkC,GACxB,MAAM,IAAIlC,MACR,mEAIJ,IAAIqC,EAAM,GAAH,OAAMF,KAAKU,QAAO,oBAAYX,EAAQmF,iBAAgB,mBAAWnF,EAAQoF,kBAAiB,sBAAcpF,EAAQsF,eAAc,cAE7HjB,EAA4BrE,EAA5BqE,WAAYY,EAAgBjF,EAAhBiF,YAEhBpB,GAAkB,EAClB,oBAAqB7D,GACnBA,EAAQ6D,kBACVA,EAAkB7D,EAAQ6D,iBAI9B,IAAIhB,GAAmB,EAKvB,GAJI,qBAAsB7C,IACxB6C,EAAmB7C,EAAQ6C,mBAGxBwB,EAKH,OAHIY,IACF9E,GAAOJ,EAAemE,sBAAsBe,IAEvChF,KAAKmE,SACVjE,EAnBY,CAAC,EAcM,cAQnB0C,EACAgB,GAIJ,IAAM+B,EAAkB7F,EAAe8F,oBAAoBxB,GAC3D,GAAIuB,EAAgBE,WAAW,SAC7B,OAAO7F,KAAKgG,cACV9F,EACAkE,EACAY,EACApC,EACAgB,GAIJ,MAAM,IAAI/F,MACR,qBAAc8H,EAAe,sBAC3B,0CAIN,oDAY+B5F,GAC7B,KAAM,qBAAsBA,GAC1B,MAAM,IAAIlC,MACR,4EAGJ,KAAM,sBAAuBkC,GAC3B,MAAM,IAAIlC,MACR,6EAGJ,KAAM,mBAAoBkC,GACxB,MAAM,IAAIlC,MACR,0EAGJ,KAAM,iBAAkBkC,GACtB,MAAM,IAAIlC,MACR,wEAIJ+B,EAAS,4BAAD,OACsBG,EAAQyF,aAAatJ,WAAU,wBACzD6D,EAAQsF,iBAGZ,IAAInF,EAAM,GAAH,OAAMF,KAAKU,QAAO,oBAAYX,EAAQmF,iBAAgB,mBAC3DnF,EAAQoF,kBAAiB,sBAEzBpF,EAAQsF,eAAc,mBACbtF,EAAQyF,aAAatJ,WAAU,aAElCkI,EAA4BrE,EAA5BqE,WAAYY,EAAgBjF,EAAhBiF,YAEhBpB,GAAkB,EAClB,oBAAqB7D,GACnBA,EAAQ6D,kBACVA,EAAkB7D,EAAQ6D,iBAG9B,IAAIhB,GAAmB,EAKvB,GAJI,qBAAsB7C,IACxB6C,EAAmB7C,EAAQ6C,mBAGxBwB,EAKH,OAHIY,IACF9E,GAAOJ,EAAemE,sBAAsBe,IAEvChF,KAAKmE,SAASjE,EAjBP,CAAC,EAaM,eAI4B,EAAO0D,GAG1D,IAAM+B,EAAkB7F,EAAe8F,oBAAoBxB,GAC3D,GAAIuB,EAAgBE,WAAW,SAC7B,OAAO7F,KAAKgG,cACV9F,EACAkE,EACAY,EACApC,EACAgB,GAGJ,GAAI+B,EAAgBE,WAAW,SAC7B,OAAO7F,KAAKiG,cACV/F,EACAkE,EACAY,EACApC,EACAgB,GAIJ,MAAM,IAAI/F,MACR,qBAAc8H,EAAe,sBAC3B,uCAIN,qDAWgC5F,GAC9B,KAAM,qBAAsBA,GAC1B,MAAM,IAAIlC,MACR,4EAGJ,KAAM,sBAAuBkC,GAC3B,MAAM,IAAIlC,MACR,6EAGJ,KAAM,mBAAoBkC,GACxB,MAAM,IAAIlC,MACR,0EAGJ,KAAM,iBAAkBkC,GACtB,MAAM,IAAIlC,MACR,wEAIJsC,QAAQgB,MAAM,4BAAD,OACiBpB,EAAQyF,aAAatJ,WAAU,wBACzD6D,EAAQsF,iBAGZ,IAAInF,EAAM,GAAH,OAAMF,KAAKU,QAAO,oBAAYX,EAAQmF,iBAAgB,mBAC3DnF,EAAQoF,kBAAiB,sBAEzBpF,EAAQsF,eAAc,mBACbtF,EAAQyF,aAAatJ,WAAU,cAElCkI,EAA4BrE,EAA5BqE,WAAYY,EAAgBjF,EAAhBiF,YAEhBpB,GAAkB,EAClB,oBAAqB7D,GACnBA,EAAQ6D,kBACVA,EAAkB7D,EAAQ6D,iBAI9B,IAAIhB,GAAmB,EAKvB,GAJI,qBAAsB7C,IACxB6C,EAAmB7C,EAAQ6C,mBAGxBwB,EAKH,OAHIY,IACF9E,GAAOJ,EAAemE,sBAAsBe,IAEvChF,KAAKmE,SACVjE,EAnBY,CAAC,EAcM,cAQnB0C,EACAgB,GAIJ,IAAM+B,EAAkB7F,EAAe8F,oBAAoBxB,GAC3D,GAAIuB,EAAgBE,WAAW,SAC7B,OAAO7F,KAAKgG,cACV9F,EACAkE,EACAY,EACApC,EACAgB,GAIJ,MAAM,IAAI/F,MACR,qBAAc8H,EAAe,sBAC3B,uCAIN,sCASiB5F,GACf,KAAM,qBAAsBA,GAC1B,MAAM,IAAIlC,MAAM,kCAElB,KAAM,sBAAuBkC,GAC3B,MAAM,IAAIlC,MAAM,mCAElB,KAAM,mBAAoBkC,GACxB,MAAM,IAAIlC,MAAM,gCAElB,IAAMqC,EAAM,GAAH,OAAMF,KAAKU,QAAO,oBAAYX,EAAQmF,iBAAgB,mBAAWnF,EAAQoF,kBAAiB,sBAAcpF,EAAQsF,gBAEjHjB,EAAerE,EAAfqE,WAAU,EACkBrE,EAA5B6D,gBAAAA,OAAe,IAAG,GAAK,IACM7D,EAA7B6C,iBAAAA,OAAgB,IAAG,GAAK,EAEhC,IAAKwB,EACH,OAAOpE,KAAKoG,kCACVlG,GACA,GACA,EACA0C,EACAgB,GACAyC,KAAKlH,GAGT,IAAMwG,EAAkB7F,EAAe8F,oBAAoBxB,GAC3D,GAAIuB,IAAoBtG,EAAWC,MACjC,OAAOU,KAAKoG,kCACVlG,EACAkE,GACA,EACAxB,EACAgB,GACAyC,KAAKlH,GAGT,MAAM,IAAItB,MAAM,cAAD,OACC8H,EAAe,oDAIjC,oCASe5F,GACb,KAAM,qBAAsBA,GAC1B,MAAM,IAAIlC,MAAM,kCAElB,KAAM,sBAAuBkC,GAC3B,MAAM,IAAIlC,MAAM,mCAGlB,IAAMqC,EAAM,GAAH,OAAMF,KAAKU,QAAO,oBAAYX,EAAQmF,iBAAgB,mBAAWnF,EAAQoF,mBAE1Ef,EAAerE,EAAfqE,WACJR,GAAkB,EAClB,oBAAqB7D,GACnBA,EAAQ6D,kBACVA,EAAkB7D,EAAQ6D,iBAI9B,IAAIhB,GAAmB,EAKvB,GAJI,qBAAsB7C,IACxB6C,EAAmB7C,EAAQ6C,mBAGxBwB,EACH,OAAOpE,KAAKoG,kCACVlG,GACA,GACA,EACA0C,EACAgB,GAIJ,IAAM+B,EAAkB7F,EAAe8F,oBAAoBxB,GAC3D,GAAIuB,IAAoBtG,EAAWC,MACjC,OAAOU,KAAKoG,kCACVlG,EACAkE,GACA,EACAxB,EACAgB,GAIJ,MAAM,IAAI/F,MAAM,cAAD,OACC8H,EAAe,kDAIjC,mCAOc5F,GACZ,KAAM,qBAAsBA,GAC1B,MAAM,IAAIlC,MAAM,kCAGlB,IAAMqC,EAAM,GAAH,OAAMF,KAAKU,QAAO,oBAAYX,EAAQmF,kBAEvCd,EAAerE,EAAfqE,WAAU,EACkBrE,EAA5B6D,gBAAAA,OAAe,IAAG,GAAK,IACM7D,EAA7B6C,iBAAAA,OAAgB,IAAG,GAAK,EAEhC,IAAKwB,EACH,OAAOpE,KAAKoG,kCACVlG,GACA,GACA,EACA0C,EACAgB,GAIJ,IAAM+B,EAAkB7F,EAAe8F,oBAAoBxB,GAC3D,GAAIuB,IAAoBtG,EAAWC,MACjC,OAAOU,KAAKoG,kCACVlG,EACAkE,GACA,EACAxB,EACAgB,GAIJ,MAAM,IAAI/F,MAAM,cAAD,OACC8H,EAAe,iDAIjC,sCAaiB5F,GACf,KAAM,gBAAiBA,GACrB,MAAM,IAAIlC,MAAM,4BAGlB,IAAMqC,EAAMH,EAAQuG,YACZlC,EAA0BrE,EAA1BqE,WAAYE,EAAcvE,EAAduE,UAAS,EACOvE,EAA5B6D,gBAAAA,OAAe,IAAG,GAAK,IACM7D,EAA7B6C,iBAAAA,OAAgB,IAAG,GAAK,EAEhC,IAA6C,IAAzC5C,KAAKa,WAAW6B,QAAQ,YAC1B,OAAO1C,KAAKmE,SAASjE,EAAKH,EAAQgB,QAAS,cAAe,KAAM6C,GAGlE,GAAIQ,EACF,IAGE,GAAsB,WAFEtE,EAAe8F,oBAAoBxB,GAGzD,OAAOpE,KAAK8F,uBACV5F,EACAkE,EACAE,GACA,GACA,EACA1B,EACAgB,GAGJ,MAAM2C,IAMV,OAAOvG,KAAKyF,wCACVvF,EACAkE,EACAE,GACA,EACA1B,EACAgB,MAIJ,oCASe7D,GACb,KAAM,aAAcA,GAClB,MAAM,IAAIlC,MAAM,qCAGlB,IAAIqC,EAAM,GAAH,OAAMF,KAAKY,QAAO,YACrB,qBAAsBb,IACxBG,GAAO,IAAJ,OAAQH,EAAQmF,mBACpB,MAE0BtJ,EAAgBmE,EAAQlE,UAA3CwB,EAAI,EAAJA,KAAMvB,EAAQ,EAARA,SACRiF,EAAU,CACd,eAAgB,0DAAF,OAA4DjF,EAAQ,MAClF,EACkCiE,EAA5B6D,gBAAAA,OAAe,IAAG,GAAK,EAC/B,OAAO5D,KAAK+E,UACV7E,EACAa,EACA1D,EACA0C,EAAQ6C,iBACRgB,EACA7D,EAAQ4B,gBAEX,6CArxDyC,IAAboC,EAAS,UAAH,6CAAG,CAAC,EACjCyC,EAAc,IAOlB,OANAxH,OAAOC,KAAK8E,GAAQ3G,SAAQ,SAAC2E,EAAKzG,GAClB,IAAVA,IACFkL,GAAe,KAEjBA,GAAe,GAAJ,OAAOzE,EAAG,YAAI0E,mBAAmB1C,EAAOhC,QAE9CyE,KACR,6CA+V8B3B,GAC7B,IAAKA,EACH,MAAM,IAAIhH,MAAM,2BAAD,OAA4BgH,IAG7C,IAAM6B,EAAW7B,EAAUnC,QAAQ,KACnC,IAAkB,IAAdgE,EACF,MAAM,IAAI7I,MAAM,2BAAD,OAA4BgH,IAG7C,IAAM8B,EAAgB9B,EAAUlG,MAAM,EAAG+H,GAEzC,IADc,CAAC,cAAe,QAAS,OAAQ,SACpCE,SAASD,GAClB,MAAM,IAAI9I,MAAM,2BAAD,OAA4BgH,IAG7C,GAAIA,EAAUlG,MAAM+H,EAAW,GAAGE,SAAS,KACzC,MAAM,IAAI/I,MAAM,2BAAD,OAA4BgH,OAE9C,qCA2QsBA,GAGrB,OAFA/E,EAAe+G,wBAAwBhC,GAEhCA,EAAUzG,MAAM,QAGzB,kDAQoCgG,EAAYG,GAC9C,IAAKxB,MAAMC,QAAQoB,GACjB,MAAM,IAAIvG,MAAM,uDAgBlB,OAbwBuG,EAAWvH,KAAI,SAAAiK,GAAQ,IACrCjC,EAAciC,EAAdjC,UAGR,GADA/E,EAAe+G,wBAAwBhC,IAClCN,EAAoBqC,SAAS/B,GAChC,MAAM,IAAIhH,MAAM,cAAD,OACCgH,EAAS,6CAI3B,OAAOA,KAGcU,KAAK,SAG9B,2DAYEnB,EACAG,GACA,WACA,IAAKxB,MAAMC,QAAQoB,GACjB,MAAM,IAAIvG,MAAM,uDAGlB,IAAKkF,MAAMC,QAAQuB,KAAyB1F,EAAS0F,GACnD,MAAM,IAAI1G,MACR,mEAIJ,IAAMkJ,EAAkB,GAwExB,GAtEA3C,EAAWhH,SAAQ,SAAA0J,GAAQ,IACjBE,EAAiCF,EAAjCE,kBAAmBnC,EAAciC,EAAdjC,UAC3B/E,EAAe+G,wBAAwBhC,GACvC,IAAIoC,EAAa,4BAAH,OAA+BpC,EAAS,KAEtD,GAAIhG,EAAS0F,GAAsB,CAGjC,KACGvF,OAAO8F,OAAOP,GACZ2C,KAAK,GACLN,SAAS/B,IAEPA,EAAUsC,SAAS,OAAUtC,EAAUsC,SAAS,MAInD,YAHAvH,EAAS,cAAD,OACQiF,EAAS,6CAM7B,GAAImC,EAAmB,CACrB,GAA0B,MAAtBA,EAA2B,CAC7B,IAAKhI,OAAOC,KAAKsF,GAAqBqC,SAASI,GAC7C,MAAM,IAAInJ,MAAM,mBAAD,OACMmJ,EAAiB,6CAIxC,IAAMI,EAAqB7C,EAAoByC,GAE/C,IAAKI,EAAmBR,SAAS/B,GAAY,CAC3C,IAAMwC,EAAavH,EAAewH,gBAAgBzC,GAAW,GAC7DuC,EAAmBvK,KAAI,SAAA0K,GACrB,IAAMC,EAAe1H,EAAewH,gBAClCC,GACA,GAGF,GAFqBF,IAAeG,IAIjC3C,EAAUsC,SAAS,QAAStC,EAAUsC,SAAS,KAKlD,MAAM,IAAItJ,MAAM,mBAAD,OACMmJ,EAAiB,iDAM5CC,GAAc,qBAAJ,OAAyBD,SAEhC,GACLjE,MAAMC,QAAQuB,KACbA,EAAoBqC,SAAS/B,GAO9B,YALI,EAAK5D,SACPd,QAAQwC,KAAK,cAAD,OACIkC,EAAS,8CAM7BkC,EAAgBnI,KAAKqI,OAGlBF,EAAgBjM,OACnB,MAAM,IAAI+C,MAAM,yCAAD,OAA0C4J,KAAKC,UAAUtD,KAG1E,OAAO2C,EAAgBxB,KAAK,SAG9B,mDAOmD,IAAhBjB,EAAY,UAAH,6CAAG,GAC7C,OAAyB,IAArBA,EAAUxJ,OACL,SAAP,OAAgBwJ,EAAU,GAAE,KAEL,IAArBA,EAAUxJ,OACL,SAAP,OAAgBwJ,EAAU,GAAE,YAAIA,EAAU,IAGrC,cAGT,0CAQ4BF,GAC1B,IAAMuD,EAAQ,IAAIC,IAElB,OAAKxD,GAAeA,EAAWtJ,QAI/BsJ,EAAWhH,SAAQ,SAAA0J,GAAQ,IACjBjC,EAAciC,EAAdjC,UACFgD,EAAO/H,EAAewH,gBAAgBzC,GAAW,GACvD8C,EAAMG,IAAI,GAAD,OAAID,EAAI,SAGZ9E,MAAMgF,KAAKJ,IATTA,KAYX,yCAW2BvD,GACzB,IAAKA,IAAeA,EAAWtJ,OAC7B,MAAM,IAAI+C,MAAM,sCAGlB,IAAMmK,EAAmBlI,EAAe4F,qBAAqBtB,GAC7D,GAAgC,IAA5B4D,EAAiBlN,OACnB,MAAM,IAAI+C,MAAM,wDACX,GAAImK,EAAiBlN,OAAS,EACnC,MAAM,IAAI+C,MAAM,mDAGlB,OAAOmK,EAAiB,uFACzB,EAz8BiB,4BGnDpBC,EAAOC,QARP,SAAcC,GAEZ,IADA,IAAI/I,EAAS,IAAI2D,MAAMoF,GACfpN,EAAE,EAAGA,EAAEoN,IAAKpN,EAClBqE,EAAOrE,GAAKA,EAEd,OAAOqE,CACT,YCDA6I,EAAOC,QAAU,SAAmBpJ,GAClC,OAAc,MAAPA,GAAkC,MAAnBA,EAAII,aACY,mBAA7BJ,EAAII,YAAYkJ,UAA2BtJ,EAAII,YAAYkJ,SAAStJ,EAC/E,mBCVA,IAAIuJ,EAAO,EAAQ,OACfD,EAAW,EAAQ,MAEnBE,EAA6C,oBAAlBC,aAE/B,SAASC,EAAWC,EAAGC,GACrB,OAAOD,EAAE,GAAKC,EAAE,EAClB,CAEA,SAASC,IACP,IAEI5N,EAFA6N,EAAS5I,KAAK4I,OACdC,EAAQ,IAAI9F,MAAM6F,EAAO9N,QAE7B,IAAIC,EAAE,EAAGA,EAAE8N,EAAM/N,SAAUC,EACzB8N,EAAM9N,GAAK,CAACW,KAAKoN,IAAIF,EAAO7N,IAAKA,GAEnC8N,EAAME,KAAKP,GACX,IAAIpJ,EAAS,IAAI2D,MAAM8F,EAAM/N,QAC7B,IAAIC,EAAE,EAAGA,EAAEqE,EAAOtE,SAAUC,EAC1BqE,EAAOrE,GAAK8N,EAAM9N,GAAG,GAEvB,OAAOqE,CACT,CAEA,SAAS4J,EAAmBC,EAAOC,GACjC,IAAIC,EAAY,CAAC,OAAQD,EAAW,IAAKD,GAAO1D,KAAK,IAClD2D,EAAY,IACbC,EAAY,WAAaF,GAE3B,IAAIG,EAAwB,YAAVH,EAElB,IAAkB,IAAfC,EAAkB,CAEnB,IAAIG,EACF,YAAYF,EAAU,+BAChBA,EAAU,2BACPF,EAAM,kLAMGE,EAAU,+GAGNA,EAAU,kBAAkBA,EAAU,QAE9D,OADgB,IAAIG,SAASD,EACtBE,EACT,CAAO,GAAiB,IAAdL,EAAiB,CAErBG,EACF,YAAYF,EAAU,mDAIhBA,EAAU,2BACPF,EAAM,6KAUCE,EAAU,uBACnBA,EAAU,gDAEDA,EAAU,6EAGGA,EAAU,kBACnCC,EAAa,6BAA+B,0BACtD,wBACqBD,EAAU,mBACrBC,EAAa,+BAAiC,4BAA4B,+BAExDD,EAAU,wBAAwBA,EAAU,SAEpE,OADgB,IAAIG,SAAS,eAAgBD,EACtCE,CAAUC,EAAoBP,GAAO,GAC9C,CAEII,EAAO,CAAC,gBAAZ,IAGII,EAAUpB,EAAKa,GACf1F,EAAOiG,EAAQ5M,KAAI,SAAS9B,GAAK,MAAO,IAAIA,CAAE,IAC9C2O,EAAY,eAAiBD,EAAQ5M,KAAI,SAAS9B,GAChD,MAAO,eAAiBA,EAAI,MAAQA,CACtC,IAAGwK,KAAK,KACRoE,EAAWF,EAAQ5M,KAAI,SAAS9B,GAChC,MAAO,IAAIA,CACb,IAAGwK,KAAK,KACNqE,EAAYH,EAAQ5M,KAAI,SAAS9B,GACjC,MAAO,IAAIA,CACb,IAAGwK,KAAK,KACV8D,EAAKzK,KACH,YAAYuK,EAAU,MAAQQ,EAAW,IAAMC,EAAY,kBACzD,eAAiBD,EAAW,IAC5B,gBAAkBC,EAAY,IAC9B,mBACF,aAAaT,EAAU,aACvB,gBAAgBF,EAAM,IACtB,mBAAmBC,GAGrBG,EAAKzK,KAAK,oDAAoDuK,EAAU,kBACjEM,EAAQ5M,KAAI,SAAS9B,GAAK,MAAO,cAAcA,EAAE,GAAI,IAAGwK,KAAK,KACtE,OAGmB,IAAd2D,EACDG,EAAKzK,KAAK,oBAEVyK,EAAKzK,KAAK,6CACPsK,EAAY,GACbG,EAAKzK,KAAK,YAAYuK,EAAU,aACf,IAAdD,EACDG,EAAKzK,KAAK,6EACY,IAAdsK,GACRG,EAAKzK,KACb,4QAkBMyK,EAAKzK,KAAK,YAKdyK,EAAKzK,KACP,sBAAsBuK,EAAU,QAAQ3F,EAAK+B,KAAK,KAAK,QAClD6D,EACDC,EAAKzK,KAAK,wBAAwB8K,EAAU,QAE5CL,EAAKzK,KAAK,oBAAoB8K,EAAU,QAI1CL,EAAKzK,KAAK,sBAAsBuK,EAAU,QAAQ3F,EAAK+B,KAAK,KAAK,MAC9D6D,EACDC,EAAKzK,KAAK,wBAAwB8K,EAAU,MAE5CL,EAAKzK,KAAK,oBAAoB8K,EAAU,MAI1CL,EAAKzK,KACH,wBAAwBuK,EAAU,UAAW3F,EAAK+B,OAAQ,YAAYmE,EAAU,KAGlFL,EAAKzK,KAAK,qBAAqBuK,EAAU,OAAO3F,EAAK+B,KAAK,KAAK,gBAAgB4D,EAAU,cACvFM,EAAQ5M,KAAI,SAAS9B,GACnB,MAAO,CAAC,YAAYA,EAAE,iBAAiBA,EAAE,kBAAmBA,EAAG,MAAOA,EAAE,MAAMwK,KAAK,GACrF,IAAGA,KAAK,KAAK,IACbkE,EAAQ5M,KAAI,SAAS9B,GACnB,MAAO,eAAeA,EAAI,GAC5B,IAAGwK,KAAK,KAAK,kBAGf,IAAIsE,EAASJ,EAAQ5M,KAAI,SAAS9B,GAAK,MAAO,IAAIA,EAAE,eAAeA,EAAE,GAAI,IACrE+O,EAASL,EAAQ5M,KAAI,SAAS9B,GAAK,MAAO,IAAIA,EAAE,gBAAgBA,EAAE,GAAI,IAC1EsO,EAAKzK,KAAK,qBAAqBuK,EAAU,OAAO3F,EAAK+B,KAAK,KAAK,2BAA2BsE,EAAOtE,KAAK,KAAK,IAAIuE,EAAOvE,KAAK,MAC3H,IAAI,IAAIxK,EAAE,EAAGA,EAAEmO,IAAanO,EAC1BsO,EAAKzK,KACT,cAAc7D,EAAE,iBAAiBA,EAAE,WAC9BA,EAAE,UACDA,EAAE,OACLA,EAAE,QAEHsO,EAAKzK,KAAK,cAAcuK,EAAU,cAChCM,EAAQ5M,KAAI,SAAS9B,GACnB,MAAO,IAAIA,CACb,IAAGwK,KAAK,KAAK,IACbkE,EAAQ5M,KAAI,SAAS9B,GACnB,MAAO,IAAIA,CACb,IAAGwK,KAAK,KAAK,QAGf8D,EAAKzK,KAAK,uBAAuBuK,EAAU,SAAS3F,EAAK+B,KAAK,KAAK,SACjEkE,EAAQ5M,KAAI,SAAS9B,GACnB,MAAO,IAAIA,EAAE,eAAeA,EAAE,GAChC,IAAGwK,KAAK,KAAK,IACbkE,EAAQ5M,KAAI,SAAS9B,GACnB,MAAO,IAAIA,EAAE,gBAAgBA,EAAE,GACjC,IAAGwK,KAAK,KAAK,qCACf,IAAQxK,EAAE,EAAGA,EAAEmO,IAAanO,EAC1BsO,EAAKzK,KACT,cAAc7D,EAAE,mBACXA,EAAE,kBAEDA,EAAE,MAAMA,EAAE,QACbA,EAAE,WAAWA,EAAE,aAEfA,EAAE,UAAUA,EAAE,QAEdA,EAAE,QAGHsO,EAAKzK,KAAK,cAAcuK,EAAU,cAChCM,EAAQ5M,KAAI,SAAS9B,GACnB,MAAO,IAAMA,CACf,IAAGwK,KAAK,KAAK,IACbkE,EAAQ5M,KAAI,SAAS9B,GACnB,MAAO,IAAMA,CACf,IAAGwK,KAAK,KAAK,QAGf,IAAIwE,EAAS,IAAIhH,MAAMmG,GACnBc,EAAU,IAAIjH,MAAMmG,GACxB,IAAQnO,EAAE,EAAGA,EAAEmO,IAAanO,EAC1BgP,EAAOhP,GAAK,MAAMA,EAAE,IACpBiP,EAAQjP,GAAK,MAAMA,EAAE,IAEvBsO,EAAKzK,KAAK,4BAA4BuK,EAAU,cAAc3F,EAAK,KACjEA,EAAK3G,KAAI,SAASsL,EAAE8B,GAAO,OAAO9B,EAAI,KAAOA,EAAI,gBAAkB8B,EAAM,IAAM9B,EAAI,KAAK,IAAG5C,KAAK,KAChG,6CAA6C4D,EAAU,cAAcY,EAAOxE,KAAK,KAAK,IAAIyE,EAAQzE,KAAK,KAAK,kBAG9G8D,EAAKzK,KAAK,uBAAuBuK,EAAU,SAAS3F,EAAK,iCACzD,IAAQzI,EAAE,EAAGA,EAAEmO,IAAanO,EAC1BsO,EAAKzK,KAAK,cAAc7D,EAAE,iBAAiBA,EAAE,yBAAyBA,EAAE,MAAMA,EAAE,8BAA8BA,EAAE,yBAAyBA,EAAE,OAe7I,OAbAsO,EAAKzK,KAAK,gEAGVyK,EAAKzK,KAAK,6BAA6BuK,EAAU,yCAAyCA,EAAU,SAClGM,EAAQ5M,KAAI,SAAS9B,GACnB,MAAO,SAASA,EAAE,GACpB,IAAGwK,KAAK,KAAK,IACbkE,EAAQ5M,KAAI,SAAS9B,GACnB,MAAO,UAAUA,EAAE,GACrB,IAAGwK,KAAK,KAAK,aAGC,IAAI+D,SAAS,YAAa,QAASD,EAAK9D,KAAK,MACtDgE,CAAUC,EAAoBP,GAAQN,EAC/C,CAsCA,IAAIa,EAAsB,CACxB,QAAU,GACV,QAAU,GACV,KAAO,GACP,MAAQ,GACR,MAAQ,GACR,MAAQ,GACR,OAAS,GACT,OAAS,GACT,MAAQ,GACR,cAAgB,GAChB,SAAY,GACZ,UAAa,GACb,OAAS,GACT,QAAU,IA4CZvB,EAAOC,QAnCP,SAA4B7K,EAAM6M,EAAOtB,EAAQvN,GAC/C,QAAY8O,IAAT9M,EAED,OADI+M,EAAOZ,EAAoBa,MAAM,IACzB,IACY,iBAAThN,IACfA,EAAO,CAACA,SAEG8M,IAAVD,IACDA,EAAQ,CAAE7M,EAAKvC,SAEjB,IAAIwP,EAAIJ,EAAMpP,OACd,QAAcqP,IAAXvB,EAAsB,CACvBA,EAAS,IAAI7F,MAAMuH,GACnB,IAAI,IAAIvP,EAAEuP,EAAE,EAAGC,EAAG,EAAGxP,GAAG,IAAKA,EAC3B6N,EAAO7N,GAAKwP,EACZA,GAAML,EAAMnP,EAEhB,CACA,QAAcoP,IAAX9O,EAAsB,CACvBA,EAAS,EACT,IAAQN,EAAE,EAAGA,EAAEuP,IAAKvP,EACf6N,EAAO7N,GAAK,IACbM,IAAW6O,EAAMnP,GAAG,GAAG6N,EAAO7N,GAGpC,CAGA,IAFA,IAAIkO,EArFN,SAAoB5L,GAClB,GAAG+K,EAAS/K,GACV,MAAO,SAET,GAAGiL,EACD,OAAOtJ,OAAOwL,UAAUtO,SAASuO,KAAKpN,IACpC,IAAK,wBACH,MAAO,UACT,IAAK,wBACH,MAAO,UACT,IAAK,qBACH,MAAO,OACT,IAAK,sBACH,MAAO,QACT,IAAK,sBACH,MAAO,QACT,IAAK,sBACH,MAAO,QACT,IAAK,uBACH,MAAO,SACT,IAAK,uBACH,MAAO,SACT,IAAK,6BACH,MAAO,gBACT,IAAK,yBACH,MAAO,WACT,IAAK,0BACH,MAAO,YAGb,OAAG0F,MAAMC,QAAQ3F,GACR,QAEF,SACT,CAmDcqN,CAAWrN,GACnBsN,EAAYnB,EAAoBP,GAC9B0B,EAAU7P,QAAUwP,EAAE,GAC1BK,EAAU/L,KAAKoK,EAAmBC,EAAO0B,EAAU7P,OAAO,IAG5D,OADIsP,EAAOO,EAAUL,EAAE,IACXjN,EAAM6M,EAAOtB,EAAQvN,EACnC,0BC1VA4M,EAAOC,QAAU,CAIhB0C,OAJgB,SAITC,EAAGC,GAIT,IAHA,IAAIC,EAAMF,EAAG/P,OACTkQ,EAAM,EAEFjQ,EAAE,EAAEA,EAAEgQ,EAAIhQ,IAAK,CACtB,IAAIuP,GAAKO,EAAG9P,IAAI,IAAM+P,EAAG/P,IAAI,GAC7BiQ,GAAOV,EAAEA,CACT,CAED,OAAOU,CACP,EAEDC,QAhBgB,SAgBRJ,EAAGC,GAIV,IAHA,IAAIC,EAAMF,EAAG/P,OACTkQ,EAAM,EAAGV,EAAI,EAETvP,EAAE,EAAEA,EAAEgQ,EAAIhQ,IAEjBiQ,IADAV,GAAKO,EAAG9P,IAAI,IAAM+P,EAAG/P,IAAI,KACd,EAAIuP,GAAKA,EAGrB,OAAOU,CACP,EAKDE,KA/BgB,SA+BXL,EAAGC,EAAGK,GACV,IAAIb,EAAI5O,KAAKoN,IAAI+B,EAAGC,GACpB,OAAOK,EAAMb,EAAIA,EAAEA,CACnB,gCClCF,IACCc,EAAWC,EAAQ,OACnBT,EAASQ,EAASR,OAClBM,EAAOE,EAASF,KAEjBjD,EAAOC,QAAU,CAChBoD,OADgB,SACTjO,EAAKkO,GAKX,IAJA,IAAI1O,EAAM,CAAC,EAAG2O,EAAK,GAAIC,EAAIF,GAAG,EAC1BR,EAAM1N,EAAKvC,OACX4Q,EAAQrO,EAAK,GAAGvC,OAAO,EAErB0Q,EAAG1Q,OAAOyQ,GAAME,KAAK,GAAG,CAC7B,IAAInB,EAAIjN,EAAK3B,KAAKM,MAAMN,KAAKO,SAAS8O,IAClChJ,EAAM2J,EAAOpB,EAAE/E,KAAK,KAAT,UAAmB+E,GAC9BzN,EAAIkF,KACPlF,EAAIkF,IAAO,EACXyJ,EAAG5M,KAAK0L,GAET,CAED,GAAGkB,EAAG1Q,OAAOyQ,EAAG,MAAM,IAAI1N,MAAM,iCAC3B,OAAO2N,CACZ,EAKDG,KAtBgB,SAsBXtO,EAAKkO,EAAEK,GACX,IAAIC,EAAWD,IAAWvO,EAAK,GAAGvC,OAAQ8P,EAASM,GAC/CM,EAAK,GAAIT,EAAM1N,EAAKvC,OACpB4Q,EAAQrO,EAAK,GAAGvC,OAAO,EAIvBgR,EAAIzO,EAAK3B,KAAKM,MAAMN,KAAKO,SAAS8O,IAC5BW,EAAOI,EAAEvG,KAAK,KAAT,UAAmBuG,GAKlC,IAJAN,EAAG5M,KAAKkN,GAIFN,EAAG1Q,OAAOyQ,GAAG,CAKlB,IAHA,IAAIQ,EAAQ,GAAIC,EAAKR,EAAG1Q,OACpBmR,EAAO,EAAGC,EAAM,GAEZnR,EAAE,EAAEA,EAAEgQ,EAAIhQ,IAAK,CAEtB,IADA,IAAIY,EAAMwQ,IACFnR,EAAE,EAAEA,EAAEgR,EAAGhR,IAAK,CACrB,IAAIkQ,EAAOW,EAASxO,EAAKtC,GAAGyQ,EAAGxQ,IAC5BkQ,GAAMvP,IAAKA,EAAMuP,EACpB,CACDa,EAAMhR,GAAKY,CACX,CAGD,IAAI,IAAIZ,EAAE,EAAEA,EAAEgQ,EAAIhQ,IACjBkR,GAAQF,EAAMhR,GAIf,IAAI,IAAIA,EAAE,EAAEA,EAAEgQ,EAAIhQ,IACjBmR,EAAInR,GAAK,CAACA,EAAEA,EAAGqR,EAAE/O,EAAKtC,GAAIsR,GAAGN,EAAMhR,GAAGkR,EAAMK,GAAG,GAIhDJ,EAAInD,MAAK,SAACN,EAAEC,GAAH,OAAOD,EAAE4D,GAAG3D,EAAE2D,EAAd,IAGTH,EAAI,GAAGI,GAAKJ,EAAI,GAAGG,GACnB,IAAI,IAAItR,EAAE,EAAEA,EAAEgQ,EAAIhQ,IACjBmR,EAAInR,GAAGuR,GAAKJ,EAAInR,EAAE,GAAGuR,GAAKJ,EAAInR,GAAGsR,GAQlC,IAJA,IAAIE,EAAM7Q,KAAKO,SAGXgO,EAAM,EACJA,EAAIc,EAAI,GAAKmB,EAAIjC,KAAOqC,GAAGC,IACjCf,EAAG5M,KAAKsN,EAAIjC,EAAI,GAAGmC,EAiBnB,CAED,OAAOZ,CACP,gCCjGF,IACCJ,EAAWC,EAAQ,OACnBmB,EAAcnB,EAAQ,MACtBT,EAASQ,EAASR,OAGlBU,GAFUF,EAASH,QACTG,EAASF,KACVsB,EAAYlB,QACrBK,EAAOa,EAAYb,KAOpB,SAASc,EAAK1B,EAAI2B,EAAIN,GACrBA,EAAIA,GAAK,GACT,IAAI,IAAIrR,EAAE,EAAEA,EAAEgQ,EAAIhQ,IAAKqR,EAAErR,GAAK2R,EAC9B,OAAON,CACP,CAED,SAASO,EAAKC,EAAOhB,GAQpB,IAPA,IACCF,EAAQ3I,MAAMC,QAAQ4J,GACtBpB,EAAKxL,KAAK6M,UACVtB,EAAIC,EAAG1Q,OAGJa,EAAMwQ,IAAUlC,EAAM,EAClBjP,EAAE,EAAEA,EAAEuQ,EAAEvQ,IAAK,CAEpB,IAAIkQ,EAAOU,EAAQA,EAAOgB,EAAMpB,EAAGxQ,IAC7B0Q,EAAOd,EAAOgC,EAAMpB,EAAGxQ,IACvBU,KAAKoN,IAAI8D,EAAMpB,EAAGxQ,IAErBkQ,GAAMvP,IACRA,EAAMuP,EACNjB,EAAMjP,EAEP,CAED,MAAO,CACNiP,IAAAA,EAAK6C,SAAStB,EAAGvB,GAElB,CAyIDhC,EAAOC,QAvIP,SAAiB7K,EAAKkO,EAAEwB,EAAQC,EAAMpB,GACrC,IAAIJ,EAAK,GAAIyB,EAAM,GAAIC,EAAO,GAAIhC,EAAO,GACrCiC,GAAO,EAAOC,EAAKJ,GAtCZ,IAuCPjC,EAAM1N,EAAKvC,OAAQuS,EAAOhQ,EAAK,GAAGvC,OAAQ4Q,EAAQ2B,EAAK,EACvDC,EAAQ,GAEZ,GAAIP,EAWHvB,EADgB,UAATuB,EACFzB,EAAOjO,EAAKkO,GAED,QAATwB,EACFpB,EAAKtO,EAAKkO,EAAEK,GAGZmB,OAfL,IADA,IAAIG,EAAO,CAAC,EAAGK,EAAE,EACX/B,EAAG1Q,OAAOyQ,GAAG,CAClB,IAAItB,EAAMvO,KAAKM,MAAMN,KAAKO,SAAS8O,GAC/BmC,EAAKjD,KACRiD,EAAKjD,IAAO,EACZuB,EAAG+B,KAAOlQ,EAAK4M,GAEhB,CAYF,EAAG,CAEFwC,EAAKlB,EAAE,EAAE+B,GAGT,IAAI,IAAIvS,EAAE,EAAEA,EAAEgQ,EAAIhQ,IAAK,CAEtB,IADA,IAAIY,EAAMwQ,IAAUlC,EAAM,EAClBjP,EAAE,EAAEA,EAAEuQ,EAAEvQ,IAAK,EAEhBkQ,EAAOU,EAASA,EAAOvO,EAAKtC,GAAGyQ,EAAGxQ,IAChC0Q,EAAOd,EAAOvN,EAAKtC,GAAGyQ,EAAGxQ,IACzBU,KAAKoN,IAAIzL,EAAKtC,GAAGyQ,EAAGxQ,MAEjBW,IACRA,EAAMuP,EACNjB,EAAMjP,EAEP,CACDkS,EAAKnS,GAAKkP,EACVqD,EAAMrD,IACN,CAGD,IAAIe,EAAM,GAAIiC,EAAM,GACpB,GAAGvB,EACF,IAAI,IAAI1Q,EAAE,EAAEA,EAAEuQ,EAAEvQ,IACfgQ,EAAIhQ,GAAKyR,EAAKY,EAAK,EAAErC,EAAIhQ,IACzBiS,EAAIjS,GAAKwQ,EAAGxQ,QAIb,IAAI,IAAIA,EAAE,EAAEA,EAAEuQ,EAAEvQ,IACfgQ,EAAIhQ,GAAK,EACTiS,EAAIjS,GAAKwQ,EAAGxQ,GAKd,GAAG0Q,EAAO,CACT,IAAI,IAAI1Q,EAAE,EAAEA,EAAEuQ,EAAEvQ,IAAKwQ,EAAGxQ,GAAK,GAG7B,IAAI,IAAID,EAAE,EAAEA,EAAEgQ,EAAIhQ,IAMjB,IALA,IACEyS,EAAOxC,EADCkC,EAAKnS,IAEb0S,EAAOpQ,EAAKtC,GAGN2S,EAAE,EAAEA,EAAEL,EAAKK,IAClBF,EAAKE,IAAMD,EAAKC,GAIlBP,GAAO,EACP,IAAI,IAAInS,EAAE,EAAEA,EAAEuQ,EAAEvQ,IAAK,CAOpB,IANA,IAAI2S,EAAMnC,EAAGxQ,GACX4S,EAAO5C,EAAIhQ,GACX6S,EAAOZ,EAAIjS,GACX8S,EAAKR,EAAMtS,GAGL0S,EAAE,EAAEA,EAAEL,EAAKK,IAClBC,EAAID,GAAME,EAAKF,GAAKI,GAAO,EAI5B,GAAGX,EACF,IAAI,IAAIO,EAAE,EAAEA,EAAEL,EAAKK,IAClB,GAAGG,EAAKH,IAAIC,EAAID,GAAI,CACnBP,GAAO,EACP,KACA,CAGH,CACD,KAEI,CAEJ,IAAI,IAAIpS,EAAE,EAAEA,EAAEgQ,EAAIhQ,IAAK,CAEtBiQ,EADUkC,EAAKnS,KACHsC,EAAKtC,EACjB,CAED,IAAI,IAAIC,EAAE,EAAEA,EAAEuQ,EAAEvQ,IACfwQ,EAAGxQ,GAAKgQ,EAAIhQ,GAAGsS,EAAMtS,IAAM,EAG5BmS,GAAO,EACP,IAAI,IAAInS,EAAE,EAAEA,EAAEuQ,EAAEvQ,IACf,GAAGiS,EAAIjS,IAAIwQ,EAAGxQ,GAAI,CACjBmS,GAAO,EACP,KACA,CAEF,CAEDA,EAAOA,KAAWC,GAAI,CACtB,QAAOD,GAER,MAAO,CACNC,IAAMJ,GAnKI,KAmKYI,EACtB7B,EAAIA,EACJ2B,KAAOA,EACPL,UAAYrB,EACZmB,KAAOA,EAER,gCClLD,IAAIoB,EAAU,EAAQ,OAkCtB9F,EAAOC,QAAU,SAAegC,EAAOjB,GACrCA,EAAQA,GAAS,UAEjB,IADA,IAAIsB,EAAK,EACDxP,EAAE,EAAGA,EAAEmP,EAAMpP,SAAUC,EAC7BwP,GAAML,EAAMnP,GAEd,OAAOgT,EAAQ,IAtCjB,SAAqB9E,GACnB,OAAOA,GACL,IAAK,QACH,OAAOpO,WACT,IAAK,SACH,OAAOmT,YACT,IAAK,SACH,OAAOC,YACT,IAAK,OACH,OAAOC,UACT,IAAK,QACH,OAAOC,WACT,IAAK,QACH,OAAOC,WACT,IAAK,QACL,IAAK,UACH,OAAOC,aACT,IAAK,SACL,IAAK,UACH,OAAO9F,aACT,IAAK,gBACH,OAAO+F,kBACT,IAAK,UACL,IAAK,SACL,IAAK,OACL,IAAK,WACH,OAAO7Q,YACT,IAAK,QACH,OAAOsF,MAEb,CAQqB,CAAakG,GAAjB,CAAyBsB,GAAKL,EAC/C","sources":["webpack:///../../../node_modules/dicomweb-client/src/message.js","webpack:///../../../node_modules/dicomweb-client/src/api.js","webpack:///../../../node_modules/dicomweb-client/src/version.js","webpack:///../../../node_modules/dicomweb-client/src/dicomweb-client.js","webpack:///../../../node_modules/iota-array/iota.js","webpack:///../../../node_modules/is-buffer/index.js","webpack:///../../../node_modules/ndarray/ndarray.js","webpack:///../../../node_modules/skmeans/distance.js","webpack:///../../../node_modules/skmeans/kinit.js","webpack:///../../../node_modules/skmeans/main.js","webpack:///../../../node_modules/zeros/zeros.js"],"sourcesContent":["/**\n * Converts a Uint8Array to a String.\n * @param {Uint8Array} array that should be converted\n * @param {Number} offset array offset in case only subset of array items should\n                   be extracted (default: 0)\n * @param {Number} limit maximum number of array items that should be extracted\n                   (defaults to length of array)\n * @returns {String}\n */\nfunction uint8ArrayToString(arr, offset = 0, limit) {\n  const itemLimit = limit || arr.length - offset;\n  let str = '';\n  for (let i = offset; i < offset + itemLimit; i++) {\n    str += String.fromCharCode(arr[i]);\n  }\n  return str;\n}\n\n/**\n * Converts a String to a Uint8Array.\n * @param {String} str string that should be converted\n * @returns {Uint8Array}\n */\nfunction stringToUint8Array(str) {\n  const arr = new Uint8Array(str.length);\n  for (let i = 0, j = str.length; i < j; i++) {\n    arr[i] = str.charCodeAt(i);\n  }\n  return arr;\n}\n\n/**\n * Identifies the boundary in a multipart/related message header.\n * @param {String} header message header\n * @returns {String} boundary\n */\nfunction identifyBoundary(header) {\n  const parts = header.split('\\r\\n');\n\n  for (let i = 0; i < parts.length; i++) {\n    if (parts[i].substr(0, 2) === '--') {\n      return parts[i];\n    }\n  }\n\n  return null;\n}\n\n/**\n * Checks whether a given token is contained by a message at a given offset.\n * @param {Uint8Array} message message content\n * @param {Uint8Array} token substring that should be present\n * @param {Number} offset offset in message content from where search should start\n * @returns {Boolean} whether message contains token at offset\n */\nfunction containsToken(message, token, offset = 0) {\n  if (offset + token.length > message.length) {\n    return false;\n  }\n\n  let index = offset;\n  for (let i = 0; i < token.length; i++) {\n    if (token[i] !== message[index]) {\n      return false;\n    }\n\n    index += 1;\n  }\n  return true;\n}\n\n/**\n * Finds a given token in a message at a given offset.\n * @param {Uint8Array} message message content\n * @param {Uint8Array} token substring that should be found\n * @param {String} offset message body offset from where search should start\n * @returns {Boolean} whether message has a part at given offset or not\n */\nfunction findToken(message, token, offset = 0, maxSearchLength) {\n  let searchLength = message.length;\n  if (maxSearchLength) {\n    searchLength = Math.min(offset + maxSearchLength, message.length);\n  }\n\n  for (let i = offset; i < searchLength; i++) {\n    // If the first value of the message matches\n    // the first value of the token, check if\n    // this is the full token.\n    if (message[i] === token[0]) {\n      if (containsToken(message, token, i)) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Create a random GUID\n *\n * @return {string}\n */\nfunction guid() {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n  }\n  return `${s4() + s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`;\n}\n\n/**\n * @typedef {Object} MultipartEncodedData\n * @property {ArrayBuffer} data The encoded Multipart Data\n * @property {String} boundary The boundary used to divide pieces of the encoded data\n */\n\n/**\n * Encode one or more DICOM datasets into a single body so it can be\n * sent using the Multipart Content-Type.\n *\n * @param {ArrayBuffer[]} datasets Array containing each file to be encoded in the\n                          multipart body, passed as ArrayBuffers.\n * @param {String} [boundary] Optional string to define a boundary between each part\n                              of the multipart body. If this is not specified, a random\n                              GUID will be generated.\n * @return {MultipartEncodedData} The Multipart encoded data returned as an Object. This\n                                  contains both the data itself, and the boundary string\n                                  used to divide it.\n */\nfunction multipartEncode(\n  datasets,\n  boundary = guid(),\n  contentType = 'application/dicom',\n) {\n  const contentTypeString = `Content-Type: ${contentType}`;\n  const header = `\\r\\n--${boundary}\\r\\n${contentTypeString}\\r\\n\\r\\n`;\n  const footer = `\\r\\n--${boundary}--`;\n  const headerArray = stringToUint8Array(header);\n  const footerArray = stringToUint8Array(footer);\n  const headerLength = headerArray.length;\n  const footerLength = footerArray.length;\n\n  let length = 0;\n\n  // Calculate the total length for the final array\n  const contentArrays = datasets.map(datasetBuffer => {\n    const contentArray = new Uint8Array(datasetBuffer);\n    const contentLength = contentArray.length;\n\n    length += headerLength + contentLength + footerLength;\n\n    return contentArray;\n  });\n\n  // Allocate the array\n  const multipartArray = new Uint8Array(length);\n\n  // Set the initial header\n  multipartArray.set(headerArray, 0);\n\n  // Write each dataset into the multipart array\n  let position = 0;\n  contentArrays.forEach(contentArray => {\n    multipartArray.set(headerArray, position);\n    multipartArray.set(contentArray, position + headerLength);\n\n    position += headerLength + contentArray.length;\n  });\n\n  multipartArray.set(footerArray, position);\n\n  return {\n    data: multipartArray.buffer,\n    boundary,\n  };\n}\n\n/**\n * Decode a Multipart encoded ArrayBuffer and return the components as an Array.\n *\n * @param {ArrayBuffer} response Data encoded as a 'multipart/related' message\n * @returns {Array} The content\n */\nfunction multipartDecode(response) {\n  // Use the raw data if it is provided in an appropriate format\n  const message = ArrayBuffer.isView(response) ? response : new Uint8Array(response);\n\n  /* Set a maximum length to search for the header boundaries, otherwise\n       findToken can run for a long time\n    */\n  const maxSearchLength = 1000;\n\n  // First look for the multipart mime header\n  const separator = stringToUint8Array('\\r\\n\\r\\n');\n  const headerIndex = findToken(message, separator, 0, maxSearchLength);\n  if (headerIndex === -1) {\n    throw new Error('Response message has no multipart mime header');\n  }\n\n  const header = uint8ArrayToString(message, 0, headerIndex);\n  const boundaryString = identifyBoundary(header);\n  if (!boundaryString) {\n    throw new Error('Header of response message does not specify boundary');\n  }\n\n  const boundary = stringToUint8Array(boundaryString);\n  const boundaryLength = boundary.length;\n  const components = [];\n\n  let offset = boundaryLength;\n\n  // Loop until we cannot find any more boundaries\n  let boundaryIndex;\n\n  while (boundaryIndex !== -1) {\n    // Search for the next boundary in the message, starting\n    // from the current offset position\n    boundaryIndex = findToken(message, boundary, offset);\n\n    // If no further boundaries are found, stop here.\n    if (boundaryIndex === -1) {\n      break;\n    }\n\n    const headerTokenIndex = findToken(\n      message,\n      separator,\n      offset,\n      maxSearchLength,\n    );\n    if (headerTokenIndex === -1) {\n      throw new Error('Response message part has no mime header');\n    }\n    offset = headerTokenIndex + separator.length;\n\n    // Extract data from response message, excluding \"\\r\\n\"\n    const spacingLength = 2;\n    const data = response.slice(offset, boundaryIndex - spacingLength);\n\n    // Add the data to the array of results\n    components.push(data);\n\n    // Move the offset to the end of the current section,\n    // plus the identified boundary\n    offset = boundaryIndex + boundaryLength;\n  }\n\n  return components;\n}\n\nexport {\n  containsToken,\n  findToken,\n  identifyBoundary,\n  uint8ArrayToString,\n  stringToUint8Array,\n  multipartEncode,\n  multipartDecode,\n  guid,\n};\n","import { multipartEncode, multipartDecode } from './message.js';\n\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null;\n}\n\nfunction isEmptyObject(obj) {\n  return Object.keys(obj).length === 0 && obj.constructor === Object;\n}\n\nfunction areValidRequestHooks(requestHooks) {\n  const isValid =\n    Array.isArray(requestHooks) &&\n    requestHooks.every(\n      requestHook =>\n        typeof requestHook === 'function' && requestHook.length === 2,\n    );\n\n  if (!isValid) {\n    console.warn(\n      'Request hooks should have the following signature: ' +\n        'function requestHook(request, metadata) { return request; }',\n    );\n  }\n\n  return isValid;\n}\n\nconst getFirstResult = result => result[0];\n\nconst MEDIATYPES = {\n  DICOM: 'application/dicom',\n  DICOM_JSON: 'application/dicom+json',\n  OCTET_STREAM: 'application/octet-stream',\n  PDF: 'application/pdf',\n  JPEG: 'image/jpeg',\n  PNG: 'image/png',\n};\n\n/**\n * debugLog is a function that can be called with console.log arguments, and will\n * be conditionally displayed, only when debug logging is enabled.\n */\nlet debugLog = () => {};\n\n/**\n * @typedef { import(\"../types/types\").InstanceMetadata } InstanceMetadata\n */\n\n/**\n * A callback with the request instance and metadata information\n * of the currently request being executed that should necessarily\n * return the given request optionally modified.\n * @typedef {function} RequestHook\n * @param {XMLHttpRequest} request - The original XMLHttpRequest instance.\n * @param {object} metadata - The metadata used by the request.\n */\n\n/**\n * Class for interacting with DICOMweb RESTful services.\n */\nclass DICOMwebClient {\n  /**\n   * @constructor\n   * @param {Object} options\n   * @param {String} options.url - URL of the DICOMweb RESTful Service endpoint\n   * @param {String=} options.qidoURLPrefix - URL path prefix for QIDO-RS\n   * @param {String=} options.wadoURLPrefix - URL path prefix for WADO-RS\n   * @param {String=} options.stowURLPrefix - URL path prefix for STOW-RS\n   * @param {String=} options.username - Username\n   * @param {String=} options.password - Password\n   * @param {Object=} options.headers - HTTP headers\n   * @param {Array.<RequestHook>=} options.requestHooks - Request hooks.\n   * @param {Object=} options.verbose - print to console request warnings and errors, default true\n   * @param {Object=} options.debug - print to the console debug level information/status updates.\n   * @param {boolean|String} options.singlepart - retrieve singlepart for the named types.\n   * The available types are:  bulkdata, video, image.  true means all.\n   */\n  constructor(options) {\n    this.baseURL = options.url;\n    if (!this.baseURL) {\n      console.error('no DICOMweb base url provided - calls that require a URL will fail');\n    }\n\n    if ('username' in options) {\n      this.username = options.username;\n      if (!('password' in options)) {\n        console.error(\n          'no password provided to authenticate with DICOMweb service',\n        );\n      }\n      this.password = options.password;\n    }\n\n    if ('qidoURLPrefix' in options) {\n      debugLog(`use URL prefix for QIDO-RS: ${options.qidoURLPrefix}`);\n      this.qidoURL = `${this.baseURL}/${options.qidoURLPrefix}`;\n    } else {\n      this.qidoURL = this.baseURL;\n    }\n\n    if ('wadoURLPrefix' in options) {\n      debugLog(`use URL prefix for WADO-RS: ${options.wadoURLPrefix}`);\n      this.wadoURL = `${this.baseURL}/${options.wadoURLPrefix}`;\n    } else {\n      this.wadoURL = this.baseURL;\n    }\n\n    if ('stowURLPrefix' in options) {\n      debugLog(`use URL prefix for STOW-RS: ${options.stowURLPrefix}`);\n      this.stowURL = `${this.baseURL}/${options.stowURLPrefix}`;\n    } else {\n      this.stowURL = this.baseURL;\n    }\n\n    if (options.singlepart) {\n      debugLog('use singlepart', options.singlepart);\n      this.singlepart = options.singlepart === true ? 'bulkdata,video,image' : options.singlepart;\n    } else {\n      this.singlepart = '';\n    }\n\n    if ('requestHooks' in options) {\n      this.requestHooks = options.requestHooks;\n    }\n\n    // Headers to pass to requests.\n    this.headers = options.headers || {};\n\n    // Optional error interceptor callback to handle any failed request.\n    this.errorInterceptor = options.errorInterceptor || (() => undefined);\n\n    // Verbose - print to console request warnings and errors, default true\n    this.verbose = options.verbose !== false;\n\n    this.setDebug(options.debug);\n \n\n  }\n\n  /**\n   * Allows setting the debug log information. \n   * Note this is different from verbose in that verbose is whether to include warning/error information, defaulting to true\n   * \n   * @param {boolean} debugLevel \n   * @param {function} debugLogFunction to call with the debug output arguments. \n   */\n  setDebug(debugLevel = false, debugLogFunction = null) {\n    this.debugLevel = !!debugLevel;\n    debugLog = debugLogFunction || debugLevel ? console.log : () => {};\n  }\n\n  /**\n   * Gets debug flag\n   * \n   * @returns true if debug logging is enabled\n   */\n  getDebug() {\n    return this.debugLevel;\n  }\n \n  /**\n   * Sets verbose flag.\n   *\n   * @param {Boolean} verbose\n   */\n  setVerbose(verbose) {\n    this.verbose = verbose;\n  }\n\n  /**\n   * Gets verbose flag.\n   *\n   * @return {Boolean} verbose\n   */\n  getVerbose() {\n    return this.verbose;\n  }\n\n  static _parseQueryParameters(params = {}) {\n    let queryString = '?';\n    Object.keys(params).forEach((key, index) => {\n      if (index !== 0) {\n        queryString += '&';\n      }\n      queryString += `${key}=${encodeURIComponent(params[key])}`;\n    });\n    return queryString;\n  }\n\n  /**\n   * Performs an HTTP request.\n   *\n   * @param {String} url\n   * @param {String} method\n   * @param {Object} headers\n   * @param {Object} options\n   * @param {Array.<RequestHook>} options.requestHooks - Request hooks.\n   * @param {XMLHttpRequest} [options.request] - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n   * @return {*}\n   * @private\n   */\n  _httpRequest(url, method, headers = {}, options = {}) {\n    const { errorInterceptor, requestHooks } = this;\n\n    return new Promise((resolve, reject) => {\n      let request = options.request ? options.request : new XMLHttpRequest();\n\n      request.open(method, url, true);\n      if ('responseType' in options) {\n        request.responseType = options.responseType;\n      }\n\n      if (typeof headers === 'object') {\n        Object.keys(headers).forEach(key => {\n          request.setRequestHeader(key, headers[key]);\n        });\n      }\n\n      // now add custom headers from the user\n      // (e.g. access tokens)\n      const userHeaders = this.headers;\n      Object.keys(userHeaders).forEach(key => {\n        request.setRequestHeader(key, userHeaders[key]);\n      });\n\n      // Event triggered when upload starts\n      request.onloadstart = function onloadstart() {\n        debugLog('upload started: ', url)\n      };\n\n      // Event triggered when upload ends\n      request.onloadend = function onloadend() {\n        debugLog('upload finished')\n      };\n\n      // Handle response message\n      request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n          if (request.status === 200) {\n            const contentType = request.getResponseHeader('Content-Type');\n            // Automatically distinguishes between multipart and singlepart in an array buffer, and\n            // converts them into a consistent type.\n            if (contentType && contentType.indexOf('multipart') !== -1) {\n              resolve(multipartDecode(request.response));\n            } else if (request.responseType === 'arraybuffer') {\n              resolve([request.response]);\n            } else {\n              resolve(request.response);\n            }\n          } else if (request.status === 202) {\n            if (this.verbose) {\n              console.warn('some resources already existed: ', request);\n            }\n            resolve(request.response);\n          } else if (request.status === 204) {\n            if (this.verbose) {\n              console.warn('empty response for request: ', request);\n            }\n            resolve([]);\n          } else {\n            const error = new Error('request failed');\n            error.request = request;\n            error.response = request.response;\n            error.status = request.status;\n            if (this.verbose) {\n              console.error('request failed: ', request);\n              console.error(error);\n              console.error(error.response);\n            }\n\n            errorInterceptor(error);\n\n            reject(error);\n          }\n        }\n      };\n\n      // Event triggered while download progresses\n      if ('progressCallback' in options) {\n        if (typeof options.progressCallback === 'function') {\n          request.onprogress = options.progressCallback;\n        }\n      }\n\n      if (requestHooks && areValidRequestHooks(requestHooks)) {\n        const combinedHeaders = Object.assign({}, headers, this.headers);\n        const metadata = { method, url, headers: combinedHeaders };\n        const pipeRequestHooks = functions => args =>\n          functions.reduce((props, fn) => fn(props, metadata), args);\n        const pipedRequest = pipeRequestHooks(requestHooks);\n        request = pipedRequest(request);\n      }\n\n      // Add withCredentials to request if needed\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          request.withCredentials = true;\n        }\n      }\n\n      if ('data' in options) {\n        request.send(options.data);\n      } else {\n        request.send();\n      }\n    });\n  }\n\n  /**\n   * Performs an HTTP GET request.\n   *\n   * @param {String} url\n   * @param {Object} headers\n   * @param {Object} responseType\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGet(url, headers, responseType, progressCallback, withCredentials) {\n    return this._httpRequest(url, 'get', headers, {\n      responseType,\n      progressCallback,\n      withCredentials,\n    });\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with application/json\n   * media type.\n   *\n   * @param {String} url\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetApplicationJson(url, params = {}, progressCallback, withCredentials) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n    const headers = { Accept: MEDIATYPES.DICOM_JSON };\n    const responseType = 'json';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with application/pdf\n   * media type.\n   *\n   * @param {String} url\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetApplicationPdf(url, params = {}, progressCallback, withCredentials) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n    const headers = { Accept: MEDIATYPES.PDF };\n    const responseType = 'json';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with an image\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetImage(\n    url,\n    mediaTypes,\n    params = {},\n    progressCallback,\n    withCredentials,\n  ) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      'image/',\n      'image/*',\n      'image/jpeg',\n      'image/jp2',\n      'image/gif',\n      'image/png',\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    const responseType = 'arraybuffer';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with a text\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetText(\n    url,\n    mediaTypes,\n    params = {},\n    progressCallback,\n    withCredentials,\n  ) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      'text/',\n      'text/*',\n      'text/html',\n      'text/plain',\n      'text/rtf',\n      'text/xml',\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    const responseType = 'arraybuffer';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with a video\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetVideo(\n    url,\n    mediaTypes,\n    params = {},\n    progressCallback,\n    withCredentials,\n  ) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      'video/',\n      'video/*',\n      'video/mpeg',\n      'video/mp4',\n      'video/H265',\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    const responseType = 'arraybuffer';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Asserts that a given media type is valid.\n   *\n   * @params {String} mediaType media type\n   */\n  static _assertMediaTypeIsValid(mediaType) {\n    if (!mediaType) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    const sepIndex = mediaType.indexOf('/');\n    if (sepIndex === -1) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    const mediaTypeType = mediaType.slice(0, sepIndex);\n    const types = ['application', 'image', 'text', 'video'];\n    if (!types.includes(mediaTypeType)) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    if (mediaType.slice(sepIndex + 1).includes('/')) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message with an image media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange - Start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Boolean} rendered - Whether resource should be requested using rendered media types\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartImage(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    rendered = false,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    let supportedMediaTypes;\n    if (rendered) {\n      supportedMediaTypes = [\n        'image/jpeg',\n        'image/gif',\n        'image/png',\n        'image/jp2',\n      ];\n    } else {\n      supportedMediaTypes = {\n        '1.2.840.10008.1.2.5': ['image/x-dicom-rle'],\n        '1.2.840.10008.1.2.4.50': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.51': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.57': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.70': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.80': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.81': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.90': ['image/jp2'],\n        '1.2.840.10008.1.2.4.91': ['image/jp2'],\n        '1.2.840.10008.1.2.4.92': ['image/jpx'],\n        '1.2.840.10008.1.2.4.93': ['image/jpx'],\n      };\n\n      if (byteRange) {\n        headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n      }\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message with a video media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange - Start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Boolean} rendered - Whether resource should be requested using rendered media types\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartVideo(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    rendered = false,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    let supportedMediaTypes;\n    if (rendered) {\n      supportedMediaTypes = [\n        'video/',\n        'video/*',\n        'video/mpeg2',\n        'video/mp4',\n        'video/H265',\n      ];\n    } else {\n      supportedMediaTypes = {\n        '1.2.840.10008.1.2.4.100': ['video/mpeg2'],\n        '1.2.840.10008.1.2.4.101': ['video/mpeg2'],\n        '1.2.840.10008.1.2.4.102': ['video/mp4'],\n        '1.2.840.10008.1.2.4.103': ['video/mp4'],\n        '1.2.840.10008.1.2.4.104': ['video/mp4'],\n        '1.2.840.10008.1.2.4.105': ['video/mp4'],\n        '1.2.840.10008.1.2.4.106': ['video/mp4'],\n      };\n\n      if (byteRange) {\n        headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n      }\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message\n   * with a application/dicom media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartApplicationDicom(\n    url,\n    mediaTypes,\n    params,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    const defaultMediaType = 'application/dicom';\n    const supportedMediaTypes = {\n      '1.2.840.10008.1.2.1': [defaultMediaType],\n      '1.2.840.10008.1.2.5': [defaultMediaType],\n      '1.2.840.10008.1.2.4.50': [defaultMediaType],\n      '1.2.840.10008.1.2.4.51': [defaultMediaType],\n      '1.2.840.10008.1.2.4.57': [defaultMediaType],\n      '1.2.840.10008.1.2.4.70': [defaultMediaType],\n      '1.2.840.10008.1.2.4.80': [defaultMediaType],\n      '1.2.840.10008.1.2.4.81': [defaultMediaType],\n      '1.2.840.10008.1.2.4.90': [defaultMediaType],\n      '1.2.840.10008.1.2.4.91': [defaultMediaType],\n      '1.2.840.10008.1.2.4.92': [defaultMediaType],\n      '1.2.840.10008.1.2.4.93': [defaultMediaType],\n      '1.2.840.10008.1.2.4.100': [defaultMediaType],\n      '1.2.840.10008.1.2.4.101': [defaultMediaType],\n      '1.2.840.10008.1.2.4.102': [defaultMediaType],\n      '1.2.840.10008.1.2.4.103': [defaultMediaType],\n      '1.2.840.10008.1.2.4.104': [defaultMediaType],\n      '1.2.840.10008.1.2.4.105': [defaultMediaType],\n      '1.2.840.10008.1.2.4.106': [defaultMediaType],\n    };\n\n    let acceptableMediaTypes = mediaTypes;\n    if (!mediaTypes) {\n      acceptableMediaTypes = [{ mediaType: defaultMediaType }];\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      acceptableMediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message\n   * with a application/octet-stream, OR any of the equivalencies for that (eg\n   * application/pdf etc)\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartApplicationOctetStream(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    const defaultMediaType = 'application/octet-stream';\n    const supportedMediaTypes = {\n      '1.2.840.10008.1.2.1': [...Object.values(MEDIATYPES)],\n    };\n\n    let acceptableMediaTypes = mediaTypes;\n    if (!mediaTypes) {\n      acceptableMediaTypes = [{ mediaType: defaultMediaType }];\n    }\n\n    if (byteRange) {\n      headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      acceptableMediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n  }\n\n  /**\n   * Performs an HTTP POST request.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object} headers - HTTP header fields\n   * @param {Array} data - Data that should be stored\n   * @param {Function} progressCallback\n   * @param {Function} progressCallback\n   * @param {XMLHttpRequest} request - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n   * @private\n   * @returns {Promise} Response\n   */\n  _httpPost(url, headers, data, progressCallback, withCredentials, request) {\n    return this._httpRequest(url, 'post', headers, {\n      data,\n      progressCallback,\n      withCredentials,\n      request,\n    });\n  }\n\n  /**\n   * Performs an HTTP POST request with content-type application/dicom+json.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object} headers - HTTP header fields\n   * @param {Array} data - Data that should be stored\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise} Response\n   */\n  _httpPostApplicationJson(url, data, progressCallback, withCredentials) {\n    const headers = { 'Content-Type': MEDIATYPES.DICOM_JSON };\n    return this._httpPost(\n      url,\n      headers,\n      data,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Parses media type and extracts its type and subtype.\n   *\n   * @param {String} mediaType - HTTP media type (e.g. image/jpeg)\n   * @private\n   * @returns {String[]} Media type and subtype\n   */\n  static _parseMediaType(mediaType) {\n    DICOMwebClient._assertMediaTypeIsValid(mediaType);\n\n    return mediaType.split('/');\n  }\n\n  /**\n   * Builds an accept header field value for HTTP GET request messages.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types\n   * @param {Object[]} supportedMediaTypes - Supported media types\n   * @return {*}\n   * @private\n   */\n  static _buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes) {\n    if (!Array.isArray(mediaTypes)) {\n      throw new Error('Acceptable media types must be provided as an Array');\n    }\n\n    const fieldValueParts = mediaTypes.map(item => {\n      const { mediaType } = item;\n\n      DICOMwebClient._assertMediaTypeIsValid(mediaType);\n      if (!supportedMediaTypes.includes(mediaType)) {\n        throw new Error(\n          `Media type ${mediaType} is not supported for requested resource`,\n        );\n      }\n\n      return mediaType;\n    });\n\n    return fieldValueParts.join(', ');\n  }\n\n  /**\n   * Builds an accept header field value for HTTP GET multipart request\n   * messages.  Will throw an exception if no media types are found which are acceptable,\n   * but will only log a verbose level message when types are specified which are\n   * not acceptable.  This allows requesting several types with having to know\n   * whether they are all acceptable or not.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types\n   * @param {Object[]} supportedMediaTypes - Supported media types\n   * @private\n   */\n  static _buildMultipartAcceptHeaderFieldValue(\n    mediaTypes,\n    supportedMediaTypes,\n  ) {\n    if (!Array.isArray(mediaTypes)) {\n      throw new Error('Acceptable media types must be provided as an Array');\n    }\n\n    if (!Array.isArray(supportedMediaTypes) && !isObject(supportedMediaTypes)) {\n      throw new Error(\n        'Supported media types must be provided as an Array or an Object',\n      );\n    }\n\n    const fieldValueParts = [];\n\n    mediaTypes.forEach(item => {\n      const { transferSyntaxUID, mediaType } = item;\n      DICOMwebClient._assertMediaTypeIsValid(mediaType);\n      let fieldValue = `multipart/related; type=\"${mediaType}\"`;\n\n      if (isObject(supportedMediaTypes)) {\n        // SupportedMediaTypes is a lookup table that maps Transfer Syntax UID\n        // to one or more Media Types\n        if (\n          !Object.values(supportedMediaTypes)\n            .flat(1)\n            .includes(mediaType)\n        ) {\n          if (!mediaType.endsWith('/*') || !mediaType.endsWith('/')) {\n            debugLog(\n              `Media type ${mediaType} is not supported for requested resource`,\n            );\n            return;\n          }\n        }\n\n        if (transferSyntaxUID) {\n          if (transferSyntaxUID !== '*') {\n            if (!Object.keys(supportedMediaTypes).includes(transferSyntaxUID)) {\n              throw new Error(\n                `Transfer syntax ${transferSyntaxUID} is not supported for requested resource`,\n              );\n            }\n\n            const expectedMediaTypes = supportedMediaTypes[transferSyntaxUID];\n\n            if (!expectedMediaTypes.includes(mediaType)) {\n              const actualType = DICOMwebClient._parseMediaType(mediaType)[0];\n              expectedMediaTypes.map(expectedMediaType => {\n                const expectedType = DICOMwebClient._parseMediaType(\n                  expectedMediaType,\n                )[0];\n                const haveSameType = actualType === expectedType;\n\n                if (\n                  haveSameType &&\n                  (mediaType.endsWith('/*') || mediaType.endsWith('/'))\n                ) {\n                  return;\n                }\n\n                throw new Error(\n                  `Transfer syntax ${transferSyntaxUID} is not supported for requested resource`,\n                );\n              });\n            }\n          }\n\n          fieldValue += `; transfer-syntax=${transferSyntaxUID}`;\n        }\n      } else if (\n        Array.isArray(supportedMediaTypes) &&\n        !supportedMediaTypes.includes(mediaType)\n      ) {\n        if( this.verbose ) {\n          console.warn(\n            `Media type ${mediaType} is not supported for requested resource`,\n          );\n        }\n        return;\n      }\n\n      fieldValueParts.push(fieldValue);\n    });\n\n    if( !fieldValueParts.length ) {\n      throw new Error(`No acceptable media types found among ${JSON.stringify(mediaTypes)}`);\n    }\n\n    return fieldValueParts.join(', ');\n  }\n\n  /**\n   * Builds a range header field value for HTTP GET request messages.\n   *\n   * @param {Array} byteRange - Start and end of byte range\n   * @returns {String} Range header field value\n   * @private\n   */\n  static _buildRangeHeaderFieldValue(byteRange = []) {\n    if (byteRange.length === 1) {\n      return `bytes=${byteRange[0]}-`;\n    }\n    if (byteRange.length === 2) {\n      return `bytes=${byteRange[0]}-${byteRange[1]}`;\n    }\n\n    return 'bytes=0-';\n  }\n\n  /**\n   * Gets types that are shared among acceptable media types.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @private\n   * @returns {String[]} Types that are shared among acceptable media types\n   */\n  static _getSharedMediaTypes(mediaTypes) {\n    const types = new Set();\n\n    if (!mediaTypes || !mediaTypes.length) {\n      return types;\n    }\n\n    mediaTypes.forEach(item => {\n      const { mediaType } = item;\n      const type = DICOMwebClient._parseMediaType(mediaType)[0];\n      types.add(`${type}/`);\n    });\n\n    return Array.from(types);\n  }\n\n  /**\n   * Gets common base type of acceptable media types and asserts that only\n   one type is specified. For example, ``(\"image/jpeg\", \"image/jp2\")``\n   will pass, but ``(\"image/jpeg\", \"video/mpeg2\")`` will raise an\n   exception.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @private\n   * @returns {String[]} Common media type, eg `image/` for the above example.\n   */\n  static _getCommonMediaType(mediaTypes) {\n    if (!mediaTypes || !mediaTypes.length) {\n      throw new Error('No acceptable media types provided');\n    }\n\n    const sharedMediaTypes = DICOMwebClient._getSharedMediaTypes(mediaTypes);\n    if (sharedMediaTypes.length === 0) {\n      throw new Error('No common acceptable media type could be identified.');\n    } else if (sharedMediaTypes.length > 1) {\n      throw new Error('Acceptable media types must have the same type.');\n    }\n\n    return sharedMediaTypes[0];\n  }\n\n  /**\n   * Searches for DICOM studies.\n   *\n   * @param {Object} options\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @return {Object[]} Study representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2)\n   */\n  searchForStudies(options = {}) {\n    debugLog('search for studies');\n    let withCredentials = false;\n    let url = `${this.qidoURL}/studies`;\n    if ('queryParams' in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Retrieves metadata for a DICOM study.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @returns {Promise<InstanceMetadata[]>} Metadata elements in DICOM JSON format for each instance\n                      belonging to the study\n   */\n  retrieveStudyMetadata(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of study metadata',\n      );\n    }\n    debugLog(`retrieve metadata of study ${options.studyInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/metadata`;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Searches for DICOM series.\n   *\n   * @param {Object} options\n   * @param {Object} [options.studyInstanceUID] - Study Instance UID\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {Object[]} Series representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2a)\n   */\n  searchForSeries(options = {}) {\n    let url = this.qidoURL;\n    if ('studyInstanceUID' in options) {\n      debugLog(`search series of study ${options.studyInstanceUID}`);\n      url += `/studies/${options.studyInstanceUID}`;\n    }\n    url += '/series';\n    if ('queryParams' in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Retrieves metadata for a DICOM series.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @returns {Promise<InstanceMetadata[]>} Metadata elements in DICOM JSON format for each instance\n                      belonging to the series\n   */\n  retrieveSeriesMetadata(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of series metadata',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of series metadata',\n      );\n    }\n\n    debugLog(`retrieve metadata of series ${options.seriesInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/metadata`;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Searches for DICOM Instances.\n   *\n   * @param {Object} options\n   * @param {String} [options.studyInstanceUID] - Study Instance UID\n   * @param {String} [options.seriesInstanceUID] - Series Instance UID\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {Object[]} Instance representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2b)\n   */\n  searchForInstances(options = {}) {\n    let url = this.qidoURL;\n    let withCredentials = false;\n    if ('studyInstanceUID' in options) {\n      url += `/studies/${options.studyInstanceUID}`;\n      if ('seriesInstanceUID' in options) {\n        debugLog(\n          `search for instances of series ${options.seriesInstanceUID}`,\n        );\n        url += `/series/${options.seriesInstanceUID}`;\n      } else {\n        debugLog(\n          `search for instances of study ${options.studyInstanceUID}`,\n        );\n      }\n    } else {\n      debugLog('search for instances');\n    }\n    url += '/instances';\n    if ('queryParams' in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /** Returns a WADO-URI URL for an instance\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @returns {String} WADO-URI URL\n   */\n  buildInstanceWadoURIUrl(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required.');\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error('Series Instance UID is required.');\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error('SOP Instance UID is required.');\n    }\n\n    const contentType = options.contentType || MEDIATYPES.DICOM;\n    const transferSyntax = options.transferSyntax || '*';\n    const params = [];\n\n    params.push('requestType=WADO');\n    params.push(`studyUID=${options.studyInstanceUID}`);\n    params.push(`seriesUID=${options.seriesInstanceUID}`);\n    params.push(`objectUID=${options.sopInstanceUID}`);\n    params.push(`contentType=${contentType}`);\n    params.push(`transferSyntax=${transferSyntax}`);\n\n    const paramString = params.join('&');\n\n    return `${this.wadoURL}?${paramString}`;\n  }\n\n  /**\n   * Retrieves metadata for a DICOM Instance.\n   *\n   * @param {Object} options object\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @returns {Promise<InstanceMetadata>} metadata elements in DICOM JSON format\n   */\n  retrieveInstanceMetadata(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of instance metadata',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of instance metadata',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of instance metadata',\n      );\n    }\n    debugLog(`retrieve metadata of instance ${options.sopInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}/metadata`;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Retrieves frames for a DICOM Instance.\n   * @param {Object} options options object\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @returns {Array} frame items as byte arrays of the pixel data element\n   */\n  retrieveInstanceFrames(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of instance frames',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of instance frames',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of instance frames',\n      );\n    }\n    if (!('frameNumbers' in options)) {\n      throw new Error(\n        'frame numbers are required for retrieval of instance frames',\n      );\n    }\n    debugLog(\n      `retrieve frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`,\n    );\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}`;\n\n    const { mediaTypes } = options;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationOctetStream(\n        url,\n        false,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const sharedMediaTypes = DICOMwebClient._getSharedMediaTypes(mediaTypes);\n    if (sharedMediaTypes.length > 1) {\n      /**\n       * Enable request of frames that are stored either compressed\n       * (image/* media type) or uncompressed (application/octet-stream\n       * media type).\n       */\n      const supportedMediaTypes = {\n        '1.2.840.10008.1.2.1': ['application/octet-stream'],\n        '1.2.840.10008.1.2.5': ['image/x-dicom-rle'],\n        '1.2.840.10008.1.2.4.50': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.51': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.57': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.70': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.80': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.81': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.90': ['image/jp2'],\n        '1.2.840.10008.1.2.4.91': ['image/jp2'],\n        '1.2.840.10008.1.2.4.92': ['image/jpx'],\n        '1.2.840.10008.1.2.4.93': ['image/jpx'],\n        '1.2.840.10008.1.2.4.201': ['image/jhc'],\n        '1.2.840.10008.1.2.4.202': ['image/jhc'],\n      };\n\n      const headers = {\n        Accept: DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n          mediaTypes,\n          supportedMediaTypes,\n        ),\n      };\n      return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n\n    if (commonMediaType.startsWith('application')) {\n      return this._httpGetMultipartApplicationOctetStream(\n        url,\n        mediaTypes,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetMultipartImage(\n        url,\n        mediaTypes,\n        false,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('video')) {\n      return this._httpGetMultipartVideo(\n        url,\n        mediaTypes,\n        false,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of frames.`,\n    );\n  }\n\n /**\n * Element in mediaTypes parameter\n * @typedef {Object} MediaType\n * @param {String} [MediaType.mediaType] - ie 'image/jpeg', 'image/png'...\n */\n\n  /**\n   * Retrieves an individual, server-side rendered DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {Promise<ArrayBuffer>} Rendered DICOM Instance\n   */\n  retrieveInstanceRendered(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance',\n      );\n    }\n\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}/rendered`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url,\n        headers,\n        responseType,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('video')) {\n      return this._httpGetVideo(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('text')) {\n      return this._httpGetText(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType === MEDIATYPES.PDF) {\n      return this._httpGetApplicationPdf(\n        url,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered instance.',\n    );\n  }\n\n  /**\n   * Retrieves a thumbnail of an DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {ArrayBuffer} Thumbnail\n   */\n  retrieveInstanceThumbnail(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance',\n      );\n    }\n\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}/thumbnail`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url,\n        headers,\n        responseType,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered instance.',\n    );\n  }\n\n  /**\n   * Retrieves rendered frames for a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {ArrayBuffer[]} Rendered Frame Items as byte arrays\n   */\n  retrieveInstanceFramesRendered(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('frameNumbers' in options)) {\n      throw new Error(\n        'frame numbers are required for retrieval of rendered instance frames',\n      );\n    }\n\n    debugLog(\n      `retrieve rendered frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`,\n    );\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}/rendered`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(url, headers, responseType, false, withCredentials);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('video')) {\n      return this._httpGetVideo(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered frame.',\n    );\n  }\n\n  /**\n   * Retrieves thumbnail of frames for a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {ArrayBuffer[]} Rendered Frame Items as byte arrays\n   */\n  retrieveInstanceFramesThumbnail(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('frameNumbers' in options)) {\n      throw new Error(\n        'frame numbers are required for retrieval of rendered instance frames',\n      );\n    }\n\n    console.debug(\n      `retrieve rendered frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`,\n    );\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}/thumbnail`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url,\n        headers,\n        responseType,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered frame.',\n    );\n  }\n\n  /**\n   * Retrieves a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @returns {Promise<ArrayBuffer>} DICOM Part 10 file as Arraybuffer\n   */\n  retrieveInstance(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required');\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error('Series Instance UID is required');\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error('SOP Instance UID is required');\n    }\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}`;\n\n    const { mediaTypes } = options;\n    const { withCredentials = false } = options;\n    const { progressCallback = false } = options;\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      ).then(getFirstResult);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        mediaTypes,\n        false,\n        progressCallback,\n        withCredentials,\n      ).then(getFirstResult);\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of instance.`,\n    );\n  }\n\n  /**\n   * Retrieves all DICOM Instances of a Series.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {Function} options.progressCallback\n   * @returns {Promise<ArrayBuffer[]>} DICOM Instances\n   */\n  retrieveSeries(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required');\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error('Series Instance UID is required');\n    }\n\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}`;\n\n    const { mediaTypes } = options;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        mediaTypes,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of series.`,\n    );\n  }\n\n  /**\n   * Retrieves all DICOM Instances of a Study.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @returns {ArrayBuffer[]} DICOM Instances\n   */\n  retrieveStudy(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required');\n    }\n\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}`;\n\n    const { mediaTypes } = options;\n    const { withCredentials = false } = options;\n    const { progressCallback = false } = options;\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        mediaTypes,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of study.`,\n    );\n  }\n\n  /**\n   * Retrieves and parses BulkData from a BulkDataURI location.\n   * Decodes the multipart encoded data and returns the resulting data\n   * as an ArrayBuffer.\n   *\n   * See http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.5.5.html\n   *\n   * @param {Object} options\n   * @param {string} options.BulkDataURI to retrieve\n   * @param {Array}  options.mediaTypes to use to fetch the URI\n   * @param {string} options.byteRange to request a sub-range (only valid on single part)\n   * @returns {Promise<Array>} Bulkdata parts\n   */\n  retrieveBulkData(options) {\n    if (!('BulkDataURI' in options)) {\n      throw new Error('BulkDataURI is required.');\n    }\n\n    const url = options.BulkDataURI;\n    const { mediaTypes, byteRange } = options;\n    const { withCredentials = false } = options;\n    const { progressCallback = false } = options;\n\n    if (this.singlepart.indexOf('bulkdata') !== -1) {\n      return this._httpGet(url, options.headers, 'arraybuffer', null, withCredentials);\n    }\n\n    if (mediaTypes) {\n      try {\n        const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n\n        if (commonMediaType==='image/') {\n          return this._httpGetMultipartImage(\n            url,\n            mediaTypes,\n            byteRange,\n            false,\n            false,\n            progressCallback,\n            withCredentials,\n          );\n        }\n      } catch(e) {\n        // No-op - this happens sometimes if trying to fetch the specific desired type but want to fallback to octet-stream\n      }\n    }\n\n    // Just use the media types provided\n    return this._httpGetMultipartApplicationOctetStream(\n      url,\n      mediaTypes,\n      byteRange,\n      false,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Stores DICOM Instances.\n   *\n   * @param {Object} options\n   * @param {ArrayBuffer[]} options.datasets - DICOM Instances in PS3.10 format\n   * @param {String} [options.studyInstanceUID] - Study Instance UID\n   * @param {XMLHttpRequest} [options.request] - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n   * @returns {Promise} Response message\n   */\n  storeInstances(options) {\n    if (!('datasets' in options)) {\n      throw new Error('datasets are required for storing');\n    }\n\n    let url = `${this.stowURL}/studies`;\n    if ('studyInstanceUID' in options) {\n      url += `/${options.studyInstanceUID}`;\n    }\n\n    const { data, boundary } = multipartEncode(options.datasets);\n    const headers = {\n      'Content-Type': `multipart/related; type=\"application/dicom\"; boundary=\"${boundary}\"`,\n    };\n    const { withCredentials = false } = options;\n    return this._httpPost(\n      url,\n      headers,\n      data,\n      options.progressCallback,\n      withCredentials,\n      options.request,\n    );\n  }\n\n  \n}\n\n\nexport { DICOMwebClient };\nexport default DICOMwebClient;\n","export default '0.5.2';\n","import { DICOMwebClient } from './api.js';\nimport {\n  getStudyInstanceUIDFromUri,\n  getSeriesInstanceUIDFromUri,\n  getSOPInstanceUIDFromUri,\n  getFrameNumbersFromUri,\n} from './utils.js';\n\nconst api = {\n  DICOMwebClient,\n};\nconst utils = {\n  getStudyInstanceUIDFromUri,\n  getSeriesInstanceUIDFromUri,\n  getSOPInstanceUIDFromUri,\n  getFrameNumbersFromUri,\n};\n\nexport { default as version } from './version.js';\n\nexport { api, utils };\n","\"use strict\"\n\nfunction iota(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = i\n  }\n  return result\n}\n\nmodule.exports = iota","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","var iota = require(\"iota-array\")\nvar isBuffer = require(\"is-buffer\")\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n      case \"[object BigInt64Array]\":\n        return \"bigint64\"\n      case \"[object BigUint64Array]\":\n        return \"biguint64\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"bigint64\": [],\n  \"biguint64\": [],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n","module.exports = {\r\n\t/**\r\n\t * Euclidean distance\r\n\t */\r\n\teudist(v1,v2) {\r\n\t\tvar len = v1.length;\r\n\t\tvar sum = 0;\r\n\r\n\t\tfor(let i=0;i<len;i++) {\r\n\t\t\tvar d = (v1[i]||0) - (v2[i]||0);\r\n\t\t\tsum += d*d;\r\n\t\t}\r\n\t\t// Square root not really needed\r\n\t\treturn sum;\r\n\t},\r\n\r\n\tmandist(v1,v2) {\r\n\t\tvar len = v1.length;\r\n\t\tvar sum = 0, d = 0;\r\n\r\n\t\tfor(let i=0;i<len;i++) {\r\n\t\t\td = (v1[i]||0) - (v2[i]||0);\r\n\t\t\tsum += (d>=0)? d : -d;\r\n\t\t}\r\n\r\n\t\treturn sum;\r\n\t},\r\n\r\n\t/**\r\n\t * Unidimensional distance\r\n\t */\r\n\tdist(v1,v2,sqrt) {\r\n\t\tvar d = Math.abs(v1-v2);\r\n\t\treturn sqrt? d : d*d;\r\n\t}\r\n\r\n}\r\n","const\r\n\tDistance = require(\"./distance.js\"),\r\n\teudist = Distance.eudist,\r\n\tdist = Distance.dist;\r\n\r\nmodule.exports = {\r\n\tkmrand(data,k) {\r\n\t\tvar map = {}, ks = [], t = k<<2;\r\n\t\tvar len = data.length;\r\n\t\tvar multi = data[0].length>0;\r\n\r\n\t\twhile(ks.length<k && (t--)>0) {\r\n\t\t\tlet d = data[Math.floor(Math.random()*len)];\r\n\t\t\tlet key = multi? d.join(\"_\") : `${d}`;\r\n\t\t\tif(!map[key]) {\r\n\t\t\t\tmap[key] = true;\r\n\t\t\t\tks.push(d);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(ks.length<k) throw new Error(\"Error initializating clusters\");\r\n\t\telse return ks;\r\n\t},\r\n\r\n\t/**\r\n\t * K-means++ initial centroid selection\r\n\t */\r\n\tkmpp(data,k,fndist) {\r\n\t\tvar distance = fndist || (data[0].length? eudist : dist);\r\n\t\tvar ks = [], len = data.length;\r\n\t\tvar multi = data[0].length>0;\r\n\t\tvar map = {};\r\n\r\n\t\t// First random centroid\r\n\t\tvar c = data[Math.floor(Math.random()*len)];\r\n\t\tvar key = multi? c.join(\"_\") : `${c}`;\r\n\t\tks.push(c);\r\n\t\tmap[key] = true;\r\n\r\n\t\t// Retrieve next centroids\r\n\t\twhile(ks.length<k) {\r\n\t\t\t// Min Distances between current centroids and data points\r\n\t\t\tlet dists = [], lk = ks.length;\r\n\t\t\tlet dsum = 0, prs = [];\r\n\r\n\t\t\tfor(let i=0;i<len;i++) {\r\n\t\t\t\tlet min = Infinity;\r\n\t\t\t\tfor(let j=0;j<lk;j++) {\r\n\t\t\t\t\tlet dist = distance(data[i],ks[j]);\r\n\t\t\t\t\tif(dist<=min) min = dist;\r\n\t\t\t\t}\r\n\t\t\t\tdists[i] = min;\r\n\t\t\t}\r\n\r\n\t\t\t// Sum all min distances\r\n\t\t\tfor(let i=0;i<len;i++) {\r\n\t\t\t\tdsum += dists[i]\r\n\t\t\t}\r\n\r\n\t\t\t// Probabilities and cummulative prob (cumsum)\r\n\t\t\tfor(let i=0;i<len;i++) {\r\n\t\t\t\tprs[i] = {i:i, v:data[i],\tpr:dists[i]/dsum, cs:0}\r\n\t\t\t}\r\n\r\n\t\t\t// Sort Probabilities\r\n\t\t\tprs.sort((a,b)=>a.pr-b.pr);\r\n\r\n\t\t\t// Cummulative Probabilities\r\n\t\t\tprs[0].cs = prs[0].pr;\r\n\t\t\tfor(let i=1;i<len;i++) {\r\n\t\t\t\tprs[i].cs = prs[i-1].cs + prs[i].pr;\r\n\t\t\t}\r\n\r\n\t\t\t// Randomize\r\n\t\t\tlet rnd = Math.random();\r\n\r\n\t\t\t// Gets only the items whose cumsum >= rnd\r\n\t\t\tlet idx = 0;\r\n\t\t\twhile(idx<len-1 && prs[idx++].cs<rnd);\r\n\t\t\tks.push(prs[idx-1].v);\r\n\t\t\t/*\r\n\t\t\tlet done = false;\r\n\t\t\twhile(!done) {\r\n\t\t\t\t// this is our new centroid\r\n\t\t\t\tc = prs[idx-1].v\r\n\t\t\t\tkey = multi? c.join(\"_\") : `${c}`;\r\n\t\t\t\tif(!map[key]) {\r\n\t\t\t\t\tmap[key] = true;\r\n\t\t\t\t\tks.push(c);\r\n\t\t\t\t\tdone = true;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tidx++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t}\r\n\r\n\t\treturn ks;\r\n\t}\r\n\r\n}\r\n","/*jshint esversion: 6 */\r\n\r\nconst\r\n\tDistance = require(\"./distance.js\"),\r\n\tClusterInit = require(\"./kinit.js\"),\r\n\teudist = Distance.eudist,\r\n\tmandist = Distance.mandist,\r\n\tabsdist = Distance.dist,\r\n\tkmrand = ClusterInit.kmrand,\r\n\tkmpp = ClusterInit.kmpp;\r\n\r\nconst MAX = 10000;\r\n\r\n/**\r\n * Inits an array with values\r\n */\r\nfunction init(len,val,v) {\r\n\tv = v || [];\r\n\tfor(let i=0;i<len;i++) v[i] = val;\r\n\treturn v;\r\n}\r\n\r\nfunction test(point, fndist) {\r\n\tlet\r\n\t\tmulti = Array.isArray(point),\r\n\t\tks = this.centroids,\r\n\t\tk = ks.length;\r\n\r\n\t// For each value in data, find the nearest centroid\r\n\tlet min = Infinity, idx = 0;\r\n\tfor(let j=0;j<k;j++) {\r\n\t\t// Custom, Multidimensional or unidimensional\r\n\t\tlet dist =\tfndist? fndist(point,ks[j]) :\r\n\t\t\t\t\t\t\t\tmulti? eudist(point,ks[j]) :\r\n\t\t\t\t\t\t\t\tMath.abs(point-ks[j]);\r\n\r\n\t\tif(dist<=min) {\r\n\t\t\tmin = dist;\r\n\t\t\tidx = j;\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tidx, centroid:ks[idx]\r\n\t}\r\n}\r\n\r\nfunction skmeans(data,k,initial,maxit,fndist) {\r\n\tvar ks = [], old = [], idxs = [], dist = [];\r\n\tvar conv = false, it = maxit || MAX;\r\n\tvar len = data.length, vlen = data[0].length, multi = vlen>0;\r\n\tvar count = [];\r\n\r\n\tif(!initial) {\r\n\t\tlet idxs = {}, z=0;\r\n\t\twhile(ks.length<k) {\r\n\t\t\tlet idx = Math.floor(Math.random()*len);\r\n\t\t\tif(!idxs[idx]) {\r\n\t\t\t\tidxs[idx] = true;\r\n\t\t\t\tks[z++] = data[idx];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse if(initial==\"kmrand\") {\r\n\t\tks = kmrand(data,k);\r\n\t}\r\n\telse if(initial==\"kmpp\") {\r\n\t\tks = kmpp(data,k,fndist);\r\n\t}\r\n\telse {\r\n\t\tks = initial;\r\n\t}\r\n\r\n\tdo {\r\n\t\t// Reset k count\r\n\t\tinit(k,0,count);\r\n\r\n\t\t// For each value in data, find the nearest centroid\r\n\t\tfor(let i=0;i<len;i++) {\r\n\t\t\tlet min = Infinity, idx = 0;\r\n\t\t\tfor(let j=0;j<k;j++) {\r\n\t\t\t\t// Custom, Multidimensional or unidimensional\r\n\t\t\t\tvar dist =\tfndist ? fndist(data[i],ks[j]) :\r\n\t\t\t\t\t\t\t\t\t\tmulti? eudist(data[i],ks[j]) :\r\n\t\t\t\t\t\t\t\t\t\tMath.abs(data[i]-ks[j]);\r\n\r\n\t\t\t\tif(dist<=min) {\r\n\t\t\t\t\tmin = dist;\r\n\t\t\t\t\tidx = j;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tidxs[i] = idx;\t// Index of the selected centroid for that value\r\n\t\t\tcount[idx]++;\t\t// Number of values for this centroid\r\n\t\t}\r\n\r\n\t\t// Recalculate centroids\r\n\t\tvar sum = [], old = [], dif = 0;\r\n\t\tif(multi) {\r\n\t\t\tfor(let j=0;j<k;j++) {\r\n\t\t\t\tsum[j] = init(vlen,0,sum[j]);\r\n\t\t\t\told[j] = ks[j];\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfor(let j=0;j<k;j++) {\r\n\t\t\t\tsum[j] = 0;\r\n\t\t\t\told[j] = ks[j];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If multidimensional\r\n\t\tif(multi) {\r\n\t\t\tfor(let j=0;j<k;j++) ks[j] = [];\r\n\r\n\t\t\t// Sum values and count for each centroid\r\n\t\t\tfor(let i=0;i<len;i++) {\r\n\t\t\t\tlet\tidx = idxs[i],\t\t// Centroid for that item\r\n\t\t\t\t\t\tvsum = sum[idx],\t// Sum values for this centroid\r\n\t\t\t\t\t\tvect = data[i];\t\t// Current vector\r\n\r\n\t\t\t\t// Accumulate value on the centroid for current vector\r\n\t\t\t\tfor(let h=0;h<vlen;h++) {\r\n\t\t\t\t\tvsum[h] += vect[h];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Calculate the average for each centroid\r\n\t\t\tconv = true;\r\n\t\t\tfor(let j=0;j<k;j++) {\r\n\t\t\t\tlet ksj = ks[j],\t\t// Current centroid\r\n\t\t\t\t\t\tsumj = sum[j],\t// Accumulated centroid values\r\n\t\t\t\t\t\toldj = old[j], \t// Old centroid value\r\n\t\t\t\t\t\tcj = count[j];\t// Number of elements for this centroid\r\n\r\n\t\t\t\t// New average\r\n\t\t\t\tfor(let h=0;h<vlen;h++) {\r\n\t\t\t\t\tksj[h] = (sumj[h])/(cj) || 0;\t// New centroid\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Find if centroids have moved\r\n\t\t\t\tif(conv) {\r\n\t\t\t\t\tfor(let h=0;h<vlen;h++) {\r\n\t\t\t\t\t\tif(oldj[h]!=ksj[h]) {\r\n\t\t\t\t\t\t\tconv = false;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// If unidimensional\r\n\t\telse {\r\n\t\t\t// Sum values and count for each centroid\r\n\t\t\tfor(let i=0;i<len;i++) {\r\n\t\t\t\tlet idx = idxs[i];\r\n\t\t\t\tsum[idx] += data[i];\r\n\t\t\t}\r\n\t\t\t// Calculate the average for each centroid\r\n\t\t\tfor(let j=0;j<k;j++) {\r\n\t\t\t\tks[j] = sum[j]/count[j] || 0;\t// New centroid\r\n\t\t\t}\r\n\t\t\t// Find if centroids have moved\r\n\t\t\tconv = true;\r\n\t\t\tfor(let j=0;j<k;j++) {\r\n\t\t\t\tif(old[j]!=ks[j]) {\r\n\t\t\t\t\tconv = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconv = conv || (--it<=0);\r\n\t}while(!conv);\r\n\r\n\treturn {\r\n\t\tit : (maxit || MAX) - it,\r\n\t\tk : k,\r\n\t\tidxs : idxs,\r\n\t\tcentroids : ks,\r\n\t\ttest : test\r\n\t};\r\n}\r\n\r\nmodule.exports = skmeans;\r\n","\"use strict\"\n\nvar ndarray = require(\"ndarray\")\n\nfunction dtypeToType(dtype) {\n  switch(dtype) {\n    case 'uint8':\n      return Uint8Array;\n    case 'uint16':\n      return Uint16Array;\n    case 'uint32':\n      return Uint32Array;\n    case 'int8':\n      return Int8Array;\n    case 'int16':\n      return Int16Array;\n    case 'int32':\n      return Int32Array;\n    case 'float':\n    case 'float32':\n      return Float32Array;\n    case 'double':\n    case 'float64':\n      return Float64Array;\n    case 'uint8_clamped':\n      return Uint8ClampedArray;\n    case 'generic':\n    case 'buffer':\n    case 'data':\n    case 'dataview':\n      return ArrayBuffer;\n    case 'array':\n      return Array;\n  }\n}\n\nmodule.exports = function zeros(shape, dtype) {\n  dtype = dtype || 'float64';\n  var sz = 1;\n  for(var i=0; i<shape.length; ++i) {\n    sz *= shape[i];\n  }\n  return ndarray(new (dtypeToType(dtype))(sz), shape);\n}\n"],"names":["stringToUint8Array","str","arr","Uint8Array","length","i","j","charCodeAt","containsToken","message","token","offset","index","findToken","maxSearchLength","searchLength","Math","min","multipartEncode","datasets","boundary","s4","floor","random","toString","substring","guid","contentTypeString","header","footer","headerArray","footerArray","headerLength","footerLength","contentArrays","map","datasetBuffer","contentArray","contentLength","multipartArray","set","position","forEach","data","buffer","multipartDecode","response","ArrayBuffer","isView","separator","headerIndex","Error","itemLimit","String","fromCharCode","uint8ArrayToString","boundaryString","parts","split","substr","identifyBoundary","boundaryIndex","boundaryLength","components","headerTokenIndex","slice","push","isObject","obj","isEmptyObject","Object","keys","constructor","getFirstResult","result","MEDIATYPES","DICOM","DICOM_JSON","OCTET_STREAM","PDF","JPEG","PNG","debugLog","api","DICOMwebClient","options","this","baseURL","url","console","error","username","password","qidoURLPrefix","qidoURL","wadoURLPrefix","wadoURL","stowURLPrefix","stowURL","singlepart","requestHooks","headers","errorInterceptor","verbose","setDebug","debug","debugLevel","debugLogFunction","log","method","Promise","resolve","reject","request","XMLHttpRequest","open","responseType","key","setRequestHeader","functions","userHeaders","onloadstart","onloadend","onreadystatechange","readyState","status","contentType","getResponseHeader","indexOf","warn","progressCallback","onprogress","isValid","Array","isArray","every","requestHook","areValidRequestHooks","combinedHeaders","assign","metadata","pipedRequest","args","reduce","props","fn","withCredentials","send","_httpRequest","params","urlWithQueryParams","_parseQueryParameters","Accept","_httpGet","mediaTypes","_buildAcceptHeaderFieldValue","byteRange","supportedMediaTypes","Range","_buildRangeHeaderFieldValue","_buildMultipartAcceptHeaderFieldValue","defaultMediaType","acceptableMediaTypes","mediaType","values","_httpPost","queryParams","_httpGetApplicationJson","studyInstanceUID","seriesInstanceUID","transferSyntax","sopInstanceUID","paramString","join","frameNumbers","_httpGetMultipartApplicationOctetStream","_getSharedMediaTypes","commonMediaType","_getCommonMediaType","startsWith","_httpGetMultipartImage","_httpGetMultipartVideo","_httpGetImage","_httpGetVideo","_httpGetText","_httpGetApplicationPdf","_httpGetMultipartApplicationDicom","then","BulkDataURI","e","queryString","encodeURIComponent","sepIndex","mediaTypeType","includes","_assertMediaTypeIsValid","item","fieldValueParts","transferSyntaxUID","fieldValue","flat","endsWith","expectedMediaTypes","actualType","_parseMediaType","expectedMediaType","expectedType","JSON","stringify","types","Set","type","add","from","sharedMediaTypes","module","exports","n","isBuffer","iota","hasTypedArrays","Float64Array","compare1st","a","b","order","stride","terms","abs","sort","compileConstructor","dtype","dimension","className","useGetters","code","Function","procedure","CACHED_CONSTRUCTORS","indices","index_str","shapeArg","strideArg","a_vars","c_vars","tShape","tStride","idx","shape","undefined","ctor","array","d","sz","prototype","call","arrayDType","ctor_list","eudist","v1","v2","len","sum","mandist","dist","sqrt","Distance","require","kmrand","k","ks","t","multi","kmpp","fndist","distance","c","dists","lk","dsum","prs","Infinity","v","pr","cs","rnd","ClusterInit","init","val","test","point","centroids","centroid","initial","maxit","old","idxs","conv","it","vlen","count","z","vsum","vect","h","ksj","sumj","oldj","cj","ndarray","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float32Array","Uint8ClampedArray"],"sourceRoot":""}