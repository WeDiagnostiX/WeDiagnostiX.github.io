{"version":3,"file":"625.bundle.4b4a91f0a3af19e971d0.js","mappings":"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","sources":["webpack:///../../../node_modules/complex.js/complex.js","webpack:///../../../node_modules/escape-latex/dist/index.js","webpack:///../../../node_modules/javascript-natural-sort/naturalSort.js","webpack:///../../../node_modules/tiny-emitter/index.js","webpack:///../../../node_modules/typed-function/lib/esm/typed-function.mjs"],"sourcesContent":["/**\n * @license Complex.js v2.1.1 12/05/2020\n *\n * Copyright (c) 2020, Robert Eisele (robert@xarg.org)\n * Dual licensed under the MIT or GPL Version 2 licenses.\n **/\n\n/**\n *\n * This class allows the manipulation of complex numbers.\n * You can pass a complex number in different formats. Either as object, double, string or two integer parameters.\n *\n * Object form\n * { re: <real>, im: <imaginary> }\n * { arg: <angle>, abs: <radius> }\n * { phi: <angle>, r: <radius> }\n *\n * Array / Vector form\n * [ real, imaginary ]\n *\n * Double form\n * 99.3 - Single double value\n *\n * String form\n * '23.1337' - Simple real number\n * '15+3i' - a simple complex number\n * '3-i' - a simple complex number\n *\n * Example:\n *\n * var c = new Complex('99.3+8i');\n * c.mul({r: 3, i: 9}).div(4.9).sub(3, 2);\n *\n */\n\n(function(root) {\n\n  'use strict';\n\n  var cosh = Math.cosh || function(x) {\n    return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;\n  };\n\n  var sinh = Math.sinh || function(x) {\n    return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;\n  };\n\n  /**\n   * Calculates cos(x) - 1 using Taylor series if x is small (-¼π ≤ x ≤ ¼π).\n   *\n   * @param {number} x\n   * @returns {number} cos(x) - 1\n   */\n  var cosm1 = function(x) {\n\n    var b = Math.PI / 4;\n    if (-b > x || x > b) {\n      return Math.cos(x) - 1.0;\n    }\n\n    /* Calculate horner form of polynomial of taylor series in Q\n    var fac = 1, alt = 1, pol = {};\n    for (var i = 0; i <= 16; i++) {\n      fac*= i || 1;\n      if (i % 2 == 0) {\n        pol[i] = new Fraction(1, alt * fac);\n        alt = -alt;\n      }\n    }\n    console.log(new Polynomial(pol).toHorner()); // (((((((1/20922789888000x^2-1/87178291200)x^2+1/479001600)x^2-1/3628800)x^2+1/40320)x^2-1/720)x^2+1/24)x^2-1/2)x^2+1\n    */\n\n    var xx = x * x;\n    return xx * (\n      xx * (\n        xx * (\n          xx * (\n            xx * (\n              xx * (\n                xx * (\n                  xx / 20922789888000\n                  - 1 / 87178291200)\n                + 1 / 479001600)\n              - 1 / 3628800)\n            + 1 / 40320)\n          - 1 / 720)\n        + 1 / 24)\n      - 1 / 2);\n  };\n\n  var hypot = function(x, y) {\n\n    var a = Math.abs(x);\n    var b = Math.abs(y);\n\n    if (a < 3000 && b < 3000) {\n      return Math.sqrt(a * a + b * b);\n    }\n\n    if (a < b) {\n      a = b;\n      b = x / y;\n    } else {\n      b = y / x;\n    }\n    return a * Math.sqrt(1 + b * b);\n  };\n\n  var parser_exit = function() {\n    throw SyntaxError('Invalid Param');\n  };\n\n  /**\n   * Calculates log(sqrt(a^2+b^2)) in a way to avoid overflows\n   *\n   * @param {number} a\n   * @param {number} b\n   * @returns {number}\n   */\n  function logHypot(a, b) {\n\n    var _a = Math.abs(a);\n    var _b = Math.abs(b);\n\n    if (a === 0) {\n      return Math.log(_b);\n    }\n\n    if (b === 0) {\n      return Math.log(_a);\n    }\n\n    if (_a < 3000 && _b < 3000) {\n      return Math.log(a * a + b * b) * 0.5;\n    }\n\n    /* I got 4 ideas to compute this property without overflow:\n     *\n     * Testing 1000000 times with random samples for a,b ∈ [1, 1000000000] against a big decimal library to get an error estimate\n     *\n     * 1. Only eliminate the square root: (OVERALL ERROR: 3.9122483030951116e-11)\n\n     Math.log(a * a + b * b) / 2\n\n     *\n     *\n     * 2. Try to use the non-overflowing pythagoras: (OVERALL ERROR: 8.889760039210159e-10)\n\n     var fn = function(a, b) {\n     a = Math.abs(a);\n     b = Math.abs(b);\n     var t = Math.min(a, b);\n     a = Math.max(a, b);\n     t = t / a;\n\n     return Math.log(a) + Math.log(1 + t * t) / 2;\n     };\n\n     * 3. Abuse the identity cos(atan(y/x) = x / sqrt(x^2+y^2): (OVERALL ERROR: 3.4780178737037204e-10)\n\n     Math.log(a / Math.cos(Math.atan2(b, a)))\n\n     * 4. Use 3. and apply log rules: (OVERALL ERROR: 1.2014087502620896e-9)\n\n     Math.log(a) - Math.log(Math.cos(Math.atan2(b, a)))\n\n     */\n\n     a = a / 2;\n     b = b / 2;\n\n    return 0.5 * Math.log(a * a + b * b) + Math.LN2;\n  }\n\n  var parse = function(a, b) {\n\n    var z = { 're': 0, 'im': 0 };\n\n    if (a === undefined || a === null) {\n      z['re'] =\n      z['im'] = 0;\n    } else if (b !== undefined) {\n      z['re'] = a;\n      z['im'] = b;\n    } else\n      switch (typeof a) {\n\n        case 'object':\n\n          if ('im' in a && 're' in a) {\n            z['re'] = a['re'];\n            z['im'] = a['im'];\n          } else if ('abs' in a && 'arg' in a) {\n            if (!Number.isFinite(a['abs']) && Number.isFinite(a['arg'])) {\n              return Complex['INFINITY'];\n            }\n            z['re'] = a['abs'] * Math.cos(a['arg']);\n            z['im'] = a['abs'] * Math.sin(a['arg']);\n          } else if ('r' in a && 'phi' in a) {\n            if (!Number.isFinite(a['r']) && Number.isFinite(a['phi'])) {\n              return Complex['INFINITY'];\n            }\n            z['re'] = a['r'] * Math.cos(a['phi']);\n            z['im'] = a['r'] * Math.sin(a['phi']);\n          } else if (a.length === 2) { // Quick array check\n            z['re'] = a[0];\n            z['im'] = a[1];\n          } else {\n            parser_exit();\n          }\n          break;\n\n        case 'string':\n\n          z['im'] = /* void */\n          z['re'] = 0;\n\n          var tokens = a.match(/\\d+\\.?\\d*e[+-]?\\d+|\\d+\\.?\\d*|\\.\\d+|./g);\n          var plus = 1;\n          var minus = 0;\n\n          if (tokens === null) {\n            parser_exit();\n          }\n\n          for (var i = 0; i < tokens.length; i++) {\n\n            var c = tokens[i];\n\n            if (c === ' ' || c === '\\t' || c === '\\n') {\n              /* void */\n            } else if (c === '+') {\n              plus++;\n            } else if (c === '-') {\n              minus++;\n            } else if (c === 'i' || c === 'I') {\n\n              if (plus + minus === 0) {\n                parser_exit();\n              }\n\n              if (tokens[i + 1] !== ' ' && !isNaN(tokens[i + 1])) {\n                z['im'] += parseFloat((minus % 2 ? '-' : '') + tokens[i + 1]);\n                i++;\n              } else {\n                z['im'] += parseFloat((minus % 2 ? '-' : '') + '1');\n              }\n              plus = minus = 0;\n\n            } else {\n\n              if (plus + minus === 0 || isNaN(c)) {\n                parser_exit();\n              }\n\n              if (tokens[i + 1] === 'i' || tokens[i + 1] === 'I') {\n                z['im'] += parseFloat((minus % 2 ? '-' : '') + c);\n                i++;\n              } else {\n                z['re'] += parseFloat((minus % 2 ? '-' : '') + c);\n              }\n              plus = minus = 0;\n            }\n          }\n\n          // Still something on the stack\n          if (plus + minus > 0) {\n            parser_exit();\n          }\n          break;\n\n        case 'number':\n          z['im'] = 0;\n          z['re'] = a;\n          break;\n\n        default:\n          parser_exit();\n      }\n\n    if (isNaN(z['re']) || isNaN(z['im'])) {\n      // If a calculation is NaN, we treat it as NaN and don't throw\n      //parser_exit();\n    }\n\n    return z;\n  };\n\n  /**\n   * @constructor\n   * @returns {Complex}\n   */\n  function Complex(a, b) {\n\n    if (!(this instanceof Complex)) {\n      return new Complex(a, b);\n    }\n\n    var z = parse(a, b);\n\n    this['re'] = z['re'];\n    this['im'] = z['im'];\n  }\n\n  Complex.prototype = {\n\n    're': 0,\n    'im': 0,\n\n    /**\n     * Calculates the sign of a complex number, which is a normalized complex\n     *\n     * @returns {Complex}\n     */\n    'sign': function() {\n\n      var abs = this['abs']();\n\n      return new Complex(\n        this['re'] / abs,\n        this['im'] / abs);\n    },\n\n    /**\n     * Adds two complex numbers\n     *\n     * @returns {Complex}\n     */\n    'add': function(a, b) {\n\n      var z = new Complex(a, b);\n\n      // Infinity + Infinity = NaN\n      if (this['isInfinite']() && z['isInfinite']()) {\n        return Complex['NAN'];\n      }\n\n      // Infinity + z = Infinity { where z != Infinity }\n      if (this['isInfinite']() || z['isInfinite']()) {\n        return Complex['INFINITY'];\n      }\n\n      return new Complex(\n        this['re'] + z['re'],\n        this['im'] + z['im']);\n    },\n\n    /**\n     * Subtracts two complex numbers\n     *\n     * @returns {Complex}\n     */\n    'sub': function(a, b) {\n\n      var z = new Complex(a, b);\n\n      // Infinity - Infinity = NaN\n      if (this['isInfinite']() && z['isInfinite']()) {\n        return Complex['NAN'];\n      }\n\n      // Infinity - z = Infinity { where z != Infinity }\n      if (this['isInfinite']() || z['isInfinite']()) {\n        return Complex['INFINITY'];\n      }\n\n      return new Complex(\n        this['re'] - z['re'],\n        this['im'] - z['im']);\n    },\n\n    /**\n     * Multiplies two complex numbers\n     *\n     * @returns {Complex}\n     */\n    'mul': function(a, b) {\n\n      var z = new Complex(a, b);\n\n      // Infinity * 0 = NaN\n      if ((this['isInfinite']() && z['isZero']()) || (this['isZero']() && z['isInfinite']())) {\n        return Complex['NAN'];\n      }\n\n      // Infinity * z = Infinity { where z != 0 }\n      if (this['isInfinite']() || z['isInfinite']()) {\n        return Complex['INFINITY'];\n      }\n\n      // Short circuit for real values\n      if (z['im'] === 0 && this['im'] === 0) {\n        return new Complex(this['re'] * z['re'], 0);\n      }\n\n      return new Complex(\n        this['re'] * z['re'] - this['im'] * z['im'],\n        this['re'] * z['im'] + this['im'] * z['re']);\n    },\n\n    /**\n     * Divides two complex numbers\n     *\n     * @returns {Complex}\n     */\n    'div': function(a, b) {\n\n      var z = new Complex(a, b);\n\n      // 0 / 0 = NaN and Infinity / Infinity = NaN\n      if ((this['isZero']() && z['isZero']()) || (this['isInfinite']() && z['isInfinite']())) {\n        return Complex['NAN'];\n      }\n\n      // Infinity / 0 = Infinity\n      if (this['isInfinite']() || z['isZero']()) {\n        return Complex['INFINITY'];\n      }\n\n      // 0 / Infinity = 0\n      if (this['isZero']() || z['isInfinite']()) {\n        return Complex['ZERO'];\n      }\n\n      a = this['re'];\n      b = this['im'];\n\n      var c = z['re'];\n      var d = z['im'];\n      var t, x;\n\n      if (0 === d) {\n        // Divisor is real\n        return new Complex(a / c, b / c);\n      }\n\n      if (Math.abs(c) < Math.abs(d)) {\n\n        x = c / d;\n        t = c * x + d;\n\n        return new Complex(\n          (a * x + b) / t,\n          (b * x - a) / t);\n\n      } else {\n\n        x = d / c;\n        t = d * x + c;\n\n        return new Complex(\n          (a + b * x) / t,\n          (b - a * x) / t);\n      }\n    },\n\n    /**\n     * Calculate the power of two complex numbers\n     *\n     * @returns {Complex}\n     */\n    'pow': function(a, b) {\n\n      var z = new Complex(a, b);\n\n      a = this['re'];\n      b = this['im'];\n\n      if (z['isZero']()) {\n        return Complex['ONE'];\n      }\n\n      // If the exponent is real\n      if (z['im'] === 0) {\n\n        if (b === 0 && a > 0) {\n\n          return new Complex(Math.pow(a, z['re']), 0);\n\n        } else if (a === 0) { // If base is fully imaginary\n\n          switch ((z['re'] % 4 + 4) % 4) {\n            case 0:\n              return new Complex(Math.pow(b, z['re']), 0);\n            case 1:\n              return new Complex(0, Math.pow(b, z['re']));\n            case 2:\n              return new Complex(-Math.pow(b, z['re']), 0);\n            case 3:\n              return new Complex(0, -Math.pow(b, z['re']));\n          }\n        }\n      }\n\n      /* I couldn't find a good formula, so here is a derivation and optimization\n       *\n       * z_1^z_2 = (a + bi)^(c + di)\n       *         = exp((c + di) * log(a + bi)\n       *         = pow(a^2 + b^2, (c + di) / 2) * exp(i(c + di)atan2(b, a))\n       * =>...\n       * Re = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * cos(d * log(a^2 + b^2) / 2 + c * atan2(b, a))\n       * Im = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * sin(d * log(a^2 + b^2) / 2 + c * atan2(b, a))\n       *\n       * =>...\n       * Re = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * cos(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))\n       * Im = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * sin(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))\n       *\n       * =>\n       * Re = exp(c * logsq2 - d * arg(z_1)) * cos(d * logsq2 + c * arg(z_1))\n       * Im = exp(c * logsq2 - d * arg(z_1)) * sin(d * logsq2 + c * arg(z_1))\n       *\n       */\n\n      if (a === 0 && b === 0 && z['re'] > 0 && z['im'] >= 0) {\n        return Complex['ZERO'];\n      }\n\n      var arg = Math.atan2(b, a);\n      var loh = logHypot(a, b);\n\n      a = Math.exp(z['re'] * loh - z['im'] * arg);\n      b = z['im'] * loh + z['re'] * arg;\n      return new Complex(\n        a * Math.cos(b),\n        a * Math.sin(b));\n    },\n\n    /**\n     * Calculate the complex square root\n     *\n     * @returns {Complex}\n     */\n    'sqrt': function() {\n\n      var a = this['re'];\n      var b = this['im'];\n      var r = this['abs']();\n\n      var re, im;\n\n      if (a >= 0) {\n\n        if (b === 0) {\n          return new Complex(Math.sqrt(a), 0);\n        }\n\n        re = 0.5 * Math.sqrt(2.0 * (r + a));\n      } else {\n        re = Math.abs(b) / Math.sqrt(2 * (r - a));\n      }\n\n      if (a <= 0) {\n        im = 0.5 * Math.sqrt(2.0 * (r - a));\n      } else {\n        im = Math.abs(b) / Math.sqrt(2 * (r + a));\n      }\n\n      return new Complex(re, b < 0 ? -im : im);\n    },\n\n    /**\n     * Calculate the complex exponent\n     *\n     * @returns {Complex}\n     */\n    'exp': function() {\n\n      var tmp = Math.exp(this['re']);\n\n      if (this['im'] === 0) {\n        //return new Complex(tmp, 0);\n      }\n      return new Complex(\n        tmp * Math.cos(this['im']),\n        tmp * Math.sin(this['im']));\n    },\n\n    /**\n     * Calculate the complex exponent and subtracts one.\n     *\n     * This may be more accurate than `Complex(x).exp().sub(1)` if\n     * `x` is small.\n     *\n     * @returns {Complex}\n     */\n    'expm1': function() {\n\n      /**\n       * exp(a + i*b) - 1\n       = exp(a) * (cos(b) + j*sin(b)) - 1\n       = expm1(a)*cos(b) + cosm1(b) + j*exp(a)*sin(b)\n       */\n\n      var a = this['re'];\n      var b = this['im'];\n\n      return new Complex(\n        Math.expm1(a) * Math.cos(b) + cosm1(b),\n        Math.exp(a) * Math.sin(b));\n    },\n\n    /**\n     * Calculate the natural log\n     *\n     * @returns {Complex}\n     */\n    'log': function() {\n\n      var a = this['re'];\n      var b = this['im'];\n\n      if (b === 0 && a > 0) {\n        //return new Complex(Math.log(a), 0);\n      }\n\n      return new Complex(\n        logHypot(a, b),\n        Math.atan2(b, a));\n    },\n\n    /**\n     * Calculate the magnitude of the complex number\n     *\n     * @returns {number}\n     */\n    'abs': function() {\n\n      return hypot(this['re'], this['im']);\n    },\n\n    /**\n     * Calculate the angle of the complex number\n     *\n     * @returns {number}\n     */\n    'arg': function() {\n\n      return Math.atan2(this['im'], this['re']);\n    },\n\n    /**\n     * Calculate the sine of the complex number\n     *\n     * @returns {Complex}\n     */\n    'sin': function() {\n\n      // sin(z) = ( e^iz - e^-iz ) / 2i \n      //        = sin(a)cosh(b) + i cos(a)sinh(b)\n\n      var a = this['re'];\n      var b = this['im'];\n\n      return new Complex(\n        Math.sin(a) * cosh(b),\n        Math.cos(a) * sinh(b));\n    },\n\n    /**\n     * Calculate the cosine\n     *\n     * @returns {Complex}\n     */\n    'cos': function() {\n\n      // cos(z) = ( e^iz + e^-iz ) / 2 \n      //        = cos(a)cosh(b) - i sin(a)sinh(b)\n\n      var a = this['re'];\n      var b = this['im'];\n\n      return new Complex(\n        Math.cos(a) * cosh(b),\n        -Math.sin(a) * sinh(b));\n    },\n\n    /**\n     * Calculate the tangent\n     *\n     * @returns {Complex}\n     */\n    'tan': function() {\n\n      // tan(z) = sin(z) / cos(z) \n      //        = ( e^iz - e^-iz ) / ( i( e^iz + e^-iz ) )\n      //        = ( e^2iz - 1 ) / i( e^2iz + 1 )\n      //        = ( sin(2a) + i sinh(2b) ) / ( cos(2a) + cosh(2b) )\n\n      var a = 2 * this['re'];\n      var b = 2 * this['im'];\n      var d = Math.cos(a) + cosh(b);\n\n      return new Complex(\n        Math.sin(a) / d,\n        sinh(b) / d);\n    },\n\n    /**\n     * Calculate the cotangent\n     *\n     * @returns {Complex}\n     */\n    'cot': function() {\n\n      // cot(c) = i(e^(ci) + e^(-ci)) / (e^(ci) - e^(-ci))\n\n      var a = 2 * this['re'];\n      var b = 2 * this['im'];\n      var d = Math.cos(a) - cosh(b);\n\n      return new Complex(\n        -Math.sin(a) / d,\n        sinh(b) / d);\n    },\n\n    /**\n     * Calculate the secant\n     *\n     * @returns {Complex}\n     */\n    'sec': function() {\n\n      // sec(c) = 2 / (e^(ci) + e^(-ci))\n\n      var a = this['re'];\n      var b = this['im'];\n      var d = 0.5 * cosh(2 * b) + 0.5 * Math.cos(2 * a);\n\n      return new Complex(\n        Math.cos(a) * cosh(b) / d,\n        Math.sin(a) * sinh(b) / d);\n    },\n\n    /**\n     * Calculate the cosecans\n     *\n     * @returns {Complex}\n     */\n    'csc': function() {\n\n      // csc(c) = 2i / (e^(ci) - e^(-ci))\n\n      var a = this['re'];\n      var b = this['im'];\n      var d = 0.5 * cosh(2 * b) - 0.5 * Math.cos(2 * a);\n\n      return new Complex(\n        Math.sin(a) * cosh(b) / d,\n        -Math.cos(a) * sinh(b) / d);\n    },\n\n    /**\n     * Calculate the complex arcus sinus\n     *\n     * @returns {Complex}\n     */\n    'asin': function() {\n\n      // asin(c) = -i * log(ci + sqrt(1 - c^2))\n\n      var a = this['re'];\n      var b = this['im'];\n\n      var t1 = new Complex(\n        b * b - a * a + 1,\n        -2 * a * b)['sqrt']();\n\n      var t2 = new Complex(\n        t1['re'] - b,\n        t1['im'] + a)['log']();\n\n      return new Complex(t2['im'], -t2['re']);\n    },\n\n    /**\n     * Calculate the complex arcus cosinus\n     *\n     * @returns {Complex}\n     */\n    'acos': function() {\n\n      // acos(c) = i * log(c - i * sqrt(1 - c^2))\n\n      var a = this['re'];\n      var b = this['im'];\n\n      var t1 = new Complex(\n        b * b - a * a + 1,\n        -2 * a * b)['sqrt']();\n\n      var t2 = new Complex(\n        t1['re'] - b,\n        t1['im'] + a)['log']();\n\n      return new Complex(Math.PI / 2 - t2['im'], t2['re']);\n    },\n\n    /**\n     * Calculate the complex arcus tangent\n     *\n     * @returns {Complex}\n     */\n    'atan': function() {\n\n      // atan(c) = i / 2 log((i + x) / (i - x))\n\n      var a = this['re'];\n      var b = this['im'];\n\n      if (a === 0) {\n\n        if (b === 1) {\n          return new Complex(0, Infinity);\n        }\n\n        if (b === -1) {\n          return new Complex(0, -Infinity);\n        }\n      }\n\n      var d = a * a + (1.0 - b) * (1.0 - b);\n\n      var t1 = new Complex(\n        (1 - b * b - a * a) / d,\n        -2 * a / d).log();\n\n      return new Complex(-0.5 * t1['im'], 0.5 * t1['re']);\n    },\n\n    /**\n     * Calculate the complex arcus cotangent\n     *\n     * @returns {Complex}\n     */\n    'acot': function() {\n\n      // acot(c) = i / 2 log((c - i) / (c + i))\n\n      var a = this['re'];\n      var b = this['im'];\n\n      if (b === 0) {\n        return new Complex(Math.atan2(1, a), 0);\n      }\n\n      var d = a * a + b * b;\n      return (d !== 0)\n        ? new Complex(\n          a / d,\n          -b / d).atan()\n        : new Complex(\n          (a !== 0) ? a / 0 : 0,\n          (b !== 0) ? -b / 0 : 0).atan();\n    },\n\n    /**\n     * Calculate the complex arcus secant\n     *\n     * @returns {Complex}\n     */\n    'asec': function() {\n\n      // asec(c) = -i * log(1 / c + sqrt(1 - i / c^2))\n\n      var a = this['re'];\n      var b = this['im'];\n\n      if (a === 0 && b === 0) {\n        return new Complex(0, Infinity);\n      }\n\n      var d = a * a + b * b;\n      return (d !== 0)\n        ? new Complex(\n          a / d,\n          -b / d).acos()\n        : new Complex(\n          (a !== 0) ? a / 0 : 0,\n          (b !== 0) ? -b / 0 : 0).acos();\n    },\n\n    /**\n     * Calculate the complex arcus cosecans\n     *\n     * @returns {Complex}\n     */\n    'acsc': function() {\n\n      // acsc(c) = -i * log(i / c + sqrt(1 - 1 / c^2))\n\n      var a = this['re'];\n      var b = this['im'];\n\n      if (a === 0 && b === 0) {\n        return new Complex(Math.PI / 2, Infinity);\n      }\n\n      var d = a * a + b * b;\n      return (d !== 0)\n        ? new Complex(\n          a / d,\n          -b / d).asin()\n        : new Complex(\n          (a !== 0) ? a / 0 : 0,\n          (b !== 0) ? -b / 0 : 0).asin();\n    },\n\n    /**\n     * Calculate the complex sinh\n     *\n     * @returns {Complex}\n     */\n    'sinh': function() {\n\n      // sinh(c) = (e^c - e^-c) / 2\n\n      var a = this['re'];\n      var b = this['im'];\n\n      return new Complex(\n        sinh(a) * Math.cos(b),\n        cosh(a) * Math.sin(b));\n    },\n\n    /**\n     * Calculate the complex cosh\n     *\n     * @returns {Complex}\n     */\n    'cosh': function() {\n\n      // cosh(c) = (e^c + e^-c) / 2\n\n      var a = this['re'];\n      var b = this['im'];\n\n      return new Complex(\n        cosh(a) * Math.cos(b),\n        sinh(a) * Math.sin(b));\n    },\n\n    /**\n     * Calculate the complex tanh\n     *\n     * @returns {Complex}\n     */\n    'tanh': function() {\n\n      // tanh(c) = (e^c - e^-c) / (e^c + e^-c)\n\n      var a = 2 * this['re'];\n      var b = 2 * this['im'];\n      var d = cosh(a) + Math.cos(b);\n\n      return new Complex(\n        sinh(a) / d,\n        Math.sin(b) / d);\n    },\n\n    /**\n     * Calculate the complex coth\n     *\n     * @returns {Complex}\n     */\n    'coth': function() {\n\n      // coth(c) = (e^c + e^-c) / (e^c - e^-c)\n\n      var a = 2 * this['re'];\n      var b = 2 * this['im'];\n      var d = cosh(a) - Math.cos(b);\n\n      return new Complex(\n        sinh(a) / d,\n        -Math.sin(b) / d);\n    },\n\n    /**\n     * Calculate the complex coth\n     *\n     * @returns {Complex}\n     */\n    'csch': function() {\n\n      // csch(c) = 2 / (e^c - e^-c)\n\n      var a = this['re'];\n      var b = this['im'];\n      var d = Math.cos(2 * b) - cosh(2 * a);\n\n      return new Complex(\n        -2 * sinh(a) * Math.cos(b) / d,\n        2 * cosh(a) * Math.sin(b) / d);\n    },\n\n    /**\n     * Calculate the complex sech\n     *\n     * @returns {Complex}\n     */\n    'sech': function() {\n\n      // sech(c) = 2 / (e^c + e^-c)\n\n      var a = this['re'];\n      var b = this['im'];\n      var d = Math.cos(2 * b) + cosh(2 * a);\n\n      return new Complex(\n        2 * cosh(a) * Math.cos(b) / d,\n        -2 * sinh(a) * Math.sin(b) / d);\n    },\n\n    /**\n     * Calculate the complex asinh\n     *\n     * @returns {Complex}\n     */\n    'asinh': function() {\n\n      // asinh(c) = log(c + sqrt(c^2 + 1))\n\n      var tmp = this['im'];\n      this['im'] = -this['re'];\n      this['re'] = tmp;\n      var res = this['asin']();\n\n      this['re'] = -this['im'];\n      this['im'] = tmp;\n      tmp = res['re'];\n\n      res['re'] = -res['im'];\n      res['im'] = tmp;\n      return res;\n    },\n\n    /**\n     * Calculate the complex acosh\n     *\n     * @returns {Complex}\n     */\n    'acosh': function() {\n\n      // acosh(c) = log(c + sqrt(c^2 - 1))\n\n      var res = this['acos']();\n      if (res['im'] <= 0) {\n        var tmp = res['re'];\n        res['re'] = -res['im'];\n        res['im'] = tmp;\n      } else {\n        var tmp = res['im'];\n        res['im'] = -res['re'];\n        res['re'] = tmp;\n      }\n      return res;\n    },\n\n    /**\n     * Calculate the complex atanh\n     *\n     * @returns {Complex}\n     */\n    'atanh': function() {\n\n      // atanh(c) = log((1+c) / (1-c)) / 2\n\n      var a = this['re'];\n      var b = this['im'];\n\n      var noIM = a > 1 && b === 0;\n      var oneMinus = 1 - a;\n      var onePlus = 1 + a;\n      var d = oneMinus * oneMinus + b * b;\n\n      var x = (d !== 0)\n        ? new Complex(\n          (onePlus * oneMinus - b * b) / d,\n          (b * oneMinus + onePlus * b) / d)\n        : new Complex(\n          (a !== -1) ? (a / 0) : 0,\n          (b !== 0) ? (b / 0) : 0);\n\n      var temp = x['re'];\n      x['re'] = logHypot(x['re'], x['im']) / 2;\n      x['im'] = Math.atan2(x['im'], temp) / 2;\n      if (noIM) {\n        x['im'] = -x['im'];\n      }\n      return x;\n    },\n\n    /**\n     * Calculate the complex acoth\n     *\n     * @returns {Complex}\n     */\n    'acoth': function() {\n\n      // acoth(c) = log((c+1) / (c-1)) / 2\n\n      var a = this['re'];\n      var b = this['im'];\n\n      if (a === 0 && b === 0) {\n        return new Complex(0, Math.PI / 2);\n      }\n\n      var d = a * a + b * b;\n      return (d !== 0)\n        ? new Complex(\n          a / d,\n          -b / d).atanh()\n        : new Complex(\n          (a !== 0) ? a / 0 : 0,\n          (b !== 0) ? -b / 0 : 0).atanh();\n    },\n\n    /**\n     * Calculate the complex acsch\n     *\n     * @returns {Complex}\n     */\n    'acsch': function() {\n\n      // acsch(c) = log((1+sqrt(1+c^2))/c)\n\n      var a = this['re'];\n      var b = this['im'];\n\n      if (b === 0) {\n\n        return new Complex(\n          (a !== 0)\n            ? Math.log(a + Math.sqrt(a * a + 1))\n            : Infinity, 0);\n      }\n\n      var d = a * a + b * b;\n      return (d !== 0)\n        ? new Complex(\n          a / d,\n          -b / d).asinh()\n        : new Complex(\n          (a !== 0) ? a / 0 : 0,\n          (b !== 0) ? -b / 0 : 0).asinh();\n    },\n\n    /**\n     * Calculate the complex asech\n     *\n     * @returns {Complex}\n     */\n    'asech': function() {\n\n      // asech(c) = log((1+sqrt(1-c^2))/c)\n\n      var a = this['re'];\n      var b = this['im'];\n\n      if (this['isZero']()) {\n        return Complex['INFINITY'];\n      }\n\n      var d = a * a + b * b;\n      return (d !== 0)\n        ? new Complex(\n          a / d,\n          -b / d).acosh()\n        : new Complex(\n          (a !== 0) ? a / 0 : 0,\n          (b !== 0) ? -b / 0 : 0).acosh();\n    },\n\n    /**\n     * Calculate the complex inverse 1/z\n     *\n     * @returns {Complex}\n     */\n    'inverse': function() {\n\n      // 1 / 0 = Infinity and 1 / Infinity = 0\n      if (this['isZero']()) {\n        return Complex['INFINITY'];\n      }\n\n      if (this['isInfinite']()) {\n        return Complex['ZERO'];\n      }\n\n      var a = this['re'];\n      var b = this['im'];\n\n      var d = a * a + b * b;\n\n      return new Complex(a / d, -b / d);\n    },\n\n    /**\n     * Returns the complex conjugate\n     *\n     * @returns {Complex}\n     */\n    'conjugate': function() {\n\n      return new Complex(this['re'], -this['im']);\n    },\n\n    /**\n     * Gets the negated complex number\n     *\n     * @returns {Complex}\n     */\n    'neg': function() {\n\n      return new Complex(-this['re'], -this['im']);\n    },\n\n    /**\n     * Ceils the actual complex number\n     *\n     * @returns {Complex}\n     */\n    'ceil': function(places) {\n\n      places = Math.pow(10, places || 0);\n\n      return new Complex(\n        Math.ceil(this['re'] * places) / places,\n        Math.ceil(this['im'] * places) / places);\n    },\n\n    /**\n     * Floors the actual complex number\n     *\n     * @returns {Complex}\n     */\n    'floor': function(places) {\n\n      places = Math.pow(10, places || 0);\n\n      return new Complex(\n        Math.floor(this['re'] * places) / places,\n        Math.floor(this['im'] * places) / places);\n    },\n\n    /**\n     * Ceils the actual complex number\n     *\n     * @returns {Complex}\n     */\n    'round': function(places) {\n\n      places = Math.pow(10, places || 0);\n\n      return new Complex(\n        Math.round(this['re'] * places) / places,\n        Math.round(this['im'] * places) / places);\n    },\n\n    /**\n     * Compares two complex numbers\n     *\n     * **Note:** new Complex(Infinity).equals(Infinity) === false\n     *\n     * @returns {boolean}\n     */\n    'equals': function(a, b) {\n\n      var z = new Complex(a, b);\n\n      return Math.abs(z['re'] - this['re']) <= Complex['EPSILON'] &&\n        Math.abs(z['im'] - this['im']) <= Complex['EPSILON'];\n    },\n\n    /**\n     * Clones the actual object\n     *\n     * @returns {Complex}\n     */\n    'clone': function() {\n\n      return new Complex(this['re'], this['im']);\n    },\n\n    /**\n     * Gets a string of the actual complex number\n     *\n     * @returns {string}\n     */\n    'toString': function() {\n\n      var a = this['re'];\n      var b = this['im'];\n      var ret = \"\";\n\n      if (this['isNaN']()) {\n        return 'NaN';\n      }\n\n      if (this['isInfinite']()) {\n        return 'Infinity';\n      }\n\n      if (Math.abs(a) < Complex['EPSILON']) {\n        a = 0;\n      }\n\n      if (Math.abs(b) < Complex['EPSILON']) {\n        b = 0;\n      }\n\n      // If is real number\n      if (b === 0) {\n        return ret + a;\n      }\n\n      if (a !== 0) {\n        ret += a;\n        ret += \" \";\n        if (b < 0) {\n          b = -b;\n          ret += \"-\";\n        } else {\n          ret += \"+\";\n        }\n        ret += \" \";\n      } else if (b < 0) {\n        b = -b;\n        ret += \"-\";\n      }\n\n      if (1 !== b) { // b is the absolute imaginary part\n        ret += b;\n      }\n      return ret + \"i\";\n    },\n\n    /**\n     * Returns the actual number as a vector\n     *\n     * @returns {Array}\n     */\n    'toVector': function() {\n\n      return [this['re'], this['im']];\n    },\n\n    /**\n     * Returns the actual real value of the current object\n     *\n     * @returns {number|null}\n     */\n    'valueOf': function() {\n\n      if (this['im'] === 0) {\n        return this['re'];\n      }\n      return null;\n    },\n\n    /**\n     * Determines whether a complex number is not on the Riemann sphere.\n     *\n     * @returns {boolean}\n     */\n    'isNaN': function() {\n      return isNaN(this['re']) || isNaN(this['im']);\n    },\n\n    /**\n     * Determines whether or not a complex number is at the zero pole of the\n     * Riemann sphere.\n     *\n     * @returns {boolean}\n     */\n    'isZero': function() {\n      return this['im'] === 0 && this['re'] === 0;\n    },\n\n    /**\n     * Determines whether a complex number is not at the infinity pole of the\n     * Riemann sphere.\n     *\n     * @returns {boolean}\n     */\n    'isFinite': function() {\n      return isFinite(this['re']) && isFinite(this['im']);\n    },\n\n    /**\n     * Determines whether or not a complex number is at the infinity pole of the\n     * Riemann sphere.\n     *\n     * @returns {boolean}\n     */\n    'isInfinite': function() {\n      return !(this['isNaN']() || this['isFinite']());\n    }\n  };\n\n  Complex['ZERO'] = new Complex(0, 0);\n  Complex['ONE'] = new Complex(1, 0);\n  Complex['I'] = new Complex(0, 1);\n  Complex['PI'] = new Complex(Math.PI, 0);\n  Complex['E'] = new Complex(Math.E, 0);\n  Complex['INFINITY'] = new Complex(Infinity, Infinity);\n  Complex['NAN'] = new Complex(NaN, NaN);\n  Complex['EPSILON'] = 1e-15;\n\n  if (typeof define === 'function' && define['amd']) {\n    define([], function() {\n      return Complex;\n    });\n  } else if (typeof exports === 'object') {\n    Object.defineProperty(Complex, \"__esModule\", { 'value': true });\n    Complex['default'] = Complex;\n    Complex['Complex'] = Complex;\n    module['exports'] = Complex;\n  } else {\n    root['Complex'] = Complex;\n  }\n\n})(this);\n","\"use strict\";\n\n// Map the characters to escape to their escaped values. The list is derived\n// from http://www.cespedes.org/blog/85/how-to-escape-latex-special-characters\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar defaultEscapes = {\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"\\\\\": \"\\\\textbackslash{}\",\n  \"#\": \"\\\\#\",\n  $: \"\\\\$\",\n  \"%\": \"\\\\%\",\n  \"&\": \"\\\\&\",\n  \"^\": \"\\\\textasciicircum{}\",\n  _: \"\\\\_\",\n  \"~\": \"\\\\textasciitilde{}\"\n};\nvar formatEscapes = {\n  \"\\u2013\": \"\\\\--\",\n  \"\\u2014\": \"\\\\---\",\n  \" \": \"~\",\n  \"\\t\": \"\\\\qquad{}\",\n  \"\\r\\n\": \"\\\\newline{}\",\n  \"\\n\": \"\\\\newline{}\"\n};\n\nvar defaultEscapeMapFn = function defaultEscapeMapFn(defaultEscapes, formatEscapes) {\n  return _extends({}, defaultEscapes, formatEscapes);\n};\n\n/**\n * Escape a string to be used in LaTeX documents.\n * @param {string} str the string to be escaped.\n * @param {boolean} params.preserveFormatting whether formatting escapes should\n *  be performed (default: false).\n * @param {function} params.escapeMapFn the function to modify the escape maps.\n * @return {string} the escaped string, ready to be used in LaTeX.\n */\nmodule.exports = function (str) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$preserveFormatti = _ref.preserveFormatting,\n      preserveFormatting = _ref$preserveFormatti === undefined ? false : _ref$preserveFormatti,\n      _ref$escapeMapFn = _ref.escapeMapFn,\n      escapeMapFn = _ref$escapeMapFn === undefined ? defaultEscapeMapFn : _ref$escapeMapFn;\n\n  var runningStr = String(str);\n  var result = \"\";\n\n  var escapes = escapeMapFn(_extends({}, defaultEscapes), preserveFormatting ? _extends({}, formatEscapes) : {});\n  var escapeKeys = Object.keys(escapes); // as it is reused later on\n\n  // Algorithm: Go through the string character by character, if it matches\n  // with one of the special characters then we'll replace it with the escaped\n  // version.\n\n  var _loop = function _loop() {\n    var specialCharFound = false;\n    escapeKeys.forEach(function (key, index) {\n      if (specialCharFound) {\n        return;\n      }\n      if (runningStr.length >= key.length && runningStr.slice(0, key.length) === key) {\n        result += escapes[escapeKeys[index]];\n        runningStr = runningStr.slice(key.length, runningStr.length);\n        specialCharFound = true;\n      }\n    });\n    if (!specialCharFound) {\n      result += runningStr.slice(0, 1);\n      runningStr = runningStr.slice(1, runningStr.length);\n    }\n  };\n\n  while (runningStr) {\n    _loop();\n  }\n  return result;\n};","/*\r\n * Natural Sort algorithm for Javascript - Version 0.7 - Released under MIT license\r\n * Author: Jim Palmer (based on chunking idea from Dave Koelle)\r\n */\r\n/*jshint unused:false */\r\nmodule.exports = function naturalSort (a, b) {\r\n\t\"use strict\";\r\n\tvar re = /(^([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?$|^0x[0-9a-f]+$|\\d+)/gi,\r\n\t\tsre = /(^[ ]*|[ ]*$)/g,\r\n\t\tdre = /(^([\\w ]+,?[\\w ]+)?[\\w ]+,?[\\w ]+\\d+:\\d+(:\\d+)?[\\w ]?|^\\d{1,4}[\\/\\-]\\d{1,4}[\\/\\-]\\d{1,4}|^\\w+, \\w+ \\d+, \\d{4})/,\r\n\t\thre = /^0x[0-9a-f]+$/i,\r\n\t\tore = /^0/,\r\n\t\ti = function(s) { return naturalSort.insensitive && ('' + s).toLowerCase() || '' + s; },\r\n\t\t// convert all to strings strip whitespace\r\n\t\tx = i(a).replace(sre, '') || '',\r\n\t\ty = i(b).replace(sre, '') || '',\r\n\t\t// chunk/tokenize\r\n\t\txN = x.replace(re, '\\0$1\\0').replace(/\\0$/,'').replace(/^\\0/,'').split('\\0'),\r\n\t\tyN = y.replace(re, '\\0$1\\0').replace(/\\0$/,'').replace(/^\\0/,'').split('\\0'),\r\n\t\t// numeric, hex or date detection\r\n\t\txD = parseInt(x.match(hre), 16) || (xN.length !== 1 && x.match(dre) && Date.parse(x)),\r\n\t\tyD = parseInt(y.match(hre), 16) || xD && y.match(dre) && Date.parse(y) || null,\r\n\t\toFxNcL, oFyNcL;\r\n\t// first try and sort Hex codes or Dates\r\n\tif (yD) {\r\n\t\tif ( xD < yD ) { return -1; }\r\n\t\telse if ( xD > yD ) { return 1; }\r\n\t}\r\n\t// natural sorting through split numeric strings and default strings\r\n\tfor(var cLoc=0, numS=Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {\r\n\t\t// find floats not starting with '0', string or 0 if not defined (Clint Priest)\r\n\t\toFxNcL = !(xN[cLoc] || '').match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;\r\n\t\toFyNcL = !(yN[cLoc] || '').match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;\r\n\t\t// handle numeric vs string comparison - number < string - (Kyle Adams)\r\n\t\tif (isNaN(oFxNcL) !== isNaN(oFyNcL)) { return (isNaN(oFxNcL)) ? 1 : -1; }\r\n\t\t// rely on string comparison if different types - i.e. '02' < 2 != '02' < '2'\r\n\t\telse if (typeof oFxNcL !== typeof oFyNcL) {\r\n\t\t\toFxNcL += '';\r\n\t\t\toFyNcL += '';\r\n\t\t}\r\n\t\tif (oFxNcL < oFyNcL) { return -1; }\r\n\t\tif (oFxNcL > oFyNcL) { return 1; }\r\n\t}\r\n\treturn 0;\r\n};\r\n","function E () {\n  // Keep this empty so it's easier to inherit from\n  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\n}\n\nE.prototype = {\n  on: function (name, callback, ctx) {\n    var e = this.e || (this.e = {});\n\n    (e[name] || (e[name] = [])).push({\n      fn: callback,\n      ctx: ctx\n    });\n\n    return this;\n  },\n\n  once: function (name, callback, ctx) {\n    var self = this;\n    function listener () {\n      self.off(name, listener);\n      callback.apply(ctx, arguments);\n    };\n\n    listener._ = callback\n    return this.on(name, listener, ctx);\n  },\n\n  emit: function (name) {\n    var data = [].slice.call(arguments, 1);\n    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\n    var i = 0;\n    var len = evtArr.length;\n\n    for (i; i < len; i++) {\n      evtArr[i].fn.apply(evtArr[i].ctx, data);\n    }\n\n    return this;\n  },\n\n  off: function (name, callback) {\n    var e = this.e || (this.e = {});\n    var evts = e[name];\n    var liveEvents = [];\n\n    if (evts && callback) {\n      for (var i = 0, len = evts.length; i < len; i++) {\n        if (evts[i].fn !== callback && evts[i].fn._ !== callback)\n          liveEvents.push(evts[i]);\n      }\n    }\n\n    // Remove event from queue to prevent memory leak\n    // Suggested by https://github.com/lazd\n    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910\n\n    (liveEvents.length)\n      ? e[name] = liveEvents\n      : delete e[name];\n\n    return this;\n  }\n};\n\nmodule.exports = E;\nmodule.exports.TinyEmitter = E;\n","function ok() {\n  return true;\n}\n\nfunction notOk() {\n  return false;\n}\n\nfunction undef() {\n  return undefined;\n}\n\nconst NOT_TYPED_FUNCTION = 'Argument is not a typed-function.';\n/**\n * @typedef {{\n *   params: Param[],\n *   fn: function,\n *   test: function,\n *   implementation: function\n * }} Signature\n *\n * @typedef {{\n *   types: Type[],\n *   hasAny: boolean,\n *   hasConversion: boolean,\n *   restParam: boolean\n * }} Param\n *\n * @typedef {{\n *   name: string,\n *   typeIndex: number,\n *   test: function,\n *   isAny: boolean,\n *   conversion?: ConversionDef,\n *   conversionIndex: number,\n * }} Type\n *\n * @typedef {{\n *   from: string,\n *   to: string,\n *   convert: function (*) : *\n * }} ConversionDef\n *\n * @typedef {{\n *   name: string,\n *   test: function(*) : boolean,\n *   isAny?: boolean\n * }} TypeDef\n */\n\n/**\n * @returns {() => function}\n */\n\nfunction create() {\n  // data type tests\n\n  /**\n   * Returns true if the argument is a non-null \"plain\" object\n   */\n  function isPlainObject(x) {\n    return typeof x === 'object' && x !== null && x.constructor === Object;\n  }\n\n  const _types = [{\n    name: 'number',\n    test: function (x) {\n      return typeof x === 'number';\n    }\n  }, {\n    name: 'string',\n    test: function (x) {\n      return typeof x === 'string';\n    }\n  }, {\n    name: 'boolean',\n    test: function (x) {\n      return typeof x === 'boolean';\n    }\n  }, {\n    name: 'Function',\n    test: function (x) {\n      return typeof x === 'function';\n    }\n  }, {\n    name: 'Array',\n    test: Array.isArray\n  }, {\n    name: 'Date',\n    test: function (x) {\n      return x instanceof Date;\n    }\n  }, {\n    name: 'RegExp',\n    test: function (x) {\n      return x instanceof RegExp;\n    }\n  }, {\n    name: 'Object',\n    test: isPlainObject\n  }, {\n    name: 'null',\n    test: function (x) {\n      return x === null;\n    }\n  }, {\n    name: 'undefined',\n    test: function (x) {\n      return x === undefined;\n    }\n  }];\n  const anyType = {\n    name: 'any',\n    test: ok,\n    isAny: true\n  }; // Data structures to track the types. As these are local variables in\n  // create(), each typed universe will get its own copy, but the variables\n  // will only be accessible through the (closures of the) functions supplied\n  // as properties of the typed object, not directly.\n  // These will be initialized in clear() below\n\n  let typeMap; // primary store of all types\n\n  let typeList; // Array of just type names, for the sake of ordering\n  // And similar data structures for the type conversions:\n\n  let nConversions = 0; // the actual conversions are stored on a property of the destination types\n  // This is a temporary object, will be replaced with a function at the end\n\n  let typed = {\n    createCount: 0\n  };\n  /**\n   * Takes a type name and returns the corresponding official type object\n   * for that type.\n   *\n   * @param {string} typeName\n   * @returns {TypeDef} type\n   */\n\n  function findType(typeName) {\n    const type = typeMap.get(typeName);\n\n    if (type) {\n      return type;\n    } // Remainder is error handling\n\n\n    let message = 'Unknown type \"' + typeName + '\"';\n    const name = typeName.toLowerCase();\n    let otherName;\n\n    for (otherName of typeList) {\n      if (otherName.toLowerCase() === name) {\n        message += '. Did you mean \"' + otherName + '\" ?';\n        break;\n      }\n    }\n\n    throw new TypeError(message);\n  }\n  /**\n   * Adds an array `types` of type definitions to this typed instance.\n   * Each type definition should be an object with properties:\n   * 'name' - a string giving the name of the type; 'test' - function\n   * returning a boolean that tests membership in the type; and optionally\n   * 'isAny' - true only for the 'any' type.\n   *\n   * The second optional argument, `before`, gives the name of a type that\n   * these types should be added before. The new types are added in the\n   * order specified.\n   * @param {TypeDef[]} types\n   * @param {string | boolean} [beforeSpec='any'] before\n   */\n\n\n  function addTypes(types) {\n    let beforeSpec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'any';\n    const beforeIndex = beforeSpec ? findType(beforeSpec).index : typeList.length;\n    const newTypes = [];\n\n    for (let i = 0; i < types.length; ++i) {\n      if (!types[i] || typeof types[i].name !== 'string' || typeof types[i].test !== 'function') {\n        throw new TypeError('Object with properties {name: string, test: function} expected');\n      }\n\n      const typeName = types[i].name;\n\n      if (typeMap.has(typeName)) {\n        throw new TypeError('Duplicate type name \"' + typeName + '\"');\n      }\n\n      newTypes.push(typeName);\n      typeMap.set(typeName, {\n        name: typeName,\n        test: types[i].test,\n        isAny: types[i].isAny,\n        index: beforeIndex + i,\n        conversionsTo: [] // Newly added type can't have any conversions to it\n\n      });\n    } // update the typeList\n\n\n    const affectedTypes = typeList.slice(beforeIndex);\n    typeList = typeList.slice(0, beforeIndex).concat(newTypes).concat(affectedTypes); // Fix the indices\n\n    for (let i = beforeIndex + newTypes.length; i < typeList.length; ++i) {\n      typeMap.get(typeList[i]).index = i;\n    }\n  }\n  /**\n   * Removes all types and conversions from this typed instance.\n   * May cause previously constructed typed-functions to throw\n   * strange errors when they are called with types that do not\n   * match any of their signatures.\n   */\n\n\n  function clear() {\n    typeMap = new Map();\n    typeList = [];\n    nConversions = 0;\n    addTypes([anyType], false);\n  } // initialize the types to the default list\n\n\n  clear();\n  addTypes(_types);\n  /**\n   * Removes all conversions, leaving the types alone.\n   */\n\n  function clearConversions() {\n    let typeName;\n\n    for (typeName of typeList) {\n      typeMap.get(typeName).conversionsTo = [];\n    }\n\n    nConversions = 0;\n  }\n  /**\n   * Find the type names that match a value.\n   * @param {*} value\n   * @return {string[]} Array of names of types for which\n   *                  the type test matches the value.\n   */\n\n\n  function findTypeNames(value) {\n    const matches = typeList.filter(name => {\n      const type = typeMap.get(name);\n      return !type.isAny && type.test(value);\n    });\n\n    if (matches.length) {\n      return matches;\n    }\n\n    return ['any'];\n  }\n  /**\n   * Check if an entity is a typed function created by any instance\n   * @param {any} entity\n   * @returns {boolean}\n   */\n\n\n  function isTypedFunction(entity) {\n    return entity && typeof entity === 'function' && '_typedFunctionData' in entity;\n  }\n  /**\n   * Find a specific signature from a (composed) typed function, for example:\n   *\n   *   typed.findSignature(fn, ['number', 'string'])\n   *   typed.findSignature(fn, 'number, string')\n   *   typed.findSignature(fn, 'number,string', {exact: true})\n   *\n   * This function findSignature will by default return the best match to\n   * the given signature, possibly employing type conversions.\n   *\n   * The (optional) third argument is a plain object giving options\n   * controlling the signature search. Currently the only implemented\n   * option is `exact`: if specified as true (default is false), only\n   * exact matches will be returned (i.e. signatures for which `fn` was\n   * directly defined). Note that a (possibly different) type matching\n   * `any`, or one or more instances of TYPE matching `...TYPE` are\n   * considered exact matches in this regard, as no conversions are used.\n   *\n   * This function returns a \"signature\" object, as does `typed.resolve()`,\n   * which is a plain object with four keys: `params` (the array of parameters\n   * for this signature), `fn` (the originally supplied function for this\n   * signature), `test` (a generated function that determines if an argument\n   * list matches this signature, and `implementation` (the function to call\n   * on a matching argument list, that performs conversions if necessary and\n   * then calls the originally supplied function).\n   *\n   * @param {Function} fn                   A typed-function\n   * @param {string | string[]} signature\n   *     Signature to be found, can be an array or a comma separated string.\n   * @param {object} options  Controls the signature search as documented\n   * @return {{ params: Param[], fn: function, test: function, implementation: function }}\n   *     Returns the matching signature, or throws an error when no signature\n   *     is found.\n   */\n\n\n  function findSignature(fn, signature, options) {\n    if (!isTypedFunction(fn)) {\n      throw new TypeError(NOT_TYPED_FUNCTION);\n    } // Canonicalize input\n\n\n    const exact = options && options.exact;\n    const stringSignature = Array.isArray(signature) ? signature.join(',') : signature;\n    const params = parseSignature(stringSignature);\n    const canonicalSignature = stringifyParams(params); // First hope we get lucky and exactly match a signature\n\n    if (!exact || canonicalSignature in fn.signatures) {\n      // OK, we can check the internal signatures\n      const match = fn._typedFunctionData.signatureMap.get(canonicalSignature);\n\n      if (match) {\n        return match;\n      }\n    } // Oh well, we did not; so we have to go back and check the parameters\n    // one by one, in order to catch things like `any` and rest params.\n    // Note here we can assume there is at least one parameter, because\n    // the empty signature would have matched successfully above.\n\n\n    const nParams = params.length;\n    let remainingSignatures;\n\n    if (exact) {\n      remainingSignatures = [];\n      let name;\n\n      for (name in fn.signatures) {\n        remainingSignatures.push(fn._typedFunctionData.signatureMap.get(name));\n      }\n    } else {\n      remainingSignatures = fn._typedFunctionData.signatures;\n    }\n\n    for (let i = 0; i < nParams; ++i) {\n      const want = params[i];\n      const filteredSignatures = [];\n      let possibility;\n\n      for (possibility of remainingSignatures) {\n        const have = getParamAtIndex(possibility.params, i);\n\n        if (!have || want.restParam && !have.restParam) {\n          continue;\n        }\n\n        if (!have.hasAny) {\n          // have to check all of the wanted types are available\n          const haveTypes = paramTypeSet(have);\n\n          if (want.types.some(wtype => !haveTypes.has(wtype.name))) {\n            continue;\n          }\n        } // OK, this looks good\n\n\n        filteredSignatures.push(possibility);\n      }\n\n      remainingSignatures = filteredSignatures;\n      if (remainingSignatures.length === 0) break;\n    } // Return the first remaining signature that was totally matched:\n\n\n    let candidate;\n\n    for (candidate of remainingSignatures) {\n      if (candidate.params.length <= nParams) {\n        return candidate;\n      }\n    }\n\n    throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + stringifyParams(params, ', ') + '))');\n  }\n  /**\n   * Find the proper function to call for a specific signature from\n   * a (composed) typed function, for example:\n   *\n   *   typed.find(fn, ['number', 'string'])\n   *   typed.find(fn, 'number, string')\n   *   typed.find(fn, 'number,string', {exact: true})\n   *\n   * This function find will by default return the best match to\n   * the given signature, possibly employing type conversions (and returning\n   * a function that will perform those conversions as needed). The\n   * (optional) third argument is a plain object giving options contolling\n   * the signature search. Currently only the option `exact` is implemented,\n   * which defaults to \"false\". If `exact` is specified as true, then only\n   * exact matches will be returned (i.e. signatures for which `fn` was\n   * directly defined). Uses of `any` and `...TYPE` are considered exact if\n   * no conversions are necessary to apply the corresponding function.\n   *\n   * @param {Function} fn                   A typed-function\n   * @param {string | string[]} signature\n   *     Signature to be found, can be an array or a comma separated string.\n   * @param {object} options  Controls the signature match as documented\n   * @return {function}\n   *     Returns the function to call for the given signature, or throws an\n   *     error if no match is found.\n   */\n\n\n  function find(fn, signature, options) {\n    return findSignature(fn, signature, options).implementation;\n  }\n  /**\n   * Convert a given value to another data type, specified by type name.\n   *\n   * @param {*} value\n   * @param {string} typeName\n   */\n\n\n  function convert(value, typeName) {\n    // check conversion is needed\n    const type = findType(typeName);\n\n    if (type.test(value)) {\n      return value;\n    }\n\n    const conversions = type.conversionsTo;\n\n    if (conversions.length === 0) {\n      throw new Error('There are no conversions to ' + typeName + ' defined.');\n    }\n\n    for (let i = 0; i < conversions.length; i++) {\n      const fromType = findType(conversions[i].from);\n\n      if (fromType.test(value)) {\n        return conversions[i].convert(value);\n      }\n    }\n\n    throw new Error('Cannot convert ' + value + ' to ' + typeName);\n  }\n  /**\n   * Stringify parameters in a normalized way\n   * @param {Param[]} params\n   * @param {string} [','] separator\n   * @return {string}\n   */\n\n\n  function stringifyParams(params) {\n    let separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ',';\n    return params.map(p => p.name).join(separator);\n  }\n  /**\n   * Parse a parameter, like \"...number | boolean\"\n   * @param {string} param\n   * @return {Param} param\n   */\n\n\n  function parseParam(param) {\n    const restParam = param.indexOf('...') === 0;\n    const types = !restParam ? param : param.length > 3 ? param.slice(3) : 'any';\n    const typeDefs = types.split('|').map(s => findType(s.trim()));\n    let hasAny = false;\n    let paramName = restParam ? '...' : '';\n    const exactTypes = typeDefs.map(function (type) {\n      hasAny = type.isAny || hasAny;\n      paramName += type.name + '|';\n      return {\n        name: type.name,\n        typeIndex: type.index,\n        test: type.test,\n        isAny: type.isAny,\n        conversion: null,\n        conversionIndex: -1\n      };\n    });\n    return {\n      types: exactTypes,\n      name: paramName.slice(0, -1),\n      // remove trailing '|' from above\n      hasAny,\n      hasConversion: false,\n      restParam\n    };\n  }\n  /**\n   * Expands a parsed parameter with the types available from currently\n   * defined conversions.\n   * @param {Param} param\n   * @return {Param} param\n   */\n\n\n  function expandParam(param) {\n    const typeNames = param.types.map(t => t.name);\n    const matchingConversions = availableConversions(typeNames);\n    let hasAny = param.hasAny;\n    let newName = param.name;\n    const convertibleTypes = matchingConversions.map(function (conversion) {\n      const type = findType(conversion.from);\n      hasAny = type.isAny || hasAny;\n      newName += '|' + conversion.from;\n      return {\n        name: conversion.from,\n        typeIndex: type.index,\n        test: type.test,\n        isAny: type.isAny,\n        conversion,\n        conversionIndex: conversion.index\n      };\n    });\n    return {\n      types: param.types.concat(convertibleTypes),\n      name: newName,\n      hasAny,\n      hasConversion: convertibleTypes.length > 0,\n      restParam: param.restParam\n    };\n  }\n  /**\n   * Return the set of type names in a parameter.\n   * Caches the result for efficiency\n   *\n   * @param {Param} param\n   * @return {Set<string>} typenames\n   */\n\n\n  function paramTypeSet(param) {\n    if (!param.typeSet) {\n      param.typeSet = new Set();\n      param.types.forEach(type => param.typeSet.add(type.name));\n    }\n\n    return param.typeSet;\n  }\n  /**\n   * Parse a signature with comma separated parameters,\n   * like \"number | boolean, ...string\"\n   *\n   * @param {string} signature\n   * @return {Param[]} params\n   */\n\n\n  function parseSignature(rawSignature) {\n    const params = [];\n\n    if (typeof rawSignature !== 'string') {\n      throw new TypeError('Signatures must be strings');\n    }\n\n    const signature = rawSignature.trim();\n\n    if (signature === '') {\n      return params;\n    }\n\n    const rawParams = signature.split(',');\n\n    for (let i = 0; i < rawParams.length; ++i) {\n      const parsedParam = parseParam(rawParams[i].trim());\n\n      if (parsedParam.restParam && i !== rawParams.length - 1) {\n        throw new SyntaxError('Unexpected rest parameter \"' + rawParams[i] + '\": ' + 'only allowed for the last parameter');\n      } // if invalid, short-circuit (all the types may have been filtered)\n\n\n      if (parsedParam.types.length === 0) {\n        return null;\n      }\n\n      params.push(parsedParam);\n    }\n\n    return params;\n  }\n  /**\n   * Test whether a set of params contains a restParam\n   * @param {Param[]} params\n   * @return {boolean} Returns true when the last parameter is a restParam\n   */\n\n\n  function hasRestParam(params) {\n    const param = last(params);\n    return param ? param.restParam : false;\n  }\n  /**\n   * Create a type test for a single parameter, which can have one or multiple\n   * types.\n   * @param {Param} param\n   * @return {function(x: *) : boolean} Returns a test function\n   */\n\n\n  function compileTest(param) {\n    if (!param || param.types.length === 0) {\n      // nothing to do\n      return ok;\n    } else if (param.types.length === 1) {\n      return findType(param.types[0].name).test;\n    } else if (param.types.length === 2) {\n      const test0 = findType(param.types[0].name).test;\n      const test1 = findType(param.types[1].name).test;\n      return function or(x) {\n        return test0(x) || test1(x);\n      };\n    } else {\n      // param.types.length > 2\n      const tests = param.types.map(function (type) {\n        return findType(type.name).test;\n      });\n      return function or(x) {\n        for (let i = 0; i < tests.length; i++) {\n          if (tests[i](x)) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n    }\n  }\n  /**\n   * Create a test for all parameters of a signature\n   * @param {Param[]} params\n   * @return {function(args: Array<*>) : boolean}\n   */\n\n\n  function compileTests(params) {\n    let tests, test0, test1;\n\n    if (hasRestParam(params)) {\n      // variable arguments like '...number'\n      tests = initial(params).map(compileTest);\n      const varIndex = tests.length;\n      const lastTest = compileTest(last(params));\n\n      const testRestParam = function (args) {\n        for (let i = varIndex; i < args.length; i++) {\n          if (!lastTest(args[i])) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n\n      return function testArgs(args) {\n        for (let i = 0; i < tests.length; i++) {\n          if (!tests[i](args[i])) {\n            return false;\n          }\n        }\n\n        return testRestParam(args) && args.length >= varIndex + 1;\n      };\n    } else {\n      // no variable arguments\n      if (params.length === 0) {\n        return function testArgs(args) {\n          return args.length === 0;\n        };\n      } else if (params.length === 1) {\n        test0 = compileTest(params[0]);\n        return function testArgs(args) {\n          return test0(args[0]) && args.length === 1;\n        };\n      } else if (params.length === 2) {\n        test0 = compileTest(params[0]);\n        test1 = compileTest(params[1]);\n        return function testArgs(args) {\n          return test0(args[0]) && test1(args[1]) && args.length === 2;\n        };\n      } else {\n        // arguments.length > 2\n        tests = params.map(compileTest);\n        return function testArgs(args) {\n          for (let i = 0; i < tests.length; i++) {\n            if (!tests[i](args[i])) {\n              return false;\n            }\n          }\n\n          return args.length === tests.length;\n        };\n      }\n    }\n  }\n  /**\n   * Find the parameter at a specific index of a Params list.\n   * Handles rest parameters.\n   * @param {Param[]} params\n   * @param {number} index\n   * @return {Param | null} Returns the matching parameter when found,\n   *                        null otherwise.\n   */\n\n\n  function getParamAtIndex(params, index) {\n    return index < params.length ? params[index] : hasRestParam(params) ? last(params) : null;\n  }\n  /**\n   * Get all type names of a parameter\n   * @param {Params[]} params\n   * @param {number} index\n   * @return {string[]} Returns an array with type names\n   */\n\n\n  function getTypeSetAtIndex(params, index) {\n    const param = getParamAtIndex(params, index);\n\n    if (!param) {\n      return new Set();\n    }\n\n    return paramTypeSet(param);\n  }\n  /**\n   * Test whether a type is an exact type or conversion\n   * @param {Type} type\n   * @return {boolean} Returns true when\n   */\n\n\n  function isExactType(type) {\n    return type.conversion === null || type.conversion === undefined;\n  }\n  /**\n   * Helper function for creating error messages: create an array with\n   * all available types on a specific argument index.\n   * @param {Signature[]} signatures\n   * @param {number} index\n   * @return {string[]} Returns an array with available types\n   */\n\n\n  function mergeExpectedParams(signatures, index) {\n    const typeSet = new Set();\n    signatures.forEach(signature => {\n      const paramSet = getTypeSetAtIndex(signature.params, index);\n      let name;\n\n      for (name of paramSet) {\n        typeSet.add(name);\n      }\n    });\n    return typeSet.has('any') ? ['any'] : Array.from(typeSet);\n  }\n  /**\n   * Create\n   * @param {string} name             The name of the function\n   * @param {array.<*>} args          The actual arguments passed to the function\n   * @param {Signature[]} signatures  A list with available signatures\n   * @return {TypeError} Returns a type error with additional data\n   *                     attached to it in the property `data`\n   */\n\n\n  function createError(name, args, signatures) {\n    let err, expected;\n\n    const _name = name || 'unnamed'; // test for wrong type at some index\n\n\n    let matchingSignatures = signatures;\n    let index;\n\n    for (index = 0; index < args.length; index++) {\n      const nextMatchingDefs = [];\n      matchingSignatures.forEach(signature => {\n        const param = getParamAtIndex(signature.params, index);\n        const test = compileTest(param);\n\n        if ((index < signature.params.length || hasRestParam(signature.params)) && test(args[index])) {\n          nextMatchingDefs.push(signature);\n        }\n      });\n\n      if (nextMatchingDefs.length === 0) {\n        // no matching signatures anymore, throw error \"wrong type\"\n        expected = mergeExpectedParams(matchingSignatures, index);\n\n        if (expected.length > 0) {\n          const actualTypes = findTypeNames(args[index]);\n          err = new TypeError('Unexpected type of argument in function ' + _name + ' (expected: ' + expected.join(' or ') + ', actual: ' + actualTypes.join(' | ') + ', index: ' + index + ')');\n          err.data = {\n            category: 'wrongType',\n            fn: _name,\n            index,\n            actual: actualTypes,\n            expected\n          };\n          return err;\n        }\n      } else {\n        matchingSignatures = nextMatchingDefs;\n      }\n    } // test for too few arguments\n\n\n    const lengths = matchingSignatures.map(function (signature) {\n      return hasRestParam(signature.params) ? Infinity : signature.params.length;\n    });\n\n    if (args.length < Math.min.apply(null, lengths)) {\n      expected = mergeExpectedParams(matchingSignatures, index);\n      err = new TypeError('Too few arguments in function ' + _name + ' (expected: ' + expected.join(' or ') + ', index: ' + args.length + ')');\n      err.data = {\n        category: 'tooFewArgs',\n        fn: _name,\n        index: args.length,\n        expected\n      };\n      return err;\n    } // test for too many arguments\n\n\n    const maxLength = Math.max.apply(null, lengths);\n\n    if (args.length > maxLength) {\n      err = new TypeError('Too many arguments in function ' + _name + ' (expected: ' + maxLength + ', actual: ' + args.length + ')');\n      err.data = {\n        category: 'tooManyArgs',\n        fn: _name,\n        index: args.length,\n        expectedLength: maxLength\n      };\n      return err;\n    } // Generic error\n\n\n    const argTypes = [];\n\n    for (let i = 0; i < args.length; ++i) {\n      argTypes.push(findTypeNames(args[i]).join('|'));\n    }\n\n    err = new TypeError('Arguments of type \"' + argTypes.join(', ') + '\" do not match any of the defined signatures of function ' + _name + '.');\n    err.data = {\n      category: 'mismatch',\n      actual: argTypes\n    };\n    return err;\n  }\n  /**\n   * Find the lowest index of all exact types of a parameter (no conversions)\n   * @param {Param} param\n   * @return {number} Returns the index of the lowest type in typed.types\n   */\n\n\n  function getLowestTypeIndex(param) {\n    let min = typeList.length + 1;\n\n    for (let i = 0; i < param.types.length; i++) {\n      if (isExactType(param.types[i])) {\n        min = Math.min(min, param.types[i].typeIndex);\n      }\n    }\n\n    return min;\n  }\n  /**\n   * Find the lowest index of the conversion of all types of the parameter\n   * having a conversion\n   * @param {Param} param\n   * @return {number} Returns the lowest index of the conversions of this type\n   */\n\n\n  function getLowestConversionIndex(param) {\n    let min = nConversions + 1;\n\n    for (let i = 0; i < param.types.length; i++) {\n      if (!isExactType(param.types[i])) {\n        min = Math.min(min, param.types[i].conversionIndex);\n      }\n    }\n\n    return min;\n  }\n  /**\n   * Compare two params\n   * @param {Param} param1\n   * @param {Param} param2\n   * @return {number} returns -1 when param1 must get a lower\n   *                  index than param2, 1 when the opposite,\n   *                  or zero when both are equal\n   */\n\n\n  function compareParams(param1, param2) {\n    // We compare a number of metrics on a param in turn:\n    // 1) 'any' parameters are the least preferred\n    if (param1.hasAny) {\n      if (!param2.hasAny) {\n        return 1;\n      }\n    } else if (param2.hasAny) {\n      return -1;\n    } // 2) Prefer non-rest to rest parameters\n\n\n    if (param1.restParam) {\n      if (!param2.restParam) {\n        return 1;\n      }\n    } else if (param2.restParam) {\n      return -1;\n    } // 3) Prefer exact type match to conversions\n\n\n    if (param1.hasConversion) {\n      if (!param2.hasConversion) {\n        return 1;\n      }\n    } else if (param2.hasConversion) {\n      return -1;\n    } // 4) Prefer lower type index:\n\n\n    const typeDiff = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);\n\n    if (typeDiff < 0) {\n      return -1;\n    }\n\n    if (typeDiff > 0) {\n      return 1;\n    } // 5) Prefer lower conversion index\n\n\n    const convDiff = getLowestConversionIndex(param1) - getLowestConversionIndex(param2);\n\n    if (convDiff < 0) {\n      return -1;\n    }\n\n    if (convDiff > 0) {\n      return 1;\n    } // Don't have a basis for preference\n\n\n    return 0;\n  }\n  /**\n   * Compare two signatures\n   * @param {Signature} signature1\n   * @param {Signature} signature2\n   * @return {number} returns a negative number when param1 must get a lower\n   *                  index than param2, a positive number when the opposite,\n   *                  or zero when both are equal\n   */\n\n\n  function compareSignatures(signature1, signature2) {\n    const pars1 = signature1.params;\n    const pars2 = signature2.params;\n    const last1 = last(pars1);\n    const last2 = last(pars2);\n    const hasRest1 = hasRestParam(pars1);\n    const hasRest2 = hasRestParam(pars2); // We compare a number of metrics on signatures in turn:\n    // 1) An \"any rest param\" is least preferred\n\n    if (hasRest1 && last1.hasAny) {\n      if (!hasRest2 || !last2.hasAny) {\n        return 1;\n      }\n    } else if (hasRest2 && last2.hasAny) {\n      return -1;\n    } // 2) Minimize the number of 'any' parameters\n\n\n    let any1 = 0;\n    let conv1 = 0;\n    let par;\n\n    for (par of pars1) {\n      if (par.hasAny) ++any1;\n      if (par.hasConversion) ++conv1;\n    }\n\n    let any2 = 0;\n    let conv2 = 0;\n\n    for (par of pars2) {\n      if (par.hasAny) ++any2;\n      if (par.hasConversion) ++conv2;\n    }\n\n    if (any1 !== any2) {\n      return any1 - any2;\n    } // 3) A conversion rest param is less preferred\n\n\n    if (hasRest1 && last1.hasConversion) {\n      if (!hasRest2 || !last2.hasConversion) {\n        return 1;\n      }\n    } else if (hasRest2 && last2.hasConversion) {\n      return -1;\n    } // 4) Minimize the number of conversions\n\n\n    if (conv1 !== conv2) {\n      return conv1 - conv2;\n    } // 5) Prefer no rest param\n\n\n    if (hasRest1) {\n      if (!hasRest2) {\n        return 1;\n      }\n    } else if (hasRest2) {\n      return -1;\n    } // 6) Prefer shorter with rest param, longer without\n\n\n    const lengthCriterion = (pars1.length - pars2.length) * (hasRest1 ? -1 : 1);\n\n    if (lengthCriterion !== 0) {\n      return lengthCriterion;\n    } // Signatures are identical in each of the above metrics.\n    // In particular, they are the same length.\n    // We can therefore compare the parameters one by one.\n    // First we count which signature has more preferred parameters.\n\n\n    const comparisons = [];\n    let tc = 0;\n\n    for (let i = 0; i < pars1.length; ++i) {\n      const thisComparison = compareParams(pars1[i], pars2[i]);\n      comparisons.push(thisComparison);\n      tc += thisComparison;\n    }\n\n    if (tc !== 0) {\n      return tc;\n    } // They have the same number of preferred parameters, so go by the\n    // earliest parameter in which we have a preference.\n    // In other words, dispatch is driven somewhat more by earlier\n    // parameters than later ones.\n\n\n    let c;\n\n    for (c of comparisons) {\n      if (c !== 0) {\n        return c;\n      }\n    } // It's a tossup:\n\n\n    return 0;\n  }\n  /**\n   * Produce a list of all conversions from distinct types to one of\n   * the given types.\n   *\n   * @param {string[]} typeNames\n   * @return {ConversionDef[]} Returns the conversions that are available\n   *                        resulting in any given type (if any)\n   */\n\n\n  function availableConversions(typeNames) {\n    if (typeNames.length === 0) {\n      return [];\n    }\n\n    const types = typeNames.map(findType);\n\n    if (typeNames.length > 1) {\n      types.sort((t1, t2) => t1.index - t2.index);\n    }\n\n    let matches = types[0].conversionsTo;\n\n    if (typeNames.length === 1) {\n      return matches;\n    }\n\n    matches = matches.concat([]); // shallow copy the matches\n    // Since the types are now in index order, we just want the first\n    // occurrence of any from type:\n\n    const knownTypes = new Set(typeNames);\n\n    for (let i = 1; i < types.length; ++i) {\n      let newMatch;\n\n      for (newMatch of types[i].conversionsTo) {\n        if (!knownTypes.has(newMatch.from)) {\n          matches.push(newMatch);\n          knownTypes.add(newMatch.from);\n        }\n      }\n    }\n\n    return matches;\n  }\n  /**\n   * Preprocess arguments before calling the original function:\n   * - if needed convert the parameters\n   * - in case of rest parameters, move the rest parameters into an Array\n   * @param {Param[]} params\n   * @param {function} fn\n   * @return {function} Returns a wrapped function\n   */\n\n\n  function compileArgsPreprocessing(params, fn) {\n    let fnConvert = fn; // TODO: can we make this wrapper function smarter/simpler?\n\n    if (params.some(p => p.hasConversion)) {\n      const restParam = hasRestParam(params);\n      const compiledConversions = params.map(compileArgConversion);\n\n      fnConvert = function convertArgs() {\n        const args = [];\n        const last = restParam ? arguments.length - 1 : arguments.length;\n\n        for (let i = 0; i < last; i++) {\n          args[i] = compiledConversions[i](arguments[i]);\n        }\n\n        if (restParam) {\n          args[last] = arguments[last].map(compiledConversions[last]);\n        }\n\n        return fn.apply(this, args);\n      };\n    }\n\n    let fnPreprocess = fnConvert;\n\n    if (hasRestParam(params)) {\n      const offset = params.length - 1;\n\n      fnPreprocess = function preprocessRestParams() {\n        return fnConvert.apply(this, slice(arguments, 0, offset).concat([slice(arguments, offset)]));\n      };\n    }\n\n    return fnPreprocess;\n  }\n  /**\n   * Compile conversion for a parameter to the right type\n   * @param {Param} param\n   * @return {function} Returns the wrapped function that will convert arguments\n   *\n   */\n\n\n  function compileArgConversion(param) {\n    let test0, test1, conversion0, conversion1;\n    const tests = [];\n    const conversions = [];\n    param.types.forEach(function (type) {\n      if (type.conversion) {\n        tests.push(findType(type.conversion.from).test);\n        conversions.push(type.conversion.convert);\n      }\n    }); // create optimized conversion functions depending on the number of conversions\n\n    switch (conversions.length) {\n      case 0:\n        return function convertArg(arg) {\n          return arg;\n        };\n\n      case 1:\n        test0 = tests[0];\n        conversion0 = conversions[0];\n        return function convertArg(arg) {\n          if (test0(arg)) {\n            return conversion0(arg);\n          }\n\n          return arg;\n        };\n\n      case 2:\n        test0 = tests[0];\n        test1 = tests[1];\n        conversion0 = conversions[0];\n        conversion1 = conversions[1];\n        return function convertArg(arg) {\n          if (test0(arg)) {\n            return conversion0(arg);\n          }\n\n          if (test1(arg)) {\n            return conversion1(arg);\n          }\n\n          return arg;\n        };\n\n      default:\n        return function convertArg(arg) {\n          for (let i = 0; i < conversions.length; i++) {\n            if (tests[i](arg)) {\n              return conversions[i](arg);\n            }\n          }\n\n          return arg;\n        };\n    }\n  }\n  /**\n   * Split params with union types in to separate params.\n   *\n   * For example:\n   *\n   *     splitParams([['Array', 'Object'], ['string', 'RegExp'])\n   *     // returns:\n   *     // [\n   *     //   ['Array', 'string'],\n   *     //   ['Array', 'RegExp'],\n   *     //   ['Object', 'string'],\n   *     //   ['Object', 'RegExp']\n   *     // ]\n   *\n   * @param {Param[]} params\n   * @return {Param[]}\n   */\n\n\n  function splitParams(params) {\n    function _splitParams(params, index, paramsSoFar) {\n      if (index < params.length) {\n        const param = params[index];\n        let resultingParams = [];\n\n        if (param.restParam) {\n          // split the types of a rest parameter in two:\n          // one with only exact types, and one with exact types and conversions\n          const exactTypes = param.types.filter(isExactType);\n\n          if (exactTypes.length < param.types.length) {\n            resultingParams.push({\n              types: exactTypes,\n              name: '...' + exactTypes.map(t => t.name).join('|'),\n              hasAny: exactTypes.some(t => t.isAny),\n              hasConversion: false,\n              restParam: true\n            });\n          }\n\n          resultingParams.push(param);\n        } else {\n          // split all the types of a regular parameter into one type per param\n          resultingParams = param.types.map(function (type) {\n            return {\n              types: [type],\n              name: type.name,\n              hasAny: type.isAny,\n              hasConversion: type.conversion,\n              restParam: false\n            };\n          });\n        } // recurse over the groups with types\n\n\n        return flatMap(resultingParams, function (nextParam) {\n          return _splitParams(params, index + 1, paramsSoFar.concat([nextParam]));\n        });\n      } else {\n        // we've reached the end of the parameters.\n        return [paramsSoFar];\n      }\n    }\n\n    return _splitParams(params, 0, []);\n  }\n  /**\n   * Test whether two param lists represent conflicting signatures\n   * @param {Param[]} params1\n   * @param {Param[]} params2\n   * @return {boolean} Returns true when the signatures conflict, false otherwise.\n   */\n\n\n  function conflicting(params1, params2) {\n    const ii = Math.max(params1.length, params2.length);\n\n    for (let i = 0; i < ii; i++) {\n      const typeSet1 = getTypeSetAtIndex(params1, i);\n      const typeSet2 = getTypeSetAtIndex(params2, i);\n      let overlap = false;\n      let name;\n\n      for (name of typeSet2) {\n        if (typeSet1.has(name)) {\n          overlap = true;\n          break;\n        }\n      }\n\n      if (!overlap) {\n        return false;\n      }\n    }\n\n    const len1 = params1.length;\n    const len2 = params2.length;\n    const restParam1 = hasRestParam(params1);\n    const restParam2 = hasRestParam(params2);\n    return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;\n  }\n  /**\n   * Helper function for `resolveReferences` that returns a copy of\n   * functionList wihe any prior resolutions cleared out, in case we are\n   * recycling signatures from a prior typed function construction.\n   *\n   * @param {Array.<function|typed-reference>} functionList\n   * @return {Array.<function|typed-reference>}\n   */\n\n\n  function clearResolutions(functionList) {\n    return functionList.map(fn => {\n      if (isReferToSelf(fn)) {\n        return referToSelf(fn.referToSelf.callback);\n      }\n\n      if (isReferTo(fn)) {\n        return makeReferTo(fn.referTo.references, fn.referTo.callback);\n      }\n\n      return fn;\n    });\n  }\n  /**\n   * Take a list of references, a list of functions functionList, and a\n   * signatureMap indexing signatures into functionList, and return\n   * the list of resolutions, or a false-y value if they don't all\n   * resolve in a valid way (yet).\n   *\n   * @param {string[]} references\n   * @param {Array<function|typed-reference} functionList\n   * @param {Object.<string, integer>} signatureMap\n   * @return {function[] | false} resolutions\n   */\n\n\n  function collectResolutions(references, functionList, signatureMap) {\n    const resolvedReferences = [];\n    let reference;\n\n    for (reference of references) {\n      let resolution = signatureMap[reference];\n\n      if (typeof resolution !== 'number') {\n        throw new TypeError('No definition for referenced signature \"' + reference + '\"');\n      }\n\n      resolution = functionList[resolution];\n\n      if (typeof resolution !== 'function') {\n        return false;\n      }\n\n      resolvedReferences.push(resolution);\n    }\n\n    return resolvedReferences;\n  }\n  /**\n   * Resolve any references in the functionList for the typed function\n   * itself. The signatureMap tells which index in the functionList a\n   * given signature should be mapped to (for use in resolving typed.referTo)\n   * and self provides the destions of a typed.referToSelf.\n   *\n   * @param {Array<function | typed-reference-object>} functionList\n   * @param {Object.<string, function>} signatureMap\n   * @param {function} self  The typed-function itself\n   * @return {Array<function>} The list of resolved functions\n   */\n\n\n  function resolveReferences(functionList, signatureMap, self) {\n    const resolvedFunctions = clearResolutions(functionList);\n    const isResolved = new Array(resolvedFunctions.length).fill(false);\n    let leftUnresolved = true;\n\n    while (leftUnresolved) {\n      leftUnresolved = false;\n      let nothingResolved = true;\n\n      for (let i = 0; i < resolvedFunctions.length; ++i) {\n        if (isResolved[i]) continue;\n        const fn = resolvedFunctions[i];\n\n        if (isReferToSelf(fn)) {\n          resolvedFunctions[i] = fn.referToSelf.callback(self); // Preserve reference in case signature is reused someday:\n\n          resolvedFunctions[i].referToSelf = fn.referToSelf;\n          isResolved[i] = true;\n          nothingResolved = false;\n        } else if (isReferTo(fn)) {\n          const resolvedReferences = collectResolutions(fn.referTo.references, resolvedFunctions, signatureMap);\n\n          if (resolvedReferences) {\n            resolvedFunctions[i] = fn.referTo.callback.apply(this, resolvedReferences); // Preserve reference in case signature is reused someday:\n\n            resolvedFunctions[i].referTo = fn.referTo;\n            isResolved[i] = true;\n            nothingResolved = false;\n          } else {\n            leftUnresolved = true;\n          }\n        }\n      }\n\n      if (nothingResolved && leftUnresolved) {\n        throw new SyntaxError('Circular reference detected in resolving typed.referTo');\n      }\n    }\n\n    return resolvedFunctions;\n  }\n  /**\n   * Validate whether any of the function bodies contains a self-reference\n   * usage like `this(...)` or `this.signatures`. This self-referencing is\n   * deprecated since typed-function v3. It has been replaced with\n   * the functions typed.referTo and typed.referToSelf.\n   * @param {Object.<string, function>} signaturesMap\n   */\n\n\n  function validateDeprecatedThis(signaturesMap) {\n    // TODO: remove this deprecation warning logic some day (it's introduced in v3)\n    // match occurrences like 'this(' and 'this.signatures'\n    const deprecatedThisRegex = /\\bthis(\\(|\\.signatures\\b)/;\n    Object.keys(signaturesMap).forEach(signature => {\n      const fn = signaturesMap[signature];\n\n      if (deprecatedThisRegex.test(fn.toString())) {\n        throw new SyntaxError('Using `this` to self-reference a function ' + 'is deprecated since typed-function@3. ' + 'Use typed.referTo and typed.referToSelf instead.');\n      }\n    });\n  }\n  /**\n   * Create a typed function\n   * @param {String} name               The name for the typed function\n   * @param {Object.<string, function>} rawSignaturesMap\n   *                                    An object with one or\n   *                                    multiple signatures as key, and the\n   *                                    function corresponding to the\n   *                                    signature as value.\n   * @return {function}  Returns the created typed function.\n   */\n\n\n  function createTypedFunction(name, rawSignaturesMap) {\n    typed.createCount++;\n\n    if (Object.keys(rawSignaturesMap).length === 0) {\n      throw new SyntaxError('No signatures provided');\n    }\n\n    if (typed.warnAgainstDeprecatedThis) {\n      validateDeprecatedThis(rawSignaturesMap);\n    } // Main processing loop for signatures\n\n\n    const parsedParams = [];\n    const originalFunctions = [];\n    const signaturesMap = {};\n    const preliminarySignatures = []; // may have duplicates from conversions\n\n    let signature;\n\n    for (signature in rawSignaturesMap) {\n      // A) Protect against polluted Object prototype:\n      if (!Object.prototype.hasOwnProperty.call(rawSignaturesMap, signature)) {\n        continue;\n      } // B) Parse the signature\n\n\n      const params = parseSignature(signature);\n      if (!params) continue; // C) Check for conflicts\n\n      parsedParams.forEach(function (pp) {\n        if (conflicting(pp, params)) {\n          throw new TypeError('Conflicting signatures \"' + stringifyParams(pp) + '\" and \"' + stringifyParams(params) + '\".');\n        }\n      });\n      parsedParams.push(params); // D) Store the provided function and add conversions\n\n      const functionIndex = originalFunctions.length;\n      originalFunctions.push(rawSignaturesMap[signature]);\n      const conversionParams = params.map(expandParam); // E) Split the signatures and collect them up\n\n      let sp;\n\n      for (sp of splitParams(conversionParams)) {\n        const spName = stringifyParams(sp);\n        preliminarySignatures.push({\n          params: sp,\n          name: spName,\n          fn: functionIndex\n        });\n\n        if (sp.every(p => !p.hasConversion)) {\n          signaturesMap[spName] = functionIndex;\n        }\n      }\n    }\n\n    preliminarySignatures.sort(compareSignatures); // Note the forward reference to theTypedFn\n\n    const resolvedFunctions = resolveReferences(originalFunctions, signaturesMap, theTypedFn); // Fill in the proper function for each signature\n\n    let s;\n\n    for (s in signaturesMap) {\n      if (Object.prototype.hasOwnProperty.call(signaturesMap, s)) {\n        signaturesMap[s] = resolvedFunctions[signaturesMap[s]];\n      }\n    }\n\n    const signatures = [];\n    const internalSignatureMap = new Map(); // benchmarks faster than object\n\n    for (s of preliminarySignatures) {\n      // Note it's only safe to eliminate duplicates like this\n      // _after_ the signature sorting step above; otherwise we might\n      // remove the wrong one.\n      if (!internalSignatureMap.has(s.name)) {\n        s.fn = resolvedFunctions[s.fn];\n        signatures.push(s);\n        internalSignatureMap.set(s.name, s);\n      }\n    } // we create a highly optimized checks for the first couple of signatures with max 2 arguments\n\n\n    const ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);\n    const ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);\n    const ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);\n    const ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);\n    const ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);\n    const ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);\n    const allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5; // compile the tests\n\n    for (let i = 0; i < signatures.length; ++i) {\n      signatures[i].test = compileTests(signatures[i].params);\n    }\n\n    const test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;\n    const test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;\n    const test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;\n    const test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;\n    const test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;\n    const test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;\n    const test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;\n    const test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;\n    const test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;\n    const test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;\n    const test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;\n    const test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk; // compile the functions\n\n    for (let i = 0; i < signatures.length; ++i) {\n      signatures[i].implementation = compileArgsPreprocessing(signatures[i].params, signatures[i].fn);\n    }\n\n    const fn0 = ok0 ? signatures[0].implementation : undef;\n    const fn1 = ok1 ? signatures[1].implementation : undef;\n    const fn2 = ok2 ? signatures[2].implementation : undef;\n    const fn3 = ok3 ? signatures[3].implementation : undef;\n    const fn4 = ok4 ? signatures[4].implementation : undef;\n    const fn5 = ok5 ? signatures[5].implementation : undef;\n    const len0 = ok0 ? signatures[0].params.length : -1;\n    const len1 = ok1 ? signatures[1].params.length : -1;\n    const len2 = ok2 ? signatures[2].params.length : -1;\n    const len3 = ok3 ? signatures[3].params.length : -1;\n    const len4 = ok4 ? signatures[4].params.length : -1;\n    const len5 = ok5 ? signatures[5].params.length : -1; // simple and generic, but also slow\n\n    const iStart = allOk ? 6 : 0;\n    const iEnd = signatures.length; // de-reference ahead for execution speed:\n\n    const tests = signatures.map(s => s.test);\n    const fns = signatures.map(s => s.implementation);\n\n    const generic = function generic() {\n      'use strict';\n\n      for (let i = iStart; i < iEnd; i++) {\n        if (tests[i](arguments)) {\n          return fns[i].apply(this, arguments);\n        }\n      }\n\n      return typed.onMismatch(name, arguments, signatures);\n    }; // create the typed function\n    // fast, specialized version. Falls back to the slower, generic one if needed\n\n\n    function theTypedFn(arg0, arg1) {\n      'use strict';\n\n      if (arguments.length === len0 && test00(arg0) && test01(arg1)) {\n        return fn0.apply(this, arguments);\n      }\n\n      if (arguments.length === len1 && test10(arg0) && test11(arg1)) {\n        return fn1.apply(this, arguments);\n      }\n\n      if (arguments.length === len2 && test20(arg0) && test21(arg1)) {\n        return fn2.apply(this, arguments);\n      }\n\n      if (arguments.length === len3 && test30(arg0) && test31(arg1)) {\n        return fn3.apply(this, arguments);\n      }\n\n      if (arguments.length === len4 && test40(arg0) && test41(arg1)) {\n        return fn4.apply(this, arguments);\n      }\n\n      if (arguments.length === len5 && test50(arg0) && test51(arg1)) {\n        return fn5.apply(this, arguments);\n      }\n\n      return generic.apply(this, arguments);\n    } // attach name the typed function\n\n\n    try {\n      Object.defineProperty(theTypedFn, 'name', {\n        value: name\n      });\n    } catch (err) {// old browsers do not support Object.defineProperty and some don't support setting the name property\n      // the function name is not essential for the functioning, it's mostly useful for debugging,\n      // so it's fine to have unnamed functions.\n    } // attach signatures to the function.\n    // This property is close to the original collection of signatures\n    // used to create the typed-function, just with unions split:\n\n\n    theTypedFn.signatures = signaturesMap; // Store internal data for functions like resolve, find, etc.\n    // Also serves as the flag that this is a typed-function\n\n    theTypedFn._typedFunctionData = {\n      signatures,\n      signatureMap: internalSignatureMap\n    };\n    return theTypedFn;\n  }\n  /**\n   * Action to take on mismatch\n   * @param {string} name      Name of function that was attempted to be called\n   * @param {Array} args       Actual arguments to the call\n   * @param {Array} signatures Known signatures of the named typed-function\n   */\n\n\n  function _onMismatch(name, args, signatures) {\n    throw createError(name, args, signatures);\n  }\n  /**\n   * Return all but the last items of an array or function Arguments\n   * @param {Array | Arguments} arr\n   * @return {Array}\n   */\n\n\n  function initial(arr) {\n    return slice(arr, 0, arr.length - 1);\n  }\n  /**\n   * return the last item of an array or function Arguments\n   * @param {Array | Arguments} arr\n   * @return {*}\n   */\n\n\n  function last(arr) {\n    return arr[arr.length - 1];\n  }\n  /**\n   * Slice an array or function Arguments\n   * @param {Array | Arguments | IArguments} arr\n   * @param {number} start\n   * @param {number} [end]\n   * @return {Array}\n   */\n\n\n  function slice(arr, start, end) {\n    return Array.prototype.slice.call(arr, start, end);\n  }\n  /**\n   * Return the first item from an array for which test(arr[i]) returns true\n   * @param {Array} arr\n   * @param {function} test\n   * @return {* | undefined} Returns the first matching item\n   *                         or undefined when there is no match\n   */\n\n\n  function findInArray(arr, test) {\n    for (let i = 0; i < arr.length; i++) {\n      if (test(arr[i])) {\n        return arr[i];\n      }\n    }\n\n    return undefined;\n  }\n  /**\n   * Flat map the result invoking a callback for every item in an array.\n   * https://gist.github.com/samgiles/762ee337dff48623e729\n   * @param {Array} arr\n   * @param {function} callback\n   * @return {Array}\n   */\n\n\n  function flatMap(arr, callback) {\n    return Array.prototype.concat.apply([], arr.map(callback));\n  }\n  /**\n   * Create a reference callback to one or multiple signatures\n   *\n   * Syntax:\n   *\n   *     typed.referTo(signature1, signature2, ..., function callback(fn1, fn2, ...) {\n   *       // ...\n   *     })\n   *\n   * @returns {{referTo: {references: string[], callback}}}\n   */\n\n\n  function referTo() {\n    const references = initial(arguments).map(s => stringifyParams(parseSignature(s)));\n    const callback = last(arguments);\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Callback function expected as last argument');\n    }\n\n    return makeReferTo(references, callback);\n  }\n\n  function makeReferTo(references, callback) {\n    return {\n      referTo: {\n        references,\n        callback\n      }\n    };\n  }\n  /**\n   * Create a reference callback to the typed-function itself\n   *\n   * @param {(self: function) => function} callback\n   * @returns {{referToSelf: { callback: function }}}\n   */\n\n\n  function referToSelf(callback) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('Callback function expected as first argument');\n    }\n\n    return {\n      referToSelf: {\n        callback\n      }\n    };\n  }\n  /**\n   * Test whether something is a referTo object, holding a list with reference\n   * signatures and a callback.\n   *\n   * @param {Object | function} objectOrFn\n   * @returns {boolean}\n   */\n\n\n  function isReferTo(objectOrFn) {\n    return objectOrFn && typeof objectOrFn.referTo === 'object' && Array.isArray(objectOrFn.referTo.references) && typeof objectOrFn.referTo.callback === 'function';\n  }\n  /**\n   * Test whether something is a referToSelf object, holding a callback where\n   * to pass `self`.\n   *\n   * @param {Object | function} objectOrFn\n   * @returns {boolean}\n   */\n\n\n  function isReferToSelf(objectOrFn) {\n    return objectOrFn && typeof objectOrFn.referToSelf === 'object' && typeof objectOrFn.referToSelf.callback === 'function';\n  }\n  /**\n   * Check if name is (A) new, (B) a match, or (C) a mismatch; and throw\n   * an error in case (C).\n   *\n   * @param { string | undefined } nameSoFar\n   * @param { string | undefined } newName\n   * @returns { string } updated name\n   */\n\n\n  function checkName(nameSoFar, newName) {\n    if (!nameSoFar) {\n      return newName;\n    }\n\n    if (newName && newName !== nameSoFar) {\n      const err = new Error('Function names do not match (expected: ' + nameSoFar + ', actual: ' + newName + ')');\n      err.data = {\n        actual: newName,\n        expected: nameSoFar\n      };\n      throw err;\n    }\n\n    return nameSoFar;\n  }\n  /**\n   * Retrieve the implied name from an object with signature keys\n   * and function values, checking whether all value names match\n   *\n   * @param { {string: function} } obj\n   */\n\n\n  function getObjectName(obj) {\n    let name;\n\n    for (const key in obj) {\n      // Only pay attention to own properties, and only if their values\n      // are typed functions or functions with a signature property\n      if (Object.prototype.hasOwnProperty.call(obj, key) && (isTypedFunction(obj[key]) || typeof obj[key].signature === 'string')) {\n        name = checkName(name, obj[key].name);\n      }\n    }\n\n    return name;\n  }\n  /**\n   * Copy all of the signatures from the second argument into the first,\n   * which is modified by side effect, checking for conflicts\n   *\n   * @param {Object.<string, function|typed-reference>} dest\n   * @param {Object.<string, function|typed-reference>} source\n   */\n\n\n  function mergeSignatures(dest, source) {\n    let key;\n\n    for (key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        if (key in dest) {\n          if (source[key] !== dest[key]) {\n            const err = new Error('Signature \"' + key + '\" is defined twice');\n            err.data = {\n              signature: key,\n              sourceFunction: source[key],\n              destFunction: dest[key]\n            };\n            throw err;\n          } // else: both signatures point to the same function, that's fine\n\n        }\n\n        dest[key] = source[key];\n      }\n    }\n  }\n\n  const saveTyped = typed;\n  /**\n   * Originally the main function was a typed function itself, but then\n   * it might not be able to generate error messages if the client\n   * replaced the type system with different names.\n   *\n   * Main entry: typed([name], functions/objects with signatures...)\n   *\n   * Assembles and returns a new typed-function from the given items\n   * that provide signatures and implementations, each of which may be\n   * * a plain object mapping (string) signatures to implementing functions,\n   * * a previously constructed typed function, or\n   * * any other single function with a string-valued property `signature`.\n    * The name of the resulting typed-function will be given by the\n   * string-valued name argument if present, or if not, by the name\n   * of any of the arguments that have one, as long as any that do are\n   * consistent with each other. If no name is specified, the name will be\n   * an empty string.\n   *\n   * @param {string} maybeName [optional]\n   * @param {(function|object)[]} signature providers\n   * @returns {typed-function}\n   */\n\n  typed = function (maybeName) {\n    const named = typeof maybeName === 'string';\n    const start = named ? 1 : 0;\n    let name = named ? maybeName : '';\n    const allSignatures = {};\n\n    for (let i = start; i < arguments.length; ++i) {\n      const item = arguments[i];\n      let theseSignatures = {};\n      let thisName;\n\n      if (typeof item === 'function') {\n        thisName = item.name;\n\n        if (typeof item.signature === 'string') {\n          // Case 1: Ordinary function with a string 'signature' property\n          theseSignatures[item.signature] = item;\n        } else if (isTypedFunction(item)) {\n          // Case 2: Existing typed function\n          theseSignatures = item.signatures;\n        }\n      } else if (isPlainObject(item)) {\n        // Case 3: Plain object, assume keys = signatures, values = functions\n        theseSignatures = item;\n\n        if (!named) {\n          thisName = getObjectName(item);\n        }\n      }\n\n      if (Object.keys(theseSignatures).length === 0) {\n        const err = new TypeError('Argument to \\'typed\\' at index ' + i + ' is not a (typed) function, ' + 'nor an object with signatures as keys and functions as values.');\n        err.data = {\n          index: i,\n          argument: item\n        };\n        throw err;\n      }\n\n      if (!named) {\n        name = checkName(name, thisName);\n      }\n\n      mergeSignatures(allSignatures, theseSignatures);\n    }\n\n    return createTypedFunction(name || '', allSignatures);\n  };\n\n  typed.create = create;\n  typed.createCount = saveTyped.createCount;\n  typed.onMismatch = _onMismatch;\n  typed.throwMismatchError = _onMismatch;\n  typed.createError = createError;\n  typed.clear = clear;\n  typed.clearConversions = clearConversions;\n  typed.addTypes = addTypes;\n  typed._findType = findType; // For unit testing only\n\n  typed.referTo = referTo;\n  typed.referToSelf = referToSelf;\n  typed.convert = convert;\n  typed.findSignature = findSignature;\n  typed.find = find;\n  typed.isTypedFunction = isTypedFunction;\n  typed.warnAgainstDeprecatedThis = true;\n  /**\n   * add a type (convenience wrapper for typed.addTypes)\n   * @param {{name: string, test: function}} type\n   * @param {boolean} [beforeObjectTest=true]\n   *                          If true, the new test will be inserted before\n   *                          the test with name 'Object' (if any), since\n   *                          tests for Object match Array and classes too.\n   */\n\n  typed.addType = function (type, beforeObjectTest) {\n    let before = 'any';\n\n    if (beforeObjectTest !== false && typeMap.has('Object')) {\n      before = 'Object';\n    }\n\n    typed.addTypes([type], before);\n  };\n  /**\n   * Verify that the ConversionDef conversion has a valid format.\n   *\n   * @param {conversionDef} conversion\n   * @return {void}\n   * @throws {TypeError|SyntaxError}\n   */\n\n\n  function _validateConversion(conversion) {\n    if (!conversion || typeof conversion.from !== 'string' || typeof conversion.to !== 'string' || typeof conversion.convert !== 'function') {\n      throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');\n    }\n\n    if (conversion.to === conversion.from) {\n      throw new SyntaxError('Illegal to define conversion from \"' + conversion.from + '\" to itself.');\n    }\n  }\n  /**\n   * Add a conversion\n   *\n   * @param {ConversionDef} conversion\n   * @returns {void}\n   * @throws {TypeError}\n   */\n\n\n  typed.addConversion = function (conversion) {\n    _validateConversion(conversion);\n\n    const to = findType(conversion.to);\n\n    if (to.conversionsTo.every(function (other) {\n      return other.from !== conversion.from;\n    })) {\n      to.conversionsTo.push({\n        from: conversion.from,\n        convert: conversion.convert,\n        index: nConversions++\n      });\n    } else {\n      throw new Error('There is already a conversion from \"' + conversion.from + '\" to \"' + to.name + '\"');\n    }\n  };\n  /**\n   * Convenience wrapper to call addConversion on each conversion in a list.\n   *\n   @param {ConversionDef[]} conversions\n   @returns {void}\n   @throws {TypeError}\n   */\n\n\n  typed.addConversions = function (conversions) {\n    conversions.forEach(typed.addConversion);\n  };\n  /**\n   * Remove the specified conversion. The format is the same as for\n   * addConversion, and the convert function must match or an error\n   * is thrown.\n   *\n   * @param {{from: string, to: string, convert: function}} conversion\n   * @returns {void}\n   * @throws {TypeError|SyntaxError|Error}\n   */\n\n\n  typed.removeConversion = function (conversion) {\n    _validateConversion(conversion);\n\n    const to = findType(conversion.to);\n    const existingConversion = findInArray(to.conversionsTo, c => c.from === conversion.from);\n\n    if (!existingConversion) {\n      throw new Error('Attempt to remove nonexistent conversion from ' + conversion.from + ' to ' + conversion.to);\n    }\n\n    if (existingConversion.convert !== conversion.convert) {\n      throw new Error('Conversion to remove does not match existing conversion');\n    }\n\n    const index = to.conversionsTo.indexOf(existingConversion);\n    to.conversionsTo.splice(index, 1);\n  };\n  /**\n   * Produce the specific signature that a typed function\n   * will execute on the given arguments. Here, a \"signature\" is an\n   * object with properties 'params', 'test', 'fn', and 'implementation'.\n   * This last property is a function that converts params as necessary\n   * and then calls 'fn'. Returns null if there is no matching signature.\n   * @param {typed-function} tf\n   * @param {any[]} argList\n   * @returns {{params: string, test: function, fn: function, implementation: function}}\n   */\n\n\n  typed.resolve = function (tf, argList) {\n    if (!isTypedFunction(tf)) {\n      throw new TypeError(NOT_TYPED_FUNCTION);\n    }\n\n    const sigs = tf._typedFunctionData.signatures;\n\n    for (let i = 0; i < sigs.length; ++i) {\n      if (sigs[i].test(argList)) {\n        return sigs[i];\n      }\n    }\n\n    return null;\n  };\n\n  return typed;\n}\n\nexport default create();\n//# sourceMappingURL=typed-function.mjs.map"],"names":["root","cosh","Math","x","abs","exp","sinh","parser_exit","SyntaxError","logHypot","a","b","_a","_b","log","LN2","Complex","this","z","undefined","Number","isFinite","cos","sin","length","tokens","match","plus","minus","i","c","isNaN","parseFloat","parse","prototype","t","d","pow","arg","atan2","loh","re","im","r","sqrt","tmp","expm1","PI","xx","cosm1","y","t1","t2","Infinity","atan","acos","asin","res","noIM","oneMinus","onePlus","temp","atanh","asinh","acosh","places","ceil","floor","round","ret","E","NaN","_extends","Object","assign","target","arguments","source","key","hasOwnProperty","call","defaultEscapes","$","_","formatEscapes","defaultEscapeMapFn","module","exports","str","_ref","_ref$preserveFormatti","preserveFormatting","_ref$escapeMapFn","escapeMapFn","runningStr","String","result","escapes","escapeKeys","keys","_loop","specialCharFound","forEach","index","slice","naturalSort","oFxNcL","oFyNcL","sre","dre","hre","ore","s","insensitive","toLowerCase","replace","xN","split","yN","xD","parseInt","Date","yD","cLoc","numS","max","on","name","callback","ctx","e","push","fn","once","self","listener","off","apply","emit","data","evtArr","len","evts","liveEvents","TinyEmitter","ok","notOk","undef","NOT_TYPED_FUNCTION","create","isPlainObject","constructor","_types","test","Array","isArray","RegExp","anyType","isAny","typeMap","typeList","nConversions","typed","createCount","findType","typeName","type","get","message","otherName","TypeError","addTypes","types","beforeSpec","beforeIndex","newTypes","has","set","conversionsTo","affectedTypes","concat","clear","Map","findTypeNames","value","matches","filter","isTypedFunction","entity","findSignature","signature","options","exact","params","parseSignature","join","canonicalSignature","stringifyParams","signatures","_typedFunctionData","signatureMap","nParams","remainingSignatures","candidate","want","filteredSignatures","possibility","have","getParamAtIndex","restParam","hasAny","haveTypes","paramTypeSet","some","wtype","separator","map","p","parseParam","param","indexOf","typeDefs","trim","paramName","typeIndex","conversion","conversionIndex","hasConversion","expandParam","matchingConversions","typeNames","sort","knownTypes","Set","newMatch","from","add","availableConversions","newName","convertibleTypes","typeSet","rawSignature","rawParams","parsedParam","hasRestParam","last","compileTest","test0","test1","tests","compileTests","initial","varIndex","lastTest","testRestParam","args","getTypeSetAtIndex","isExactType","mergeExpectedParams","paramSet","createError","err","expected","_name","matchingSignatures","nextMatchingDefs","actualTypes","category","actual","lengths","min","maxLength","expectedLength","argTypes","getLowestTypeIndex","getLowestConversionIndex","compareParams","param1","param2","typeDiff","convDiff","compareSignatures","signature1","signature2","pars1","pars2","last1","last2","hasRest1","hasRest2","par","any1","conv1","any2","conv2","lengthCriterion","comparisons","tc","thisComparison","compileArgsPreprocessing","fnConvert","compiledConversions","compileArgConversion","fnPreprocess","offset","conversion0","conversion1","conversions","convert","splitParams","_splitParams","paramsSoFar","resultingParams","exactTypes","arr","nextParam","conflicting","params1","params2","ii","typeSet1","typeSet2","overlap","len1","len2","restParam1","restParam2","collectResolutions","references","functionList","resolvedReferences","reference","resolution","resolveReferences","resolvedFunctions","isReferToSelf","referToSelf","isReferTo","makeReferTo","referTo","clearResolutions","isResolved","fill","leftUnresolved","nothingResolved","createTypedFunction","rawSignaturesMap","warnAgainstDeprecatedThis","signaturesMap","deprecatedThisRegex","toString","validateDeprecatedThis","parsedParams","originalFunctions","preliminarySignatures","pp","functionIndex","conversionParams","sp","spName","every","theTypedFn","internalSignatureMap","ok0","ok1","ok2","ok3","ok4","ok5","allOk","test00","test10","test20","test30","test40","test50","test01","test11","test21","test31","test41","test51","implementation","fn0","fn1","fn2","fn3","fn4","fn5","len0","len3","len4","len5","iStart","iEnd","fns","generic","onMismatch","arg0","arg1","defineProperty","_onMismatch","start","end","objectOrFn","checkName","nameSoFar","Error","getObjectName","obj","mergeSignatures","dest","sourceFunction","destFunction","saveTyped","_validateConversion","to","maybeName","named","allSignatures","item","thisName","theseSignatures","argument","throwMismatchError","clearConversions","_findType","find","addType","beforeObjectTest","before","addConversion","other","addConversions","removeConversion","existingConversion","findInArray","splice","resolve","tf","argList","sigs"],"sourceRoot":""}