{"version":3,"file":"335.bundle.55607debb3b013859325.js","mappings":"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","sources":["webpack:///../../../extensions/cornerstone-dicom-seg/src/id.js","webpack:///../../../extensions/cornerstone-dicom-seg/src/getSopClassHandlerModule.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/utils/dicomlabToRGB.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/getHangingProtocolModule.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/types/segmentation.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/panels/callInputDialog.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/panels/colorPickerDialog.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/panels/segmentationIO/index.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/panels/PanelSegmentation.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/getPanelModule.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/utils/hydrationUtils.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/commandsModule.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/index.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/getToolbarModule.ts","webpack:///../../../extensions/cornerstone/src/Viewport/Overlays/utils.ts"],"sourcesContent":["import packageJson from '../package.json';\n\nconst id = packageJson.name;\nconst SOPClassHandlerName = 'dicom-seg';\nconst SOPClassHandlerId = `${id}.sopClassHandlerModule.${SOPClassHandlerName}`;\n\nexport { id, SOPClassHandlerId, SOPClassHandlerName };\n","import { utils } from '@ohif/core';\nimport { metaData, cache, triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { CONSTANTS } from '@cornerstonejs/tools';\nimport { adaptersSEG, Enums } from '@cornerstonejs/adapters';\n\nimport { SOPClassHandlerId } from './id';\nimport { dicomlabToRGB } from './utils/dicomlabToRGB';\n\nconst sopClassUids = ['1.2.840.10008.5.1.4.1.1.66.4'];\n\nconst loadPromises = {};\n\nfunction _getDisplaySetsFromSeries(\n  instances,\n  servicesManager: AppTypes.ServicesManager,\n  extensionManager\n) {\n  const instance = instances[0];\n\n  const {\n    StudyInstanceUID,\n    SeriesInstanceUID,\n    SOPInstanceUID,\n    SeriesDescription,\n    SeriesNumber,\n    SeriesDate,\n    SOPClassUID,\n    wadoRoot,\n    wadoUri,\n    wadoUriRoot,\n  } = instance;\n\n  const displaySet = {\n    Modality: 'SEG',\n    loading: false,\n    isReconstructable: true, // by default for now since it is a volumetric SEG currently\n    displaySetInstanceUID: utils.guid(),\n    SeriesDescription,\n    SeriesNumber,\n    SeriesDate,\n    SOPInstanceUID,\n    SeriesInstanceUID,\n    StudyInstanceUID,\n    SOPClassHandlerId,\n    SOPClassUID,\n    referencedImages: null,\n    referencedSeriesInstanceUID: null,\n    referencedDisplaySetInstanceUID: null,\n    isDerivedDisplaySet: true,\n    isLoaded: false,\n    isHydrated: false,\n    segments: {},\n    sopClassUids,\n    instance,\n    instances: [instance],\n    wadoRoot,\n    wadoUriRoot,\n    wadoUri,\n    isOverlayDisplaySet: true,\n  };\n\n  const referencedSeriesSequence = instance.ReferencedSeriesSequence;\n\n  if (!referencedSeriesSequence) {\n    console.error('ReferencedSeriesSequence is missing for the SEG');\n    return;\n  }\n\n  const referencedSeries = referencedSeriesSequence[0] || referencedSeriesSequence;\n\n  displaySet.referencedImages = instance.ReferencedSeriesSequence.ReferencedInstanceSequence;\n  displaySet.referencedSeriesInstanceUID = referencedSeries.SeriesInstanceUID;\n\n  displaySet.getReferenceDisplaySet = () => {\n    const { displaySetService } = servicesManager.services;\n    const referencedDisplaySets = displaySetService.getDisplaySetsForSeries(\n      displaySet.referencedSeriesInstanceUID\n    );\n\n    if (!referencedDisplaySets || referencedDisplaySets.length === 0) {\n      throw new Error('Referenced DisplaySet is missing for the SEG');\n    }\n\n    const referencedDisplaySet = referencedDisplaySets[0];\n\n    displaySet.referencedDisplaySetInstanceUID = referencedDisplaySet.displaySetInstanceUID;\n\n    // Todo: this needs to be able to work with other reference volumes (other than streaming) such as nifti, etc.\n    displaySet.referencedVolumeURI = referencedDisplaySet.displaySetInstanceUID;\n    const referencedVolumeId = `cornerstoneStreamingImageVolume:${displaySet.referencedVolumeURI}`;\n    displaySet.referencedVolumeId = referencedVolumeId;\n\n    return referencedDisplaySet;\n  };\n\n  displaySet.load = async ({ headers }) =>\n    await _load(displaySet, servicesManager, extensionManager, headers);\n\n  return [displaySet];\n}\n\nfunction _load(\n  segDisplaySet,\n  servicesManager: AppTypes.ServicesManager,\n  extensionManager,\n  headers\n) {\n  const { SOPInstanceUID } = segDisplaySet;\n  const { segmentationService } = servicesManager.services;\n\n  if (\n    (segDisplaySet.loading || segDisplaySet.isLoaded) &&\n    loadPromises[SOPInstanceUID] &&\n    _segmentationExists(segDisplaySet, segmentationService)\n  ) {\n    return loadPromises[SOPInstanceUID];\n  }\n\n  segDisplaySet.loading = true;\n\n  // We don't want to fire multiple loads, so we'll wait for the first to finish\n  // and also return the same promise to any other callers.\n  loadPromises[SOPInstanceUID] = new Promise(async (resolve, reject) => {\n    if (!segDisplaySet.segments || Object.keys(segDisplaySet.segments).length === 0) {\n      await _loadSegments({\n        extensionManager,\n        servicesManager,\n        segDisplaySet,\n        headers,\n      });\n    }\n\n    const suppressEvents = true;\n    segmentationService\n      .createSegmentationForSEGDisplaySet(segDisplaySet, null, suppressEvents)\n      .then(() => {\n        segDisplaySet.loading = false;\n        resolve();\n      })\n      .catch(error => {\n        segDisplaySet.loading = false;\n        reject(error);\n      });\n  });\n\n  return loadPromises[SOPInstanceUID];\n}\n\nasync function _loadSegments({\n  extensionManager,\n  servicesManager,\n  segDisplaySet,\n  headers,\n}: withAppTypes) {\n  const utilityModule = extensionManager.getModuleEntry(\n    '@ohif/extension-cornerstone.utilityModule.common'\n  );\n\n  const { segmentationService, uiNotificationService } = servicesManager.services;\n\n  const { dicomLoaderService } = utilityModule.exports;\n  const arrayBuffer = await dicomLoaderService.findDicomDataPromise(segDisplaySet, null, headers);\n\n  const cachedReferencedVolume = cache.getVolume(segDisplaySet.referencedVolumeId);\n\n  if (!cachedReferencedVolume) {\n    throw new Error(\n      'Referenced Volume is missing for the SEG, and stack viewport SEG is not supported yet'\n    );\n  }\n\n  const { imageIds } = cachedReferencedVolume;\n\n  // Todo: what should be defaults here\n  const tolerance = 0.001;\n  const skipOverlapping = true;\n\n  eventTarget.addEventListener(Enums.Events.SEGMENTATION_LOAD_PROGRESS, evt => {\n    const { percentComplete } = evt.detail;\n    segmentationService._broadcastEvent(segmentationService.EVENTS.SEGMENT_LOADING_COMPLETE, {\n      percentComplete,\n    });\n  });\n\n  const results = await adaptersSEG.Cornerstone3D.Segmentation.generateToolState(\n    imageIds,\n    arrayBuffer,\n    metaData,\n    { skipOverlapping, tolerance, eventTarget, triggerEvent }\n  );\n\n  let usedRecommendedDisplayCIELabValue = true;\n  results.segMetadata.data.forEach((data, i) => {\n    if (i > 0) {\n      data.rgba = data.RecommendedDisplayCIELabValue;\n\n      if (data.rgba) {\n        data.rgba = dicomlabToRGB(data.rgba);\n      } else {\n        usedRecommendedDisplayCIELabValue = false;\n        data.rgba = CONSTANTS.COLOR_LUT[i % CONSTANTS.COLOR_LUT.length];\n      }\n    }\n  });\n\n  if (results.overlappingSegments) {\n    uiNotificationService.show({\n      title: 'Overlapping Segments',\n      message:\n        'Unsupported overlapping segments detected, segmentation rendering results may be incorrect.',\n      type: 'warning',\n    });\n  }\n\n  if (!usedRecommendedDisplayCIELabValue) {\n    // Display a notification about the non-utilization of RecommendedDisplayCIELabValue\n    uiNotificationService.show({\n      title: 'DICOM SEG import',\n      message:\n        'RecommendedDisplayCIELabValue not found for one or more segments. The default color was used instead.',\n      type: 'warning',\n      duration: 5000,\n    });\n  }\n\n  Object.assign(segDisplaySet, results);\n}\n\nfunction _segmentationExists(segDisplaySet, segmentationService: AppTypes.SegmentationService) {\n  // This should be abstracted with the CornerstoneCacheService\n  return segmentationService.getSegmentation(segDisplaySet.displaySetInstanceUID);\n}\n\nfunction getSopClassHandlerModule({ servicesManager, extensionManager }) {\n  const getDisplaySetsFromSeries = instances => {\n    return _getDisplaySetsFromSeries(instances, servicesManager, extensionManager);\n  };\n\n  return [\n    {\n      name: 'dicom-seg',\n      sopClassUids,\n      getDisplaySetsFromSeries,\n    },\n  ];\n}\n\nexport default getSopClassHandlerModule;\n","import dcmjs from 'dcmjs';\n\n/**\n * Converts a CIELAB color to an RGB color using the dcmjs library.\n * @param cielab - The CIELAB color to convert.\n * @returns The RGB color as an array of three integers between 0 and 255.\n */\nfunction dicomlabToRGB(cielab: number[]): number[] {\n  const rgb = dcmjs.data.Colors.dicomlab2RGB(cielab).map(x => Math.round(x * 255));\n\n  return rgb;\n}\n\nexport { dicomlabToRGB };\n","import { Types } from '@ohif/core';\n\nconst segProtocol: Types.HangingProtocol.Protocol = {\n  id: '@ohif/seg',\n  // Don't store this hanging protocol as it applies to the currently active\n  // display set by default\n  // cacheId: null,\n  name: 'Segmentations',\n  // Just apply this one when specifically listed\n  protocolMatchingRules: [],\n  toolGroupIds: ['default'],\n  // -1 would be used to indicate active only, whereas other values are\n  // the number of required priors referenced - so 0 means active with\n  // 0 or more priors.\n  numberOfPriorsReferenced: 0,\n  // Default viewport is used to define the viewport when\n  // additional viewports are added using the layout tool\n  defaultViewport: {\n    viewportOptions: {\n      viewportType: 'stack',\n      toolGroupId: 'default',\n      allowUnmatchedView: true,\n    },\n    displaySets: [\n      {\n        id: 'segDisplaySetId',\n        matchedDisplaySetsIndex: -1,\n      },\n    ],\n  },\n  displaySetSelectors: {\n    segDisplaySetId: {\n      seriesMatchingRules: [\n        {\n          attribute: 'Modality',\n          constraint: {\n            equals: 'SEG',\n          },\n        },\n      ],\n    },\n  },\n  stages: [\n    {\n      name: 'Segmentations',\n      viewportStructure: {\n        layoutType: 'grid',\n        properties: {\n          rows: 1,\n          columns: 1,\n        },\n      },\n      viewports: [\n        {\n          viewportOptions: { allowUnmatchedView: true },\n          displaySets: [\n            {\n              id: 'segDisplaySetId',\n            },\n          ],\n        },\n      ],\n    },\n  ],\n};\n\nfunction getHangingProtocolModule() {\n  return [\n    {\n      name: segProtocol.id,\n      protocol: segProtocol,\n    },\n  ];\n}\n\nexport default getHangingProtocolModule;\nexport { segProtocol };\n","export enum SegmentationPanelMode {\n  Expanded = 'expanded',\n  Dropdown = 'dropdown',\n}\n","import React from 'react';\nimport { Input, Dialog, ButtonEnums } from '@ohif/ui';\n\nfunction callInputDialog(uiDialogService, label, callback) {\n  const dialogId = 'enter-segment-label';\n\n  const onSubmitHandler = ({ action, value }) => {\n    switch (action.id) {\n      case 'save':\n        callback(value.label, action.id);\n        break;\n      case 'cancel':\n        callback('', action.id);\n        break;\n    }\n    uiDialogService.dismiss({ id: dialogId });\n  };\n\n  if (uiDialogService) {\n    uiDialogService.create({\n      id: dialogId,\n      centralize: true,\n      isDraggable: false,\n      showOverlay: true,\n      content: Dialog,\n      contentProps: {\n        title: 'Segment',\n        value: { label },\n        noCloseButton: true,\n        onClose: () => uiDialogService.dismiss({ id: dialogId }),\n        actions: [\n          { id: 'cancel', text: 'Cancel', type: ButtonEnums.type.secondary },\n          { id: 'save', text: 'Confirm', type: ButtonEnums.type.primary },\n        ],\n        onSubmit: onSubmitHandler,\n        body: ({ value, setValue }) => {\n          return (\n            <Input\n              label=\"Enter the segment label\"\n              labelClassName=\"text-white text-[14px] leading-[1.2]\"\n              autoFocus\n              className=\"border-primary-main bg-black\"\n              type=\"text\"\n              value={value.label}\n              onChange={event => {\n                event.persist();\n                setValue(value => ({ ...value, label: event.target.value }));\n              }}\n              onKeyPress={event => {\n                if (event.key === 'Enter') {\n                  onSubmitHandler({ value, action: { id: 'save' } });\n                }\n              }}\n            />\n          );\n        },\n      },\n    });\n  }\n}\n\nexport default callInputDialog;\n","import React from 'react';\nimport { Dialog } from '@ohif/ui';\nimport { ChromePicker } from 'react-color';\n\nimport './colorPickerDialog.css';\n\nfunction callColorPickerDialog(uiDialogService, rgbaColor, callback) {\n  const dialogId = 'pick-color';\n\n  const onSubmitHandler = ({ action, value }) => {\n    switch (action.id) {\n      case 'save':\n        callback(value.rgbaColor, action.id);\n        break;\n      case 'cancel':\n        callback('', action.id);\n        break;\n    }\n    uiDialogService.dismiss({ id: dialogId });\n  };\n\n  if (uiDialogService) {\n    uiDialogService.create({\n      id: dialogId,\n      centralize: true,\n      isDraggable: false,\n      showOverlay: true,\n      content: Dialog,\n      contentProps: {\n        title: 'Segment Color',\n        value: { rgbaColor },\n        noCloseButton: true,\n        onClose: () => uiDialogService.dismiss({ id: dialogId }),\n        actions: [\n          { id: 'cancel', text: 'Cancel', type: 'primary' },\n          { id: 'save', text: 'Save', type: 'secondary' },\n        ],\n        onSubmit: onSubmitHandler,\n        body: ({ value, setValue }) => {\n          const handleChange = color => {\n            setValue({ rgbaColor: color.rgb });\n          };\n\n          return (\n            <ChromePicker\n              color={value.rgbaColor}\n              onChange={handleChange}\n              presetColors={[]}\n              width={300}\n            />\n          );\n        },\n      },\n    });\n  }\n}\n\nexport default callColorPickerDialog;\n","import {Button, ButtonEnums, useViewportGrid, Icon} from \"@ohif/ui\";\nimport React, {useEffect, useState} from \"react\";\nimport PropTypes from \"prop-types\";\nimport {saveAs, FileSaver} from 'file-saver'\nimport JSZip from \"jszip\";\nimport { segmentation as cstSegmentation, utilities as csToolsUtils, Enums } from '@cornerstonejs/tools';\nimport { DicomMetadataStore } from '@ohif/core';\nimport { formatPN } from '../../../../cornerstone/src/Viewport/Overlays/utils'\n\nfunction SegmentationImportExport({\n  segmentationService,\n  uiNotificationService,\n  hangingProtocolService,\n  toolGroupService,\n  viewportGridService\n}) : React.JSX.Element {\n\n  const exportActiveSegmentation = async () => {\n    let segmentation = segmentationService.getActiveSegmentation();\n    if (!segmentation) {\n      uiNotificationService.show({\n        title: `Export Active Segmentation`,\n        message: `No active segmentation detected`,\n        type: 'info',\n        duration: 3000,\n      });\n      return;\n    }\n    const dentascanSegmentations = segmentationService.getDentascanSegmentations();\n    if (dentascanSegmentations?.includes(segmentation)) {\n      // Always export main segmentation\n      segmentation = segmentationService.getHiddenSegmentation(segmentation.id);\n    }\n\n    const { segments: segmentsInfo, label: segmentationLabel } = segmentation;\n    const { dimensions, scalarData } = segmentationService.getLabelmapVolume(segmentation.id);\n    const layerSize = dimensions[0] * dimensions[1];\n    const nbLayers = dimensions[2];\n\n    // One zip file per segmentation\n    const zip = new JSZip();\n\n    // One PNG image per layer\n    for (let layerI = 0; layerI < nbLayers; layerI++) {\n      const pixelData = new Uint8ClampedArray(layerSize * 4).fill(0);\n      for (let i = 0; i < layerSize; i++) {\n        const segmentIndex = scalarData[layerI * layerSize + i];\n        if (segmentIndex !== 0) {\n          // Not background\n          const { color } = segmentsInfo[segmentIndex];\n          pixelData[i * 4] = color[0];\n          pixelData[i * 4 + 1] = color[1];\n          pixelData[i * 4 + 2] = color[2];\n        }\n        pixelData[i * 4 + 3] = 255;\n      }\n\n      // Store PNG image in zip\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      canvas.width = dimensions[0];\n      canvas.height = dimensions[1];\n      const imgData = new ImageData(pixelData, dimensions[0], dimensions[1], { colorSpace: 'srgb' });\n      ctx.putImageData(imgData, 0, 0);\n      ctx.putImageData(imgData, 0, 0);\n\n      const pngBlob = await new Promise<Blob>((resolve, reject) => {\n        canvas.toBlob(blob => blob ? resolve(blob) : reject(new Error('Conversion to blob failed')), 'image/png');\n      });\n      zip.file(`layer_${layerI}.png`, pngBlob);\n    }\n\n    // Add scalar data as binary file\n    const binaryBlob = new Blob([new Uint8ClampedArray(scalarData)], { type: 'application/octet-stream' });\n    zip.file(`labelmapVolume_${segmentationLabel}.bin`, binaryBlob);\n\n    // Add segments information as JSON File\n    const jsonBlob = new Blob([JSON.stringify(segmentsInfo, null, '\\t')], { type: 'text/plain;charset=utf-8' });\n    zip.file(`segmentsInfo_${segmentationLabel}.json`, jsonBlob);\n\n    // Get study metadata\n    const { activeStudyUID } = hangingProtocolService.getState();\n    const study = DicomMetadataStore.getStudy(activeStudyUID);\n    const { StudyDate, PatientName } = study?.series[0]?.instances[0];\n    const patientNameFormatted = formatPN(PatientName[0]);\n\n    // Save zip file\n    const content = await zip.generateAsync({ type:'blob' });\n    saveAs(content, `${StudyDate ?? ''}_${patientNameFormatted ?? ''}_${segmentationLabel}.zip`);\n  }\n\n  const importConfiguration = (configurationFile) => {\n    // Default viewport needs to be accessible\n    const displaySetUID = viewportGridService.getDisplaySetsUIDsForViewport('default')[0];\n    if (!displaySetUID) {\n      uiNotificationService.show({\n        title: `Import Segmentation`,\n        message: `Default viewport not found`,\n        type: 'info',\n        duration: 3000,\n      });\n      return;\n    }\n    const toolGroupId = toolGroupService.getToolGroupForViewport('default').id;\n    const LABELMAP = Enums.SegmentationRepresentations.Labelmap;\n\n    const reader = new FileReader();\n    // Read configuration file\n    reader.onload = async function(event) {\n      try {\n        if (typeof event.target.result !== \"string\") {\n          // TODO error message\n          console.error(\"ERROR::JSON_READING::CORRUPTED_CONTENT\");\n          return;\n        }\n        // Copy segmentation\n        // TODO does not handle _ in segmentation label\n        const segmentationLabel = configurationFile.name.split('_').pop().replace(/\\.[^/.]+$/, \"\");\n        const options = { label: segmentationLabel };\n        const segId = await segmentationService.createSegmentationForDisplaySet(displaySetUID, options);\n        await segmentationService.addSegmentationRepresentationToToolGroup(toolGroupId, segId, true, LABELMAP);\n        segmentationService.setActiveSegmentationForToolGroup(segId, toolGroupId);\n\n        // Copy segments\n        const segments = JSON.parse(event.target.result);\n        for (const segment of segments) {\n          if (!segment) {\n            // Skip segment 0 (background) and deleted segments\n            continue;\n          }\n          const { segmentIndex } = segment;\n          segmentationService.addSegment(segId, {\n            segmentIndex: segmentIndex,\n            toolGroupId: toolGroupId,\n            properties: segment,\n            override: true\n          });\n        }\n      } catch (error) {\n        // TODO error message\n        console.error(\"ERROR::JSON_READING\", error);\n      }\n    };\n    reader.readAsText(configurationFile);\n  }\n\n  const importBinary = async (binaryFile) => {\n    // TODO promise?\n    const reader = new FileReader();\n    // Read binary file\n    reader.onload = async function(event) {\n      const newScalarData = new Uint8Array(event.target.result as ArrayBuffer);\n      const segmentationLabel = binaryFile.name.split('_').pop().replace(/\\.[^/.]+$/, \"\");\n      const segmentation = segmentationService.getSegmentations().filter(s => s.label === segmentationLabel)[0];\n      if (!segmentation) {\n        uiNotificationService.show({\n          title: `Import Segmentation`,\n          message: `Segmentation with name ${segmentationLabel} does not match segmentation of configuration file`,\n          type: 'info',\n          duration: 3000,\n        });\n        return;\n      }\n\n      const { scalarData } = segmentationService.getLabelmapVolume(segmentation.id);\n      for (let i = 0; i < scalarData.length; i++) {\n        scalarData[i] = newScalarData[i];\n      }\n      // Triggers rendering\n      cstSegmentation.triggerSegmentationEvents.triggerSegmentationDataModified(segmentation.id);\n    }\n    reader.readAsArrayBuffer(binaryFile);\n  }\n\n  const importSegmentationFromFolder = () => {\n    // Default viewport needs to be accessible\n    const displaySetUID = viewportGridService.getDisplaySetsUIDsForViewport('default')[0];\n    if (!displaySetUID) {\n      uiNotificationService.show({\n        title: `Import Segmentation`,\n        message: `Default viewport not found`,\n        type: 'info',\n        duration: 3000,\n      });\n      return;\n    }\n\n    // Load binary file\n    const input = document.createElement('input');\n    input.type = 'file';\n    input.webkitdirectory = true;\n    input.onchange = async _ => {\n      const files = Array.from(input.files);\n      const configurationFile = files.filter(filter => filter.type === 'application/json')[0];\n      const binaryFile = files.filter(file => file.type === 'application/octet-stream')[0];\n      if (!configurationFile || !binaryFile) {\n        uiNotificationService.show({\n          title: `Import Segmentation`,\n          message: `Missing configuration or binary file`,\n          type: 'info',\n          duration: 3000,\n        });\n        return;\n      }\n      importConfiguration(configurationFile);\n      importBinary(binaryFile);\n    };\n    input.click();\n  }\n\n  return (\n    <div className=\"flex flex-col min-h-0 font-inter font-[300]\">\n      <div className=\"bg-primary-dark pt-[6px] pb-[6px]\">\n        <p className=\"text-[#d8d8d8] text-[12px] font-[300] pl-[9px] pr-[9px] pb-[6px] flex\">{'Segmentation'}</p>\n        <div className=\"text-[#d8d8d8] text-[12px] font-[300] justify-evenly flex\">\n          <Button\n            size={ButtonEnums.size.small}\n            onClick={importSegmentationFromFolder}\n          >{'Import'}</Button>\n          <Button\n            size={ButtonEnums.size.small}\n            onClick={exportActiveSegmentation}\n          >{'Export'}</Button>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default SegmentationImportExport\n","import { createReportAsync } from '@ohif/extension-default';\nimport React, {useCallback, useEffect, useState} from 'react';\nimport PropTypes, {element} from 'prop-types';\nimport {Button, SegmentationGroupTable, SegmentationGroupTableExpanded, useViewportGrid, ListMenu} from '@ohif/ui';\nimport { SegmentationPanelMode } from '../types/segmentation';\nimport callInputDialog from './callInputDialog';\nimport callColorPickerDialog from './colorPickerDialog';\nimport BaseToolEdit from \"./segToolsEditSection/baseToolEdit\";\nimport SegmentationImportExport from \"./segmentationIO\";\nimport {useTranslation} from 'react-i18next';\nimport { DisplaySet, RGB } from 'platform/core/src/types';\nimport { VolumeData } from 'extensions/cornerstone/src/types/CornerstoneCacheService';\nimport { Enums as csEnums } from '@cornerstonejs/core';\nimport { Enums as cstEnums } from '@cornerstonejs/tools';\n\nconst components = {\n  [SegmentationPanelMode.Expanded]: SegmentationGroupTableExpanded,\n  [SegmentationPanelMode.Dropdown]: SegmentationGroupTable,\n};\n\nconst seededRandom = (seed: number) => {\n  let value = seed % 2147483647;\n  return () => {\n      value = (value * 16807) % 2147483647;\n      return value / 2147483647;\n  };\n}\nconst random = seededRandom(42);\n\nexport default function PanelSegmentation({\n  servicesManager,\n  commandsManager,\n  extensionManager,\n  configuration,\n}: withAppTypes) {\n  const [{ activeViewportId, viewports }] = useViewportGrid();\n  const {\n    segmentationService,\n    viewportGridService,\n    uiDialogService,\n    displaySetService,\n    cornerstoneViewportService,\n    toolbarService,\n    uiNotificationService,\n    panoramicService,\n    hangingProtocolService,\n    toolGroupService,\n  } = servicesManager.services;\n\n  const { t } = useTranslation('PanelSegmentation');\n\n  const [addSegmentationClassName, setAddSegmentationClassName] = useState('');\n  const [segmentationConfiguration, setSegmentationConfiguration] = useState(\n    segmentationService.getConfiguration()\n  );\n\n  const isDentascanViewport = (viewportId): boolean => {\n    const { volume } = cornerstoneViewportService.getViewportInfo(viewportId).getViewportData().data[0] as VolumeData;\n    return volume?.metadata.SeriesInstanceUID.includes('dentascan') || false;\n  }\n\n  const viewportDentascanIsActive = isDentascanViewport(viewportGridService.getActiveViewportId());\n  const [visibleSegmentations, setVisibleSegmentations] = useState(\n    () => viewportDentascanIsActive ? segmentationService.getDentascanSegmentations()\n                                    : segmentationService.getAxialSegmentations()\n  );\n  const [hiddenSegmentations, setHiddenSegmentations] = useState(\n    () => viewportDentascanIsActive ? segmentationService.getAxialSegmentations()\n                                    : segmentationService.getDentascanSegmentations()\n  );\n  const [isMinimized, setIsMinimized] = useState({});\n\n  const onToggleMinimizeSegmentation = useCallback(id => {\n    setIsMinimized(prevState => ({ ...prevState, [id]: !prevState[id] }));\n  }, [setIsMinimized]);\n\n  // Only expand the last segmentation added to the list and collapse the rest\n  useEffect(() => {\n    const lastSegmentationId = visibleSegmentations[visibleSegmentations.length - 1]?.id;\n    if (lastSegmentationId) {\n      setIsMinimized(prevState => ({ ...prevState, [lastSegmentationId]: false, }));\n    }\n  }, [visibleSegmentations, setIsMinimized]);\n\n  useEffect(() => {\n    // ~~ Subscription\n    const added = segmentationService.EVENTS.SEGMENTATION_ADDED;\n    const updated = segmentationService.EVENTS.SEGMENTATION_UPDATED;\n    const removed = segmentationService.EVENTS.SEGMENTATION_REMOVED;\n    const configChanged = segmentationService.EVENTS.SEGMENTATION_CONFIGURATION_CHANGED;\n    const subscriptions: any[] = [];\n\n    [added, updated, removed].forEach(evt => {\n      const { unsubscribe } = segmentationService.subscribe(evt, () => {\n        const viewportDentascanIsActive = isDentascanViewport(viewportGridService.getActiveViewportId());\n        setVisibleSegmentations(viewportDentascanIsActive ? segmentationService.getDentascanSegmentations()\n                                                          : segmentationService.getAxialSegmentations());\n        setHiddenSegmentations(viewportDentascanIsActive ? segmentationService.getAxialSegmentations()\n                                                         : segmentationService.getDentascanSegmentations());\n      });\n      subscriptions.push(unsubscribe);\n    });\n\n    [configChanged].forEach(evt => {\n      const { unsubscribe } = segmentationService.subscribe(evt, () => {\n        setSegmentationConfiguration(segmentationService.getConfiguration());\n      });\n      subscriptions.push(unsubscribe);\n    });\n\n    return () => {\n      subscriptions.forEach(unsub => {\n        unsub();\n      });\n    };\n  }, []);\n\n  // temporary measure to not allow add segmentation when the selected viewport\n  // is stack viewport\n  useEffect(() => {\n    const handleActiveViewportChange = viewportId => {\n      const activeDisplaySetsUIDs = viewportGridService.getDisplaySetsUIDsForViewport(\n        viewportId || viewportGridService.getActiveViewportId()\n      );\n\n      if (!activeDisplaySetsUIDs) {\n        return;\n      }\n\n      const isReconstructable =\n          activeDisplaySetsUIDs?.some(displaySetUID => {\n          const displaySet = displaySetService.getDisplaySetByUID(displaySetUID);\n          return displaySet?.isReconstructable;\n        }) || false;\n\n      if (isReconstructable) {\n        setAddSegmentationClassName('');\n      } else {\n        setAddSegmentationClassName('ohif-disabled');\n      }\n    };\n\n    // Handle initial state\n    handleActiveViewportChange();\n\n    const changedGrid = viewportGridService.EVENTS.ACTIVE_VIEWPORT_ID_CHANGED;\n    const ready = viewportGridService.EVENTS.VIEWPORTS_READY;\n\n    const subsGrid = [];\n    [ready, changedGrid].forEach(evt => {\n      const { unsubscribe } = viewportGridService.subscribe(evt, ({ viewportId }) => {\n        handleActiveViewportChange(viewportId);\n      });\n\n      subsGrid.push(unsubscribe);\n    });\n\n    const changedData = cornerstoneViewportService.EVENTS.VIEWPORT_DATA_CHANGED;\n\n    const subsData = [];\n    [changedData].forEach(evt => {\n      const { unsubscribe } = cornerstoneViewportService.subscribe(evt, () => {\n        handleActiveViewportChange();\n      });\n\n      subsData.push(unsubscribe);\n    });\n\n    // Clean up\n    return () => {\n      subsGrid.forEach(unsub => unsub());\n      subsData.forEach(unsub => unsub());\n    };\n  }, []);\n\n  const onSegmentationAdd = () => {\n    if (hangingProtocolService.getActiveProtocol().protocol.id !== 'panoramicViewport') {\n      commandsManager.runCommand('createEmptySegmentationForViewport', {\n        viewportId: viewportGridService.getActiveViewportId(),\n      });\n    } else {\n      const viewportIds = cornerstoneViewportService.getViewportIds();\n      if (isDentascanViewport(viewportGridService.getActiveViewportId())) {\n        commandsManager.runCommand('createEmptySegmentationForViewport', { viewportId: 'default' });\n        commandsManager.runCommand('createEmptySegmentationForViewport', { viewportId: viewportIds[2] });\n      } else {\n        commandsManager.runCommand('createEmptySegmentationForViewport', { viewportId: viewportIds[2] });\n        commandsManager.runCommand('createEmptySegmentationForViewport', { viewportId: 'default' });\n      }\n    }\n  };\n\n  const onSegmentationClick = (segmentationId: string) => {\n    for (const toolGroupId of segmentationService.getToolGroupIdsWithSegmentation(segmentationId)) {\n      segmentationService.setActiveSegmentationForToolGroup(segmentationId, toolGroupId);\n    };\n  };\n\n  const onSegmentationDelete = (segmentationId: string) => {\n    // Also delete hidden segmentation\n    // Delete hidden segmentation first so the new active segmentation is visible\n    const hiddenSegmentation = segmentationService.getHiddenSegmentation(segmentationId);\n    if (hiddenSegmentation) {\n      segmentationService.remove(hiddenSegmentation.id);\n    }\n\n    segmentationService.remove(segmentationId);\n  };\n\n  const onSegmentClick = (segmentationId, segmentIndex) => {\n    segmentationService.setActiveSegment(segmentationId, segmentIndex);\n\n    for (const toolGroupId of segmentationService.getToolGroupIdsWithSegmentation(segmentationId)) {\n      segmentationService.setActiveSegmentationForToolGroup(segmentationId, toolGroupId);\n      segmentationService.jumpToSegmentCenter(segmentationId, segmentIndex, toolGroupId);\n    };\n\n    const hiddenSegmentation = segmentationService.getHiddenSegmentation(segmentationId);\n    if (hiddenSegmentation) {\n      segmentationService.setActiveSegment(hiddenSegmentation.id, segmentIndex);\n      // Also jump for hidden segment\n      for (const toolGroupId of segmentationService.getToolGroupIdsWithSegmentation(hiddenSegmentation.id)) {\n        segmentationService.jumpToSegmentCenter(hiddenSegmentation.id, segmentIndex, toolGroupId);\n      }\n    }\n  };\n\n  const onSegmentEdit = (segmentationId, segmentIndex) => {\n    const segmentation = segmentationService.getSegmentation(segmentationId);\n\n    const segment = segmentation.segments[segmentIndex];\n    const { label } = segment;\n\n    callInputDialog(uiDialogService, label, (label, actionId) => {\n      if (label === '') {\n        return;\n      }\n\n      segmentationService.setSegmentLabel(segmentationId, segmentIndex, label);\n      // Also edit hidden segment\n      const hiddenSegmentation = segmentationService.getHiddenSegmentation(segmentationId);\n      if (hiddenSegmentation) {\n        segmentationService.setSegmentLabel(hiddenSegmentation.id, segmentIndex, label);\n      }\n    });\n  };\n\n  const onSegmentAdd = (segmentationId) => {\n    const segmentIndex = segmentationService.getSegmentation(segmentationId).segments.length;\n\n    const config = {\n      segmentIndex: segmentIndex,\n      properties: {\n        label: `Segment ${segmentIndex}`,\n        color: [Math.floor(random() * 256), Math.floor(random() * 256), Math.floor(random() * 256)] as RGB,\n        opacity: 255,\n        visibility: true,\n        isLocked: false,\n        active: true\n      }\n    }\n\n    segmentationService.addSegment(segmentationId, config);\n\n    // Also add on hidden segmentation\n    // Add also on dentascan segmentation\n    const hiddenSegmentation = segmentationService.getHiddenSegmentation(segmentationId);\n    if (hiddenSegmentation) {\n      segmentationService.addSegment(hiddenSegmentation.id, config);\n    }\n  }\n\n  const onSegmentationEdit = (segmentationId) => {\n    const segmentation = segmentationService.getSegmentation(segmentationId);\n    const { label } = segmentation;\n\n    callInputDialog(uiDialogService, label, (label, actionId) => {\n      if (label === '') {\n        return;\n      }\n\n      segmentationService.addOrUpdateSegmentation(\n        {\n          id: segmentationId,\n          label,\n        },\n        false, // suppress event\n        true // notYetUpdatedAtSource\n      );\n\n      // Also update hidden segmentation\n      const hiddenSegmentation = segmentationService.getHiddenSegmentation(segmentationId);\n      if (hiddenSegmentation) {\n        segmentationService.addOrUpdateSegmentation({ id: hiddenSegmentation.id, label }, false, true);\n      }\n    });\n  };\n\n  const onSegmentColorClick = (segmentationId, segmentIndex) => {\n    const segmentation = segmentationService.getSegmentation(segmentationId);\n\n    const segment = segmentation.segments[segmentIndex];\n    const { color, opacity } = segment;\n\n    const rgbaColor = {\n      r: color[0],\n      g: color[1],\n      b: color[2],\n      a: opacity / 255.0,\n    };\n\n    callColorPickerDialog(uiDialogService, rgbaColor, (newRgbaColor, actionId) => {\n      if (actionId === 'cancel') {\n        return;\n      }\n\n      segmentationService.setSegmentRGBAColor(segmentationId, segmentIndex, [\n        newRgbaColor.r,\n        newRgbaColor.g,\n        newRgbaColor.b,\n        newRgbaColor.a * 255.0,\n      ]);\n\n      // Also update hidden segment\n      const hiddenSegmentation = segmentationService.getHiddenSegmentation(segmentationId);\n      if (hiddenSegmentation) {\n        segmentationService.setSegmentRGBAColor(hiddenSegmentation.id, segmentIndex, [\n          newRgbaColor.r,\n          newRgbaColor.g,\n          newRgbaColor.b,\n          newRgbaColor.a * 255.0,\n        ]);\n      }\n    });\n  };\n\n  const onSegmentDelete = (segmentationId, segmentIndex) => {\n    segmentationService.removeSegment(segmentationId, segmentIndex);\n    // Also delete hidden segment\n    const hiddenSegmentation = segmentationService.getHiddenSegmentation(segmentationId);\n    if (hiddenSegmentation) {\n      segmentationService.removeSegment(hiddenSegmentation.id, segmentIndex);\n    }\n  };\n\n  // segment hide\n  const onToggleSegmentVisibility = (segmentationId, segmentIndex) => {\n    const segmentation = segmentationService.getSegmentation(segmentationId);\n    const segmentInfo = segmentation.segments[segmentIndex];\n    const isVisible = !segmentInfo.isVisible;\n\n    // Todo: right now we apply the visibility to all tool groups\n    for (const toolGroupId of segmentationService.getToolGroupIdsWithSegmentation(segmentationId)) {\n      segmentationService.setSegmentVisibility(\n        segmentationId,\n        segmentIndex,\n        isVisible,\n        toolGroupId\n      );\n    };\n\n    // Also hide hidden segment\n    const hiddenSegmentation = segmentationService.getHiddenSegmentation(segmentationId);\n    if (hiddenSegmentation) {\n      for (const toolGroupId of segmentationService.getToolGroupIdsWithSegmentation(hiddenSegmentation.id)) {\n        segmentationService.setSegmentVisibility(\n          hiddenSegmentation.id,\n          segmentIndex,\n          isVisible,\n          toolGroupId\n        );\n      };\n    }\n  };\n\n  const onToggleSegmentLock = (segmentationId, segmentIndex) => {\n    segmentationService.toggleSegmentLocked(segmentationId, segmentIndex);\n    // Also lock hidden segment\n    const hiddenSegmentation = segmentationService.getHiddenSegmentation(segmentationId);\n    if (hiddenSegmentation) {\n      segmentationService.toggleSegmentLocked(hiddenSegmentation.id, segmentIndex);\n    }\n  };\n\n  const onToggleSegmentationVisibility = segmentationId => {\n    segmentationService.toggleSegmentationVisibility(segmentationId);\n    const segmentation = segmentationService.getSegmentation(segmentationId);\n    const isVisible = segmentation.isVisible;\n    const segments = segmentation.segments;\n\n    const toolGroupIds = segmentationService.getToolGroupIdsWithSegmentation(segmentationId);\n\n    toolGroupIds.forEach(toolGroupId => {\n      segments.forEach((segment, segmentIndex) => {\n        segmentationService.setSegmentVisibility(\n          segmentationId,\n          segmentIndex,\n          isVisible,\n          toolGroupId\n        );\n      });\n    });\n  };\n\n  const _setSegmentationConfiguration = useCallback(\n    (key, value) => {\n      segmentationService.setConfiguration({[key]: value});\n    }, [segmentationService]\n  );\n\n  const onSegmentationDownload = segmentationId => {\n    commandsManager.runCommand('downloadSegmentation', {\n      segmentationId,\n    });\n  };\n\n  const storeSegmentation = async segmentationId => {\n    const datasources = extensionManager.getActiveDataSource();\n\n    const displaySetInstanceUIDs = await createReportAsync({\n      servicesManager,\n      getReport: () =>\n        commandsManager.runCommand('storeSegmentation', {\n          segmentationId,\n          dataSource: datasources[0],\n        }),\n      reportType: 'Segmentation',\n    });\n\n    // Show the exported report in the active viewport as read only (similar to SR)\n    if (displaySetInstanceUIDs) {\n      // clear the segmentation that we exported, similar to the storeMeasurement\n      // where we remove the measurements and prompt again the user if they would like\n      // to re-read the measurements in a SR read only viewport\n      segmentationService.remove(segmentationId);\n\n      viewportGridService.setDisplaySetsForViewport({\n        viewportId: viewportGridService.getActiveViewportId(),\n        displaySetInstanceUIDs,\n      });\n    }\n  };\n\n  const onSegmentationDownloadRTSS = segmentationId => {\n    commandsManager.runCommand('downloadRTSS', {\n      segmentationId,\n    });\n  };\n\n  const SegmentationGroupTableComponent =\n    components[configuration?.segmentationPanelMode] || SegmentationGroupTable;\n  const allowAddSegment = configuration?.addSegment;\n  const onSegmentationAddWrapper =\n    configuration?.onSegmentationAdd && typeof configuration?.onSegmentationAdd === 'function'\n      ? configuration?.onSegmentationAdd\n      : onSegmentationAdd;\n\n  return (\n    <div className=\"flex flex-col flex-auto min-h-0F mt-1\">\n      {/* Segmentation tool edition */}\n      {/* <BaseToolEdit\n        segmentationService={segmentationService}\n        cornerstoneViewportService={cornerstoneViewportService}\n        toolbarService={toolbarService}\n      /> */}\n      {/* show segmentation table */}\n      <SegmentationGroupTableComponent\n        title={t('Segmentations')}\n        segmentations={visibleSegmentations}\n        hiddenSegmentations={hiddenSegmentations}\n        segmentationConfig={{ initialConfig: segmentationConfiguration }}\n        disableEditing={configuration.disableEditing}\n        showAddSegment={allowAddSegment}\n        showDeleteSegment={true}\n        onSegmentationAdd={onSegmentationAddWrapper}\n        onSegmentationEdit={onSegmentationEdit}\n        onSegmentationClick={onSegmentationClick}\n        onSegmentationDelete={onSegmentationDelete}\n        onSegmentationDownload={onSegmentationDownload}\n        onSegmentationDownloadRTSS={onSegmentationDownloadRTSS}\n        storeSegmentation={storeSegmentation}\n        onSegmentClick={onSegmentClick}\n        onSegmentAdd={onSegmentAdd}\n        onSegmentDelete={onSegmentDelete}\n        onSegmentEdit={onSegmentEdit}\n        onToggleSegmentationVisibility={onToggleSegmentationVisibility}\n        onToggleSegmentVisibility={onToggleSegmentVisibility}\n        onToggleSegmentLock={onToggleSegmentLock}\n        onSegmentColorClick={onSegmentColorClick}\n        setFillAlpha={value => _setSegmentationConfiguration('fillAlpha', value)}\n        setFillAlphaInactive={value => _setSegmentationConfiguration('fillAlphaInactive', value)}\n        setOutlineWidthActive={value => _setSegmentationConfiguration('outlineWidthActive', value)}\n        setOutlineOpacityActive={value => _setSegmentationConfiguration('outlineOpacity', value)}\n        setRenderFill={value => _setSegmentationConfiguration('renderFill', value)}\n        setRenderInactiveSegmentations={value => _setSegmentationConfiguration('renderInactiveSegmentations', value)}\n        setRenderOutline={value => _setSegmentationConfiguration('renderOutline', value)}\n\n        addSegmentationClassName={addSegmentationClassName}\n      />\n      <div className=\"h-[6px] bg-black \"></div>\n      <SegmentationImportExport\n        segmentationService={segmentationService}\n        uiNotificationService={uiNotificationService}\n        hangingProtocolService={hangingProtocolService}\n        toolGroupService={toolGroupService}\n        viewportGridService={viewportGridService}\n      />\n    </div>\n  )\n}\n\nPanelSegmentation.propTypes = {\n  commandsManager: PropTypes.shape({\n    runCommand: PropTypes.func.isRequired,\n  }),\n  servicesManager: PropTypes.shape({\n    services: PropTypes.shape({\n      segmentationService: PropTypes.shape({\n        getSegmentation: PropTypes.func.isRequired,\n        getSegmentations: PropTypes.func.isRequired,\n        toggleSegmentationVisibility: PropTypes.func.isRequired,\n        subscribe: PropTypes.func.isRequired,\n        EVENTS: PropTypes.object.isRequired,\n      }).isRequired,\n    }).isRequired,\n  }).isRequired,\n};\n","import React from 'react';\n\nimport { useAppConfig } from '@state';\nimport { Toolbox } from '@ohif/ui';\nimport PanelSegmentation from './panels/PanelSegmentation';\n\nconst getPanelModule = ({\n  commandsManager,\n  servicesManager,\n  extensionManager,\n  configuration,\n  title,\n}: withAppTypes) => {\n  const { customizationService } = servicesManager.services;\n\n  const wrappedPanelSegmentation = configuration => {\n    const [appConfig] = useAppConfig();\n\n    return (\n      <PanelSegmentation\n        commandsManager={commandsManager}\n        servicesManager={servicesManager}\n        extensionManager={extensionManager}\n        configuration={{\n          ...configuration,\n          disableEditing: appConfig.disableEditing,\n          ...customizationService.get('segmentation.panel'),\n        }}\n      />\n    );\n  };\n\n  const wrappedPanelSegmentationWithTools = configuration => {\n    const [appConfig] = useAppConfig();\n\n    return (\n      <>\n        <Toolbox\n          commandsManager={commandsManager}\n          servicesManager={servicesManager}\n          extensionManager={extensionManager}\n          buttonSectionId=\"segmentationToolbox\"\n          title=\"Segmentation Tools\"\n          configuration={{\n            ...configuration,\n          }}\n        />\n        <PanelSegmentation\n          commandsManager={commandsManager}\n          servicesManager={servicesManager}\n          extensionManager={extensionManager}\n          configuration={{\n            ...configuration,\n            disableEditing: appConfig.disableEditing,\n            ...customizationService.get('segmentation.panel'),\n          }}\n        />\n      </>\n    );\n  };\n\n  return [\n    {\n      name: 'panelSegmentation',\n      iconName: 'tab-segmentation',\n      iconLabel: 'Segmentation',\n      label: 'Segmentation',\n      component: wrappedPanelSegmentation,\n    },\n    {\n      name: 'panelSegmentationWithTools',\n      iconName: 'tab-segmentation',\n      iconLabel: 'Segmentation',\n      label: 'Segmentation',\n      component: wrappedPanelSegmentationWithTools,\n    },\n  ];\n};\n\nexport default getPanelModule;\n","import { Enums, cache } from '@cornerstonejs/core';\n\n/**\n * Updates the viewports in preparation for rendering segmentations.\n * Evaluates each viewport to determine which need modifications,\n * then for those viewports, changes them to a volume type and ensures\n * they are ready for segmentation rendering.\n *\n * @param {Object} params - Parameters for the function.\n * @param params.viewportId - ID of the viewport to be updated.\n * @param params.loadFn - Function to load the segmentation data.\n * @param params.servicesManager - The services manager.\n * @param params.displaySet -  the display set.\n * @param params.initialSliceIndex - The initial slice index.\n *\n * @returns Returns true upon successful update of viewports for segmentation rendering.\n */\nasync function updateViewportsForSegmentationRendering({\n  viewportId,\n  loadFn,\n  servicesManager,\n  displaySet,\n  initialSliceIndex = null,\n}: {\n  viewportId: string;\n  loadFn: () => Promise<string>;\n  servicesManager: AppTypes.ServicesManager;\n  displaySet?: any;\n  initialSliceIndex?: number;\n}) {\n  const { cornerstoneViewportService, segmentationService, viewportGridService } =\n    servicesManager.services;\n\n  const viewport = getTargetViewport({ viewportId, viewportGridService });\n  const targetViewportId = viewport.viewportOptions.viewportId;\n\n  const referencedDisplaySetInstanceUID =\n    displaySet?.referencedDisplaySetInstanceUID || viewport?.displaySetInstanceUIDs[0];\n\n  const updatedViewports = getUpdatedViewportsForSegmentation({\n    viewportId,\n    servicesManager,\n    displaySet,\n  });\n\n  // create Segmentation callback which needs to be waited until\n  // the volume is created (if coming from stack)\n  const createSegmentationForVolume = async () => {\n    const segmentationId = await loadFn();\n    segmentationService.hydrateSegmentation(segmentationId);\n  };\n\n  // the reference volume that is used to draw the segmentation. so check if the\n  // volume exists in the cache (the target Viewport is already a volume viewport)\n  const volumeExists = Array.from(cache._volumeCache.keys()).some(volumeId =>\n    volumeId.includes(referencedDisplaySetInstanceUID)\n  );\n\n  updatedViewports.forEach(async viewport => {\n    viewport.viewportOptions = {\n      ...viewport.viewportOptions,\n      viewportType: displaySet?.Modality === 'RTSTRUCT' ? 'stack' : 'volume',\n      needsRerendering: true,\n    };\n    const viewportId = viewport.viewportId;\n\n    // maintain the prehydration slice on the target viewport only\n    if (viewportId === targetViewportId) {\n      viewport.viewportOptions.initialImageOptions = {\n        index: initialSliceIndex,\n        useOnce: true,\n      };\n    }\n\n    const csViewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\n    const prevCamera = csViewport.getCamera();\n\n    // only run the createSegmentationForVolume for the targetViewportId\n    // since the rest will get handled by cornerstoneViewportService\n    if ((volumeExists || displaySet.Modality === 'RTSTRUCT') && viewportId === targetViewportId) {\n      await createSegmentationForVolume();\n      return;\n    }\n\n    const createNewSegmentationWhenVolumeMounts = async evt => {\n      const isTheActiveViewportVolumeMounted = evt.detail.volumeActors?.find(ac =>\n        ac.uid.includes(referencedDisplaySetInstanceUID)\n      );\n\n      // Note: make sure to re-grab the viewport since it might have changed\n      // during the time it took for the volume to be mounted, for instance\n      // the stack viewport has been changed to a volume viewport\n      const volumeViewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\n      volumeViewport.setCamera(prevCamera);\n\n      volumeViewport.element.removeEventListener(\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n        createNewSegmentationWhenVolumeMounts\n      );\n\n      if (!isTheActiveViewportVolumeMounted) {\n        // it means it is one of those other updated viewports so just update the camera\n        return;\n      }\n\n      if (viewportId === targetViewportId) {\n        await createSegmentationForVolume();\n      }\n    };\n\n    csViewport.element.addEventListener(\n      Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n      createNewSegmentationWhenVolumeMounts\n    );\n  });\n\n  // Set the displaySets for the viewports that require to be updated\n  viewportGridService.setDisplaySetsForViewports(updatedViewports);\n\n  return true;\n}\n\nconst getTargetViewport = ({ viewportId, viewportGridService }) => {\n  const { viewports, activeViewportId } = viewportGridService.getState();\n  const targetViewportId = viewportId || activeViewportId;\n\n  const viewport = viewports.get(targetViewportId);\n\n  return viewport;\n};\n\n/**\n * Retrieves a list of viewports that require updates in preparation for segmentation rendering.\n * This function evaluates viewports based on their compatibility with the provided segmentation's\n * frame of reference UID and appends them to the updated list if they should render the segmentation.\n *\n * @param {Object} params - Parameters for the function.\n * @param params.viewportId - the ID of the viewport to be updated.\n * @param params.servicesManager - The services manager\n * @param params.displaySet -  the display set.\n *\n * @returns {Array} Returns an array of viewports that require updates for segmentation rendering.\n */\nfunction getUpdatedViewportsForSegmentation({\n  viewportId,\n  servicesManager,\n  displaySet,\n}: withAppTypes) {\n  const { hangingProtocolService, displaySetService, segmentationService, viewportGridService } =\n    servicesManager.services;\n\n  const { viewports, isHangingProtocolLayout } = viewportGridService.getState();\n\n  const viewport = getTargetViewport({ viewportId, viewportGridService });\n  const targetViewportId = viewport.viewportOptions.viewportId;\n\n  const displaySetInstanceUIDs = viewports.get(targetViewportId).displaySetInstanceUIDs;\n\n  const referenceDisplaySetInstanceUID =\n    displaySet?.referencedDisplaySetInstanceUID || displaySetInstanceUIDs[0];\n\n  const referencedDisplaySet = displaySetService.getDisplaySetByUID(referenceDisplaySetInstanceUID);\n  const segmentationFrameOfReferenceUID = referencedDisplaySet.instances[0].FrameOfReferenceUID;\n\n  const updatedViewports = hangingProtocolService.getViewportsRequireUpdate(\n    targetViewportId,\n    referenceDisplaySetInstanceUID,\n    isHangingProtocolLayout\n  );\n\n  viewports.forEach((viewport, viewportId) => {\n    if (\n      targetViewportId === viewportId ||\n      updatedViewports.find(v => v.viewportId === viewportId)\n    ) {\n      return;\n    }\n\n    const shouldDisplaySeg = segmentationService.shouldRenderSegmentation(\n      viewport.displaySetInstanceUIDs,\n      segmentationFrameOfReferenceUID\n    );\n\n    if (shouldDisplaySeg) {\n      updatedViewports.push({\n        viewportId,\n        displaySetInstanceUIDs: viewport.displaySetInstanceUIDs,\n        viewportOptions: {\n          viewportType: displaySet?.Modality === 'RTSTRUCT' ? 'stack' : 'volume',\n          needsRerendering: true,\n        },\n      });\n    }\n  });\n\n  return updatedViewports.filter(v => v.viewportOptions?.viewportType !== 'volume3d');\n}\n\nexport {\n  updateViewportsForSegmentationRendering,\n  getUpdatedViewportsForSegmentation,\n  getTargetViewport,\n};\n","import dcmjs from 'dcmjs';\nimport { createReportDialogPrompt } from '@ohif/extension-default';\nimport { Types } from '@ohif/core';\nimport { cache, metaData } from '@cornerstonejs/core';\nimport {\n  segmentation as cornerstoneToolsSegmentation,\n  Enums as cornerstoneToolsEnums,\n  utilities,\n} from '@cornerstonejs/tools';\nimport { adaptersRT, helpers, adaptersSEG } from '@cornerstonejs/adapters';\nimport { classes, DicomMetadataStore } from '@ohif/core';\n\nimport vtkImageMarchingSquares from '@kitware/vtk.js/Filters/General/ImageMarchingSquares';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\n\nimport {\n  updateViewportsForSegmentationRendering,\n  getUpdatedViewportsForSegmentation,\n  getTargetViewport,\n} from './utils/hydrationUtils';\nconst { segmentation: segmentationUtils } = utilities;\n\nconst { datasetToBlob } = dcmjs.data;\n\nconst {\n  Cornerstone3D: {\n    Segmentation: { generateLabelMaps2DFrom3D, generateSegmentation },\n  },\n} = adaptersSEG;\n\nconst {\n  Cornerstone3D: {\n    RTSS: { generateRTSSFromSegmentations },\n  },\n} = adaptersRT;\n\nconst { downloadDICOMData } = helpers;\n\nconst commandsModule = ({\n  servicesManager,\n  extensionManager,\n}: Types.Extensions.ExtensionParams): Types.Extensions.CommandsModule => {\n  const {\n    uiNotificationService,\n    segmentationService,\n    uiDialogService,\n    displaySetService,\n    viewportGridService,\n    toolGroupService,\n    cornerstoneViewportService,\n  } = servicesManager.services;\n\n  const actions = {\n    /**\n     * Retrieves a list of viewports that require updates in preparation for segmentation rendering.\n     * This function evaluates viewports based on their compatibility with the provided segmentation's\n     * frame of reference UID and appends them to the updated list if they should render the segmentation.\n     *\n     * @param {Object} params - Parameters for the function.\n     * @param params.viewportId - the ID of the viewport to be updated.\n     * @param params.servicesManager - The services manager\n     * @param params.referencedDisplaySetInstanceUID - Optional UID for the referenced display set instance.\n     *\n     * @returns {Array} Returns an array of viewports that require updates for segmentation rendering.\n     */\n    getUpdatedViewportsForSegmentation,\n    /**\n     * Creates an empty segmentation for a specified viewport.\n     * It first checks if the display set associated with the viewport is reconstructable.\n     * If not, it raises a notification error. Otherwise, it creates a new segmentation\n     * for the display set after handling the necessary steps for making the viewport\n     * a volume viewport first\n     *\n     * @param {Object} params - Parameters for the function.\n     * @param params.viewportId - the target viewport ID.\n     *\n     */\n    createEmptySegmentationForViewport: async ({ viewportId }) => {\n      const viewport = getTargetViewport({ viewportId, viewportGridService });\n      // Todo: add support for multiple display sets\n      const displaySetInstanceUID = viewport.displaySetInstanceUIDs[0];\n\n      const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n\n      if (!displaySet.isReconstructable) {\n        uiNotificationService.show({\n          title: 'Segmentation',\n          message: 'Segmentation is not supported for non-reconstructible displaysets yet',\n          type: 'error',\n        });\n        return;\n      }\n\n      updateViewportsForSegmentationRendering({\n        viewportId,\n        servicesManager,\n        displaySet,\n        loadFn: async () => {\n          const currentSegmentations = segmentationService.getSegmentations();\n          const segmentationId = await segmentationService.createSegmentationForDisplaySet(\n            displaySetInstanceUID,\n            { label: `Segmentation ${currentSegmentations.length + 1}` }\n          );\n\n          const toolGroupId = viewport.viewportOptions.toolGroupId;\n\n          await segmentationService.addSegmentationRepresentationToToolGroup(\n            toolGroupId,\n            segmentationId\n          );\n\n          // Add only one segment for now\n          segmentationService.addSegment(segmentationId, {\n            toolGroupId,\n            segmentIndex: 1,\n            properties: {\n              label: 'Segment 1',\n              color: [255, 0, 0],\n              opacity: 255,\n              visibility: true,\n              isLocked: false,\n              active: true\n            },\n          });\n\n          return segmentationId;\n        },\n      });\n    },\n    /**\n     * Loads segmentations for a specified viewport.\n     * The function prepares the viewport for rendering, then loads the segmentation details.\n     * Additionally, if the segmentation has scalar data, it is set for the corresponding label map volume.\n     *\n     * @param {Object} params - Parameters for the function.\n     * @param params.segmentations - Array of segmentations to be loaded.\n     * @param params.viewportId - the target viewport ID.\n     *\n     */\n    loadSegmentationsForViewport: async ({ segmentations, viewportId }) => {\n      updateViewportsForSegmentationRendering({\n        viewportId,\n        servicesManager,\n        loadFn: async () => {\n          // Todo: handle adding more than one segmentation\n          const viewport = getTargetViewport({ viewportId, viewportGridService });\n          const displaySetInstanceUID = viewport.displaySetInstanceUIDs[0];\n\n          const segmentation = segmentations[0];\n          const segmentationId = segmentation.id;\n          const label = segmentation.label;\n          const segments = segmentation.segments;\n\n          delete segmentation.segments;\n\n          await segmentationService.createSegmentationForDisplaySet(displaySetInstanceUID, {\n            segmentationId,\n            label,\n          });\n\n          if (segmentation.scalarData) {\n            const labelmapVolume = segmentationService.getLabelmapVolume(segmentationId);\n            labelmapVolume.scalarData.set(segmentation.scalarData);\n          }\n\n          segmentationService.addOrUpdateSegmentation(segmentation);\n\n          const toolGroupId = viewport.viewportOptions.toolGroupId;\n          await segmentationService.addSegmentationRepresentationToToolGroup(\n            toolGroupId,\n            segmentationId\n          );\n\n          segments.forEach(segment => {\n            if (segment === null) {\n              return;\n            }\n            segmentationService.addSegment(segmentationId, {\n              segmentIndex: segment.segmentIndex,\n              toolGroupId,\n              properties: {\n                color: segment.color,\n                label: segment.label,\n                opacity: segment.opacity,\n                isLocked: segment.isLocked,\n                visibility: segment.isVisible,\n                active: segmentation.activeSegmentIndex === segment.segmentIndex,\n              },\n            });\n          });\n\n          if (segmentation.centroidsIJK) {\n            segmentationService.setCentroids(segmentation.id, segmentation.centroidsIJK);\n          }\n\n          return segmentationId;\n        },\n      });\n    },\n    /**\n     * Loads segmentation display sets for a specified viewport.\n     * Depending on the modality of the display set (SEG or RTSTRUCT),\n     * it chooses the appropriate service function to create\n     * the segmentation for the display set.\n     * The function then prepares the viewport for rendering segmentation.\n     *\n     * @param {Object} params - Parameters for the function.\n     * @param params.viewportId - ID of the viewport where the segmentation display sets should be loaded.\n     * @param params.displaySets - Array of display sets to be loaded for segmentation.\n     *\n     */\n    loadSegmentationDisplaySetsForViewport: async ({ viewportId, displaySets }) => {\n      // Todo: handle adding more than one segmentation\n      const displaySet = displaySets[0];\n      const referencedDisplaySet = displaySetService.getDisplaySetByUID(\n        displaySet.referencedDisplaySetInstanceUID\n      );\n      const viewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\n      const initialSliceIndex = viewport.getSliceIndex();\n\n      updateViewportsForSegmentationRendering({\n        viewportId,\n        servicesManager,\n        displaySet,\n        loadFn: async () => {\n          const segDisplaySet = displaySet;\n          const suppressEvents = false;\n          const serviceFunction =\n            segDisplaySet.Modality === 'SEG'\n              ? 'createSegmentationForSEGDisplaySet'\n              : 'createSegmentationForRTDisplaySet';\n\n          const boundFn = segmentationService[serviceFunction].bind(segmentationService);\n          const segmentationId = await boundFn(segDisplaySet, null, suppressEvents);\n          const segmentation = segmentationService.getSegmentation(segmentationId);\n          segmentation.description = `S${referencedDisplaySet.SeriesNumber}: ${referencedDisplaySet.SeriesDescription}`;\n          return segmentationId;\n        },\n        initialSliceIndex,\n      });\n    },\n    /**\n     * Generates a segmentation from a given segmentation ID.\n     * This function retrieves the associated segmentation and\n     * its referenced volume, extracts label maps from the\n     * segmentation volume, and produces segmentation data\n     * alongside associated metadata.\n     *\n     * @param {Object} params - Parameters for the function.\n     * @param params.segmentationId - ID of the segmentation to be generated.\n     * @param params.options - Optional configuration for the generation process.\n     *\n     * @returns Returns the generated segmentation data.\n     */\n    generateSegmentation: ({ segmentationId, options = {} }) => {\n      const segmentation = cornerstoneToolsSegmentation.state.getSegmentation(segmentationId);\n\n      const { referencedVolumeId } = segmentation.representationData.LABELMAP;\n\n      const segmentationVolume = cache.getVolume(segmentationId);\n      const referencedVolume = cache.getVolume(referencedVolumeId);\n      const referencedImages = referencedVolume.getCornerstoneImages();\n\n      const labelmapObj = generateLabelMaps2DFrom3D(segmentationVolume);\n\n      // Generate fake metadata as an example\n      labelmapObj.metadata = [];\n\n      const segmentationInOHIF = segmentationService.getSegmentation(segmentationId);\n      segmentationInOHIF.segments.forEach(segment => {\n        // segmentation service already has a color for each segment\n        if (!segment) {\n          return;\n        }\n        const segmentIndex = segment.segmentIndex;\n        const { label, color } = segment;\n\n        const RecommendedDisplayCIELabValue = dcmjs.data.Colors.rgb2DICOMLAB(\n          color.slice(0, 3).map(value => value / 255)\n        ).map(value => Math.round(value));\n\n        const segmentMetadata = {\n          SegmentNumber: segmentIndex.toString(),\n          SegmentLabel: label,\n          SegmentAlgorithmType: segment?.algorithmType || 'MANUAL',\n          SegmentAlgorithmName: segment?.algorithmName || 'OHIF Brush',\n          RecommendedDisplayCIELabValue,\n          SegmentedPropertyCategoryCodeSequence: {\n            CodeValue: 'T-D0050',\n            CodingSchemeDesignator: 'SRT',\n            CodeMeaning: 'Tissue',\n          },\n          SegmentedPropertyTypeCodeSequence: {\n            CodeValue: 'T-D0050',\n            CodingSchemeDesignator: 'SRT',\n            CodeMeaning: 'Tissue',\n          },\n        };\n        labelmapObj.metadata[segmentIndex] = segmentMetadata;\n      });\n\n      const generatedSegmentation = generateSegmentation(\n        referencedImages,\n        labelmapObj,\n        metaData,\n        options\n      );\n\n      return generatedSegmentation;\n    },\n    /**\n     * Downloads a segmentation based on the provided segmentation ID.\n     * This function retrieves the associated segmentation and\n     * uses it to generate the corresponding DICOM dataset, which\n     * is then downloaded with an appropriate filename.\n     *\n     * @param {Object} params - Parameters for the function.\n     * @param params.segmentationId - ID of the segmentation to be downloaded.\n     *\n     */\n    downloadSegmentation: ({ segmentationId }) => {\n      const segmentationInOHIF = segmentationService.getSegmentation(segmentationId);\n      const generatedSegmentation = actions.generateSegmentation({\n        segmentationId,\n      });\n\n      downloadDICOMData(generatedSegmentation.dataset, `${segmentationInOHIF.label}`);\n    },\n    /**\n     * Stores a segmentation based on the provided segmentationId into a specified data source.\n     * The SeriesDescription is derived from user input or defaults to the segmentation label,\n     * and in its absence, defaults to 'Research Derived Series'.\n     *\n     * @param {Object} params - Parameters for the function.\n     * @param params.segmentationId - ID of the segmentation to be stored.\n     * @param params.dataSource - Data source where the generated segmentation will be stored.\n     *\n     * @returns {Object|void} Returns the naturalized report if successfully stored,\n     * otherwise throws an error.\n     */\n    storeSegmentation: async ({ segmentationId, dataSource }) => {\n      const promptResult = await createReportDialogPrompt(uiDialogService, {\n        extensionManager,\n      });\n\n      if (promptResult.action !== 1 && promptResult.value) {\n        return;\n      }\n\n      const segmentation = segmentationService.getSegmentation(segmentationId);\n\n      if (!segmentation) {\n        throw new Error('No segmentation found');\n      }\n\n      const { label } = segmentation;\n      const SeriesDescription = promptResult.value || label || 'Research Derived Series';\n\n      const generatedData = actions.generateSegmentation({\n        segmentationId,\n        options: {\n          SeriesDescription,\n        },\n      });\n\n      if (!generatedData || !generatedData.dataset) {\n        throw new Error('Error during segmentation generation');\n      }\n\n      const { dataset: naturalizedReport } = generatedData;\n\n      await dataSource.store.dicom(naturalizedReport);\n\n      // The \"Mode\" route listens for DicomMetadataStore changes\n      // When a new instance is added, it listens and\n      // automatically calls makeDisplaySets\n\n      // add the information for where we stored it to the instance as well\n      naturalizedReport.wadoRoot = dataSource.getConfig().wadoRoot;\n\n      DicomMetadataStore.addInstances([naturalizedReport], true);\n\n      return naturalizedReport;\n    },\n    /**\n     * Converts segmentations into RTSS for download.\n     * This sample function retrieves all segentations and passes to\n     * cornerstone tool adapter to convert to DICOM RTSS format. It then\n     * converts dataset to downloadable blob.\n     *\n     */\n    downloadRTSS: ({ segmentationId }) => {\n      const segmentations = segmentationService.getSegmentation(segmentationId);\n      const vtkUtils = {\n        vtkImageMarchingSquares,\n        vtkDataArray,\n        vtkImageData,\n      };\n\n      const RTSS = generateRTSSFromSegmentations(\n        segmentations,\n        classes.MetadataProvider,\n        DicomMetadataStore,\n        cache,\n        cornerstoneToolsEnums,\n        vtkUtils\n      );\n\n      try {\n        const reportBlob = datasetToBlob(RTSS);\n\n        //Create a URL for the binary.\n        const objectUrl = URL.createObjectURL(reportBlob);\n        window.location.assign(objectUrl);\n      } catch (e) {\n        console.warn(e);\n      }\n    },\n    setBrushSize: ({ value, toolNames }) => {\n      const brushSize = Number(value);\n\n      toolGroupService.getToolGroupIds()?.forEach(toolGroupId => {\n        if (toolNames?.length === 0) {\n          segmentationUtils.setBrushSizeForToolGroup(toolGroupId, brushSize);\n        } else {\n          toolNames?.forEach(toolName => {\n            segmentationUtils.setBrushSizeForToolGroup(toolGroupId, brushSize, toolName);\n          });\n        }\n      });\n    },\n    setThresholdRange: ({\n      value,\n      toolNames = ['ThresholdCircularBrush', 'ThresholdSphereBrush'],\n      toolGroupIds = toolGroupService.getToolGroupIds(),\n    }) => {\n      toolGroupIds?.forEach(toolGroupId => {\n        const toolGroup = toolGroupService.getToolGroup(toolGroupId);\n        if (toolGroup) {\n          toolNames?.forEach(toolName => {\n            toolGroup.setToolConfiguration(toolName, {\n              strategySpecificConfiguration: { THRESHOLD: { threshold: value } },\n            });\n          });\n        }\n      });\n    },\n  };\n\n  const definitions = {\n    getUpdatedViewportsForSegmentation: {\n      commandFn: actions.getUpdatedViewportsForSegmentation,\n    },\n    loadSegmentationDisplaySetsForViewport: {\n      commandFn: actions.loadSegmentationDisplaySetsForViewport,\n    },\n    loadSegmentationsForViewport: {\n      commandFn: actions.loadSegmentationsForViewport,\n    },\n    createEmptySegmentationForViewport: {\n      commandFn: actions.createEmptySegmentationForViewport,\n    },\n    generateSegmentation: {\n      commandFn: actions.generateSegmentation,\n    },\n    downloadSegmentation: {\n      commandFn: actions.downloadSegmentation,\n    },\n    storeSegmentation: {\n      commandFn: actions.storeSegmentation,\n    },\n    downloadRTSS: {\n      commandFn: actions.downloadRTSS,\n    },\n    setBrushSize: {\n      commandFn: actions.setBrushSize,\n    },\n    setThresholdRange: {\n      commandFn: actions.setThresholdRange,\n    },\n  };\n\n  return {\n    actions,\n    definitions,\n    defaultContext: 'SEGMENTATION',\n  };\n};\n\nexport default commandsModule;\n","import { id } from './id';\nimport React from 'react';\n\nimport getSopClassHandlerModule from './getSopClassHandlerModule';\nimport getHangingProtocolModule from './getHangingProtocolModule';\nimport getPanelModule from './getPanelModule';\nimport getCommandsModule from './commandsModule';\nimport { getToolbarModule } from './getToolbarModule';\n\nconst Component = React.lazy(() => {\n  return import(/* webpackPrefetch: true */ './viewports/OHIFCornerstoneSEGViewport');\n});\n\nconst OHIFCornerstoneSEGViewport = props => {\n  return (\n    <React.Suspense fallback={<div>Loading...</div>}>\n      <Component {...props} />\n    </React.Suspense>\n  );\n};\n\n/**\n * You can remove any of the following modules if you don't need them.\n */\nconst extension = {\n  /**\n   * Only required property. Should be a unique value across all extensions.\n   * You ID can be anything you want, but it should be unique.\n   */\n  id,\n  /**\n   * PanelModule should provide a list of panels that will be available in OHIF\n   * for Modes to consume and render. Each panel is defined by a {name,\n   * iconName, iconLabel, label, component} object. Example of a panel module\n   * is the StudyBrowserPanel that is provided by the default extension in OHIF.\n   */\n  getPanelModule,\n  getCommandsModule,\n  getToolbarModule,\n  getViewportModule({ servicesManager, extensionManager, commandsManager }) {\n    const ExtendedOHIFCornerstoneSEGViewport = props => {\n      return (\n        <OHIFCornerstoneSEGViewport\n          servicesManager={servicesManager}\n          extensionManager={extensionManager}\n          commandsManager={commandsManager}\n          {...props}\n        />\n      );\n    };\n\n    return [{ name: 'dicom-seg', component: ExtendedOHIFCornerstoneSEGViewport }];\n  },\n  /**\n   * SopClassHandlerModule should provide a list of sop class handlers that will be\n   * available in OHIF for Modes to consume and use to create displaySets from Series.\n   * Each sop class handler is defined by a { name, sopClassUids, getDisplaySetsFromSeries}.\n   * Examples include the default sop class handler provided by the default extension\n   */\n  getSopClassHandlerModule,\n  getHangingProtocolModule,\n};\n\nexport default extension;\n","export function getToolbarModule({ servicesManager }: withAppTypes) {\n  const { segmentationService, toolbarService, toolGroupService } = servicesManager.services;\n  return [\n    {\n      name: 'evaluate.cornerstone.segmentation',\n      evaluate: ({ viewportId, button, toolNames, disabledText }) => {\n        // Todo: we need to pass in the button section Id since we are kind of\n        // forcing the button to have black background since initially\n        // it is designed for the toolbox not the toolbar on top\n        // we should then branch the buttonSectionId to have different styles\n        const segmentations = segmentationService.getSegmentations();\n        if (!segmentations?.length) {\n          return {\n            disabled: true,\n            className: '!text-common-bright !bg-black opacity-50',\n            disabledText: disabledText ?? 'No segmentations available',\n          };\n        }\n\n        const toolGroup = toolGroupService.getToolGroupForViewport(viewportId);\n\n        if (!toolGroup) {\n          return {\n            disabled: true,\n            className: '!text-common-bright ohif-disabled',\n            disabledText: disabledText ?? 'Not available on the current viewport',\n          };\n        }\n\n        const toolName = toolbarService.getToolNameForButton(button);\n\n        if (!toolGroup.hasTool(toolName) && !toolNames) {\n          return {\n            disabled: true,\n            className: '!text-common-bright ohif-disabled',\n            disabledText: disabledText ?? 'Not available on the current viewport',\n          };\n        }\n\n        const isPrimaryActive = toolNames\n          ? toolNames.includes(toolGroup.getActivePrimaryMouseButtonTool())\n          : toolGroup.getActivePrimaryMouseButtonTool() === toolName;\n\n        return {\n          disabled: false,\n          className: isPrimaryActive\n            ? '!text-black !bg-primary-light hover:bg-primary-light hover-text-black hover:cursor-pointer'\n            : '!text-common-bright !bg-black hover:bg-primary-light hover:cursor-pointer hover:text-black',\n          // Todo: isActive right now is used for nested buttons where the primary\n          // button needs to be fully rounded (vs partial rounded) when active\n          // otherwise it does not have any other use\n          isActive: isPrimaryActive,\n        };\n      },\n    },\n  ];\n}\n","import moment from 'moment';\nimport { metaData } from '@cornerstonejs/core';\n\n/**\n * Checks if value is valid.\n *\n * @param {number} value\n * @returns {boolean} is valid.\n */\nexport function isValidNumber(value) {\n  return typeof value === 'number' && !isNaN(value);\n}\n\n/**\n * Formats number precision.\n *\n * @param {number} number\n * @param {number} precision\n * @returns {number} formatted number.\n */\nexport function formatNumberPrecision(number, precision = 0) {\n  if (number !== null) {\n    return parseFloat(number).toFixed(precision);\n  }\n}\n\n/**\n * Formats DICOM date.\n *\n * @param {string} date\n * @param {string} strFormat\n * @returns {string} formatted date.\n */\nexport function formatDICOMDate(date, strFormat = 'MMM D, YYYY') {\n  return moment(date, 'YYYYMMDD').format(strFormat);\n}\n\n/**\n *    DICOM Time is stored as HHmmss.SSS, where:\n *      HH 24 hour time:\n *        m mm        0..59   Minutes\n *        s ss        0..59   Seconds\n *        S SS SSS    0..999  Fractional seconds\n *\n *        Goal: '24:12:12'\n *\n * @param {*} time\n * @param {string} strFormat\n * @returns {string} formatted name.\n */\nexport function formatDICOMTime(time, strFormat = 'HH:mm:ss') {\n  return moment(time, 'HH:mm:ss').format(strFormat);\n}\n\n/**\n * Formats a patient name for display purposes\n *\n * @param {string} name\n * @returns {string} formatted name.\n */\nexport function formatPN(name) {\n  if (!name) {\n    return '';\n  }\n  if (typeof name === 'object') {\n    name = name.Alphabetic;\n    if (!name) {\n      return '';\n    }\n  }\n\n  const cleaned = name\n    .split('^')\n    .filter(s => !!s)\n    .join(', ')\n    .trim();\n  return cleaned === ',' || cleaned === '' ? '' : cleaned;\n}\n\n/**\n * Gets compression type\n *\n * @param {number} imageId\n * @returns {string} compression type.\n */\nexport function getCompression(imageId) {\n  const generalImageModule = metaData.get('generalImageModule', imageId) || {};\n  const { lossyImageCompression, lossyImageCompressionRatio, lossyImageCompressionMethod } =\n    generalImageModule;\n\n  if (lossyImageCompression === '01' && lossyImageCompressionRatio !== '') {\n    const compressionMethod = lossyImageCompressionMethod || 'Lossy: ';\n    const compressionRatio = formatNumberPrecision(lossyImageCompressionRatio, 2);\n    return compressionMethod + compressionRatio + ' : 1';\n  }\n\n  return 'Lossless / Uncompressed';\n}\n"],"names":["id","packageJson","SOPClassHandlerId","sopClassUids","loadPromises","_getDisplaySetsFromSeries","instances","servicesManager","extensionManager","instance","StudyInstanceUID","SeriesInstanceUID","SOPInstanceUID","SeriesDescription","SeriesNumber","SeriesDate","SOPClassUID","wadoRoot","wadoUri","wadoUriRoot","displaySet","Modality","loading","isReconstructable","displaySetInstanceUID","utils","guid","referencedImages","referencedSeriesInstanceUID","referencedDisplaySetInstanceUID","isDerivedDisplaySet","isLoaded","isHydrated","segments","isOverlayDisplaySet","referencedSeriesSequence","ReferencedSeriesSequence","console","error","referencedSeries","ReferencedInstanceSequence","getReferenceDisplaySet","displaySetService","services","referencedDisplaySets","getDisplaySetsForSeries","length","Error","referencedDisplaySet","referencedVolumeURI","referencedVolumeId","load","async","headers","segDisplaySet","segmentationService","getSegmentation","_segmentationExists","Promise","resolve","reject","Object","keys","utilityModule","getModuleEntry","uiNotificationService","dicomLoaderService","exports","arrayBuffer","findDicomDataPromise","cachedReferencedVolume","cache","getVolume","imageIds","tolerance","skipOverlapping","eventTarget","addEventListener","Enums","Events","SEGMENTATION_LOAD_PROGRESS","evt","percentComplete","detail","_broadcastEvent","EVENTS","SEGMENT_LOADING_COMPLETE","results","adaptersSEG","Cornerstone3D","Segmentation","generateToolState","metaData","triggerEvent","usedRecommendedDisplayCIELabValue","segMetadata","data","forEach","i","cielab","rgba","RecommendedDisplayCIELabValue","dcmjs","Colors","dicomlab2RGB","map","x","Math","round","CONSTANTS","overlappingSegments","show","title","message","type","duration","assign","_loadSegments","suppressEvents","createSegmentationForSEGDisplaySet","then","catch","_load","name","getDisplaySetsFromSeries","segProtocol","protocolMatchingRules","toolGroupIds","numberOfPriorsReferenced","defaultViewport","viewportOptions","viewportType","toolGroupId","allowUnmatchedView","displaySets","matchedDisplaySetsIndex","displaySetSelectors","segDisplaySetId","seriesMatchingRules","attribute","constraint","equals","stages","viewportStructure","layoutType","properties","rows","columns","viewports","protocol","SegmentationPanelMode","uiDialogService","label","callback","dialogId","onSubmitHandler","action","value","dismiss","create","centralize","isDraggable","showOverlay","content","Dialog","contentProps","noCloseButton","onClose","actions","text","ButtonEnums","secondary","primary","onSubmit","body","setValue","React","Input","labelClassName","autoFocus","className","onChange","event","persist","target","onKeyPress","key","rgbaColor","ChromePicker","color","rgb","presetColors","width","hangingProtocolService","toolGroupService","viewportGridService","Button","size","small","onClick","importSegmentationFromFolder","getDisplaySetsUIDsForViewport","input","document","createElement","webkitdirectory","onchange","files","Array","from","configurationFile","filter","binaryFile","file","displaySetUID","getToolGroupForViewport","LABELMAP","Labelmap","reader","FileReader","onload","result","options","split","pop","replace","segId","createSegmentationForDisplaySet","addSegmentationRepresentationToToolGroup","setActiveSegmentationForToolGroup","JSON","parse","segment","segmentIndex","addSegment","override","readAsText","importConfiguration","newScalarData","Uint8Array","segmentationLabel","segmentation","getSegmentations","s","scalarData","getLabelmapVolume","cstSegmentation","readAsArrayBuffer","importBinary","click","getActiveSegmentation","dentascanSegmentations","getDentascanSegmentations","includes","getHiddenSegmentation","segmentsInfo","dimensions","layerSize","nbLayers","zip","JSZip","layerI","pixelData","Uint8ClampedArray","fill","canvas","ctx","getContext","height","imgData","ImageData","colorSpace","putImageData","pngBlob","toBlob","blob","binaryBlob","Blob","jsonBlob","stringify","activeStudyUID","getState","study","DicomMetadataStore","getStudy","StudyDate","PatientName","series","patientNameFormatted","formatPN","generateAsync","saveAs","components","Expanded","SegmentationGroupTableExpanded","Dropdown","SegmentationGroupTable","random","seed","seededRandom","PanelSegmentation","commandsManager","configuration","activeViewportId","useViewportGrid","cornerstoneViewportService","toolbarService","panoramicService","t","useTranslation","addSegmentationClassName","setAddSegmentationClassName","useState","segmentationConfiguration","setSegmentationConfiguration","getConfiguration","isDentascanViewport","viewportId","volume","getViewportInfo","getViewportData","metadata","viewportDentascanIsActive","getActiveViewportId","visibleSegmentations","setVisibleSegmentations","getAxialSegmentations","hiddenSegmentations","setHiddenSegmentations","isMinimized","setIsMinimized","useCallback","prevState","useEffect","lastSegmentationId","added","SEGMENTATION_ADDED","updated","SEGMENTATION_UPDATED","removed","SEGMENTATION_REMOVED","configChanged","SEGMENTATION_CONFIGURATION_CHANGED","subscriptions","unsubscribe","subscribe","push","unsub","handleActiveViewportChange","activeDisplaySetsUIDs","some","getDisplaySetByUID","changedGrid","ACTIVE_VIEWPORT_ID_CHANGED","ready","VIEWPORTS_READY","subsGrid","changedData","VIEWPORT_DATA_CHANGED","subsData","_setSegmentationConfiguration","setConfiguration","SegmentationGroupTableComponent","segmentationPanelMode","allowAddSegment","onSegmentationAddWrapper","onSegmentationAdd","getActiveProtocol","runCommand","viewportIds","getViewportIds","segmentations","segmentationConfig","initialConfig","disableEditing","showAddSegment","showDeleteSegment","onSegmentationEdit","segmentationId","callInputDialog","actionId","addOrUpdateSegmentation","hiddenSegmentation","onSegmentationClick","getToolGroupIdsWithSegmentation","onSegmentationDelete","remove","onSegmentationDownload","onSegmentationDownloadRTSS","storeSegmentation","datasources","getActiveDataSource","displaySetInstanceUIDs","createReportAsync","getReport","dataSource","reportType","setDisplaySetsForViewport","onSegmentClick","setActiveSegment","jumpToSegmentCenter","onSegmentAdd","config","floor","opacity","visibility","isLocked","active","onSegmentDelete","removeSegment","onSegmentEdit","setSegmentLabel","onToggleSegmentationVisibility","toggleSegmentationVisibility","isVisible","setSegmentVisibility","onToggleSegmentVisibility","onToggleSegmentLock","toggleSegmentLocked","onSegmentColorClick","r","g","b","a","callColorPickerDialog","newRgbaColor","setSegmentRGBAColor","setFillAlpha","setFillAlphaInactive","setOutlineWidthActive","setOutlineOpacityActive","setRenderFill","setRenderInactiveSegmentations","setRenderOutline","SegmentationImportExport","propTypes","PropTypes","isRequired","getPanelModule","customizationService","iconName","iconLabel","component","appConfig","useAppConfig","get","Toolbox","buttonSectionId","updateViewportsForSegmentationRendering","loadFn","initialSliceIndex","viewport","getTargetViewport","targetViewportId","updatedViewports","getUpdatedViewportsForSegmentation","createSegmentationForVolume","hydrateSegmentation","volumeExists","_volumeCache","volumeId","needsRerendering","initialImageOptions","index","useOnce","csViewport","getCornerstoneViewport","prevCamera","getCamera","createNewSegmentationWhenVolumeMounts","isTheActiveViewportVolumeMounted","volumeActors","find","ac","uid","volumeViewport","setCamera","element","removeEventListener","VOLUME_VIEWPORT_NEW_VOLUME","setDisplaySetsForViewports","isHangingProtocolLayout","referenceDisplaySetInstanceUID","segmentationFrameOfReferenceUID","FrameOfReferenceUID","getViewportsRequireUpdate","v","shouldRenderSegmentation","segmentationUtils","utilities","datasetToBlob","generateLabelMaps2DFrom3D","generateSegmentation","RTSS","generateRTSSFromSegmentations","adaptersRT","downloadDICOMData","helpers","commandsModule","createEmptySegmentationForViewport","currentSegmentations","loadSegmentationsForViewport","set","activeSegmentIndex","centroidsIJK","setCentroids","loadSegmentationDisplaySetsForViewport","getSliceIndex","serviceFunction","boundFn","bind","description","cornerstoneToolsSegmentation","representationData","segmentationVolume","getCornerstoneImages","labelmapObj","rgb2DICOMLAB","slice","segmentMetadata","SegmentNumber","toString","SegmentLabel","SegmentAlgorithmType","algorithmType","SegmentAlgorithmName","algorithmName","SegmentedPropertyCategoryCodeSequence","CodeValue","CodingSchemeDesignator","CodeMeaning","SegmentedPropertyTypeCodeSequence","downloadSegmentation","segmentationInOHIF","generatedSegmentation","dataset","promptResult","createReportDialogPrompt","generatedData","naturalizedReport","store","dicom","getConfig","addInstances","downloadRTSS","vtkUtils","vtkImageMarchingSquares","vtkDataArray","vtkImageData","classes","MetadataProvider","cornerstoneToolsEnums","reportBlob","objectUrl","URL","createObjectURL","window","location","e","warn","setBrushSize","toolNames","brushSize","Number","getToolGroupIds","setBrushSizeForToolGroup","toolName","setThresholdRange","toolGroup","getToolGroup","setToolConfiguration","strategySpecificConfiguration","THRESHOLD","threshold","definitions","commandFn","defaultContext","Component","OHIFCornerstoneSEGViewport","props","fallback","getCommandsModule","getToolbarModule","evaluate","button","disabledText","disabled","getToolNameForButton","hasTool","isPrimaryActive","getActivePrimaryMouseButtonTool","isActive","getViewportModule","_extends","getSopClassHandlerModule","getHangingProtocolModule","formatNumberPrecision","number","precision","parseFloat","toFixed","formatDICOMDate","date","strFormat","moment","format","formatDICOMTime","time","Alphabetic","cleaned","join","trim"],"sourceRoot":""}