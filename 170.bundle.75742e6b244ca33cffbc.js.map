{"version":3,"file":"170.bundle.75742e6b244ca33cffbc.js","mappings":";mNA0CA,MAAMA,UAAsB,WACZ,KAAAC,oBAAsB,yCAA0C,CAqE9E,WAAAC,CAAYC,GACVC,MAAM,IACDD,EACHE,OAAQF,EAAME,SAAU,QAAkBF,EAAMG,WA/D5C,KAAAC,WAAa,EACb,KAAAC,YAAc,EAEd,KAAAC,MAAO,EACP,KAAAC,MAAO,EACP,KAAAC,WAAY,EACZ,KAAAC,YAAc,EACd,KAAAC,aAAe,EAaf,KAAAC,WAA+B,CAAC,EAAG,GASnC,KAAAC,IAAM,GAKN,KAAAC,YAAmC,CACzCC,SAAU,CAAC,EAAG,GACdC,cAAe,GAmBT,KAAAC,SAAqB,CAC3BC,MAAO,EACPC,MAAO,KA2YF,KAAAC,cAAgB,KACd,CACLb,KAAMc,KAAKC,aAAaf,KACxBgB,MAAOF,KAAKC,aAAaC,MACzBZ,aAAcU,KAAKV,aACnBD,YAAaW,KAAKX,YAClBO,SAAU,IAAKI,KAAKJ,YAsUjB,KAAAO,YAAc,KACnBH,KAAKI,sBAELJ,KAAKK,cAAcC,SAAS,EAAG,EAAGN,KAAKlB,OAAOyB,MAAOP,KAAKlB,OAAO0B,SAE1C,IAAnBR,KAAKZ,WAEPY,KAAKS,eAEA,GAGF,KAAAC,kBAAoB,KACzB,MAAMC,EAAiBC,KAAKC,MACzBb,KAAKC,aAAaa,SAAWd,KAAKR,IAAOQ,KAAKX,aAEjD,OAAO0B,MAAMJ,GAAkBX,KAAKgB,eAAiBL,CAAc,EAG9D,KAAAM,uBAAyB,IAEvBjB,KAAKC,aAAaiB,IAGpB,KAAAC,OAAS,KACd,MAAMrC,EAASkB,KAAKlB,QACd,YAAEsC,EAAW,aAAEC,GAAiBvC,EAGlCA,EAAOyB,QAAUa,GAAetC,EAAO0B,SAAWa,IACpDvC,EAAOyB,MAAQa,EACftC,EAAO0B,OAASa,GAGlBrB,KAAKI,uBAEkB,IAAnBJ,KAAKZ,WAEPY,KAAKS,aACP,EASK,KAAAa,cAAgB,CACrBC,EACAC,EAAkB,CAAC,EAAG,EAAG,MAEzB,MAAMC,EAAczB,KAAKP,YAAYC,SAC/BgC,EAA6B1B,KAAK2B,wBAElCC,EAA0B,CAC9BH,EAAI,GAAKC,EACTD,EAAI,GAAKC,GAGLG,EAAuB,CAC3BN,EAAU,GAAKK,EAAgB,GAC/BL,EAAU,GAAKK,EAAgB,IAWjC,OANAJ,EAAQM,OACN,EACA,EACAD,EAAa,GAAKH,EAClBG,EAAa,GAAKH,GAEbF,CAAO,EAST,KAAAO,cAAiBC,IACtB,MAAMP,EAAczB,KAAKP,YAAYC,SAC/BgC,EAA6B1B,KAAK2B,wBAOxC,MAL0B,EACvBK,EAAS,GAAKP,EAAI,IAAMC,GACxBM,EAAS,GAAKP,EAAI,IAAMC,EAGX,EAQX,KAAAO,YAAc,IAAM,EAKjB,KAAAC,cAAiBX,IACzB,MAAMY,EAAYnC,KAAKoC,eAGvB,OAFAD,EAAUE,SAEHF,EAAUG,eACPf,EAAUgB,KAAKC,GAAOA,EAAKC,mBACpC,EAGO,KAAAC,cAAiBC,GACP3C,KAAKoC,eAEXE,eAAeK,GAAUJ,KAAKC,GAAOA,EAAKC,mBA2CjD,KAAAG,6BAA+B,KACpC5C,KAAKS,aAAa,EAwEZ,KAAAA,YAAc,KACpB,MACMoC,EADY7C,KAAKoC,eAC0BU,YAE3CC,EAAM/C,KAAKK,cAEjB0C,EAAIC,iBAGJD,EAAIZ,UACFU,EAAqB,GACrBA,EAAqB,GACrBA,EAAqB,GACrBA,EAAqB,GACrBA,EAAqB,GACrBA,EAAqB,IAGvBE,EAAIE,UACFjD,KAAKC,aACL,EACA,EACAD,KAAKhB,YAAc,KACnBgB,KAAKf,aAAe,MAGtB,IAAK,MAAMiE,KAASlD,KAAKmD,YACtBD,EAAMA,MAAuBE,OAAOpD,KAAMA,KAAKK,eAElDL,KAAKK,cAAc2C,kBAGnB,IAAAK,cAAarD,KAAKjB,QAAS,SAAOuE,gBAAiB,CACjDvE,QAASiB,KAAKjB,QACdwE,WAAYvD,KAAKwD,GACjBC,SAAUzD,KACV0D,kBAAmB1D,KAAK0D,kBACxBC,KAAM3D,KAAKC,aAAa2D,YACxB9C,SAAUd,KAAKC,aAAaa,YAE9B,IAAAuC,cAAarD,KAAKjB,QAAS,SAAO8E,eAAgB,CAChD9E,QAASiB,KAAKjB,QACdwE,WAAYvD,KAAKwD,GACjBC,SAAUzD,KACV0D,kBAAmB1D,KAAK0D,kBACxBC,KAAM3D,KAAKC,aAAa2D,YACxB9C,SAAUd,KAAKC,aAAaa,WAG9Bd,KAAK8D,kBAEL,MAAMC,EAAQ/D,KAAKgE,iBACfhE,KAAKZ,YACH2E,EAAQ/D,KAAKT,WAAW,GAC1BS,KAAKiE,eAAejE,KAAKT,WAAW,IAC3BwE,EAAQ/D,KAAKT,WAAW,KAC7BS,KAAKd,KACPc,KAAKiE,eAAejE,KAAKT,WAAW,IAEpCS,KAAKkE,SAGX,EAGM,KAAAC,oBAAsB,KAC5BnE,KAAKS,cAGDT,KAAKZ,WACPgF,sBAAsBpE,KAAKmE,oBAC7B,EA9/BAnE,KAAKK,cAAgBL,KAAKlB,OAAOuF,WAAW,MAC5CrE,KAAK0D,kBAAoB9E,EAAM8E,kBAE/B1D,KAAKjB,QAAQuF,aAAa,oBAAqBtE,KAAKwD,IACpDxD,KAAKjB,QAAQuF,aACX,4BACAtE,KAAK0D,mBAGP1D,KAAKC,aAAesE,SAASC,cAAc,SAC3CxE,KAAKC,aAAaC,MAAQF,KAAKb,KAC/Ba,KAAKC,aAAaf,KAAOc,KAAKd,KAC9Bc,KAAKC,aAAawE,UAAW,EAC7BzE,KAAKC,aAAayE,YAAc,YAEhC1E,KAAK2E,oBACL3E,KAAKmB,QACP,CAEO,qCAAWyD,GAChB,OAAO,CACT,CAEQ,iBAAAD,GACN3E,KAAKlB,OAAO+F,iBACV,SAAOC,iBACP9E,KAAK+E,uBAET,CAEQ,oBAAAC,GACNhF,KAAKlB,OAAOmG,oBACV,SAAOH,iBACP9E,KAAK+E,uBAET,CAEQ,sBAAAA,GACN/E,KAAKgF,uBACLhF,KAAKC,aAAaiF,QACpB,CAEO,oBAAAC,CAAqBC,GAC1B,MAAMC,EAA2B,iBAAVD,EAAqBA,EAAQA,EAAMC,QACpDC,EAAmB,MAAa,EAAAC,gBAAgBC,YAAaH,GAEnE,IAAII,EAAqBH,EAAiBG,WACtCC,EAAwBJ,EAAiBI,cAG3B,MAAdD,GAAuC,MAAjBC,IACxBD,EAAqB,CAAC,EAAG,EAAG,GAC5BC,EAAwB,CAAC,EAAG,EAAG,IAGjC,MAAMC,EAAe,gBACnBF,EAAW,GACXA,EAAW,GACXA,EAAW,IAEPG,EAAe,gBACnBF,EAAc,GACdA,EAAc,GACdA,EAAc,KAGV,KAAEG,EAAI,QAAEC,GAAYR,EACpBS,EAAiB,cACvB,WAAWA,EAAgBJ,EAAcC,GAEzC,IAAII,EAASV,EAAiBW,qBAEhB,MAAVD,IACFA,EAAS,CAAC,EAAG,EAAG,IAGlB,MAAME,EAAWZ,EAAiBa,oBAAsB,EAClDC,EAAWd,EAAiBe,iBAAmB,EAC/CC,EAAUhB,EAAiBQ,QAC3BS,EAAUjB,EAAiBO,KAMjC,OADA7F,KAAKwG,kBAAoBlB,EAAiBa,mBACnC,CACLM,cAAe,EACfC,SAAU,EACVV,SACAH,OACAC,UACAa,UAAW,IAAIhB,KAAiBC,KAAiBG,GACjDa,WAAY,CAACN,EAASC,EAVR,GAWdM,QAAS,CAACX,EAAUE,EAZL,GAafI,gBAAiBxG,KAAKwG,gBACtBM,UAAWR,EAAUC,EAbP,EAcdjB,mBAEJ,CAQO,UAAAyB,CAAWC,EAAoBC,GACpCjH,KAAKkH,SACHF,EAAS,GACRC,GAASE,eAAeC,YAAyB,EAEtD,CAOO,QAAAF,CAAS7B,EAAiBgC,GAC/BrH,KAAKqF,QAAUiC,MAAMC,QAAQlC,GAAWA,EAAQ,GAAKA,EACrD,MAAMmC,EAAiB,MAAa,EAAAjC,gBAAgBkC,UAAWpC,GAC/D,IAAKmC,GAAgBE,SACnB,MAAM,IAAIC,MACR,kBAAkBtC,yCAGtB,MAAM,SAAEqC,GAAaF,EACfI,EAAgB,MAAa,EAAArC,gBAAgBsC,eAAgBxC,GACnErF,KAAK8H,SAAWF,GAAeG,SAC/B/H,KAAKgI,SAAWhI,KAAKmF,qBAAqBE,GAC1C,IAAI,SAAE4C,EAAQ,eAAEjH,GAAmB,MACjC,EAAAuE,gBAAgB2C,KAChB7C,GAIF,OAFArF,KAAKgB,eAAiBA,EAEfhB,KAAKmI,YAAYT,GAAUU,MAAK,KAChCpH,GAAqC,IAAnBA,IACrBA,EAAiBJ,KAAKC,MACpBb,KAAKC,aAAaa,UAAYmH,GAAY,MAGzCA,IACHA,EAAWrH,KAAKC,MAAMG,EAAiBhB,KAAKC,aAAaa,WAE3Dd,KAAKR,IAAMyI,EACXjI,KAAKgB,eAAiBA,EAEtBhB,KAAKqI,cAAc,CAAC,EAAGrH,IAGvBhB,KAAK8D,cAAgB,KACnB9D,KAAK8D,cAAgB,KACrB9D,KAAKkE,QACLlE,KAAKiE,eAAeoD,GAAe,EAAE,EAMhC,IAAIiB,SAASC,IAClBC,OAAOC,YAAW,KAChBzI,KAAKiE,eAAeoD,GAAe,GACnCkB,EAAQvI,KAAK,GACZ,GAAG,MAGZ,CAEO,iBAAMmI,CAAYO,GACvB,OAAO,IAAIJ,SAASC,IAClBvI,KAAKC,aAAaiB,IAAMwH,EACxB1I,KAAKC,aAAa0I,QAAU,OAE5B,MAAMC,EAA6B,KACjC5I,KAAKhB,WAAagB,KAAKC,aAAajB,WACpCgB,KAAKf,YAAce,KAAKC,aAAahB,YACrCe,KAAKC,aAAagF,oBAChB,iBACA2D,GAGF5I,KAAKI,sBAELmI,GAAQ,EAAK,EAGfvI,KAAKC,aAAa4E,iBAChB,iBACA+D,EACD,GAEL,CAMO,WAAAC,GACL,MAAM7B,EAAW,IAAIM,MAActH,KAAKgB,gBAClC8H,EAAc9I,KAAKqF,QAAQ0D,QAAQ,UAAW,IACpD,IAAK,IAAIC,EAAI,EAAGA,EAAIhJ,KAAKgB,eAAgBgI,IACvChC,EAASgC,GAAK,GAAGF,IAAcE,EAAI,IAErC,OAAOhC,CACT,CAEO,eAAAiC,GACL,OAAIjJ,KAAKZ,WACPY,KAAKkE,SACE,IAEPlE,KAAKkJ,QACE,EAEX,CAEO,UAAMA,GACX,IACOlJ,KAAKZ,kBAEFY,KAAKC,aAAaiJ,OACxBlJ,KAAKZ,WAAY,EACjBY,KAAKmE,sBAET,CAAE,MAAOgF,GAGT,CACF,CAEO,WAAMjF,GACX,UACQlE,KAAKC,aAAaiE,QACxBlE,KAAKZ,WAAY,CACnB,CAAE,MAAO+J,GAET,CACF,CAEO,YAAMC,CAAOC,EAAQ,SACpBrJ,KAAKkE,QAEX,MAAMjE,EAAeD,KAAKC,aACpBQ,EAAcT,KAAKS,YAGnB6I,EADcrJ,EAAa2D,YACFyF,EAAQrJ,KAAKX,YAAeW,KAAKR,IAEhES,EAAa2D,YAAc0F,EAG3B,MAAMC,EAAqBC,IACzB/I,IAEAR,EAAagF,oBAAoB,SAAUsE,EAAkB,EAG/DtJ,EAAa4E,iBAAiB,SAAU0E,EAC1C,CAEO,WAAME,GACX,MAAMxJ,EAAeD,KAAKC,aACpBQ,EAAcT,KAAKS,YAIzB,GAFAR,EAAa2D,YAAc,EAEvB3D,EAAayJ,OAAQ,CAEvB,MAAMH,EAAqBC,IACzB/I,IAEAR,EAAagF,oBAAoB,SAAUsE,EAAkB,EAG/DtJ,EAAa4E,iBAAiB,SAAU0E,EAC1C,CACF,CAEO,SAAMI,GACX,MAAM1J,EAAeD,KAAKC,aACpBQ,EAAcT,KAAKS,YAIzB,GAFAR,EAAa2D,YAAc3D,EAAaa,SAEpCb,EAAayJ,OAAQ,CAEvB,MAAMH,EAAqBC,IACzB/I,IAEAR,EAAagF,oBAAoB,SAAUsE,EAAkB,EAG/DtJ,EAAa4E,iBAAiB,SAAU0E,EAC1C,CACF,CAEO,aAAMK,CAAQC,GACnB,MAAM5J,EAAeD,KAAKC,aACpBQ,EAAcT,KAAKS,YAIzB,GAFAR,EAAa2D,YAAciG,EAEvB5J,EAAayJ,OAAQ,CAEvB,MAAMH,EAAqBC,IACzB/I,IAEAR,EAAagF,oBAAoB,SAAUsE,EAAkB,EAG/DtJ,EAAa4E,iBAAiB,SAAU0E,EAC1C,CACF,CAGO,oBAAMtF,CAAeF,GAC1B/D,KAAK4J,SAAS7F,EAAQ,GAAK/D,KAAKR,IAClC,CAQO,aAAA6I,CAAc9I,GACdA,EAIqB,IAAtBA,EAAWuK,QAAgBvK,EAAW,KAAOA,EAAW,KAG5DS,KAAKT,WAAa,CAACA,EAAW,GAAIA,EAAW,KAN3CS,KAAKT,WAAa,CAAC,EAAGS,KAAKgB,eAO/B,CAEO,aAAA+I,GACL,OAAO/J,KAAKT,UACd,CAEO,aAAAyK,CAAcpL,QACAqL,IAAfrL,EAAMM,OACRc,KAAKC,aAAaf,KAAON,EAAMM,WAGb+K,IAAhBrL,EAAMsB,QACRF,KAAKC,aAAaC,MAAQtB,EAAMsB,YAGP+J,IAAvBrL,EAAMU,cACRU,KAAKkK,gBAAgBtL,EAAMU,mBAGH2K,IAAtBrL,EAAMS,aACRW,KAAKmK,eAAevL,EAAMS,aAGxBT,EAAMgB,UACRI,KAAKoK,OAAOxL,EAAMgB,SAEtB,CAEO,eAAAsK,CAAgBG,EAAO,GAC5BrK,KAAKV,aAAe+K,EAEhBA,EAAO,MACTrK,KAAKkE,QAGFlE,KAAKC,eAGVD,KAAKC,aAAaX,aAAe+K,EACjCrK,KAAKkJ,OACP,CAEO,cAAAiB,CACL9K,EAAc,EACdiL,EAAO,uBAA4BC,OAEnCvK,KAAKX,YACHiL,IAAS,uBAA4BE,OACjCnL,EAAcW,KAAKR,IACnBH,CACR,CAYO,eAAAoL,GACLzK,KAAKgK,cAAc,CACjB9K,MAAM,EACNgB,OAAO,GAEX,CAEU,aAAAwK,GACR,GAAI1K,KAAK2K,YAAYtD,cAAgBrH,KAAKgE,iBACxC,OAAOhE,KAAK2K,WAEd,MAAM7L,EAASyF,SAASC,cAAc,UACtC1F,EAAOyB,MAAQP,KAAKhB,WACpBF,EAAO0B,OAASR,KAAKf,YACrB,MAAM2L,EAAU9L,EAAOuF,WAAW,MAClCuG,EAAQ3H,UAAUjD,KAAKC,aAAc,EAAG,GACxC,MAMM0K,EANaC,EAAQC,aACzB,EACA,EACA7K,KAAKhB,WACLgB,KAAKf,aAEuB6L,KAI9B,OAHAH,EAAWI,SAAW,IAAM,CAAC,EAAG,KAChCJ,EAAWtD,YAAcrH,KAAKgE,iBAC9BhE,KAAK2K,WAAaA,EACXA,CACT,CAEO,YAAAE,GACL,MAAM,SAAE7C,GAAahI,KAEf6G,EAAUmB,EAASnB,QAEnBmE,EAAY,CAChBpE,WAAYoB,EAASpB,WACrBC,UACAb,OAAQgC,EAAShC,OACjBW,UAAWqB,EAASrB,UACpBqB,SAAU,CAAED,SAAU/H,KAAK8H,UAC3B4C,cAAe,IAAM1K,KAAK0K,gBAC1BM,UAAW,CACTC,aAAc,IAAMjD,EAASrB,UAC7BuE,cAAe,IAAMlD,EAASpB,WAC9BmE,SAAU,IAAM,CAAC,EAAG,KACpBL,cAAe,IAAM1K,KAAK0K,gBAC1BS,WAAY,IAAMnD,EAASnB,QAC3BuE,aAAeC,IACb,MAAMC,EAActL,KAAK+B,cAAcsJ,GACjCE,EAAavL,KAAKkC,cAAcoJ,GACtC,MAAO,CAACC,EAAW,GAAIA,EAAW,GAAI,EAAE,EAE1CC,aAAc,CAACH,EAAeI,KAC5B,MAAMH,EAActL,KAAK0C,cAAc,CAAC2I,EAAM,GAAIA,EAAM,KACxD,OAAOrL,KAAKsB,cAAcgK,EAAaG,EAAU,GAGrDjF,gBAAiBxG,KAAKwG,gBACtBkF,YAAa1L,KAAK0L,YAClBC,SAAU,CACRC,QAAQ,IAOZ,OAJAC,OAAOC,eAAed,EAAW,aAAc,CAC7Ce,IAAK,IAAM/L,KAAK0K,gBAChBsB,YAAY,IAEPhB,CACT,CAmBO,WAAAiB,CAAYC,GAEjB,MAAMC,EAAcD,EAASE,MAAM3N,EAAcC,qBAC3C2N,EAAUF,EACZD,EAASI,UAAU,EAAGH,EAAYI,OAClCL,EACJ,OAA0C,IAAnClM,KAAKqF,QAAQmH,QAAQH,EAC9B,CAEO,MAAAjC,CAAOxK,GACZI,KAAKJ,SAAWA,EAChBI,KAAKyM,mBACP,CAEO,cAAAC,CAAeC,EAAc,IAAKC,EAAe,KACtD,MAAM/M,EAAQ+M,EAAeD,EAAc,EACrC7M,EAAQ8M,EAAeD,EAAc,EAAI,EAC/C3M,KAAKoK,OAAO,CAAEvK,QAAOC,UACrBE,KAAKyM,mBACP,CAEO,eAAAI,CAAgBC,GACrB9M,KAAK8M,aAAeA,EACpB9M,KAAKyM,mBACP,CAEU,iBAAAA,GACR,IAAKzM,KAAKJ,WAAaI,KAAK8M,aAE1B,YADA9M,KAAK+M,SAAW,MAGlB,MAAMC,EAAQhN,KAAK8M,cAAgB,CAAC,IAAK,IAAK,KACxCG,EAAWrM,KAAKsM,OAAOF,GACvBG,EAAaH,EAAMzK,KAAK6K,GAAMH,EAAWG,KACzC,MAAEvN,EAAQ,EAAC,MAAEC,EAAQ,KAAQE,KAAKJ,UAAY,CAAC,EAC/CyN,GAAWvN,EAAQD,EAAQ,GAAK,IAChCyN,EAAUzN,EAAQ,IACxBG,KAAK+M,SAAW,4MAKRI,EAAW,GAAKE,WAAiBC,iBAC/BH,EAAW,GAAKE,SAAeC,mBAC7BH,EAAW,GAAKE,OAAaC,kEAKzCtN,KAAKlB,OAAOyO,MAAMC,OAASxN,KAAK+M,QAClC,CAEO,SAAAU,CAAUC,GACf,MAAM,cAAE/N,EAAa,WAAEgO,GAAeD,EAStC,GALI/N,IACFK,KAAKP,YAAYE,cACfK,KAAKjB,QAAQsC,aAAe,EAAI1B,QAGjBsK,IAAf0D,EAA0B,CAC5B,MAAMC,EAAmB5N,KAAK+B,cAAc4L,GACtCE,EAAuB,CAC3B7N,KAAKjB,QAAQqC,YAAc,EAC3BpB,KAAKjB,QAAQsC,aAAe,GAGxByM,EAAwB,EAC3BF,EAAiB,GAAKC,EAAa,IAClC7N,KAAKP,YAAYE,eAClBiO,EAAiB,GAAKC,EAAa,IAClC7N,KAAKP,YAAYE,eAGrBK,KAAKP,YAAYC,SAAW,CAC1BM,KAAKP,YAAYC,SAAS,GAAKoO,EAAc,GAC7C9N,KAAKP,YAAYC,SAAS,GAAKoO,EAAc,GAEjD,CAEA9N,KAAKK,cAAc0N,UAAY,gBAC/B/N,KAAKK,cAAcC,SAAS,EAAG,EAAGN,KAAKlB,OAAOyB,MAAOP,KAAKlB,OAAO0B,SAE1C,IAAnBR,KAAKZ,WACPY,KAAKS,aAET,CAcO,iBAAAuN,GAOL,OANgBhO,KAAKqF,QAAQ0D,QAC3B,YACA/I,KAAKZ,UACD,WAAWY,KAAKT,WAAW,MAAMS,KAAKT,WAAW,KACjD,WAAWS,KAAKgE,mBAGxB,CAKO,cAAAiK,CAAeC,EAAoC,CAAC,GACzD,MAAQ9G,WAAYA,GAAe8G,EACnC,QAAmBjE,IAAf7C,EACF,MAAO,WAAWpH,KAAKgO,sBAEzB,GAAI1G,MAAMC,QAAQH,GAEhB,MAAO,WAAWpH,KAAKqF,QAAQiH,UAAU,EAAGtM,KAAKqF,QAAQyE,OAAS,KAChE1C,EAAW,GAAK,KACdA,EAAW,GAAK,IAMtB,MAAO,WAJYpH,KAAKqF,QAAQ0D,QAC9B,YACA,WAAW,EAAI3B,MAGnB,CAKO,mBAAA+G,CACLC,EACAnH,EAAsC,CAAC,GAEvC,IAAI,SAAEiF,GAAajF,EACnB,MAAM,kBAAEoH,EAAmBjH,WAAYA,GAAegH,EACtD,IAAKvP,MAAMsP,oBAAoBC,GAC7B,OAAO,EAGT,MAAM/I,EAAUrF,KAAKgO,oBACrB,IAAK9B,EAAU,CAGb,MAAMoC,EAAajJ,EAAQmH,QAAQ,KACnCN,EAAW7G,EAAQiH,UAAUgC,EAAa,EAAGjJ,EAAQyE,OAAS,EAChE,CAEA,GAAI7C,EAAQsH,eACV,OAAO,EAET,MAAMC,EAAexO,KAAKyO,gBAC1B,GAAInH,MAAMC,QAAQH,GAChB,OAAOoH,GAAgBpH,EAAW,IAAMoH,GAAgBpH,EAAW,GAErE,QAAmB6C,IAAf7C,EACF,OAAOoH,IAAiBpH,EAE1B,IAAKiH,EACH,OAAO,EAET,MAAMjC,EAAQiC,EAAkBjC,MAAM3N,EAAcC,qBACpD,IAAK0N,IAAUA,EAAM,GACnB,OAAO,EAET,MAAMsC,EAAQtC,EAAM,GAAGuC,MAAM,KAAKpM,KAAKC,GAAOoM,OAAOpM,KAC/CuB,EAAQyK,EAAe,EAC7B,OAAOE,EAAM,IAAM3K,GAASA,IAAU2K,EAAM,IAAMA,EAAM,GAC1D,CAMO,gBAAAG,CACLC,GAEA,IAAI1H,EAAa0H,GAAkB1H,WAMnC,OALKA,IACHA,EAAapH,KAAKZ,UACd,CAACY,KAAKT,WAAW,GAAK,EAAGS,KAAKT,WAAW,GAAK,GAC9CS,KAAK+O,0BAEJ,IACFlQ,MAAMgQ,iBAAiBC,GAC1BT,kBAAmBrO,KAAKiO,eAAea,GACvC1H,WAAYA,EAEhB,CAKO,cAAApD,GAEL,OAAO,EAAIhE,KAAK+O,wBAClB,CAEO,sBAAAA,GACL,OAAOnO,KAAKC,MAAMb,KAAKC,aAAa2D,YAAc5D,KAAKR,IACzD,CAEO,aAAAiP,GACL,OAAOzO,KAAK+O,wBACd,CAEO,SAAAC,GACL,MAAM,cAAErP,GAAkBK,KAAKP,YAEzBoO,EAAuB,CAC3B7N,KAAKjB,QAAQqC,YAAc,EAC3BpB,KAAKjB,QAAQsC,aAAe,GAQ9B,MAAO,CACL4N,oBAAoB,EACpBtB,WAJwB3N,KAAKsB,cAAcuM,GAK3CqB,SAAU,CAAC,EAAG,EAAG,GACjBC,OAAQ,CAAC,GAAI,EAAG,GAChBxP,cAAeK,KAAKjB,QAAQsC,aAAe,EAAI1B,EAC/CyP,gBAAiB,CAAC,EAAG,EAAG,GAE5B,CAgGO,MAAAC,GACL,MAAM3P,EAAWM,KAAKP,YAAYC,SAClC,MAAO,CAACA,EAAS,GAAIA,EAAS,GAChC,CA2BQ,mBAAAU,GAGN,IAAIsB,EAAqB1B,KAAKlB,OAAOwQ,YAActP,KAAKhB,WAEpDgB,KAAKf,YAAcyC,EAAqB1B,KAAKlB,OAAO0B,SAGtDkB,EAAqB1B,KAAKlB,OAAOyQ,aAAevP,KAAKf,aAKvD,MAAMuQ,EAAY5O,KAAK6O,MAAMzP,KAAKhB,WAAa0C,GACzCgO,EAAa9O,KAAK6O,MAAMzP,KAAKf,YAAcyC,GAM3CiO,GAHiB3P,KAAKlB,OAAOwQ,YAAcE,GAAa,EAGzB9N,EAC/BkO,GAHiB5P,KAAKlB,OAAOyQ,aAAeG,GAAc,EAG3BhO,EAErC1B,KAAKP,YAAYC,SAAW,CAACiQ,EAAcC,GAC3C5P,KAAKP,YAAYE,cAAgB+B,CACnC,CAEQ,qBAAAC,GACN,OAAO3B,KAAKP,YAAYE,aAC1B,CAEQ,qBAAAkQ,GACN,OAAO,EAAM7P,KAAKP,YAAYE,aAChC,CASU,YAAAyC,GACR,MAAM1C,EAAmBM,KAAKP,YAAYC,SACpC+C,EAAmB+F,OAAO/F,kBAAoB,EAC9Cf,EAA6B1B,KAAK2B,wBAClCmO,EAA6B9P,KAAK6P,wBAClCE,EAAa,CACjB/P,KAAKlB,OAAOwQ,YAAc,EAC1BtP,KAAKlB,OAAOyQ,aAAe,GAEvBS,EAA6B,CACjCD,EAAW,GAAKD,EAChBC,EAAW,GAAKD,GAEZ3N,EAAY,IAAI,IAoBtB,OAjBAA,EAAU8N,MAAMxN,EAAkBA,GAIlCN,EAAU+N,UAAUH,EAAW,GAAIA,EAAW,IAG9C5N,EAAU8N,MAAMvO,EAAoBA,GAGpCS,EAAU+N,UAAUxQ,EAAS,GAAIA,EAAS,IAG1CyC,EAAU+N,WACPF,EAA2B,IAC3BA,EAA2B,IAEvB7N,CACT,CAKO,kCAAAgO,GAEP,CAEO,SAAAC,CAAUC,GACf,MAAMC,EAAStQ,KAAKmD,YACpBkN,EAAYE,SAASC,IACnB,MAAMpL,EAAQ,KAAMqL,SAASD,EAAWnL,SAElCqL,EAAa1Q,KAAK2Q,kBAAkBvL,GACtCsL,IACFJ,EAAOM,KAAK,CAAEC,IAAKL,EAAWM,SAAU5N,MAAOwN,IAC3CF,EAAWO,UACbP,EAAWO,SAAS,CAAEL,aAAYrL,QAASmL,EAAWnL,UAE1D,IAEFrF,KAAKgR,UAAUV,EACjB,CAEU,iBAAAK,CAAkBvL,GAC1B,OAAO,IAAI,IAAYpF,KAAMoF,EAC/B,EAgFF,4CCrkCA,QAhCA6L,eACEC,EACAb,EACAc,GAGA,IAAK,MAAM5N,KAAc4N,EAAa,CACpC,MAAM1N,EAAWyN,EAAgBE,YAAY7N,GAE7C,IAAKE,EACH,MAAM,IAAIkE,MAAM,oBAAoBpE,oBAItC,IAAME,EAA4B2M,UAKhC,YAJAiB,QAAQC,KACN,oBAAoB/N,6EAK1B,CAEA,MAAMgO,EAAmBJ,EAAY5O,KAAI0O,MAAO1N,GAC7B2N,EAAgBE,YAAY7N,GAE7B6M,UAAUC,WAGtB/H,QAAQkJ,IAAID,EACpB,mDCMA,QAnCAN,eACEC,EACAO,EACAN,EACAO,GAAkB,EAClBC,GAAiB,GAGjB,IAAK,MAAMpO,KAAc4N,EAAa,CACpC,MAAM1N,EAAWyN,EAAgBE,YAAY7N,GAE7C,IAAKE,EACH,MAAM,IAAIkE,MAAM,oBAAoBpE,oBAItC,KAAME,aAAoB,KAKxB,YAJA4N,QAAQC,KACN,oBAAoB/N,qEAK1B,CAEA,MAAMqO,EAAoBT,EAAY5O,KAAI0O,MAAO1N,IAC/C,MAAME,EAAWyN,EAAgBE,YAAY7N,SAEvCE,EAASoO,WAAWJ,EAAcC,EAAiBC,EAAe,UAGpErJ,QAAQkJ,IAAII,EAEpB,0EC5CA,MAAME,EAA4B,CAAC,EAAG,EAAG,EAAG,GAoC5C,SAASC,EAAQC,EAAOC,GACtB,IAAIC,EAAO,EACPC,EAAQH,EAAMlI,OAAS,EAE3B,KAAOoI,GAAQC,GAAO,CACpB,MAAMC,EAAMF,EAAOtR,KAAK6O,OAAO0C,EAAQD,GAAQ,GACzCG,EAAUL,EAAMI,GAEtB,GAAIC,IAAYJ,EACd,OAAOG,EACEH,EAAOI,EAChBF,EAAQC,EAAM,EAEdF,EAAOE,EAAM,CAEjB,CAEA,OAAOF,CACT,CA4CA,SAASI,EAAiBC,EAAGzH,EAAM0H,GACjC,IAAIxJ,EACJ,MAAMyJ,EAAI,GACJC,EAAK,GACLC,EAAK,GACLC,EAAM,GAIZ,IAFAJ,EAAkB,OAAVA,EAAiB,EAAIA,EAExBxJ,EAAI,EAAGA,EAAI8B,EAAKhB,OAAQd,IAAK,CAChC,MAAMjK,EAAU+L,EAAK9B,GAErByJ,EAAE7B,MAAM2B,EAAI,GAAKxT,EAAQ,IACzB2T,EAAG9B,KAAK7R,EAAQ,IAChB4T,EAAG/B,KAAK7R,EAAQ,GAClB,CAEA,MAAM8T,EAxGR,SAAkBC,EAAWC,EAAWC,GAGtC,MAAMC,GAAaF,EAAID,KAFvBE,EAAU,OAANA,EAAa,IAAMA,GAEU,GAC3BE,EAAS,GAEf,KAAOF,KAAM,GACXE,EAAOtC,KAAKkC,GACZA,GAAKG,EAOP,OAFAC,EAAOA,EAAOpJ,OAAS,GAAKiJ,EAErBG,CACT,CAwFoBC,CAAS,EAAG,EAAGZ,GAEjC,IAAKvJ,EAAI,EAAGA,EAAIuJ,EAAGvJ,IACjB6J,EAAU7J,IAAMuJ,EAAI,GAAK3R,KAAKwS,IAAIP,EAAU7J,GAAIwJ,GAGlD,MAAMa,EAxDR,SAAsBC,EAAYC,GAChC,IAAIvK,EACJ,MAAMwK,EAAU,GACVC,EAAMF,EAAOzJ,OAMnB,IAJAwJ,EAAWI,MAAK,SAAUZ,EAAGC,GAC3B,OAAOD,EAAIC,CACb,IAEK/J,EAAI,EAAGA,EAAIyK,EAAKzK,IACnBwK,EAAQxK,GAAK+I,EAAQuB,EAAYC,EAAOvK,IAG1C,OAAOwK,CACT,CA0C2BG,CAAalB,EAAGI,GAEzC,IAAK7J,EAAI,EAAGA,EAAIuJ,EAAI,EAAGvJ,IAAK,CAC1B,MAAMuD,EAAQ8G,EAAiBrK,GACzB4K,GACHf,EAAU7J,GAAKyJ,EAAElG,EAAQ,KAAOkG,EAAElG,GAASkG,EAAElG,EAAQ,IAClDsH,EAAanB,EAAGnG,GAASoG,EAAGpG,EAAQ,GAE1CqG,EAAI5J,GAAK4K,EAAeC,EAAalB,EAAGpG,EAAQ,EAClD,CAKA,OAHAqG,EAAI,GAAKD,EAAG,GACZC,EAAIL,EAAI,GAAKG,EAAG5H,EAAKhB,OAAS,GAEvB8I,CACT,CAkFO,SAASkB,EACdtQ,EACAuQ,GAEA,IAAIC,EAAW,IAAcxQ,GAExBwQ,IACHA,EAAW,IAAcxQ,GAAMuQ,GAAgB,CAC7CE,KAAM,GACNC,OAAQ,MAIPF,EAASE,QAAUF,EAASG,gBAC/BH,EAASE,OAhFb,SAAuCC,EAAe5B,EAAGC,GACvD,IAAIxJ,EACJ,MAAM4J,EAAM,GAGZJ,EAAkB,OAAVA,EAAiB,EAAIA,EAE7B,MAAM4B,EAAS9B,EAHfC,EAAU,OAANA,EAAa,IAAMA,EAGY4B,EAAcE,IAAK7B,GAChD8B,EAAWhC,EAAiBC,EAAG4B,EAAcI,MAAO/B,GACpDgC,EAAUlC,EAAiBC,EAAG4B,EAAcM,KAAMjC,GAExD,IAAKxJ,EAAI,EAAGA,EAAIuJ,EAAGvJ,IAAK,CACtB,MAGM0L,EAAO,CAHD9T,KAAKC,MAAkB,IAAZuT,EAAOpL,IAChBpI,KAAKC,MAAoB,IAAdyT,EAAStL,IACrBpI,KAAKC,MAAmB,IAAb2T,EAAQxL,IACA,KAEhC4J,EAAIhC,KAAK8D,EACX,CAEA,OAAO9B,CACT,CA2DsB+B,CAChBX,EAASG,cACTH,EAASY,UACTZ,EAASxB,QAkGb,MA9FiD,CAC/CqC,MAAK,IACIrR,EAGTsR,mBAAkB,IACTd,EAASC,KAGlB,kBAAAc,CAAmBd,GACjBD,EAASC,KAAOA,CAClB,EAEAe,kBAAiB,IACRhB,EAASE,OAAOpK,OAGzB,iBAAAmL,CAAkBL,GAChB,KAAOZ,EAASE,OAAOpK,OAAS8K,GAC9BZ,EAASE,OAAOtD,KAAKkB,GAGvBkC,EAASE,OAAOpK,OAAS8K,CAC3B,EAEA,QAAAM,CAAS3I,GACP,OAAIvM,KAAKmV,aAAa5I,GACbyH,EAASE,OAAO3H,GAGlBuF,CACT,EAEA,iBAAAsD,CAAkB7I,GAChB,MAAMqI,EAAYZ,EAASE,OAAOpK,OAIlC,OAFAyC,EAAQqI,EAAYrI,EAAQqI,EAAY,EAEjC5U,KAAKkV,SAAS3I,EACvB,EAEA,QAAA8I,CAAS9I,EAAOmI,GACV1U,KAAKmV,aAAa5I,KACpByH,EAASE,OAAO3H,GAASmI,EAE7B,EAEA,QAAAY,CAASZ,GACPV,EAASE,OAAOtD,KAAK8D,EACvB,EAEA,WAAAa,CAAYhJ,EAAOmI,GACb1U,KAAKmV,aAAa5I,IACpByH,EAASE,OAAOpS,OAAOyK,EAAO,EAAGmI,EAErC,EAEA,WAAAc,CAAYjJ,GACNvM,KAAKmV,aAAa5I,IACpByH,EAASE,OAAOpS,OAAOyK,EAAO,EAElC,EAEA,WAAAkJ,GACEzB,EAASE,OAAS,EACpB,EAEA,gBAAAwB,CAAiB9C,GACf,IAAKA,EACH,OAGF,MAAMgC,EAAYZ,EAASE,OAAOpK,OAElC8I,EAAI+C,uBAAuBf,GAE3B,IAAK,IAAI5L,EAAI,EAAGA,EAAI4L,EAAW5L,IAC7B4J,EAAIgD,cAAc5M,EAAGgL,EAASE,OAAOlL,GAEzC,EAEA,iBAAA6M,GACE,MAAMjD,EAAM,IAAI,IAIhB,OAFA5S,KAAK0V,iBAAiB9C,GAEfA,CACT,EAEAuC,aAAa5I,GACJA,GAAS,GAAKA,EAAQyH,EAASE,OAAOpK,OAKnD,kFC1Ue,SAAS,EACtBgM,EACAC,GAEA,MAAM3Q,EAAQ0Q,EAAe1Q,MAG7B,IAAK0Q,EAAehX,SAAWgX,EAAe1Q,MAC5C,OAIF,MAAMqE,GAAQ,SAUd,GARArE,EAAM4Q,MAAQ,CACZC,sBAAuB,EACvBC,0CAA2C,EAC3CC,sBAAuB,EACvBC,gBAAiB,EACjBC,qBAAsB,GAGpBjR,EAAO,CACT,IAAIhC,EAASgC,EAAMhC,OAEdA,IAEDA,EADE0S,EAAerS,SAASuQ,SACjB,IACA5O,EAAMkR,MACN,IAEA,KAIblT,EAAO0S,EAAgBC,EACzB,CAGA,MAAMQ,GAAiB,SAAQ9M,EAE/BrE,EAAM4Q,MAAMI,eAAiBG,EAE7BT,EAAeU,SAAU,EACzBV,EAAeW,aAAc,CAC/B,mDC5Ce,SAAS,EACtBX,EACA7F,GAEA,MAAM9N,EAAY,IAAI,IAEtB,IAAK2T,EAAerS,SAASiT,cAC3B,OAAOvU,EAITA,EAAU+N,UACR4F,EAAehX,OAAOyB,MAAQ,EAC9BuV,EAAehX,OAAO0B,OAAS,GAIjC,MAAMmW,EAAQb,EAAerS,SAASmT,SAExB,IAAVD,GACFxU,EAAU0U,OAAQF,EAAQ/V,KAAKkW,GAAM,KAIvC,IAAIC,EAAajB,EAAerS,SAASwM,MACrC+G,EAAclB,EAAerS,SAASwM,MAE1C,MAAM1P,EACJuV,EAAerS,SAASiT,cAAcO,KAAKxE,GAC1CqD,EAAerS,SAASiT,cAAcQ,KAAKzE,EAAI,GAC5CjS,EACJsV,EAAerS,SAASiT,cAAcO,KAAKE,GAC1CrB,EAAerS,SAASiT,cAAcQ,KAAKC,EAAI,GAElD,GAAmE,SAA/DrB,EAAerS,SAASiT,cAAcU,qBAEtCtB,EAAe1Q,MAAMiB,gBACrByP,EAAe1Q,MAAMe,mBAErB4Q,GACEjB,EAAe1Q,MAAMe,mBACrB2P,EAAe1Q,MAAMiB,gBAEvByP,EAAe1Q,MAAMe,mBACrB2P,EAAe1Q,MAAMiB,kBAErB2Q,GACElB,EAAe1Q,MAAMiB,gBACrByP,EAAe1Q,MAAMe,yBAOzB,GAHA4Q,EAAajB,EAAerS,SAASiT,cAAcvQ,mBACnD6Q,EAAclB,EAAerS,SAASiT,cAAcrQ,gBAIlD,iBADAyP,EAAerS,SAASiT,cAAcU,qBAEtC,CAEA,MAAMC,EACJvB,EAAehX,OAAO0B,QAAUA,EAASwW,GACrCM,EACJxB,EAAehX,OAAOyB,OAASA,EAAQwW,GAGzCA,EAAaC,EAAcpW,KAAK2W,IAAID,EAAiBD,GAGnDvB,EAAerS,SAASiT,cAAcrQ,gBACtCyP,EAAerS,SAASiT,cAAcvQ,mBAEtC4Q,GACEjB,EAAerS,SAASiT,cAAcvQ,mBACtC2P,EAAerS,SAASiT,cAAcrQ,gBAExCyP,EAAerS,SAASiT,cAAcvQ,mBACtC2P,EAAerS,SAASiT,cAAcrQ,kBAEtC2Q,GACElB,EAAerS,SAASiT,cAAcrQ,gBACtCyP,EAAerS,SAASiT,cAAcvQ,mBAE5C,CAsCF,OAnCAhE,EAAU8N,MAAM8G,EAAYC,GAGd,IAAVL,GACFxU,EAAU0U,QAASF,EAAQ/V,KAAKkW,GAAM,KAIxC3U,EAAU+N,UACR4F,EAAerS,SAAS+T,YAAY/E,EACpCqD,EAAerS,SAAS+T,YAAYL,GAIxB,IAAVR,GACFxU,EAAU0U,OAAQF,EAAQ/V,KAAKkW,GAAM,UAGzB7M,IAAVgG,GAEF9N,EAAU8N,MAAMA,EAAOA,GAIrB6F,EAAerS,SAASgU,OAC1BtV,EAAU8N,OAAO,EAAG,GAGlB6F,EAAerS,SAASiU,OAC1BvV,EAAU8N,MAAM,GAAI,GAItB9N,EAAU+N,WAAW3P,EAAQ,GAAIC,EAAS,GAEnC2B,CACT,mDCxHe,SAAS,EACtB2T,EACA6B,GAEA,MAAMxV,GAAY,OAAa2T,GAI/B,OAFA3T,EAAUE,SAEHF,EAAUG,eAAeqV,EAClC,mBCZe,SAAS,EACtBC,EACAC,GAEA,MAAM,MAAEJ,EAAK,MAAEC,EAAK,SAAEd,GAAaiB,EAOnC,GAJAD,EAAMnF,GAAKgF,GAAS,EAAI,EACxBG,EAAMT,GAAKO,GAAS,EAAI,EAGP,IAAbd,EAAgB,CAClB,MAAMD,EAASC,EAAWhW,KAAKkW,GAAM,IAE/BgB,EAAOlX,KAAKmX,IAAIpB,GAChBqB,EAAOpX,KAAKqX,IAAItB,GAEhBuB,EAAON,EAAMnF,EAAIqF,EAAOF,EAAMT,EAAIa,EAClCG,EAAOP,EAAMnF,EAAIuF,EAAOJ,EAAMT,EAAIW,EAExCF,EAAMnF,EAAIyF,EACVN,EAAMT,EAAIgB,CACZ,CAEA,OAAOP,CACT,8ECtBe,SAAS,EACtB9Y,EACAsG,EACA0C,EACAkM,GAEA,QAAe/J,IAAXnL,EACF,MAAM,IAAI6I,MACR,8DAIJ,QAAcsC,IAAV7E,EACF,OAAO,SAIT,MAAM6K,GAAQ,OAAiBnR,EAAQsG,EAAO,GAAGgT,YAEjD,IAAIC,EAqBJ,MAnBiB,OAAbvQ,GAAqB1C,EAAMkT,YAC7BD,EAAM,CACJ1L,YAAa,EACbC,aAAc,UAGM3C,IAAtB7E,EAAMuH,kBACiB1C,IAAvB7E,EAAMwH,eAENyL,EAAM,CACJ1L,YAAarF,MAAMC,QAAQnC,EAAMuH,aAC7BvH,EAAMuH,YAAY,GAClBvH,EAAMuH,YACVC,aAActF,MAAMC,QAAQnC,EAAMwH,cAC9BxH,EAAMwH,aAAa,GACnBxH,EAAMwH,eAIP,CACLqD,QACAuH,YAAa,CACX/E,EAAG,EACH0E,EAAG,GAELkB,MACAhW,OAAQ+C,EAAM/C,OACdkW,kBAAkB,EAClB3B,SAAU,EACVa,OAAO,EACPC,OAAO,EACPc,YAAapT,EAAMoT,YACnB1Q,WACA2Q,OAAQrT,EAAMqT,OACdzE,cAAuB/J,IAAb+J,EAAyBA,EAAW5O,EAAM4O,SACpD0C,cAAe,CACbQ,KAAM,CACJzE,EAAG,EACH0E,EAAG,GAELF,KAAM,CACJxE,EAAGrN,EAAMU,QACTqR,EAAG/R,EAAMS,MAEXQ,qBAC4B4D,IAA1B7E,EAAMiB,gBAAgC,EAAIjB,EAAMiB,gBAClDF,wBAC+B8D,IAA7B7E,EAAMe,mBAAmC,EAAIf,EAAMe,mBACrDiR,qBAAsB,QAG5B,6DC5Ee,SAAS,EACtBtY,EACAsG,EACAwR,EAA0B,OAM1B,OACE9X,EACA,0DAEF,OACEsG,EACA,wDAGF,MAAMsT,GAAY,OAAatT,EAAOwR,GAChCvQ,EAAkBjB,EAAMiB,iBAAmB,EAC3CF,EAAqBf,EAAMe,oBAAsB,EACvD,IAAIwS,EAAgB,EAChBC,EAAkB,EAElBvS,EAAkBF,EACpByS,EAAkBzS,EAAqBE,EAGvCsS,EAAgBtS,EAAkBF,EAGpC,MAAMkR,EAAgBvY,EAAO0B,OAASkY,EAAUlY,OAASmY,EACnDrB,EAAkBxY,EAAOyB,MAAQmY,EAAUnY,MAAQqY,EAGzD,MAAO,CACLvB,gBACAC,kBACAc,YAAaxX,KAAK2W,IAAID,EAAiBD,GAE3C,kDCzBe,SAAS,EACtBjS,EACAwR,EAAW,MAeX,OAbA,OACExR,EACA,wDAEF,OACEA,EAAM7E,MACN,kDAEF,OACE6E,EAAM5E,OACN,kDA/BJ,SAAmBoW,GACjB,QACEA,SAEa,IAAbA,GACa,MAAbA,EAEJ,CA2BMiC,CAAUjC,GACL,CACLpW,OAAQ4E,EAAM7E,MACdA,MAAO6E,EAAM5E,QAIV,CACLD,MAAO6E,EAAM7E,MACbC,OAAQ4E,EAAM5E,OAElB,mDChDe,SAAS,EACtBsV,GAQA,OAAO,OAAmBA,EAC5B,mDCFe,SAAS,EACtBA,EACA6B,GAIA,OAFkB,OAAa7B,GAEdxT,eAAeqV,EAClC,mDCde,SAAS,EACtB7B,EACAgD,GAAW,EACXC,GAAY,GAEZ,MAAM,OAAEja,EAAM,MAAEsG,EAAK,SAAE3B,GAAaqS,EAC9B7F,GAAQ,OAAiBnR,EAAQsG,EAAO,GAAGgT,YAEjD3U,EAASiU,OAAQ,EACjBjU,EAASgU,OAAQ,EAEbqB,IACFrV,EAAS+T,YAAY/E,EAAI,EACzBhP,EAAS+T,YAAYL,EAAI,GAGvB4B,IACFtV,EAASiT,cAAcQ,KAAKzE,EAAI,EAChChP,EAASiT,cAAcQ,KAAKC,EAAI,EAChC1T,EAASiT,cAAcO,KAAKxE,EAAIrN,EAAMU,QACtCrC,EAASiT,cAAcO,KAAKE,EAAI/R,EAAMS,KAEtCpC,EAASwM,MAAQA,EAErB,kECsDe,SAAS,EACtB6F,EACAkD,GAAmB,GAEnB,MAAMC,EAAiBnD,EAAehX,OAAOyB,MACvC2Y,EAAkBpD,EAAehX,OAAO0B,QA/EhD,SAAuBsV,GACrB,MAAM,OAAEhX,GAAWgX,GACb,YAAE1U,EAAW,aAAEC,GAAiBvC,EAGlCA,EAAOyB,QAAUa,GAAetC,EAAO0B,SAAWa,IACpDvC,EAAOyB,MAAQa,EACftC,EAAO0B,OAASa,EAEpB,CAwEE8X,CAAcrD,QAEe7L,IAAzB6L,EAAe1Q,QAKjB4T,GApEJ,SACElD,EACAmD,EACAC,GAEA,MAAMjJ,EAAQ6F,EAAerS,SAASwM,MAChCyI,GAAY,EAAAU,EAAA,GAChBtD,EAAe1Q,MACf0Q,EAAerS,SAASmT,UAEpByC,EAAazY,KAAKC,MAAM6X,EAAUnY,MAAQ0P,GAC1CqJ,EAAc1Y,KAAKC,MAAM6X,EAAUlY,OAASyP,GAC5CwC,EAAIqD,EAAerS,SAAS+T,YAAY/E,EACxC0E,EAAIrB,EAAerS,SAAS+T,YAAYL,EAE9C,OACGkC,IAAeJ,GAAkBK,GAAeJ,GAChDG,GAAcJ,GACbK,IAAgBJ,GACV,IAANzG,GACM,IAAN0E,CAEN,CA+CIoC,CAAezD,EAAgBmD,EAAgBC,GC3FpC,SAAUpD,GACvB,MAAM,MAAE1Q,GAAU0Q,EAGlBA,EAAerS,SAASwM,OAAQ,EAAAuJ,EAAA,GAC9B1D,EAAehX,OACfsG,EACA0Q,EAAerS,SAASmT,UACxBwB,YAEFtC,EAAerS,SAAS+T,YAAY/E,EAAI,EACxCqD,EAAerS,SAAS+T,YAAYL,EAAI,CAC1C,CDkFIsC,CAAY3D,GAxChB,SACEA,EACAmD,EACAC,GAEA,MAAMjJ,EAAQ6F,EAAerS,SAASwM,MAGhCyJ,EAFc5D,EAAehX,OAAOyB,MAEL0Y,EAC/BU,EAFe7D,EAAehX,OAAO0B,OAEJ0Y,EACjCU,EAAYhZ,KAAKiZ,KAAKH,EAAiBC,GAE7C7D,EAAerS,SAASwM,MAAQ2J,EAAY3J,CAC9C,CA8BI6J,CAAgBhE,EAAgBmD,EAAgBC,GAEpD,yGEJA,QAzEAjI,eACErS,EACAG,EACAwE,EACAoO,GAAiB,EACjBoI,GAAoB,GAEpB,MAAM,SAAEC,EAAQ,SAAEjJ,EAAQ,UAAEkJ,GAAcrb,EAEpCsb,QAAoB,IAAAC,YAAWH,GAErC,IAAKE,EACH,MAAM,IAAIvS,MACR,wBAAwBuS,EAAYF,2BAIxC,MAAM,UAAEhP,EAAS,iBAAEoP,GAAqBF,EAElCG,GAAe,OAAmBrP,EAAWoP,GAE/CH,GACFI,EAAaC,aAAaL,GAG5B,MAAMM,EAAc,mBAsBpB,OArBAA,EAAYC,UAAUH,GAOK,IALArP,EACxByP,eACAC,aACAC,yBAGDJ,EAAYK,cAAcC,0BAAyB,SAG/C,OAAoBN,EAAaL,EAAaH,GAEhDhJ,GACFA,EAAS,CAAEwJ,cAAaP,aAGrBrI,GAOP,SACE5S,EACAwE,EACAgX,EACAP,GAEA,MAAMpa,EAAW2a,EACdK,cACAE,uBAAuB,GACvB/P,WAEGgQ,EAAiD,CACrDxX,aACAmL,MAAO,CACL7O,MAAOD,EAAS,GAChBE,MAAOF,EAAS,IAElBoa,aAGF,IAAA3W,cAAatE,EAAS,EAAAic,OAAOC,aAAcF,EAC7C,CA3BIG,CAAmBnc,EAASwE,EAAYgX,EAAaP,GAGhDO,CACT,8FCnEA,MACMY,EAAe,EAAAC,YAAYC,SA6OjC,QAjOApK,eACEsJ,EACAL,EACAH,GAEA,IAAI1B,EAwDN,SAA4B6B,GAC1B,MAAM,SAAElT,EAAQ,SAAEgB,GAAakS,EAC/B,IAAI7B,EACJ,GAAIrR,EAAS8C,OAAQ,CACnB,MACMzE,EAAU2B,EADKpG,KAAK6O,MAAMzI,EAAS8C,OAAS,IAE5CwR,EAAe,MAAa,eAAgBjW,GAClD,GAAIiW,GAAgBA,EAAa3O,aAAe2O,EAAa1O,aAAc,CACzE,MAAM,YAAED,EAAW,aAAEC,GAAiB0O,EACtCjD,EAAM,CACJ1L,YAAarF,MAAMC,QAAQoF,GAAeA,EAAY,GAAKA,EAC3DC,aAActF,MAAMC,QAAQqF,GACxBA,EAAa,GACbA,EAER,CACF,MACEyL,EAAMrQ,GAAUuT,SAAS,GAE3B,GAAIlD,EAAK,CACP,MAAM,MAAExY,EAAK,MAAEC,GAAU,EAAA0b,YAAA,eACvB5M,OAAOyJ,EAAI1L,aACXiC,OAAOyJ,EAAIzL,eAEb,MAAO,CACL/M,QACAC,QAEJ,CACF,CArFY2b,CAAmBvB,IAExB7B,GAAO6B,GAAalT,UAAU8C,SACjCuO,QA4FJpH,eACEiJ,EACAH,GAEA,MAAM,SAAE/S,GAAakT,EACfvP,EAAauP,EAAYxP,gBAGzBgR,EAAe9a,KAAK6O,MAAMzI,EAAS8C,OAAS,GAC5CzE,EAAU6U,EAAYlT,SAAS0U,GAC/BC,EACJ,MAAa,sBAAuBtW,IAAY,CAAC,GAC7C,SAAEyC,GAAa6T,EACfC,EAAoB,MAAa,oBAAqBvW,IAAY,CAAC,EAEnEwW,EAAY7U,EAAS8C,OACrBgS,EAAgBnR,EAAWoR,WAAaF,EACxCG,EAAiBrR,EAAWb,OAAS+R,EACrCI,EAAetR,EAAWuR,kBAE1BC,EAAuC,CAC3CC,aAAcR,EAAkBQ,aAChCC,iBAAkBT,EAAkBS,iBACpCvU,YAGF,IAAIwU,EACJ,GAAiB,OAAbxU,EAAmB,CACrB,MAAMyU,EAAY,MAAa,gBAAiBlX,GAE5CkX,IACFD,EAAyB,IACpBH,EACHK,MAAOD,EAAUC,OAGvB,CAEA,MAAMC,EAAaf,EAAeI,EAE5B7U,EAAU,CACdyV,aAAc,CACZC,KAAM5C,OAAoB9P,EAAY,gBAExC2S,SA7Ja,EA8JbC,YAAa1B,EACbpB,oBACApO,SAAU,CACRmR,SAAS,EACTX,kBAAmBG,IAevB,IAAIlX,EAAQ,KAAMqL,SAASpL,GAEtB6U,EAAY6C,oBAAoBjT,SAInC1E,QAAc,IAAA4X,mBAAkB3X,EAAS,IAAK4B,EAASgW,aAAa,KAGtE,MAAMC,EAAkB9X,EACpBA,EAAM+X,eAiBZ,SACEjD,EACAuC,EACAR,EACAD,GAEA,MAAM,WAAErR,GAAeuP,GACjB,OAAEkD,GAAWzS,EACfA,EAAWuR,oBAAsBD,IACnCQ,GAAc9R,EAAWuR,kBAAoBD,GAG/C,MAAMoB,EAAa1S,EAAWhM,YACxBue,EAAkB,IAAIG,EAAWrB,GAEjCsB,EAAmB,IAAID,EAAWD,EAAQX,EAAYT,GAI5D,OAFAkB,EAAgBK,IAAID,GAEbJ,CACT,CApCMM,CACEtD,EACAuC,EACAR,EACAD,IAIA,IAAEzE,EAAG,IAAErK,IAAQ,IAAAuQ,WAAUP,GAE/B,MAAO,CACLrd,MAAO0X,EACPzX,MAAOoN,EAEX,CArLgBwQ,CAAiBxD,EAAaH,GAC1C1B,EAqBJ,SAA+B6B,EAA2B7B,GACxD,MAAMrR,EAAWkT,EAAYlT,SACvB0U,EAAe9a,KAAK6O,MAAMzI,EAAS8C,OAAS,GAC5CzE,EAAU2B,EAAS0U,GAWzB,GAyKF,SAAoC5T,EAAUoS,GAC5C,GAAiB,OAAbpS,IAAsBoS,EAAY5B,YACpC,OAAO,EAGT,IAAK4B,EAAYyD,SAASC,GAAGpB,MAC3B,OAAO,EAGT,OAAO,CACT,CAnLMqB,EARF,MAAa,sBAAuBxY,IAAY,CAAC,GAQAyC,SAAUoS,GAC3D,MAAO,CACLra,MAAO,EACPC,MAAO,GAIX,OAAOuY,CACT,CA3CUyF,CAAsB5D,EAAa7B,IAQzB,IAAfA,GAAKxY,OAA8B,IAAfwY,GAAKvY,YACXmK,IAAfoO,GAAKxY,YACUoK,IAAfoO,GAAKvY,OAKPya,EACGK,cACAE,uBAAuB,GACvBiD,gBAAgB1F,EAAIxY,MAAOwY,EAAIvY,MACpC,8DCvBA,MAAMke,EAAiB,CACrBC,cAAe,MAGV,SAASC,EAAOC,EAAWC,EAAOC,EAAgB,CAAC,GACxDxS,OAAOyS,OAAOF,EAAOJ,EAAgBK,GAErC,YAAuBF,EAAWC,EAAOC,GAEzC,YAAaF,EAAWC,EAAO,CAAC,kBAzBlC,SAA+BD,EAAWC,GACxCA,EAAMG,eAAe3N,KAAK,yBAE1B,MAAM4N,EAAcL,EAAUM,OAC9BN,EAAUM,OAAS,KACjBL,EAAMH,cAAgB,KACtBO,GAAa,CAEjB,CAoBEE,CAAsBP,EAAWC,EACnC,CAIO,MAIP,GAAiBO,YAJU,iBAAkBT,EAAQ,yBAIvBA,4CC/C9B,MAAMU,EAAmBC,OAAO,mBAC1BC,EAAmBD,OAAO,mBAC1BE,EAAsBF,OAAO,qBAC7BG,EAAaH,OAAO,cAKX,MAAMI,EACnB,WAAAtgB,CAAYugB,GACV,MAAMC,EAAatT,OAAOuT,OACvBF,aAAgBD,GAAYD,KAAcE,EACvCA,EAAKF,GACL,MAENnT,OAAOwT,KACLxT,OAAOC,eAAe9L,KAAMgf,EAAY,CACtCM,MAAOH,IAGb,CAEA,GAAA5B,CAAIgC,EAAaD,GACf,OAAO/B,EAAIvd,KAAKgf,GAAaO,EAAKD,EAAO,KAC3C,CAEA,GAAAvT,CAAIwT,GACF,OA8MJ,SAAaJ,EAAqCI,GAChD,OAAOJ,EAAWI,EACpB,CAhNWxT,CAAI/L,KAAKgf,GAAaO,EAC/B,CAQA,KAAAC,CAAMD,GACJ,OA8GJ,SAAeJ,EAAqClL,GAClD,GAAIA,EAAKwL,SAAS,KAAM,CACtB,IAAIC,EAAc,EAClB,MAAMC,EAAY1L,EACZiL,EAAOS,EAAUC,MAAM,GAAI,GAC3BC,EAA4B,IAAhBX,EAAKpV,OACvB,IAAK,MAAMyV,KAAOJ,EAEdtT,OAAOiU,UAAUC,eAAeC,KAAKb,EAAYI,KAChDM,GAAaN,EAAIU,WAAWN,IAAcJ,IAAQL,YAE5CC,EAAWI,KAChBG,GAGN,OAAOA,EAAc,CACvB,CACA,cAAcP,EAAWlL,EAC3B,CAhIWuL,CAAMxf,KAAKgf,GAAaO,EAAM,GACvC,CAEA,OAAAhP,CAAQQ,GACNmP,EAAQlgB,KAAKgf,GAAajO,EAC5B,CAEA,MAAAmN,GACE,OAAO,IAAIe,EAASjf,KACtB,CAQA,MAAAmgB,CAAOC,GACDC,EAAcD,IAChBvU,OAAOyU,KAAKF,GAAM7P,SAASgP,IACzBhC,EAAIvd,KAAKgf,GAAaO,EAAKa,EAAKb,GAAM,KAAK,GAGjD,CASA,IAAAgB,GACE,MAAM3V,EAAU,CAAC,EAMjB,OALAsV,EAAQlgB,KAAKgf,IAAa,CAACO,EAAKD,UACT,IAAVA,GACTkB,EAAQ5V,EAAS2U,EAAKD,EACxB,IAEK1U,CACT,CAEA,aAAO6V,CAAOC,GACZ,OAAOA,aAAmBzB,EACtByB,EACAzB,EAAS0B,oBACf,CAEA,yBAAOC,CAAmBC,EAAW,MACnC,IAAIC,EAAkB7B,EAASL,GAQ/B,GAPMkC,aAA2B7B,IAC/B6B,EAAkB,IAAI7B,EACtBA,EAASL,GAAoBkC,GAK3BD,EAAU,CACZ,MAAME,EAAa,CAAC,EAOpB,OANAD,EAAgBvQ,SAAS0D,IACvB,GAAIA,EAAKgM,WAAWY,GAAW,CAC7B,MAAMG,EAAU/M,EAAKtF,MAAM,GAAGkS,MAAa,GAC3CE,EAAWC,GAAWF,EAAgB/U,IAAIkI,EAC5C,KAEK8M,CACT,CAEA,OAAOD,CACT,CAEA,yBAAOH,GACL,IAAIM,EAAkBhC,EAASH,GAK/B,OAJMmC,aAA2BhC,IAC/BgC,EAAkB,IAAIhC,EAASA,EAAS2B,sBACxC3B,EAASH,GAAoBmC,GAExBA,CACT,CAEA,wBAAOC,CAAkBR,EAAkBS,GACzC,IAAIC,EAAW,KACf,GAAIV,aAAmBzB,EACrBmC,EAAWV,OACN,GAAuB,iBAAZA,GAAoC,OAAZA,EAAkB,CAC1D,IAAIW,EAAoBpC,EAASF,GAC3BsC,aAA6BC,UACjCD,EAAoB,IAAIC,QACxBrC,EAASF,GAAuBsC,GAElCD,EAAWC,EAAkBtV,IAAI2U,GAC3BU,aAAoBnC,IACxBmC,EAAW,IAAInC,EACbA,EAASwB,OAAOxB,EAASiC,kBAAkBC,KAE7CE,EAAkB9D,IAAImD,EAASU,GAEnC,CACA,OAAOA,CACT,CAEA,4BAAOG,GACL,OAAOtC,EAAS0B,qBAAqBzC,QACvC,EA2BF,SAASgC,EACPf,EACApO,GAEA,IAAK,MAAMwO,KAAOJ,EAChBpO,EAASwO,EAAKJ,EAAWI,GAE7B,CAsCA,SAAShC,EACP4B,EACAI,EACAD,EACAkC,GAEA,QA8BF,SAAoBjC,GAClB,IAAIkC,EAAcC,EAAiBC,EACnC,GAAmB,iBAARpC,IAAqBkC,EAAOlC,EAAIzV,OAAS,GAAK,EACvD,OAAO,EAET6X,GAAY,EACZ,MAAQD,EAAUnC,EAAI/S,QAAQ,IAAKmV,EAAW,KAAO,GAAG,CACtD,GAAID,EAAUC,EAAW,GAAKD,IAAYD,EACxC,OAAO,EAETE,EAAWD,CACb,CACA,OAAO,CACT,CA3CME,CAAWrC,KACTc,EAAcf,GA3CtB,SACEH,EACA0C,EACAC,EACAN,GAEA,IAAIO,EACJ,GAAIP,EAAWQ,IAAIF,GACjB,OAAOvE,EAAI4B,EAAY0C,EAAQ,KAAML,GAEvCA,EAAWS,IAAIH,GACfC,EAAY,EACZ,IAAK,MAAMG,KAASJ,EACdjW,OAAOiU,UAAUC,eAAeC,KAAK8B,EAAQI,KAE1C3E,EAAI4B,EADoB,IAAjB+C,EAAMpY,OAAe+X,EAAS,GAAGA,KAAUK,IAC7BJ,EAAOI,GAAQV,MACrCO,GAKR,OADAP,EAAW/C,OAAOqD,GACG,IAAdC,CACT,CAsBaI,CACLhD,EACAI,EACAD,EACAkC,aAAsBY,QAAUZ,EAAa,IAAIY,UAGrDjD,EAAWI,GAAOD,GACX,GAGX,CAgCA,SAASe,EAAcK,GACrB,GAAuB,iBAAZA,GAAoC,OAAZA,EAAkB,CACnD,MAAMZ,EAAYjU,OAAOwW,eAAe3B,GACxC,GAAIZ,IAAcjU,OAAOiU,WAA2B,OAAdA,EACpC,OAAO,CAEX,CACA,OAAO,CACT,CAEA,SAASU,EAAQ5V,EAAS2U,EAAKD,GAC7B,MAAMgD,EAAY/C,EAAI/S,QAAQ,KAC9B,GAAI8V,GAAa,EAAG,CAClB,MAAMC,EAAShD,EAAIK,MAAM,EAAG0C,GAC5B,IAAIE,EAAa5X,EAAQ2X,GACzB,GAA0B,iBAAfC,GAA0C,OAAfA,EAAqB,CACzD,MAAMC,EAAkBD,EACxBA,EAAa,CAAC,OACiB,IAApBC,IACTD,EAAW,IAAMC,GAEnB7X,EAAQ2X,GAAUC,CACpB,CACAhC,EAAQgC,EAAYjD,EAAIK,MAAM0C,EAAY,EAAG/C,EAAIzV,QAASwV,EAC5D,MACE1U,EAAQ2U,GAAOD,CAEnB,CAKAL,EAAS2B,qBAAqBrD,IAAI,cAAc,oFCzRhD,MAAMmF,EAAS,WAw9Bf,MACA,EADc,IA78Bd,MAaE,WAAA/jB,GAXiB,KAAAgkB,YAAc,IAAIC,IAElB,KAAAC,aAAe,IAAID,IAI5B,KAAAE,gBAAkB,EAClB,KAAAC,iBAAmB,EACnB,KAAAC,cAAgB,EAAIN,EACpB,KAAAO,iBAAmB,WAgBpB,KAAAC,gBAAmBC,IACxB,IAAKA,GAA8C,iBAApBA,EAA8B,CAC3D,MAAMC,EAAe,qBAAqBpjB,KAAKgjB,0DAC/C,MAAM,IAAIrb,MAAMyb,EAClB,CAEApjB,KAAKgjB,cAAgBG,CAAe,EAa/B,KAAAE,YAAetH,IACpB,GAAIA,EAAa/b,KAAKijB,iBACpB,OAAO,EAMT,OAJyBjjB,KAAKsjB,oBACPtjB,KAAK8iB,gBAGJ/G,CAAU,EAQ7B,KAAAwH,gBAAkB,IAAcvjB,KAAKgjB,cAOrC,KAAAQ,mBAAqB,IAAcxjB,KAAKijB,iBAOxC,KAAAQ,aAAe,IACpBzjB,KAAK8iB,gBAAkB9iB,KAAK+iB,iBAgBtB,KAAAW,cAAiBre,IACvB,MAAM,gBAAEse,GAAoB3jB,KAAK2iB,YAAY5W,IAAI1G,GAG7Cse,EAAgBC,UAClBD,EAAgBC,WAGdD,EAAgBE,SAClBF,EAAgBE,UAGlB7jB,KAAK2iB,YAAYlE,OAAOpZ,EAAQ,EAS1B,KAAAye,eAAkB9J,IACxB,MAAM+J,EAAe/jB,KAAK6iB,aAAa9W,IAAIiO,IACrC,iBAAEgK,EAAgB,OAAEC,GAAWF,EAEjCE,EAAOC,eACTD,EAAOC,gBAGLD,EAAOjZ,WACTiZ,EAAOjZ,UAAUyT,SAKnBze,KAAKmkB,yBAAyBF,GAE1BD,EAAiBJ,UAEnBI,EAAiBJ,WAGfI,EAAiBH,SACnBG,EAAiBH,UAGnB7jB,KAAK6iB,aAAapE,OAAOzE,EAAS,EAa7B,KAAAoK,WAAa,KAClB,MAAMC,EAAgBrkB,KAAK2iB,YAAYrC,OAGvC,OAAa,CACX,MAAQhB,MAAOja,EAAO,KAAEif,GAASD,EAAcE,OAE/C,GAAID,EACF,MAGFtkB,KAAKwkB,sBAAsBnf,IAE3B,IAAAhC,cAAa,IAAa,IAAOohB,0BAA2B,CAAEpf,WAChE,CAEArF,KAAK0kB,kBAAkB,EAMlB,KAAAA,iBAAmB,KACxB,MAAMC,EAAiB3kB,KAAK6iB,aAAavC,OAGzC,OAAa,CACX,MAAQhB,MAAOtF,EAAQ,KAAEsK,GAASK,EAAeJ,OAEjD,GAAID,EACF,MAGFtkB,KAAK4kB,uBAAuB5K,IAE5B,IAAA3W,cAAa,IAAa,IAAOwhB,4BAA6B,CAC5D7K,YAEJ,GA0ZK,KAAA8K,oBAAuB9K,IAC5B,QAAiB/P,IAAb+P,EACF,MAAM,IAAIrS,MAAM,uDAElB,MAAMoc,EAAe/jB,KAAK6iB,aAAa9W,IAAIiO,GAE3C,QAAqB/P,IAAjB8Z,EAOJ,OAFAA,EAAagB,UAAYC,KAAKC,MAEvBlB,EAAaC,gBAAgB,EAG/B,KAAAkB,YAAeC,IACpB,GAAkB,MAAdA,EACF,MAAM,IAAIxd,MAAM,iDAGlB,MAAMyd,EAAiBplB,KAAKqlB,eAAetZ,IAAIoZ,GAE/C,QAAuBlb,IAAnBmb,EAOJ,OAFAA,EAAeL,UAAYC,KAAKC,MAEzBG,EAAeE,QAAQ,EASzB,KAAA7U,SAAYpL,IACjB,QAAgB4E,IAAZ5E,EACF,MAAM,IAAIsC,MAAM,2CAElB,MAAM4d,EAAcvlB,KAAK2iB,YAAY5W,IAAI1G,GAEzC,QAAoB4E,IAAhBsb,EAOJ,OAFAA,EAAYR,UAAYC,KAAKC,MAEtBM,EAAYngB,KAAK,EASnB,KAAAogB,UAAaxL,IAClB,QAAiB/P,IAAb+P,EACF,MAAM,IAAIrS,MAAM,6CAElB,MAAMoc,EAAe/jB,KAAK6iB,aAAa9W,IAAIiO,GAE3C,QAAqB/P,IAAjB8Z,EAOJ,OAFAA,EAAagB,UAAYC,KAAKC,MAEvBlB,EAAaE,MAAM,EAOrB,KAAAwB,WAAa,IACIne,MAAM6Z,KAAKnhB,KAAK6iB,aAAatP,UAE9BhR,KAAKwhB,GAAiBA,EAAaE,SAQnD,KAAAyB,2BACL1L,GAEsBha,KAAKylB,aAENjY,QAAQyW,GACpBA,EAAO0B,qBAAuB3L,IAalC,KAAAwK,sBAAyBnf,IAC9B,QAAgB4E,IAAZ5E,EACF,MAAM,IAAIsC,MAAM,wDAElB,MAAM4d,EAAcvlB,KAAK2iB,YAAY5W,IAAI1G,GAEzC,QAAoB4E,IAAhBsb,EACF,MAAM,IAAI5d,MACR,gEAIJ3H,KAAK4lB,yBAAyBL,EAAYM,aAE1C,MAAMC,EAAe,CACnB1gB,MAAOmgB,EACPlgB,YAGF,IAAAhC,cAAa,IAAa,IAAOohB,0BAA2BqB,GAC5D9lB,KAAK0jB,cAAcre,EAAQ,EAYtB,KAAAuf,uBAA0B5K,IAC/B,QAAiB/P,IAAb+P,EACF,MAAM,IAAIrS,MAAM,0DAElB,MAAMoc,EAAe/jB,KAAK6iB,aAAa9W,IAAIiO,GAE3C,QAAqB/P,IAAjB8Z,EACF,MAAM,IAAIpc,MACR,mEAIJ3H,KAAK+lB,0BAA0BhC,EAAa8B,aAE5C,MAAMC,EAAe,CACnB7B,OAAQF,EACR/J,aAGF,IAAA3W,cAAa,IAAa,IAAOwhB,4BAA6BiB,GAC9D9lB,KAAK8jB,eAAe9J,EAAS,EAG/B,KAAAgM,sBAAwB,CACtBb,EACAc,KAEA,GAAkBhc,MAAdkb,EACF,MAAM,IAAIxd,MACR,2DAIJ,GAAI3H,KAAKqlB,eAAerD,IAAImD,GAC1B,MAAM,IAAIxd,MACR,sEAIJ,MAAMyd,EAAkC,CACtCD,aACAc,qBACAC,QAAQ,EACRnB,UAAWC,KAAKC,MAChBY,YAAa,GAKf,OAFA7lB,KAAKqlB,eAAe9H,IAAI4H,EAAYC,GAE7Ba,EAAmBE,QACvB/d,MAAMkd,IACL,IAAKtlB,KAAKqlB,eAAerD,IAAImD,GAI3B,YAHA9T,QAAQC,KACN,oEAKJ,GAAI1C,OAAO7N,MAAMukB,EAASO,aACxB,MAAM,IAAIle,MACR,+DAMJyd,EAAec,QAAS,EACxBd,EAAeE,SAAWA,EAC1BF,EAAeS,YAAcP,EAASO,YAItC,MAAMC,EAAe,CACnBR,WACAH,eAGF,IAAA9hB,cACE,IACA,IAAO+iB,8BACPN,EAGI,IAEPO,OAAOC,IAEN,MADAtmB,KAAKqlB,eAAe5G,OAAO0G,GACrBmB,CAAK,GACX,EAQC,KAAAV,wBAA2B3S,IAChCjT,KAAK8iB,iBAAmB7P,CAAS,EAQ5B,KAAA8S,yBAA4B9S,IACjCjT,KAAK+iB,kBAAoB9P,CAAS,EAQ7B,KAAAsT,wBAA2BC,IAChCxmB,KAAK8iB,iBAAmB0D,CAAS,EAQ5B,KAAAC,yBAA4BD,IACjCxmB,KAAK+iB,kBAAoByD,CAAS,EAp1BlCxmB,KAAKqlB,eAAiB,IAAIzC,GAC5B,CAmEO,iBAAAU,GACL,OAAOtjB,KAAKujB,kBAAoBvjB,KAAKyjB,cACvC,CAmIO,qCAAAiD,CACLC,EACAC,GAEA,IAAIC,EAAiB7mB,KAAKsjB,oBAG1B,GAAIuD,GAAkBF,EACpB,OAAOE,EAGT,IAAIC,EAAexf,MAAM6Z,KAAKnhB,KAAK2iB,YAAYpP,UAe/CuT,EAAapT,MAXb,SAAiBZ,EAAGC,GAClB,OAAID,EAAEiS,UAAYhS,EAAEgS,UACX,EAELjS,EAAEiS,UAAYhS,EAAEgS,WACV,EAGH,CACT,IAGA,IAAIgC,EAAiBD,EAAavkB,KAAKykB,GAAOA,EAAG3hB,UAE7C4hB,EAAkBF,EAIlBH,IACFK,EAAkBF,EAAevZ,QAC9BhK,IAAQojB,EAAeM,SAAS1jB,MAMrC,IAAK,MAAM6B,KAAW4hB,EAMpB,GALAjnB,KAAKwkB,sBAAsBnf,IAE3B,IAAAhC,cAAa,IAAa,IAAOohB,0BAA2B,CAAEpf,YAE9DwhB,EAAiB7mB,KAAKsjB,oBAClBuD,GAAkBF,EACpB,OAAOE,EAKXC,EAAexf,MAAM6Z,KAAKnhB,KAAK2iB,YAAYpP,UAC3CwT,EAAiBD,EAAavkB,KAAKykB,GAAOA,EAAG3hB,UAI7C,IAAK,MAAMA,KAAW0hB,EAMpB,GALA/mB,KAAKwkB,sBAAsBnf,IAE3B,IAAAhC,cAAa,IAAa,IAAOohB,0BAA2B,CAAEpf,YAE9DwhB,EAAiB7mB,KAAKsjB,oBAClBuD,GAAkBF,EACpB,OAAOE,CAOb,CAmBO,kBAAAM,CACL9hB,EACAse,GAEA,QAAgB1Z,IAAZ5E,EACF,MAAM,IAAIsC,MAAM,qDAGlB,QAAgCsC,IAA5B0Z,EAAgBwC,QAClB,MAAM,IAAIxe,MACR,qEAIJ,GAAI3H,KAAK2iB,YAAYX,IAAI3c,GACvB,MAAM,IAAIsC,MAAM,gDAGlB,GACEgc,EAAgBC,UACoB,mBAA7BD,EAAgBC,SAEvB,MAAM,IAAIjc,MACR,iEAIJ,MAAM4d,EAA4B,CAChCW,QAAQ,EACR7gB,UACA+hB,oBAAgBnd,EAChB0Z,kBACAoB,UAAWC,KAAKC,MAChBY,YAAa,GAKf,OAFA7lB,KAAK2iB,YAAYpF,IAAIlY,EAASkgB,GAEvB5B,EAAgBwC,QACpB/d,MAAMhD,IACL,IAAKpF,KAAK2iB,YAAY5W,IAAI1G,GAKxB,YAHAgM,QAAQC,KACN,oEAKJ,QACwBrH,IAAtB7E,EAAMygB,aACNjX,OAAO7N,MAAMqE,EAAMygB,aAEnB,MAAM,IAAIle,MACR,+DAGJ,QAAkCsC,IAA9B7E,EAAMygB,YAAYwB,QACpB,MAAM,IAAI1f,MACR,yDAKJ,IAAK3H,KAAKqjB,YAAYje,EAAMygB,aAC1B,MAAM,IAAIle,MAAM,IAAO2f,qBAIzBtnB,KAAK0mB,sCAAsCthB,EAAMygB,aAEjDN,EAAYW,QAAS,EACrBX,EAAYngB,MAAQA,EACpBmgB,EAAYM,YAAczgB,EAAMygB,YAChC7lB,KAAK4lB,wBAAwBL,EAAYM,aACzC,MAAMC,EAA2D,CAC/D1gB,MAAOmgB,IAGT,IAAAliB,cAAa,IAAa,IAAOkkB,wBAAyBzB,GAE1DP,EAAY6B,eAAiBhiB,EAAMgiB,cAAc,IAElDf,OAAOC,IAGN,MADAtmB,KAAK2iB,YAAYlE,OAAOpZ,GAClBihB,CAAK,GAEjB,CAQO,kBAAAkB,CAAmBniB,GACxB,QAAgB4E,IAAZ5E,EACF,MAAM,IAAIsC,MAAM,qDAElB,MAAM4d,EAAcvlB,KAAK2iB,YAAY5W,IAAI1G,GAEzC,QAAoB4E,IAAhBsb,EAOJ,OAFAA,EAAYR,UAAYC,KAAKC,MAEtBM,EAAY5B,eACrB,CASO,QAAA8D,CAASpiB,GACd,MAAMkgB,EAAcvlB,KAAK2iB,YAAY5W,IAAI1G,GAEzC,QAAKkgB,GAIEA,EAAYW,MACrB,CASO,0BAAAwB,CAA2BriB,GAIhC,MAAMsiB,EAAYrgB,MAAM6Z,KAAKnhB,KAAK6iB,aAAavC,QACzCsH,GAAe,IAAAC,cAAaxiB,GAElC,IAAK,MAAM2U,KAAY2N,EAAW,CAChC,MAAM5D,EAAe/jB,KAAK6iB,aAAa9W,IAAIiO,IACrC,OAAEiK,GAAWF,EAEnB,IAAKE,GAAQjd,UAAU8C,OACrB,OAGF,MAAM4R,EAAeuI,EAAO6D,iBAAiBF,GAE7C,GAAIlM,GAAgB,EAClB,MAAO,CAAEuI,SAAQvI,eAErB,CACF,CASO,6BAAAqM,CACL1iB,GAEA,MAAM2iB,GAAgB,IAAAH,cAAaxiB,GAG7B4iB,EADiB3gB,MAAM6Z,KAAKnhB,KAAK2iB,YAAYrC,QACf4H,MAAM7iB,IACjC,IAAAwiB,cAAaxiB,KAAa2iB,IAGnC,GAAKC,EAIL,OAAOjoB,KAAK2iB,YAAY5W,IAAIkc,EAC9B,CAiBO,mBAAAE,CACLnO,EACAgK,GAEA,QAAiB/Z,IAAb+P,EACF,MAAM,IAAIrS,MAAM,uDAElB,QAAiCsC,IAA7B+Z,EAAiBmC,QACnB,MAAM,IAAIxe,MACR,uEAGJ,GAAI3H,KAAK6iB,aAAab,IAAIhI,GACxB,MAAM,IAAIrS,MACR,iCAAiCqS,sBAGrC,GACEgK,EAAiBJ,UACoB,mBAA9BI,EAAiBJ,SAExB,MAAM,IAAIjc,MACR,mEAOJ,MAAMoc,EAA8B,CAClCmC,QAAQ,EACRlM,WACAgK,mBACAe,UAAWC,KAAKC,MAChBY,YAAa,GAKf,OAFA7lB,KAAK6iB,aAAatF,IAAIvD,EAAU+J,GAEzBC,EAAiBmC,QACrB/d,MAAM6b,IACL,IAAKjkB,KAAK6iB,aAAa9W,IAAIiO,GAKzB,YAHA3I,QAAQC,KACN,oEAKJ,GAAI1C,OAAO7N,MAAMkjB,EAAO4B,aACtB,MAAM,IAAIle,MACR,iEAGJ,QAAmCsC,IAA/Bga,EAAO4B,YAAYwB,QACrB,MAAM,IAAI1f,MACR,2DAOJ3H,KAAK0mB,sCACHzC,EAAO4B,YAEP5B,EAAOjd,UAIT+c,EAAaE,OAASA,EACtBF,EAAa8B,YAAc5B,EAAO4B,YAClC7lB,KAAK+lB,yBAAyBhC,EAAa8B,aAE3C,MAAMC,EAA6D,CACjE7B,OAAQF,IAGV,IAAA1gB,cACE,IACA,IAAO+kB,0BACPtC,EACD,IAEFO,OAAOC,IAEN,MADAtmB,KAAK6iB,aAAapE,OAAOzE,GACnBsM,CAAK,GAEjB,CA8RQ,wBAAAnC,CAAyBF,GAC/B,KAAMA,aAAkB,KAItB,YAHA5S,QAAQC,KACN,oEAMJ,MAAM3G,EAAasZ,EAAOvZ,gBACpB2d,EAAsBpE,EAAOoE,oBAEnC,GAAiC,IAA7BA,EAAoBC,KAAxB,CAOA,IAAK,MAAOjjB,GAAS,OAAEkjB,MAAaF,EAAqB,CACvD,MAAMjjB,EAAQpF,KAAKyQ,SAASpL,GAE5B,IAAKD,EAAO,CACViM,QAAQC,KAAK,iBAAiBjM,yBAC9B,QACF,CAEA,MAAMmjB,EAAgBpjB,EAAM+X,eACtBrT,EAAS0e,EAAc1e,OAIvB2e,EAAY,IAAID,EAAc7pB,YAClCgM,EAAWyS,OACXmL,EACAze,GAIF1E,EAAM+X,aAAe,IAAMsL,EAEvBrjB,EAAMsjB,aACRtjB,EAAMsjB,WAAWD,UAAYA,UAGxBrjB,EAAMujB,WAGb3oB,KAAK4lB,wBAAwBxgB,EAAMygB,YACrC,CAEAxU,QAAQuX,IAAI,0CAA0C3E,EAAOjK,YAnC7D,CAoCF,qCC/7BF,MAEA,EAFgB,uCCAhB,MAAM6O,EAAqB,CACzBC,uBAAwB,IACxBC,qBAAsB,KAGxBld,OAAOmd,OAAOH,GAEd,2BCJA,IAAKzN,mBAAL,SAAKA,GAEH,4BAEA,wBAEA,sBAEA,mBACD,CATD,CAAKA,IAAAA,EAAW,KAWhB,2BCdA,IAAK6N,mBAAL,SAAKA,GAEH,mBAEA,oBAEA,yBAEA,kBAEA,qBACD,CAXD,CAAKA,IAAAA,EAAc,KAanB,wZCXA,MAAM,UAAEC,GAAc,UAStB,IAAKC,GAAL,SAAKA,GAEH,cAAYD,EAAUE,iBAAe,YAErC,4BAA0BF,EAAUG,yBAAuB,0BAE3D,4BAA0BH,EAAUI,yBAAuB,0BAE3D,4BAA0BJ,EAAUK,yBAAuB,yBAC5D,CATD,CAAKJ,IAAAA,EAAU,KAWf,cCtBKK,yBAAL,SAAKA,GACH,oBACA,mBACD,CAHD,CAAKA,IAAAA,EAAY,KAKjB,sBCDKC,cAAL,SAAKA,GAEH,YAEA,oBAEA,qBACD,CAPD,CAAKA,IAAAA,EAAmB,KCAxB,IAAYC,GAAZ,SAAYA,GAMV,oBAWA,cAOA,cASA,oBAMA,kBAMA,gBAEA,6BACD,CAhDD,CAAYA,IAAAA,EAAgB,KAkD5B,mICrBe,SAASC,EACtB5qB,GAEA,IAAKA,EACH,OAGF,MAAM,YAAE6qB,EAAW,mBAAEC,GAAuB9qB,EAAQ+qB,QAEpD,OAAOC,EAAuBH,EAAaC,EAC7C,CAYO,SAASE,EACdxmB,EACAG,GAEA,IAAKA,IAAsBH,EACzB,OAGF,MAAM2N,GAAkB,QAAmBxN,GAE3C,IAAKwN,GAAmBA,EAAgB8Y,iBACtC,OAGF,MAAMvmB,EAAWyN,EAAgBE,YAAY7N,GAI7C,IAAKE,EACH,OAGF,MAAMwmB,EAAsBxmB,EAASxC,yBAErC,MAAO,CACLwC,WACAyN,kBACA3N,aACAG,oBACAumB,sBAEJ,CASO,SAASC,EAA8B3mB,GAC5C,MAAM4mB,GAAmB,UAEzB,IAAK,IAAInhB,EAAI,EAAGA,EAAImhB,EAAiBrgB,OAAQd,IAAK,CAChD,MAAMkI,EAAkBiZ,EAAiBnhB,GAGzC,GAFiBkI,EAAgBE,YAAY7N,GAG3C,OAAOwmB,EAAuBxmB,EAAY2N,EAAgB1N,GAE9D,CACF,CAMO,SAAS4mB,IACd,MAAMC,EAAkB,GAYxB,OAVyB,UAER9Z,SAASW,IACNA,EAAgBoZ,eAExB/Z,SAAQ,EAAGxR,cACnBsrB,EAAgBzZ,KAAK+Y,EAAkB5qB,GAAS,GAChD,IAGGsrB,CACT,6gBC5DA,MAAME,EAAe,CAAC,EACtB,IAAIC,EAaJ,SAASC,EACPplB,EACA4B,GAGA,MAAMqH,EAAajJ,EAAQmH,QAAQ,KAC7Bke,EAASrlB,EAAQiH,UAAU,EAAGgC,GAC9Bqc,EAASJ,EAAaG,GAC5B,GAAIC,QAAyC,CAC3C,QAA2B1gB,IAAvBugB,EACF,OAAOA,EAAmBnlB,GAE5B,MAAM,IAAIsC,MAAM,wDAClB,CAEA,MAAMgc,EAAkBgH,EAAOtlB,EAAS4B,GAcxC,OAZA0c,EAAgBwC,QAAQ/d,MACtB,SAAUhD,IACR,IAAA/B,cAAa,IAAa,IAAOunB,aAAc,CAAExlB,SACnD,IACA,SAAUkhB,GACR,MAAMuE,EAAuD,CAC3DxlB,UACAihB,UAEF,IAAAjjB,cAAa,IAAa,IAAOynB,kBAAmBD,EACtD,IAEKlH,CACT,CAeA,SAASoH,EACP1lB,EACA4B,GAEA,GAAIA,EAAQgW,YACV,OAAOwN,EAAyBplB,EAAS4B,GAI3C,IAAI0c,EAAkB,IAAM6D,mBAAmBniB,GAC/C,QAAwB4E,IAApB0Z,EACF,OAAOA,EAIT,MAAMqH,EAAmB,IAAMtD,2BAA2BriB,GAC1D,GAAI2lB,GAAkB/G,QAAQgH,YAAY/E,OAAQ,CAGhD,MAAM,OAAEjC,EAAM,aAAEvI,GAAiBsP,EAKjC,OAHI/G,aAAkB,OACpBN,EAAkBM,EAAOiH,0BAA0B7lB,EAASqW,IAEvDiI,CACT,CAIA,MAAM4B,EAAc,IAAMwC,8BAA8B1iB,GACxD,OAAIkgB,GACF5B,EAAkB4B,EAAY5B,gBACvBA,IAITA,EAAkB8G,EAAyBplB,EAAS4B,GAE7C0c,EACT,CAaO,SAASwH,EACd9lB,EACA4B,EAA8B,CAAE2V,SAAU,EAAGC,YAAa,aAE1D,QAAgB5S,IAAZ5E,EACF,MAAM,IAAIsC,MAAM,sDAGlB,OAAOojB,EAA2B1lB,EAAS4B,GAASkf,OACtD,CAYO,SAASnJ,EACd3X,EACA4B,EAA8B,CAAE2V,SAAU,EAAGC,YAAa,aAE1D,QAAgB5S,IAAZ5E,EACF,MAAM,IAAIsC,MACR,8DAKJ,MAAMgc,EAAkBoH,EAA2B1lB,EAAS4B,GAU5D,OANK,IAAMugB,mBAAmBniB,IAC5B,IAAM8hB,mBAAmB9hB,EAASse,GAAiB0C,OAAO+E,IACxD/Z,QAAQC,KAAK8Z,EAAI,IAIdzH,EAAgBwC,OACzB,CASO,SAASkF,EACdrkB,EACAC,EAA8B,CAAE2V,SAAU,EAAGC,YAAa,aAE1D,IAAK7V,GAAgC,IAApBA,EAAS8C,OACxB,MAAM,IAAInC,MACR,oEAQJ,OAJoBX,EAASzE,KAAK8C,GACzB2X,EAAkB3X,EAAS4B,IAItC,CAYO,SAASqkB,EACdjd,EACApH,EAA+B,CAAC,EAChCskB,GAAe,GAEf,QAA0BthB,IAAtBoE,EACF,MAAM,IAAI1G,MACR,4EAIoBsC,IAApBhD,EAAQ5B,UACV4B,EAAQ5B,QAAU,YAAW,IAAAmmB,aAG/B,MAAM,QAAEnmB,EAAO,iBAAEomB,EAAgB,WAAEC,GAAezkB,EAE5C3B,EAAmB,EAAAqmB,SAAA,IAAa,mBAAoBtd,GAEpDvE,EAASxE,EAAiBO,KAAOP,EAAiBQ,SAElD,sBAAE8lB,IAA0B,IAAAC,wBAChC5kB,EAAQ6kB,iBACRhiB,GAIIoT,EAAkB,IAAI0O,EAC1BH,EAAmB,EAAI3hB,GAEnBiiB,EAAiB1mB,EAEvB,CAAC,mBAAoB,uBAAuBkL,SAASoM,IACnD,EAAAqP,wBAAwB/J,IAAI8J,EAAgB,CAC1CpP,OACA3U,SAAU,EAAA2jB,SAAA,IAAahP,EAAMtO,IAC7B,IAGJ,MAAM4d,EAAmB,EAAAN,SAAA,IAAa,mBAAoBtd,GAE1D,EAAA2d,wBAAwB/J,IAAI8J,EAAgB,CAC1CpP,KAAM,mBACN3U,SAAU,IACLikB,EACHxlB,cAAe,EACfylB,WAAY,EACZC,QAAS,EACTC,gBAAiB,EACjBC,oBAAqB,KAIzB,MAAMC,EAAaC,EACjB,CAAE5hB,WAAYuS,EAAiBwO,aAAYD,oBAC3CpmB,GACA,GAGIse,EAAkB,CACtBwC,QAAS7d,QAAQC,QAAQ+jB,IAM3B,OAHKf,GACH,IAAMpE,mBAAmB4E,EAAgBpI,GAEpCA,EAAgBwC,OACzB,CAWO,SAASqG,EACdzP,EACA9V,EAGI,CAAC,GAEL,GAAmC,IAA/B8V,GAAoBjT,OACtB,MAAM,IAAInC,MACR,6EAIJ,MAAM8kB,EAAkB,GAClBC,EAAc3P,EAAmBxa,KAAK8L,IAC1C,MAAMse,EAAkC,CACtCtnB,QACE4B,EAAQ2lB,oBAAoBve,IAAsB,YAAW,IAAAmd,eAC5DvkB,GAGL,OADAwlB,EAAgB7b,KAAK+b,EAAWtnB,SACzBimB,EAA2Bjd,EAAmBse,EAAW,IAGlE,MAAO,CAAE3lB,SAAUylB,EAAiBI,SAAUH,EAChD,CAEO,SAASH,EACdtlB,EACA5B,EACAkmB,GAAe,GAEf,MAAMjmB,EAAmB,EAAAqmB,SAAA,IAAa,mBAAoBtmB,GAEpDyE,EAASxE,EAAiBO,KAAOP,EAAiBQ,QAElDV,EAAQ,CACZC,QAASA,EACTynB,UAAW,EACXlgB,aAAc,EACdD,YAAa,EACb2J,OAAO,EACP5P,SAAU,EACVqmB,MAAO,EACPC,cAAe,EACfC,cAAe,IACfC,oBAAgBjjB,EAChBpE,KAAMP,EAAiBO,KACvBC,QAASR,EAAiBQ,QAC1BqnB,eAAWljB,EACXzJ,OAAQ8E,EAAiBO,KACzBtF,MAAO+E,EAAiBQ,QACxB4O,UAAMzK,EACN9D,mBAAoBb,EAAiBa,mBACrCE,gBAAiBf,EAAiBe,gBAClChE,QAAQ,GAGV,GAAI4E,EAAQ0D,WAAY,CACtB,MAAMuS,EAAkBjW,EAAQ0D,WAEhC,KAEIuS,aAA2BkQ,YAC3BlQ,aAA2BmQ,cAC3BnQ,aAA2BoQ,aAC3BpQ,aAA2BqQ,YAG7B,MAAM,IAAI5lB,MACR,mHAIJvC,EAAMygB,YAAc3I,EAAgBnB,WACpC3W,EAAM+X,aAAe,IAAMD,CAC7B,MAAO,IAAiC,IAA7BjW,EAAQwkB,iBAA2B,CAC5C,MAAM,SAAE9E,EAAQ,sBAAEiF,IAA0B,IAAAC,wBAC1C5kB,EAAQ6kB,iBACRhiB,GAGIoT,EAAkB,IAAI0O,EAAsB9hB,GAElD1E,EAAMygB,YAAcc,EACpBvhB,EAAM+X,aAAe,IAAMD,CAC7B,CAKAjW,EAAQykB,aAAatmB,GAErB,MAAMue,EAAkB,CACtBwC,QAAS7d,QAAQC,QAAQnD,IAO3B,OAJKmmB,GACH,IAAMpE,mBAAmB/hB,EAAMC,QAASse,GAGnCve,CACT,CASO,SAASooB,EAAgBnoB,GAa9B,IAAqBooB,gBAZE,EAAGC,wBACpBA,EAAkBroB,SACbqoB,EAAkBroB,UAAYA,IAezC,MAAMse,EAAkB,IAAM6D,mBAAmBniB,GAE7Cse,GACFA,EAAgBC,UAEpB,CASO,SAAS+J,EAAiB3mB,GAC/BA,EAASuJ,SAASlL,GAAYmoB,EAAgBnoB,IAChD,CAOO,SAASuoB,IACd,MAAMC,EAAc,IAAqBC,iBAEzCjiB,OAAOyU,KAAKuN,GAAatd,SAASoM,IAChC,MAAMoR,EAAWF,EAAYlR,GAE7B9Q,OAAOyU,KAAKyN,GAAUxd,SAASqM,IAC7B,MACM8Q,EADiBK,EAASnR,GAAUoR,MACDN,mBACnC,QAAEroB,EAAO,SAAE2U,GAAa0T,EAE9B,IAAIO,EAEA5oB,EACF4oB,EAAa,IAAMzG,mBAAmBniB,GAC7B2U,IACTiU,EAAa,IAAMnJ,oBAAoB9K,IAErCiU,GACFA,EAAWC,QACb,IAGF,IAAqBC,kBAAkBxR,EAAK,GAIhD,CAQO,SAASyR,EACd1D,EACA2D,GAEA9D,EAAaG,GAAU2D,CACzB,CAQO,SAASC,EACdD,GAEA,MAAME,EAAiB/D,EAEvB,OADAA,EAAqB6D,EACdE,CACT,CAMO,SAASC,IACd3iB,OAAOyU,KAAKiK,GAAcha,SACvB8d,UAAuB9D,EAAa8D,KAEvC7D,OAAqBvgB,CACvB,CAYO,SAASwkB,EACd1R,EACA9V,EAA+B,CAC7B6kB,iBAAkB,eAGpB,OAAOU,EAA4BzP,EAAoB9V,EACzD,CAYO,SAASynB,EACdrgB,EACApH,EAA+B,CAC7B6kB,iBAAkB,eAGpB,OAAOR,EAA2Bjd,EAAmBpH,EACvD,ygBCpeA,SAAS0nB,EACP1K,GAEA,MAAM,WAAErd,EAAU,SAAEoB,EAAQ,QAAEnB,EAAO,UAAEF,EAAS,OAAEX,GAAWie,GACvD,0BAAE2K,GAA8B5mB,EAEtC,IAAI6mB,EAAgB,EACc,QAA9BD,IACFC,EAAgB,GAGlB,MAAM7jB,EAAY,mBACZ8jB,EAAiB,CAAEC,mBAAoBF,GAQ7C,GANA7jB,EAAUgkB,cAAcpoB,GACxBoE,EAAUikB,WAAWpoB,GACrBmE,EAAUkkB,aAAavoB,GACvBqE,EAAUmkB,UAAUnpB,GAGhBie,EAAOmL,kBAAmB,EAvChC,SACEpkB,EACAqkB,EACAP,GAEAO,EAAiB9e,SAAQ,CAAC5F,EAAY3B,KACpC,MAAMsmB,EAAiB,sBAAyB,CAC9Crb,KAAM,aAAajL,IACnBuK,OAAQ5I,KACLmkB,IAGL9jB,EAAUyP,eAAe8U,SAASD,EAAe,IAInDtkB,EAAUyP,eAAe+U,iBAAiB,cAC5C,CA2BIC,CAA+BzkB,EAJgB,EAE5C0kB,sBAEyDZ,EAC9D,KAAO,EA9DT,SACE9jB,EACAL,EACAmkB,GAEA,MAAMa,EAAc,sBAAyB,CAC3C1b,KAAM,SACNV,OAAQ5I,KACLmkB,IAGL9jB,EAAUyP,eAAemV,WAAWD,EACtC,CAqDIE,CAAyB7kB,EAFNiZ,EAAOvZ,gBAEsBokB,EAClD,CAEA,OAAO9jB,CACT,CAMA,MAAM8kB,EAAgB,CAAC,EAEvB,IAAIC,EAeJ,SAASC,EACPhW,EACA/S,GAEA,MAAMqH,EAAa0L,EAASxN,QAAQ,KAC9Bke,EAAS1Q,EAAS1N,UAAU,EAAGgC,GACrC,IAAIqc,EAASmF,EAAcpF,GAE3B,GAAIC,QAAyC,CAC3C,GACyB,MAAvBoF,GAC+B,mBAAxBA,EAEP,MAAM,IAAIpoB,MACR,+BAA+B+iB,yBAInCC,EAASoF,CACX,CAEA,MAAM/L,EAAmB2G,EAAO3Q,EAAU/S,GAmB1C,OAjBA,IAAAgpB,qCAAoCjW,GAGpCgK,EAAiBmC,QAAQ/d,MACvB,SAAU6b,IACR,OAAa,IAAa,IAAOiM,cAAe,CAAEjM,UACpD,IACA,SAAUqC,GACR,MAAMuE,EAAwD,CAC5D7Q,WACAsM,UAGF,OAAa,IAAa,IAAO6J,qBAAsBtF,EACzD,IAGK7G,CACT,CAWO,SAAS7J,EACdH,EACA/S,EAA+B,CAAED,SAAU,KAE3C,QAAiBiD,IAAb+P,EACF,MAAM,IAAIrS,MAAM,wDAGlB,IAAIqc,EAAmB,IAAMc,oBAAoB9K,GAEjD,YAAyB/P,IAArB+Z,EACKA,EAAiBmC,SAG1BnC,EAAmBgM,EAA2BhW,EAAU/S,GAEjD+c,EAAiBmC,QAAQ/d,MAAM6b,IACpCA,EAAOjZ,UAAY2jB,EAAgC1K,GAC5CA,KAEX,CAWOhT,eAAemf,EACpBpW,EACA/S,GAEA,QAAiBgD,IAAb+P,EACF,MAAM,IAAIrS,MACR,kEAIJ,IAAIqc,EAAmB,IAAMc,oBAAoB9K,GAEjD,YAAyB/P,IAArB+Z,IAIJA,EAAmBgM,EAA2BhW,EAAU/S,GAExD+c,EAAiBmC,QAAQ/d,MAAM6b,IAC7BA,EAAOjZ,UAAY2jB,EAAgC1K,EAAO,IAG5D,IAAMkE,oBAAoBnO,EAAUgK,GAAkBqC,OAAO+E,IAC3D,MAAMA,CAAG,KAVFpH,EAAiBmC,OAc5B,CAcOlV,eAAeof,EACpB1K,EACA1e,GAEA,MAAMqpB,EAAmB,IAAM9K,UAAUG,GACzC,IAAK2K,EACH,MAAM,IAAI3oB,MACR,4DAA4Dge,qBAIhE,IAAI,SAAE3L,GAAa/S,EACnB,MAAM,aAAEyV,GAAiBzV,OAERgD,IAAb+P,IACFA,GAAW,IAAAwR,WAGb,MAAM,SAAExjB,EAAQ,WAAEpB,EAAU,QAAEC,EAAO,OAAEb,EAAM,UAAEW,GAAc2pB,EAEvDC,EADaD,EAAiB5lB,gBACJZ,QAE1B,iBAAE0mB,EAAgB,SAAE7J,GAAa8J,EACrC/T,EACA6T,GAIIZ,EAAc,sBAAyB,CAC3C1b,KAAM,SACN8a,mBAAoB,EACpBxb,OAAQid,IAGJE,EAAmB,mBAEzBA,EAAiB1B,cAAcpoB,GAC/B8pB,EAAiBzB,WAAWpoB,GAC5B6pB,EAAiBxB,aAAavoB,GAC9B+pB,EAAiBvB,UAAUnpB,GAC3B0qB,EAAiBjW,eAAemV,WAAWD,GAE3C,MAAMgB,EAAgB,IAAI,IAAY,CACpC3W,WACAhS,SAAU,IAAUA,GACpBpB,WAAY,CAACA,EAAW,GAAIA,EAAW,GAAIA,EAAW,IACtDC,UACAb,SACAW,YACAqE,UAAW0lB,EACX/lB,WAAY6lB,EACZ3K,YAAac,EACb3f,SAAU,GACV2e,uBAGI3B,EAAmB,CACvBmC,QAAS7d,QAAQC,QAAQooB,IAK3B,aAFM,IAAMxI,oBAAoBnO,EAAUgK,GAEnC2M,CACT,CAYO,SAASC,EACd3pB,EACA+S,EACAuR,GAAe,GAEf,MAAM,SAAEvjB,EAAQ,WAAEpB,EAAU,QAAEC,EAAO,OAAEb,EAAM,UAAEW,EAAS,aAAE+V,GACxDzV,EAEF,IAAI,WAAE0D,GAAe1D,EAGrB,MAAM4pB,EAAiB,CACrB,aACA,eACA,cACA,cAGIN,EAAe3pB,EAAW,GAAKA,EAAW,GAAKA,EAAW,GAGhE,IAAK+D,IAAekmB,EAAe3J,SAASvc,EAAWhM,YAAYsV,MAAO,CAExE,IAAKyI,GAAcC,OAASkU,EAAe3J,SAASxK,EAAaC,MAC/D,MAAM,IAAIhV,MACR,qIAKD6oB,iBAAkB7lB,GAAe8lB,EAClC/T,EACA6T,GAEJ,MAGiBtmB,IAAb+P,IACFA,GAAW,IAAAwR,WAGb,MAAMzH,EAAe,IAAMyB,UAAUxL,GAErC,GAAI+J,EACF,OAAOA,EAGT,MAAM4C,EAAWhc,EAAaA,EAAWyS,OAAOrB,WAA4B,EAAfwU,EAI7D,IADoB,IAAMlN,YAAYsD,GAEpC,MAAM,IAAIhf,MAAM,IAAO2f,qBAGzB,MAAMqI,EAAc,sBAAyB,CAC3C1b,KAAM,SACN8a,mBAAoB,EACpBxb,OAAQ5I,IAGJK,EAAY,mBAElBA,EAAUgkB,cAAcpoB,GACxBoE,EAAUikB,WAAWpoB,GACrBmE,EAAUkkB,aAAavoB,GACvBqE,EAAUmkB,UAAUnpB,GACpBgF,EAAUyP,eAAemV,WAAWD,GAEpC,MAAMgB,EAAgB,IAAI,IAAY,CACpC3W,WACAhS,SAAU,IAAUA,GACpBpB,WAAY,CAACA,EAAW,GAAIA,EAAW,GAAIA,EAAW,IACtDC,UACAb,SACAW,YACAqE,UAAWA,EACXL,aACAkb,YAAac,EACb5J,mBAAoB9V,EAAQ8V,oBAAsB,GAClD4I,mBAAoB1e,EAAQ0e,mBAC5B3e,SAAUC,EAAQD,UAAY,KAGhC,GAAIukB,EACF,OAAOoF,EAGT,MAAM3M,EAAmB,CACvBmC,QAAS7d,QAAQC,QAAQooB,IAI3B,OAFA,IAAMxI,oBAAoBnO,EAAUgK,GAE7B2M,CACT,CAEO1f,eAAe6f,EACpB9W,EACAhT,EACAC,EAGI,CAAC,GAEL,MAAM,aAAEskB,GAAe,GAAUtkB,EAEjC,QAAiBgD,IAAbjD,EACF,MAAM,IAAIW,MACR,4EAIJ,QAAiBsC,IAAb+P,EACF,MAAM,IAAIrS,MACR,4EAIJ,MAAMoc,EAAe,IAAMyB,UAAUxL,GAErC,GAAI+J,EACF,OAAOzb,QAAQC,QAAQwb,GAGzB,MAAMgN,GAAc,IAAAC,iCAAgChqB,EAAUgT,GAOxDiX,EAAgBF,EAAY/pB,SAASzE,KAAI,CAAC8C,EAASqW,IAC/B,IAAM8L,mBAAmBniB,GAE1B8gB,QAAQ/d,MAAMhD,IACnC,MAAMqjB,EAAYrjB,EAAM+X,eAClBoL,EAAS7M,EAAetW,EAAMS,KAAOT,EAAMU,QAEhDirB,EAAYpmB,WAAmC4S,IAAIkL,EAAWF,EAAO,YAIpEjgB,QAAQkJ,IAAIyf,GAElB,MAAMhN,EAAS,IAAI,IAAY,IAC1B8M,EACHhU,mBAAoB/V,KACjBC,KAML,IAAAiqB,mCAAkCjN,GAElC,MAAMD,EAAmB,CACvBmC,QAAS7d,QAAQC,QAAQ0b,IAG3B,OAAIsH,GAIJ,IAAMpD,oBAAoBnO,EAAUgK,GAH3BA,EAAiBmC,OAM5B,CAQO,SAASgL,EACdzG,EACA0G,GAEAtB,EAAcpF,GAAU0G,CAC1B,CAGO,SAASC,IACd,OAAOxlB,OAAOyU,KAAKwP,EACrB,CASO,SAASwB,EACdF,GAEA,MAAMG,EAAkBxB,EAIxB,OAFAA,EAAsBqB,EAEfG,CACT,CAEO,SAASC,IACd,OAAOzB,EAAoB9b,IAC7B,CAWOhD,eAAewgB,EACpB9L,EACA1e,EAAU,CAAC,GAEX,OAAOopB,EAA4B1K,EAAoB,IAClD1e,EACHyV,aAAc,CACZC,KAAM,eAGZ,CAUO1L,eAAeygB,EACpBzqB,EACA+S,EACAuR,GAAe,GAQf,OANKtkB,EAAQ0D,aACX1D,EAAQ0D,WAAa,IAAIyiB,WACvBnmB,EAAQL,WAAW,GAAKK,EAAQL,WAAW,GAAKK,EAAQL,WAAW,KAIhEgqB,EAAkB3pB,EAAS+S,EAAUuR,EAC9C,CAaA,SAASkF,EACP/T,EAIA6T,GAEA,MAAM,iBAAEoB,IAAqB,UAAmBC,WAE1C,sBAAEhG,EAAqB,SAAEjF,IAAa,IAAAkF,wBAC1CnP,GAAcC,KACd4T,EACA,CACEsB,gBAAiBF,EACjBG,gBAAgB,IAKpB,IADoB,IAAMzO,YAAYsD,GAEpC,MAAM,IAAIhf,MAAM,IAAO2f,qBAGzB,IAAIkJ,EACJ,GAAI9T,GAAcqV,oBAAqB,UACrC,OAAQrV,EAAaC,MACnB,IAAK,eACH6T,GAAmB,IAAAwB,0BAAyBzB,GAC5C,MACF,IAAK,aACHC,GAAmB,IAAAyB,wBAAuB1B,GAC1C,MACF,IAAK,cAGL,IAAK,aACHC,GAAmB,IAAA0B,yBAAwB3B,GAC3C,MACF,QACE,MAAM,IAAI5oB,MACR,0GAIN6oB,EAAmB,IAAI5E,EAAsB2E,GAG/C,MAAO,CAAEC,mBAAkB7J,WAC7B,8DC3nBA,MAAMwL,EAAuB,IAAI,IAAmB,iBAEpDA,EAAqBC,UAAY,EAEjCD,EAAqBE,2BAA2B,IAAYC,YAAa,KACzEH,EAAqBE,2BAA2B,IAAYE,UAAW,KACvEJ,EAAqBE,2BAA2B,IAAYhX,SAAU,KAEtE,sEC8BA,MAAMmX,EA0BJ,WAAA7zB,CAAY6E,GAtBJ,KAAAivB,YAAc,CACpBC,YAAa,EACbC,UAAW,EACXC,SAAU,EACVC,QAAS,GAmBT7yB,KAAKwD,GAAKA,IAAU,IAAAgoB,UAEpBxrB,KAAK6tB,YAAc,CACjB6E,YAAa,CAAE,EAAG,IAClBC,UAAW,CAAE,EAAG,IAChBC,SAAU,CAAE,EAAG,IACfC,QAAS,CAAE,EAAG,KAGhB7yB,KAAKoyB,UAAY,EACjBpyB,KAAK8yB,OAAQ,EAEb9yB,KAAKyyB,YAAc,CACjBC,YAAa,EACbC,UAAW,EACXC,SAAU,EACVC,QAAS,GAGX7yB,KAAK+yB,eAAiB,CACpBL,YAAa,EACbC,UAAW,EACXC,SAAU,EAOVC,QAAS,IAEb,CASO,0BAAAR,CACL1V,EACAoW,GAEA/yB,KAAK+yB,eAAepW,GAAQoW,CAC9B,CAOO,0BAAAC,CAA2BrW,GAChC,OAAO3c,KAAK+yB,eAAepW,EAC7B,CAMO,OAAAsW,GACDjzB,KAAKkzB,eACP1qB,OAAO2qB,aAAanzB,KAAKkzB,cAE7B,CAcO,UAAAE,CACLC,EACA1W,EACA+Q,EACA9Q,EAAW,GAGX,MAAM0W,EAA0C,CAC9CD,YACA1W,OACA+Q,0BAIuCzjB,IAArCjK,KAAK6tB,YAAYlR,GAAMC,KACzB5c,KAAK6tB,YAAYlR,GAAMC,GAAY,IAIrC5c,KAAK6tB,YAAYlR,GAAMC,GAAUhM,KAAK0iB,GAEtCtzB,KAAKuzB,eACP,CAQO,cAAA9F,CACL+F,GAEA3nB,OAAOyU,KAAKtgB,KAAK6tB,aAAatd,SAASoM,IACrC,MAAME,EAAc7c,KAAK6tB,YAAYlR,GACrC9Q,OAAOyU,KAAKzD,GAAatM,SAASqM,IAChCC,EAAYD,GAAYC,EAAYD,GAAUpP,QAC3C8lB,GACQE,EAAeF,IAEzB,GACD,GAEN,CASO,iBAAAnF,CAAkBxR,GACvB,IAAK3c,KAAK6tB,YAAYlR,GACpB,MAAM,IAAIhV,MAAM,4BAA4BgV,WAE9C3c,KAAK6tB,YAAYlR,GAAQ,CAAE,EAAG,GAChC,CAEQ,YAAA8W,CAAa9W,GACnB,MAAM+W,EAAiB1zB,KAAK+yB,eAAepW,GAAQ3c,KAAKyyB,YAAY9V,GACpE,IAAIgX,EAAiB,EAErB,IAAK,IAAI3qB,EAAI,EAAGA,EAAI0qB,EAAgB1qB,IAAK,CACvC,MAAMsqB,EAAiBtzB,KAAK4zB,eAAejX,GAC3C,GAAuB,OAAnB2W,EACF,OAAO,EACF,GAAIA,EAAgB,CAIzB,IAAIO,EAHJ7zB,KAAKyyB,YAAY9V,KACjB3c,KAAK8yB,OAAQ,EAGb,IACEe,EAAgBP,EAAeD,WACjC,CAAE,MAAOlqB,GAEPkI,QAAQC,KAAK,qBAAsBnI,EACrC,CACI0qB,GAAeC,QACjBD,EAAcC,SAAQ,KACpB9zB,KAAKyyB,YAAY9V,KACjB3c,KAAK+zB,YAAY,KAInB/zB,KAAKyyB,YAAY9V,KACjBgX,IAEJ,CACF,CAKA,OAJIA,GACF3zB,KAAK+zB,cAGA,CACT,CAEQ,cAAAH,CAAejX,GACrB,MAAMqX,EAAwBh0B,KAAKi0B,wBAAwBtX,GAC3D,IAAK,MAAMC,KAAYoX,EACrB,GAAIh0B,KAAK6tB,YAAYlR,GAAMC,GAAU9S,OACnC,OAAO9J,KAAK6tB,YAAYlR,GAAMC,GAAUhF,QAI5C,OAAO,IACT,CAEU,aAAA2b,GACR,MAAMW,EAAkCl0B,KAAKyzB,aAC3C,IAAYnB,aAER6B,EAAgCn0B,KAAKyzB,aACzC,IAAYlB,WAER6B,EAA+Bp0B,KAAKyzB,aACxC,IAAYpY,UAERgZ,EAA8Br0B,KAAKyzB,aAAa,IAAYa,SAG/DJ,GACAC,GACAC,GACAC,IAEDr0B,KAAK8yB,OAAQ,EAEjB,CAEU,UAAAiB,GACH/zB,KAAK8yB,aAIa7oB,IAAnBjK,KAAKoyB,UAIFpyB,KAAKkzB,gBACRlzB,KAAKkzB,cAAgB1qB,OAAOC,YAAW,KACrCzI,KAAKkzB,cAAgB,KACrBlzB,KAAKuzB,eAAe,GACnBvzB,KAAKoyB,YAGVpyB,KAAKuzB,gBAET,CAEU,uBAAAU,CAAwBtX,GAKhC,OAJmB9Q,OAAOyU,KAAKtgB,KAAK6tB,YAAYlR,IAC7Cpa,IAAIqM,QACJpB,QAAQoP,GAAa5c,KAAK6tB,YAAYlR,GAAMC,GAAU9S,SACtD4J,MAAK,CAACZ,EAAGC,IAAMD,EAAIC,GAExB,CASA,cAAA+a,GACE,OAAO9tB,KAAK6tB,WACd,qKC3UK,SAASoC,EAAoCjW,GAClD,MAAM,wBAAEua,IAA4B,UAC9BC,GAAe,UAEOD,GAA2BC,GAKvD,IAAYC,qBACV,EAAAzZ,OAAO0Z,gCACNlrB,IACC,GAAIA,EAAImrB,OAAO3a,WAAaA,EAC1B,OAKFkX,EAFe,KAAM1L,UAAUxL,GAEU,GAG/C,CAQO,SAASkX,EAAkCjN,GAChD,KAAMA,aAAkB,MACtB,OAGF,MAAMtZ,EAAasZ,EAAOvZ,gBAE1BuZ,EAAOoE,oBAAoBC,KAAO,EAcpC,SAAqCrE,EAAQtZ,GAC3CsZ,EAAOoE,oBAAoB9X,SAAQ,EAAGgY,UAAUljB,KAC9C,MAAMD,EAAQ,KAAMqL,SAASpL,GACxBD,IAILwvB,EAA+BxvB,EAAOuF,EAAY4d,GAClD,KAAMhC,wBAAwBnhB,EAAMygB,aAAY,GAEpD,CAvBMgP,CAA4B5Q,EAAQtZ,GAkC1C,SAA8BsZ,EAAQtZ,GACpC,IAAImqB,EAAuBnqB,EAE3B,MAAMoqB,EAAyB9Q,EAAOjd,SAASkhB,MAAM7iB,GACrC,KAAMoL,SAASpL,KAI/B,IAAK0vB,EACH,OAGF,MAAMC,EAAc,KAAMvkB,SAASskB,GAC7BE,EACJD,EAAYtM,YAAYD,WAAauM,EAAY7X,eAG/CxS,EAAWhM,cAAgBs2B,EAAgBt2B,cAE7Cm2B,EAAuB,IAAIG,EAAgBt2B,YAAYgM,EAAWb,QAGlEgrB,EAAqBvX,IAAI5S,IAG3BsZ,EAAOjd,SAASuJ,SAASlL,IACvB,MAAMD,EAAQ,KAAMqL,SAASpL,GAC7B,IAAKD,EACH,OAGF,MACMmjB,EADQtE,EAAOiR,gBAAgB7vB,GACdD,EAAM+X,eAAepB,WAE5C6Y,EAA+BxvB,EAAO0vB,EAAsBvM,GAC5D,KAAMhC,wBAAwBnhB,EAAMygB,YAAY,GAEpD,CAtEMsP,CAAqBlR,EAAQtZ,EACnC,CAuEA,SAASiqB,EAA+BxvB,EAAOuF,EAAY4d,GACzD,MAAME,EAAYrjB,EAAMsjB,WACpBtjB,EAAMsjB,WAAWD,UACjBrjB,EAAM+X,eAEJiY,EAAO,IAAI3M,EAAU9pB,YACzBgM,EAAWyS,OACXmL,EACAE,EAAU3e,QAGZ1E,EAAM+X,aAAe,IAAMiY,EAEvBhwB,EAAMsjB,aACRtjB,EAAMsjB,WAAWD,UAAY2M,GAG/BhwB,EAAMujB,WAAa,CACjBvL,OAAQzS,EAAWyS,OACnBmL,SAEJ,kKC1IA,MAAM8M,EAAa,IAAIzS,IAOvB,SAAS0S,EAAiBthB,GACxBqhB,EAAW9X,IAAIvJ,EAASuhB,KAAMvhB,EAChC,CAOA,SAASF,EAAYG,GACnB,OAAOohB,EAAWtpB,IAAIkI,EACxB,CAOA,SAASuhB,IACP,OAAOluB,MAAM6Z,KAAKkU,EAAW/U,OAC/B,CAQA,SAASmV,EAAqBC,EAAWxyB,GACvC,MAAMyyB,EAAe,IAAaC,eAAerzB,KAAKszB,GACpD,IAAaC,gBAAgBD,KAGzBE,EAAgBP,IAAmBjzB,KAAKyzB,GAC5CliB,EAAYkiB,KAMRC,EAHYN,EAAaO,OAAOH,GAGJ7N,MAAMlU,IACtC,MAAQmiB,UAAWC,GAAoBpiB,EAEvC,GAAIoiB,EAAgBtsB,SAAW4rB,EAAU5rB,OACvC,OAAO,EAGT,IAAK,IAAId,EAAI,EAAGA,EAAIotB,EAAgBtsB,OAAQd,GAAK,EAC/C,KACG,QACCotB,EAAgBxW,MAAM5W,EAAI,EAAGA,EAAI,GACjC0sB,EAAU9V,MAAM5W,EAAI,EAAGA,EAAI,IAG7B,OAAO,EAIX,OAAO,CAAI,IAGb,IAAKitB,EACH,OAAO,KAGT,MAAMI,EAAU,GAChB,IAAI,OAASnzB,EAAO,aAAc,CAChC,MAAMozB,EAAgBpzB,EACnB0X,cACA2b,iBAAiB,GACjBC,iBAEH,IAAKF,EACH,MAAO,CACLriB,KAAMgiB,EAAgBV,MAI1B,IAAK,IAAIvsB,EAAI,EAAGA,EAAIstB,EAAcxsB,OAAQd,GAAK,EAC7CqtB,EAAQzlB,KAAK,CACX0O,MAAOgX,EAActtB,GACrBqtB,QAASC,EAActtB,EAAI,IAGjC,CAEA,MAAO,CACLiL,KAAMgiB,EAAgBV,KACtBc,UAEJ,kDCpGe,SAASI,EACtB72B,GAEA,MAAM82B,EAAO,mBACb,IAAI72B,EAAQ,EACRC,EAAQ,KAYZ,OAVEF,QACmBqK,IAAnBrK,EAASC,YACUoK,IAAnBrK,EAASE,QAETD,EAAQD,EAASC,MACjBC,EAAQF,EAASE,OAEnB42B,EAAKC,YAAY92B,EAAO,EAAK,EAAK,GAClC62B,EAAKC,YAAY72B,EAAO,EAAK,EAAK,GAE3B42B,CACT,8LCuCA,QAlDA,SACEjzB,GAEA,MAAMiK,EAASjK,EAASuL,aAElB,yBAAE4nB,EAAwB,YAAE1c,IAChC,OAAqCzW,EAAUiK,GAEjD,IAAKwM,EACH,OAGF,MAAM,gBAAE9K,EAAe,WAAEzB,GAAeD,EAElCmpB,EAAapzB,EAChBN,YACA+kB,MACEpV,GACCA,EAAEgkB,cAAgB5c,EAAYF,UAAYlH,EAAEjC,MAAQqJ,EAAYF,WAGjE6c,GACHxlB,QAAQC,KAAK,sCAAuC4I,EAAYF,UAGlE,MAAMO,EAAcsc,EAAW3zB,MACzB6zB,GAAa,OAAcxc,EAAanL,EAAiBzB,IAEzD,IAAE4J,EAAG,IAAErK,EAAG,QAAEwU,GAAYqV,EAGxBC,EAAiBp2B,KAAKC,OAAOqM,EAAMqK,GAAOqf,GAA4B,EAG5E,IAAIK,GAAevV,EAAUnK,IAAQrK,EAAMqK,GAAQyf,EAUnD,OATAC,EAAar2B,KAAK6O,MAAMwnB,GAGpBA,EAAaD,EAAiB,EAChCC,EAAaD,EAAiB,EACrBC,EAAa,IACtBA,EAAa,GAGR,CACLD,iBACAC,aAEJ,mBC1DA,SAASC,EAAyBC,GAChC,MAAM7O,EAAO6O,EAAiBC,UACxB7jB,EAAS,GACf,IAAK,IAAIhH,EAAQ,EAAGA,EAAQ+b,EAAM/b,IAAS,CACzC,MAAM8qB,EAAa,GAEnBF,EAAiBG,aAAa/qB,EAAO8qB,GAErC9jB,EAAO3C,KAAKymB,EACd,CAEA,OAAO9jB,CACT,CAEA,SAASgkB,EAAyBJ,EAAkBK,GAC7CA,GAAO1tB,SAIZqtB,EAAiBM,kBAEjBD,EAAMjnB,SAASmnB,IACbP,EAAiBR,eAAee,EAAK,IAEzC,gGCde,SAASC,EAAsB3sB,EAAWhJ,GAIvD,OAHwBgJ,EAAUI,aAAapJ,GACjBO,IAAI3B,KAAKC,MAGzC,mECOe,SAASwC,EACtBu0B,EAAkB,IAClBjb,EACAgY,EAAkB,MAElB,IAAKhY,EACH,MAAM,IAAIhV,MAAM,8BAGlB,MAAMkwB,EAAQ,IAAIC,YAAYnb,EAAM,CAClCgY,SACAoD,YAAY,IAGd,OAAOH,EAAGI,cAAcH,EAC1B,wECwNA,QAzPA,MACE,WAAAl5B,GACEqB,KAAKi4B,eAAiB,CAAC,EACvBj4B,KAAKk4B,kBAAoB,IAAI,IAAmB,YAClD,CAcA,cAAAC,CAAeC,EAAYC,EAAUpxB,EAAU,CAAC,GAC9C,MAAM,mBACJqxB,EAAqB,EAAC,UACtBC,GAAY,EAAK,oBACjBC,EAAsB,CACpB1b,SAAS,EACT2b,kBAAmB,MAEnBxxB,EAEJ,GAAIjH,KAAKi4B,eAAeG,KAAgBG,EAEtC,YADAlnB,QAAQC,KAAK,gBAAgB8mB,+BAI3BG,GAAav4B,KAAKi4B,eAAeG,IAAaM,qBAChDC,cAAc34B,KAAKi4B,eAAeG,GAAYM,qBAGhD,MAAME,EAAmB,CACvBP,SAAU,KACVQ,UAAW,GACXC,aAAc,GACdC,eAAgB,GAEhBC,cAAe,GAEfR,oBAAqBA,EAAoB1b,QACzC4b,oBAAqB,KACrBD,kBAAmBD,EAAoBC,mBAGzCG,EAAiBE,aAAexxB,MAAMgxB,GAAoBW,KAAK,GAC/DL,EAAiBG,eAAiBzxB,MAAMgxB,GAAoBW,KAAK,MAEjE,IAAK,IAAIjwB,EAAI,EAAGA,EAAIsvB,EAAoBtvB,IAAK,CAC3C,MAAMkwB,EAASb,IACfO,EAAiBC,UAAUjoB,KAAK,KAAasoB,IAC7CN,EAAiBI,cAAcpoB,KAAKsoB,GACpCN,EAAiBP,SAAWA,CAC9B,CAEAr4B,KAAKi4B,eAAeG,GAAcQ,CACpC,CAEA,gBAAAO,CAAiBf,GACf,MAAMQ,EAAmB54B,KAAKi4B,eAAeG,GAE7C,IAAKQ,EAEH,OADAvnB,QAAQiV,MAAM,gBAAgB8R,yBACvB,KAIT,MAAMgB,EAAkBR,EAAiBC,UAAUrrB,QAChD6rB,GAA0B,OAAbA,IAGhB,IAAIC,EAAe,EACfC,EAAeX,EAAiBE,aAAa,IAAM,EACvD,IAAK,IAAI9vB,EAAI,EAAGA,EAAIowB,EAAgBtvB,OAAQd,IAAK,CAC/C,MAAMwwB,EAAmBZ,EAAiBE,aAAa9vB,IAAM,EACzDwwB,EAAmBD,IACrBD,EAAetwB,EACfuwB,EAAeC,EAEnB,CAGA,GAAiD,OAA7CZ,EAAiBC,UAAUS,GAAwB,CACrD,MAAMJ,EAASN,EAAiBP,WAChCO,EAAiBC,UAAUS,GAAgB,KAAaJ,GACxDN,EAAiBI,cAAcM,GAAgBJ,CACjD,CAMA,OAHAN,EAAiBE,aAAaQ,IAAiB,EAGxC,CACLG,IAAKb,EAAiBC,UAAUS,GAChC/sB,MAAO+sB,EAEX,CAkBA,WAAAI,CACEtB,EACAuB,EACAC,EAAO,CAAC,GACR,YACE/c,EAAc,EAAAzB,YAAYkZ,QAAO,SACjC1X,EAAW,EAAC,QACZ3V,EAAU,CAAC,EAAC,UACZ4yB,EAAY,IACV,CAAC,GAEL,OAAO,IAAIvxB,SAAQ,CAACC,EAASuxB,KA6D3B95B,KAAKk4B,kBAAkB9E,YA5DLniB,UAChB,MAAM,IAAEwoB,EAAG,MAAEltB,GAAUvM,KAAKm5B,iBAAiBf,GAC7C,IAAKqB,EAAK,CACR,MAAMnT,EAAQ,IAAI3e,MAChB,qCAAqCywB,MAIvC,OAFA/mB,QAAQiV,MAAMA,QACdwT,EAAOxT,EAET,CAEA,IAGE,IAAIyT,EAAiB,GACjBF,EAAU/vB,SACZiwB,EAAiBF,EAAUt3B,KAAKy3B,GACvB,KAAcA,MAGzB,MAAMpB,EAAmB54B,KAAKi4B,eAAeG,GAE7CQ,EAAiBqB,YAAa,EAE9B,MAAMC,QAAgBT,EAAIE,GAAYC,KAASG,GAE/CnB,EAAiBqB,YAAa,EAC9BrB,EAAiBG,eAAexsB,GAASyY,KAAKC,MAI5C2T,EAAiBJ,sBAChBI,EAAiBF,qBAClBE,EAAiBH,oBAEjBG,EAAiBF,oBAAsByB,aAAY,KACjDn6B,KAAKo6B,qBACHhC,EACAQ,EAAiBH,kBAClB,GACAG,EAAiBH,oBAGtBlwB,EAAQ2xB,EACV,CAAE,MAAO9O,GACP/Z,QAAQiV,MACN,2BAA2BqT,iBAA0BvB,MACrDhN,GAEF0O,EAAO1O,EACT,SACEprB,KAAKi4B,eAAeG,GAAYU,aAAavsB,IAC/C,IAUAsQ,EACA5V,EACA2V,EACD,GAEL,CAEA,oBAAAwd,CAAqBhC,EAAYK,GAC/B,MAAMG,EAAmB54B,KAAKi4B,eAAeG,GAE7C,GAAIQ,EAAiBqB,WACnB,OAGF,MAAMhV,EAAMD,KAAKC,MAEjB2T,EAAiBC,UAAUtoB,SAAQ,CAAC8pB,EAAG9tB,KACrC,MAAMwsB,EAAiBH,EAAiBG,eAAexsB,KAElC,OAAnBwsB,GAA2BH,EAAiBE,aAAavsB,GAAS,IACnD0Y,EAAM8T,EAEWN,GAChCz4B,KAAKs6B,wBAAwBlC,EAAY7rB,EAC3C,GAEJ,CAEA,SAAAguB,CAAUnC,GACR,MAAMQ,EAAmB54B,KAAKi4B,eAAeG,GACxCQ,EAKLA,EAAiBC,UAAUtoB,SAAQ,CAAC8pB,EAAG9tB,KACrCvM,KAAKs6B,wBAAwBlC,EAAY7rB,EAAM,IAL/C8E,QAAQiV,MAAM,gBAAgB8R,wBAOlC,CAGA,uBAAAkC,CAAwBlC,EAAY7rB,GAClC,MAAMqsB,EAAmB54B,KAAKi4B,eAAeG,GACvCoC,EAAiB5B,EAAiBC,UAAUtsB,GAE3B,OAAnBiuB,IACFA,EAAe,QACf5B,EAAiBI,cAAczsB,GAAOguB,YAGtC3B,EAAiBC,UAAUtsB,GAAS,KACpCqsB,EAAiBG,eAAexsB,GAAS,KAE7C,+CCpPF,MAAMkuB,EAA4B,CAChCC,YAAa,GACbC,SAAU,GACVC,QAAS,CACPnoB,EAAG,GACH0E,EAAG,IAEL0jB,WAAY,CACVpoB,EAAG,EACH0E,EAAG,GAEL2jB,wBAAyB,gHAMrBC,EAAiC,CACrCtoB,EAAG,IACH0E,EAAG,IAGC6jB,EAAa,gFAIbC,EAAY,0JAKZC,EAAe,2iBACfC,EAAiB,+HACjBC,EAAc,+MAEdC,EAAiD,CACrDC,MAAOpd,EAAOuc,EAAM,CAClBC,YAAa,uMAGbE,QAAS,CACPnoB,EAAG,KACH0E,EAAG,QAGPokB,cAAerd,EAAOuc,EAAM,CAC1BC,YAAa,+NAGbE,QAAS,CACPnoB,EAAG,GACH0E,EAAG,MAGPqkB,cAAetd,EAAOuc,EAAM,CAC1BC,YAAa,i0BAQbE,QAAS,CACPnoB,EAAG,GACH0E,EAAG,MAGPskB,UAAWvd,EAAOuc,EAAM,CACtBC,YAAa,gVAQbE,QAAS,CACPnoB,EAAG,GACH0E,EAAG,MAGPukB,UAAWxd,EAAOuc,EAAM,CACtBC,YAAa,oFACbE,QAAS,CACPnoB,EAAG,GACH0E,EAAG,MAGPwkB,cAAezd,EAAOuc,EAAM,CAC1BC,YAAa,sNAGbE,QAAS,CACPnoB,EAAG,GACH0E,EAAG,MAGPykB,YAAa1d,EAAOuc,EAAM,CACxBC,YAAa,w8EAgCbE,QAAS,CACPnoB,EAAG,GACH0E,EAAG,MAGP0kB,oBAAqB3d,EAAOuc,EAAM,CAChCC,YAAa,usFAkCbE,QAAS,CACPnoB,EAAG,GACH0E,EAAG,MAGP2kB,OAAQ5d,EAAOuc,EAAM,CACnBC,YAAa,oOAGbE,QAAS,CACPnoB,EAAG,GACH0E,EAAG,MAGP4kB,MAAO7d,EAAOuc,EAAM,CAClBC,YAAa,wXAKbE,QAAS,CACPnoB,EAAG,KACH0E,EAAG,QAGP6kB,aAAc9d,EAAOuc,EAAM,CACzBC,YAAa,ySAIbE,QAAS,CACPnoB,EAAG,KACH0E,EAAG,QAGP8kB,WAAY/d,EAAOuc,EAAM,CACvBC,YAAa,6oBASbE,QAAS,CACPnoB,EAAG,KACH0E,EAAG,QAGP+kB,WAAYhe,EAAOuc,EAAM,CACvBC,YAAa,+uBAWbE,QAAS,CACPnoB,EAAG,KACH0E,EAAG,QAGPglB,OAAQje,EAAOuc,EAAM,CACnBC,YAAa,sSAIbE,QAAS,CACPnoB,EAAG,KACH0E,EAAG,QAGPilB,QAASle,EAAOuc,EAAM,CACpBC,YAAa,4XAKbE,QAAS,CACPnoB,EAAG,IACH0E,EAAG,OAGPklB,IAAKne,EAAOuc,EAAM,CAChBC,YAAa,ggBAObE,QAAS,CACPnoB,EAAG,KACH0E,EAAG,QAGPmlB,OAAQpe,EAAOuc,EAAM,CACnBC,YAAa,+dAObE,QAAS,CACPnoB,EAAG,KACH0E,EAAG,QAGPolB,YAAare,EAAOuc,EAAM,CACxBC,YAAa,gWAKbE,QAAS,CACPnoB,EAAG,GACH0E,EAAG,MAGPqlB,kBAAmBte,EAAOuc,EAAM,CAC9BC,YAAa,0LAGbE,QAAS,CACPnoB,EAAG,KACH0E,EAAG,QAGPslB,YAAave,EAAOuc,EAAM,CACxBC,YAAa,oLAGbE,QAAS,CACPnoB,EAAG,GACH0E,EAAG,MAGPulB,KAAMxe,EAAOuc,EAAM,CACjBC,YAAa,srBAUbE,QAAS,CACPnoB,EAAG,IACH0E,EAAG,OAQPwlB,gCAAiCze,EAAOuc,EAAM,CAC5CC,YAAa,GAAGQ,KAAgBF,IAChCJ,QAASG,IAGX6B,+BAAgC1e,EAAOuc,EAAM,CAC3CC,YAAa,GAAGQ,KAAgBD,IAChCL,QAASG,IAGX8B,iCAAkC3e,EAAOuc,EAAM,CAC7CC,YAAa,GAAGQ,KAAgBF,IAChCJ,QAASG,IAGX+B,gCAAiC5e,EAAOuc,EAAM,CAC5CC,YAAa,GAAGQ,KAAgBD,IAChCL,QAASG,IAGXgC,iCAAkC7e,EAAOuc,EAAM,CAC7CC,YAAa,GAAGS,KAAkBH,IAClCJ,QAASG,IAIXiC,iBAAkB9e,EAAOuc,EAAM,CAC7BC,YAAa,GAAGS,KAAkBF,IAClCL,QAASG,IAGX,+BAAgC7c,EAAOuc,EAAM,CAC3CC,YAAa,GAAGS,KAAkBF,IAClCL,QAASG,IAGX,gCAAiC7c,EAAOuc,EAAM,CAC5CC,YAAa,GAAGS,KAAkBF,IAClCL,QAASG,IAGX,iCAAkC7c,EAAOuc,EAAM,CAC7CC,YAAa,GAAGS,KAAkBH,IAClCJ,QAASG,IAGX,gCAAiC7c,EAAOuc,EAAM,CAC5CC,YAAa,GAAGS,KAAkBH,IAClCJ,QAASG,IAGXkC,cAAe/e,EAAOuc,EAAM,CAC1BC,YAAa,GAAGU,KAAeH,IAC/BL,QAASG,IAGX,4BAA6B7c,EAAOuc,EAAM,CACxCC,YAAa,GAAGU,KAAeH,IAC/BL,QAASG,IAGX,8BAA+B7c,EAAOuc,EAAM,CAC1CC,YAAa,GAAGU,KAAeJ,IAC/BJ,QAASG,IAGX,6BAA8B7c,EAAOuc,EAAM,CACzCC,YAAa,GAAGU,KAAeH,IAC/BL,QAASG,KAQb,SAAS7c,EACPgB,EACA3L,GAEA,OAAO1H,OAAOyS,OAAOzS,OAAOuT,OAAOF,GAAO3L,EAC5C,CAqBA,SAAS2pB,EACPjpB,GAEA,OAAOonB,EAAUpnB,EACnB,CAKA,MAAMkpB,EAAiBtxB,OAAOyU,KAAK+a,6jBCtZnC,MAAM,sBAAE1D,GAA0B,YAqClC,MAAMyF,UAA0B,KAkB9B,WAAAz+B,CACE0+B,EAA6B,CAAC,EAC9BC,EAA8B,CAC5BC,0BAA2B,CAAC,QAAS,SACrCC,cAAe,CACbC,2BAA2B,EAC3BC,aAAcC,KAIlB9+B,MAAMw+B,EAAWC,GAmHnB,KAAAM,gBAAkB,CAChB7+B,EACA8+B,EACAC,EACAC,KAEA,MAAMjoB,GAAiB,IAAA6T,mBAAkB5qB,IACnC,SAAE0E,GAAaqS,GACf,KAAEhL,GAAS+yB,GACX,OAAEG,GAAWlzB,EAAKmzB,QAGxB,IAAIC,EAAez6B,EAAS1B,cAAci8B,EAAO,IAC7CG,EAAe16B,EAAS1B,cAAci8B,EAAO,IAE7CI,EAAO,CACT30B,MAAO,CACLgJ,EAAGyrB,EAAa,GAChB/mB,EAAG+mB,EAAa,IAElBv0B,IAAK,CACH8I,EAAG0rB,EAAa,GAChBhnB,EAAGgnB,EAAa,KAIhBE,EAAkB,kBACpB,CAACD,EAAK30B,MAAMgJ,EAAG2rB,EAAK30B,MAAM0N,GAC1B,CAACinB,EAAKz0B,IAAI8I,EAAG2rB,EAAKz0B,IAAIwN,GACtB,CAAC2mB,EAAa,GAAIA,EAAa,KAGjC,OAAIO,GAAmBN,IAKvBG,EAAez6B,EAAS1B,cAAci8B,EAAO,IAC7CG,EAAe16B,EAAS1B,cAAci8B,EAAO,IAE7CI,EAAO,CACL30B,MAAO,CACLgJ,EAAGyrB,EAAa,GAChB/mB,EAAG+mB,EAAa,IAElBv0B,IAAK,CACH8I,EAAG0rB,EAAa,GAChBhnB,EAAGgnB,EAAa,KAIpBE,EAAkB,kBAChB,CAACD,EAAK30B,MAAMgJ,EAAG2rB,EAAK30B,MAAM0N,GAC1B,CAACinB,EAAKz0B,IAAI8I,EAAG2rB,EAAKz0B,IAAIwN,GACtB,CAAC2mB,EAAa,GAAIA,EAAa,KAG7BO,GAAmBN,EAIX,EASd,KAAAO,qBAAuB,CACrB90B,EACAq0B,KAEA,MAAMU,EAAc/0B,EAAImrB,QAClB,QAAE51B,GAAYw/B,EAEpBV,EAAWW,aAAc,EAEzB,MAAMC,GAAsB,IAAAC,gCAC1B3/B,EACAiB,KAAK2+B,eAGP3+B,KAAK4+B,SAAW,CACdf,aACAY,sBACAI,eAAe,GAGjB7+B,KAAK8+B,gBAAgB//B,GAErB,MAAM+W,GAAiB,IAAA6T,mBAAkB5qB,IACnC,gBAAEmS,GAAoB4E,GAE5B,OAAsC5E,EAAiButB,IAEvD,IAAAM,mBAAkBhgC,GAElByK,EAAIw1B,gBAAgB,EAYtB,KAAAC,uBAAyB,CACvBz1B,EACAq0B,EACAqB,KAEA,MAAMX,EAAc/0B,EAAImrB,QAClB,QAAE51B,GAAYw/B,EACdzzB,EAAO+yB,EAAW/yB,KAExB+yB,EAAWW,aAAc,EAEzB,IACIW,EADAN,GAAgB,EAGfK,EAAyBE,cAC5BP,GAAgB,EAEhBM,EAAcr0B,EAAKmzB,QAAQD,OAAOqB,WAAWC,GAAMA,IAAMJ,IAI3D,MAAMT,GAAsB,IAAAC,gCAC1B3/B,EACAiB,KAAK2+B,gBAGP,IAAAI,mBAAkBhgC,GAElBiB,KAAK4+B,SAAW,CACdf,aACAY,sBACAU,cACAN,iBAEF7+B,KAAK8+B,gBAAgB//B,GAErB,MAAM+W,GAAiB,IAAA6T,mBAAkB5qB,IACnC,gBAAEmS,GAAoB4E,GAE5B,OAAsC5E,EAAiButB,GAEvDj1B,EAAIw1B,gBAAgB,EAWtB,KAAAO,aAAgB/1B,IACd,MAAM+0B,EAAc/0B,EAAImrB,QAClB,QAAE51B,GAAYw/B,GAEd,WAAEV,EAAU,oBAAEY,EAAmB,cAAEe,EAAa,SAAEC,GACtDz/B,KAAK4+B,UACD,KAAE9zB,GAAS+yB,EAEjB,GAAI2B,IAAkBC,EACpB,OAGF30B,EAAKmzB,QAAQyB,kBAAoB,KAEjC1/B,KAAK2/B,kBAAkB5gC,GACvBiB,KAAK4/B,gBAAgB7gC,IAErB,IAAA8gC,oBAAmB9gC,GAEnB,MAAM,gBAAEmS,IAAoB,IAAAyY,mBAAkB5qB,GAE9C,QAAkCkL,IAA9BjK,KAAK4+B,SAASO,YAA2B,CAC3C,MAAM,OAAEnB,GAAWlzB,EAAKmzB,QAClB6B,EAAyB,cAAc9B,EAAO,GAAIA,EAAO,IAG/D,GAFgC,cAAcA,EAAO,GAAIA,EAAO,IAElC8B,EAAwB,CAGpD,MAAMC,EAAW,CAAC,IAAI/B,EAAO,IAAK,IAAIA,EAAO,KAEvCgC,EAAkB,IAAIhC,EAAO,IAC7BiC,EAAkB,IAAIjC,EAAO,IAG7BkC,EAAiB,cAEvB,SACEA,EACAH,EAAS,GAAG,GAAKA,EAAS,GAAG,GAC7BA,EAAS,GAAG,GAAKA,EAAS,GAAG,IAG/B,MAAMI,EAA0C,cAEhD,SACEA,GACCD,EAAe,GAChBA,EAAe,IAGjB,MAAME,EAAyB,cAQ/B,IAAIC,EANJ,SACED,EACAH,EAAgB,GAAKD,EAAgB,GACrCC,EAAgB,GAAKD,EAAgB,IAWrCK,EALA,SACED,EACAD,GACE,EAEQ,CAACH,EAAiBC,GAElB,CAACA,EAAiBD,GAGhCl1B,EAAKmzB,QAAQD,OAAS,CACpB+B,EAAS,GACTA,EAAS,GACTM,EAAU,GACVA,EAAU,GAEd,CACF,CAGErgC,KAAKsgC,sBACLtgC,KAAKw9B,cAAcC,4BAEnB,IAAA8C,kBAAiB1C,EAAW2C,gBAG9B,OAAsCtvB,EAAiButB,GAEnDe,IACF,QAA2B3B,GAG7B79B,KAAK4+B,SAAW,KAChB5+B,KAAKygC,WAAY,CAAK,EAMxB,KAAAC,kBAAqBl3B,IACnBxJ,KAAKygC,WAAY,EAEjB,MAAMlC,EAAc/0B,EAAImrB,QAClB,cAAEgM,EAAa,QAAE5hC,GAAYw/B,EAC7BzoB,GAAiB,IAAA6T,mBAAkB5qB,IACnC,gBAAEmS,EAAe,SAAEzN,GAAaqS,GAChC,cAAE/T,GAAkB0B,GACpB,WAAEo6B,EAAU,oBAAEY,EAAmB,YAAEU,GAAgBn/B,KAAK4+B,UACxD,KAAE9zB,GAAS+yB,EAEX77B,EAAW2+B,EAAcC,MAG/B91B,EAAKmzB,QAAQD,OAAOmB,GAAe,IAAIn9B,GAEvC,MAAM6+B,EAAoB/1B,EAAKmzB,QAAQD,OAAOz7B,IAAIR,GAE5C+7B,EACa,CACfr0B,MAAO,CACLgJ,EAAGouB,EAAkB,GAAG,GACxB1pB,EAAG0pB,EAAkB,GAAG,IAE1Bl3B,IAAK,CACH8I,EAAGouB,EAAkB,GAAG,GACxB1pB,EAAG0pB,EAAkB,GAAG,KAoBxBC,GAfGD,EAAkB,GAAG,GACrBA,EAAkB,GAAG,GAGrBA,EAAkB,GAAG,GACrBA,EAAkB,GAAG,GAQjB,cAAcA,EAAkB,GAAIA,EAAkB,IAE5B,GAEjCE,EACJjD,EAA6Br0B,MAAMgJ,EAAIqrB,EAA6Bn0B,IAAI8I,EACpEuuB,EACJlD,EAA6Br0B,MAAM0N,EAAI2mB,EAA6Bn0B,IAAIwN,EACpErN,EAASlJ,KAAKiZ,KAAKknB,EAAKA,EAAKC,EAAKA,GAClCC,EAAUF,EAAKj3B,EACfo3B,EAAUF,EAAKl3B,EAEfq3B,GACHrD,EAA6Br0B,MAAMgJ,EAClCqrB,EAA6Bn0B,IAAI8I,GACnC,EACI2uB,GACHtD,EAA6Br0B,MAAM0N,EAClC2mB,EAA6Bn0B,IAAIwN,GACnC,EAEIkqB,EAASF,EAAOL,EAA0BI,EAC1CI,EAASF,EAAON,EAA0BG,EAC1CM,EAAOJ,EAAOL,EAA0BI,EACxCM,EAAOJ,EAAON,EAA0BG,EAG9Cn2B,EAAKmzB,QAAQD,OAAO,GAAKv6B,EAASnC,cAAc,CAAC+/B,EAAQC,IACzDx2B,EAAKmzB,QAAQD,OAAO,GAAKv6B,EAASnC,cAAc,CAACigC,EAAMC,IAEvD3D,EAAW9nB,aAAc,GACzB,OAAsC7E,EAAiButB,GAEvDz+B,KAAK4+B,SAASa,UAAW,CAAI,EAO/B,KAAAgC,oBAAuBj4B,IACrBxJ,KAAKygC,WAAY,EAEjB,MAAMlC,EAAc/0B,EAAImrB,QAClB,QAAE51B,GAAYw/B,EACdzoB,GAAiB,IAAA6T,mBAAkB5qB,IACnC,gBAAEmS,GAAoB4E,GACtB,WAAE+nB,EAAU,oBAAEY,EAAmB,YAAEU,EAAW,cAAEN,GACpD7+B,KAAK4+B,UACD,KAAE9zB,GAAS+yB,EACjB,GAAIgB,EAAe,CACjB,MAAM,YAAE6C,GAAgBnD,EAClBoD,EAAgBD,EAAYd,OAE5B,QAAEgB,GAAY92B,EAAKmzB,SACnB,cAAEmB,GAAkBwC,EAE1BxC,EAAc,IAAMuC,EAAc,GAClCvC,EAAc,IAAMuC,EAAc,GAClCvC,EAAc,IAAMuC,EAAc,GAElCC,EAAQnC,UAAW,CACrB,MAAO,QAAoBx1B,IAAhBk1B,EAA2B,CAEpC,MAAM,YAAEuC,GAAgBnD,EAClBoD,EAAgBD,EAAYd,MACnB91B,EAAKmzB,QAAQD,OAErBztB,SAASlF,IACdA,EAAM,IAAMs2B,EAAc,GAC1Bt2B,EAAM,IAAMs2B,EAAc,GAC1Bt2B,EAAM,IAAMs2B,EAAc,EAAE,IAE9B9D,EAAW9nB,aAAc,CAC3B,MACE/V,KAAK6hC,kBAAkBr4B,GACvBq0B,EAAW9nB,aAAc,GAG3B,OAAsC7E,EAAiButB,EAAoB,EAO7E,KAAAoD,kBAAqBr4B,IACnB,MAAM+0B,EAAc/0B,EAAImrB,QAClB,cAAEgM,EAAa,QAAE5hC,GAAYw/B,EAC7BzoB,GAAiB,IAAA6T,mBAAkB5qB,IACnC,SAAE0E,GAAaqS,GACf,WAAE+nB,EAAYsB,YAAa2C,GAAsB9hC,KAAK4+B,UACtD,KAAE9zB,GAAS+yB,EAGX77B,EAAW2+B,EAAcC,MACzBmB,EAA4B,CAChCt+B,EAAS1B,cAAc+I,EAAKmzB,QAAQD,OAAO,IAC3Cv6B,EAAS1B,cAAc+I,EAAKmzB,QAAQD,OAAO,IAC3Cv6B,EAAS1B,cAAc+I,EAAKmzB,QAAQD,OAAO,IAC3Cv6B,EAAS1B,cAAc+I,EAAKmzB,QAAQD,OAAO,KAGvCgE,EAAmB,CACvBv4B,MAAO,CACLgJ,EAAGsvB,EAA0B,GAAG,GAChC5qB,EAAG4qB,EAA0B,GAAG,IAElCp4B,IAAK,CACH8I,EAAGsvB,EAA0B,GAAG,GAChC5qB,EAAG4qB,EAA0B,GAAG,KAG9BE,EAAoB,CACxBx4B,MAAO,CACLgJ,EAAGsvB,EAA0B,GAAG,GAChC5qB,EAAG4qB,EAA0B,GAAG,IAElCp4B,IAAK,CACH8I,EAAGsvB,EAA0B,GAAG,GAChC5qB,EAAG4qB,EAA0B,GAAG,KAK9BG,EAA8B,IAAIlgC,GAClCmgC,EAAsB1+B,EAAS1B,cAAcmgC,GAEnD,GAA0B,IAAtBJ,GAAiD,IAAtBA,EAAyB,CACtD,MAEMM,EACJL,EAH6C,IAAtBD,EAA0B,EAAI,GAKjDO,EAAgC,SACpC,cACAF,EAAoB,GAAKC,EAAuB,GAChDD,EAAoB,GAAKC,EAAuB,IAG5CE,EAA2B,SAC/B,cACAP,EAA0BD,GAAmB,GAC3CM,EAAuB,GACzBL,EAA0BD,GAAmB,GAC3CM,EAAuB,IAI3B,eACEC,EACAA,GAEF,eAAeC,EAA0BA,GAGzC,MAAMC,EAA2B,CAC/B94B,MAAO,CACLgJ,EAAG2vB,EAAuB,GAC1BjrB,EAAGirB,EAAuB,IAE5Bz4B,IAAK,CACH8I,EAAG0vB,EAAoB,GACvBhrB,EAAGgrB,EAAoB,KAS3B,GACEniC,KAAKwiC,0CACHD,EACAN,GAGF,OAGF,MAAMQ,EAAmBL,EAEnBzrB,EAAQ3W,KAAK0iC,gBACjBJ,EACAD,GAKF,IAAIM,EAAcZ,EAA0B,GAAG,GAC3Ca,EAAcb,EAA0B,GAAG,GAE3Cc,EAAed,EAA0B,GAAG,GAC5Ce,EAAef,EAA0B,GAAG,GAGhDY,GAAeF,EAAiB,GAChCG,GAAeH,EAAiB,GAEhCI,GAAgBJ,EAAiB,GACjCK,GAAgBL,EAAiB,GAGjC,MAAMM,EACJJ,EAAc/hC,KAAKmX,IAAIpB,GAASisB,EAAchiC,KAAKqX,IAAItB,GACnDqsB,EACJL,EAAc/hC,KAAKqX,IAAItB,GAASisB,EAAchiC,KAAKmX,IAAIpB,GAEnDssB,EACJJ,EAAejiC,KAAKmX,IAAIpB,GAASmsB,EAAeliC,KAAKqX,IAAItB,GACrDusB,EACJL,EAAejiC,KAAKqX,IAAItB,GAASmsB,EAAeliC,KAAKmX,IAAIpB,GAG3DgsB,EAAcI,EAAoBN,EAAiB,GACnDG,EAAcI,EAAqBP,EAAiB,GAEpDI,EAAeI,EAAqBR,EAAiB,GACrDK,EAAeI,EAAsBT,EAAiB,GAGtD,MAAMU,EAAgB1/B,EAASnC,cAAc,CAACqhC,EAAaC,IACrDQ,EAAiB3/B,EAASnC,cAAc,CAC5CuhC,EACAC,IAKFh4B,EAAKmzB,QAAQD,OAAO8D,GAAqBI,EACzCp3B,EAAKmzB,QAAQD,OAAO,GAAKmF,EACzBr4B,EAAKmzB,QAAQD,OAAO,GAAKoF,CAC3B,KAAO,CAEL,MAAMC,EAA6C,IAAtBvB,EAA0B,EAAI,EAErDwB,EAAsB,CAC1BC,gBAAiB,CACf95B,MAAOu4B,EAAiBv4B,MACxBE,IAAKq4B,EAAiBr4B,KAExB65B,iBAAkB,CAChB/5B,MAAOw4B,EAAkBx4B,MACzBE,IAAKs4B,EAAkBt4B,MAIrB85B,EAAqB,cACzB,cACA,CACEH,EAAoBC,gBAAgB55B,IAAI8I,EACxC6wB,EAAoBC,gBAAgB55B,IAAIwN,GAE1C,CACEmsB,EAAoBC,gBAAgB95B,MAAMgJ,EAC1C6wB,EAAoBC,gBAAgB95B,MAAM0N,IAIxCusB,EAA+B,eACnC,cACAD,GAGIE,EAAuB,cAC3B,cACA,CAACxB,EAAoB,GAAIA,EAAoB,IAC7C,CACEJ,EAA0BD,GAAmB,GAC7CC,EAA0BD,GAAmB,KAI3C8B,EAAiB,YAAYD,GAE7BhtB,EAAQ3W,KAAK0iC,gBACjBgB,EACAC,GAGIE,EAAiCjjC,KAAKmX,IAAIpB,GAASitB,EAEnDE,EAAqB,iBACzB,cACA,CACE/B,EAA0BsB,GAAsB,GAChDtB,EAA0BsB,GAAsB,IAElDK,EACAG,GAIF,GACE7jC,KAAKwiC,0CACH,CACE/4B,MAAO,CACLgJ,EAAG0vB,EAAoB,GACvBhrB,EAAGgrB,EAAoB,IAEzBx4B,IAAK,CACH8I,EAAGqxB,EAAmB,GACtB3sB,EAAG2sB,EAAmB,KAG1B,CACEr6B,MAAO,CACLgJ,EAAG6wB,EAAoBC,gBAAgB95B,MAAMgJ,EAC7C0E,EAAGmsB,EAAoBC,gBAAgB95B,MAAM0N,GAE/CxN,IAAK,CACH8I,EAAG6wB,EAAoBC,gBAAgB55B,IAAI8I,EAC3C0E,EAAGmsB,EAAoBC,gBAAgB55B,IAAIwN,KAKjD,OAWF,IAR0B,gBACxB,CAACgrB,EAAoB,GAAIA,EAAoB,IAC7C,CAAC2B,EAAmB,GAAIA,EAAmB,IAC3C,CAAC9B,EAAiBv4B,MAAMgJ,EAAGuvB,EAAiBv4B,MAAM0N,GAClD,CAAC6qB,EAAiBr4B,IAAI8I,EAAGuvB,EAAiBr4B,IAAIwN,IAK9C,OAGFrM,EAAKmzB,QAAQD,OAAOqF,GAAwB5/B,EAASnC,cACnDwiC,GAEFh5B,EAAKmzB,QAAQD,OAAO8D,GAAqBI,CAC3C,GAOF,KAAAhU,OAAUnvB,IAER,GAAIiB,KAAKygC,UAAW,CAClBzgC,KAAKygC,WAAY,EACjBzgC,KAAK4/B,gBAAgB7gC,GACrBiB,KAAK2/B,kBAAkB5gC,IACvB,IAAA8gC,oBAAmB9gC,GAEnB,MAAM,WAAE8+B,EAAU,oBAAEY,EAAmB,cAAEe,GAAkBx/B,KAAK4+B,UAC1D,KAAE9zB,GAAS+yB,EAEjBA,EAAWW,aAAc,EACzB1zB,EAAKmzB,QAAQyB,kBAAoB,KAEjC,MAAM,gBAAExuB,IAAoB,IAAAyY,mBAAkB5qB,GAY9C,OAVA,OACEmS,EACAutB,GAGEe,IACF,QAA2B3B,GAG7B79B,KAAK4+B,SAAW,KACTf,EAAW2C,aACpB,GAGF,KAAAuD,cAAiBhlC,IACf,KAAMilC,uBAAwB,EAE9BjlC,EAAQ8F,iBAAiB,EAAAmW,OAAOipB,SAAUjkC,KAAKu/B,cAC/CxgC,EAAQ8F,iBAAiB,EAAAmW,OAAOkpB,WAAYlkC,KAAK0gC,mBACjD3hC,EAAQ8F,iBAAiB,EAAAmW,OAAOmpB,WAAYnkC,KAAK0gC,mBACjD3hC,EAAQ8F,iBAAiB,EAAAmW,OAAOopB,YAAapkC,KAAKu/B,cAElDxgC,EAAQ8F,iBACN,EAAAmW,OAAOqpB,UACPrkC,KAAKu/B,cAEPxgC,EAAQ8F,iBACN,EAAAmW,OAAOspB,UACPtkC,KAAKu/B,cAEPxgC,EAAQ8F,iBACN,EAAAmW,OAAOupB,WACPvkC,KAAK0gC,kBACN,EAGH,KAAAd,gBAAmB7gC,IACjB,KAAMilC,uBAAwB,EAE9BjlC,EAAQkG,oBAAoB,EAAA+V,OAAOipB,SAAUjkC,KAAKu/B,cAClDxgC,EAAQkG,oBAAoB,EAAA+V,OAAOkpB,WAAYlkC,KAAK0gC,mBACpD3hC,EAAQkG,oBAAoB,EAAA+V,OAAOmpB,WAAYnkC,KAAK0gC,mBACpD3hC,EAAQkG,oBAAoB,EAAA+V,OAAOopB,YAAapkC,KAAKu/B,cAErDxgC,EAAQkG,oBACN,EAAA+V,OAAOqpB,UACPrkC,KAAKu/B,cAEPxgC,EAAQkG,oBACN,EAAA+V,OAAOspB,UACPtkC,KAAKu/B,cAEPxgC,EAAQkG,oBACN,EAAA+V,OAAOupB,WACPvkC,KAAK0gC,kBACN,EAGH,KAAA5B,gBAAmB//B,IACjB,KAAMilC,uBAAwB,EAE9BjlC,EAAQ8F,iBAAiB,EAAAmW,OAAOipB,SAAUjkC,KAAKu/B,cAC/CxgC,EAAQ8F,iBAAiB,EAAAmW,OAAOkpB,WAAYlkC,KAAKyhC,qBACjD1iC,EAAQ8F,iBAAiB,EAAAmW,OAAOopB,YAAapkC,KAAKu/B,cAElDxgC,EAAQ8F,iBACN,EAAAmW,OAAOspB,UACPtkC,KAAKu/B,cAEPxgC,EAAQ8F,iBACN,EAAAmW,OAAOupB,WACPvkC,KAAKyhC,qBAEP1iC,EAAQ8F,iBACN,EAAAmW,OAAOqpB,UACPrkC,KAAKu/B,aACN,EAGH,KAAAI,kBAAqB5gC,IACnB,KAAMilC,uBAAwB,EAE9BjlC,EAAQkG,oBAAoB,EAAA+V,OAAOipB,SAAUjkC,KAAKu/B,cAClDxgC,EAAQkG,oBAAoB,EAAA+V,OAAOkpB,WAAYlkC,KAAKyhC,qBACpD1iC,EAAQkG,oBAAoB,EAAA+V,OAAOopB,YAAapkC,KAAKu/B,cAErDxgC,EAAQkG,oBACN,EAAA+V,OAAOspB,UACPtkC,KAAKu/B,cAEPxgC,EAAQkG,oBACN,EAAA+V,OAAOupB,WACPvkC,KAAKyhC,qBAEP1iC,EAAQkG,oBACN,EAAA+V,OAAOqpB,UACPrkC,KAAKu/B,aACN,EAWH,KAAAiF,iBAAmB,CACjB1uB,EACA2uB,KAEA,IAAIC,GAAe,EACnB,MAAM,SAAEjhC,GAAaqS,GACf,QAAE/W,GAAY0E,EACpB,IAAIkhC,GAAc,IAAAC,gBAAe5kC,KAAK2+B,cAAe5/B,GAErD,IAAK4lC,GAAa76B,OAChB,OAAO46B,EAQT,GALAC,EAAc3kC,KAAK6kC,wCACjB9lC,EACA4lC,IAGGA,GAAa76B,OAChB,OAAO46B,EAGT,MAAMI,EAAW9kC,KAAK+kC,YAAYthC,GAE5ByN,EAAkBzN,EAASuhC,qBAE3BC,EAAiC,CACrCC,YAAallC,KAAKklC,YAClBC,SAAUnlC,KAAK2+B,cACfp7B,WAAYuS,EAAerS,SAASD,IAGtC,IAAK,IAAIwF,EAAI,EAAGA,EAAI27B,EAAY76B,OAAQd,IAAK,CAC3C,MAAM60B,EAAa8G,EAAY37B,IACzB,cAAEw3B,EAAa,KAAE11B,GAAS+yB,GAC1B,OAAEG,EAAM,kBAAE0B,GAAsB50B,EAAKmzB,QACrCmH,EAAoBpH,EAAOz7B,KAAK+8B,GAAM77B,EAAS1B,cAAcu9B,KAEnE2F,EAAezE,cAAgBA,EAE/B,MAAM,MAAElqB,EAAK,UAAE+uB,EAAS,SAAEC,EAAQ,OAAEC,GAAWvlC,KAAKwlC,mBAAmB,CACrE3H,aACAoH,mBAyBF,GAnBGn6B,EAAK26B,YAAYX,IACiB,MAAnCh6B,EAAK26B,YAAYX,GAAUx6B,KASlBuzB,EAAW9nB,aACpB/V,KAAK0lC,+BACH7H,EACA3sB,EACA4E,IAXFhL,EAAK26B,YAAYX,GAAY,CAC3Bh7B,OAAQ,KACRvJ,MAAO,KACP+J,KAAM,MAGRtK,KAAK2lC,sBAAsB9H,EAAY3sB,EAAiB4E,KAUrDrS,EAASuhC,qBAEZ,OADA3zB,QAAQC,KAAK,uCACNozB,EAGT,IAAIkB,EAEJ,KAAK,IAAAC,qBAAoBrF,GACvB,SAYF,IARG,IAAAsF,oBAAmBjI,IACnB79B,KAAK4+B,UACgB,OAAtBc,IAGAkG,EAA2B,CAACR,EAAkB1F,KAG5CkG,EAA0B,CAC5B,MAAMG,EAAiB,KAEvB,IAAAC,aACEvB,EACAjE,EACAuF,EACAH,EACA,CACEtvB,SAGN,CAEA,MAAM2vB,EAAU,GAAGzF,WACb0F,EAAU,GAAG1F,WAEb2F,EAAU,KAChB,IAAAC,UACE3B,EACAjE,EACA2F,EACAf,EAAkB,GAClBA,EAAkB,GAClB,CACE9uB,QACAgvB,WACAD,YACAE,UAEFU,GAGF,MAAMI,EAAgB,KACtB,IAAAD,UACE3B,EACAjE,EACA6F,EACAjB,EAAkB,GAClBA,EAAkB,GAClB,CACE9uB,QACAgvB,WACAD,YACAE,UAEFW,GAGFxB,GAAe,EAEf,MAAMz9B,EAAUjH,KAAKsmC,sBAAsBrB,EAAgBpH,GAC3D,IAAK52B,EAAQs/B,WAAY,CACvBz7B,EAAKmzB,QAAQ2D,QAAU,CACrBnC,UAAU,EACVL,cAA6B,CAAC,EAAG,EAAG,GACpCoH,iBAAkB,CAChBC,QAAuB,CAAC,EAAG,EAAG,GAC9BC,SAAwB,CAAC,EAAG,EAAG,GAC/BC,WAA0B,CAAC,EAAG,EAAG,GACjCC,YAA2B,CAAC,EAAG,EAAG,KAGtC,QACF,CAEA,MAAMC,EAAY7mC,KAAKw9B,cAAcE,aAAa5yB,EAAMg6B,GACxD,IAAK+B,GAAkC,IAArBA,EAAU/8B,OAC1B,SAGF,IAAIg9B,EAECh8B,EAAKmzB,QAAQ2D,QAAQnC,WACxBqH,GAAsB,IAAAC,wBAAuB3B,GAE7Ct6B,EAAKmzB,QAAQ2D,QAAQxC,cACnB37B,EAASnC,cAAcwlC,IAG3B,MAAME,EAAkBvjC,EAAS1B,cAC/B+I,EAAKmzB,QAAQ2D,QAAQxC,eAGjB6H,EAAa,IACbC,GAAc,IAAAC,mBAClB1C,EACAjE,EACAyG,EACAJ,EACAG,EACA5B,EACA,CAAC,EACDn+B,IAGMwL,EAAGP,EAAMiF,EAAGiwB,EAAG,MAAE7mC,EAAK,OAAEC,GAAW0mC,EAE3Cp8B,EAAKmzB,QAAQ2D,QAAQ4E,iBAAmB,CACtCC,QAAShjC,EAASnC,cAAc,CAAC4Q,EAAMk1B,IACvCV,SAAUjjC,EAASnC,cAAc,CAAC4Q,EAAO3R,EAAO6mC,IAChDT,WAAYljC,EAASnC,cAAc,CAAC4Q,EAAMk1B,EAAM5mC,IAChDomC,YAAanjC,EAASnC,cAAc,CAAC4Q,EAAO3R,EAAO6mC,EAAM5mC,IAE7D,CAEA,OAAOkkC,CAAY,EAGrB,KAAAlC,0CAA4C,CAC1CR,EACAC,KAEA,MAAMoF,EAA8B,cAEpC,SACEA,EACApF,EAAkBt4B,IAAI8I,EAAIwvB,EAAkBx4B,MAAMgJ,EAClDwvB,EAAkBt4B,IAAIwN,EAAI8qB,EAAkBx4B,MAAM0N,GAGpD,eAAekwB,EAA6BA,GAE5C,MAAMC,EAA4B,CAChC79B,MAAO,CACLgJ,EAAGwvB,EAAkBx4B,MAAMgJ,EAAqC,GAAjC40B,EAA4B,GAC3DlwB,EAAG8qB,EAAkBx4B,MAAM0N,EAAqC,GAAjCkwB,EAA4B,IAE7D19B,IAAK,CACH8I,EAAGwvB,EAAkBt4B,IAAI8I,EAAqC,GAAjC40B,EAA4B,GACzDlwB,EAAG8qB,EAAkBt4B,IAAIwN,EAAqC,GAAjCkwB,EAA4B,KAgB7D,OATkC,gBAChC,CAACC,EAA0B79B,MAAMgJ,EAAG60B,EAA0B79B,MAAM0N,GACpE,CAACmwB,EAA0B39B,IAAI8I,EAAG60B,EAA0B39B,IAAIwN,GAChE,CAAC6qB,EAAiBv4B,MAAMgJ,EAAGuvB,EAAiBv4B,MAAM0N,GAClD,CAAC6qB,EAAiBr4B,IAAI8I,EAAGuvB,EAAiBr4B,IAAIwN,GAKjB,EAWjC,KAAAwuB,sBAAwB,CAAC9H,EAAY3sB,EAAiB4E,KACpD,MAAM,KAAEhL,GAAS+yB,GACX,QAAE9+B,GAAY+W,EAAerS,SAE7B8jC,EAAYz8B,EAAKmzB,QAAQD,OAAO,GAChCwJ,EAAY18B,EAAKmzB,QAAQD,OAAO,GAChCyJ,EAAY38B,EAAKmzB,QAAQD,OAAO,GAChC0J,EAAY58B,EAAKmzB,QAAQD,OAAO,IAEhC,YAAEyH,GAAgB36B,EAClB68B,EAAY97B,OAAOyU,KAAKmlB,GAE9B,IAAK,IAAIz8B,EAAI,EAAGA,EAAI2+B,EAAU79B,OAAQd,IAAK,CACzC,MAAM87B,EAAW6C,EAAU3+B,GAErB5D,EAAQpF,KAAK4nC,iBAAiB9C,EAAU5zB,GAK9C,IAAK9L,EACH,SAGF,MAAM,UAAE4F,EAAS,WAAEpE,GAAexB,EAC5ByiC,EAASlQ,EAAsB3sB,EAAWu8B,GAC1CO,EAASnQ,EAAsB3sB,EAAWw8B,GAC1CO,EAASpQ,EAAsB3sB,EAAWy8B,GAC1CO,EAASrQ,EAAsB3sB,EAAW08B,GAE1CO,EAAW,CAACJ,EAAQC,GACpBI,EAAW,CAACH,EAAQC,IAElB/3B,MAAOk4B,EAAQC,MAAOC,IAAW,QACvCjjC,EACA6iC,IAGMh4B,MAAOq4B,EAAQF,MAAOG,IAAW,QACvCnjC,EACA8iC,GAGIM,EAAQxoC,KAAKyoC,iBAAiBlB,EAAWC,GAAaW,EACtDO,EAAQ1oC,KAAKyoC,iBAAiBhB,EAAWC,GAAaY,EACtDx+B,EAAS0+B,EAAQE,EAAQF,EAAQE,EACjCnoC,EAAQioC,EAAQE,EAAQA,EAAQF,EAEhCG,EAAaH,EAAQE,EAAQL,EAASE,EACtCK,EAAYJ,EAAQE,EAAQH,EAASF,EAE3CroC,KAAK6oC,gBAAgBhB,EAAQC,EAAQC,EAAQC,EAAQphC,GAChD5G,KAAKsgC,sBAAuB,EAC5BtgC,KAAKsgC,sBAAuB,EAEjCmF,EAAYX,GAAY,CACtBh7B,SACAvJ,QACA+J,KAAM+9B,EACNM,aACAC,YAEJ,CAOA,OALA/K,EAAW9nB,aAAc,GAGzB,QAA0B8nB,EAAY9+B,GAE/B0mC,CAAW,EAGpB,KAAAoD,gBAAkB,CAAChB,EAAQC,EAAQC,EAAQC,EAAQphC,IAE/C,kCAA8BihC,EAAQjhC,IACtC,kCAA8BkhC,EAAQlhC,IACtC,kCAA8BmhC,EAAQnhC,IACtC,kCAA8BohC,EAAQphC,GAI1C,KAAA87B,gBAAkB,CAACoG,EAASC,IACnBnoC,KAAKooC,MACVF,EAAQ,GAAKC,EAAQ,GAAKD,EAAQ,GAAKC,EAAQ,GAC/CD,EAAQ,GAAKC,EAAQ,GAAKD,EAAQ,GAAKC,EAAQ,IAjsCjD/oC,KAAK0lC,gCAAiC,OACpC1lC,KAAK2lC,sBACL,IACA,CAAEsD,UAAU,GAEhB,CAUA,gBAAAC,CACE1/B,GAEA,MAAM+0B,EAAc/0B,EAAImrB,QAClB,cAAEgM,EAAa,QAAE5hC,GAAYw/B,EAC7Bv8B,EAAW2+B,EAAcC,MACzB9qB,GAAiB,IAAA6T,mBAAkB5qB,IACnC,SAAE0E,EAAQ,gBAAEyN,GAAoB4E,EAEtC9V,KAAKygC,WAAY,EAEjB,MAAM/yB,EAASjK,EAASuL,aAClB,gBAAEI,EAAe,OAAED,GAAWzB,EAE9BW,EAAoBrO,KAAKmpC,qBAC7B1lC,EACAzB,EACAoN,EACAD,GAGI8a,EAAsBxmB,EAASxC,yBAE/B48B,EAAsC,CAC1CW,aAAa,EACbzoB,aAAa,EACb/N,SAAU,CACRm9B,SAAUnlC,KAAK2+B,cACfvvB,gBAA+B,IAAIA,GACnCD,OAAsB,IAAIA,GAC1B8a,sBACA5b,uBACG5K,EAASoL,iBAAiB,CAAEmvB,OAAQ,CAACh8B,MAE1C8I,KAAM,CACJmzB,QAAS,CACPD,OAAQ,CAEQ,IAAIh8B,GACJ,IAAIA,GAEJ,IAAIA,GACJ,IAAIA,IAEpB4/B,QAAS,CACPnC,UAAU,EACVL,cAA6B,CAAC,EAAG,EAAG,GACpCoH,iBAAkB,CAChBC,QAAuB,CAAC,EAAG,EAAG,GAC9BC,SAAwB,CAAC,EAAG,EAAG,GAC/BC,WAA0B,CAAC,EAAG,EAAG,GACjCC,YAA2B,CAAC,EAAG,EAAG,KAGtClH,kBAAmB,MAErB0J,MAAO,GACP3D,YAAa,CAAC,KAIlB,IAAA4D,eAAcxL,EAAY9+B,GAE1B,MAAM0/B,GAAsB,IAAAC,gCAC1B3/B,EACAiB,KAAK2+B,eAmBP,OAhBA3+B,KAAK4+B,SAAW,CACdf,aACAY,sBACAU,YAAa,EACbN,eAAe,EACfW,eAAe,EACfC,UAAU,GAEZz/B,KAAK+jC,cAAchlC,IAEnB,IAAAggC,mBAAkBhgC,GAElByK,EAAIw1B,kBAEJ,OAAsC9tB,EAAiButB,GAEhDZ,CACT,CAigCA,gBAAA4K,CAAiBa,EAAMC,GACrB,MAAMxI,EAAKuI,EAAK,GAAKC,EAAK,GACpBvI,EAAKsI,EAAK,GAAKC,EAAK,GACpBC,EAAKF,EAAK,GAAKC,EAAK,GAE1B,OAAO3oC,KAAKiZ,KAAKknB,EAAKA,EAAKC,EAAKA,EAAKwI,EAAKA,EAC5C,EA2FF,SAAS7L,EAAoB7yB,EAAMg6B,GACjC,MAAM,YAAEW,EAAW,MAAE2D,GAAUt+B,GACzB,OAAEhB,EAAM,MAAEvJ,EAAK,KAAE+J,EAAI,WAAEq+B,EAAU,UAAEC,GAAcnD,EAAYX,GAE7D+B,EAAY,GAIlB,OAHIuC,GACFvC,EAAUj2B,KAAKw4B,QAEFn/B,IAAXH,GAMJ+8B,EAAUj2B,KACR,OAAM,IAAA64B,aAAY3/B,MAAW6+B,GAAcr+B,IAC3C,OAAM,IAAAm/B,aAAYlpC,MAAUqoC,GAAat+B,KAPlCu8B,CAWX,CAEAzJ,EAAkB+H,SAAW,mICxyC7B,MAAeuE,UAAuB,IAI7B,uBAAOC,IAAoBC,GAChC,IAAI/L,EAAyB,CAC3B2C,cAAe,KACfhC,aAAa,EACbzoB,aAAa,EACb/N,SAAU,CACRm9B,SAAUnlC,KAAKmlC,UAEjBr6B,KAAM,CACJ++B,KAAM,GACN5L,QAAS,CACPD,OAAQ,IAAI12B,MACZs6B,QAAS,CACPnC,UAAU,EACVL,cAA6B,CAAC,EAAG,EAAG,GACpCoH,iBAAkB,CAChBC,QAAuB,CAAC,EAAG,EAAG,GAC9BC,SAAwB,CAAC,EAAG,EAAG,GAC/BC,WAA0B,CAAC,EAAG,EAAG,GACjCC,YAA2B,CAAC,EAAG,EAAG,MAIxCwC,MAAO,KAGX,IAAK,MAAMU,KAAYF,EACrB/L,EAAa,sBAAkBA,EAAYiM,GAE7C,OAAOjM,CACT,CAOO,kCAAOkM,CAA4BtmC,KAAammC,GACrD,OAAO5pC,KAAK2pC,iBACV,CAAE3hC,SAAUvE,EAASoL,uBAClB+6B,EAEP,CAUO,6BAAOI,CAAuBvmC,KAAammC,GAChD,MAAM/L,EAAa79B,KAAK+pC,4BACtBtmC,KACGmmC,IAEL,IAAAP,eAAcxL,EAAYp6B,EAAS1E,UACnC,QAA0B8+B,EAAYp6B,EAAS1E,QACjD,CAOA,WAAAJ,CAAY0+B,EAA4BC,GACtCz+B,MAAMw+B,EAAWC,GAqFZ,KAAA2M,kBAAoB,CACzBzgC,EACA0gC,KAEA,IAAKA,EACH,OAAO,EAGT,MAAM,QAAEnrC,EAAO,cAAE4hC,GAAkBn3B,EAAImrB,OACjCmJ,EAAe6C,EAAc7hC,OACnC,IAAIqrC,GAA6B,EAEjC,IAAK,MAAMtM,KAAcqM,EAAqB,CAE5C,IACE,IAAApE,oBAAmBjI,MAClB,IAAAgI,qBAAoBhI,EAAW2C,eAEhC,SAGF,MAAM,KAAE11B,GAAS+yB,EACXuM,EAAsBt/B,EAAKmzB,QAC7BnzB,EAAKmzB,QAAQyB,uBACbz1B,EAIEogC,EAAOrqC,KAAKsqC,4BAChBvrC,EACA8+B,EACAC,EACA,GAGIyM,EAA6BF,IAASxM,EAAWW,YACjDgM,GAA8BH,GAAQxM,EAAWW,YACnD+L,GAA8BC,GAChC3M,EAAWW,aAAeX,EAAWW,YACrC2L,GAA6B,GAE7Br/B,EAAKmzB,SACLnzB,EAAKmzB,QAAQyB,oBAAsB0K,IAGnCD,GAA6B,EAEjC,CAEA,OAAOA,CAA0B,EApI7B9M,EAAUG,eAAeE,eAC3B19B,KAAKw9B,cAAcE,aAAeL,EAAUG,cAAcE,cAGxDL,EAAUG,eAAeiN,kBAC3BzqC,KAAKw9B,cAAciN,gBACjBpN,EAAUG,cAAciN,gBAE9B,CA4IA,uBAAAC,CACE3rC,EACA8+B,EACAC,EACAC,GAEA,MAAMjoB,GAAiB,IAAA6T,mBAAkB5qB,IACnC,SAAE0E,GAAaqS,GAEf,KAAEhL,GAAS+yB,GACX,mBAAE8M,GAAuB7/B,GACzB,OAAEkzB,EAAM,QAAE4D,GAAY92B,EAAKmzB,QAEjC,GAAI2D,EAAS,CACX,MAAM,iBAAE4E,GAAqB5E,EAC7B,GAAI4E,EAAkB,CACpB,MAAMoE,EAAoB,CACxBnE,QAAShjC,EAAS1B,cAAcykC,EAAiBC,SACjDC,SAAUjjC,EAAS1B,cAAcykC,EAAiBE,UAClDC,WAAYljC,EAAS1B,cAAcykC,EAAiBG,YACpDC,YAAanjC,EAAS1B,cAAcykC,EAAiBI,cAGvD,GACE9I,EAAa,IAAM8M,EAAkBnE,QAAQ,IAC7C3I,EAAa,IAAM8M,EAAkBhE,YAAY,IACjD9I,EAAa,IAAM8M,EAAkBnE,QAAQ,IAC7C3I,EAAa,IAAM8M,EAAkBhE,YAAY,GAGjD,OADA97B,EAAKmzB,QAAQyB,kBAAoB,KAC1BkC,CAEX,CACF,CAEA,IAAK,IAAI54B,EAAI,EAAGA,EAAIg1B,GAAQl0B,OAAQd,IAAK,CACvC,MAAMqC,EAAQ2yB,EAAOh1B,GACf6hC,EAA6BF,EAC/Bt/B,EAAMuU,MAAM,EAAG,GACfnc,EAAS1B,cAAcsJ,GAQ3B,IAAa,IALX,cACEyyB,EACA+M,GACE9M,EAIJ,OADAjzB,EAAKmzB,QAAQyB,kBAAoB12B,EAC1BqC,CAEX,CAEAP,EAAKmzB,QAAQyB,kBAAoB,IACnC,CAYO,qBAAA4G,CACLwE,EACAjN,GAKA,MAAO,CACL0I,WAAYvmC,KAAK+qC,SACf,oBACAD,EACAjN,GAEFmN,WAAYhrC,KAAK+qC,SACf,oBACAD,EACAjN,GAEFoN,SAAUjrC,KAAK+qC,SAAS,kBAAmBD,EAAgBjN,GAC3DvnB,MAAOtW,KAAK+qC,SAAS,eAAgBD,EAAgBjN,GACrD0H,OAAQvlC,KAAK+qC,SAAS,gBAAiBD,EAAgBjN,GACvDqN,WAAYlrC,KAAK+qC,SACf,oBACAD,EACAjN,GAEFwH,UAAWrlC,KAAK+qC,SACd,uBACAD,EACAjN,GAEFyH,SAAUtlC,KAAK+qC,SACb,sBACAD,EACAjN,GAGN,CASA,WAAAsN,CACE1nC,EACAqhC,EACAz/B,GAEA,GAAI5B,aAAoB,EAAA2nC,mBAAoB,CAC1C,MAAMpxB,EAAW,wBAAoB8qB,GAC/B7gB,EAAS,EAAAonB,MAAM7lB,UAAUxL,GAC/B,YAA+B/P,IAAxBga,GAAQtG,SAASC,EAC1B,CACA,MAAM0tB,EACJjmC,GAAW,EAAAsmB,SAAA,IAAa,gBAAiBtmB,GAC3C,MAAuC,iBAAzBimC,GAAe9uB,KAC/B,CAMU,kBAAAgpB,CAAmB56B,GAI3B,MAAM,WAAEizB,EAAU,eAAEoH,GAAmBr6B,EACjCmgC,EAAYQ,GAChBvrC,KAAK+qC,SAASQ,EAAUtG,EAAgBpH,IACpC,cAAE2C,GAAkB3C,EACpB0I,GAAa,IAAAV,qBAAoBrF,GACjCgL,GAAS,IAAA1F,oBAAmBjI,GAE5BwH,EAAY0F,EAAS,aACrBzF,EAAWyF,EAAS,YACpBz0B,EAAQy0B,EAAS,SAIvB,MAAO,CACLxE,aACAiF,SACAl1B,QACA+uB,YACAC,WACAmG,YAAa,EACbC,UAAWp1B,EACXq1B,YAAa,EACbpG,OAZawF,EAAS,UAatBa,QAZmB5rC,KAAKsmC,sBAAsBrB,EAAgBpH,GAclE,CAYQ,2BAAAyM,CACNvrC,EACA8+B,EACAC,EACAC,GAUA,GAP6B/9B,KAAK0qC,wBAChC3rC,EACA8+B,EACAC,EACAC,GAIA,OAAO,EAYT,QAR0B/9B,KAAK49B,gBAC7B7+B,EACA8+B,EACAC,EACAC,EACA,eAGF,CAGF,EAGF2L,EAAevE,SAAW,iBAC1B,4CC9cA,MAAM0G,EAAwC,CAC5CC,eAAe,EACfC,mBAAoB,EACpBC,qBAAsB,EACtBC,+BAAgC,EAChCC,YAAY,EACZC,oBAAoB,EACpBC,UAAW,GACXC,kBAAmB,IACnBC,eAAgB,EAChBC,uBAAwB,KAyB1B,QAtBA,WACE,OAAOV,CACT,inBCmBA,MAAMW,UAAkCC,EAAA,EAatC,WAAA9tC,CACE0+B,EAA6B,CAAC,EAC9BC,EAA8B,CAC5BC,0BAA2B,CAAC,QAAS,SACrCC,cAAe,CACb+H,QAAQ,EACR9H,2BAA2B,KAI/B5+B,MAAMw+B,EAAWC,GAWnB,KAAA4L,iBAAoB1/B,IAClB,MAAM+0B,EAAc/0B,EAAImrB,QAClB,cAAEgM,EAAa,QAAE5hC,GAAYw/B,EAC7Bv8B,EAAW2+B,EAAcC,MAEzB9qB,GAAiB,IAAA6T,mBAAkB5qB,IACnC,SAAE0E,EAAQ,gBAAEyN,GAAoB4E,EAEtC9V,KAAKygC,WAAY,EAEjB,MAAM/yB,EAASjK,EAASuL,aAClB,gBAAEI,EAAe,OAAED,GAAWzB,EAE9Bo3B,EAAW9kC,KAAK+kC,YAAYthC,GAClC,IAAI4K,EAAmB2L,EAEvB,GAAIvW,aAAoB,EAAAipC,cACtBr+B,EAAoBy2B,EAASn2B,MAAM,YAAY,OAC1C,CACLqL,EAAW,wBAAoB8qB,GAC/B,MAAM5qB,EAAc,EAAAmxB,MAAM7lB,UAAUxL,GACpC3L,EAAoB,8BAClB6L,EACAlY,EACAoN,EAEJ,CAEA,MAAM6a,EAAsBxmB,EAASxC,yBAG/B48B,EAAa,CACjBW,aAAa,EACbzoB,aAAa,EACb/N,SAAU,CACRoH,gBAA+B,IAAIA,GACnC0G,iBACA3G,OAAsB,IAAIA,GAC1B8a,sBACA5b,oBACA82B,SAAUnlC,KAAK2+B,cACf3kB,YAEFlP,KAAM,CACJs+B,MAAO,GACPnL,QAAS,CAEP2D,QAAS,CACPnC,UAAU,EACVL,cAAe,KACfoH,iBAAkB,MAEpBxI,OAAQ,CACQ,IAAIh8B,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,IAEpB09B,kBAAmB,MAErBiN,eAAgB,QAIpB,QAAc9O,EAAY9+B,GAE1B,MAAM0/B,GAAsB,IAAAC,gCAC1B3/B,EACAiB,KAAK2+B,eAkBP,OAfA3+B,KAAK4+B,SAAW,CACdf,aACAY,sBACAU,YAAa,EACbK,eAAe,EACfC,UAAU,GAEZz/B,KAAK+jC,cAAchlC,IAEnB,IAAAggC,mBAAkBhgC,GAElByK,EAAIw1B,kBAEJ,EAAA4N,EAAA,GAAsC17B,EAAiButB,GAEhDZ,CAAU,EAUnB,KAAA2G,iBAAmB,CACjB1uB,EACA2uB,KAEA,IAAIC,GAAe,EACnB,MAAM,SAAEjhC,GAAaqS,GACf,QAAE/W,GAAY0E,EACpB,IAAIkhC,GAAc,QAAe3kC,KAAK2+B,cAAe5/B,GAErD,IAAK4lC,GAAa76B,OAChB,OAAO46B,EAQT,GALAC,EAAc3kC,KAAK6kC,wCACjB9lC,EACA4lC,IAGGA,GAAa76B,OAChB,OAAO46B,EAGT,MAAMO,EAAiC,CACrCC,YAAallC,KAAKklC,YAClBC,SAAUnlC,KAAK2+B,cACfp7B,WAAYuS,EAAerS,SAASD,IAGtC,IAAK,IAAIwF,EAAI,EAAGA,EAAI27B,EAAY76B,OAAQd,IAAK,CAC3C,MAAM60B,EAAa8G,EAAY37B,IACzB,cAAEw3B,EAAa,KAAE11B,GAAS+yB,GAC1B,OAAEG,EAAM,kBAAE0B,GAAsB50B,EAAKmzB,QACrCmH,EAAoBpH,EAAOz7B,KAAK+8B,GAAM77B,EAAS1B,cAAcu9B,KAEnE2F,EAAezE,cAAgBA,EAE/B,MAAM6E,EAAYrlC,KAAK+qC,SAAS,YAAa9F,EAAgBpH,GACvDyH,EAAWtlC,KAAK+qC,SAAS,WAAY9F,EAAgBpH,GACrDvnB,EAAQ,qBAGd,IAAK7S,EAASuhC,qBAEZ,OADA3zB,QAAQC,KAAK,uCACNozB,EAQT,IAAIkB,EAEJ,IAJA,QAA0B/H,EAAY9+B,KAIjC,IAAA8mC,qBAAoBrF,GACvB,SAYF,IARG,IAAAsF,oBAAmBjI,IACnB79B,KAAK4+B,UACgB,OAAtBc,IAGAkG,EAA2B,CAACR,EAAkB1F,KAG5CkG,EAA0B,CAC5B,MAAMG,EAAiB,KAEvB,IAAAC,aACEvB,EACAjE,EACAuF,EACAH,EACA,CACEtvB,SAGN,CAEA,MAAMu2B,EAAe,KACrB,IAAAC,UACErI,EACAjE,EACAqM,EACAzH,EAAkB,GAClBA,EAAkB,GAClB,CACE9uB,QACAgvB,WACAD,cAIJX,GAAe,CACjB,CAEA,OAAOA,CAAY,CA3MrB,EA+MF8H,EAA0BrH,SAAW,6DCjOrC,MAAM,sBAAExN,GAA0B,YAclC,MAAMoV,UAA0CN,EAAA,EAa9C,WAAA9tC,CACE0+B,EAA6B,CAAC,EAC9BC,EAA8B,CAC5BE,cAAe,CACbwP,qBAAsB,GACtBC,2BAA2B,KAI/BpuC,MAAMw+B,EAAWC,GAiBnB,KAAA4L,iBAAoB1/B,IAClB,MAAM+0B,EAAc/0B,EAAImrB,QAClB,cAAEgM,EAAa,QAAE5hC,GAAYw/B,EAC7Bv8B,EAAW2+B,EAAcC,MAEzB9qB,GAAiB,IAAA6T,mBAAkB5qB,IACnC,SAAE0E,EAAQ,gBAAEyN,GAAoB4E,EAEtC9V,KAAKygC,WAAY,EAEjB,MAAM/yB,EAASjK,EAASuL,aAClB,gBAAEI,EAAe,OAAED,GAAWzB,EAEpC,IAAIW,EAAmB6L,EAAaF,EACpC,GAAIvW,aAAoB,EAAAipC,cACtB,MAAM,IAAI/kC,MAAM,kCACX,CACL,MAAMm9B,EAAW9kC,KAAK+kC,YAAYthC,GAClCuW,EAAW,wBAAoB8qB,GAC/B5qB,EAAc,EAAAmxB,MAAM7lB,UAAUxL,GAC9B3L,EAAoB,8BAClB6L,EACAlY,EACAoN,EAEJ,CAEA,IAAKf,EACH,MAAM,IAAI1G,MAAM,qDAGlB,MAAMulC,EAAazpC,EAASsL,yBACtBo+B,EAAkB,wCACtBjzB,EACA9K,GAOIg+B,EAAWptC,KAAKqtC,kBACpBnzB,EACAlY,EACAmrC,EACA/9B,GAGI6a,EAAsBxmB,EAASxC,yBAE/B48B,EAAa,CACjBW,aAAa,EACbzoB,aAAa,EACb/N,SAAU,CACRoH,gBAA+B,IAAIA,GACnC0G,iBACA3G,OAAsB,IAAIA,GAC1B8a,sBACA5b,oBACA82B,SAAUnlC,KAAK2+B,cACf3kB,WACAmzB,mBAEFriC,KAAM,CACJs+B,MAAO,GACPkE,WAAYJ,EACZK,SAAUH,EACV3H,YAAa,CACX+H,eAAgB,GAChBC,iBAAkB,GAClBC,yBAA0B,CAACr/B,IAE7B4vB,QAAS,CAEP2D,QAAS,CACPnC,UAAU,EACVL,cAAe,KACfoH,iBAAkB,MAEpBxI,OAAQ,CACQ,IAAIh8B,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,IAEpB09B,kBAAmB,MAErBiO,YAAa,OAOjB3tC,KAAK4tC,yBAAyB/P,EAAY3jB,IAE1C,QAAc2jB,EAAY9+B,GAE1B,MAAM0/B,GAAsB,IAAAC,gCAC1B3/B,EACAiB,KAAK2+B,eAkBP,OAfA3+B,KAAK4+B,SAAW,CACdf,aACAY,sBACAU,YAAa,EACbK,eAAe,EACfC,UAAU,GAEZz/B,KAAK+jC,cAAchlC,IAEnB,IAAAggC,mBAAkBhgC,GAElByK,EAAIw1B,kBAEJ,EAAA4N,EAAA,GAAsC17B,EAAiButB,GAEhDZ,CAAU,EAGnB,KAAA0B,aAAgB/1B,IACd,MAAM+0B,EAAc/0B,EAAImrB,QAClB,QAAE51B,GAAYw/B,GAEd,WAAEV,EAAU,oBAAEY,EAAmB,cAAEe,EAAa,SAAEC,GACtDz/B,KAAK4+B,UACD,KAAE9zB,GAAS+yB,EAEjB,GAAI2B,IAAkBC,EACpB,OAGF30B,EAAKmzB,QAAQyB,kBAAoB,KAEjC1/B,KAAK2/B,kBAAkB5gC,GACvBiB,KAAK4/B,gBAAgB7gC,IAErB,IAAA8gC,oBAAmB9gC,GAEnB,MAAM+W,GAAiB,IAAA6T,mBAAkB5qB,GAEzCiB,KAAK4+B,SAAW,KAChB5+B,KAAKygC,WAAY,EAGfzgC,KAAKsgC,sBACLtgC,KAAKw9B,cAAcC,4BAEnB,QAAiBI,EAAW2C,eAG9B,MAAMsE,EAAW9kC,KAAK+kC,YAAYjvB,EAAerS,UAC3CyW,EAAc,EAAAmxB,MAAM7lB,UAAUsf,EAASn2B,MAAM,gBAAgB,IAE/D3O,KAAKw9B,cAAcqQ,6BACrB7tC,KAAK8tC,2BAA2BjQ,EAAY3jB,EAAapE,IAG3D,EAAA82B,EAAA,GACE92B,EAAe5E,gBACfutB,GAGEe,IACF,QAA2B3B,EAC7B,EAkKF,KAAA2G,iBAAmB,CACjB1uB,EACA2uB,KAEA,IAAIC,GAAe,EACnB,MAAM,SAAEjhC,GAAaqS,EAEf6uB,GAAc,QAAe3kC,KAAK2+B,cAAel7B,EAAS1E,SAEhE,IAAK4lC,GAAa76B,OAChB,OAAO46B,EAGT,MAAMt9B,EAAa3D,EAASsL,yBAEtBk2B,EAAiC,CACrCC,YAAallC,KAAKklC,YAClBC,SAAUnlC,KAAK2+B,cACfp7B,WAAYuS,EAAerS,SAASD,IAGtC,IAAK,IAAIwF,EAAI,EAAGA,EAAI27B,EAAY76B,OAAQd,IAAK,CAC3C,MAAM60B,EAAa8G,EACjB37B,IAEI,cAAEw3B,EAAa,KAAE11B,GAAS+yB,GAC1B,WAAEyP,EAAU,SAAEC,GAAaziC,GAC3B,OAAEkzB,EAAM,kBAAE0B,GAAsB50B,EAAKmzB,QAErCmH,EAAoBpH,EAAOz7B,KAAK+8B,GAAM77B,EAAS1B,cAAcu9B,KAEnE2F,EAAezE,cAAgBA,EAE/B,MAAM6E,EAAYrlC,KAAK+qC,SAAS,YAAa9F,EAAgBpH,GACvDyH,EAAWtlC,KAAK+qC,SAAS,WAAY9F,EAAgBpH,GACrDvnB,EAAQ,qBAKd,GACElP,EAAaxG,KAAK2W,IAAI+1B,EAAYC,IAClCnmC,EAAaxG,KAAKsM,IAAIogC,EAAYC,GAElC,SAKE1P,EAAW9nB,aACb/V,KAAK0lC,+BAA+B7H,EAAY/nB,GAKlD,IAWI8vB,EAXAmI,GAAmB,EAMvB,GALI3mC,IAAekmC,GAAclmC,IAAemmC,IAC9CQ,GAAmB,IAIhBtqC,EAASuhC,qBAEZ,OADA3zB,QAAQC,KAAK,uCACNozB,EAKT,KAAK,IAAAmB,qBAAoBrF,GACvB,SAaF,IATG,IAAAsF,oBAAmBjI,IACnB79B,KAAK4+B,UACgB,OAAtBc,IACAqO,IAGAnI,EAA2B,CAACR,EAAkB1F,KAG5CkG,EAA0B,CAC5B,MAAMG,EAAiB,KAEvB,IAAAC,aACEvB,EACAjE,EACAuF,EACAH,EACA,CACEtvB,SAGN,CAEA,IAAI03B,EAAgB1I,EAEfyI,IACHC,EAAgB,GAGlB,MAAMnB,EAAe,KACrB,IAAAC,UACErI,EACAjE,EACAqM,EACAzH,EAAkB,GAClBA,EAAkB,GAClB,CACE9uB,QACAgvB,SAAU0I,EACV3I,cAIJX,GAAe,CACjB,CAEA,OAAOA,CAAY,EA9cnB1kC,KAAK0lC,gCAAiC,EAAAuI,EAAA,GACpCjuC,KAAKkuC,0BACL,IACA,CAAEjF,UAAU,GAEhB,CAoLA,wBAAA2E,CACE/P,EACA3jB,GAEA,MAAM,KAAEpP,EAAI,SAAE9C,GAAa61B,GACrB,gBAAEzuB,EAAe,gBAAE+9B,GAAoBnlC,GACvC,UAAEgD,GAAckP,GAChB,WAAEozB,EAAU,SAAEC,GAAaziC,GAC3B,OAAEkzB,GAAWlzB,EAAKmzB,QAElBkQ,EAAWxW,EAAsB3sB,EAAWgzB,EAAO,IAEzD,GAAImQ,EAAS,KAAOb,EAClB,MAAM,IAAI3lC,MAAM,8BAIlB,MAAMymC,EAAS,gBAAgBD,EAAS,GAAIA,EAAS,GAAIZ,GAEnDc,EAAa,cACnBrjC,EAAUsjC,iBAAiBH,EAAUE,GAErC,MAAME,EAAW,cACjBvjC,EAAUsjC,iBAAiBF,EAAQG,GAGnC,MAAMC,EAAW,cAAcH,EAAYE,GAIrCE,EAAsB,GAC5B,IAAK,IAAIC,EAAO,EAAGA,EAAOF,EAAUE,GAAQvB,EAC1CsB,EAAoB79B,KAClBotB,EAAOz7B,KAAK8I,IACV,MAAMsjC,EAAW,cAEjB,OADA,iBAAiBA,EAAUtjC,EAAO+D,EAAiBs/B,GAC5CpnC,MAAM6Z,KAAKwtB,EAAS,KAKjC7jC,EAAK26B,YAAYgI,iBAAmBgB,EAGpC,MAAMf,EAA2B,GACjC,IAAK,MAAMkB,KAAmBH,EAAqB,CACjD,MAAMppC,EAAU,8BACd6U,EACA00B,EAAgB,GAChBx/B,GAEFs+B,EAAyB98B,KAAKvL,EAChC,CAEAyF,EAAK26B,YAAYiI,yBAA2BA,CAC9C,CAGA,0BAAAI,CAA2BjQ,EAAY3jB,EAAapE,GAClD,MAAM,KAAEhL,GAAS+yB,EACX4P,EAAmB3iC,EAAK26B,YAAYgI,iBAEpCoB,EAAuC,CAAC,IAE9C,IAAK,IAAI7lC,EAAI,EAAGA,EAAIykC,EAAiB3jC,OAAQd,IAAK,CAIhD,IAAKkR,EACH,SAGF,MAAM40B,EAAkBrB,EAAiBzkC,GAAG,GAEtCu+B,EAAYz8B,EAAKmzB,QAAQD,OAAO,GAChCwJ,EAAY18B,EAAKmzB,QAAQD,OAAO,IAEhC,WAAEp3B,EAAU,UAAEoE,GAAckP,EAE5B60B,EAAiBpX,EAAsB3sB,EAAWu8B,GAElDyH,EAA4BrX,EAChC3sB,EACA8jC,GAGFC,EAAe,GAAKnuC,KAAK6O,MAAMs/B,EAAe,IAC9CA,EAAe,GAAKnuC,KAAK6O,MAAMs/B,EAAe,IAC9CA,EAAe,GAAKnuC,KAAK6O,MAAMu/B,EAA0B,IAEzD,MAAMC,EAAiBtX,EAAsB3sB,EAAWw8B,GASxD,GAPAyH,EAAe,GAAKruC,KAAK6O,MAAMw/B,EAAe,IAC9CA,EAAe,GAAKruC,KAAK6O,MAAMw/B,EAAe,IAC9CA,EAAe,GAAKruC,KAAK6O,MAAMu/B,EAA0B,IAKrDhvC,KAAK6oC,gBAAgBkG,EAAgBE,EAAgBroC,GAAa,CACpE5G,KAAKsgC,sBAAuB,EAC5B,MASM4O,EAAY,CAChB,CAVWtuC,KAAK2W,IAAIw3B,EAAe,GAAIE,EAAe,IAC3CruC,KAAKsM,IAAI6hC,EAAe,GAAIE,EAAe,KAUtD,CARWruC,KAAK2W,IAAIw3B,EAAe,GAAIE,EAAe,IAC3CruC,KAAKsM,IAAI6hC,EAAe,GAAIE,EAAe,KAQtD,CANWruC,KAAK2W,IAAIw3B,EAAe,GAAIE,EAAe,IAC3CruC,KAAKsM,IAAI6hC,EAAe,GAAIE,EAAe,MAQlDE,GAAgB,IAAAC,sBACpBpkC,GACA,KAAM,GACN,KACAkkC,GAIFL,EAAmBj+B,KAAKu+B,EAC1B,CACF,CACArkC,EAAK26B,YAAY+H,eAAiBqB,CACpC,CAEA,yBAAAX,CAA0BrQ,EAAY/nB,GACpC,MAAMhL,EAAO+yB,EAAW/yB,MAClB,SAAErH,GAAaqS,GAEf,YAAE2vB,GAAgB36B,EAClBg6B,EAAW9kC,KAAK+kC,YAAYthC,GAC5ByW,EAAc,EAAAmxB,MAAM7lB,UAAUsf,EAASn2B,MAAM,gBAAgB,IAYnE,OAPA3O,KAAK4tC,yBAAyB/P,EAAY3jB,GAE1C2jB,EAAW9nB,aAAc,GAGzB,QAA0B8nB,EAAYp6B,EAAS1E,SAExC0mC,CACT,CAmIA,iBAAA4H,CACEnzB,EACAlY,EACAmrC,EACA/9B,GAEA,MAAM49B,EAAuBhtC,KAAKw9B,cAAcwP,qBAI1CqC,EAAS,cACf,iBACEA,EACArtC,EACAoN,EACA49B,EAAuBG,GAGzB,MAAMmC,EAA+BnC,EAAkB,GAEjD,SAAEnmC,GAAakT,EACrB,IAAIwB,EACJ,IAAK,IAAI1S,EAAI,EAAGA,EAAIhC,EAAS8C,OAAQd,IAAK,CACxC,MAAM3D,EAAU2B,EAASgC,IAEnB,qBAAE/C,GAAyB,EAAA0lB,SAAA,IAC/B,mBACAtmB,GAGIkqC,EAAM,cACZ,SAASA,EAAKF,EAAQppC,GAEtB,MAAMupC,EAAM,SAASD,EAAKngC,GAEtBxO,KAAK6uC,IAAID,GAAOF,IAClB5zB,EAAe1S,EAEnB,CAEA,OAAO0S,CACT,EAGFqxB,EAAkC5H,SAAW,+HClkB9B,MAAMuK,SACF,KAAAhxC,oBACf,yCAA0C,CAElC,sBAAOixC,CAAgBtqC,GAC/B,MAAM+G,EAAQ/G,EAAQ+G,MAAMpM,KAAKtB,qBACjC,IAAK0N,IAAUA,EAAM,GACnB,OAAO,KAET,MAAMsC,EAAQtC,EAAM,GAAGuC,MAAM,KAAKpM,KAAKC,GAAOoM,OAAOpM,KACrD,OAAqB,IAAjBkM,EAAM5E,OACD4E,EAAM,GAERA,CACT,CAEO,qBAAOkhC,CAAelhC,GAC3B,OAAIpH,MAAMC,QAAQmH,GACT,GAAGA,EAAM,MAAMA,EAAM,KAEvBmhC,OAAOnhC,EAChB,CAEU,sBAAOohC,CACfzqC,EACAqJ,GAEA,MAAMtC,EAAQ/G,EAAQ+G,MAAMpM,KAAKtB,qBACjC,IAAK0N,IAAUA,EAAM,GACnB,OAAO,KAET,MAAM2jC,EAAiB/vC,KAAK4vC,eAAelhC,GAC3C,OAAOrJ,EAAQ0D,QACb/I,KAAKtB,oBACL,GAAG0N,EAAM,KAAK2jC,IAElB,CAQO,oBAAO1nC,CACZw1B,EACAnvB,EACAshC,GAEA,MAAM,kBAAE3hC,GAAsBwvB,EAAW71B,SACzC61B,EAAW71B,SAASqG,kBAAoBrO,KAAK8vC,gBAC3CzhC,EACAK,GAEF,MAAM6vB,EAAc,IACfyR,EACHnS,eAEF,IAAAx6B,cAAa,EAAA4sC,YAAa,UAAOC,oBAAqB3R,EACxD,CAEO,oBAAOx0B,CACZ8zB,GAEA,OAAO79B,KAAK2vC,gBAAgB9R,EAAW71B,SAASqG,kBAClD,0EC6BF,SAAS8hC,EACP1sC,EACAzB,EACAoN,GAEA,MAAMpI,EAAWvD,EAASoF,cAC1B,IAAK7B,IAAaA,EAAS8C,OACzB,OAGF,MAAMsmC,EAAqBppC,EAASzE,KAAK8C,IACvC,MAAM,qBAAEY,GAAyB,EAAA0lB,SAAA,IAAa,mBAAoBtmB,GAC5DmpC,EAaV,SACExsC,EACAquC,EACAjhC,GAEA,MAAMmgC,EAAM,cACZ,SAASA,EAAKvtC,EAAUquC,GAExB,MAAMb,EAAM,SAASD,EAAKngC,GAE1B,OAAOxO,KAAK6uC,IAAID,EAClB,CAxBqBc,CACftuC,EACAiE,EACAmJ,GAEF,MAAO,CAAE/J,UAASmpC,WAAU,IAK9B,OAFA4B,EAAmB18B,MAAK,CAACZ,EAAGC,IAAMD,EAAE07B,SAAWz7B,EAAEy7B,WAE1C4B,EAAmB,GAAG/qC,OAC/B,wEC7HA,MAAM,QAAEkrC,GAAY,EAAAC,UAOpB,SAASC,EACPzS,EACAp3B,EACA8pC,GAAU,GAEV,IAAIC,EAAOC,IACPC,EAAOH,GAAWE,IAAW,EAC7BE,EAAOF,IACPG,EAAOL,GAAWE,IAAW,EAC7BI,EAAOJ,IACPK,EAAOP,GAAWE,IAAW,EAEjC,MAAMM,EAA6B,IAAtBlT,EAAO,IAAIl0B,OAGxB,IAAK,IAAId,EAAI,EAAGA,EAAIg1B,EAAOl0B,OAAQd,IAAK,CACtC,MAAMs2B,EAAItB,EAAOh1B,GACjB2nC,EAAO/vC,KAAK2W,IAAI+nB,EAAE,GAAIqR,GACtBE,EAAOjwC,KAAKsM,IAAIoyB,EAAE,GAAIuR,GACtBC,EAAOlwC,KAAK2W,IAAI+nB,EAAE,GAAIwR,GACtBC,EAAOnwC,KAAKsM,IAAIoyB,EAAE,GAAIyR,GAElBG,IACFF,EAAOpwC,KAAK2W,IAAI+nB,EAAE,IAAM0R,EAAMA,GAC9BC,EAAOrwC,KAAKsM,IAAIoyB,EAAE,IAAM2R,EAAMA,GAElC,CAkCA,OAhCIrqC,GACF+pC,EAAO/vC,KAAKsM,IAAIwjC,EAAU9pC,EAAW,GAAK2pC,EAAU,EAAGI,GACvDE,EAAOjwC,KAAK2W,IACVm5B,EAAU9pC,EAAW,GAAK2pC,EAAU3pC,EAAW,GAAK,EACpDiqC,GAEFC,EAAOlwC,KAAKsM,IAAIwjC,EAAU9pC,EAAW,GAAK2pC,EAAU,EAAGO,GACvDC,EAAOnwC,KAAK2W,IACVm5B,EAAU9pC,EAAW,GAAK2pC,EAAU3pC,EAAW,GAAK,EACpDmqC,GAGEG,GAA8B,IAAtBtqC,EAAWkD,SACrBknC,EAAOpwC,KAAKsM,IAAIwjC,EAAU9pC,EAAW,GAAK2pC,EAAU,EAAGS,GACvDC,EAAOrwC,KAAK2W,IACVm5B,EAAU9pC,EAAW,GAAK2pC,EAAU3pC,EAAW,GAAK,EACpDqqC,KAGMP,IAEVC,EAAO/vC,KAAKsM,IAAI,EAAGyjC,GACnBE,EAAOjwC,KAAK2W,IAAIq5B,IAAUC,GAC1BC,EAAOlwC,KAAKsM,IAAI,EAAG4jC,GACnBC,EAAOnwC,KAAK2W,IAAIq5B,IAAUG,GAEtBG,IACFF,EAAOpwC,KAAKsM,IAAI,EAAG8jC,GACnBC,EAAOrwC,KAAK2W,IAAIq5B,IAAUK,KAIvBC,EACH,CACE,CAACP,EAAME,GACP,CAACC,EAAMC,GACP,CAACC,EAAMC,IAET,CAAC,CAACN,EAAME,GAAO,CAACC,EAAMC,GAAO,KACnC,CAWO,SAASI,EACdnT,EACAp3B,GAEA,OAAO6pC,EAAqBzS,EAAQp3B,GAAY,EAClD,CAWO,SAASwqC,EACdpT,EACAqT,GAEA,OAAOZ,EAAqBzS,EAAQqT,GAAY,EAClD,gKC1GA,MAAM,uCAAEC,GAA2C,EAAAC,wCCA9Cv2B,cAAL,SAAKA,GACH,+CACA,8CACD,CAHD,CAAKA,IAAAA,EAAM,cCcX,MAAM,eAAEiO,GAAmB,EAAAuoB,OACrB,aAAEnuC,GAAiB,YAGQ,IAAIuf,qBCX9B,SAAS6uB,EAAKC,EAAKC,EAAKC,GAC7B,OAAOhxC,KAAK2W,IAAI3W,KAAKsM,IAAIykC,EAAKD,GAAME,EACtC,mBAiBA,2DCtBO,SAASC,EACdhU,GAEA,GAAIA,EAAWiU,oBAEb,OAEF,IAAKjU,EAAW/yB,KAAKinC,aACnB,MAAM,IAAIpqC,MACR,kFAIJ,MAAM,eAAEglC,EAAc,aAAEqF,GAAiBnU,EAAW/yB,KAAKinC,aACnDA,GAAe,IAAAE,iBAAgBtF,GAEhCoF,EAAaG,mBAAmBC,UACnCJ,EAAaG,mBAAmBC,QAAU,CAAEC,kBAAmB,IAAIxvB,MAGrE,MAAM,kBAAEwvB,GAAsBL,EAAaG,mBAAmBC,QAE9D,IAAIE,EAAqBD,EAAkBrmC,IAAIimC,GAE1CK,IACHA,EAAqB,IAAIC,IACzBF,EAAkB70B,IAAIy0B,EAAcK,IAGtCD,EAAkB70B,IAChBy0B,EACAK,EAAmBpwB,IAAI4b,EAAW2C,eAEtC,kPC9BO,SAAS+R,EACd1U,GAEA,IAAKA,EAAW/yB,KAAKinC,aACnB,MAAM,IAAIpqC,MACR,qFAIJ,MAAM,eAAEglC,EAAc,aAAEqF,GAAiBnU,EAAW/yB,KAAKinC,aACnDA,EAAe,EAAAS,MAAA,gBAAsB7F,IACrC,kBAAEyF,GAAsBL,GAAcG,mBAAmBC,SAAW,CAAC,EACrEE,EAAqBD,GAAmBrmC,IAAIimC,GAE7CK,IAILA,EAAmB5zB,OAAOof,EAAW2C,eAGhC6R,EAAmB/pB,MACtB8pB,EAAkB3zB,OAAOuzB,GAE7B,mCCJA,QAvBA,SAA4BS,EAAsBC,GAChD,IAAIC,EAAY,EAEhB,IAAK,IAAI3pC,EAAI,EAAGA,EAAIypC,EAAS3oC,OAAS,EAAGd,IAAK,CAC5C,MAAM4pC,EAASH,EAASzpC,GAClB6pC,EAASJ,EAASzpC,EAAI,GAC5B2pC,GAAa/xC,KAAKiZ,KAChBjZ,KAAKwS,IAAIy/B,EAAO,GAAKD,EAAO,GAAI,GAAKhyC,KAAKwS,IAAIy/B,EAAO,GAAKD,EAAO,GAAI,GAEzE,CAEA,GAAIF,EAAQ,CACV,MAAMI,EAAaL,EAAS,GACtBM,EAAYN,EAASA,EAAS3oC,OAAS,GAC7C6oC,GAAa/xC,KAAKiZ,KAChBjZ,KAAKwS,IAAI2/B,EAAU,GAAKD,EAAW,GAAI,GACrClyC,KAAKwS,IAAI2/B,EAAU,GAAKD,EAAW,GAAI,GAE7C,CAEA,OAAOH,CACT,8DCvBA,MAAM,QAAEK,GAAY,YAeL,SAASC,EACtBpV,EACAsB,GAEA,MAAM,SAAEsT,GAAa5U,EAAW/yB,KAAKooC,SAC/B,OAAElV,GAAWH,EAAW/yB,KAAKmzB,SAC7B,OAAEn0B,GAAWk0B,EACnB,GAAImB,IAAgBr1B,EAClB,OAAO2oC,EAAS3oC,OAKlB,GAHIq1B,EAAc,IAChBA,GAAeA,EAAcr1B,GAAUA,GAErB,IAAhBq1B,EACF,OAAO,EAET,MAAMD,EAASlB,EAAOmB,GAChB5yB,EAAQkmC,EAASpT,WAAWh0B,GAAU2nC,EAAQ9T,EAAQ7zB,KAC5D,IAAe,IAAXkB,EACF,OAAOA,EAGT,IAAI4mC,EAAkBvC,IACtB,OAAO6B,EAASW,QAAO,CAACC,EAAchoC,EAAOioC,KAC3C,MAAM9E,EAAW,qBAAqBnjC,EAAO6zB,GAC7C,OAAIsP,EAAW2E,GACbA,EAAkB3E,EACX8E,GAEFD,CAAY,IACjB,EACN,qJC1CA,MAAM,SAAEE,GAAaC,EAAA,uBCGrB,MAAMC,SACG,KAAAC,WAAkC,CAAC,CAAE,CAE5C,WAAA/0C,GAEA,CAEA,cAAOg1C,CAAQ9V,EAAYtxB,EAAOqnC,IAjBpC,SAA4B/V,GAC1B,IAAKA,GAAY/yB,KACf,MAAM,IAAInD,MAAM,sBAGlB,IAAKk2B,EAAW71B,UAAY61B,EAAW71B,SAAS6rC,iBAC9C,MAAM,IAAIlsC,MAAM,+CAEpB,CAUImsC,CAAmBjW,GAEnB,MAAM,SAAEsH,GAAatH,EAAW71B,SAC1B+rC,EAAYN,EAAsBC,WAAWvO,GAEnD,IAAK4O,EACH,MAAM,IAAIpsC,MACR,sBAAsBw9B,mCAO1B,MAAM6O,EAAkBD,EAAUE,mBAChCpW,EACA+V,GAUF,MAAO,CACLM,oBAAqB3nC,EAAQ,EAC7B4nC,gBARY,CACZvzC,KAAK6O,MAAsB,IAAhB7O,KAAKwzC,UAChBxzC,KAAK6O,MAAsB,IAAhB7O,KAAKwzC,UAChBxzC,KAAK6O,MAAsB,IAAhB7O,KAAKwzC,WAMhBJ,kBAEJ,CAEA,eAAOK,CAASN,GACdN,EAAsBC,WAAWK,EAAU5O,UAAY4O,CACzD,EAGFN,EAAsBY,SAASC,EAAA,kBChDhB,SAASC,EACtB1W,EACAp6B,GAEA,MAAM+wC,ECJO,SACb3W,GAIA,OAF4BA,EAAW4W,qBAAuB,IAEnClyC,KACxBsO,IAAS,QAAcA,GAA2B/F,KAAKooC,QAAQT,UAEpE,CDJ4BiC,CAAyB7W,GAC7C8W,EAAqB,GAgB3B,OAdAH,EAAkBjkC,SAASqkC,IACzB,MAAMC,EAAYD,EAAiB9qC,OAG7BgrC,EAAoC,IAAIxtC,MAAMutC,GAGpD,IAAK,IAAI7rC,EAAI,EAAGA,EAAI6rC,EAAW7rC,IAC7B8rC,EAAkB9rC,GAAKvF,EAAS1B,cAAc6yC,EAAiB5rC,IAGjE2rC,EAAmB/jC,KAAKkkC,EAAkB,IAGrCH,CACT,8LETe,SAASI,EACtBlX,EACAmX,EAKAC,EAIAhuC,GAOA,MAAM,cAAE3F,EAAa,cAAES,GAAkBkzC,GACnC,KAAEnqC,GAAS+yB,GACX,uBAAEqX,GAA2BF,EACnC,IAAMhX,OAAQyU,GAAauC,EAGvB/tC,GAASkuC,UAAUr4B,UACrB21B,EAAW,oBACTuC,EAAahX,OACb/2B,GAASkuC,UAAUC,UAIvB,IAAI,OAAE1C,GAAWsC,EACjB,MAAMH,EAAYpC,EAAS3oC,OACrBurC,EAAsB,IAAI/tC,MAAMutC,GAChCS,EACJ,+BAAkC7C,GAC9B8C,GAAmB,QAAoB1X,GAE7C,QAAe5zB,IAAXyoC,EAAsB,CACxB,IAAI8C,GAAqB,EAGzB,GAAI/C,EAAS3oC,OAAS,EAAG,CACvB,MAAM2rC,EAAkB,+BACtBhD,EAAS,GACTA,EAASoC,EAAY,IAGvBW,EAAqB,oBAAgB,EAAGC,EAC1C,CAEA/C,EAAS8C,CACX,CAGA,IAAIE,EAAmBH,GAC+B,EAAlDA,EAAiBzqC,KAAKooC,QAAQwC,iBAC9BR,OAEqBjrC,IAArByrC,IACFA,EAAmBJ,GAGjBI,IAAqBJ,GACvB7C,EAASkD,UAGX,MAAMC,EAAe9qC,EAAKmzB,QAAQD,OAAOz7B,KAAK+8B,GAAMv9B,EAAcu9B,KAElE,GAAIsW,EAAa9rC,OAAS,EAAG,CAEzB,+BAAkC8rC,KAEGF,GACrC5qC,EAAKmzB,QAAQD,OAAO2X,SAExB,CAEA,IAAK,IAAI3sC,EAAI,EAAGA,EAAI6rC,EAAW7rC,IAC7BqsC,EAAoBrsC,GAAK1H,EAAcmxC,EAASzpC,IAGlD8B,EAAKooC,QAAQT,SAAW4C,EACxBvqC,EAAKooC,QAAQR,OAASA,EACtB5nC,EAAKooC,QAAQwC,iBAAmBA,GAEhC,QAAqB7X,EACvB,mDC0GA,QA3JA,SAAkBgY,EAAMC,EAAM7uC,GAC5B,IAAI8uC,EAAUC,EAAUC,EAASC,EAAQC,EAASC,EAE9CC,EAAiB,EACjBC,GAAU,EACVC,GAAS,EACTtN,GAAW,EAGf,MAAMuN,GACHV,GAAiB,IAATA,GAAsD,mBAAjCttC,OAAOpE,sBAEvC,GAAoB,mBAATyxC,EACT,MAAM,IAAIY,UAAU,uBAUtB,SAASC,EAAW/yC,GAClB,MAAMi2B,EAAOmc,EACPY,EAAUX,EAMhB,OAJAD,EAAWC,OAAW/rC,EACtBosC,EAAiB1yC,EACjBuyC,EAASL,EAAKe,MAAMD,EAAS/c,GAEtBsc,CACT,CAEA,SAASW,EAAWC,EAAahB,GAC/B,OAAIU,EACKhuC,OAAOpE,sBAAsB0yC,GAG/BruC,WAAWquC,EAAahB,EACjC,CA6BA,SAASiB,EAAapzC,GACpB,MAAMqzC,EAAoBrzC,EAAOyyC,EAMjC,YACmBnsC,IAAjBmsC,GACAY,GAAqBlB,GACrBkB,EAAoB,GACnBT,GATyB5yC,EAAO0yC,GASCJ,CAEtC,CAEA,SAASgB,IACP,MAAMtzC,EAAOqhB,KAAKC,MAElB,GAAI8xB,EAAapzC,GACf,OAAOuzC,EAAavzC,GAGtBwyC,EAAUU,EAAWI,EAhCvB,SAAuBtzC,GACrB,MACMwzC,EAAsBxzC,EAAO0yC,EAC7Be,EAActB,GAFMnyC,EAAOyyC,GAIjC,OAAOG,EACH31C,KAAK2W,IAAI6/B,EAAanB,EAAUkB,GAChCC,CACN,CAwBqCC,CAAc1zC,GACnD,CAEA,SAASuzC,EAAavzC,GAKpB,OAJAwyC,OAAUlsC,EAINg/B,GAAY8M,EACPW,EAAW/yC,IAEpBoyC,EAAWC,OAAW/rC,EAEfisC,EACT,CAkBA,SAASoB,KAAa1d,GACpB,MAAMj2B,EAAOqhB,KAAKC,MACZsyB,EAAaR,EAAapzC,GAMhC,GAJAoyC,EAAWnc,EACXoc,EAAWh2C,KACXo2C,EAAezyC,EAEX4zC,EAAY,CACd,QAAgBttC,IAAZksC,EACF,OApFN,SAAqBxyC,GAOnB,OALA0yC,EAAiB1yC,EAEjBwyC,EAAUU,EAAWI,EAAcnB,GAG5BQ,EAAUI,EAAW/yC,GAAQuyC,CACtC,CA4EasB,CAAYpB,GAErB,GAAIG,EAIF,OAFAJ,EAAUU,EAAWI,EAAcnB,GAE5BY,EAAWN,EAEtB,CAKA,YAJgBnsC,IAAZksC,IACFA,EAAUU,EAAWI,EAAcnB,IAG9BI,CACT,CAKA,OAzIAJ,EAAOlnC,OAAOknC,IAAS,GACnB,OAAS7uC,KACXqvC,EAAUmB,QAAQxwC,EAAQqvC,SAC1BC,EAAS,YAAatvC,EACtBgvC,EAAUM,EAAS31C,KAAKsM,IAAI0B,OAAO3H,EAAQgvC,UAAY,EAAGH,GAAQG,EAClEhN,EAAW,aAAchiC,EAAUwwC,QAAQxwC,EAAQgiC,UAAYA,GAgIjEqO,EAAUppB,OAzCV,gBACkBjkB,IAAZksC,GAlEN,SAAqB3yC,GACnB,GAAIgzC,EACF,OAAOhuC,OAAOkvC,qBAAqBl0C,GAErC2vB,aAAa3vB,EACf,CA8DIm0C,CAAYxB,GAEdE,EAAiB,EACjBN,EAAWK,EAAeJ,EAAWG,OAAUlsC,CACjD,EAoCAqtC,EAAUM,MAlCV,WACE,YAAmB3tC,IAAZksC,EAAwBD,EAASgB,EAAalyB,KAAKC,MAC5D,EAiCAqyB,EAAUO,QA/BV,WACE,YAAmB5tC,IAAZksC,CACT,EA+BOmB,CACT,mBC7Me,SAASvQ,EACtB+Q,GAEA,MAAMC,EAaR,SAA2BC,GACzB,MAAMC,EAAqB,CAACD,EAAa,GAAIA,EAAa,IAAItkC,KAAKwkC,GAC7DC,EAAqB,CAACH,EAAa,GAAIA,EAAa,IAAItkC,KAAK0kC,GAC7DjmC,EAAQ8lC,EAAmBA,EAAmBnuC,OAAS,GACvDs9B,EAAM+Q,EAAmB,GACzBE,EAASF,EAAmBA,EAAmBruC,OAAS,GAE9D,MAAO,CACLs9B,MACAiR,SACAlmC,SAGF,SAAS+lC,EAAUplC,EAAGC,GACpB,OAAOD,EAAE,GAAKC,EAAE,IAAM,EAAI,CAC5B,CACA,SAASqlC,EAAUtlC,EAAGC,GACpB,OAAOD,EAAE,GAAKC,EAAE,IAAM,EAAI,CAC5B,CACF,CAhCkBulC,CAAkBR,GAC5BS,GAAWR,EAAQ3Q,IAAI,GAAK2Q,EAAQM,OAAO,IAAM,EAGvD,MAFoC,CAACN,EAAQ5lC,MAAM,GAAIomC,EAGzD,mMCfA,MAAM,iBAAE7uB,GAAqB,EAAA8nB,MACvBgH,EAAc,KAEdC,EAA8B,CAClC,GAGIC,EAA2B,CAC/B,OAGIC,EAA0B,CAC9B,OAGIC,EAAe,CACnB,EAAG,KACH,EAAG,WAICC,EAAS,IASTC,EAAmC,CAAC1zC,EAAO64B,KAC/C,MAAM,YAAEvyB,EAAW,gBAAElF,GAAoBpB,EACzC,IAAIgjC,EAAQ5hC,EAAkB,KAAOgyC,EACjCO,EAAY3Q,EAAQyQ,EACpB5oC,EAAQ,EACR+oC,EAAkB,GAEtB,IACGttC,IACCA,EAAYiR,OAASjR,EAAYutC,4BAEnC,MAAO,CAAE7Q,QAAO2Q,YAAW9oC,SAG7B,GAAIvE,EAAYiR,OAAS+M,EAAiBwvB,aACxC,MAAO,CAAE9Q,MAAOoQ,EAAaO,UAAWP,EAAcK,EAAQ5oC,SAGhE,GAAIvE,EAAYutC,4BAA6B,CAC3C,IAAIE,EAAaC,EACjB,GAAI9xC,MAAMC,QAAQ02B,IAA+B,IAAnBA,EAAQn0B,QACnCqvC,EAAaC,GAAenb,OACxB,GAAuB,mBAAZA,EAAwB,CACxC,MAAMD,EAASC,IACfkb,EAAcnb,EAAO,GACrBob,EAAcpb,EAAO,EACvB,CAEA,IAAIqb,EAAU3tC,EAAYutC,4BAA4BzrC,QACnD8rC,GACCH,EAAY,IAAMG,EAAOC,qBACzBJ,EAAY,IAAMG,EAAOE,qBACzBL,EAAY,IAAMG,EAAOG,qBACzBN,EAAY,IAAMG,EAAOI,qBACzBN,EAAY,IAAME,EAAOC,qBACzBH,EAAY,IAAME,EAAOE,qBACzBJ,EAAY,IAAME,EAAOG,qBACzBL,EAAY,IAAME,EAAOI,sBAK7B,IAAKL,GAASvvC,OACZ,MAAO,CAAEs+B,QAAO2Q,YAAW9oC,SAc7B,GARAopC,EAAUA,EAAQ7rC,QACf8rC,GACCb,EAA4BvxB,SAASoyB,EAAOK,iBAC5CjB,EAAyBxxB,SACvB,GAAGoyB,EAAOM,2BAA2BN,EAAOO,8BAI7CR,EAAQvvC,OACX,MAAO,CAAEs+B,MAAOoQ,EAAaO,UAAWP,EAAcK,EAAQ5oC,SAIhE,MAAMqpC,EAASD,EAAQ,GAEjBS,EAAiBl5C,KAAK6uC,IAAI6J,EAAOQ,gBACjCC,EAAiBn5C,KAAK6uC,IAAI6J,EAAOS,gBAYvC,IAN4B,EAAAxI,UAAA,QAC1BuI,EACAC,EAnFM,MAkGN,MAAO,CAAE3R,MAAOoQ,EAAaO,UAAWP,EAAcK,EAAQ5oC,SAT9DA,EAAQ,GAAsB,GAAjB6pC,GACbd,EAAkB,YAClB5Q,EAAQ,KACR2Q,EAAY,KAQhB,MAAWrtC,EAAYuE,QACrBA,EAAQvE,EAAYuE,OAetB,MAXc,CACZyZ,EAAiBswB,KACjBtwB,EAAiBuwB,KACjBvwB,EAAiBwwB,MACjBxwB,EAAiBywB,YAGTjzB,SAASxb,GAAaiR,QAC9Bq8B,EAAkBttC,EAAYiR,MAGzB,CACLyrB,MAAOA,GAAS4Q,EAAkB,IAAIA,IAAoB,IAC1DD,UAAWA,GAAaC,EAAkB,IAAIA,IAAoB,IAClE/oC,QACD,EAGGmqC,EAAkC,CAACh1C,EAAO64B,KAC9C,MAAOhH,GAAcgH,GACf,YAAEvyB,GAAgBtG,EACxB,IAAIgjC,EAAQ,CAAC,OACT70B,EAAS,CAAC,MACVylC,EAAkB,GAEtB,IACGttC,IACCA,EAAYiR,OAASjR,EAAYutC,4BAEnC,MAAO,CAAE7Q,QAAO70B,UAIlB,GAAI7H,EAAYutC,4BAA6B,CAE3C,MAAMoB,EACJ3uC,EAAYutC,4BAA4BzrC,QACrC8rC,GACCb,EAA4BvxB,SAASoyB,EAAOK,iBAC5ChB,EAAwBzxB,SACtB,GAAGoyB,EAAOM,2BAA2BN,EAAOO,6BAIpD,IAAKQ,GAA0BvwC,OAC7B,MAAO,CAAEs+B,QAAO70B,UAGlB,MAAM+lC,EAASe,EAAyBnyB,MACrCoxB,GACCriB,EAAW,IAAMqiB,EAAOC,qBACxBtiB,EAAW,IAAMqiB,EAAOE,qBACxBviB,EAAW,IAAMqiB,EAAOG,qBACxBxiB,EAAW,IAAMqiB,EAAOI,sBAG5B,IAAKJ,EACH,MAAO,CAAElR,QAAO70B,UAKlB,MAAM,iBAAE+mC,EAAmB,EAAC,iBAAEC,EAAmB,GAAMjB,GACjD,eAAEQ,EAAc,eAAEC,GAAmBT,EAErCkB,GACHvjB,EAAW,GAAKqiB,EAAOG,oBAAsBc,GAC9CR,EAMFf,EAAkB,YAClBzlC,EAAS,EAJN0jB,EAAW,GAAKqiB,EAAOC,oBAAsBe,GAC9CR,EAGgBU,GAClBpS,EAAQ,CACNwQ,EAAaU,EAAOM,yBACpBhB,EAAaU,EAAOO,yBAExB,CAEA,MAAO,CACLzR,QACA70B,SACAylC,kBACD,EASGyB,EAAuBr1C,GAAUA,EAAMsG,aAAagvC,QAAU,yECrNpE,MAAM,sBAAE/iB,GAA0B,YAiBlC,SAASgjB,EACPC,EACA5vC,EACAvH,GAQA,MAAO40C,EAAQjR,GAAOwT,EAGhBC,EAAc,iBACjBxC,EAAO,GAAKjR,EAAI,IAAM,GACtBiR,EAAO,GAAKjR,EAAI,IAAM,GACtBiR,EAAO,GAAKjR,EAAI,IAAM,GAInB0T,EAAc,cAAczC,EAAQjR,GAAO,EAEjD,IAAK3jC,EACH,MAAM,IAAIkE,MACR,gEAIJ,MAAM,UAAEunC,EAAS,aAAE6L,EAAY,iBAAEC,GAkBnC,SACEhwC,EACAvH,EACAm3C,EACAC,EACAC,GAEA,MAAOzC,EAAQjR,GAAOwT,EAEhBh0C,EAAaoE,EAAUE,gBAEvBwC,EAASjK,EAASuL,YAKlBG,EAAS,gBACbzB,EAAOyB,OAAO,GACdzB,EAAOyB,OAAO,GACdzB,EAAOyB,OAAO,IAEVC,EAAkB,gBACtB1B,EAAO0B,gBAAgB,GACvB1B,EAAO0B,gBAAgB,GACvB1B,EAAO0B,gBAAgB,IAEnB6rC,EAAY,cAElB,WAAWA,EAAW9rC,EAAQC,GAQ9B,MAAM2rC,EAAe,cACfC,EAAmB,cAEzB,iBAAiBD,EAAc3T,EAAKh4B,EAAiB0rC,GACrD,iBAAiBE,EAAkB3C,EAAQjpC,GAAkB0rC,GAG7D,iBAAiBC,EAAcA,EAAcE,GAAYH,GACzD,iBAAiBE,EAAkBA,EAAkBC,EAAWH,GAMhE,MAAMI,EAAavjB,EACjB3sB,EACA+vC,GAEII,EAAiBxjB,EACrB3sB,EACAgwC,GAGII,EAAYR,EAAar4C,KAAK+8B,GAClC3H,EAAsB3sB,EAAWs0B,KAI7B4P,GAAY,IAAAiC,8BAChB,CAAC+J,EAAYC,KAAmBC,GAChCx0C,GAGF,MAAO,CAAEsoC,YAAW6L,eAAcC,mBACpC,CAvFIK,CACErwC,EACAvH,EACAm3C,EACAC,EACAC,GAGJ,MAAO,CACL5L,YACA2L,YAAaA,EACbC,cACAC,aAAcA,EACdC,iBAAkBA,EAEtB,mDCzDe,SAASM,EACtBzd,GAEA,MAAM0d,GAAY,OAA0B1d,GAE5C,OAAO0d,EAAUzxC,OAASyxC,EAAU,QAAKtxC,CAC3C,6sBCmCA,MAAMw/B,EAAc,EAAA8H,UAAA,8CC1BpB,QANA,SAAkBjyB,GAChB,MAAM3C,SAAc2C,EAEpB,OAAiB,OAAVA,IAA4B,WAAT3C,GAA8B,aAATA,EACjD,kBClBe,SAAS6+B,EACtBC,EACAC,GAEA,OACED,EAAME,MAAQD,EAAME,MACpBH,EAAMG,MAAQF,EAAMC,MACpBF,EAAMI,MAAQH,EAAMI,MACpBL,EAAMK,MAAQJ,EAAMG,IAExB,CCNe,SAASE,EACtBC,EACA3wC,GAEA,MAAM4wC,EAAYD,EAAKJ,KAAOI,EAAKL,KAC7BO,EAAaF,EAAKF,KAAOE,EAAKH,KAC9BM,EAAW,CAACF,EAAWC,GACvBE,EAA2B,CAC/BJ,EAAKL,KAAOM,EAAY,EACxBD,EAAKH,KAAOK,EAAa,GAKrBG,EAAkB,CACtBz7C,KAAK6uC,IAAIpkC,EAAM,GAAK+wC,EAAW,IAC/Bx7C,KAAK6uC,IAAIpkC,EAAM,GAAK+wC,EAAW,KAI3Brb,EAAKsb,EAAgB,GAAmB,GAAdF,EAAS,GACnCnb,EAAKqb,EAAgB,GAAmB,GAAdF,EAAS,GAMzC,GAAIpb,EAAK,GAAKC,EAAK,EACjB,OAAOD,EAAKA,EAAKC,EAAKA,EAGxB,MAAM0N,EAAO9tC,KAAKsM,IAAI6zB,EAAI,GAAKngC,KAAKsM,IAAI8zB,EAAI,GAE5C,OAAO0N,EAAOA,CAChB,CChCe,SAASrQ,EACtB2d,EACA3wC,GAEA,OAAOzK,KAAKiZ,KAAKkiC,EAAuBC,EAAM3wC,GAChD,4JCTA,QARA,SCEM,cAAEixC,GAAkB,EAAA/K,UAEX,MAAMgL,UAA6B,SACjC,KAAArvC,IAAM,EAAE0jC,IAAU,QAClB,KAAAr5B,IAAM,CAACq5B,IAAU,QACjB,KAAA4L,IAAM,CAAC,EAAG,QACV,KAAAC,MAAQ,CAAE,QAIV,KAAAC,QAAU,CAAC,EAAG,QACd,KAAAC,GAAK,CAAC,EAAG,QAGT,KAAAxN,cAAgBmN,EAAcM,QAAQ,KAAM,CAEpD,gBAAOC,CAAU51C,GAClBA,EAAQ61C,qBACVP,EAAqBpN,cAAgB,KAEzC,QAMO,KAAA4N,cAAgB,EAAGz9B,MAAO09B,EAAUC,WAAW,SAElD31C,MAAMC,QAAQy1C,IACdA,EAASlzC,OAAS,GACE,IAApB9J,KAAKkN,IAAIpD,SAET9J,KAAKkN,IAAI0D,KAAK5Q,KAAKkN,IAAI,GAAIlN,KAAKkN,IAAI,IACpClN,KAAKuX,IAAI3G,KAAK5Q,KAAKuX,IAAI,GAAIvX,KAAKuX,IAAI,IACpCvX,KAAKw8C,IAAI5rC,KAAK5Q,KAAKw8C,IAAI,GAAIx8C,KAAKw8C,IAAI,IACpCx8C,KAAK08C,QAAQ9rC,KAAK,EAAG,GAErB5Q,KAAK28C,GAAG/rC,KAAK5Q,KAAK28C,GAAG,GAAI38C,KAAK28C,GAAG,KAGnC38C,KAAKmvC,eAAev+B,KAAKqsC,GACzB,MAAMC,EAAW51C,MAAMC,QAAQy1C,GAAYA,EAAW,CAACA,GAEvDh9C,KAAKy8C,OAAS,EACdz8C,KAAKkN,IAAI3K,KAAI,CAACC,EAAI26C,KAChB,MAAM79B,EAAQ49B,EAASC,GAEjB9zC,EAAQiW,EAAQtf,KAAK08C,QAAQS,GACnCn9C,KAAKw8C,IAAIW,IAAQ79B,EACjBtf,KAAK08C,QAAQS,IAAQ9zC,EAAQrJ,KAAKy8C,MAClC,MAAMW,EAAS99B,EAAQtf,KAAK08C,QAAQS,GACpCn9C,KAAK28C,GAAGQ,IAAQ9zC,EAAQ+zC,EAGxBp9C,KAAKuX,IAAI4lC,GAAOv8C,KAAK2W,IAAIvX,KAAKuX,IAAI4lC,GAAM79B,GACxCtf,KAAKkN,IAAIiwC,GAAOv8C,KAAKsM,IAAI1K,EAAI8c,EAAM,GACnC,CACF,QAWK,KAAA+9B,cAAiBp2C,IACtB,MAAMq2C,EAAOt9C,KAAKw8C,IAAIj6C,KAAKi6C,GAAQA,EAAMx8C,KAAKy8C,QACxCc,EAASv9C,KAAK28C,GAAGp6C,KAAKi7C,GAC1B58C,KAAKiZ,KAAK2jC,EAAiBx9C,KAAKy8C,SAM5BnyC,EAAOrD,GAASqD,MAAQ,KAExBmzC,EAAyB,CAC7BvwC,IAAK,CACH+G,KAAM,MACNm1B,MAAO,YACP9pB,MAAOo+B,EAAoB19C,KAAKkN,KAChC5C,QAEFiN,IAAK,CACHtD,KAAM,MACNm1B,MAAO,YACP9pB,MAAOo+B,EAAoB19C,KAAKuX,KAChCjN,QAEFgzC,KAAM,CACJrpC,KAAM,OACNm1B,MAAO,aACP9pB,MAAOo+B,EAAoBJ,GAC3BhzC,QAEFizC,OAAQ,CACNtpC,KAAM,SACNm1B,MAAO,qBACP9pB,MAAOo+B,EAAoBH,GAC3BjzC,QAOFmyC,MAAO,CACLxoC,KAAM,QACNm1B,MAAO,cACP9pB,MAAOtf,KAAKy8C,MACZnyC,KAAM,MAER6kC,cAAenvC,KAAKmvC,cACpBn9B,MAAO,IAqBT,OAnBAyrC,EAAMzrC,MAAMpB,KACV6sC,EAAMvwC,IACNuwC,EAAMH,KACNG,EAAMF,OAGNE,EAAMF,OACNE,EAAMhB,OAGRz8C,KAAKkN,IAAM,EAAE0jC,KACb5wC,KAAKuX,IAAM,CAACq5B,KACZ5wC,KAAKw8C,IAAM,CAAC,GAEZx8C,KAAK28C,GAAK,CAAC,GACX38C,KAAK08C,QAAU,CAAC,GAChB18C,KAAKy8C,MAAQ,EACbz8C,KAAKmvC,cAAgBmN,EAAcM,QAAQ,MAEpCa,CAAK,CACZ,EAGJ,SAASC,EAAoBhM,GAC3B,OAAsB,IAAfA,EAAI5nC,OAAe4nC,EAAI,GAAKA,CACrC,mBCxHe,SAASiM,EACtBC,EACAX,EACAY,EAAmB,CAAC,GAKpB,OAHKA,EAAQC,eACXC,EAA2BH,EAASC,GAE/BA,EAAQC,cAAcb,EAC/B,8FAcA,MAAMc,EAA6B,CAACH,EAASC,EAAmB,CAAC,KAC/D,MAAM,QAAEG,EAAO,QAAEC,EAAO,QAAEC,GAAYN,OAKX3zC,IAAzB4zC,EAAQM,mBACiBl0C,IAAzB4zC,EAAQO,mBACiBn0C,IAAzB4zC,EAAQQ,eAERR,EAAQM,aAA2B,IAAZH,EAAgB,EAAIA,GAAW,EAAI,EAC1DH,EAAQO,aAA2B,IAAZH,EAAgB,EAAIA,GAAW,EAAI,EAC1DJ,EAAQQ,aAA2B,IAAZH,EAAgB,EAAIA,GAAW,EAAI,GAG5D,MAAM,aAAEC,EAAY,aAAEC,EAAY,aAAEC,GAAiBR,GAC/C,OAAES,GAAWV,GACZW,EAASC,EAASC,GAAWH,EAuBpC,OArBAT,EAAQC,cAAiBb,IAEvB,MAAMlc,EAAKkc,EAAS,GAAKsB,EACzB,IAAIG,EAAS3d,EAAKA,EAAKod,EACvB,GAAIO,EAAS,EACX,OAAO,EAGT,MAAM1d,EAAKic,EAAS,GAAKuB,EAEzB,GADAE,GAAU1d,EAAKA,EAAKod,EAChBM,EAAS,EACX,OAAO,EAGT,MAAMlV,EAAKyT,EAAS,GAAKwB,EAIzB,OAHAC,GAAUlV,EAAKA,EAAK6U,EAGbK,GAAU,CAAC,EAGbb,CAAO,EC1ED,SAASc,EACtBC,GAEA,MAAOvG,EAAQjR,EAAKl1B,EAAMC,GAASysC,EAKnC,MAAO,CAHuB,CAAC1sC,EAAK,GAAIk1B,EAAI,IACV,CAACj1B,EAAM,GAAIkmC,EAAO,IAGtD,4VCVe,SAASwG,EACtBC,EACAC,EACA1zC,GAKA,IAAI2zC,EACJ,MAAMC,EAAkBC,EAAK7zC,MAAM0wC,uBAAuB+C,EAAWC,GAQrE,GAJID,EAAU,KAAOC,EAAQ,IAAMD,EAAU,KAAOC,EAAQ,KAC1DC,EAAeF,IAGZE,EAAc,CACjB,MAAMG,IACF9zC,EAAM,GAAKyzC,EAAU,KAAOC,EAAQ,GAAKD,EAAU,KAClDzzC,EAAM,GAAKyzC,EAAU,KAAOC,EAAQ,GAAKD,EAAU,KACtDG,EAGAD,EADEG,EAAa,EACAL,EACNK,EAAa,EACPJ,EAEA,CACbD,EAAU,GAAKK,GAAcJ,EAAQ,GAAKD,EAAU,IACpDA,EAAU,GAAKK,GAAcJ,EAAQ,GAAKD,EAAU,IAG1D,CAEA,MAAO,CACLzzC,MAAO,IAAI2zC,GACXC,gBAAiBC,EAAK7zC,MAAM0wC,uBAAuB1wC,EAAO2zC,GAE9D,CC3Ce,SAASjD,EACtB+C,EACAC,EACA1zC,GAEA,OAAOwzC,EAA2BC,EAAWC,EAAS1zC,GAAO4zC,eAC/D,CCNe,SAAS5gB,EACtBygB,EACAC,EACA1zC,GAEA,GAAyB,IAArByzC,EAAUh1C,QAAmC,IAAnBi1C,EAAQj1C,QAAiC,IAAjBuB,EAAMvB,OAC1D,MAAMnC,MACJ,kEAIJ,OAAO/G,KAAKiZ,KAAKkiC,EAAuB+C,EAAWC,EAAS1zC,GAC9D,CCpBA,SAAS+zC,EAAK3sC,GACZ,MAAoB,iBAANA,EACVA,EACEA,EAAI,GACD,EACD,EACFA,GAAMA,EACN,EACA4sC,IACFA,GACN,CAYe,SAASC,EACtBC,EACAC,EACAC,EACAC,GAEA,MAAOC,EAAIhtC,GAAM4sC,GACVK,EAAIC,GAAML,GACVM,EAAIC,GAAMN,GACVO,EAAIC,GAAMP,EAGXQ,EAAKL,EAAKltC,EACVwtC,EAAKR,EAAKC,EACVQ,EAAKR,EAAKjtC,EAAKgtC,EAAKE,EAGpBQ,EAAKH,EAAKJ,EAAKK,EAAKJ,EAAKK,EACzBE,EAAKJ,EAAKF,EAAKG,EAAKF,EAAKG,EAM/B,GAAW,IAAPC,GAAmB,IAAPC,GAAYlB,EAAKiB,KAAQjB,EAAKkB,GAC5C,OAIF,MAAMC,EAAKN,EAAKF,EACVS,EAAKV,EAAKE,EACVS,EAAKT,EAAKD,EAAKD,EAAKG,EAGpBS,EAAKH,EAAKZ,EAAKa,EAAK7tC,EAAK8tC,EACzBE,EAAKJ,EAAKX,EAAKY,EAAKX,EAAKY,EAO/B,GAAW,IAAPC,GAAmB,IAAPC,GAAYvB,EAAKsB,KAAQtB,EAAKuB,GAC5C,OAMF,MAAMC,EAAQV,EAAKM,EAAKD,EAAKJ,EAC7B,IAAIU,EAOJA,EAAMV,EAAKM,EAAKD,EAAKJ,EACrB,MAAM3tC,EAAIouC,EAAMD,EAEhBC,EAAMN,EAAKH,EAAKF,EAAKO,EAKrB,MAF0B,CAAChuC,EAFjBouC,EAAMD,EAKlB,CCzFA,MAAME,EAAwB,IASf,SAASC,EACtBjC,EACAC,EACA1zC,GAKA,MAAMswC,EAAOmD,EAAU,IAAMC,EAAQ,GAAKD,EAAU,GAAKC,EAAQ,GAC3DnD,EAAOkD,EAAU,IAAMC,EAAQ,GAAKD,EAAU,GAAKC,EAAQ,GAC3DlD,EAAOiD,EAAU,IAAMC,EAAQ,GAAKD,EAAU,GAAKC,EAAQ,GAC3DjD,EAAOgD,EAAU,IAAMC,EAAQ,GAAKD,EAAU,GAAKC,EAAQ,GASjE,KALE1zC,EAAM,IAAMswC,EAAOmF,GACnBz1C,EAAM,IAAMuwC,EAAOkF,GACnBz1C,EAAM,IAAMwwC,EAAOiF,GACnBz1C,EAAM,IAAMywC,EAAOgF,GAGnB,OAAO,EAIT,MAAME,GACHjC,EAAQ,GAAKD,EAAU,KAAOzzC,EAAM,GAAK0zC,EAAQ,KACjDA,EAAQ,GAAKD,EAAU,KAAOzzC,EAAM,GAAK0zC,EAAQ,IAIpD,OAHuBiC,GAAe,EAAIA,GAAeA,IAGhCF,CAC3B,mDC/Be,SAASziB,EAAgB4iB,EAAWC,GACjD,OAAOtgD,KAAKiZ,MAAK,OAAuBonC,EAAIC,GAC9C,mBCHe,SAASnF,EAAuBkF,EAAWC,GACxD,GAAID,EAAGn3C,SAAWo3C,EAAGp3C,OACnB,MAAMnC,MAAM,mDAGd,MAAOg4C,EAAIhtC,EAAIwuC,EAAK,GAAKF,GAClBrB,EAAIC,EAAIuB,EAAK,GAAKF,EACnBngB,EAAK6e,EAAKD,EACV3e,EAAK6e,EAAKltC,EACV62B,EAAK4X,EAAKD,EAIhB,OAAOpgB,EAAKA,EAAKC,EAAKA,EAAKwI,EAAKA,CAClC,mCChBe,SAAS6X,EACtBC,EACAC,GAEA,MAAO5B,EAAIhtC,GAAM2uC,GACV1B,EAAIC,GAAM0B,EAKjB,MAAO,CAHM,EAAI3B,EAAKD,EACT,EAAIE,EAAKltC,EAGxB,8qBCVe,SAAS6uC,EAAS/O,GAC/B,GAAIA,EAAS3oC,OAAS,EACpB,OAAO,EAGT,MAAM23C,EAAoBhP,EAAS3oC,OAE7BgpC,EAAaL,EAAS,GACtBM,EAAYN,EAASgP,EAAoB,GACzCC,EAAwBxC,EAAK7zC,MAAM0wC,uBACvCjJ,EACAC,GAGF,OAAO,YAAgB,EAAG2O,EAC5B,CCTe,SAASC,EACtBlP,EACApnC,EACApE,EAGI,CACFyrC,YAAQzoC,IAGV,GAAIwoC,EAAS3oC,OAAS,EACpB,OAAO,EAGT,MAAM23C,EAAoBhP,EAAS3oC,OACnC,IAAI83C,EAAmB,EAEvB,MAAM,OAAElP,EAAM,MAAEmP,GAAU56C,EAE1B,GAAI46C,GAAO/3C,OACT,IAAK,MAAMg4C,KAAQD,EACjB,GAAIF,EAAcG,EAAMz2C,GACtB,OAAO,EAMb,MAAM02C,SAA2B93C,IAAXyoC,EAAuB8O,EAAS/O,GAAYC,GAC5DsP,EAAkBvP,EAAS3oC,QAAUi4C,EAAc,EAAI,GAE7D,IAAK,IAAI/4C,EAAI,EAAGA,GAAKg5C,EAAiBh5C,IAAK,CACzC,MAAMi4C,EAAKxO,EAASzpC,GAKdk4C,EAAKzO,EADKzpC,IAAMy4C,EAAoB,EAAI,EAAIz4C,EAAI,GAIhD4yC,EAAOqF,EAAG,IAAMC,EAAG,GAAKD,EAAG,GAAKC,EAAG,GACnCpF,EAAOmF,EAAG,IAAMC,EAAG,GAAKD,EAAG,GAAKC,EAAG,GACnCrF,EAAOoF,EAAG,IAAMC,EAAG,GAAKD,EAAG,GAAKC,EAAG,GAKzC,GAFE71C,EAAM,IAAMuwC,GAAQvwC,EAAM,IAAMwwC,GAAQxwC,EAAM,GAAKywC,EAExB,CAE3B,IAAImG,EADmBhB,EAAG,KAAOC,EAAG,GAGpC,IAAKe,EAAY,CACf,MAAMC,GACF72C,EAAM,GAAK41C,EAAG,KAAOC,EAAG,GAAKD,EAAG,KAAQC,EAAG,GAAKD,EAAG,IAAMA,EAAG,GAEhEgB,EAAa52C,EAAM,IAAM62C,CAC3B,CAEAN,GAAoBK,EAAa,EAAI,CACvC,CACF,CAEA,SAAUL,EAAmB,EAC/B,CCrEe,SAASO,EACtB1P,EACAzU,GAEA,IAAK,IAAIh1B,EAAI,EAAGo5C,EAAWpkB,EAAOl0B,OAAQd,EAAIo5C,EAAUp5C,IACtD,IAAK24C,EAAclP,EAAUzU,EAAOh1B,IAClC,OAAO,EAIX,OAAO,CACT,gBCZe,SAASq5C,EAAQrkB,GAE9B,MAAMhrB,EAAIgrB,EAAOl0B,OACjB,IAAIw4C,EAAO,EACPC,EAAIvvC,EAAI,EAEZ,IAAK,IAAIhK,EAAI,EAAGA,EAAIgK,EAAGhK,IACrBs5C,IAAStkB,EAAOukB,GAAG,GAAKvkB,EAAOh1B,GAAG,KAAOg1B,EAAOukB,GAAG,GAAKvkB,EAAOh1B,GAAG,IAClEu5C,EAAIv5C,EAIN,OAAOpI,KAAK6uC,IAAI6S,EAAO,EACzB,CCRe,SAASE,EAAc/P,GACpC,GAAIA,EAAS3oC,OAAS,EACpB,OAAO,EAIT,MAAM24C,EAAWhQ,EAAS,GAC1B,IAAI6P,EAAO,EAUX,IAAK,IAAIt5C,EAAI,EAAGyK,EAAMg/B,EAAS3oC,OAAQd,EAAIyK,EAAKzK,IAAK,CACnD,MAAMi4C,EAAKxO,EAASzpC,GAGdk4C,EAAKzO,EADKzpC,IAAMyK,EAAM,EAAI,EAAIzK,EAAI,GAElC05C,EAAKzB,EAAG,GAAKwB,EAAS,GACtBE,EAAK1B,EAAG,GAAKwB,EAAS,GACtBG,EAAK1B,EAAG,GAAKuB,EAAS,GAK5BH,GAAQI,GAJGxB,EAAG,GAAKuB,EAAS,IAIVE,EAAKC,CACzB,CAKA,OAFAN,GAAQ,GAEDA,CACT,CC1Ce,SAASO,EAAoBpQ,GAI1C,OAHmB+P,EAAc/P,IAGZ,EAAI,GAAK,CAChC,CCmCe,SAASqQ,EAAWrQ,GACjC,MAAMsQ,EA9CR,SAAwBtQ,GACtB,MAAMsQ,EAAU,cAGVN,EAAWhQ,EAAS,GAU1B,IAAK,IAAIzpC,EAAI,EAAGyK,EAAMg/B,EAAS3oC,OAAQd,EAAIyK,EAAKzK,IAAK,CACnD,MAAMi4C,EAAKxO,EAASzpC,GAGdk4C,EAAKzO,EADKzpC,IAAMyK,EAAM,EAAI,EAAIzK,EAAI,GAGlC05C,EAAKzB,EAAG,GAAKwB,EAAS,GACtBE,EAAK1B,EAAG,GAAKwB,EAAS,GACtBO,EAAK/B,EAAG,GAAKwB,EAAS,GACtBG,EAAK1B,EAAG,GAAKuB,EAAS,GACtBQ,EAAK/B,EAAG,GAAKuB,EAAS,GACtBS,EAAKhC,EAAG,GAAKuB,EAAS,GAG5BM,EAAQ,IAAMJ,EAAKO,EAAKF,EAAKC,EAC7BF,EAAQ,IAAMC,EAAKJ,EAAKF,EAAKQ,EAC7BH,EAAQ,IAAML,EAAKO,EAAKN,EAAKC,CAC/B,CAMA,OAHA,WAAWG,EAASA,EAAS,IAGRA,CACvB,CAQkBI,CAAe1Q,GAE/B,OAAO,eAAesQ,EAASA,EACjC,CC1Ce,SAASK,EAAW3Q,GACjC,MAAM6P,EAAOE,EAAc/P,GAI3B,MAAO,CAAC,EAAG,EAAG6P,EAAO1hD,KAAK6uC,IAAI6S,GAChC,gBCMe,SAASe,EACtBpC,EACAqC,EACApC,EACAqC,GAEA,IAAIrN,GAAS,EAGb,MAAMsN,EAAYvC,EAAG,GAAKqC,EAAG,GAAKrC,EAAG,GAAKqC,EAAG,GACvCG,EAAYxC,EAAG,GAAKqC,EAAG,GAAKrC,EAAG,GAAKqC,EAAG,GACvCI,EAAYzC,EAAG,GAAKqC,EAAG,GAAKrC,EAAG,GAAKqC,EAAG,GACvCK,EAAY1C,EAAG,GAAKqC,EAAG,GAAKrC,EAAG,GAAKqC,EAAG,GAGvCM,EAAY1C,EAAG,GAAKqC,EAAG,GAAKrC,EAAG,GAAKqC,EAAG,GACvCM,EAAY3C,EAAG,GAAKqC,EAAG,GAAKrC,EAAG,GAAKqC,EAAG,GACvCO,EAAY5C,EAAG,GAAKqC,EAAG,GAAKrC,EAAG,GAAKqC,EAAG,GACvCQ,EAAY7C,EAAG,GAAKqC,EAAG,GAAKrC,EAAG,GAAKqC,EAAG,GAI7C,GACEC,EAAYM,GACZJ,EAAYE,GACZH,EAAYM,GACZJ,EAAYE,EAEZ,OAAO,EAGT,MAAMG,EAAS,CACbhD,EAAYC,EAAIqC,EAAIpC,GACpBF,EAAYC,EAAIqC,EAAIC,GACpBvC,EAAYE,EAAIqC,EAAItC,GACpBD,EAAYE,EAAIqC,EAAID,IAItB,OAAIU,EAAO,KAAOA,EAAO,IAAMA,EAAO,KAAOA,EAAO,MAKlC,IAAdA,EAAO,IAAYC,EAAUhD,EAAIC,EAAIoC,IAGhB,IAAdU,EAAO,IAAYC,EAAUhD,EAAIsC,EAAID,IAGvB,IAAdU,EAAO,IAAYC,EAAU/C,EAAID,EAAIsC,IAGvB,IAAdS,EAAO,IAAYC,EAAU/C,EAAIoC,EAAIC,MAP9CrN,GAAS,GAYJA,EACT,CAMA,SAAS8K,EACP1hB,EACA4kB,EACAC,GAGA,MAAMC,GACHF,EAAE,GAAK5kB,EAAE,KAAO6kB,EAAE,GAAKD,EAAE,KAAOA,EAAE,GAAK5kB,EAAE,KAAO6kB,EAAE,GAAKD,EAAE,IAE5D,OAAyB,IAArBE,EACK,EAGFA,EAAmB,EAAI,EAAI,CACpC,CAKA,SAASH,EAAU3kB,EAAiB4kB,EAAiBC,GACnD,OACED,EAAE,IAAMtjD,KAAKsM,IAAIoyB,EAAE,GAAI6kB,EAAE,KACzBD,EAAE,IAAMtjD,KAAK2W,IAAI+nB,EAAE,GAAI6kB,EAAE,KACzBD,EAAE,IAAMtjD,KAAKsM,IAAIoyB,EAAE,GAAI6kB,EAAE,KACzBD,EAAE,IAAMtjD,KAAK2W,IAAI+nB,EAAE,GAAI6kB,EAAE,GAM7B,CCzGe,SAASE,EACtB5R,EACAwO,EACAqC,EACA5Q,GAAS,GAET,MAAM4R,EAAgC,GAChCzP,EAAYpC,EAAS3oC,OACrBy6C,EAAO1P,GAAanC,EAAS,EAAI,GAEvC,IAAK,IAAI1pC,EAAI,EAAGA,GAAKu7C,EAAMv7C,IAAK,CAC9B,MAEMu5C,EAAIv5C,IAAM6rC,EAAY,EAAI,EAAI7rC,EAAI,EAGpCq6C,EAA4BpC,EAAIqC,EALzB7Q,EAASzpC,GAGTypC,EAAS8P,KAGlB+B,EAAc1zC,KAAK,CAAC5H,EAAGu5C,GAE3B,CAEA,OAAO+B,CACT,gBC3BA,MAAME,EAA2B,IAelB,SAASC,EACtBxD,EACAqC,EACApC,EACAqC,GAEA,MAAMmB,EAAW,CAACpB,EAAG,GAAKrC,EAAG,GAAIqC,EAAG,GAAKrC,EAAG,IACtC0D,EAAW,CAACpB,EAAG,GAAKrC,EAAG,GAAIqC,EAAG,GAAKrC,EAAG,IACtC0D,EAAcD,EAAS,GAAKD,EAAS,GAAKC,EAAS,GAAKD,EAAS,GAGvE,IAFuBE,GAAe,EAAIA,GAAeA,GAEpCJ,EAA0B,CAE7C,MAAMK,EAAY,CAChB5D,EAAG,GAAKqC,EAAG,GAAKrC,EAAG,GAAKqC,EAAG,GAC3BrC,EAAG,GAAKqC,EAAG,GAAKrC,EAAG,GAAKqC,EAAG,GAC3BrC,EAAG,GAAKqC,EAAG,GAAKrC,EAAG,GAAKqC,EAAG,GAC3BrC,EAAG,GAAKqC,EAAG,GAAKrC,EAAG,GAAKqC,EAAG,IAIvBwB,EAAY,CAChB5D,EAAG,GAAKqC,EAAG,GAAKrC,EAAG,GAAKqC,EAAG,GAC3BrC,EAAG,GAAKqC,EAAG,GAAKrC,EAAG,GAAKqC,EAAG,GAC3BrC,EAAG,GAAKqC,EAAG,GAAKrC,EAAG,GAAKqC,EAAG,GAC3BrC,EAAG,GAAKqC,EAAG,GAAKrC,EAAG,GAAKqC,EAAG,IAS7B,KALEsB,EAAU,IAAMC,EAAU,IAC1BD,EAAU,IAAMC,EAAU,IAC1BD,EAAU,IAAMC,EAAU,IAC1BD,EAAU,IAAMC,EAAU,IAG1B,OASF,KAJE,uBAA8B7D,EAAIqC,EAAIpC,IACtC,uBAA8BD,EAAIqC,EAAIC,IACtC,uBAA8BrC,EAAIqC,EAAItC,IAGtC,OAYF,MAAO,CAHsB,KAJhB4D,EAAU,GAAKC,EAAU,GAAKD,EAAU,GAAKC,EAAU,KACvDD,EAAU,GAAKC,EAAU,GAAKD,EAAU,GAAKC,EAAU,KAIvC,KAHhBD,EAAU,GAAKC,EAAU,GAAKD,EAAU,GAAKC,EAAU,KACvDD,EAAU,GAAKC,EAAU,GAAKD,EAAU,GAAKC,EAAU,KAKtE,CAEA,IAAIhyC,EAAImuC,EAAG,GAAKC,EAAG,GACfnuC,EAAIkuC,EAAG,GAAKC,EAAG,GACnB,MACM6D,EAAaL,EAAS,GAAK5xC,EAAI4xC,EAAS,GAAK3xC,EACnDD,GAFmB6xC,EAAS,GAAK7xC,EAAI6xC,EAAS,GAAK5xC,GAElC6xC,EACjB7xC,EAAIgyC,EAAaH,EAKjB,MAAO,CAHS3D,EAAG,GAAKnuC,EAAI4xC,EAAS,GACrBzD,EAAG,GAAKnuC,EAAI4xC,EAAS,GAGvC,CCrFA,IAAKM,EAMAC,EAQAC,EAwBL,SAASC,EAAoBC,GAE3B,IAAK,IAAIp8C,EAAI,EAAGyK,EAAM2xC,EAAet7C,OAAQd,EAAIyK,EAAKzK,IAAK,CACzD,MAAMq8C,EAAeD,EAAep8C,GAE/Bq8C,EAAa9gC,OAChB8gC,EAAa9gC,KAAO6gC,EAAep8C,IAAMyK,EAAM,EAAI,EAAIzK,EAAI,GAE/D,CACF,CAUA,SAASs8C,EACPC,EACAC,GAEA,MAAMC,EAAwC,GACxCC,EAAwC,GACxCC,EAA2B,IAAI/iC,IAOrC,IAAIgjC,EAFuBjE,EAAc6D,EAAgBD,EAAe,IAGpEL,EAAuBW,QACvBX,EAAuBY,SAG3B,IAAK,IAAI98C,EAAI,EAAGyK,EAAM8xC,EAAez7C,OAAQd,EAAIyK,EAAKzK,IAAK,CACzD,MAAMi4C,EAAKsE,EAAev8C,GACpB+8C,EAAcpE,EAAc6D,EAAgBvE,GAC5C+E,EAA6B,CACjCrpC,KAAMqoC,EAAkBiB,OACxBC,YAAajF,EACb/xC,SAAU62C,EACNd,EAAsBkB,OACtBlB,EAAsBmB,QAC1BC,SAAS,EACT9hC,KAAM,MAGRkhC,EAAqB70C,KAAKo1C,GAE1B,MAAM1C,EAAKiC,EAAev8C,IAAMyK,EAAM,EAAI,EAAIzK,EAAI,GAC5Cs9C,EAAoBjC,EACxBmB,EACAvE,EACAqC,GACA/gD,KAAKgkD,IACL,MAAMC,EAA8BD,EAAuB,GACrDrF,EAAKsE,EAAee,EAAuB,IAC3ChD,EAAKiC,EAAee,EAAuB,IAK3CE,EAAyBhC,EAC7BxD,EACAqC,EACApC,EACAqC,GAQF,MAAO,CACLiD,sBACAE,WAAYD,EACZE,4BARkC,yBAClC1F,EACAwF,GAOD,IAGHH,EAAkB5yC,MAChB,CAACxB,EAAMC,IACLD,EAAKy0C,4BAA8Bx0C,EAAMw0C,8BAG7CL,EAAkB/1C,SAASq2C,IACzB,MAAM,oBAAEJ,EAAqBE,WAAYD,GACvCG,EAGIC,EAA6C,CACjDlqC,KAAMqoC,EAAkB8B,aACxBZ,YAAaO,EACbv3C,SAAU+1C,EAAsB8B,KAChCpgD,UAAWi/C,EACXS,SAAS,EACT9hC,KAAM,MAOFyiC,EAA6C,IAC9CH,EACHlgD,UAAWu+C,EAAuB+B,QAClCC,QAAQ,GAGNtB,IAA+BV,EAAuBY,SACxDe,EAAgBtiC,KAAOyiC,EAEvBA,EAAgBziC,KAAOsiC,EAGzB,IAAIM,EACFxB,EAAyB55C,IAAIy6C,GAE1BW,IACHA,EAA2B,GAC3BxB,EAAyBpoC,IACvBipC,EACAW,IAIJ1B,EAAqB70C,KAAKi2C,GAC1BM,EAAyBv2C,KAAKo2C,GAG9BpB,IAA+B,CAAC,GAEpC,CAGA,IAAK,IAAI58C,EAAI,EAAGyK,EAAM+xC,EAAe17C,OAAQd,EAAIyK,EAAKzK,IAAK,CACzD,MAAMo+C,EAAwBp+C,EACxBi4C,EAAKuE,EAAex8C,GACpBg9C,EAA6B,CACjCrpC,KAAMqoC,EAAkBiB,OACxBC,YAAajF,EACboF,SAAS,EACT9hC,KAAM,MAGRmhC,EAAqB90C,KAAKo1C,GAE1B,MAAMmB,EACJxB,EAAyB55C,IAAIq7C,GAE1BD,GAA0Br9C,QAO/Bq9C,EACG5kD,KAAK8kD,IAAsB,CAC1BA,oBACAC,wBAAyB,yBACvBrG,EACAoG,EAAkBnB,iBAGrBxyC,MACC,CAACxB,EAAMC,IACLD,EAAKo1C,wBAA0Bn1C,EAAMm1C,0BAExC/kD,KAAI,EAAG8kD,uBAAwBA,IAC/B92C,SAAS82C,GACR3B,EAAqB90C,KAAKy2C,IAEhC,CAKA,OAHAlC,EAAoBM,GACpBN,EAAoBO,GAEb,CAAED,uBAAsBC,uBACjC,CAQA,SAAS6B,EAAyBnC,GAChC,IAAK,IAAIp8C,EAAI,EAAGyK,EAAM2xC,EAAet7C,OAAQd,EAAIyK,EAAKzK,IAAK,CACzD,MAAMqC,EAAQ+5C,EAAep8C,GAE7B,IAAKqC,EAAMg7C,SAAWh7C,EAAM6D,WAAa+1C,EAAsBmB,QAC7D,OAAO/6C,CAEX,CACF,CAKA,SAASm8C,EACPjC,EACAC,GAEA,MAAMiC,EAAerE,EAAWmC,GAC1BmC,EAAetE,EAAWoC,GAC1BmC,EAAa,SAASD,EAAcD,GAIrC,YAAgB,EAAGE,KACtBnC,EAAiBA,EAAe5lC,QAAQ+1B,WAG1C,MAAM,qBAAE8P,GAAyBH,EAC/BC,EACAC,GAEIoC,EACJL,EAAyB9B,GAG3B,IAAKmC,EACH,OAAOrC,EAAe3lC,QAGxB,MAAMioC,EAAiB,CAACD,EAAW1B,aACnC,IAAIb,EAAeuC,EAAWrjC,KAE9B,KAAO8gC,IAAiBuC,GAEpBvC,EAAa1oC,OAASqoC,EAAkB8B,cACZzB,EAAc6B,QAM5CW,EAAej3C,KAAKy0C,EAAaa,aAJ/Bb,EAAeA,EAAa9gC,KAQhC,OAAOsjC,CACT,CAKA,SAASC,EACPvC,EACAC,GAEA,MAAMiC,EAAerE,EAAWmC,GAC1BmC,EAAetE,EAAWoC,GAC1BmC,EAAa,SAASD,EAAcD,GAKrC,aAAiB,EAAGE,KACvBnC,EAAiBA,EAAe5lC,QAAQ+1B,WAG1C,MAAM,qBAAE8P,GAAyBH,EAC/BC,EACAC,GAEF,IAAIoC,EAA4B,KAChC,MAAMG,EAAsB,GAE5B,KAAQH,EAAaL,EAAyB9B,IAAwB,CACpE,MAAMuC,EAAqB,CAACJ,EAAW1B,aACvC,IAAIb,EAAeuC,EAAWrjC,KAI9B,IAFAqjC,EAAWvB,SAAU,EAEdhB,IAAiBuC,GACtBvC,EAAagB,SAAU,EAGrBhB,EAAa1oC,OAASqoC,EAAkB8B,cACZzB,EAAc6B,QAM5Cc,EAAmBp3C,KAAKy0C,EAAaa,aAJnCb,EAAeA,EAAa9gC,KAQhCwjC,EAAoBn3C,KAAKo3C,EAC3B,CAEA,OAAOD,CACT,CC3Ue,SAASE,EACtBjqB,EACAijB,EACAqC,EACA5Q,GAAS,GAET,IAAIwV,EACA3F,EAEA7P,GACF6P,EAAIvkB,EAAOl0B,OAAS,EACpBo+C,EAAW,IAEX3F,EAAI,EACJ2F,EAAW,GAGb,IAAK,IAAIl/C,EAAIk/C,EAAUl/C,EAAIg1B,EAAOl0B,OAAQd,IAAK,CAI7C,GAAIq6C,EAA4BpC,EAAIqC,EAHzBtlB,EAAOukB,GACPvkB,EAAOh1B,IAGhB,MAAO,CAACu5C,EAAGv5C,GAGbu5C,EAAIv5C,CACN,CACF,CChCe,SAASm/C,EACtB3C,EACAD,GAKA,IAAK,IAAIv8C,EAAI,EAAGo/C,EAAY5C,EAAe17C,OAAQd,EAAIo/C,EAAWp/C,IAAK,CACrE,MAIMq/C,EAA2BJ,EAC/B1C,EALeC,EAAex8C,GAEfw8C,EADKx8C,IAAMo/C,EAAY,EAAI,EAAIp/C,EAAI,IASpD,GAAyC,IAArCq/C,GAA0Bv+C,OAC5B,OAAO,CAEX,CAEA,OAAO,CACT,EFzBA,SAAKk7C,GACH,uBACA,kCACD,CAHD,CAAKA,IAAAA,EAAiB,KAMtB,SAAKC,GACH,0BACA,mBACA,sBACD,CAJD,CAAKA,IAAAA,EAAqB,KAQ1B,SAAKC,GACH,0BACA,yBACA,0BACD,CAJD,CAAKA,IAAAA,EAAsB,KGnB3B,MAAMoD,EAAkB,GAkBT,SAASnT,EACtB1C,EACA2C,EAAUkT,GAEV,MAAMzT,EAAYpC,EAAS3oC,OAG3B,GAAI+qC,EAAY,EACd,OAAOpC,EAGT,MAAM8V,EAAiBnT,EAAUA,EAC3BoT,EAAiB,CAAC,CAAC,EAAG3T,EAAY,IAKlC4T,EAAqB,IAAInhD,MAAMutC,GAAW5b,MAAK,GAGrD,IAAIyvB,EAAqB,EAQzB,IALAD,EAAmB,IAAK,EACxBA,EAAmB5T,EAAY,IAAK,EAI7B2T,EAAe1+C,QAAQ,CAC5B,MAAOojC,EAAYE,GAAYob,EAAex6B,MAG9C,GAAIof,EAAWF,GAAe,EAC5B,SAGF,MAAM0a,EAAanV,EAASvF,GACtByb,EAAWlW,EAASrF,GAC1B,IAAIwb,GAAkBhY,IAClBiY,GAAgB,EAGpB,IAAK,IAAI7/C,EAAIkkC,EAAa,EAAGlkC,EAAIokC,EAAUpkC,IAAK,CAC9C,MAAMq8C,EAAe5S,EAASzpC,GACxB8/C,EAAc,yBAClBlB,EACAe,EACAtD,GAGEyD,EAAcF,IAChBA,EAAiBE,EACjBD,EAAe7/C,EAEnB,CAII4/C,EAAiBL,IAMrBE,EAAmBI,IAAgB,EACnCH,IAIAF,EAAe53C,KAAK,CAACi4C,EAAczb,IACnCob,EAAe53C,KAAK,CAACs8B,EAAY2b,IACnC,CAGA,MAAME,EAAoC,IAAIzhD,MAAMohD,GAEpD,IAAK,IAAIM,EAAW,EAAGC,EAAW,EAAGD,EAAWnU,EAAWmU,IACrDP,EAAmBO,KACrBD,EAAkBE,KAAcxW,EAASuW,IAI7C,OAAOD,CACT,CCjGe,SAASG,EACtBlrB,EACAijB,EACAqC,EACA5Q,GAAS,GAET,MAAMwD,EAAS,GACTiT,EAAkB9E,EACtBrmB,EACAijB,EACAqC,EACA5Q,GAGF,IAAK,IAAI1pC,EAAI,EAAGA,EAAImgD,EAAgBr/C,OAAQd,IAAK,CAC/C,MAEMogD,EAAe3E,EAAqBxD,EAAIqC,EAFnCtlB,EAAOmrB,EAAgBngD,GAAG,IAC1Bg1B,EAAOmrB,EAAgBngD,GAAG,KAErCktC,EAAOtlC,KAAKw4C,EACd,CAEA,OAAOlT,CACT,CChBe,SAASmT,EACtBrrB,EACAijB,EACAqC,EACA5Q,GAAS,GAET,IAAI4W,EACAC,EAEA7W,GACF6W,EAAUvrB,EAAOl0B,OAAS,EAC1Bw/C,EAAiB,IAEjBC,EAAU,EACVD,EAAiB,GAGnB,MAAMhF,EAAgB,GAEtB,IAAK,IAAIkF,EAAUF,EAAgBE,EAAUxrB,EAAOl0B,OAAQ0/C,IAAW,CACrE,MAAMtI,EAAKljB,EAAOurB,GACZhG,EAAKvlB,EAAOwrB,GAEdnG,EAA4BpC,EAAIqC,EAAIpC,EAAIqC,IAC1Ce,EAAc1zC,KAAK,CAAC24C,EAASC,IAG/BD,EAAUC,CACZ,CAEA,GAA6B,IAAzBlF,EAAcx6C,OAChB,OAIF,MAAM2/C,EAAY,GAElBnF,EAAc/zC,SAAS64C,IACrB,MAAMM,EAAqB,CACzB1rB,EAAOorB,EAAa,IACpBprB,EAAOorB,EAAa,KAGhBO,EAAW,EACdD,EAAmB,GAAG,GAAKA,EAAmB,GAAG,IAAM,GACvDA,EAAmB,GAAG,GAAKA,EAAmB,GAAG,IAAM,GAG1DD,EAAU74C,KAAK,cAAoB+4C,EAAU1I,GAAI,IAGnD,MAAM2I,EAAchpD,KAAK2W,OAAOkyC,GAGhC,MAAO,CACLI,QAASvF,EAHgBmF,EAAUj9C,QAAQo9C,IAI3Cpb,SAAUob,EAEd,gBCnEA,MAAMrZ,EAAU,KA8FhB,EAhF0C,CACxC9sC,EACAqmD,KAEA,IAAIjjD,EACAkjD,EACAC,EAEJ,GAAIvmD,aAAoB,EAAAipC,cAAe,CAErC,MAAM1hC,EAAYvH,EAASoH,eAE3Bk/C,EAAO/+C,EAAUrE,UAAUiZ,MAAM,EAAG,GACpCoqC,EAAOh/C,EAAUrE,UAAUiZ,MAAM,EAAG,GAEpC/Y,EAAUmE,EAAUnE,OACtB,KAAO,CAEL,MAAMmE,EAAYvH,EAASoH,gBACrB,UAAElE,EAAWE,QAASojD,GAAkBj/C,GACxC,gBAAEoE,EAAe,OAAED,GAAW1L,EAASuL,YAGvCk7C,EAAUvjD,EAAUiZ,MAAM,EAAG,GAC7BuqC,EAAUxjD,EAAUiZ,MAAM,EAAG,GAC7BwqC,EAAUzjD,EAAUiZ,MAAM,EAAG,GAE7Bq7B,EAAY,cAElB,WAAWA,EAAiB9rC,EAAcC,GAE1C,MAAMi7C,EAAmBzpD,KAAK6uC,IAAI,SAASwL,EAAWiP,IAChDI,EAAmB1pD,KAAK6uC,IAAI,SAASwL,EAAWkP,IAChDI,EAAmB3pD,KAAK6uC,IAAI,SAASwL,EAAWmP,IAGtD,IAAIlkD,EACJ,GAAItF,KAAK6uC,IAAI,EAAI4a,GAAoB9Z,EACnCrqC,EAAW+jD,EAAc,GACzBF,EAAOG,OACF,GAAItpD,KAAK6uC,IAAI,EAAI6a,GAAoB/Z,EAC1CrqC,EAAW+jD,EAAc,GACzBF,EAAOI,MACF,MAAIvpD,KAAK6uC,IAAI,EAAI8a,GAAoBha,GAI1C,MAAM,IAAI5oC,MAAM,oDAHhBzB,EAAW+jD,EAAc,GACzBF,EAAOK,CAGT,CAEA,MAAMI,EAAgB5pD,KAAK6uC,IAAI,SAAStgC,EAAQ+6C,IAC1CO,EAAgB7pD,KAAK6uC,IAAI,SAAStgC,EAAQg7C,IAC1CO,EAAgB9pD,KAAK6uC,IAAI,SAAStgC,EAAQi7C,IAGhD,IAAIhkD,EACJ,GAAIxF,KAAK6uC,IAAI,EAAI+a,GAAiBja,EAChCnqC,EAAW6jD,EAAc,GACzBD,EAAOE,OACF,GAAItpD,KAAK6uC,IAAI,EAAIgb,GAAiBla,EACvCnqC,EAAW6jD,EAAc,GACzBD,EAAOG,MACF,MAAIvpD,KAAK6uC,IAAI,EAAIib,GAAiBna,GAIvC,MAAM,IAAI5oC,MAAM,oDAHhBvB,EAAW6jD,EAAc,GACzBD,EAAOI,CAGT,CAEAvjD,EAAU,CAACX,EAAUE,EACvB,CAOA,MAAO,CAAES,QAL6B,CACpCA,EAAQ,GAAKijD,EACbjjD,EAAQ,GAAKijD,GAGoBC,OAAMC,OAAM,ECjFjD,EAR6C,CAC3C/I,EACAC,EACAyJ,IAEO,UAAU1J,EAAIC,GAAMyJ,ECuD7B,EA1D+B,CAC7B5rD,EACAi5C,EACA4S,EACAC,KAEA,MAAM,KAAEd,EAAI,KAAEC,EAAI,QAAEnjD,GAAYgkD,EAC1B/0C,GAAiB,IAAA6T,mBAAkB5qB,IACnC,SAAE0E,GAAaqS,EAErB,IAAKkiC,EAAaluC,OAGhB,OAFAkuC,EAAapnC,KAAKg6C,GAClBv5C,QAAQuX,IAAI,kCACL,EAGT,MAAMkiC,EAAernD,EAASnC,cAC5B02C,EAAaA,EAAaluC,OAAS,IAE/BihD,EAActnD,EAASnC,cAAcspD,GACrCI,EAAe,cAErB,cAAcA,EAAcD,EAAaD,GAEzC,MAAMG,EAAQrqD,KAAK6uC,IAAI,SAASub,EAAcjB,IACxCmB,EAAQtqD,KAAK6uC,IAAI,SAASub,EAAchB,IAExCmB,EAAiBvqD,KAAKsM,IAC1BtM,KAAK6O,MAAMw7C,EAAQpkD,EAAQ,IAC3BjG,KAAK6O,MAAMy7C,EAAQrkD,EAAQ,KAG7B,GAAIskD,EAAiB,EAAG,CACtB,MAAMC,EAAkBpT,EAAaA,EAAaluC,OAAS,GAErDuhD,EAAa,UAAUD,EAAiBR,GAExCU,EAAY,cAElB,cAAcA,EAAWV,EAAgBQ,GAEzC,SAASE,EAAWA,EAAU,GAAKD,EAAYC,EAAU,GAAKD,GAE9D,MAAME,EAAeF,EAAaF,EAElC,IAAK,IAAIniD,EAAI,EAAGA,GAAKmiD,EAAgBniD,IACnCgvC,EAAapnC,KAAK,CAChBw6C,EAAgB,GAAKG,EAAeD,EAAU,GAAKtiD,EACnDoiD,EAAgB,GAAKG,EAAeD,EAAU,GAAKtiD,GAGzD,MACEgvC,EAAapnC,KAAKg6C,GAGpB,OAAOO,CAAc,ECPvB,EAjD8B,CAC5B7rB,EACA2hB,EACAC,EACAnjB,KAGA,MAAMytB,EAAM,CAAClsB,EAAE,GAAK2hB,EAAG,GAAI3hB,EAAE,GAAK2hB,EAAG,IAC/BwK,EAAO,CAACvK,EAAG,GAAKD,EAAG,GAAIC,EAAG,GAAKD,EAAG,IAElCzR,EAAMgc,EAAI,GAAKC,EAAK,GAAKD,EAAI,GAAKC,EAAK,GAG7C,GAAIjc,EAAM,EACR,OAAO,EAGT,MAAMkc,EAAU9qD,KAAKiZ,KAAK4xC,EAAK,GAAKA,EAAK,GAAKA,EAAK,GAAKA,EAAK,IAE7D,GAAgB,IAAZC,EACF,OAAO,EAGT,MAAMC,EAAsBnc,EAAMkc,EAC5BE,EAAiB,CAACH,EAAK,GAAKC,EAASD,EAAK,GAAKC,GAC/CG,EAAmB,CACvBD,EAAe,GAAKD,EACpBC,EAAe,GAAKD,GAEhB7c,EAAgC,CACpCmS,EAAG,GAAK4K,EAAiB,GACzB5K,EAAG,GAAK4K,EAAiB,IAK3B,QAFiB,cAAcvsB,EAAGwP,GAEnB/Q,MAMX,cAAckjB,EAAInS,GAAmB,cAAcmS,EAAIC,GAIhD,EClDP9L,EAAU,KAST,SAAS0W,EAAYrZ,GAI1B,IAAIsZ,EAEJ,MAAMC,EAAa,EAAAza,UAAA,yBAAmCkB,EAAU,IAEhE,IAAK,IAAIzpC,EAAI,EAAGA,EAAI,EAAGA,IACrB,GACEgjD,EAAWC,OACT,CAAC5gD,EAAOkB,EAAOyF,IAAUpR,KAAK6uC,IAAIpkC,EAAMrC,GAAKgJ,EAAM,GAAGhJ,IAAMosC,IAE9D,CACA2W,EAAuB/iD,EACvB,KACF,CAGF,QAA6BiB,IAAzB8hD,EACF,MAAM,IAAIpkD,MACR,6EAKJ,MAAMukD,EAAW,GAEXC,GAAYJ,EAAuB,GAAK,EACxCK,GAAaL,EAAuB,GAAK,EAE/C,IAAK,IAAI/iD,EAAI,EAAGA,EAAIypC,EAAS3oC,OAAQd,IACnCkjD,EAASt7C,KAAK,CAAC6hC,EAASzpC,GAAGmjD,GAAW1Z,EAASzpC,GAAGojD,KAGpD,MAAO,CACLL,uBACAM,kBAAmBH,EAEvB,CClCO,SAASI,EACdjhD,EACAonC,EACAxrC,EAAwC,CAAC,GAEzC,MAAM,qBAAE8kD,EAAoB,kBAAEM,GAAsBP,EAAYrZ,IAE1D,MAAEoP,GAAU56C,EACZslD,EAAiB,GAEvB,GAAI1K,EACF,IAAK,IAAI74C,EAAI,EAAGA,EAAI64C,EAAM/3C,OAAQd,IAAK,CACrC,MAAM84C,EAAOD,EAAM74C,GACbwjD,EAAS,GAEf,IAAK,IAAIjK,EAAI,EAAGA,EAAIT,EAAKh4C,OAAQy4C,IAC/BiK,EAAO57C,KAAK,CACVkxC,EAAKS,IAAIwJ,EAAuB,GAAK,GACrCjK,EAAKS,IAAIwJ,EAAuB,GAAK,KAIzCQ,EAAe37C,KAAK47C,EACtB,CAQF,OAAO7K,EAAc0K,EALL,CACdhhD,GAAO0gD,EAAuB,GAAK,GACnC1gD,GAAO0gD,EAAuB,GAAK,IAGY,CAAElK,MAAO0K,GAC5D,iECOe,SAASluB,EACtBouB,EACAphD,GAEA,GAAoB,IAAhBohD,EAAK3iD,QAAiC,IAAjBuB,EAAMvB,OAC7B,MAAMnC,MACJ,8EAIJ,MAAOuK,EAAMk1B,EAAK7mC,EAAOC,GAAUisD,EAEnC,IAAI7C,EAAc,OAClB,MAAM8C,EAjDR,SACEx6C,EACAk1B,EACA7mC,EACAC,GAqBA,MAPqB,CACnB4mC,IAAK,CAb4B,CAACl1B,EAAMk1B,GACT,CAACl1B,EAAO3R,EAAO6mC,IAa9Cj1B,MAAO,CAX4B,CAACD,EAAO3R,EAAO6mC,GACjB,CAACl1B,EAAO3R,EAAO6mC,EAAM5mC,IAWtD63C,OAAQ,CAT4B,CAACnmC,EAAO3R,EAAO6mC,EAAM5mC,GACvB,CAAC0R,EAAMk1B,EAAM5mC,IAS/C0R,KAAM,CAP4B,CAACA,EAAMk1B,EAAM5mC,GACf,CAAC0R,EAAMk1B,IAU3C,CAuBuBulB,CAAmBz6C,EAAMk1B,EAAK7mC,EAAOC,GAW1D,OATAqL,OAAOyU,KAAKosC,GAAcn8C,SAASs5C,IACjC,MAAO/K,EAAWC,GAAW2N,EAAa7C,GACpCrb,EAAWpQ,EAAA,gBAA4B0gB,EAAWC,EAAS1zC,GAE7DmjC,EAAWob,IACbA,EAAcpb,EAChB,IAGKob,CACT,mBCxDe,SAASgD,EAAcC,EAAgB5P,GACpD,MAAM,OAAEqB,EAAM,OAAEwO,GAAWD,EACrBE,EAAUF,EAAOE,SAAWD,EAASA,EAE3C,OACG7P,EAAS,GAAKqB,EAAO,KAAOrB,EAAS,GAAKqB,EAAO,KAC/CrB,EAAS,GAAKqB,EAAO,KAAOrB,EAAS,GAAKqB,EAAO,KACjDrB,EAAS,GAAKqB,EAAO,KAAOrB,EAAS,GAAKqB,EAAO,KACpDyO,CAEJ,qFCzBA,MAAMxc,EAAU,KACVyc,EAAS,EACTC,EAAU,EAEhB,SAASC,EAAMrM,EAAKD,EAAOxzC,GACzB,MAAO+/C,EAAIC,GAAMhgD,EACjB,GAAIxM,KAAK6uC,IAAImR,GAASrQ,EACpB,OAAOsQ,EAAM,EAEf,MAAMwM,EAAIxM,EAAMD,EAEhB,GAAIA,EAAQ,EAAG,CACb,GAAIyM,EAAID,EACN,OAAO,EAELC,EAAIF,IACN//C,EAAE,GAAKigD,EAEX,KAAO,CACL,GAAIA,EAAIF,EACN,OAAO,EAELE,EAAID,IACNhgD,EAAE,GAAKigD,EAEX,CACA,OAAO,CACT,CAUe,SAAS5b,EAAK3+B,EAAGC,EAAGu6C,EAAKC,EAAKC,GAC3C,MAAO7N,EAAIhtC,GAAMG,GACV8sC,EAAIC,GAAM9sC,EACXguB,EAAK6e,EAAKD,EACV3e,EAAK6e,EAAKltC,EAYhB,QAVW1I,IAAPsjD,QAA2BtjD,IAAPujD,GACtBD,EAAKz6C,EACL06C,EAAKz6C,IAELw6C,EAAG,GAAKz6C,EAAE,GACVy6C,EAAG,GAAKz6C,EAAE,GACV06C,EAAG,GAAKz6C,EAAE,GACVy6C,EAAG,GAAKz6C,EAAE,IAIVnS,KAAK6uC,IAAI1O,GAAMwP,GACf3vC,KAAK6uC,IAAIzO,GAAMuP,GACfoP,GAAM2N,EAAI,IACV3N,GAAM2N,EAAI,IACV36C,GAAM26C,EAAI,IACV36C,GAAM26C,EAAI,GAEV,OAAON,EAGT,MAAM5/C,EAAI,CAAC,EAAG,GACd,GACE8/C,EAAMI,EAAI,GAAK3N,EAAI5e,EAAI3zB,IACvB8/C,EAAMvN,EAAK2N,EAAI,IAAKvsB,EAAI3zB,IACxB8/C,EAAMI,EAAI,GAAK36C,EAAIquB,EAAI5zB,IACvB8/C,EAAMv6C,EAAK26C,EAAI,IAAKtsB,EAAI5zB,GACxB,CACA,MAAO+/C,EAAIC,GAAMhgD,EASjB,OARIggD,EAAK,IACPI,EAAG,GAAK7N,EAAKyN,EAAKrsB,EAClBysB,EAAG,GAAK76C,EAAKy6C,EAAKpsB,GAEhBmsB,EAAK,IACPI,EAAG,IAAMJ,EAAKpsB,EACdwsB,EAAG,IAAMJ,EAAKnsB,GAETgsB,CACT,CACA,OAAOC,CACT,+DC1FkB,oMCIY,IACK,IACN,IACM,IACV,qDC6BV,SAAS7d,EACtBpkC,EACAyiD,EACA18C,EACAm+B,GAEA,IAAIwe,EAAMC,EAAMC,EAAMC,EAAMC,EAAMC,EAE9BpjD,EACJ,MAAM,SAAEjE,GAAasE,EAYrB,GAREL,EADGK,EAAiCN,cACtBM,EAAiCN,gBAEjCM,EACXyP,eACAC,aACAszC,WAGArjD,EAEH,YADA0G,QAAQC,KAAK,qCAAsCtG,GAIrD,MAAMpE,EAAaoE,EAAUE,gBAExBgkC,IAQDwe,EAAMC,IAAQC,EAAMC,IAAQC,EAAMC,IAAS7e,GAP7Cwe,EAAO,EACPC,EAAO/mD,EAAW,GAClBgnD,EAAO,EACPC,EAAOjnD,EAAW,GAClBknD,EAAO,EACPC,EAAOnnD,EAAW,IAKpB,MAAM6C,EAAQ,gBAAgBikD,EAAME,EAAME,GAEpCnnD,EAAYqE,EAAUC,eACtBxF,EAAakB,EAAUiZ,MAAM,EAAG,GAChCla,EAAgBiB,EAAUiZ,MAAM,EAAG,GACnC7Z,EAAiBY,EAAUiZ,MAAM,EAAG,GAEpC/Y,EAAUmE,EAAUG,cACnB8iD,EAAYC,EAAeC,GAAmBtnD,EAG/CunD,EAAgBpjD,EAAUQ,aAAa/B,GAEvC4kD,EAAU,gBACd5oD,EAAW,GAAKwoD,EAChBxoD,EAAW,GAAKwoD,EAChBxoD,EAAW,GAAKwoD,GAGZK,EAAa,gBACjB5oD,EAAc,GAAKwoD,EACnBxoD,EAAc,GAAKwoD,EACnBxoD,EAAc,GAAKwoD,GAGfK,EAAe,gBACnBxoD,EAAe,GAAKooD,EACpBpoD,EAAe,GAAKooD,EACpBpoD,EAAe,GAAKooD,GAGhBK,EACJ9nD,GACAiE,EAAWb,OAASlD,EAAW,GAAKA,EAAW,GAAKA,EAAW,GAC3D6nD,EAAY7nD,EAAW,GAAK4nD,EAC5BE,EAAY9nD,EAAW,GAAK6nD,EAE5Btf,EAAqC,GAErCwf,EAAa,WAAWP,GAE9B,IAAK,IAAIQ,EAAId,EAAMc,GAAKb,EAAMa,IAAK,CACjC,MAAMC,EAAY,WAAWF,GAE7B,IAAK,IAAIpM,EAAIqL,EAAMrL,GAAKsL,EAAMtL,IAAK,CACjC,MAAMuM,EAAY,WAAWH,GAE7B,IAAK,IAAI3lD,EAAI0kD,EAAM1kD,GAAK2kD,EAAM3kD,IAAK,CACjC,MAAM+lD,EAAyB,CAAC/lD,EAAGu5C,EAAGqM,GAGtC,GAAInB,EAAekB,EAA4BI,GAAW,CACxD,MAAMxiD,EAAQqiD,EAAIF,EAAYnM,EAAIkM,EAAYzlD,EAAIwlD,EAClD,IAAIlvC,EAEFA,EADEkvC,EAAY,EACN,CACN7jD,EAAW4B,GACX5B,EAAW4B,EAAQ,GACnB5B,EAAW4B,EAAQ,IAGb5B,EAAW4B,GAGrB4iC,EAAcv+B,KAAK,CACjB0O,QACA/S,QACAwiD,WACA9R,SAAU0R,EAAW/uC,UAEnB7O,GACFA,EAAS,CAAEuO,QAAO/S,QAAOwiD,WAAU9R,SAAU0R,GAEjD,CAGA,SAASA,EAAYA,EAAYN,EACnC,CAGA,UAAUM,EAAYG,GACtB,SAASH,EAAYA,EAAYL,EACnC,CAGA,UAAUK,EAAYE,GACtB,SAASF,EAAYA,EAAYJ,EACnC,CAEA,OAAOpf,CACT,sEC7JA,MAAM,sBAAExX,GAA0B,4BCZ3B,SAASq3B,EAAc3jD,EAAO4jD,EAAW,GAC9C,OACEC,WAAW7jD,EAAM,IAAIgc,QAAQ4nC,GAC7B,IACAC,WAAW7jD,EAAM,IAAIgc,QAAQ4nC,GAC7B,IACAC,WAAW7jD,EAAM,IAAIgc,QAAQ4nC,GAC7B,GAEJ,uICCO,SAASE,EAASnxB,EAAQmf,GAC/B,MAAMiS,EAAa,EAANjS,EACb,GAAIiS,EAAOpxB,EAAOl0B,OAChB,OAAO,gBACLk0B,EAAOoxB,GACPpxB,EAAOoxB,EAAO,GACdpxB,EAAOoxB,EAAO,GAGpB,CAOO,SAASC,EAAwBC,GACtC,MAAMC,EAAYD,EAASE,WAAWxB,UACtC,IAAI7Q,EAAM,EACV,MAAMuP,EAAe,IAAI9pC,IAGzB,KAAOu6B,EAAMoS,EAAUzlD,QAAQ,CAC7B,MAAM2lD,EAAcF,EAAUpS,KACxB0M,EAAU,GAChB,IAAK,IAAI7gD,EAAI,EAAGA,EAAIymD,EAAazmD,IAC/B6gD,EAAQj5C,KAAK2+C,EAAUpS,EAAMn0C,IAE/B0jD,EAAanvC,IAAIssC,EAAQ,GAAIA,GAC7B1M,GAAOsS,CACT,CAEA,MAAMC,EAAW,GAGXC,EAAqBptD,IACzB,IAAK,MAAOgd,EAAKD,KAAU/c,EAAIqtD,UAC7B,QAAc3lD,IAAVqV,EACF,OAAOC,EAGX,OAAQ,CAAC,EAIX,IAAIqoC,EAAa+H,EAAkBjD,GACnC,MAAuB,IAAhB9E,GAAmB,CACxB,MAAM1U,EAAU,CAAC0U,GACjB,KAAO8E,EAAa1qC,IAAI4lC,IAAa,CACnC,MAAMiI,EAAYnD,EAAa3gD,IAAI67C,GAAY,GAC3C8E,EAAa1qC,IAAI6tC,IACnB3c,EAAQtiC,KAAKi/C,GAEfnD,EAAajuC,OAAOmpC,GACpBA,EAAaiI,CACf,CACAH,EAAS9+C,KAAKsiC,GACd0U,EAAa+H,EAAkBjD,EACjC,CAEA,OAAOgD,EAAS5lD,OAAS4lD,OAAWzlD,CACtC,CAOO,SAAS6lD,EAAkBR,GAChC,MAAMS,EAAkBV,EAAwBC,GAChD,IAAKS,EACH,OAGF,MAAMC,EAAgBV,EAASW,YAAYjC,UAC3C,OAAO+B,EAAgBxtD,KAAK2tD,GAC1BA,EAAe3tD,KAAKgK,GAAU4iD,EAASa,EAAezjD,MAE1D,4HCrFA,MAAM,QAAEymC,GAAY,YAEN,gBAAgB,EAAG,EAAG,GACtB,gBAAgB,EAAG,EAAG,GACtB,gBAAgB,EAAG,EAAG,oDCarB,SAAS5pC,EACtB3F,EACAwD,GAKA,KAFuB,IAAA0iB,mBAAkBlmB,EAAS1E,SAGhD,MAAM,IAAI4I,MAAM,0DAGlB,GACElE,aAAoB,EAAAipC,eACc,IAAlCjpC,EAASoF,cAAciB,OAEvB,MAAM,IAAInC,MAAM,wCAGlB,MAAM,SAAEqS,EAAQ,MAAE3Q,EAAK,YAAE8mD,GAAgBlpD,EAErCxD,aAAoB,EAAA2sD,eAWnB,SACL3sD,EACAuW,EACA3Q,EACA8mD,GAAc,GAEd,MAAME,EAAmBF,GAEnB,eAAEG,EAAc,iBAAEC,EAAgB,eAAEC,GACxC,wCAAoC/sD,EAAUuW,EAAUq2C,GAE1D,IAAKG,EACH,OAGF,MAAM,WAAEz5B,EAAU,yBAAEH,EAAwB,OAAElpB,GAAW8iD,GACnD,WAAE7iD,EAAU,gBAAEyB,EAAe,SAAEF,GAAaxB,GAE5C,cAAE+iD,EAAa,YAAEC,GAAgB,kCACrC/iD,EACAuB,EACA6nB,EACA3nB,EACAwnB,EACAvtB,GAGF5F,EAASgK,UAAU,CACjBE,WAAY8iD,EACZvhD,SAAUwhD,IAEZjtD,EAASL,SAET,MAAMutD,EAAmBJ,EAAmBlnD,EAEtCunD,EACJ,CACE52C,WACAvW,WACA4F,QACAsnD,mBACAJ,mBACAD,iBACAO,eAAgBptD,EAASuK,sBAI1B2iD,EAAmBL,GAAkBK,EAAmB,IACzDltD,EAASuK,oBAKT,yBACE,EAAAiiC,YACA,EAAA6gB,OAAOC,4BACPH,GAGF,yBACE,EAAA3gB,YACA,EAAA6gB,OAAOE,uBACPJ,EAGN,CA3EIK,CAAaxtD,EAAUuW,EAAU3Q,EAAO8mD,GAEvC1sD,EAAkC2F,OACjCC,EACApC,EAAQiqD,gBACRjqD,EAAQ/H,KAGd,+HC5BA,MAAM,OAAEssB,GAAW,YAEb2lC,EAA8B,CAClC,IAAYC,eACZ,IAAYC,sBAGC,MAAMC,SACZ,KAAAC,UAAY,EAAG,CAEtB,cAAOC,CAAQrsB,GACRnlC,KAAKuxD,UAAUrqC,SAASie,IAC3BnlC,KAAKuxD,UAAU3gD,KAAKu0B,EAExB,CA4BA,0BAAOssB,CACLC,EACAC,EAAwC,CAAC,GAEzC,MAAM,UAAEJ,EAAS,eAAE5kB,EAAc,aAAEqF,EAAY,WAAE5qC,GAAeuqD,EAChE,IAAK,MAAMxsB,KAAYosB,GAAaD,EAAqBC,UAAW,CAClE,MAAM5sB,EAAc,uBAClBQ,EACAusB,GAEF,GAAK/sB,GAAa76B,OAGlB,IAAK,MAAM+zB,KAAc8G,EAAa,CACpC,MAAM,iBAAEitB,EAAgB,KAAE9mD,EAAI,cAAE+mD,EAAa,SAAE7pD,GAAa61B,EACxD+zB,IACF/zB,EAAWi0B,wBAAyB,GAEjCD,IAGD7f,GAAgBA,IAAiBlnC,EAAKinC,aAAaC,mBAItC/nC,IAAf7C,GACAY,GACAZ,IAAeY,EAASZ,YAKxBulC,GACAA,IAAmB7hC,EAAKinC,aAAapF,kBAIvC,OAAiC9O,GACjCA,EAAWg0B,eAAgB,GAC7B,CACF,CACF,QAOO,KAAAE,0BAA6BvoD,IAClC,MAAMq0B,EAAar0B,EAAImrB,OAAOkJ,WAC9B,IAAKA,GAAY71B,SACf,OAEF,MAAM,SAAEm9B,EAAQ,iBAAE6sB,GAAqBn0B,EAAW71B,SAElD,IACGhI,KAAKuxD,UAAUrqC,SAASie,KACxBnlC,KAAKuxD,UAAUrqC,SAAS8qC,GAEzB,OAGF,MAAMvuD,GAAW,OAAyBo6B,GAC1C,IAAKp6B,EAEH,YADA4N,QAAQC,KAAK,8BAA+BusB,GAG9C,MACMo0B,EAA0C,CAC9CxuD,WACAyuD,UAHsCC,EAAa1uD,GAInDo6B,aACA+zB,iBAAkB/zB,EAAW+zB,kBAEzBQ,IAAwBv0B,EAAW+zB,iBAGzC,GADA/zB,EAAWg0B,eAAgB,EACvBO,EAKF,OAFA,OAAyBH,QACzB,OAAYA,GAGd,MAAMI,EAAa,CACjB,CACE9yC,IAAK,eACLD,MAAOue,EAAW/yB,KAAKinC,aAAaC,aACpCsgB,UAAYz0B,GAAeA,EAAW/yB,KAAKinC,cAE7C,CACExyB,IAAK,kBACLD,MAAOue,EAAW71B,SAASoH,gBAC3BkjD,UAAYz0B,GAAeA,EAAW71B,UAExC,CACEuX,IAAK,SACLD,MAAOue,EAAW71B,SAASmH,OAC3BmjD,UAAYz0B,GAAeA,EAAW71B,WAG1C,IAAIuqD,GAA2B,OAC7BN,EACAI,GAGF,MAAM,WAAEjrD,GAAey2B,EAAW71B,SAC5BwqD,EAAW,IAAIlgB,IACrBigB,EAAyBhiD,SAASkiD,IAChC,GACEA,EAAwBX,wBACxBW,EAAwBzqD,SAASZ,aAAeA,EAChD,CACA,MAAM,iBAAEwqD,GAAqBa,EAC7BD,EAASvwC,IAAI2vC,EACf,KAEFW,EAA2BA,EAAyB/kD,QACjDilD,IACED,EAASxwC,IAAIywC,EAAwBb,oBAI1C/zB,EAAW+zB,iBACTW,EAAyB,IAAIX,kBAAoBpmC,IACnDymC,EAAaL,iBAAmB/zB,EAAW+zB,kBAC3C,OAAYK,EAAa,CACzB,QAMK,KAAAS,uBAA0BlpD,IAC/B,MAAMq0B,EAAar0B,EAAImrB,OAAOkJ,YACxB,WAAE80B,EAAa,IAAYvB,gBAAmB5nD,EAAImrB,OACxD,IAAKkJ,GAAY71B,SACf,OAEF,MAAM,SAAEm9B,EAAQ,iBAAE6sB,GAAqBn0B,EAAW71B,SAElD,IACIhI,KAAKuxD,UAAUrqC,SAASie,KACvBnlC,KAAKuxD,UAAUrqC,SAAS8qC,KAC1Bb,EAA4BjqC,SAASyrC,GAEtC,OAEF,MAAMlvD,GAAW,OAAyBo6B,GAC1C,IAAKp6B,EAKH,YAJA4N,QAAQC,KACN,gEACAusB,GAIAA,EAAWg0B,iBAGb,OAAiCh0B,GACjCA,EAAWg0B,eAAgB,GAG7B,MACMI,EAA0C,CAC9CxuD,WACAyuD,UAHsCC,EAAa1uD,GAInDo6B,aACA+zB,iBAAkB/zB,EAAW+zB,iBAC7BgB,sBAAuBD,IAAe,IAAYtB,uBAEpD,OAAYY,EAAa,CACzB,QAKK,KAAAY,uBAA0BrpD,IAC/B,MAAMq0B,EAAar0B,EAAImrB,OAAOkJ,WAC9B,IAAKA,GAAY71B,SACf,OAEF,MAAM,SAAEm9B,GAAatH,EAAW71B,SAEhC,IAAKhI,KAAKuxD,UAAUrqC,SAASie,IAAatH,EAAWg0B,cACnD,OAEF,MAAMpuD,GAAW,OAAyBo6B,GAE1C,IAAKp6B,EAKH,YAJA4N,QAAQC,KACN,iDACAusB,GAKJ,MACMo0B,EAA0C,CAC9CxuD,WACAyuD,UAHsCC,EAAa1uD,GAInDo6B,aACA+zB,iBAAkB/zB,EAAW+zB,kBAG/B/zB,EAAWg0B,eAAgB,GAC3B,OAAyBI,EAAa,CACtC,EAGJ,SAASE,EAAa1uD,GAKpB,MAJwC,CACtCuzB,eAAgBvzB,EAAS/C,oBACzBu2B,WAAYxzB,EAASsL,yBAGzB,wLCnRA,MAAM,SAAEwkC,GAAaC,EAAA,2CCKrB,SAASsf,EACPC,EACAC,GAQA,OAN4B,IAAIpwC,IAC9BmwC,EAAcxwD,KAAI,CAAC8C,EAASkH,IACnB,CAAClH,EAAS2tD,EAAqBzmD,MAK5C,+FCmLA,SAAS0mD,EAAKC,EAAQC,EAAWrpD,GAI/B,OAHc,IAAIxC,MAAMwC,EAAS,GACfspD,KAAKD,GAETD,GAAQtzC,OAAO9V,EAC/B,kBAEA,QAjLA,SACEupD,EACAC,EACArsD,EAA4B,CAAC,GAE7B,MAAMssD,EAAUtsD,EAAQssD,QAClBC,EAAavsD,EAAQusD,WACrBC,EAASxsD,EAAQwsD,OACjBC,EAAYzsD,EAAQysD,YAAa,EACjCC,EAAY5nD,EAAIunD,GAChBM,EA6GN,WACE,MAAMA,EASR,SAAiB9pD,GACf,MAAM+pD,EAAQ,GAERC,EAAc,SAAUZ,GAC5B,OAAOA,EAAOvkD,MAAM,IAAIpM,KAAI,SAAU6K,GACpC,OAAO2mD,SAAS3mD,EAAG,IAAM,CAC3B,GACF,EAEA,IAAK,IAAIpE,EAAI,EAAGA,EAAIpI,KAAKwS,IAAI,EAAGtJ,GAASd,GAAK,EAAG,CAC/C,MAAMkqD,EAASD,EAAKjqD,EAAEgrD,SAAS,GAAI,IAAKlqD,GAExC+pD,EAAMjjD,KAAKkjD,EAAYZ,GACzB,CAEA,OAAOW,CACT,CAzBuBI,CAAQX,EAAKxpD,QAElC,OAAO8pD,EAAapmD,QAAO,SAAU0mD,GACnC,MAAMzX,EAmCZ,SAAwBzqC,GACtB,IAAIyqC,EAAQ,EAEZ,IAAK,IAAIzzC,EAAI,EAAGA,EAAIgJ,EAAMlI,OAAQd,GAAK,EACpB,IAAbgJ,EAAMhJ,KACRyzC,GAAS,GAIb,OAAOA,CACT,CA7CoB0X,CAAeD,GAE7B,OAAiB,IAAVzX,IAA0B,IAAVA,GAAeiX,EACxC,GACF,CArHqBU,GACfC,EAAQ,GACRC,EAAU,GACVC,EAAS,IAAIjiB,IACbkiB,EAAS,IAAI5xC,IAInB,IAFAyxC,EAAMzjD,KAAK,CAAE6jD,YAAanB,IAEnBe,EAAMvqD,OAAS,GACpB4qD,EAAML,EAAMrmC,OAGd,MAAO,CACLsmC,UACAK,WA2HF,WACE,MAAM3iD,EAAQ1K,MAAM6Z,KAAKqzC,EAAOjhD,UAEhC,OADAvB,EAAM2jC,UACC3jC,CACT,CA/Hc2iD,IAGd,SAASD,EAAME,GACb,MAAMC,EAAUD,EAAIH,YACdK,EAAWF,EAAIG,cAmBvB,SAAiBx1C,GACf,MAAO9M,EAAG0E,EAAG69C,EAAI,GAAKz1C,EAGhB01C,EAAOxiD,EAAI,MAAQ,OAAS0E,EAAI,MAAQ,OAAS69C,EAAI,QAC3D,OAAOT,EAAOvyC,IAAIizC,EACpB,EAvBM5O,CAAQwO,KAyBd,SAAuBt1C,GACrB,MAAO9M,EAAG0E,EAAG69C,EAAI,GAAKz1C,EAChB01C,EAAOxiD,EAAI,MAAQ,OAAS0E,EAAI,MAAQ,OAAS69C,EAAI,QAC3DT,EAAOtyC,IAAIgzC,EACb,CA1BEC,CAAcL,GA4BhB,SAAgBA,GACd,MAAMn9B,EAAO3rB,EAAI8oD,GAEjB,OAAOpB,EAASA,EAAO/7B,EAAMi8B,GAAaj8B,IAASi8B,CACrD,CA9BMwB,CAAON,IAgCb,SAAuBA,GACrBP,EAAQ1jD,KAAKikD,GACTtB,GAEFA,KAAWsB,EAEf,CArCIO,CAAcP,GAmDlB,SAAsBA,GACpB,IAAK,IAAI7rD,EAAI,EAAGA,EAAI4qD,EAAa9pD,OAAQd,GAAK,EAAG,CAC/C,MAAMkrD,EAAON,EAAa5qD,GACpBqsD,EAAWR,EAAQj1C,MAAM,GAE/B,IAAK,IAAI2iC,EAAI,EAAGA,EAAIsS,EAAQ/qD,OAAQy4C,GAAK,EACvC8S,EAAS9S,IAAM2R,EAAK3R,GAGtB8R,EAAMzjD,KAAK,CACT6jD,YAAaY,EACbN,aAAcF,GAElB,CACF,CAhEIS,CAAaT,IAsCjB,SAAwBC,GACtB,MAAOriD,EAAG0E,EAAG69C,EAAI,GAAKF,EAGhBG,EAAOxiD,EAAI,MAAQ,OAAS0E,EAAI,MAAQ,OAAS69C,EAAI,QAC3DR,EAAOj3C,IAAI03C,EAAMH,GACbtB,GAEFA,KAAcsB,EAElB,CA9CIS,CAAeT,GAEnB,CA8DA,SAAS/oD,EAAI8oD,GAEX,OAAOxB,KAAUwB,EACnB,CA6CF,+FC5KO,SAASW,EAAwC7oB,GACtD,MAAMoF,GAAe,IAAAE,iBAAgBtF,IAC/B,kBAAEyF,GAAsBL,EAAaG,mBAAmBC,QAE9D,IAAK,MAAOH,EAAcyjB,KAAmBrjB,EAAkBwd,UAAW,CAKxE,GAJiCtoD,MAAM6Z,KAAKs0C,GAAgBvtC,MACzDsY,IAAkB,QAAcA,GAAehC,cAIhD,OAAOwT,CAEX,CAGF,yECGO,SAAS0jB,EACd/oB,EACAgpB,GACA,SAAElyD,EAAQ,aAAEmyD,IAEZ,MAAM7jB,GAAe,IAAAE,iBAAgBtF,GAE/BkpB,EAAe9jB,EAAaG,mBAAmB4jB,SAErD,IAAI,OAAqBD,GAAe,CACtC,MAAM,SAAE77C,GAAa67C,EACfE,EAAqB,EAAA1qB,MAAM7lB,UAAUxL,GAE3C,IAAK+7C,EACH,OAGF,MAAM/qD,EAAY+qD,EAAmB/qD,UAE/BgnC,EAAehnC,EAAUgrD,wBAAwBL,GAIjDM,EAkHV,SACE3qD,EACA0mC,EACAvuC,EACAuH,EACA4qD,GAEA,MAAMM,EAAmB,CAACC,EAAgBC,KACxC,MAAMC,EAAiB,CAAC/qD,EAAY,GAAK6qD,EAAQ7qD,EAAY,GAAK8qD,GAE5DT,EAAalyD,EAASnC,cAAc+0D,GAC1C,OAAOrrD,EAAUgrD,wBAAwBL,EAAW,EAGtD,OAAOW,EAAgBJ,EAAkBlkB,EAAc4jB,EACzD,CAjImBW,CAFK9yD,EAAS1B,cAAc4zD,GAIzC3jB,EACAvuC,EACAuH,EACA4qD,GAGF,OAAOK,EAASjkB,OAAe/nC,CACjC,CAGA,MAAM,oBAAEusD,GAAwBX,EAE1BhF,EAAkBptD,EAAkCuK,oBAEpDyoD,EAAsBD,EAAoBzqD,IAAI8kD,GAGpD,IAFc,EAAAxlB,MAAM56B,SAASgmD,GAG3B,OAMF,MAAMC,GAA8B,IAAAC,kCAClC5kB,EAAapF,iBAGT,8BAAEiqB,GAAkCF,EAA4B,GAChEG,EAAoBpzD,EAASqzD,SAASF,GACtC5rD,EAAY6rD,GAAmB3zD,MAAM6zD,YAAYC,eACjDC,EAAW,EAAA1lB,UAAA,sBAAgCvmC,EAAW2qD,GAEtD/uD,EAAaoE,EAAUE,gBACvBgsD,EAAgBlsD,EAAUksD,cAC9B,EAAA3lB,UAAA,aAAuB4lB,yBACrBvwD,EACAoE,EAAUyP,eAAeC,aAAaszC,WAGpChc,EAAeklB,EAAaE,cAAcH,GAE1ChB,EAkDR,SACEgB,EACArwD,EACAswD,EACAllB,EACA4jB,GAEA,MAAMM,EAAmB,CAACC,EAAgBC,EAAgBiB,KACxD,MAAMC,EAAc,CAClBL,EAAS,GAAKd,EACdc,EAAS,GAAKb,EACda,EAAS,GAAKI,GAGhB,OAAOH,EAAaK,YAAYD,EAAY,EAG9C,OAAOhB,EAAgBJ,EAAkBlkB,EAAc4jB,EACzD,CApEiB4B,CACbP,EACArwD,EACAswD,EACAllB,GAGF,OAAOikB,EAASjkB,OAAe/nC,CACjC,CASA,SAASqsD,EACPJ,EAKAlkB,EACA4jB,EAAe,GAEf,MAAM6B,EAAgBnwD,MAAM6Z,KAC1B,CAAErX,OAAQ,EAAI8rD,EAAe,IAC7B,CAACv7B,EAAGrxB,IAAMA,EAAI4sD,IAGhB,IAAK,MAAMO,KAAUsB,EACnB,IAAK,MAAMrB,KAAUqB,EACnB,IAAK,MAAMJ,KAAUI,EAAe,CAClC,GAAe,IAAXtB,GAA2B,IAAXC,GAA2B,IAAXiB,EAClC,SAGF,MAAMK,EAAgBxB,EAAiBC,EAAQC,EAAQiB,GAEvD,QAAsBptD,IAAlBytD,GAA+B1lB,IAAiB0lB,EAClD,OAAO,CAEX,CAIJ,OAAO,CACT,2GClHO,SAASC,EACdhrB,EACAgpB,EACA1uD,EAAU,CAAC,GAEX,MAAM8qC,GAAe,IAAAE,iBAAgBtF,GAE/BuF,EAAqBH,EAAaG,mBAGlC0lB,EACJ3wD,GAAS4wD,oBAAsBhsD,OAAOyU,KAAK4xB,GAAoB,GAEjE,IAAK0lB,EACH,MAAM,IAAIjwD,MACR,gBAAgBglC,uCAIpB,OAAQirB,GACN,KAAK,EAAApkB,4BAA4BD,SAC/B,OAgBC,SACLxB,EACA4jB,GACA,SAAElyD,IAEF,MAAMoyD,EAAe9jB,EAAaG,mBAAmB4jB,SAErD,IAAI,OAAqBD,GAAe,CACtC,MAAM,SAAE77C,GAAa67C,EACfE,EAAqB,EAAA1qB,MAAM7lB,UAAUxL,GAE3C,IAAK+7C,EACH,OAMF,OAFEA,EAAmB/qD,UAAUgrD,wBAAwBL,EAGzD,CAGA,MAAM,oBAAEa,GAAwBX,EAE1BhF,EAAkBptD,EAAkCuK,oBAEpDyoD,EAAsBD,EAAoBzqD,IAAI8kD,GAGpD,IAFc,EAAAxlB,MAAM56B,SAASgmD,GAG3B,OAMF,MAAMC,GAA8B,IAAAC,kCAClC5kB,EAAapF,iBAGT,8BAAEiqB,GAAkCF,EAA4B,GAEhEG,EAAoBpzD,EAASqzD,SAASF,GACtC5rD,EAAY6rD,GAAmB3zD,MAAM6zD,YAAYC,eACjDC,EAAW,EAAA1lB,UAAA,sBAAgCvmC,EAAW2qD,GAEtD/uD,EAAaoE,EAAUE,gBACvBgsD,EAAgBlsD,EAAUksD,cAC9B,EAAA3lB,UAAA,aAAuB4lB,yBACrBvwD,EACAoE,EAAUyP,eAAeC,aAAaszC,WAK1C,OAFqBkJ,EAAaE,cAAcH,EAGlD,CAxEaa,CAA6B/lB,EAAc4jB,EAAY1uD,GAChE,KAAK,EAAAusC,4BAA4BukB,QAC/B,OAgFC,SACLhmB,EACA4jB,GACA,SAAElyD,IAEF,MAAMu0D,EAAcjmB,EAAaG,mBAAmBC,QAE9C8lB,EAAiB3wD,MAAM6Z,KAAK62C,EAAY5lB,kBAAkB9xB,SAC1D,gBAAElR,GAAoB3L,EAASuL,YAErC,IAAK,MAAMgjC,KAAgBimB,EAAgB,CACzC,MAAMC,EAAiBF,EAAY5lB,kBAAkBrmC,IAAIimC,GAEzD,GAAKkmB,EAIL,IAAK,MAAM13B,KAAiB03B,EAAgB,CAC1C,MAAMr6B,GAAa,QACjB2C,GAGF,IAAK3C,EACH,SAGF,MAAM,SAAE4U,GAAa5U,EAAW/yB,KAAKooC,QAErC,GACG,EAAA3B,UAAA,QAAkBniC,EAAiByuB,EAAW71B,SAASoH,mBAQtD,IAAAk9C,yBAAwBqJ,EAAYljB,GACtC,OAAO7jC,OAAOojC,EAElB,CACF,CACF,CA1HammB,CAA4BpmB,EAAc4jB,EAAY1uD,GAC/D,QACE,OAEN,4jBC1CO,SAASmxD,EAAsBlzB,GACpC,MAAMmzB,GAAY,IAAAC,cAAapzB,GAE/B,QAAkBj7B,IAAdouD,EACF,QAG8B,QAAsBnzB,GAE9B30B,SAASgoD,IAE/BA,EAAKH,uBAAuB,IAI9B,MAAMI,EAAgBH,EAAUI,mBAE1BC,EAAqB7sD,OAAOyU,KAAKk4C,GAAej2D,KACnDgd,GAAQi5C,EAAcj5C,KAGzB,IAAKm5C,EAAmB5uD,OACtB,OAGF,MAAM,kBAAEpG,GAAsBg1D,EAAmB,GAI3CvnD,EAAcknD,EAAUM,iBAExBznD,GAAkB,IAAA8zB,oBAAmBthC,IAE3C,OAAsCwN,EAAiBC,EACzD,iVCnCO,SAASynD,EAAsB1zB,EAAqBC,GACzD,MAAMkzB,GAAY,IAAAC,cAAapzB,GAE/B,QAAkBj7B,IAAdouD,EACF,OAGF,MAAMQ,EAAgBR,EAAUS,eAEhC,IAAKjtD,OAAOyU,KAAKu4C,GAAe/uD,OAC9B,OAGF,GAAIq7B,GAAY0zB,EAAc1zB,GAC5B,MAAO,CAAC0zB,EAAc1zB,IAQxB,OAJgCt5B,OAAO0H,OAAOslD,GAAerrD,QAC1DurD,GAAiBA,aAAwB,KAI9C,iHCiCA,QAnBA,SAAkBljB,EAAMC,EAAM7uC,GAC5B,IAAIqvC,GAAU,EACVrN,GAAW,EAEf,GAAoB,mBAAT4M,EACT,MAAM,IAAIY,UAAU,uBAOtB,OALI,OAASxvC,KACXqvC,EAAU,YAAarvC,EAAUwwC,QAAQxwC,EAAQqvC,SAAWA,EAC5DrN,EAAW,aAAchiC,EAAUwwC,QAAQxwC,EAAQgiC,UAAYA,IAG1D,OAAS4M,EAAMC,EAAM,CAC1BQ,UACArN,WACAgN,QAASH,GAEb,mBCxDA,SAASkjB,EACPr4B,EACAs4B,GAEA,MAAMC,EAAOC,EAAcx4B,GACrBlf,EAAO03C,EAAcF,GAC3B,MAAO,CACLG,KAAMC,EAAkBH,EAAKE,KAAM33C,EAAK23C,MACxCE,OAAQD,EAAkBH,EAAKI,OAAQ73C,EAAK63C,QAC5Cx6D,OAAQu6D,EAAkBH,EAAKp6D,OAAQ2iB,EAAK3iB,QAC5C8hC,OAiKF24B,EAjK2BL,EAAKt4B,MAkKhCgS,EAlKuCnxB,EAAKmf,MAoKrC,CAAC24B,EAAO,GAAK3mB,EAAO,GAAI2mB,EAAO,GAAK3mB,EAAO,GAAI2mB,EAAO,GAAK3mB,EAAO,MAJ3E,IACE2mB,EACA3mB,CAhKF,CASA,SAAS4mB,EACP74B,EACAs4B,GAEA,MAAMC,EAAOC,EAAcx4B,GACrBlf,EAAO03C,EAAcF,GAC3B,MAAO,CACLG,KAAMK,EAAeP,EAAKE,KAAM33C,EAAK23C,MACrCE,OAAQG,EAAeP,EAAKI,OAAQ73C,EAAK63C,QACzCx6D,OAAQ26D,EAAeP,EAAKp6D,OAAQ2iB,EAAK3iB,QACzC8hC,MAAO84B,EAAeR,EAAKt4B,MAAOnf,EAAKmf,OAE3C,CAgBA,SAAS+4B,EACPh5B,EACAs4B,GAEA,MAAMW,EAAkBC,EAAkCl5B,GACpDm5B,EAAeD,EAAkCZ,GAOvD,MANsB,CACpBG,KAAMQ,EAAgBR,KAAOU,EAAaV,KAC1CE,OAAQM,EAAgBN,OAASQ,EAAaR,OAC9Cx6D,OAAQ86D,EAAgB96D,OAASg7D,EAAah7D,OAC9C8hC,MAAOg5B,EAAgBh5B,MAAQk5B,EAAal5B,MAGhD,CAQA,SAASm5B,EAAe/7B,GACtB,OAAOg8B,KAAKC,MAAMD,KAAKE,UAAUl8B,GACnC,CAEA,SAASm8B,EAAWn8B,GAClB,OAAOg8B,KAAKC,MAAMD,KAAKE,UAAUl8B,GACnC,CAEA,SAASm7B,EAAcn7B,GACrB,OAAOA,EAAOoV,QACZ,CAACgnB,EAAMlB,KACE,CACLE,KAAM,CACJgB,EAAKhB,KAAK,GAAKF,EAAKE,KAAK,GAAKp7B,EAAOl0B,OACrCswD,EAAKhB,KAAK,GAAKF,EAAKE,KAAK,GAAKp7B,EAAOl0B,QAEvCwvD,OAAQ,CACNc,EAAKd,OAAO,GAAKJ,EAAKI,OAAO,GAAKt7B,EAAOl0B,OACzCswD,EAAKd,OAAO,GAAKJ,EAAKI,OAAO,GAAKt7B,EAAOl0B,QAE3ChL,OAAQ,CACNs7D,EAAKt7D,OAAO,GAAKo6D,EAAKp6D,OAAO,GAAKk/B,EAAOl0B,OACzCswD,EAAKt7D,OAAO,GAAKo6D,EAAKp6D,OAAO,GAAKk/B,EAAOl0B,QAE3C82B,MAAO,CACLw5B,EAAKx5B,MAAM,GAAKs4B,EAAKt4B,MAAM,GAAK5C,EAAOl0B,OACvCswD,EAAKx5B,MAAM,GAAKs4B,EAAKt4B,MAAM,GAAK5C,EAAOl0B,OACvCswD,EAAKx5B,MAAM,GAAKs4B,EAAKt4B,MAAM,GAAK5C,EAAOl0B,WAI7C,CACEsvD,KAAM,CAAC,EAAG,GACVE,OAAQ,CAAC,EAAG,GACZx6D,OAAQ,CAAC,EAAG,GACZ8hC,MAAO,CAAC,EAAG,EAAG,IAGpB,CAEA,SAASy5B,EAAmBr8B,GAC1B,OAAOA,EAAOoV,QACZ,CAACgnB,EAAMlB,KACE,CACLE,KAAM,CACJgB,EAAKhB,KAAK,GAAKF,EAAKE,KAAK,GAAKp7B,EAAOl0B,OACrCswD,EAAKhB,KAAK,GAAKF,EAAKE,KAAK,GAAKp7B,EAAOl0B,QAEvCwvD,OAAQ,CACNc,EAAKd,OAAO,GAAKJ,EAAKI,OAAO,GAAKt7B,EAAOl0B,OACzCswD,EAAKd,OAAO,GAAKJ,EAAKI,OAAO,GAAKt7B,EAAOl0B,QAE3ChL,OAAQ,CACNs7D,EAAKt7D,OAAO,GAAKo6D,EAAKp6D,OAAO,GAAKk/B,EAAOl0B,OACzCswD,EAAKt7D,OAAO,GAAKo6D,EAAKp6D,OAAO,GAAKk/B,EAAOl0B,QAE3C82B,MAAO,CACLw5B,EAAKx5B,MAAM,GAAKs4B,EAAKt4B,MAAM,GAAK5C,EAAOl0B,OACvCswD,EAAKx5B,MAAM,GAAKs4B,EAAKt4B,MAAM,GAAK5C,EAAOl0B,OACvCswD,EAAKx5B,MAAM,GAAKs4B,EAAKt4B,MAAM,GAAK5C,EAAOl0B,QAEzCwwD,MAAO,CACLC,WAAY,KACZC,QAASJ,EAAKE,MAAME,QAAUtB,EAAKoB,MAAME,QAAUx8B,EAAOl0B,OAC1D2wD,QAASL,EAAKE,MAAMG,QAAUvB,EAAKoB,MAAMG,QAAUz8B,EAAOl0B,OAC1D4wD,MAAON,EAAKE,MAAMI,MAAQxB,EAAKoB,MAAMI,MAAQ18B,EAAOl0B,OACpD6wD,cACEP,EAAKE,MAAMK,cAAgBzB,EAAKoB,MAAMK,cAAgB38B,EAAOl0B,WAIrE,CACEsvD,KAAM,CAAC,EAAG,GACVE,OAAQ,CAAC,EAAG,GACZx6D,OAAQ,CAAC,EAAG,GACZ8hC,MAAO,CAAC,EAAG,EAAG,GACd05B,MAAO,CACLC,WAAY,KACZC,QAAS,EACTC,QAAS,EACTC,MAAO,EACPC,cAAe,IAIvB,CAQA,SAAStB,EACPE,EACA3mB,GAEA,MAAO,CAAC2mB,EAAO,GAAK3mB,EAAO,GAAI2mB,EAAO,GAAK3mB,EAAO,GACpD,CASA,SAASinB,EAAkC77B,GAEzC,MAAM48B,EAA8B,GACpC,IAAK,IAAI5xD,EAAI,EAAGA,EAAIg1B,EAAOl0B,OAAQd,IACjC,IAAK,IAAIu5C,EAAI,EAAGA,EAAIvkB,EAAOl0B,OAAQy4C,IAC7Bv5C,EAAIu5C,GACNqY,EAAehqD,KAAK,CAClBwoD,KAAMK,EAAez7B,EAAOh1B,GAAGowD,KAAMp7B,EAAOukB,GAAG6W,MAC/CE,OAAQG,EAAez7B,EAAOh1B,GAAGswD,OAAQt7B,EAAOukB,GAAG+W,QACnDx6D,OAAQ26D,EAAez7B,EAAOh1B,GAAGlK,OAAQk/B,EAAOukB,GAAGzjD,QACnD8hC,MAAO84B,EAAe17B,EAAOh1B,GAAG43B,MAAO5C,EAAOukB,GAAG3hB,SAOzD,OAAOg6B,EAAexnB,QACpB,CAACgnB,EAAMlB,KACE,CACLE,KAAMgB,EAAKhB,KAAOF,EAAKE,KAAOwB,EAAe9wD,OAC7CwvD,OAAQc,EAAKd,OAASJ,EAAKI,OAASsB,EAAe9wD,OACnDhL,OAAQs7D,EAAKt7D,OAASo6D,EAAKp6D,OAAS87D,EAAe9wD,OACnD82B,MAAOw5B,EAAKx5B,MAAQs4B,EAAKt4B,MAAQg6B,EAAe9wD,UAGpD,CACEsvD,KAAM,EACNE,OAAQ,EACRx6D,OAAQ,EACR8hC,MAAO,GAGb,CAEA,SAAS64B,EAAeF,EAAsB3mB,GAC5C,OAAOhyC,KAAKiZ,KACVjZ,KAAKwS,IAAImmD,EAAO,GAAK3mB,EAAO,GAAI,GAAKhyC,KAAKwS,IAAImmD,EAAO,GAAK3mB,EAAO,GAAI,GAEzE,CAEA,SAAS8mB,EAAeH,EAAsB3mB,GAC5C,OAAOhyC,KAAKiZ,KACVjZ,KAAKwS,IAAImmD,EAAO,GAAK3mB,EAAO,GAAI,GAC9BhyC,KAAKwS,IAAImmD,EAAO,GAAK3mB,EAAO,GAAI,GAChChyC,KAAKwS,IAAImmD,EAAO,GAAK3mB,EAAO,GAAI,GAEtC,iOCrMA,QA5BO,SACLioB,GAEAA,EAAatqD,SAAS20B,IACpB,MAAMmzB,GAAY,IAAAC,cAAapzB,GAE/B,IAAKmzB,EAEH,YADAhnD,QAAQC,KAAK,+BAA+B4zB,KAIxBmzB,EAAUI,mBAElBloD,SAASuqD,IACrB,MAAM,kBAAEp3D,EAAiB,WAAEH,GAAeu3D,EAEpC5pD,GAAkB,IAAA8zB,oBAAmBthC,GAC3C,IAAKwN,EAEH,YADAG,QAAQC,KAAK,qCAAqC5N,KAIpD,MAAMD,EAAWyN,EAAgBE,YAAY7N,IAC7C,QAAwBE,EAAS1E,QAAQ,GACzC,GAEN,gIC9BA,MAAM,OAAEg8D,EAAM,QAAEC,EAAO,QAAEC,GAAY,EAAAC,UAUtB,SAASC,EACtB5f,EACApW,GAEA,MAAMi2B,EAAe7f,EAAUzxC,OAEzBuxD,EAA2B,GAEjC,IAAK,IAAIC,EAAK,EAAGA,EAAKF,EAAcE,IAAM,CACxC,MAAM73D,EAAW83C,EAAU+f,GAErBjD,EAAY,6BAChB50D,EAASD,GACTC,EAASC,mBAGX,IAAK20D,EACH,SAGckD,EACdlD,EACAlzB,IAIAk2B,EAAyBzqD,KAAKnN,EAElC,CAEA,OAAO43D,CACT,CAWA,SAASE,EACPlD,EACAlzB,GAEA,MAAM,YAAEq2B,GAAgBnD,EAClBE,EAAOiD,EAAYr2B,GAEzB,IAAKozB,EACH,OAAO,EAGT,MAAMkD,EAAWlD,EAAKmD,KAEtB,OAAOD,IAAaV,GAAUU,IAAaT,GAAWS,IAAaR,CACrE,2BC9CA,QAhBO,SACL1f,EACA7tC,EACAiuD,EAAM,MAEN,OAAOpgB,EAAU/tC,QAAQ/J,IACvB,MAAMm4D,EAAWn4D,EAASuL,YAM1B,OAHEpO,KAAK6uC,IAAI,SAASmsB,EAASxsD,gBAAiB1B,EAAO0B,kBACnDusD,CAEe,GAErB,ECPe,SAASj9B,EACtB3/B,EACAomC,EACA02B,GAAyB,GAEzB,MAAM/lD,GAAiB,IAAA6T,mBAAkB5qB,IACnC,gBAAEmS,EAAe,oBAAE+Y,GAAwBnU,EAGjD,IAAIylC,EAAYrqC,EAAgBoZ,eAEhCixB,EChBa,SACbA,EACAtxB,GAEA,MAAMmxC,EAAe7f,EAAUzxC,OACzBgyD,EAAmC,GAEzC,IAAK,IAAIR,EAAK,EAAGA,EAAKF,EAAcE,IAAM,CACxC,MAAM73D,EAAW83C,EAAU+f,GAE3BjqD,QAAQuX,IAAI,YAAY0yC,iBAAkB73D,EAASxC,4BAC/CwC,EAASxC,2BAA6BgpB,GACxC6xC,EAAiClrD,KAAKnN,EAE1C,CAEA,OAAOq4D,CACT,CDDcC,CACVxgB,EACAtxB,GAEFsxB,EAAY4f,EAA+B5f,EAAWpW,GAEtD,MAAM1hC,EAAWyN,EAAgBE,YAAY0E,EAAevS,YAExDs4D,IACFtgB,EAAY,EACVA,EACA93C,EAASuL,cAMb,OAFoBusC,EAAUh5C,KAAK+4D,GAAOA,EAAG93D,IAG/C,+FEtCA,SAASw4D,EACPv4D,EACAqhC,GAEA,GAAIrhC,aAAoB,EAAA2nC,mBAAoB,CAC1C,MAAM6wB,EAAiBn3B,EAASn2B,MAAM,aAChCqL,EACJiiD,EAAenyD,OAAS,EACpBmyD,EAAe,GAAGttD,MAAM,KAAK,GAC7BstD,EAAe,GACfh4C,EAAS,EAAAonB,MAAM7lB,UAAUxL,GAC/B,QAASiK,GAAQtG,SAAW9R,OAAOyU,KAAK2D,EAAOtG,SAAS7T,OAAS,CACnE,CAAO,GAAIrG,aAAoB,EAAAipC,cAAe,CAC5C,MAAM,SAAE/gC,GAAalI,EAASoH,gBAAkB,CAAC,EACjD,QAASc,GAAUC,MACrB,CACE,OAAO,CAEX,0GCbe,SAASswD,EACtBz4D,EACA04D,GAGA,KAAM14D,aAAoB,EAAA2sD,gBACxB,OAGF,MAAM,WAAEziD,GAAelK,EAASuL,YAE1B3F,EAAsB,CAAC,EAAG,EAAG,GAKnC,OAJA,SAASA,EAAO8yD,EAAWxuD,GAO7B,SAAqBlK,EAAU4F,GAC7B,MAAMqE,EAASjK,EAASuL,YAClBotD,EAAS1uD,EAAO0B,gBAEhBitD,EAAU,SAAShzD,EAAO+yD,GAC1BE,EAAiB,gBAAgBF,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAIpE,GAFA,WAAWE,EAAgBA,EAAgBD,GAGzCz7D,KAAK6uC,IAAI6sB,EAAe,IAAM,MAC9B17D,KAAK6uC,IAAI6sB,EAAe,IAAM,MAC9B17D,KAAK6uC,IAAI6sB,EAAe,IAAM,KAC9B,CACA,MAAM7L,EAA8B,CAAC,EAAG,EAAG,GACrCC,EAA4B,CAAC,EAAG,EAAG,GAEzC,SAASD,EAAe/iD,EAAOC,WAAY2uD,GAC3C,SAAS5L,EAAahjD,EAAOwB,SAAUotD,GAEvC74D,EAASgK,UAAU,CACjBE,WAAY8iD,EACZvhD,SAAUwhD,IAEZjtD,EAASL,QACX,CACF,CA/BEm5D,CAAY94D,EAAU4F,IAEf,CACT,0DClBA,MCEM,MAAEmzD,GAAU,EAAAjrB,mBCAK,IAA0BkrB,uDCAjD,MAAM,OAAEzhD,GAAW,EAAAw2B,uBCRnB,IAAYkrB,mBAAZ,SAAYA,GACV,YACA,cACA,kBACA,eACD,CALD,CAAYA,IAAAA,EAAyB,sPCQrC,SAASC,EAAuB3xD,EAAWyH,EAAG0E,EAAG5W,EAAOC,GACtD,MAAMo8D,EAAY,GAClB,IAAIrwD,EAAQ,EACZ,MAAMkc,EAAYzd,EAAUL,WAC5B,IAAIkyD,EAASC,EAAKC,EAElB,GAAI/xD,EAAUsL,MACZ,IAAKwmD,EAAM,EAAGA,EAAMt8D,EAAQs8D,IAC1B,IAAKC,EAAS,EAAGA,EAASx8D,EAAOw8D,IAAU,CACzCF,EAA2D,IAA/CC,EAAM3lD,GAAKnM,EAAUlF,SAAWi3D,EAAStqD,IACrD,MAAM4B,EAAMoU,EAAUo0C,GAChBtoD,EAAQkU,EAAUo0C,EAAU,GAC5BpoD,EAAOgU,EAAUo0C,EAAU,GAEjCD,EAAUrwD,KAAW,MAAS8H,EAAM,MAASE,EAAQ,MAASE,CAChE,MAGF,IAAKqoD,EAAM,EAAGA,EAAMt8D,EAAQs8D,IAC1B,IAAKC,EAAS,EAAGA,EAASx8D,EAAOw8D,IAC/BF,GAAWC,EAAM3lD,GAAKnM,EAAUlF,SAAWi3D,EAAStqD,GACpDmqD,EAAUrwD,KAAWkc,EAAUo0C,GAKrC,OAAOD,CACT,CCxCA,SAASI,EAAoBC,EAAgBC,EAAWC,GACtD,MAAMC,EAAYH,EAAenzD,OACjC,IAAIyN,EAAM4lD,EACNjwD,EAAMgwD,EACN1gB,EAAM,EAEV,GAAI4gB,EAAY,EACd,MAAO,CACL7lD,MACArK,MACAowC,MAAO4f,EAAYC,GAAa,GAIpC,IAAK,IAAI5wD,EAAQ,EAAGA,EAAQ6wD,EAAW7wD,IAAS,CAC9C,MAAM8wD,EAAMJ,EAAe1wD,GAE3BgL,EAAM3W,KAAK2W,IAAIA,EAAK8lD,GACpBnwD,EAAMtM,KAAKsM,IAAIA,EAAKmwD,GACpB7gB,GAAO6gB,CACT,CAEA,MAAO,CACL9lD,MACArK,MACAowC,KAAMd,EAAM4gB,EAEhB,gBCpBA,SAASE,EAAiC75D,GACxC,GAAIA,aAAoB,EAAA2sD,eACtB,OASJ,SAAgC3sD,GAC9B,MAAM,WAAEkH,EAAU,MAAEpK,EAAK,OAAEC,GACzB,0CAAsCiD,IAChC8T,IAAKyV,EAAe9f,IAAK+f,GAC/B,sBAAkBtiB,GACdqP,EAAWvW,EAAS85D,cACpBt5C,EAAS,EAAAonB,MAAM7lB,UAAUxL,IAEzB,SAAEhS,EAAQ,yBAAEw1D,GAA6Bv5C,GACvCw5C,KAAM53D,EAAM63D,QAAS53D,GAAYkC,GACnC,MAAEsO,GAAUknD,EAClB,MAAO,CACL7yD,aACApK,QACAC,SACAwsB,gBACAC,gBACApnB,OACAC,UACAwQ,QAEJ,CA9BWqnD,CAAuBl6D,GAEhC,GAAIA,aAAoB,EAAAipC,cACtB,OA6BJ,SAA+BjpC,GAC7B,MAAMuH,EAAYvH,EAASoH,gBACrB,WAAEF,GAAeK,GACfuM,IAAKyV,EAAe9f,IAAK+f,GAC/B,sBAAkBtiB,GACdpK,EAAQyK,EAAUpE,WAAW,GAC7BpG,EAASwK,EAAUpE,WAAW,IAC9B,KAAEf,EAAI,QAAEC,EAAO,MAAEwQ,GAAU7S,EAASm6D,sBAE1C,MAAO,CACLjzD,aACApK,QACAC,SACAwsB,gBACAC,gBACApnB,OACAC,UACAwQ,QAEJ,CAhDWunD,CAAsBp6D,GAG/B,MAAM,IAAIkE,MAAM,yBAClB,uBCdMm2D,kCAaN,SAbMA,EAAiC,oBAAbv5D,UAA4BA,SAASw5D,cAAgBx5D,SAASw5D,cAAc78D,SAAM+I,EAEnG,SACA+zD,GAGT,IAAkEC,EAAoBC,EAAlFC,OAA6B,KAF/BH,EAAgBA,GAAiB,CAAC,GAESA,EAAc,CAAC,EAA6CG,EAAc,MAAE,IAAI71D,SAAQ,SAASC,EAAQuxB,GAAQmkC,EAAoB11D,EAAQ21D,EAAmBpkC,CAAM,IAAG,IAAoXskC,EAAhXC,EAAgBxyD,OAAOyS,OAAO,CAAC,EAAE6/C,GAAYG,EAAW,GAAOC,EAAY,iBAAqBC,EAAM,CAACC,EAAOC,KAAW,MAAMA,GAAyEC,EAAgB,GAAsT,oBAAVp6D,UAAuBA,SAASw5D,gBAAeY,EAAgBp6D,SAASw5D,cAAc78D,KAAO48D,IAAYa,EAAgBb,GAAoDa,EAAH,IAAnCA,EAAgBnyD,QAAQ,SAA8BmyD,EAAgBC,OAAO,EAAED,EAAgB51D,QAAQ,SAAS,IAAI81D,YAAY,KAAK,GAAwB,GAAilB,IAAoVC,EAAhVC,EAAIZ,EAAc,OAAG9sD,QAAQuX,IAAIo2C,KAAK3tD,SAAa+Z,EAAI+yC,EAAiB,UAAG9sD,QAAQC,KAAK0tD,KAAK3tD,SAASxF,OAAOyS,OAAO6/C,EAAOE,GAAiBA,EAAgB,KAAQF,EAAkB,YAAEG,EAAWH,EAAkB,WAAKA,EAAoB,cAAEI,EAAYJ,EAAoB,aAAKA,EAAa,OAAEK,EAAML,EAAa,MAAuCA,EAAmB,aAAEW,EAAWX,EAAmB,YAAE,IAA8Hc,EAA1HC,EAAcf,EAAsB,gBAAG,EAA4B,iBAAbgB,aAAuBC,EAAM,mCAAkD,IAAoBC,EAAg6DjiD,EAAOkiD,EAAMC,EAAOC,EAAOC,EAAQC,EAAOC,EAAQC,EAAQC,EAA1+DC,GAAM,EAAyBC,EAAgC,oBAAbC,YAAyB,IAAIA,YAAY,aAAQ/1D,EAAU,SAASg2D,EAAkBC,EAAY/iB,EAAIgjB,GAA6D,IAA7C,IAAIC,EAAOjjB,EAAIgjB,EAAmBE,EAAOljB,EAAU+iB,EAAYG,MAAWA,GAAQD,MAAUC,EAAO,GAAGA,EAAOljB,EAAI,IAAI+iB,EAAY9iD,QAAQ2iD,EAAa,OAAOA,EAAYO,OAAOJ,EAAYK,SAASpjB,EAAIkjB,IAAoB,IAAX,IAAIG,EAAI,GAASrjB,EAAIkjB,GAAO,CAAC,IAAII,EAAGP,EAAY/iB,KAAO,GAAQ,IAAHsjB,EAAL,CAAoD,IAAIC,EAAsB,GAAnBR,EAAY/iB,KAAU,GAAa,MAAN,IAAHsjB,GAAJ,CAAmE,IAAIE,EAAsB,GAAnBT,EAAY/iB,KAA0G,IAA9EsjB,EAAL,MAAN,IAAHA,IAAqB,GAAHA,IAAQ,GAAGC,GAAI,EAAEC,GAAe,EAAHF,IAAO,GAAGC,GAAI,GAAGC,GAAI,EAAqB,GAAnBT,EAAY/iB,MAAgB,MAAOqjB,GAAK3wB,OAAO+wB,aAAaH,OAAQ,CAAC,IAAII,EAAGJ,EAAG,MAAMD,GAAK3wB,OAAO+wB,aAAa,MAAMC,GAAI,GAAG,MAAS,KAAHA,EAAQ,CAAjP,MAAhDL,GAAK3wB,OAAO+wB,cAAiB,GAAHH,IAAQ,EAAEC,EAApF,MAArCF,GAAK3wB,OAAO+wB,aAAaH,EAA8V,CAAC,OAAOD,CAAG,CAAC,SAASM,EAAaC,EAAIZ,GAAgB,OAAOY,EAAId,EAAkBV,EAAOwB,EAAIZ,GAAgB,EAAE,CAAC,SAASa,EAAkBR,EAAIS,EAAKC,EAAOC,GAAiB,KAAKA,EAAgB,GAAG,OAAO,EAA0D,IAAxD,IAAIC,EAASF,EAAWd,EAAOc,EAAOC,EAAgB,EAAUn4D,EAAE,EAAEA,EAAEw3D,EAAI12D,SAASd,EAAE,CAAC,IAAIq4D,EAAEb,EAAIc,WAAWt4D,GAAoF,GAA9Eq4D,GAAG,OAAOA,GAAG,QAAkCA,EAAE,QAAU,KAAFA,IAAS,IAAO,KAA9Cb,EAAIc,aAAat4D,IAAqCq4D,GAAG,IAAI,CAAC,GAAGH,GAAQd,EAAO,MAAMa,EAAKC,KAAUG,CAAC,MAAM,GAAGA,GAAG,KAAK,CAAC,GAAGH,EAAO,GAAGd,EAAO,MAAMa,EAAKC,KAAU,IAAIG,GAAG,EAAEJ,EAAKC,KAAU,IAAM,GAAFG,CAAI,MAAM,GAAGA,GAAG,MAAM,CAAC,GAAGH,EAAO,GAAGd,EAAO,MAAMa,EAAKC,KAAU,IAAIG,GAAG,GAAGJ,EAAKC,KAAU,IAAIG,GAAG,EAAE,GAAGJ,EAAKC,KAAU,IAAM,GAAFG,CAAI,KAAK,CAAC,GAAGH,EAAO,GAAGd,EAAO,MAAMa,EAAKC,KAAU,IAAIG,GAAG,GAAGJ,EAAKC,KAAU,IAAIG,GAAG,GAAG,GAAGJ,EAAKC,KAAU,IAAIG,GAAG,EAAE,GAAGJ,EAAKC,KAAU,IAAM,GAAFG,CAAI,CAAC,CAAgB,OAAfJ,EAAKC,GAAQ,EAASA,EAAOE,CAAQ,CAA+G,SAASG,EAAgBf,GAAe,IAAV,IAAI/sD,EAAI,EAAUzK,EAAE,EAAEA,EAAEw3D,EAAI12D,SAASd,EAAE,CAAC,IAAIoE,EAAEozD,EAAIc,WAAWt4D,GAAMoE,GAAG,IAAKqG,IAAcrG,GAAG,KAAMqG,GAAK,EAAUrG,GAAG,OAAOA,GAAG,OAAOqG,GAAK,IAAIzK,GAAOyK,GAAK,CAAE,CAAC,OAAOA,CAAG,CAAuE,SAAS+tD,EAA2BC,GAAKrkD,EAAOqkD,EAAItD,EAAc,MAAEmB,EAAM,IAAIoC,UAAUD,GAAKtD,EAAe,OAAEqB,EAAO,IAAIjyC,WAAWk0C,GAAKtD,EAAe,OAAEuB,EAAO,IAAIiC,WAAWF,GAAKtD,EAAe,OAAEoB,EAAO,IAAInyC,WAAWq0C,GAAKtD,EAAgB,QAAEsB,EAAQ,IAAInyC,YAAYm0C,GAAKtD,EAAgB,QAAEwB,EAAQ,IAAIiC,YAAYH,GAAKtD,EAAgB,QAAEyB,EAAQ,IAAIvyC,aAAao0C,GAAKtD,EAAgB,QAAE0B,EAAQ,IAAIgC,aAAaJ,EAAI,CAAoBtD,EAAuB,eAA1C,IAA0D2D,EAAszDC,EAA/6LC,EAAuoIC,EAAa,GAAOC,EAAW,GAAOC,EAAW,GAAOC,EAAc,GAA4yBC,EAAgB,EAAMC,EAAqB,KAASC,EAAsB,KAAif,SAASnD,EAAMoD,GAASrE,EAAgB,SAAGA,EAAgB,QAAEqE,GAA+Bp3C,EAAzBo3C,EAAK,WAAWA,EAAK,KAAc1C,GAAM,EAAKT,EAAW,EAAEmD,GAAM,2CAA2C,IAAIr5D,EAAE,IAAIg2D,YAAYsD,aAAaD,GAA4B,MAAtBtE,EAAmB/0D,GAASA,CAAC,CAA2D,SAASu5D,EAAUC,GAAU,OAAOA,EAAS1iD,WAArF,wCAA8G,CAA8H,SAAS2iD,EAAUC,GAAM,IAAI,GAAGA,GAAMd,GAAgBjD,EAAY,OAAO,IAAI1xC,WAAW0xC,GAAY,GAAGV,EAAY,OAAOA,EAAWyE,GAAM,KAAK,iDAAiD,CAAC,MAAMz3C,GAAKg0C,EAAMh0C,EAAI,CAAC,CAA7Rs3C,EAArCX,EAAe,qBAA78LC,EAAwhMD,EAA1BA,EAAr/L5D,EAAmB,WAAUA,EAAmB,WAAE6D,EAAKrD,GAAwBA,EAAgBqD,GAAimQ,IAAIc,EAAW,CAAC,OAAOC,IAAQ5E,EAAO6E,gBAAgB7E,EAAO6E,eAAeD,EAAG,GAAI,SAASE,EAAWxE,GAAQz+D,KAAKiU,KAAK,aAAajU,KAAKkjE,QAAQ,gCAAgCzE,EAAO,IAAIz+D,KAAKy+D,OAAOA,CAAM,CAAC,SAAS0E,EAAqBtpC,GAAW,KAAMA,EAAU/vB,OAAO,GAAG+vB,EAAUjiB,OAAViiB,CAAkBskC,EAAQ,CAAC,SAASiF,EAAcC,GAAQrjE,KAAKqjE,OAAOA,EAAOrjE,KAAK+gE,IAAIsC,EAAO,GAAGrjE,KAAKsjE,SAAS,SAAS3mD,GAAMgjD,EAAQ3/D,KAAK+gE,IAAI,GAAG,GAAGpkD,CAAI,EAAE3c,KAAKujE,SAAS,WAAW,OAAO5D,EAAQ3/D,KAAK+gE,IAAI,GAAG,EAAE,EAAE/gE,KAAKwjE,eAAe,SAASC,GAAY9D,EAAQ3/D,KAAK+gE,IAAI,GAAG,GAAG0C,CAAU,EAAEzjE,KAAK0jE,eAAe,WAAW,OAAO/D,EAAQ3/D,KAAK+gE,IAAI,GAAG,EAAE,EAAE/gE,KAAK2jE,aAAa,SAASC,GAAUlE,EAAO1/D,KAAK+gE,KAAK,GAAG6C,CAAQ,EAAE5jE,KAAK6jE,WAAW,SAASC,GAAQA,EAAOA,EAAO,EAAE,EAAExE,EAAMt/D,KAAK+gE,IAAI,GAAI,GAAG+C,CAAM,EAAE9jE,KAAK+jE,WAAW,WAAW,OAA8B,GAAvBzE,EAAMt/D,KAAK+gE,IAAI,GAAI,EAAK,EAAE/gE,KAAKgkE,aAAa,SAASC,GAAUA,EAASA,EAAS,EAAE,EAAE3E,EAAMt/D,KAAK+gE,IAAI,GAAI,GAAGkD,CAAQ,EAAEjkE,KAAKkkE,aAAa,WAAW,OAA8B,GAAvB5E,EAAMt/D,KAAK+gE,IAAI,GAAI,EAAK,EAAE/gE,KAAKmkE,KAAK,SAASxnD,EAAK8mD,GAAYzjE,KAAKokE,iBAAiB,GAAGpkE,KAAKsjE,SAAS3mD,GAAM3c,KAAKwjE,eAAeC,GAAYzjE,KAAK2jE,aAAa,GAAG3jE,KAAK6jE,YAAW,GAAO7jE,KAAKgkE,cAAa,EAAM,EAAEhkE,KAAKqkE,QAAQ,WAAW,IAAI/kD,EAAMogD,EAAO1/D,KAAK+gE,KAAK,GAAGrB,EAAO1/D,KAAK+gE,KAAK,GAAGzhD,EAAM,CAAC,EAAEtf,KAAKskE,YAAY,WAAW,IAAIlK,EAAKsF,EAAO1/D,KAAK+gE,KAAK,GAA8B,OAA3BrB,EAAO1/D,KAAK+gE,KAAK,GAAG3G,EAAK,EAAgB,IAAPA,CAAQ,EAAEp6D,KAAKokE,iBAAiB,SAASG,GAAa5E,EAAQ3/D,KAAK+gE,IAAI,IAAI,GAAGwD,CAAW,EAAEvkE,KAAKwkE,iBAAiB,WAAW,OAAO7E,EAAQ3/D,KAAK+gE,IAAI,IAAI,EAAE,EAAE/gE,KAAKykE,kBAAkB,WAAiE,GAAxCC,GAAuB1kE,KAAKujE,YAA0B,OAAO5D,EAAQ3/D,KAAKqjE,QAAQ,GAAG,IAAIsB,EAAS3kE,KAAKwkE,mBAAmB,OAAc,IAAXG,EAAoBA,EAAgB3kE,KAAKqjE,MAAM,CAAC,CAA6M,IAAIuB,EAAS,CAACC,aAAQ56D,EAAU8B,IAAI,WAAqE,OAA1D64D,EAASC,SAAS,EAAUnF,EAAOkF,EAASC,QAAQ,GAAG,EAAa,EAAEC,OAAO,SAAS/D,GAA+B,OAAlBD,EAAaC,EAAe,GAAwQgE,EAAoB,CAAC,EAAE,SAASC,EAAeC,GAAa,KAAMA,EAAYn7D,QAAO,CAAC,IAAIi3D,EAAIkE,EAAYj3C,MAAci3C,EAAYj3C,KAAMk3C,CAAInE,EAAI,CAAC,CAAC,SAASoE,EAA2BC,GAAS,OAAOplE,KAAmB,aAAE0/D,EAAO0F,GAAS,GAAG,CAAC,IAAIC,GAAqB,CAAC,EAAMC,GAAgB,CAAC,EAAMC,GAAiB,CAAC,EAA8B,SAASC,GAAsBvxD,GAAM,QAAGhK,IAAYgK,EAAM,MAAM,WAAmD,IAAIwxD,GAA5CxxD,EAAKA,EAAKlL,QAAQ,iBAAiB,MAAgBu4D,WAAW,GAAG,OAAGmE,GAAhK,IAA2KA,GAA7J,GAA8K,IAAIxxD,EAAYA,CAAI,CAAC,SAASyxD,GAAoBzxD,EAAK0xD,GAAuC,OAAjC1xD,EAAKuxD,GAAsBvxD,GAAa,IAAI2xD,SAAS,OAAO,mBAAmB3xD,EAAnB,uEAApB,CAA6H0xD,EAAK,CAAC,SAASE,GAAYC,EAAcC,GAAW,IAAIC,EAAWN,GAAoBK,GAAU,SAAS7C,GAASljE,KAAKiU,KAAK8xD,EAAU/lE,KAAKkjE,QAAQA,EAAQ,IAAI7O,EAAM,IAAI1sD,MAAMu7D,GAAS7O,WAAiBpqD,IAARoqD,IAAmBr0D,KAAKq0D,MAAMr0D,KAAKg0D,WAAW,KAAKK,EAAMtrD,QAAQ,qBAAqB,IAAI,IAA4O,OAAzOi9D,EAAWlmD,UAAUjU,OAAOuT,OAAO0mD,EAAchmD,WAAWkmD,EAAWlmD,UAAUnhB,YAAYqnE,EAAWA,EAAWlmD,UAAUk0C,SAAS,WAAW,YAAkB/pD,IAAfjK,KAAKkjE,QAA4BljE,KAAKiU,KAAiBjU,KAAKiU,KAAK,KAAKjU,KAAKkjE,OAAQ,EAAS8C,CAAU,CAAC,IAAIC,QAAch8D,EAAU,SAASi8D,GAAmBhD,GAAS,MAAM,IAAI+C,GAAc/C,EAAQ,CAAC,SAASiD,GAA8BC,EAAQC,EAAeC,GAA0F,SAASC,EAAWC,GAAgB,IAAIC,EAAiBH,EAAkBE,GAAmBC,EAAiB38D,SAASs8D,EAAQt8D,QAAQo8D,GAAmB,mCAAmC,IAAI,IAAIl9D,EAAE,EAAEA,EAAEo9D,EAAQt8D,SAASd,EAAG09D,GAAaN,EAAQp9D,GAAGy9D,EAAiBz9D,GAAI,CAApVo9D,EAAQ71D,SAAQ,SAASoM,GAAM4oD,GAAiB5oD,GAAM0pD,CAAc,IAAiR,IAAIG,EAAe,IAAIl/D,MAAM++D,EAAev8D,QAAY68D,EAAkB,GAAOC,EAAW,EAAEP,EAAe91D,SAAQ,CAACs2D,EAAG79D,KAAQs8D,GAAgBvlD,eAAe8mD,GAAKL,EAAex9D,GAAGs8D,GAAgBuB,IAASF,EAAkB/1D,KAAKi2D,GAAQxB,GAAqBtlD,eAAe8mD,KAAKxB,GAAqBwB,GAAI,IAAGxB,GAAqBwB,GAAIj2D,MAAK,KAAK41D,EAAex9D,GAAGs8D,GAAgBuB,KAAMD,IAA2BD,EAAkB78D,QAAQy8D,EAAWC,EAAe,IAAG,IAAO,IAAIG,EAAkB78D,QAAQy8D,EAAWC,EAAgB,CAA+iD,SAASM,GAAiBx+C,GAAM,OAAOA,GAAM,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,MAAM,IAAImuB,UAAU,sBAAsBnuB,GAAM,CAAyI,IAAIy+C,QAAiB98D,EAAU,SAAS+8D,GAAiBjG,GAA0B,IAArB,IAAIkG,EAAI,GAAO75D,EAAE2zD,EAAUxB,EAAOnyD,IAAI65D,GAAKF,GAAiBxH,EAAOnyD,MAAM,OAAO65D,CAAG,CAAC,IAAIC,QAAaj9D,EAAU,SAASk9D,GAAkBjE,GAAS,MAAM,IAAIgE,GAAahE,EAAQ,CAAC,SAASwD,GAAaU,EAAQC,EAAmBpgE,EAAQ,CAAC,GAAG,KAAK,mBAAmBogE,GAAqB,MAAM,IAAI5wB,UAAU,2DAA2D,IAAIxiC,EAAKozD,EAAmBpzD,KAAmG,GAA1FmzD,GAASD,GAAkB,SAASlzD,EAAK,iDAAoDqxD,GAAgBvlD,eAAeqnD,GAAS,CAAC,GAAGngE,EAAQqgE,6BAA8B,OAAYH,GAAkB,yBAAyBlzD,EAAK,UAAW,CAA8E,GAA7EqxD,GAAgB8B,GAASC,SAA0B9B,GAAiB6B,GAAY/B,GAAqBtlD,eAAeqnD,GAAS,CAAC,IAAIvtC,EAAUwrC,GAAqB+B,UAAgB/B,GAAqB+B,GAASvtC,EAAUtpB,SAAQypB,GAAIA,KAAK,CAAC,CAAqjB,IAAIutC,GAAgB,GAAOC,GAAmB,CAAC,CAAC,EAAE,CAACloD,WAAMrV,GAAW,CAACqV,MAAM,MAAM,CAACA,OAAM,GAAM,CAACA,OAAM,IAAQ,SAASmoD,GAAevoC,GAAWA,EAAO,GAAG,KAAMsoC,GAAmBtoC,GAAQ0kC,WAAU4D,GAAmBtoC,QAAQj1B,EAAUs9D,GAAgB32D,KAAKsuB,GAAQ,CAAC,SAASwoC,KAAkC,IAAZ,IAAIjrB,EAAM,EAAUzzC,EAAE,EAAEA,EAAEw+D,GAAmB19D,SAASd,OAA8BiB,IAAxBu9D,GAAmBx+D,MAAkByzC,EAAO,OAAOA,CAAK,CAAC,SAASkrB,KAAkB,IAAI,IAAI3+D,EAAE,EAAEA,EAAEw+D,GAAmB19D,SAASd,EAAG,QAA2BiB,IAAxBu9D,GAAmBx+D,GAAgB,OAAOw+D,GAAmBx+D,GAAI,OAAO,IAAI,CAAmH,IAAI4+D,GAAe1oC,IAAaA,GAAQioC,GAAkB,oCAAoCjoC,GAAesoC,GAAmBtoC,GAAQ5f,OAApIsoD,GAAoJtoD,IAAQ,OAAOA,GAAO,UAAKrV,EAAU,OAAO,EAAE,KAAK,KAAK,OAAO,EAAE,KAAK,EAAK,OAAO,EAAE,KAAK,EAAM,OAAO,EAAE,QAAS,IAAIi1B,EAAOqoC,GAAgBz9D,OAAOy9D,GAAgBv5C,MAAMw5C,GAAmB19D,OAA2D,OAApD09D,GAAmBtoC,GAAQ,CAAC0kC,SAAS,EAAEtkD,MAAMA,GAAc4f,EAAO,EAAoX,SAAS2oC,GAA0B5zD,EAAK2D,GAAO,OAAOA,GAAO,KAAK,EAAE,OAAO,SAASwtD,GAAS,OAAOplE,KAAmB,aAAE4/D,EAAQwF,GAAS,GAAG,EAAE,KAAK,EAAE,OAAO,SAASA,GAAS,OAAOplE,KAAmB,aAAE6/D,EAAQuF,GAAS,GAAG,EAAE,QAAQ,MAAM,IAAI3uB,UAAU,uBAAuBxiC,GAAM,CAAgW,SAAS6zD,GAAKnpE,EAAYopE,GAAc,KAAKppE,aAAuBinE,UAAW,MAAM,IAAInvB,UAAU,4CAA4C93C,EAAY,4BAA4B,IAAIqpE,EAAMtC,GAAoB/mE,EAAYsV,MAAM,uBAAsB,WAAW,IAAG+zD,EAAMloD,UAAUnhB,EAAYmhB,UAAU,IAAImoD,EAAI,IAAID,EAAU7jB,EAAExlD,EAAYi4C,MAAMqxB,EAAIF,GAAc,OAAO5jB,aAAat4C,OAAOs4C,EAAE8jB,CAAG,CAAm1F,SAASC,GAAmBj0D,EAAKqL,EAAM6oD,GAAiBhK,EAAOp+C,eAAe9L,UAAUhK,IAAYk+D,QAAcl+D,IAAYk0D,EAAOlqD,GAAMm0D,oBAAen+D,IAAYk0D,EAAOlqD,GAAMm0D,cAAcD,KAAehB,GAAkB,gCAAgClzD,EAAK,WAA10B,SAA6Bo0D,EAAM1uC,EAAW2uC,GAAW,QAAGr+D,IAAYo+D,EAAM1uC,GAAYyuC,cAAc,CAAC,IAAIG,EAASF,EAAM1uC,GAAY0uC,EAAM1uC,GAAY,WAAyP,OAA1O0uC,EAAM1uC,GAAYyuC,cAAcroD,eAAeyoD,UAAU1+D,SAASq9D,GAAkB,aAAamB,EAAU,iDAAiDE,UAAU1+D,OAAO,uBAAuBu+D,EAAM1uC,GAAYyuC,cAAc,MAAaC,EAAM1uC,GAAYyuC,cAAcI,UAAU1+D,QAAQ8sC,MAAM52C,KAAKwoE,UAAU,EAAEH,EAAM1uC,GAAYyuC,cAAc,GAAGC,EAAM1uC,GAAYyuC,cAAcG,EAASE,UAAUF,CAAQ,CAAC,CAAmRG,CAAoBvK,EAAOlqD,EAAKA,GAASkqD,EAAOp+C,eAAeooD,IAAehB,GAAkB,uFAAuFgB,EAAa,MAAMhK,EAAOlqD,GAAMm0D,cAAcD,GAAc7oD,IAAW6+C,EAAOlqD,GAAMqL,OAASrV,IAAYk+D,IAAchK,EAAOlqD,GAAMk0D,aAAaA,GAAc,CAA4lB,IAAIQ,GAAgB,GAAG,SAASC,GAAkBC,GAAS,IAAIhzB,EAAK8yB,GAAgBE,GAA4I,OAA/HhzB,IAASgzB,GAASF,GAAgB7+D,SAAO6+D,GAAgB7+D,OAAO++D,EAAQ,GAAEF,GAAgBE,GAAShzB,EAAKisB,EAAU/1D,IAAI88D,IAAgBhzB,CAAI,CAAC,SAASizB,GAAQC,EAAIhI,EAAInnC,GAAM,OAAGmvC,EAAI7hD,SAAS,KAAxa,SAAuB6hD,EAAIhI,EAAInnC,GAAM,IAAI6rC,EAAEtH,EAAO,WAAW4K,GAAK,OAAOnvC,GAAMA,EAAK9vB,OAAO27D,EAAE7uB,MAAM,KAAK,CAACmqB,GAAK7qC,OAAO0D,IAAO6rC,EAAEzlD,KAAK,KAAK+gD,EAAI,CAAySiI,CAAcD,EAAIhI,EAAInnC,GAAcgvC,GAAkB7H,GAAKnqB,MAAM,KAAKhd,EAAgB,CAAwJ,SAASqvC,GAAwBC,EAAUC,GAAyL,IAArWJ,EAAIhI,EAASqI,EAA4VC,GAAhLH,EAAUlC,GAAiBkC,IAAiDhiD,SAAS,MAA9Q6hD,EAAwSG,EAApSnI,EAA8SoI,EAArSC,EAAS,GAAU,WAA+D,OAApDA,EAASt/D,OAAO,EAAE+B,OAAOyS,OAAO8qD,EAASZ,WAAkBM,GAAQC,EAAIhI,EAAIqI,EAAS,GAAuMR,GAAkBO,GAAuJ,MAArG,mBAAJE,GAAgBlC,GAAkB,2CAA2C+B,EAAU,KAAKC,GAAoBE,CAAE,CAAC,IAAIC,QAAiBr/D,EAAU,SAASs/D,GAAY5sD,GAAM,IAAIokD,EAAIyI,GAAe7sD,GAAU8sD,EAAGzC,GAAiBjG,GAAgB,OAAX2I,GAAM3I,GAAY0I,CAAE,CAAy8B,SAASE,GAA4B11D,EAAK2D,EAAMgyD,GAAQ,OAAOhyD,GAAO,KAAK,EAAE,OAAOgyD,EAAO,SAA2BxE,GAAS,OAAO9F,EAAM8F,EAAQ,EAAE,SAA2BA,GAAS,OAAO7F,EAAO6F,EAAQ,EAAE,KAAK,EAAE,OAAOwE,EAAO,SAA4BxE,GAAS,OAAO5F,EAAO4F,GAAS,EAAE,EAAE,SAA4BA,GAAS,OAAO3F,EAAQ2F,GAAS,EAAE,EAAE,KAAK,EAAE,OAAOwE,EAAO,SAA4BxE,GAAS,OAAO1F,EAAO0F,GAAS,EAAE,EAAE,SAA4BA,GAAS,OAAOzF,EAAQyF,GAAS,EAAE,EAAE,QAAQ,MAAM,IAAI3uB,UAAU,yBAAyBxiC,GAAM,CAA2jG,IAAI41D,GAAiC,oBAAb7J,YAAyB,IAAIA,YAAY,iBAAY/1D,EAAU,SAAS6/D,GAAc/I,EAAIZ,GAAiF,IAAjE,IAAIE,EAAOU,EAAQ5jB,EAAIkjB,GAAQ,EAAM0J,EAAO5sB,EAAIgjB,EAAe,IAAUhjB,GAAK4sB,IAAStK,EAAQtiB,MAAOA,EAAkB,IAAdkjB,EAAOljB,GAAK,GAAY4jB,EAAI,IAAI8I,GAAa,OAAOA,GAAavJ,OAAOf,EAAOgB,SAASQ,EAAIV,IAAoB,IAAX,IAAIG,EAAI,GAAWx3D,EAAE,IAAIA,GAAGm3D,EAAe,KAAKn3D,EAAE,CAAC,IAAIghE,EAASxK,EAAOuB,EAAM,EAAF/3D,GAAK,GAAG,GAAa,GAAVghE,EAAY,MAAMxJ,GAAK3wB,OAAO+wB,aAAaoJ,EAAS,CAAC,OAAOxJ,CAAG,CAAC,SAASyJ,GAAczJ,EAAI0J,EAAO/I,GAA4E,QAAtCl3D,IAAlBk3D,IAA6BA,EAAgB,YAAcA,EAAgB,EAAE,OAAO,EAAuH,IAAlG,IAAIgJ,EAASD,EAAWE,GAA3CjJ,GAAiB,GAAqE,EAAXX,EAAI12D,OAASq3D,EAAgB,EAAEX,EAAI12D,OAAed,EAAE,EAAEA,EAAEohE,IAAkBphE,EAAE,CAAC,IAAIghE,EAASxJ,EAAIc,WAAWt4D,GAAGw2D,EAAO0K,GAAQ,GAAGF,EAASE,GAAQ,CAAC,CAAqB,OAApB1K,EAAO0K,GAAQ,GAAG,EAASA,EAAOC,CAAQ,CAAC,SAASE,GAAiB7J,GAAK,OAAkB,EAAXA,EAAI12D,MAAQ,CAAC,SAASwgE,GAAcvJ,EAAIZ,GAAmC,IAAnB,IAAIn3D,EAAE,EAAMw3D,EAAI,KAAWx3D,GAAGm3D,EAAe,IAAG,CAAC,IAAIoK,EAAM7K,EAAOqB,EAAM,EAAF/3D,GAAK,GAAG,GAAU,GAAPuhE,EAAS,MAAU,KAAFvhE,EAAKuhE,GAAO,MAAM,CAAC,IAAI1J,EAAG0J,EAAM,MAAM/J,GAAK3wB,OAAO+wB,aAAa,MAAMC,GAAI,GAAG,MAAS,KAAHA,EAAQ,MAAML,GAAK3wB,OAAO+wB,aAAa2J,EAAO,CAAC,OAAO/J,CAAG,CAAC,SAASgK,GAAchK,EAAI0J,EAAO/I,GAA4E,QAAtCl3D,IAAlBk3D,IAA6BA,EAAgB,YAAcA,EAAgB,EAAE,OAAO,EAA4D,IAA1D,IAAIgJ,EAASD,EAAW7J,EAAO8J,EAAShJ,EAAgB,EAAUn4D,EAAE,EAAEA,EAAEw3D,EAAI12D,SAASd,EAAE,CAAC,IAAIghE,EAASxJ,EAAIc,WAAWt4D,GAA6K,GAAvKghE,GAAU,OAAOA,GAAU,QAA8CA,EAAS,QAAiB,KAATA,IAAgB,IAAmB,KAAxExJ,EAAIc,aAAat4D,IAA4D02D,EAAOwK,GAAQ,GAAGF,GAASE,GAAQ,GAAY,EAAE7J,EAAO,KAAK,CAAqB,OAApBX,EAAOwK,GAAQ,GAAG,EAASA,EAAOC,CAAQ,CAAC,SAASM,GAAiBjK,GAAe,IAAV,IAAI/sD,EAAI,EAAUzK,EAAE,EAAEA,EAAEw3D,EAAI12D,SAASd,EAAE,CAAC,IAAIghE,EAASxJ,EAAIc,WAAWt4D,GAAMghE,GAAU,OAAOA,GAAU,SAAQhhE,EAAEyK,GAAK,CAAC,CAAC,OAAOA,CAAG,CAA46E,SAASi3D,GAAsBtD,EAAQkB,GAAW,IAAIqC,EAAKrF,GAAgB8B,GAAqG,YAAzFn9D,IAAY0gE,GAAMxD,GAAkBmB,EAAU,qBAAqBiB,GAAYnC,IAAiBuD,CAAI,CAAqR,IAAIC,GAAc,CAAC,EAAE,SAASC,GAAkBC,GAAS,IAAIC,EAAOH,GAAcE,GAAS,YAAY7gE,IAAT8gE,EAA2B/D,GAAiB8D,GAAgBC,CAAM,CAAC,IAAIC,GAAoB,GAAiN,SAASC,KAAmB,MAAsB,iBAAZC,WAA6BA,WAAoCtF,SAAY,cAA9B,EAA8C,CAA6d,IAAIuF,GAAwB,GAAgwEC,GAAa,CAAC,EAA6mBC,GAAmB,GAA4N,SAASC,GAAiBC,EAAKC,EAAOC,GAAQ,IAAI7xC,EAA3Q,SAAuB4xC,EAAO/J,GAAiC,IAAIZ,EAAW,IAA3CwK,GAAmBvhE,OAAO,EAAS23D,IAAM,EAAQZ,EAAGtB,EAAOiM,MAAW/J,GAAS,KAAJZ,EAAQY,EAAI4J,GAAmBz6D,KAAS,KAAJiwD,EAAQnB,EAAO+B,GAAK5B,EAAQ4B,KAAO,MAAMA,EAAI,OAAO4J,EAAkB,CAAwDK,CAAcF,EAAOC,GAAQ,OAAO3I,EAAWyI,GAAM30B,MAAM,KAAKhd,EAAK,CAAsR,SAAS+xC,GAA0BrjD,GAAM,IAAqG,OAAjG22C,EAAW2M,KAAKtjD,EAAKlL,EAAOrB,WAAW,QAAQ,IAAIylD,EAA2BvC,EAAW7hD,QAAe,CAAC,CAAC,MAAMjU,GAAG,CAAC,CAAkkB,IAAI0iE,GAAI,CAAC,EAAoE,SAASC,KAAgB,IAAIA,GAAcC,QAAQ,CAAC,IAAsHC,EAAI,CAAC,KAAO,WAAW,QAAU,WAAW,KAAO,IAAI,IAAM,IAAI,KAAO,iBAAiB,MAAnL,iBAAXC,WAAqBA,UAAUC,WAAWD,UAAUC,UAAU,IAAI,KAAKnjE,QAAQ,IAAI,KAAK,SAAkH,EAA7Sw1D,GAAa,kBAAyT,IAAI,IAAI9rD,KAAKo5D,QAAiB5hE,IAAT4hE,GAAIp5D,UAAsBu5D,EAAIv5D,GAAQu5D,EAAIv5D,GAAGo5D,GAAIp5D,GAAG,IAAIs5D,EAAQ,GAAG,IAAI,IAAIt5D,KAAKu5D,EAAKD,EAAQn7D,KAAK6B,EAAE,IAAIu5D,EAAIv5D,IAAIq5D,GAAcC,QAAQA,CAAO,CAAC,OAAOD,GAAcC,OAAO,CAAoxB,IAAII,GAAiB,CAAC,KAAK,GAAG,IAAI,SAASC,GAAUC,EAAOnT,GAAM,IAAI97C,EAAO+uD,GAAiBE,GAAkB,IAAPnT,GAAiB,KAAPA,IAAqB,IAATmT,EAAWtN,EAAI3zC,GAAK60C,EAAkB7iD,EAAO,IAAIA,EAAOtT,OAAO,GAAOsT,EAAOxM,KAAKsoD,EAAM,CAA+N,SAASoT,GAAaC,GAAM,OAAOA,EAAK,GAAI,IAAIA,EAAK,KAAM,GAAGA,EAAK,KAAM,EAAE,CAA8F,IAAIC,GAAkB,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAQC,GAAqB,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAA43B,SAASC,GAAUC,EAAEC,EAAQC,EAAOC,GAAI,IAAIC,EAAQrN,EAAOoN,EAAG,IAAI,GAAOE,EAAK,CAACC,OAAOvN,EAAOoN,GAAI,GAAGI,OAAOxN,EAAOoN,EAAG,GAAG,GAAGK,QAAQzN,EAAOoN,EAAG,GAAG,GAAGM,QAAQ1N,EAAOoN,EAAG,IAAI,GAAGO,OAAO3N,EAAOoN,EAAG,IAAI,GAAGQ,QAAQ5N,EAAOoN,EAAG,IAAI,GAAGS,QAAQ7N,EAAOoN,EAAG,IAAI,GAAGU,QAAQ9N,EAAOoN,EAAG,IAAI,GAAGW,SAAS/N,EAAOoN,EAAG,IAAI,GAAGY,UAAUhO,EAAOoN,EAAG,IAAI,GAAGC,QAAQA,EAAQjM,EAAaiM,GAAS,IAAQY,EAAQ7M,EAAa+L,GAAYe,EAAkB,CAAC,KAAK,uBAAuB,KAAK,WAAW,KAAK,WAAW,KAAK,KAAK,KAAK,cAAc,KAAK,QAAQ,KAAK,WAAW,KAAK,WAAW,KAAK,WAAW,MAAM,KAAK,MAAM,KAAK,MAAM,WAAW,MAAM,WAAW,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,MAAM,IAAI,IAAIC,KAAQD,EAAmBD,EAAQA,EAAQ5kE,QAAQ,IAAI+kE,OAAOD,EAAK,KAAKD,EAAkBC,IAAO,IAAIE,EAAS,CAAC,SAAS,SAAS,UAAU,YAAY,WAAW,SAAS,YAAgBC,EAAO,CAAC,UAAU,WAAW,QAAQ,QAAQ,MAAM,OAAO,OAAO,SAAS,YAAY,UAAU,WAAW,YAAY,SAASC,EAAiB3uD,EAAM4uD,EAAO/a,GAAqE,IAA1D,IAAIqN,EAAkB,iBAAPlhD,EAAgBA,EAAM00C,WAAW10C,GAAO,GAASkhD,EAAI12D,OAAOokE,GAAQ1N,EAAIrN,EAAU,GAAGqN,EAAI,OAAOA,CAAG,CAAC,SAAS2N,EAAa7uD,EAAM4uD,GAAQ,OAAOD,EAAiB3uD,EAAM4uD,EAAO,IAAI,CAAC,SAASE,EAAaC,EAAMC,GAAO,SAASC,EAAIjvD,GAAO,OAAOA,EAAM,GAAG,EAAEA,EAAM,EAAE,EAAE,CAAC,CAAC,IAAIkvD,EAA8K,OAA1G,KAAxDA,EAAQD,EAAIF,EAAMI,cAAcH,EAAMG,iBAA2E,KAAlDD,EAAQD,EAAIF,EAAMK,WAAWJ,EAAMI,eAAkBF,EAAQD,EAAIF,EAAMM,UAAUL,EAAMK,YAAmBH,CAAO,CAAC,SAASI,EAAsBC,GAAW,OAAOA,EAAUC,UAAU,KAAK,EAAE,OAAO,IAAI9pD,KAAK6pD,EAAUJ,cAAc,EAAE,GAAG,IAAI,KAAK,EAAE,OAAOI,EAAU,KAAK,EAAE,OAAO,IAAI7pD,KAAK6pD,EAAUJ,cAAc,EAAE,GAAG,KAAK,EAAE,OAAO,IAAIzpD,KAAK6pD,EAAUJ,cAAc,EAAE,GAAG,KAAK,EAAE,OAAO,IAAIzpD,KAAK6pD,EAAUJ,cAAc,EAAE,GAAG,KAAK,EAAE,OAAO,IAAIzpD,KAAK6pD,EAAUJ,cAAc,EAAE,GAAG,IAAI,KAAK,EAAE,OAAO,IAAIzpD,KAAK6pD,EAAUJ,cAAc,EAAE,GAAG,IAAI,CAAC,SAASM,EAAiB/B,GAAM,IAAIgC,EAA35F,SAAmBhC,EAAKiC,GAA2C,IAArC,IAAIC,EAAQ,IAAIlqD,KAAKgoD,EAAKmC,WAAiBF,EAAK,GAAE,CAAC,IAAIG,EAAK9C,GAAa4C,EAAQT,eAAmBY,EAAaH,EAAQR,WAAeY,GAAoBF,EAAK5C,GAAkBC,IAAsB4C,GAAc,KAAGJ,EAAKK,EAAmBJ,EAAQP,WAAoP,OAAxCO,EAAQK,QAAQL,EAAQP,UAAUM,GAAaC,EAAhPD,GAAMK,EAAmBJ,EAAQP,UAAU,EAAEO,EAAQK,QAAQ,GAAMF,EAAa,GAAIH,EAAQM,SAASH,EAAa,IAAQH,EAAQM,SAAS,GAAGN,EAAQO,YAAYP,EAAQT,cAAc,GAAgE,CAAC,OAAOS,CAAO,CAA03EQ,CAAU,IAAI1qD,KAAKgoD,EAAKM,QAAQ,KAAK,EAAE,GAAGN,EAAKQ,SAAamC,EAAkB,IAAI3qD,KAAKgqD,EAASP,cAAc,EAAE,GAAOmB,EAAkB,IAAI5qD,KAAKgqD,EAASP,cAAc,EAAE,EAAE,GAAOoB,EAAuBjB,EAAsBe,GAAuBG,EAAuBlB,EAAsBgB,GAAmB,OAAGxB,EAAayB,EAAuBb,IAAW,EAAMZ,EAAa0B,EAAuBd,IAAW,EAAUA,EAASP,cAAc,EAASO,EAASP,cAAqBO,EAASP,cAAc,CAAC,CAAC,IAAIsB,EAAkB,CAAC,KAAK,SAAS/C,GAAM,OAAOe,EAASf,EAAKO,SAASjhE,UAAU,EAAE,EAAE,EAAE,KAAK,SAAS0gE,GAAM,OAAOe,EAASf,EAAKO,QAAQ,EAAE,KAAK,SAASP,GAAM,OAAOgB,EAAOhB,EAAKK,QAAQ/gE,UAAU,EAAE,EAAE,EAAE,KAAK,SAAS0gE,GAAM,OAAOgB,EAAOhB,EAAKK,OAAO,EAAE,KAAK,SAASL,GAAiC,OAAOmB,GAAzBnB,EAAKM,QAAQ,MAA8B,IAAI,EAAE,EAAE,EAAE,KAAK,SAASN,GAAM,OAAOmB,EAAanB,EAAKI,QAAQ,EAAE,EAAE,KAAK,SAASJ,GAAM,OAAOiB,EAAiBjB,EAAKI,QAAQ,EAAE,IAAI,EAAE,KAAK,SAASJ,GAAM,OAAO+B,EAAiB/B,GAAMhZ,WAAW1nD,UAAU,EAAE,EAAE,KAAK,SAAS0gE,GAAM,OAAO+B,EAAiB/B,EAAK,EAAE,KAAK,SAASA,GAAM,OAAOmB,EAAanB,EAAKG,QAAQ,EAAE,EAAE,KAAK,SAASH,GAAM,IAAIgD,EAAWhD,EAAKG,QAA4E,OAArD,GAAZ6C,EAAcA,EAAW,GAAWA,EAAW,KAAGA,GAAY,IAAU7B,EAAa6B,EAAW,EAAE,EAAE,KAAK,SAAShD,GAAM,OAAOmB,EAAanB,EAAKI,QAA97I,SAAoBp7D,EAAMzF,GAAiB,IAAV,IAAIiwC,EAAI,EAAUxzC,EAAE,EAAEA,GAAGuD,EAAMiwC,GAAKxqC,EAAMhJ,MAAO,OAAOwzC,CAAG,CAA02IyzB,CAAW3D,GAAaU,EAAKM,QAAQ,MAAMd,GAAkBC,GAAqBO,EAAKK,OAAO,GAAG,EAAE,EAAE,KAAK,SAASL,GAAM,OAAOmB,EAAanB,EAAKK,OAAO,EAAE,EAAE,EAAE,KAAK,SAASL,GAAM,OAAOmB,EAAanB,EAAKE,OAAO,EAAE,EAAE,KAAK,WAAW,MAAM,IAAI,EAAE,KAAK,SAASF,GAAM,OAAGA,EAAKG,SAAS,GAAGH,EAAKG,QAAQ,GAAU,KAAW,IAAI,EAAE,KAAK,SAASH,GAAM,OAAOmB,EAAanB,EAAKC,OAAO,EAAE,EAAE,KAAK,WAAW,MAAM,IAAI,EAAE,KAAK,SAASD,GAAM,OAAOA,EAAKO,SAAS,CAAC,EAAE,KAAK,SAASP,GAAM,IAAIiC,EAAKjC,EAAKQ,QAAQ,EAAER,EAAKO,QAAQ,OAAOY,EAAavtE,KAAK6O,MAAMw/D,EAAK,GAAG,EAAE,EAAE,KAAK,SAASjC,GAAM,IAAIt7B,EAAI9wC,KAAK6O,OAAOu9D,EAAKQ,QAAQ,GAAGR,EAAKO,QAAQ,GAAG,GAAG,GAAoD,IAA7CP,EAAKO,QAAQ,IAAIP,EAAKQ,QAAQ,GAAG,GAAG,GAAG97B,IAAUA,GAA6H,GAAQ,IAALA,EAAQ,CAAC,IAAIw+B,GAAMlD,EAAKO,QAAQ,IAAIP,EAAKQ,SAAS,EAAW,GAAN0C,GAAgB,GAANA,GAAU5D,GAAaU,EAAKM,WAAU57B,EAAI,EAAC,MAAxO,CAACA,EAAI,GAAG,IAAIy+B,GAAOnD,EAAKO,QAAQ,EAAEP,EAAKQ,QAAQ,GAAG,GAAY,GAAP2C,GAAiB,GAAPA,GAAU7D,GAAaU,EAAKM,QAAQ,IAAI,KAAI57B,GAAM,CAAsH,OAAOy8B,EAAaz8B,EAAI,EAAE,EAAE,KAAK,SAASs7B,GAAM,OAAOA,EAAKO,OAAO,EAAE,KAAK,SAASP,GAAM,IAAIiC,EAAKjC,EAAKQ,QAAQ,GAAGR,EAAKO,QAAQ,GAAG,EAAE,OAAOY,EAAavtE,KAAK6O,MAAMw/D,EAAK,GAAG,EAAE,EAAE,KAAK,SAASjC,GAAM,OAAOA,EAAKM,QAAQ,MAAMtZ,WAAW1nD,UAAU,EAAE,EAAE,KAAK,SAAS0gE,GAAM,OAAOA,EAAKM,QAAQ,IAAI,EAAE,KAAK,SAASN,GAAM,IAAIoD,EAAIpD,EAAKU,UAAc2C,EAAMD,GAAK,EAA6C,OAAtBA,GAArBA,EAAIxvE,KAAK6uC,IAAI2gC,GAAK,IAAW,GAAG,IAAIA,EAAI,IAAUC,EAAM,IAAI,KAAKxgC,OAAO,OAAOugC,GAAKxwD,OAAO,EAAE,EAAE,KAAK,SAASotD,GAAM,OAAOA,EAAKD,OAAO,EAAE,KAAK,WAAW,MAAM,GAAG,GAAyC,IAAI,IAAIc,KAA9CF,EAAQA,EAAQ5kE,QAAQ,MAAM,QAAwBgnE,EAAsBpC,EAAQzmD,SAAS2mD,KAAOF,EAAQA,EAAQ5kE,QAAQ,IAAI+kE,OAAOD,EAAK,KAAKkC,EAAkBlC,GAAMb,KAAQW,EAAQA,EAAQ5kE,QAAQ,QAAQ,KAAK,IAAxxKunE,EAAQC,EAAYzmE,EAAY2J,EAAmD+8D,EAA2BC,EAA8qKC,GAA5xKJ,EAAqzK3C,EAA7yK4C,GAAqzK,EAA7xK98D,EAAI3J,EAAO,EAAEA,EAAOy3D,EAAgB+O,GAAS,EAAME,EAAQ,IAAIlpE,MAAMmM,GAASg9D,EAAgBzP,EAAkBsP,EAAQE,EAAQ,EAAEA,EAAQ1mE,QAAWymE,IAAYC,EAAQ1mE,OAAO2mE,GAAuBD,GAA6lK,OAAGE,EAAM5mE,OAAO8iE,EAAgB,GAArnK,SAA4B56D,EAAMoL,GAAQkiD,EAAM/hD,IAAIvL,EAAMoL,EAAO,CAAsjKuzD,CAAmBD,EAAM/D,GAAU+D,EAAM5mE,OAAO,EAAC,CAAqF,SAAS8mE,GAAWrF,GAAMlM,EAAWkM,EAAv6zCrM,IAAu8zCf,EAAe,QAAEA,EAAe,OAAEoN,GAAMzL,GAAM,GAAKtB,EAAM+M,EAAK,IAAItI,EAAWsI,GAAM,CAAyKtF,GAAc9H,EAAsB,cAAE0H,GAAYl+D,MAAM,iBAA3hgC,WAA0D,IAAzB,IAAIkpE,EAAM,IAAIvpE,MAAM,KAAa0B,EAAE,EAAEA,EAAE,MAAMA,EAAG6nE,EAAM7nE,GAAG6mC,OAAO+wB,aAAa53D,GAAG+9D,GAAiB8J,CAAK,CAAq6/BC,GAAwB5J,GAAa/I,EAAqB,aAAE0H,GAAYl+D,MAAM,gBAAl87Bw2D,EAA4B,oBAAEuJ,GAAoBvJ,EAAwB,gBAAEwJ,GAAm57B2B,GAAiBnL,EAAyB,iBAAE0H,GAAYl+D,MAAM,oBAAoB,IAAg5GopE,GAA54GC,GAAc,CAAC,EAA1zpC,SAAsBjQ,EAAIpkD,EAAK8mD,GAAkH,MAA7F,IAAIL,EAAcrC,GAAUoD,KAAKxnD,EAAK8mD,GAA6D1C,CAAG,EAAirpC,EAA//oC,SAA2BU,EAAIn5C,GAAM,EAAg/oC,EAA/+oC,SAA+B2oD,EAAGC,EAAKz0B,GAAO,EAA29oC,EAA19oC,SAA2B00B,EAAMnP,EAAKoP,EAAMvM,GAASD,EAASC,QAAQA,CAAO,EAAm6oC,EAAl6oC,SAA+BsM,EAAMnP,EAAKP,EAAI4P,GAAS,EAAq4oC,EAAp4oC,SAA2BrP,EAAKP,GAAK,EAAq3oC,EAAvlkC,SAAwC6P,GAAY,IAAIC,EAAIxM,EAAoBuM,UAAmBvM,EAAoBuM,GAAY,IAAIE,EAAeD,EAAIC,eAAmBC,EAAcF,EAAIE,cAAkBC,EAAaH,EAAII,OAAgIxL,GAA8B,CAACmL,GAAzII,EAAanvE,KAAI2f,GAAOA,EAAM0vD,mBAAkB17C,OAAOw7C,EAAanvE,KAAI2f,GAAOA,EAAM2vD,uBAA2EC,IAAa,IAAIH,EAAO,CAAC,EAAwgB,OAAtgBD,EAAanhE,SAAQ,CAAC2R,EAAMlZ,KAAK,IAAI+oE,EAAU7vD,EAAM6vD,UAAcH,EAAiBE,EAAW9oE,GAAOqqD,EAAOnxC,EAAMmxC,OAAW2e,EAAc9vD,EAAM8vD,cAAkBH,EAAmBC,EAAW9oE,EAAE0oE,EAAa5nE,QAAYmoE,EAAO/vD,EAAM+vD,OAAWC,EAAchwD,EAAMgwD,cAAcP,EAAOI,GAAW,CAACI,KAAKpR,GAAa6Q,EAA+B,aAAEve,EAAO2e,EAAcjR,IAAOqR,MAAM,CAACrR,EAAIsR,KAAK,IAAIpN,EAAY,GAAGgN,EAAOC,EAAcnR,EAAI8Q,EAA+B,WAAE5M,EAAYoN,IAAIrN,EAAeC,EAAW,EAAE,IAAU,CAAC,CAAChxD,KAAKs9D,EAAIt9D,KAAK,aAAe,SAAS8sD,GAAK,IAAI0I,EAAG,CAAC,EAAE,IAAI,IAAIzgE,KAAK2oE,EAAQlI,EAAGzgE,GAAG2oE,EAAO3oE,GAAGmpE,KAAKpR,GAAwB,OAAnB0Q,EAAc1Q,GAAY0I,CAAE,EAAE,WAAa,SAASxE,EAAYoN,GAAG,IAAI,IAAIN,KAAaJ,EAAQ,KAAKI,KAAaM,GAAI,MAAM,IAAI57B,UAAU,oBAAoBs7B,EAAU,KAAM,IAAIhR,EAAIyQ,IAAiB,IAAIO,KAAaJ,EAAQA,EAAOI,GAAWK,MAAMrR,EAAIsR,EAAEN,IAAuE,OAA1C,OAAd9M,GAAoBA,EAAYr0D,KAAK6gE,EAAc1Q,GAAYA,CAAG,EAAE,eAAiB,EAAE,qBAAuBoE,EAA2BmN,mBAAmBb,GAAc,GAAG,EAA2phC,EAA1phC,SAAkCc,EAAct+D,EAAKqU,EAAKkqD,EAASC,GAAU,EAA0mhC,EAAz4+B,SAAgCrL,EAAQnzD,EAAKqU,EAAKoqD,EAAUC,GAAY,IAAI/6D,EAAMkvD,GAAiBx+C,GAAkCo+C,GAAaU,EAAQ,CAACnzD,KAAlDA,EAAK+yD,GAAiB/yD,GAAsC,aAAe,SAAS2+D,GAAI,QAAQA,CAAE,EAAE,WAAa,SAAS3N,EAAYoN,GAAG,OAAOA,EAAEK,EAAUC,CAAU,EAAE,eAAiB,EAAE,qBAAuB,SAASvN,GAAS,IAAInE,EAAK,GAAU,IAAP34C,EAAU24C,EAAK3B,OAAW,GAAU,IAAPh3C,EAAU24C,EAAKzB,MAAY,IAAU,IAAPl3C,EAA2B,MAAM,IAAImuB,UAAU,8BAA8BxiC,GAAnEgtD,EAAKvB,CAAmE,CAAC,OAAO1/D,KAAmB,aAAEihE,EAAKmE,GAASxtD,GAAO,EAAE06D,mBAAmB,MAAM,EAAi39B,EAAzy7B,SAAiClL,EAAQnzD,GAAkCyyD,GAAaU,EAAQ,CAACnzD,KAAlDA,EAAK+yD,GAAiB/yD,GAAsC,aAAe,SAASirB,GAAQ,IAAIuqC,EAAG7B,GAAc1oC,GAA+B,OAAvBuoC,GAAevoC,GAAeuqC,CAAE,EAAE,WAAa,SAASxE,EAAY3lD,GAAO,OAAOsoD,GAAetoD,EAAM,EAAE,eAAiB,EAAE,qBAAuB6lD,EAA2BmN,mBAAmB,MAAM,EAAs96B,EAA1r6B,SAAiClL,EAAQnzD,EAAKqU,GAAM,IAAI1Q,EAAMkvD,GAAiBx+C,GAAkCo+C,GAAaU,EAAQ,CAACnzD,KAAlDA,EAAK+yD,GAAiB/yD,GAAsC,aAAe,SAASqL,GAAO,OAAOA,CAAK,EAAE,WAAa,SAAS2lD,EAAY3lD,GAAO,OAAOA,CAAK,EAAE,eAAiB,EAAE,qBAAuBuoD,GAA0B5zD,EAAK2D,GAAO06D,mBAAmB,MAAM,EAAw35B,EAAzkuB,SAAoCr+D,EAAKw0D,EAASoK,EAAgB3J,EAAU4J,EAAWC,GAAI,IAAIC,EAApkE,SAA6Bv2B,EAAMw2B,GAA2B,IAAb,IAAIjhE,EAAM,GAAWhJ,EAAE,EAAEA,EAAEyzC,EAAMzzC,IAAKgJ,EAAMpB,KAAK+uD,EAAQsT,EAAe,EAAFjqE,GAAK,IAAI,OAAOgJ,CAAK,CAAi8DkhE,CAAoBzK,EAASoK,GAAiB5+D,EAAK+yD,GAAiB/yD,GAAM6+D,EAAW7J,GAAwBC,EAAU4J,GAAY5K,GAAmBj0D,GAAK,YAAtnB,SAA+BivD,EAAQiQ,GAAO,IAAIC,EAAa,GAAOC,EAAK,CAAC,EAAmN,MAArBF,EAAM5iE,SAAlM,SAAS+iE,EAAM32D,GAAS02D,EAAK12D,IAAiB2oD,GAAgB3oD,KAAiB4oD,GAAiB5oD,GAAO4oD,GAAiB5oD,GAAMpM,QAAQ+iE,IAAcF,EAAaxiE,KAAK+L,GAAM02D,EAAK12D,IAAM,GAAI,IAA4B,IAAI2sD,GAAiBpG,EAAQ,KAAKkQ,EAAa7wE,IAAIgnE,IAAanW,KAAK,CAAC,OAAO,CAA+QmgB,CAAsB,eAAet/D,EAAK,wBAAwB++D,EAAS,GAAEvK,EAAS,GAAGtC,GAA8B,GAAG6M,GAAS,SAASA,GAAU,IAAIQ,EAAiB,CAACR,EAAS,GAAG,MAAM98C,OAAO88C,EAASpzD,MAAM,IAAwG,OAAl6E,SAA6B3L,EAAKqL,EAAM6oD,GAAkBhK,EAAOp+C,eAAe9L,IAAOiyD,GAAmB,4CAA0Cj8D,IAAYk0D,EAAOlqD,GAAMm0D,oBAAen+D,IAAYk+D,EAAchK,EAAOlqD,GAAMm0D,cAAcD,GAAc7oD,GAAW6+C,EAAOlqD,GAAMqL,EAAM6+C,EAAOlqD,GAAMw0D,SAASN,EAAa,CAA8/DsL,CAAoBx/D,EAA15L,SAA8Bq0D,EAAU0K,EAASU,EAAUC,EAAeC,GAAe,IAAInL,EAASuK,EAASlpE,OAAU2+D,EAAS,GAAGtB,GAAkB,kFAA4K,IAA1F,IAAI0M,EAAgC,OAAdb,EAAS,IAAuB,OAAZU,EAAqBI,GAAqB,EAAc9qE,EAAE,EAAEA,EAAEgqE,EAASlpE,SAASd,EAAG,GAAiB,OAAdgqE,EAAShqE,SAA4CiB,IAAjC+oE,EAAShqE,GAAGspE,mBAA+B,CAACwB,GAAqB,EAAK,KAAK,CAAE,IAAIC,EAA2B,SAAnBf,EAAS,GAAG/+D,KAAkB+/D,EAAS,GAAOC,EAAc,GAAG,IAAQjrE,EAAE,EAAEA,EAAEy/D,EAAS,IAAIz/D,EAAGgrE,IAAe,IAAJhrE,EAAM,KAAK,IAAI,MAAMA,EAAEirE,IAAoB,IAAJjrE,EAAM,KAAK,IAAI,MAAMA,EAAE,QAAQ,IAAIkrE,EAAc,mBAAmB1O,GAAsB8C,GAAW,IAAI0L,EAAxD,kCAAsGvL,EAAS,GAA/G,oCAAyJH,EAAU,8DAA8DG,EAAS,GAA1O,iBAAoQqL,IAAsBI,GAAe,2BAA0B,IAAIC,EAAUL,EAAqB,cAAc,OAAWM,EAAM,CAAC,oBAAoB,UAAU,KAAK,iBAAiB,UAAU,cAAkBC,EAAM,CAAClN,GAAkBwM,EAAeC,EAAc5O,EAAegO,EAAS,GAAGA,EAAS,IAAyG,IAAlGa,IAAmBK,GAAe,yCAAyCC,EAAU,cAAqBnrE,EAAE,EAAEA,EAAEy/D,EAAS,IAAIz/D,EAAGkrE,GAAe,UAAUlrE,EAAE,kBAAkBA,EAAE,eAAemrE,EAAU,QAAQnrE,EAAE,SAASgqE,EAAShqE,EAAE,GAAGiL,KAAK,KAAKmgE,EAAMxjE,KAAK,UAAU5H,GAAGqrE,EAAMzjE,KAAKoiE,EAAShqE,EAAE,IAA8M,GAAvM6qE,IAAmBI,EAAc,aAAaA,EAAcnqE,OAAO,EAAE,KAAK,IAAImqE,GAAcC,IAAgBH,EAAQ,YAAY,IAAI,cAAcE,EAAcnqE,OAAO,EAAE,KAAK,IAAImqE,EAAc,OAAUH,EAAsBI,GAAe,sCAAsC,IAAQlrE,EAAE6qE,EAAkB,EAAE,EAAE7qE,EAAEgqE,EAASlpE,SAASd,EAAE,CAAC,IAAIsrE,EAAc,IAAJtrE,EAAM,YAAY,OAAOA,EAAE,GAAG,QAA4C,OAAjCgqE,EAAShqE,GAAGspE,qBAA2B4B,GAAeI,EAAU,SAASA,EAAU,SAAStB,EAAShqE,GAAGiL,KAAK,KAAKmgE,EAAMxjE,KAAK0jE,EAAU,SAASD,EAAMzjE,KAAKoiE,EAAShqE,GAAGspE,oBAAoB,CAAqM,OAAhMyB,IAASG,GAAe,sDAA8DA,GAAe,MAAME,EAAMxjE,KAAKsjE,GAAmCpM,GAAKlC,SAASwO,GAAOx9B,MAAM,KAAKy9B,EAA6B,CAAipHE,CAAqBtgE,EAAKu/D,EAAiB,KAAKV,EAAWC,GAAItK,EAAS,GAAS,EAAE,GAAE,EAAohtB,EAAz9rB,SAAmC8J,EAAct+D,EAAKqU,EAAKkqD,EAASC,GAAUx+D,EAAK+yD,GAAiB/yD,IAAqB,IAAZw+D,IAAeA,EAAS,YAAW,IAAI76D,EAAMkvD,GAAiBx+C,GAAUksD,EAAal1D,GAAOA,EAAM,GAAc,IAAXkzD,EAAa,CAAC,IAAIiC,EAAS,GAAG,EAAEnsD,EAAKksD,EAAal1D,GAAOA,GAAOm1D,IAAWA,CAAQ,CAAC,IAAIC,EAAezgE,EAAKiT,SAAS,YAA8Qw/C,GAAa6L,EAAc,CAACt+D,KAAKA,EAAK,aAAeugE,EAAa,WAAvQE,EAA2B,SAASzP,EAAY3lD,GAAwC,OAAXtf,KAAKiU,KAAaqL,IAAQ,CAAC,EAAkB,SAAS2lD,EAAY3lD,GAAwC,OAAXtf,KAAKiU,KAAaqL,CAAK,EAA4F,eAAiB,EAAE,qBAAuBqqD,GAA4B11D,EAAK2D,EAAiB,IAAX46D,GAAcF,mBAAmB,MAAM,EAAgtqB,EAA/sqB,SAAuClL,EAAQuN,EAAc1gE,GAAM,IAAmH2gE,EAAnG,CAAClT,UAAUt0C,WAAWG,WAAWD,YAAYq0C,WAAWC,YAAYv0C,aAAaw0C,cAAiC8S,GAAe,SAASE,EAAiB31C,GAAyB,IAAI+hC,EAAKtB,EAAYr3C,EAAK24C,EAA3C/hC,IAAe,GAA6Cp0B,EAAKm2D,EAAK/hC,EAAO,GAAG,OAAO,IAAI01C,EAAGx3D,EAAOtS,EAAKwd,EAAK,CAA6Bo+C,GAAaU,EAAQ,CAACnzD,KAAlDA,EAAK+yD,GAAiB/yD,GAAsC,aAAe4gE,EAAiB,eAAiB,EAAE,qBAAuBA,GAAkB,CAACvN,8BAA6B,GAAM,EAA+spB,EAA9spB,SAAsCF,EAAQnzD,GAAkC,IAAI6gE,EAAuB,iBAAvD7gE,EAAK+yD,GAAiB/yD,IAA+CyyD,GAAaU,EAAQ,CAACnzD,KAAKA,EAAK,aAAe,SAASqL,GAAO,IAAqDkhD,EAAjD12D,EAAO61D,EAAQrgD,GAAO,GAAOy1D,EAAQz1D,EAAM,EAAU,GAAGw1D,EAA4C,IAA3B,IAAIE,EAAeD,EAAgB/rE,EAAE,EAAEA,GAAGc,IAASd,EAAE,CAAC,IAAIisE,EAAeF,EAAQ/rE,EAAE,GAAGA,GAAGc,GAAgC,GAAxBy1D,EAAO0V,GAAmB,CAAC,IAA8CC,EAAcpU,EAAakU,EAA7DC,EAAeD,QAA+E/qE,IAANu2D,EAAiBA,EAAI0U,GAAmB1U,GAAK3wB,OAAO+wB,aAAa,GAAGJ,GAAK0U,GAAcF,EAAeC,EAAe,CAAC,CAAC,KAAM,CAAC,IAAIniE,EAAE,IAAIxL,MAAMwC,GAAQ,IAAQd,EAAE,EAAEA,EAAEc,IAASd,EAAG8J,EAAE9J,GAAG6mC,OAAO+wB,aAAarB,EAAOwV,EAAQ/rE,IAAIw3D,EAAI1tD,EAAEsgD,KAAK,GAAG,CAAc,OAAbsW,GAAMpqD,GAAckhD,CAAG,EAAE,WAAa,SAASyE,EAAY3lD,GAAoE,IAAIxV,EAA9DwV,aAAiB61D,cAAa71D,EAAM,IAAI8N,WAAW9N,IAAkB,IAAI81D,EAAkC,iBAAP91D,EAAqB81D,GAAqB91D,aAAiB8N,YAAY9N,aAAiB+1D,mBAAmB/1D,aAAiBoiD,WAAYyF,GAAkB,yCAAkFr9D,EAAtCgrE,GAAiBM,EAA4B7T,EAAgBjiD,GAAmBA,EAAMxV,OAAO,IAAIoV,EAAKo2D,GAAQ,EAAExrE,EAAO,GAAOi3D,EAAI7hD,EAAK,EAA0B,GAAxBygD,EAAQzgD,GAAM,GAAGpV,EAAUgrE,GAAiBM,EAA5ywBpU,EAA80wB1hD,EAAxzwBigD,EAA8zwBwB,EAAIj3D,EAAO,QAAQ,GAAGsrE,EAAqB,IAAI,IAAIpsE,EAAE,EAAEA,EAAEc,IAASd,EAAE,CAAC,IAAIusE,EAASj2D,EAAMgiD,WAAWt4D,GAAMusE,EAAS,MAAK7L,GAAM3I,GAAKoG,GAAkB,2DAA0D5H,EAAOwB,EAAI/3D,GAAGusE,CAAQ,MAAO,IAAQvsE,EAAE,EAAEA,EAAEc,IAASd,EAAGu2D,EAAOwB,EAAI/3D,GAAGsW,EAAMtW,GAAyD,OAAnC,OAAdi8D,GAAoBA,EAAYr0D,KAAK84D,GAAMxqD,GAAaA,CAAI,EAAE,eAAiB,EAAE,qBAAuBimD,EAA2BmN,mBAAmB,SAASvR,GAAK2I,GAAM3I,EAAI,GAAG,EAAigmB,EAAzqiB,SAAuCqG,EAAQoO,EAASvhE,GAAkC,IAAIwhE,EAAaC,EAAaC,EAAQC,EAAeh+D,EAAjF3D,EAAK+yD,GAAiB/yD,GAA+E,IAAXuhE,GAAcC,EAAa3L,GAAc4L,EAAazL,GAAc2L,EAAevL,GAAiBsL,EAAQ,IAAIlW,EAAQ7nD,EAAM,GAAqB,IAAX49D,IAAcC,EAAanL,GAAcoL,EAAalL,GAAcoL,EAAenL,GAAiBkL,EAAQ,IAAIhW,EAAQ/nD,EAAM,GAAE8uD,GAAaU,EAAQ,CAACnzD,KAAKA,EAAK,aAAe,SAASqL,GAA0F,IAAnF,IAAoDkhD,EAAhD12D,EAAO61D,EAAQrgD,GAAO,GAAOu2D,EAAKF,IAAsBX,EAAe11D,EAAM,EAAUtW,EAAE,EAAEA,GAAGc,IAASd,EAAE,CAAC,IAAIisE,EAAe31D,EAAM,EAAEtW,EAAEwsE,EAAS,GAAGxsE,GAAGc,GAAqC,GAA7B+rE,EAAKZ,GAAgBr9D,GAAU,CAAC,IAAmDs9D,EAAcO,EAAaT,EAA7DC,EAAeD,QAAoF/qE,IAANu2D,EAAiBA,EAAI0U,GAAmB1U,GAAK3wB,OAAO+wB,aAAa,GAAGJ,GAAK0U,GAAcF,EAAeC,EAAeO,CAAQ,CAAC,CAAc,OAAb9L,GAAMpqD,GAAckhD,CAAG,EAAE,WAAa,SAASyE,EAAY3lD,GAA0B,iBAAPA,GAAkB6nD,GAAkB,6CAA6ClzD,GAAM,IAAInK,EAAO8rE,EAAet2D,GAAWyhD,EAAIuU,GAAQ,EAAExrE,EAAO0rE,GAAqI,OAA3H7V,EAAQoB,GAAK,GAAGj3D,GAAQ8N,EAAM89D,EAAap2D,EAAMyhD,EAAI,EAAEj3D,EAAO0rE,GAA2B,OAAdvQ,GAAoBA,EAAYr0D,KAAK84D,GAAM3I,GAAYA,CAAG,EAAE,eAAiB,EAAE,qBAAuBoE,EAA2BmN,mBAAmB,SAASvR,GAAK2I,GAAM3I,EAAI,GAAG,EAA01f,EAAz1f,SAAwCqG,EAAQnzD,EAAK6hE,EAAqBtE,EAAeuE,EAAoBtE,GAAe1M,EAAoBqC,GAAS,CAACnzD,KAAK+yD,GAAiB/yD,GAAMu9D,eAAevI,GAAwB6M,EAAqBtE,GAAgBC,cAAcxI,GAAwB8M,EAAoBtE,GAAeE,OAAO,GAAG,EAAuif,EAAtif,SAA8CL,EAAWS,EAAUH,EAAiBoE,EAAgB3iB,EAAO2e,EAAcH,EAAmBoE,EAAgBhE,EAAOC,GAAenN,EAAoBuM,GAAYK,OAAO/gE,KAAK,CAACmhE,UAAU/K,GAAiB+K,GAAWH,iBAAiBA,EAAiBve,OAAO4V,GAAwB+M,EAAgB3iB,GAAQ2e,cAAcA,EAAcH,mBAAmBA,EAAmBI,OAAOhJ,GAAwBgN,EAAgBhE,GAAQC,cAAcA,GAAe,EAA2le,EAA1le,SAAgC9K,EAAQnzD,GAAkCyyD,GAAaU,EAAQ,CAAC8O,QAAO,EAAKjiE,KAA9DA,EAAK+yD,GAAiB/yD,GAAkD,eAAiB,EAAE,aAAe,WAA2B,EAAE,WAAa,SAASgxD,EAAYoN,GAAmB,GAAG,EAAw4d,EAA3sd,SAAoBnzC,EAAOi3C,EAAWC,GAAgBl3C,EAAO0oC,GAAc1oC,GAAQi3C,EAAWzL,GAAsByL,EAAW,aAAa,IAAIlR,EAAY,GAAOoR,EAAGzO,GAAe3C,GAA2C,OAA9BtF,EAAQyW,GAAgB,GAAGC,EAAUF,EAAuB,WAAElR,EAAY/lC,EAAO,EAAu8c,EAA1wc,SAAkCo3C,EAAOp3C,EAAOvF,EAAWC,IAAM08C,EAAOtL,GAAoBsL,IAAQp3C,EAAO0oC,GAAc1oC,GAAQvF,EAAWkxC,GAAkBlxC,GAAqC,KAAKC,EAAK,EAA0lc,EAAI6tC,GAAe,EAAx+b,SAA4BxzD,GAAM,OAAU,IAAPA,EAAiB2zD,GAAeqD,OAAyBh3D,EAAK42D,GAAkB52D,GAAa2zD,GAAeqD,KAAmBh3D,IAAO,EAAo1b,EAApgb,SAAmCw0D,EAASuK,GAAU,IAAIG,EAArR,SAA2B1K,EAASuK,GAAoC,IAA1B,IAAIlgE,EAAE,IAAIxL,MAAMmhE,GAAkBz/D,EAAE,EAAEA,EAAEy/D,IAAWz/D,EAAG8J,EAAE9J,GAAG0hE,GAAsB/K,EAAQqT,EAArzgC,EAA8zgChqE,GAAgB,GAAG,aAAaA,GAAG,OAAO8J,CAAC,CAAgGyjE,CAAkB9N,EAASuK,GAAcwD,EAAQrD,EAAM,GAAOsD,EAAcD,EAAQviE,KAAK,KAAKk/D,EAAMvzD,MAAM,GAAGrd,KAAI,SAAS8qD,GAAG,OAAOA,EAAEp5C,IAAI,IAAGm/C,KAAK,KAAK,IAAQsjB,EAASvL,GAAwBsL,GAAe,QAAcxsE,IAAXysE,EAAsB,OAAOA,EAAmE,IAA1D,IAAIC,EAAO,CAAC,WAAe/8C,EAAK,CAAC48C,GAAaxC,EAAS,GAAWhrE,EAAE,EAAEA,EAAEy/D,EAAS,IAAIz/D,EAAGgrE,IAAe,IAAJhrE,EAAM,KAAK,IAAI,MAAMA,EAAE2tE,EAAO/lE,KAAK,UAAU5H,GAAG4wB,EAAKhpB,KAAKuiE,EAAM,EAAEnqE,IAAI,IAA0E4tE,EAAa,mBAAtEpR,GAAsB,gBAAgBiR,GAAgE,wCAA4CluD,EAAO,EAAE,IAAQvf,EAAE,EAAEA,EAAEy/D,EAAS,IAAIz/D,EAAG4tE,GAAc,cAAc5tE,EAAE,aAAaA,EAAE,8BAA8Buf,EAAO,IAAIA,EAAO,IAAI,OAAOA,GAAQ4qD,EAAMnqE,EAAE,GAAmB,eAA6D,IAA3D4tE,GAAc,6BAA6B5C,EAAS,OAAehrE,EAAE,EAAEA,EAAEy/D,EAAS,IAAIz/D,EAAMmqE,EAAMnqE,EAAE,GAAiB,eAAG4tE,GAAc,cAAc5tE,EAAE,oBAAoBA,EAAE,QAAYwtE,EAAQN,SAAQU,GAAc,qDAAoDA,GAAc,OAAOD,EAAO/lE,KAAKgmE,GAAc,IAAj6CN,EAAY9yE,EAAy5CqzE,EAAgB/O,GAAKlC,SAAS+Q,GAAQ//B,MAAM,KAAKhd,GAAsG,OAA5jD08C,EAA2/CO,EAA/+CrzE,EAAGwnE,GAAoBlhE,OAAOkhE,GAAoBp6D,KAAK0lE,GAAy5CI,EAA14ClzE,EAA07C2nE,GAAwBsL,GAAeC,EAAgBA,CAAQ,EAAuwY,EAAtwY,SAA8Bx3C,EAAO3f,GAAyD,OAApD2f,EAAO0oC,GAAc1oC,GAAQ3f,EAAIqoD,GAAcroD,GAAYqoD,GAAe1oC,EAAO3f,GAAK,EAA+pY,EAA9pY,SAAwB2f,GAAWA,EAAO,IAAGsoC,GAAmBtoC,GAAQ0kC,UAAU,EAAE,EAA6lY,EAAj0W,SAAqB1kC,EAAOupC,EAASuK,EAASp5C,GAAMsF,EAAO0oC,GAAc1oC,GAAQ,IAAI43C,EAAM1L,GAAa3C,GAAsF,OAAxEqO,IAAOA,EAAx5B,SAA6BrO,GAA0B,IAAhB,IAAIuL,EAAS,GAAWhrE,EAAE,EAAEA,EAAEy/D,IAAWz/D,EAAGgrE,IAAe,IAAJhrE,EAAM,KAAK,IAAI,MAAMA,EAAE,IAA8B4tE,EAAa,mCAAmCnO,EAAnC,kEAAiH,IAAQz/D,EAAE,EAAEA,EAAEy/D,IAAWz/D,EAAG4tE,GAAc,cAAc5tE,EAAE,iEAAiEA,EAAjF,eAAqGA,EAAE,aAAaA,EAApH,gDAAyKA,EAAzK,wCAAsT,OAAhG4tE,GAAc,6BAA6B5C,EAA7B,sCAAyF,IAAIpO,SAAS,wBAAwB,SAAS,gBAAgB,YAAYgR,EAA1E,CAAwFlM,GAAsBvM,EAAOyJ,IAA1mB,IAAIjI,GAA+nB,CAAwJoX,CAAoBtO,GAAU2C,GAAa3C,GAAUqO,GAAaA,EAAM53C,EAAO8zC,EAASp5C,EAAK,EAAinW,EAAhnW,SAA6Bo9C,GAAG,OAAOpP,GAAeiD,GAAkBmM,GAAG,EAA6jW,EAA5jW,SAAiC93C,GAA8C8lC,EAAtB4C,GAAc1oC,IAAoCuoC,GAAevoC,EAAO,EAAu9V,EAAt9V,SAA4BviB,EAAKs6D,GAA0D,IAAID,GAAzDr6D,EAAK+tD,GAAsB/tD,EAAK,sBAAsD,qBAAEs6D,GAAK,OAAOrP,GAAeoP,EAAE,EAAk1V,EAAj1V,WAAkB5X,EAAM,GAAG,EAAi0V,EAAh9U,SAAmCmM,EAAKC,EAAOC,GAAQ,OAAOH,GAAiBC,EAAKC,EAAOC,EAAO,EAA44U,EAAn2U,WAAoC,OAA/C,UAAkE,EAAy0U,EAAx0U,SAAgCyL,EAAKh2E,EAAI2/C,GAAK0e,EAAO4X,WAAWD,EAAKh2E,EAAIA,EAAI2/C,EAAI,EAAkxU,EAA/mU,SAAiCu2B,GAAe,IAA+I3kE,EAAE4kE,EAA7IC,EAAQ/X,EAAOz1D,OAA2CytE,EAAra,WAA8b,IAA7DH,KAA8B,GAAgDG,EAAa,OAAO,EAAiE,IAAI,IAAIC,EAAQ,EAAEA,GAAS,EAAEA,GAAS,EAAE,CAAC,IAAIC,EAAkBH,GAAS,EAAE,GAAGE,GAA6N,GAApNC,EAAkB72E,KAAK2W,IAAIkgE,EAAkBL,EAAc,WAAsHzL,GAA/F/qE,KAAK2W,IAAIggE,GAA/N9kE,EAAmP7R,KAAKsM,IAAIkqE,EAAcK,MAAxQJ,EAA2R,OAApQ5kE,EAAE4kE,GAAUA,IAAmU,OAAO,CAAK,CAAC,OAAO,CAAK,EAA2kT,EAA33R,SAAsBK,EAAUC,GAAa,IAAIC,EAAQ,EAAiK,OAA/J9L,KAAgBv7D,SAAQ,SAAS2iD,EAAOlqD,GAAG,IAAI+3D,EAAI4W,EAAYC,EAAQjY,EAAQ+X,EAAY,EAAF1uE,GAAK,GAAG+3D,EAAtT,SAA4BP,EAAIpjD,EAAOmzD,GAAa,IAAI,IAAIvnE,EAAE,EAAEA,EAAEw3D,EAAI12D,SAASd,EAAGs2D,EAAgB,EAAVliD,KAAaojD,EAAIc,WAAWt4D,GAAOunE,IAAYjR,EAAc,EAARliD,GAAW,EAAC,CAAiKy6D,CAAmB3kB,EAAO6N,GAAK6W,GAAS1kB,EAAOppD,OAAO,CAAC,IAAU,CAAC,EAA0qR,EAAzqR,SAA4BguE,EAAeC,GAAmB,IAAIhM,EAAQD,KAAgBnM,EAAQmY,GAAgB,GAAG/L,EAAQjiE,OAAO,IAAI8tE,EAAQ,EAAoG,OAAlG7L,EAAQx7D,SAAQ,SAAS2iD,GAAQ0kB,GAAS1kB,EAAOppD,OAAO,CAAC,IAAG61D,EAAQoY,GAAmB,GAAGH,EAAe,CAAC,EAAo8Q,EAAn8Q,SAAmB3G,GAAI,OAAO,EAAE,EAAi7Q,EAAh7Q,SAAkBA,EAAG+G,EAAIC,EAAOC,GAAM,OAAO,EAAE,EAA84Q,EAA74Q,SAAkBjH,EAAGkH,EAAWC,EAAYC,EAAOC,GAAW,OAAO,EAAE,EAAm1Q,EAA1nQ,SAAmBrH,EAAG+G,EAAIC,EAAOC,GAAgB,IAAV,IAAIr3B,EAAI,EAAU73C,EAAE,EAAEA,EAAEivE,EAAOjvE,IAAI,CAAC,IAAI+3D,EAAIpB,EAAQqY,GAAK,GAAOvkE,EAAIksD,EAAQqY,EAAI,GAAG,GAAGA,GAAK,EAAE,IAAI,IAAIz1B,EAAE,EAAEA,EAAE9uC,EAAI8uC,IAAK6pB,GAAU6E,EAAG1R,EAAOwB,EAAIxe,IAAI1B,GAAKptC,CAAG,CAAsB,OAArBksD,EAAQuY,GAAM,GAAGr3B,EAAW,CAAC,EAA26P,EAAvqD,SAAqB8rB,EAAEC,EAAQC,EAAOC,EAAGyL,GAAK,OAAO7L,GAAUC,EAAEC,EAAQC,EAAOC,EAAG,GAA44DwI,IAA91yC,WAAsB,IAAIkD,EAAK,CAAC,EAAIxH,IAAe,SAASyH,EAAgBp/C,EAASq/C,GAAQ,IAAt3D1+C,EAA03D2+C,EAAQt/C,EAASs/C,QAAQxa,EAAY,IAAEwa,EAAsCnX,GAA9BvC,EAAWd,EAAY,IAAK,GAAwC/gD,QAAQ0kD,EAAU3D,EAAY,IAAK,EAAhhEnkC,EAA4hEmkC,EAAY,IAAK,EAAziE+D,EAAW0W,QAAQ5+C,GAAmR,WAA0I,GAAzGqoC,IAAqBlE,EAA+B,wBAAGA,EAA+B,uBAAEkE,GAAqC,GAAjBA,IAA8C,OAAvBC,IAA6B3pC,cAAc2pC,GAAsBA,EAAqB,MAAQC,GAAsB,CAAC,IAAIxxD,EAASwxD,EAAsBA,EAAsB,KAAKxxD,GAAU,CAAE,CAAm6C8nE,EAAuC,CAAsC,SAASC,EAA2B5iC,GAAQuiC,EAAgBviC,EAAiB,SAAE,CAAC,SAAS6iC,EAAuBC,GAAU,OAA53Bla,GAA0E,mBAAPma,MAAsR3wE,QAAQC,UAAUH,MAAK,WAAW,OAAOw6D,EAAUb,EAAe,IAA9TkX,MAAMlX,EAAe,CAACmX,YAAY,gBAAgB9wE,MAAK,SAAS+wE,GAAU,IAAIA,EAAa,GAAG,KAAK,uCAAuCpX,EAAe,IAAI,OAAOoX,EAAsB,aAAG,IAAG9yD,OAAM,WAAW,OAAOu8C,EAAUb,EAAe,KAAwkB35D,MAAK,SAASgxE,GAAQ,OAAOja,YAAYka,YAAYD,EAAOZ,EAAK,IAAGpwE,MAAK,SAASixB,GAAU,OAAOA,CAAQ,IAAGjxB,KAAK4wE,GAAS,SAASM,GAAQluD,EAAI,0CAA0CkuD,GAAQla,EAAMka,EAAO,GAAE,CAAgkB,GAAn2FjX,IAAqBlE,EAA+B,wBAAGA,EAA+B,uBAAEkE,GAA8wFlE,EAAwB,gBAAG,IAAgE,OAAhDA,EAAwB,gBAAEqa,EAAKC,EAA+B,CAAC,MAAMtvE,GAAGiiB,EAAI,sDAAsDjiB,GAAG+0D,EAAmB/0D,EAAE,EAAvuB21D,GAAqD,mBAAlCK,YAAYoa,sBAAmC7W,EAAUX,IAA+B,mBAAPkX,MAAuYF,EAAuBD,GAApYG,MAAMlX,EAAe,CAACmX,YAAY,gBAAgB9wE,MAAK,SAAS+wE,GAAqE,OAAhDha,YAAYoa,qBAAqBJ,EAASX,GAAoBpwE,KAAK0wE,GAA2B,SAASQ,GAAuG,OAA/FluD,EAAI,kCAAkCkuD,GAAQluD,EAAI,6CAAoD2tD,EAAuBD,EAA2B,GAAE,KAAgSzyD,MAAM63C,EAA4B,CAAsjvCsb,GAAoCrb,EAA2B,mBAAE,WAAW,OAA0BA,EAA2B,mBAAEA,EAAY,IAAK,GAAGvnB,MAAM,KAAK4xB,UAAU,EAAYrK,EAAc,MAAE,WAAW,OAAaA,EAAc,MAAEA,EAAY,IAAK,GAAGvnB,MAAM,KAAK4xB,UAAU,EAAcrK,EAAgB,QAAE,WAAW,OAAOmX,GAAQnX,EAAgB,QAAEA,EAAY,IAAK,GAAGvnB,MAAM,KAAK4xB,UAAU,GAAMkB,GAAMvL,EAAc,MAAE,WAAW,OAAOuL,GAAMvL,EAAc,MAAEA,EAAY,IAAK,GAAGvnB,MAAM,KAAK4xB,UAAU,EAAMgB,GAAerL,EAAuB,eAAE,WAAW,OAAOqL,GAAerL,EAAuB,eAAEA,EAAY,IAAK,GAAGvnB,MAAM,KAAK4xB,UAAU,EAA+M9D,IAA5KvG,EAAqC,6BAAE,WAAW,OAAoCA,EAAqC,6BAAEA,EAAY,IAAK,GAAGvnB,MAAM,KAAK4xB,UAAU,EAA6BrK,EAA+B,uBAAE,WAAW,OAAOuG,GAAuBvG,EAA+B,uBAAEA,EAAY,IAAK,GAAGvnB,MAAM,KAAK4xB,UAAU,GAA69C,SAASiR,GAAS7/C,GAAM,IAA97H6kC,EAAk8Hib,EAAcvb,EAAc,MAAwB,IAAI,IAAI8I,EAAIyS,EAAzB,EAAW,GAAwD,OAA3hIra,EAAjBZ,EAAkiIwI,EAA//H2J,GAAWnS,GAAqgIwI,CAAG,CAAC,MAAM99D,GAAG,OAA1gI,SAAyBA,GAAG,GAAGA,aAAa85D,GAAe,UAAH95D,EAAa,OAAOk2D,EAAWb,EAAM,EAAEr1D,EAAE,CAAg7HwwE,CAAgBxwE,EAAE,CAAC,CAAC,SAASywE,GAAIhgD,GAA+F,SAASigD,IAAW9I,KAAiBA,IAAU,EAAK5S,EAAkB,WAAE,EAAQ2B,IAA1i8CqD,EAAqBjB,GAA+BiB,EAAqBhB,GAAsg8ClE,EAAoBE,GAAWA,EAA6B,sBAAEA,EAA6B,uBAAO2b,IAAaL,KAAzm8C,WAAmB,GAAGtb,EAAgB,QAAiF,IAAjD,mBAAnBA,EAAgB,UAAcA,EAAgB,QAAE,CAACA,EAAgB,UAASA,EAAgB,QAAEr0D,QAA2MkwB,EAAtLmkC,EAAgB,QAAEvmD,QAAwKwqD,EAAcwW,QAAQ5+C,GAAhD,IAAsBA,EAA1JmpC,EAAqBf,EAAc,CAAq57C2X,IAAS,CAArVngD,EAAKA,GAAM0kC,EAAc+D,EAAgB,IAApr8C,WAAkB,GAAGlE,EAAe,OAA8E,IAA/C,mBAAlBA,EAAe,SAAcA,EAAe,OAAE,CAACA,EAAe,SAASA,EAAe,OAAEr0D,QAA+ckwB,EAA3bmkC,EAAe,OAAEvmD,QAA8aqqD,EAAa2W,QAAQ5+C,GAA9C,IAAqBA,EAAhampC,EAAqBlB,EAAa,CAAo+7C+X,GAAY3X,EAAgB,IAA0QlE,EAAkB,WAAGA,EAAkB,UAAE,cAAc11D,YAAW,WAAWA,YAAW,WAAW01D,EAAkB,UAAE,GAAG,GAAE,GAAG0b,GAAO,GAAE,IAAQA,KAAQ,CAAC,GAApoE1b,EAAqB,aAAE,WAAW,OAAoBA,EAAqB,aAAEA,EAAY,IAAK,GAAGvnB,MAAM,KAAK4xB,UAAU,EAAkBrK,EAAoB,YAAE,WAAW,OAAmBA,EAAoB,YAAEA,EAAY,IAAK,GAAGvnB,MAAM,KAAK4xB,UAAU,EAAkBrK,EAAoB,YAAE,WAAW,OAAmBA,EAAoB,YAAEA,EAAY,IAAK,GAAGvnB,MAAM,KAAK4xB,UAAU,EAAmBrK,EAAqB,aAAE,WAAW,OAAoBA,EAAqB,aAAEA,EAAY,IAAM,IAAGvnB,MAAM,KAAK4xB,UAAU,EAAmBrK,EAAqB,aAAE,WAAW,OAAoBA,EAAqB,aAAEA,EAAY,IAAM,IAAGvnB,MAAM,KAAK4xB,UAAU,EAAqBrK,EAAuB,eAAE,WAAW,OAAsBA,EAAuB,eAAEA,EAAY,IAAM,IAAGvnB,MAAM,KAAK4xB,UAAU,EAAqBrK,EAAuB,eAAE,WAAW,OAAsBA,EAAuB,eAAEA,EAAY,IAAM,IAAGvnB,MAAM,KAAK4xB,UAAU,EAAsBrK,EAAwB,gBAAE,WAAW,OAAuBA,EAAwB,gBAAEA,EAAY,IAAM,IAAGvnB,MAAM,KAAK4xB,UAAU,EAAuBrK,EAAyB,iBAAE,WAAW,OAAwBA,EAAyB,iBAAEA,EAAY,IAAM,IAAGvnB,MAAM,KAAK4xB,UAAU,EAAqBrK,EAAuB,eAAE,OAAyBA,EAAsB,cAAE,OAAqBoE,EAAsB,SAAS0X,IAAgBlJ,IAAU6I,KAAU7I,KAAUxO,EAAsB0X,EAAS,EAA+rB9b,EAAgB,QAAiF,IAAjD,mBAAnBA,EAAgB,UAAcA,EAAgB,QAAE,CAACA,EAAgB,UAASA,EAAgB,QAAEr0D,OAAO,GAAGq0D,EAAgB,QAAEnwC,KAAlBmwC,GAA2B,IAAI2b,IAAa,EAGphnD,OAH4hnD3b,EAAqB,eAAE2b,IAAa,GAAMF,KAG/jnD5b,EAAckc,KAEvB,qCCVe,MAAMC,EACnB,WAAAx7E,GACEqB,KAAKo6E,SACP,CAEA,YAAI/gD,GACF,GAAIr5B,KAAKo6E,UACP,OAAOp6E,KAAKo6E,UAGd,MAAM,IAAIzyE,MAAM,iCAClB,CAEA,gBAAM0yE,CAAW1D,EAAS,CAAC,GACzB32E,KAAKo6E,gBAAkB,EAAS,CAC9BE,WAAa7U,GACPA,EAAEhmD,SAAS,SACN,EAEFgmD,KAENkR,GAEP,iDCvBF,MAAM4D,EACK,EADLA,GAEO,EAEPl0B,EAAU,IAAI/T,IA0GpB,MAAMt0B,EAAiB,CAAC,EAIxB,SAASE,EAAOC,EAAWC,GACzB,IAAIC,EAAgBmqD,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzF38D,OAAOyS,OAAOF,EAAOJ,EAAgBK,GACrC,EAAAm8D,EAAMvS,IAAI9pD,EAAWC,GACrB,EAAAo8D,EAAMC,KAAKt8D,EAAWC,EAAO,EAAG,GAjHlC,SAAkCD,GAChCA,EAAUu8D,YAAc,CAACC,EAAQC,KAC/B,MAAOC,GAASF,EACXC,EAAQ,KACXA,EAAQ,GAAK,oBAEf,MAAOE,GAAUF,EACjBz8D,EAAU48D,gBAAgBF,EAAOC,GACjCA,EAAOE,UAAU,EAEnB78D,EAAU88D,aAAe,CAACC,EAAI3rC,EAAK4rC,EAAaC,EAAWC,KACzD,IAAIC,EAASH,EACTI,EAAWH,EACXI,GAAa,EACbC,EAAc,EAClB,MAAQD,GAAY,CAClB,MAAM,aACJE,GACER,EAAGS,cAAcL,GACrB,IAAKI,EAEH,SAEFH,EAAWG,EAAa,KAAOH,EAAWG,EAAa,GAAKA,EAAa,GACzED,IAGA,MAAMpuB,EAAI9d,EAAMksC,EAChBJ,EAAWzqE,KAAK,CACdy8C,IACAuuB,KAAML,IAER,MAAMM,EAAWX,EAAGY,cAAcP,GAClC,GAAwB,IAApBM,EAAS/xE,QAAgByxE,IAAaH,EAExC,OAAOG,EAEe,IAApBM,EAAS/xE,QAEXwxE,EAASO,EAAS,KAAOP,EAASO,EAAS,GAAKA,EAAS,GACzDx1B,EAAQpkC,IAAIq5D,IAGZE,GAAa,CAEjB,CACA,OAAOD,CAAQ,EAEjBp9D,EAAU48D,gBAAkB,CAACF,EAAOC,KAClC,MAAMiB,EAAQ,GACd11B,EAAQ21B,QACR,MAAMC,EAAUpB,EAAMrrB,WACtBsrB,EAAO7qB,YAAYisB,QAAQ7uD,aAAalM,KAAK05D,EAAM5qB,YAAYjC,YAI/D,IAAK,IAAImuB,EAAK,EAAGA,EAAKF,EAAQG,mBAAoBD,IAAM,CACtD,GAAI91B,EAAQrkC,IAAIm6D,GAEd,SAEF,MAAM,aACJT,GACEb,EAAMc,cAAcQ,GACxB,IAAKT,EAEH,SAEFr1B,EAAQpkC,IAAIk6D,GACZ,MAAMf,EAAYM,EAAa,GACzBL,EAAa,GACnBA,EAAWzqE,KAAK,CACdy8C,EAAG,EACHuuB,KAAMR,IAGJA,IADYj9D,EAAU88D,aAAaJ,EAAON,EAAa4B,EAAIf,EAAWC,KAGxEl9D,EAAU88D,aAAaJ,EAAON,EAAc4B,EAAIf,EAAWC,GAC3DA,EAAW3nE,MAAK,CAACZ,EAAGC,IAAMD,EAAEu6C,EAAIt6C,EAAEs6C,GAAK,EAAI,IAEvCguB,EAAWvxE,QAAUuxE,EAAW,GAAGO,OAASP,EAAWA,EAAWvxE,OAAS,IAAI8xE,MACjFP,EAAWzqE,KAAK,IACXyqE,EAAWA,EAAWvxE,OAAS,MAIpCuxE,EAAWvxE,QACbiyE,EAAMnrE,KAAKyqE,EAEf,CAGA,MAAMgB,EAAWvB,EAAOtrB,WACxB6sB,EAASl7E,OAAO,GAChB46E,EAAMxrE,SAAQrR,IACZm9E,EAASC,eAAep9E,EAAKqD,KAAIoV,GAAMA,EAAGikE,OAAM,GAChD,CAEN,CAeEW,CAAyBp+D,EAC3B,CAQA,IAAI,EAAQ,CACVQ,YALkB,EAAA67D,EAAM77D,YAAYT,EAAQ,4BAM5CA,gECxGF,MAAMs+D,EAAoB,CAIxBC,QAAS,KAKTC,qBAAqB,EACrBC,2BAA4B,KAI5B,uBAAMC,CAAkBC,GAClB78E,KAAK08E,0BACD18E,KAAK28E,2BAIT38E,KAAKy8E,SAASpjD,WAIlBr5B,KAAK08E,qBAAsB,EAC3B18E,KAAK28E,2BAA6B,IAAIr0E,SAASC,IAC7CvI,KAAKy8E,QAAU,IAAItC,EACnBn6E,KAAKy8E,QACFpC,WAAW,CACVrX,eAAgB6Z,IAEjBz0E,MAAK,KACJpI,KAAK08E,qBAAsB,EAC3Bn0E,GAAS,GACT,UAGAvI,KAAK28E,2BACb,EASA,6BAAMG,CAAwBljD,KAASC,GACrC,MAAM,UAAEkjD,EAAS,eAAEC,GAAmBpjD,GAC/BijD,GAAoBhjD,QACrB75B,KAAK48E,kBAAkBC,GAM7B,aALsB78E,KAAKy8E,QAAQpjD,SAAS4jD,2BAC1CF,EACAC,EAIJ,EAaA,8BAAME,CAAyBtjD,KAASC,GACtC,MAAOgjD,GAAoBhjD,QACrB75B,KAAK48E,kBAAkBC,GAU7B,OARgB78E,KAAKy8E,QAAQpjD,SAAS6jD,yBACpCtjD,EAAKjvB,WACLivB,EAAKhzB,WACLgzB,EAAK/yB,QACL+yB,EAAKjzB,UACLizB,EAAK5zB,OACL,CAAC4zB,EAAKoY,cAGV,EAeA,oCAAMmrC,CAA+BvjD,KAASC,GAC5C,MAAOgjD,GAAoBhjD,EACrB4iD,QAAgB,IAAItC,QACpBsC,EAAQpC,WAAW,CACvBrX,eAAgB6Z,IAGlB,MAAM,eACJ5kB,EAAc,WACdttD,EAAU,2BACVyyE,EAA0B,WAC1Bx2E,EAAU,OACVZ,EAAM,UACNW,EAAS,QACTE,GACE+yB,EAEEyjD,EACJ,EAAA9rC,UAAA,aAAuB4lB,yBAAyBvwD,EAAY+D,GAExDK,EAAY,mBAClBA,EAAUgkB,cAAcpoB,GACxBoE,EAAUmkB,UAAUnpB,GACpBgF,EAAUkkB,aAAavoB,GACvBqE,EAAUikB,WAAWpoB,GAErB,MAAM8oB,EAAc,sBAAyB,CAC3C1b,KAAM,SACN8a,mBAAoB,EACpBxb,OAAQ5I,IAGVK,EAAUyP,eAAemV,WAAWD,GAEpC3kB,EAAUgwE,WAEV,IAAK,MAAMzuE,KAAS0rD,EAAgB,CAClC,MAAMtzB,EAAcy4C,EAA2BrxE,IAAIQ,GAEnD,IAAK,MAAMsxB,KAAc8G,EAAa,CACpC,IAAK9G,EAAW4U,SACd,SAGF,MAAM,SAAEA,EAAQ,cAAE6qC,GAAkBz/C,EAC9B22B,GAAS,IAAApjB,gCAA+BqB,IAEvCib,EAAME,EAAME,GAAQ,EAAAvc,UAAA,sBAAgCvmC,EAAW,CACpEwpD,EAAO,GAAG,GACVA,EAAO,GAAG,GACVA,EAAO,GAAG,MAGL7G,EAAME,EAAME,GAAQ,EAAAxc,UAAA,sBAAgCvmC,EAAW,CACpEwpD,EAAO,GAAG,GACVA,EAAO,GAAG,GACVA,EAAO,GAAG,MAGN,kBAAEnI,EAAiB,qBAAEN,IACzB,IAAAD,aAAYrZ,GAERoP,EAAQy7B,GAAe/6E,KAAKu/C,IAChC,MAAQuK,kBAAmBkxB,IAAkB,IAAAzxB,aAAYhK,GACzD,OAAOy7B,CAAa,IAGhBpxB,GAAYJ,EAAuB,GAAK,EACxCK,GAAaL,EAAuB,GAAK,GAG/C,IAAA3c,sBACEpkC,GACCiyC,IACC,MAAMugC,EAAU,CAACvgC,EAASkP,GAAWlP,EAASmP,IAO9C,OAJiB,IAAAzK,eAAc0K,EAAmBmxB,EAAS,CACzD37B,SAGa,IAEjB,EAAGkN,eACDsuB,EAAyBI,cAAc1uB,EAAUxiD,EAAM,GAEzD,CACE,CAACmhD,EAAMC,GACP,CAACC,EAAMC,GACP,CAACC,EAAMC,IAGb,CACF,CAEA,OAAOsvB,EAAyB1yE,UAClC,EAOA,mCAAM+yE,CAA8B9jD,KAASC,GAC3C,MAAOgjD,GAAoBhjD,EACrB4iD,QAAgB,IAAItC,QACpBsC,EAAQpC,WAAW,CACvBrX,eAAgB6Z,IAGlB,MAAM,kBAAEc,EAAiB,2BAAEP,EAA0B,eAAEnlB,GACrDr+B,EAEIgkD,EAA4B,IAAIh7D,IAEtC+6D,EAAkBptE,SAAQ,CAACstE,EAAkBxvE,KAC3C,MAAM,WAAEzH,EAAU,WAAE+D,EAAU,UAAEhE,EAAS,QAAEE,EAAO,OAAEb,GAClD63E,EACIC,EAAU,EAAAvsC,UAAA,aAAuB4lB,yBACrCvwD,EACA+D,GAGIK,EAAY,mBAClBA,EAAUgkB,cAAcpoB,GACxBoE,EAAUmkB,UAAUnpB,GACpBgF,EAAUkkB,aAAavoB,GACvBqE,EAAUikB,WAAWpoB,GAErB,MAAM8oB,EAAc,sBAAyB,CAC3C1b,KAAM,SACN8a,mBAAoB,EACpBxb,OAAQ5I,IAGVK,EAAUyP,eAAemV,WAAWD,GAEpC3kB,EAAUgwE,WAEV4C,EAA0BrgE,IAAIlP,EAAmB,CAAEyvE,UAAS9yE,aAAY,IAG1E,IAAK,MAAMuB,KAAS0rD,EAAgB,CAClC,MAAMtzB,EAAcy4C,EAA2BrxE,IAAIQ,GAEnD,IAAK,MAAMsxB,KAAc8G,EAAa,CACpC,IAAK9G,EAAW4U,SACd,SAGF,MAAM,SAAEA,EAAQ,cAAE6qC,EAAa,kBAAEjvE,GAAsBwvB,EACjD22B,GAAS,IAAApjB,gCAA+BqB,IAEtCqrC,QAAST,EAAwB,UAAEryE,GACzC4yE,EAA0B7xE,IAAIsC,IAEzBq/C,EAAME,EAAME,GAAQ,EAAAvc,UAAA,sBAAgCvmC,EAAW,CACpEwpD,EAAO,GAAG,GACVA,EAAO,GAAG,GACVA,EAAO,GAAG,MAGL7G,EAAME,EAAME,GAAQ,EAAAxc,UAAA,sBAAgCvmC,EAAW,CACpEwpD,EAAO,GAAG,GACVA,EAAO,GAAG,GACVA,EAAO,GAAG,MAGN,kBAAEnI,EAAiB,qBAAEN,IACzB,IAAAD,aAAYrZ,GAERoP,EAAQy7B,GAAe/6E,KAAKu/C,IAChC,MAAQuK,kBAAmBkxB,IAAkB,IAAAzxB,aAAYhK,GACzD,OAAOy7B,CAAa,IAGhBpxB,GAAYJ,EAAuB,GAAK,EACxCK,GAAaL,EAAuB,GAAK,GAG/C,IAAA3c,sBACEpkC,GACCiyC,IACC,MAAMugC,EAAU,CAACvgC,EAASkP,GAAWlP,EAASmP,IAO9C,OAJiB,IAAAzK,eAAc0K,EAAmBmxB,EAAS,CACzD37B,SAGa,IAEjB,EAAGkN,eACDsuB,EAAyBI,cAAc1uB,EAAUxiD,EAAM,GAEzD,CACE,CAACmhD,EAAMC,GACP,CAACC,EAAMC,GACP,CAACC,EAAMC,IAGb,CACF,CAQA,OANA4vB,EAAkBptE,SAAQ,CAACstE,EAAkBxvE,KAC3C,MAAQyvE,QAAST,GACfO,EAA0B7xE,IAAIsC,GAEhCwvE,EAAiBlzE,WAAa0yE,EAAyB1yE,UAAU,IAE5DgzE,CACT,EAcA,oCAAMI,CAA+BnkD,KAASC,GAC5C,MAAOgjD,GAAoBhjD,QACrB75B,KAAK48E,kBAAkBC,GAW7B,OATgB78E,KAAKy8E,QAAQpjD,SAAS2kD,yBACpCpkD,EAAKoE,OACLpE,EAAKqkD,MACLrkD,EAAKhzB,WACLgzB,EAAK/yB,QACL+yB,EAAKjzB,UACLizB,EAAK5zB,OAIT,EAQA,qCAAMk4E,CAAgCtkD,KAASC,GAC7C,MAAOgjD,GAAoBhjD,QACrB75B,KAAK48E,kBAAkBC,GAE7B,MAAM,aAAEsB,GAAiBvkD,EAEnB/M,EAAWvlB,MAAM6Z,KAAKg9D,EAAa79D,QAAQ/d,KAAKyvC,IACpD,MAAM,OAAEhU,EAAM,MAAEigD,GAAUE,EAAapyE,IAAIimC,GAU3C,MAAO,IATQhyC,KAAKy8E,QAAQpjD,SAAS2kD,yBACnChgD,EACAigD,EACArkD,EAAKhzB,WACLgzB,EAAK/yB,QACL+yB,EAAKjzB,UACLizB,EAAK5zB,QAKLgsC,eACD,IAGG9X,QAAgB5xB,QAAQkJ,IAAIqb,GAE5BuxD,EAAkB,mBACxBA,EAAgBpvD,cAAc4K,EAAKhzB,YACnCw3E,EAAgBjvD,UAAUyK,EAAK5zB,QAC/Bo4E,EAAgBnvD,WAAW2K,EAAK/yB,SAChCu3E,EAAgBlvD,aAAa0K,EAAKjzB,WAElC,MAAM03E,EACJzkD,EAAKhzB,WAAW,GAAKgzB,EAAKhzB,WAAW,GAAKgzB,EAAKhzB,WAAW,GAEtD+oB,EAAc,sBAAyB,CAC3C1b,KAAM,SACN8a,mBAAoB,EACpBxb,OAAQ,IAAI6Z,WAAWixD,KAGzBD,EAAgB3jE,eAAemV,WAAWD,GAC1CyuD,EAAgBpD,WAOhB,MAAMqC,EACJ,EAAA9rC,UAAA,aAAuB4lB,yBACrBv9B,EAAKhzB,WACLw3E,EAAgB3jE,eAAeC,aAAaszC,WAG1CswB,EAAoBpkD,EAAQ33B,KAAK2zC,IACrC,MAAM,KAAEprC,EAAI,WAAElE,EAAU,UAAED,EAAS,OAAEX,EAAM,QAAEa,GAAYqvC,EACnDjyB,EAAS,mBACfA,EAAO+K,cAAcpoB,GACrBqd,EAAOkL,UAAUnpB,GACjBie,EAAOgL,WAAWpoB,GAClBod,EAAOiL,aAAavoB,GAEpB,MAAMgpB,EAAc,sBAAyB,CAC3C1b,KAAM,SACN8a,mBAAoB,EACpBxb,OAAQzI,IAGVmZ,EAAOxJ,eAAemV,WAAWD,GAEjC1L,EAAO+2D,WAEP,MAAM9jB,EAAe,EAAA3lB,UAAA,aAAuB4lB,yBAC1CvwD,EACAkE,GAGIyzE,EAASt6D,EAAOu6D,YAEtB,MAAO,CACLv6D,SACAizC,eACAqnB,SACA5zE,WAAYG,EACZknC,aAAckE,EAAOlE,aACtB,IA0CH,OAvCA,IAAA5C,sBACEgvC,GACA,KAAM,IACN,EAAGrvB,WAAU9R,eAKX,IACE,IAAK,MAAMwhC,KAAcH,EAAmB,CAC1C,MAAM,OAAEr6D,EAAM,OAAEs6D,EAAM,aAAErnB,EAAY,aAAEllB,GAAiBysC,EAEjDlyE,EAAQ0X,EAAO7Y,aAAa6xC,GAGlC,GACE1wC,EAAM,GAAKgyE,EAAO,IAClBhyE,EAAM,GAAKgyE,EAAO,IAClBhyE,EAAM,GAAKgyE,EAAO,IAClBhyE,EAAM,GAAKgyE,EAAO,IAClBhyE,EAAM,GAAKgyE,EAAO,IAClBhyE,EAAM,GAAKgyE,EAAO,GAElB,SAGF,MAAMG,EAAenyE,EAAMhK,IAAI3B,KAAKC,OAEpC,GADcq2D,EAAaK,YAAYmnB,GAC3B,EAAG,CACbrB,EAAyBI,cAAc1uB,EAAU/c,GACjD,KACF,CACF,CACF,CAAE,MAAO1rB,GAET,KAIG+2D,EAAyB1yE,UAClC,EACA,gBAAAg0E,EAAiB,aAAEC,IACjB,MAAMC,EAAQ,IAAIj8D,IAClB,IAAK,MAAM,OAAEob,EAAM,GAAEx6B,KAAQo7E,EAAc,CACzC,MAAM5iC,GAAO,IAAA8iC,SAAQ9gD,EAAQ,CAAE+gD,cAAe,IAC9CF,EAAMthE,IAAI/Z,EAAIw4C,EAChB,CACA,OAAO6iC,CACT,EAUA,qBAAAG,EACE,WAAEC,EAAU,aAAEL,EAAY,aAAEM,EAAe,IAAIt8D,KAC/Ci6D,EACAsC,GAEA,MAAMC,EAAiBH,EAAWn1E,OAC5Bu1E,EAAS,mBAETC,EAAS,mBAEfD,EAAOE,eAAeD,GAEtB,MAAME,EAAkB,mBAExB,IACE,IAAK,MAAOjzE,EAAOkzE,KAAcR,EAAWrvB,UAAW,CACrD,MAAM,WAAExoD,EAAU,OAAEs4E,GAAWD,EAEzBE,EAAkB,IAAI/8D,IAC5B,IAAK,MAAMg9D,KAAgBhB,EAAc,CACvC,MAAM,OAAE5gD,EAAM,MAAEigD,EAAK,GAAEz6E,GAAOo8E,EAExBC,EACJX,EAAanzE,IAAIvI,KAAO,IAAAs7E,SAAQ9gD,EAAQ,CAAE+gD,cAAe,IAEtDG,EAAal9D,IAAIxe,IACpB07E,EAAa3hE,IAAI/Z,EAAIq8E,GAGvB,MAAM,KAAElkC,EAAI,KAAEE,EAAI,KAAEikC,EAAI,KAAElkC,EAAI,KAAEE,EAAI,KAAEikC,GAASF,GAEzC,OAAE75E,EAAM,OAAEo2D,GAAWsjB,EAAO,GAGlC,KACG,IAAAM,yBACCh6E,EACAo2D,EACAzgB,EACAE,EACAikC,EACAlkC,EACAE,EACAikC,GAGF,SAGFP,EAAgBvvB,YAAYisB,QAAQl+C,EAAQ,GAC5CwhD,EAAgBS,WAAW/D,QAAQ+B,EAAO,GAC1CuB,EAAgBxE,WAEhBqE,EAAOa,aAAaV,GACpBF,EAAOnwD,UAAUnpB,GACjBs5E,EAAOa,UAAU/jB,GAEjB,IACEijB,EAAOe,QACT,CAAE,MAAOj3E,GACPkI,QAAQC,KAAK,wBAAyBnI,GACtC,QACF,CAEA,MAAMmmD,EAAW+vB,EAAOgB,gBAElBC,EAAehxB,EACrBgxB,EAAaC,aACb,MAAMC,EAAiB,gBACvBA,EAAeN,aAAaI,GAE5B,MAAMG,EAAaD,EAAeH,gBAC9B/wB,GACFqwB,EAAgBpiE,IAAI/Z,EAAI,CACtBw6B,OAAQyiD,EAAWxwB,YAAYjC,UAC/B0yB,MAAOD,EAAWjxB,WAAWxB,UAC7B2yB,cAAeF,EAAWjxB,WAAW4sB,oBAG3C,CAEAS,EAAiB,CAAE+D,UAAWr0E,EAAQ,GAAK6yE,IAE3CD,EAAoB,CAAE/3E,aAAYu4E,mBACpC,CACF,CAAE,MAAOx2E,GACPkI,QAAQC,KAAK,0BAA2BnI,EAC1C,SAEEy1E,EAAe,KACfU,EAAO7gE,QACT,CACF,IAGF,QAAO+9D,sHC/lBP,MAAM,cACJqE,GACE,EAAArG,EAwTJ,MAAMx8D,EAAiB,CACrBrX,UAAW,KAEX6E,aAAc,KAEdJ,aAAc,KAEdvE,QAAS,CAAC,EAAK,EAAK,GACpBb,OAAQ,CAAC,EAAK,EAAK,GACnBu4E,OAAQ,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,GAC3BuC,gBAAiB,IAAeC,OAKlC,SAAS7iE,EAAOC,EAAWC,GACzB,IAAIC,EAAgBmqD,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzF38D,OAAOyS,OAAOF,EAAOJ,EAAgBK,GAGrC,iBAAkBF,EAAWC,EAAOC,GAC/BD,EAAMzX,UAEAW,MAAMC,QAAQ6W,EAAMzX,aAC7ByX,EAAMzX,UAAY,IAAIk7D,aAAazjD,EAAMzX,UAAUiZ,MAAM,EAAG,KAF5DxB,EAAMzX,UAAY,cAAc,IAAIk7D,aAAa,IAInDzjD,EAAM5S,aAAe,IAAIq2D,aAAa,IACtCzjD,EAAMhT,aAAe,IAAIy2D,aAAa,IAGtC,EAAA2Y,EAAMzuE,IAAIoS,EAAWC,EAAO,CAAC,eAAgB,iBAC7C,EAAAo8D,EAAMwG,YAAY7iE,EAAWC,EAAO,CAAC,SAAU,WAAY,GAC3D,EAAAo8D,EAAMwG,YAAY7iE,EAAWC,EAAO,CAAC,aAAc,GACnD,EAAAo8D,EAAMyG,SAAS9iE,EAAWC,EAAO,CAAC,UAAW,GAnV/C,SAAsBD,EAAWC,GAE/BA,EAAMG,eAAe3N,KAAK,gBAC1BuN,EAAU+iE,UAAY,WACpB,GAAI9iE,EAAM+iE,QAER,OADAN,EAAc,8CACP,EAET,IAAK,IAAIO,EAAO5Y,UAAU1+D,OAAQu3E,EAAW,IAAI/5E,MAAM85E,GAAOE,EAAO,EAAGA,EAAOF,EAAME,IACnFD,EAASC,GAAQ9Y,UAAU8Y,GAE7B,MAAMC,EAAkC,IAApBF,EAASv3E,OAAeu3E,EAAS,GAAKA,EAC1D,GAA2B,IAAvBE,EAAYz3E,OACd,OAAO,EAET,MAAM03E,EAAiBpjE,EAAMmgE,OAAOkD,MAAK,CAACC,EAAMn1E,IAAUm1E,IAASH,EAAYh1E,KAM/E,OALIi1E,IACFpjE,EAAMmgE,OAASgD,EAAY3hE,QAC3BxB,EAAM0iE,gBAAkB,iCAA+C1iE,EAAMmgE,QAC7EpgE,EAAU68D,YAELwG,CACT,EACArjE,EAAU6Q,cAAgB,WACxB,IAAIhmB,EACAu5C,EACAqM,EACJ,GAAIxwC,EAAM+iE,QACRN,EAAc,iDADhB,CAIA,GAAyB,IAArBrY,UAAU1+D,OAAc,CAC1B,MAAMkI,EAAQw2D,UAAU1+D,QAAU,OAAIG,EAAYu+D,UAAU,GAC5Dx/D,EAAIgJ,EAAM,GACVuwC,EAAIvwC,EAAM,GACV48C,EAAI58C,EAAM,EACZ,KAAO,IAAyB,IAArBw2D,UAAU1+D,OAMnB,YADA+2E,EAAc,+BAJd73E,EAAIw/D,UAAU1+D,QAAU,OAAIG,EAAYu+D,UAAU,GAClDjmB,EAAIimB,UAAU1+D,QAAU,OAAIG,EAAYu+D,UAAU,GAClD5Z,EAAI4Z,UAAU1+D,QAAU,OAAIG,EAAYu+D,UAAU,EAIpD,CACArqD,EAAU+iE,UAAU,EAAGl4E,EAAI,EAAG,EAAGu5C,EAAI,EAAG,EAAGqM,EAAI,EAd/C,CAeF,EACAzwC,EAAUjT,cAAgB,IAAM,CAACkT,EAAMmgE,OAAO,GAAKngE,EAAMmgE,OAAO,GAAK,EAAGngE,EAAMmgE,OAAO,GAAKngE,EAAMmgE,OAAO,GAAK,EAAGngE,EAAMmgE,OAAO,GAAKngE,EAAMmgE,OAAO,GAAK,GACnJpgE,EAAUi+D,iBAAmB,KAC3B,MAAMuF,EAAOxjE,EAAUjT,gBACvB,IAAI02E,EAAS,EACb,IAAK,IAAI54E,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,GAAgB,IAAZ24E,EAAK34E,GACP,OAAO,EAEL24E,EAAK34E,GAAK,IACZ44E,GAAUD,EAAK34E,GAAK,EAExB,CACA,OAAO44E,CAAM,EAEfzjE,EAAU0jE,kBAAoB,KAC5B,MAAMF,EAAOxjE,EAAUjT,gBACvB,OAAOy2E,EAAK,GAAKA,EAAK,GAAKA,EAAK,EAAE,EAEpCxjE,EAAUgxC,SAAW5iD,IACnB,MAAMo1E,EAAOxjE,EAAUjT,gBACvB,GAAgB,IAAZy2E,EAAK,IAAwB,IAAZA,EAAK,IAAwB,IAAZA,EAAK,GAEzC,OADAd,EAAc,2CACP,KAET,MAAMiB,EAAM,IAAIjgB,aAAa,GAC7B,OAAQzjD,EAAM0iE,iBACZ,KAAK,IAAeC,MAClB,OAAO,KACT,KAAK,IAAegB,aAClB,MACF,KAAK,IAAeC,OAClBF,EAAI,GAAKv1E,EACT,MACF,KAAK,IAAe01E,OAClBH,EAAI,GAAKv1E,EACT,MACF,KAAK,IAAe21E,OAClBJ,EAAI,GAAKv1E,EACT,MACF,KAAK,IAAe41E,SAClBL,EAAI,GAAKv1E,EAAQo1E,EAAK,GACtBG,EAAI,GAAKv1E,EAAQo1E,EAAK,GACtB,MACF,KAAK,IAAeS,SAClBN,EAAI,GAAKv1E,EAAQo1E,EAAK,GACtBG,EAAI,GAAKv1E,EAAQo1E,EAAK,GACtB,MACF,KAAK,IAAeU,SAClBP,EAAI,GAAKv1E,EAAQo1E,EAAK,GACtBG,EAAI,GAAKv1E,EAAQo1E,EAAK,GACtB,MACF,KAAK,IAAeW,SAClBR,EAAI,GAAKv1E,EAAQo1E,EAAK,GACtBG,EAAI,GAAKv1E,EAAQo1E,EAAK,GAAKA,EAAK,GAChCG,EAAI,GAAKv1E,GAASo1E,EAAK,GAAKA,EAAK,IACjC,MACF,QACEd,EAAc,2BAGlB,MAAM0B,EAAS,CAAC,EAAG,EAAG,GAEtB,OADApkE,EAAU3S,aAAas2E,EAAKS,GACrBA,CAAM,EA8BfpkE,EAAUqkE,UAAY,IAAMrkE,EAAUskE,eAAetkE,EAAUukE,oBAC/DvkE,EAAUskE,eAAiBE,GAAM,qBAA+BA,EAAIvkE,EAAM5S,cAC1E2S,EAAUukE,iBAAmB,IAAM,aAAuB,IAAItkE,EAAMmgE,QAAS,IAG7EpgE,EAAUykE,kBAAoB,KAC5B,qBAAqBxkE,EAAM5S,aAAc4S,EAAMpY,QAC/CoY,EAAM5S,aAAa,GAAK4S,EAAMzX,UAAU,GACxCyX,EAAM5S,aAAa,GAAK4S,EAAMzX,UAAU,GACxCyX,EAAM5S,aAAa,GAAK4S,EAAMzX,UAAU,GACxCyX,EAAM5S,aAAa,GAAK4S,EAAMzX,UAAU,GACxCyX,EAAM5S,aAAa,GAAK4S,EAAMzX,UAAU,GACxCyX,EAAM5S,aAAa,GAAK4S,EAAMzX,UAAU,GACxCyX,EAAM5S,aAAa,GAAK4S,EAAMzX,UAAU,GACxCyX,EAAM5S,aAAa,GAAK4S,EAAMzX,UAAU,GACxCyX,EAAM5S,aAAa,IAAM4S,EAAMzX,UAAU,GACzC,WAAWyX,EAAM5S,aAAc4S,EAAM5S,aAAc4S,EAAMvX,SACzD,YAAYuX,EAAMhT,aAAcgT,EAAM5S,aAAa,EAErD2S,EAAU3S,aAAe,SAAUq3E,GACjC,IAAIC,EAAOta,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,GAE/E,OADA,mBAAmBsa,EAAMD,EAAKzkE,EAAM5S,cAC7Bs3E,CACT,EACA3kE,EAAUmwB,iBAAmBnwB,EAAU3S,aACvC2S,EAAU/S,aAAe,SAAUy3E,GACjC,IAAIC,EAAOta,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,GAE/E,OADA,mBAAmBsa,EAAMD,EAAKzkE,EAAMhT,cAC7B03E,CACT,EACA3kE,EAAU4kE,iBAAmB5kE,EAAU/S,aACvC+S,EAAU6kE,mBAAqB,SAAUC,GACvC,IAAIC,EAAO1a,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,GAC/E,OAAO,qBAA+Bya,EAAK7kE,EAAM5S,aAAc03E,EACjE,EACA/kE,EAAUglE,mBAAqB,SAAUF,GACvC,IAAIC,EAAO1a,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,GAC/E,OAAO,qBAA+Bya,EAAK7kE,EAAMhT,aAAc83E,EACjE,EAGA/kE,EAAUilE,WAAWjlE,EAAUykE,mBAC/BzkE,EAAUykE,oBACVzkE,EAAUklE,UAAY,IAAM,eAAyBllE,EAAUqkE,aAC/DrkE,EAAUmlE,iBAAmB,SAAUC,GACrC,IAAIC,EAAYhb,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,KACpF,MAAMhU,EAAS,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAC/Br2C,EAAUglE,mBAAmBI,EAAa/uB,GAC1C,MAAM5hB,EAAS,CAAC,EAAG,EAAG,GAChBC,EAAS,CAAC,EAAG,EAAG,GACtB,yBAAmC2hB,EAAQ5hB,EAAQC,IACnD,OAAYD,EAAQA,IACpB,OAAYC,EAAQA,GACpB,MAAMjsC,EAAauX,EAAUjT,iBAC7B,IAAAkC,GAAYwlC,EAAQ,CAAC,EAAG,EAAG,GAAI,CAAChsC,EAAW,GAAK,EAAGA,EAAW,GAAK,EAAGA,EAAW,GAAK,GAAIgsC,IAC1F,IAAAxlC,GAAYylC,EAAQ,CAAC,EAAG,EAAG,GAAI,CAACjsC,EAAW,GAAK,EAAGA,EAAW,GAAK,EAAGA,EAAW,GAAK,GAAIisC,GAC1F,MAAM4wC,EAAU78E,EAAW,GACrB88E,EAAU98E,EAAW,GAAKA,EAAW,GACrC+8E,EAASxlE,EAAU1D,eAAeC,aAAaszC,UACrD,IAAI41B,GAAU,IACVC,EAAUjzC,IACVkzC,EAAe,EACfC,EAAO,EACPC,EAAO,EACX,IAAK,IAAIhvB,EAAIpiB,EAAO,GAAIoiB,GAAKniB,EAAO,GAAImiB,IACtC,IAAK,IAAI79C,EAAIy7B,EAAO,GAAIz7B,GAAK07B,EAAO,GAAI17B,IAAK,CAC3C,IAAI5K,EAAQqmC,EAAO,GAAKz7B,EAAIssE,EAAUzuB,EAAI0uB,EAC1C,IAAK,IAAIjxE,EAAImgC,EAAO,GAAIngC,GAAKogC,EAAO,GAAIpgC,IAAK,CAC3C,IAAK+wE,GAAaA,EAAU,CAAC/wE,EAAG0E,EAAG69C,GAAIR,GAAS,CAC9C,MAAMyvB,EAAQN,EAAOp3E,GACjB03E,EAAQL,IAASA,EAAUK,GAC3BA,EAAQJ,IAASA,EAAUI,GAC/BH,GAAgBG,EAAQA,EACxBF,GAAQE,EACRD,GAAQ,CACV,GACEz3E,CACJ,CACF,CAEF,MAAM23E,EAAUF,EAAO,EAAID,EAAOC,EAAO,EACnCG,EAAWH,EAAOpjF,KAAK6uC,IAAIq0C,EAAeE,EAAOE,EAAUA,GAAW,EAE5E,MAAO,CACLL,UACAD,UACAM,UACAC,WACAC,MANYxjF,KAAKiZ,KAAKsqE,GAOtB1nC,MAAOunC,EAEX,EAIA7lE,EAAUkmE,kBAAoB,SAAU9F,GAEtC,MAAM+F,EAAa,GACnB,IAAIC,EAFqB/b,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,EAM7F,IAAK,IAAIrrB,EAAM,EAAGA,EAAM,IAAKA,EAC3BmnC,EAAWnnC,GAAOonC,EAClBA,GAAQhG,EAAa,EAANphC,EAAU,GAAKohC,EAAa,EAANphC,GAAW,EAElD,OAAOmnC,CACT,EAMAnmE,EAAUqmE,mBAAqBC,IAC7B,IAAKz7E,EAAGu5C,EAAGqM,GAAK61B,EAChB,MAAMlG,EAASpgE,EAAUqgE,YACnBzvD,EAAqB5Q,EAAU1D,eAAeC,aAAaC,wBAC3D2pE,EAAanmE,EAAUkmE,kBAAkB9F,EAAQxvD,GAIvD,OAAOnuB,KAAK6O,OAAO7O,KAAKC,MAAMmI,GAAKu1E,EAAO,IAAM+F,EAAW,IAAM1jF,KAAKC,MAAM0hD,GAAKg8B,EAAO,IAAM+F,EAAW,IAAM1jF,KAAKC,MAAM+tD,GAAK2vB,EAAO,IAAM+F,EAAW,GAAG,EAO5JnmE,EAAUumE,wBAA0BC,IAClC,MAAMpG,EAASpgE,EAAUqgE,YACnBjyE,EAAQ4R,EAAU/S,aAAau5E,GAGrC,IAAK,IAAIxnC,EAAM,EAAGA,EAAM,IAAKA,EAC3B,GAAI5wC,EAAM4wC,GAAOohC,EAAa,EAANphC,IAAY5wC,EAAM4wC,GAAOohC,EAAa,EAANphC,EAAU,GAEhE,OADA0jC,EAAc,2BAA2Bt0E,wCAA4CgyE,KAC9El/B,IAKX,OAAOlhC,EAAUqmE,mBAAmBj4E,EAAM,EAO5C4R,EAAU63C,wBAA0B,SAAU2uB,GAC5C,IAAIC,EAAOpc,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,EAC/E,MAAMz5C,EAAqB5Q,EAAU1D,eAAeC,aAAaC,wBACjE,GAAIiqE,EAAO,GAAKA,GAAQ71D,EAEtB,OADA8xD,EAAc,sCAAsC+D,8DAAiE71D,KAC9GswB,IAET,MAAMwlC,EAAc1mE,EAAUumE,wBAAwBC,GACtD,OAAI/1E,OAAO7N,MAAM8jF,GAERA,EAEF1mE,EAAU1D,eAAeC,aAAaoqE,aAAaD,EAAaD,EACzE,CACF,CA0CEG,CAAa5mE,EAAWC,EAC1B,CAQA,IAAI4mE,EAAiB,CACnBrmE,YALkB,EAAA67D,EAAM77D,YAAYT,EAAQ,gBAM5CA,4DC/WF,MAAM,cACJ2iE,GACE,EAAArG,EAohBJ,MAAMx8D,EAAiB,CAErBtP,MAAO,CAAC,EAAG,GACXu2E,UAAU,EACVC,uBAAuB,GAKzB,SAAShnE,EAAOC,EAAWC,GACzB,IAAIC,EAAgBmqD,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzF38D,OAAOyS,OAAOF,EAAOJ,EAAgBK,GAGrC,EAAAm8D,EAAMvS,IAAI9pD,EAAWC,GAGrBA,EAAMoZ,MAAQ,GAGd,EAAAgjD,EAAM2K,OAAOhnE,EAAWC,EAAO,CAAC,wBAAyB,aACzD,EAAAo8D,EAAM4K,SAASjnE,EAAWC,EAAO,CAAC,SAAU,GAG5C,EAAAo8D,EAAMyG,SAAS9iE,EAAWC,EAAO,CAAC,UAtiBpC,SAA8BD,EAAWC,GAEvCA,EAAMG,eAAe3N,KAAK,wBAG1BuN,EAAUiZ,QAAU,IAAMhZ,EAAMoZ,MAAM1tB,OAUtCqU,EAAUknE,QAAU,KAClB,IAAI/lE,EACAgmE,EAAY,EACZC,EAAe,EACfnnE,EAAMoZ,MAAM1tB,OAAS,IACvBw7E,EAAYlnE,EAAMoZ,MAAM,GAAGrgB,GAE7B,IAAK,IAAInO,EAAI,EAAGA,EAAIoV,EAAMoZ,MAAM1tB,OAAQd,IAAK,CAI3C,GAHAsW,EAAQlB,EAAMoZ,MAAMxuB,GAAGmO,EAGnBmI,IAAUgmE,EACZ,GAAIhmE,EAAQgmE,EACV,OAAQC,GACN,KAAK,EACL,KAAK,EAEHA,EAAe,EACf,MAEF,QAEEA,EAAe,OAKnB,OAAQA,GACN,KAAK,EACL,KAAK,EAEHA,EAAe,EACf,MAEF,QAEEA,EAAe,EAQvB,GAHAD,EAAYhmE,EAGS,IAAjBimE,EACF,KAEJ,CACA,OAAQA,GACN,KAAK,EACH,MAAO,WACT,KAAK,EACH,MAAO,gBACT,KAAK,EACH,MAAO,gBAET,QACE,MAAO,SACX,EAMFpnE,EAAUqY,eAAiB,KACzB,MAAMlO,EAAOlK,EAAMoZ,MAAM1tB,OAEzB,GADAsU,EAAMonE,SAAW,KACbl9D,EAAO,EAAG,CACZlK,EAAMonE,SAAW,GACjB,IAAK,IAAIx8E,EAAI,EAAGA,EAAIsf,EAAMtf,IACxBoV,EAAMonE,SAAS,EAAIx8E,GAAKoV,EAAMoZ,MAAMxuB,GAAGyJ,EACvC2L,EAAMonE,SAAS,EAAIx8E,EAAI,GAAKoV,EAAMoZ,MAAMxuB,GAAGmO,CAE/C,CACA,OAAOiH,EAAMonE,QAAQ,EAKvBrnE,EAAUsnE,qBAAuB,KAE/B,GAA2B,IAAvBrnE,EAAMoZ,MAAM1tB,OACd,OAAO,EAET,IAAI47E,EAAU,EACVjzE,EAAI,EACJzJ,EAAI,EACR,KAAOA,EAAIoV,EAAMoZ,MAAM1tB,OAAQd,IAC7B,GAAyB,IAArBoV,EAAMoZ,MAAMxuB,GAAGmO,EAAW,CAC5BuuE,EAAU,EACV,KACF,CAmBF,OAbEjzE,EADEizE,EACE92E,OAAO+2E,UACF38E,EAAI,EAGToV,EAAMoZ,MAAMxuB,EAAI,GAAGyJ,EACd2L,EAAM6mE,UAIVr2E,OAAO+2E,UAERvnE,EAAMoZ,MAAM,GAAG/kB,EAEdA,CAAC,EAIV0L,EAAUmZ,aAAe,CAAC/qB,EAAOmlC,KAC/B,MAAMppB,EAAOlK,EAAMoZ,MAAM1tB,OACzB,OAAIyC,EAAQ,GAAKA,GAAS+b,GACxBu4D,EAAc,wBACN,IAEVnvC,EAAI,GAAKtzB,EAAMoZ,MAAMjrB,GAAOkG,EAC5Bi/B,EAAI,GAAKtzB,EAAMoZ,MAAMjrB,GAAO4K,EAC5Bu6B,EAAI,GAAKtzB,EAAMoZ,MAAMjrB,GAAOo9C,SAC5BjY,EAAI,GAAKtzB,EAAMoZ,MAAMjrB,GAAOq5E,UACrB,EAAC,EAIVznE,EAAU0nE,aAAe,CAACt5E,EAAOmlC,KAC/B,MAAMppB,EAAOlK,EAAMoZ,MAAM1tB,OACzB,GAAIyC,EAAQ,GAAKA,GAAS+b,EAExB,OADAu4D,EAAc,wBACN,EAEV,MAAMiF,EAAO1nE,EAAMoZ,MAAMjrB,GAAOkG,EAchC,OAbA2L,EAAMoZ,MAAMjrB,GAAOkG,EAAIi/B,EAAI,GAC3BtzB,EAAMoZ,MAAMjrB,GAAO4K,EAAIu6B,EAAI,GAC3BtzB,EAAMoZ,MAAMjrB,GAAOo9C,SAAWjY,EAAI,GAClCtzB,EAAMoZ,MAAMjrB,GAAOq5E,UAAYl0C,EAAI,GAC/Bo0C,IAASp0C,EAAI,GAGfvzB,EAAU4nE,qBAIV5nE,EAAU68D,WAEL,CAAC,EAOV78D,EAAU6nE,SAAW,CAACvzE,EAAG0E,IAAMgH,EAAU8nE,aAAaxzE,EAAG0E,EAAG,GAAK,GAGjEgH,EAAU8nE,aAAe,CAACxzE,EAAG0E,EAAGwyC,EAAUi8B,KAExC,GAAIj8B,EAAW,GAAOA,EAAW,EAE/B,OADAk3B,EAAc,sCACN,EAEV,GAAI+E,EAAY,GAAOA,EAAY,EAEjC,OADA/E,EAAc,uCACN,EAILziE,EAAM8mE,uBACT/mE,EAAU+nE,YAAYzzE,GAIxB,MAAMilB,EAAO,CACXjlB,IACA0E,IACAwyC,WACAi8B,aAQF,IAAI58E,EACJ,IALAoV,EAAMoZ,MAAM5mB,KAAK8mB,GACjBvZ,EAAU4nE,qBAIL/8E,EAAI,EAAGA,EAAIoV,EAAMoZ,MAAM1tB,QACtBsU,EAAMoZ,MAAMxuB,GAAGyJ,IAAMA,EADSzJ,KAQpC,OAAIA,EAAIoV,EAAMoZ,MAAM1tB,OACXd,GAED,CAAC,EAEXmV,EAAUgoE,SAAW3uD,IACfpZ,EAAMoZ,QAAUA,IAClBpZ,EAAMoZ,MAAQA,EACdrZ,EAAU4nE,qBACZ,EAKF5nE,EAAU4nE,mBAAqB,KAC7B3nE,EAAMoZ,MAAM9jB,MAAK,CAACZ,EAAGC,IAAMD,EAAEL,EAAIM,EAAEN,IACX0L,EAAUioE,eAGhCjoE,EAAU68D,UACZ,EAIF78D,EAAUioE,YAAc,KACtB,MAAMC,EAAWjoE,EAAM1P,MAAMkR,QACvB0I,EAAOlK,EAAMoZ,MAAM1tB,OASzB,OARIwe,GACFlK,EAAM1P,MAAM,GAAK0P,EAAMoZ,MAAM,GAAG/kB,EAChC2L,EAAM1P,MAAM,GAAK0P,EAAMoZ,MAAMlP,EAAO,GAAG7V,IAEvC2L,EAAM1P,MAAM,GAAK,EACjB0P,EAAM1P,MAAM,GAAK,IAGf23E,EAAS,KAAOjoE,EAAM1P,MAAM,IAAM23E,EAAS,KAAOjoE,EAAM1P,MAAM,MAGlEyP,EAAU68D,YACH,EAAI,EAKb78D,EAAU+nE,YAAczzE,IAGtB,IAAIzJ,EACJ,IAAKA,EAAI,EAAGA,EAAIoV,EAAMoZ,MAAM1tB,QACtBsU,EAAMoZ,MAAMxuB,GAAGyJ,IAAMA,EADSzJ,KAOpC,GAAIA,GAAKoV,EAAMoZ,MAAM1tB,OACnB,OAAQ,EAEV,MAAMw8E,EAASt9E,EAIf,IAAIu9E,GAAkB,EAQtB,OAPAnoE,EAAMoZ,MAAM11B,OAAOkH,EAAG,GACZ,IAANA,GAAWA,IAAMoV,EAAMoZ,MAAM1tB,SAC/By8E,EAAkBpoE,EAAUioE,eAEzBG,GACHpoE,EAAU68D,WAELsL,CAAM,EAIfnoE,EAAUsZ,gBAAkB,KAC1BrZ,EAAMoZ,MAAQ,GACdrZ,EAAU4nE,oBAAoB,EAKhC5nE,EAAUqoE,WAAa,CAAC7mC,EAAIhtC,EAAIitC,EAAIC,KAElC1hC,EAAU4nE,qBACV,IAAK,IAAI/8E,EAAI,EAAGA,EAAIoV,EAAMoZ,MAAM1tB,QAC1BsU,EAAMoZ,MAAMxuB,GAAGyJ,GAAKktC,GAAMvhC,EAAMoZ,MAAMxuB,GAAGyJ,GAAKmtC,EAChDxhC,EAAMoZ,MAAM11B,OAAOkH,EAAG,GAEtBA,IAKJmV,EAAU6nE,SAASrmC,EAAIhtC,EAAI,GAAK,GAChCwL,EAAU6nE,SAASpmC,EAAIC,EAAI,GAAK,EAAI,EAItC1hC,EAAUsoE,SAAWh0E,IACnB,MAAMi0E,EAAQ,GAEd,OADAvoE,EAAUwoE,SAASl0E,EAAGA,EAAG,EAAGi0E,GACrBA,EAAM,EAAE,EAMjBvoE,EAAUyoE,YAAcl4E,IACtB,GAAIA,EAAM5E,OAAS,EACjB,OAAO,EAET,MAAM+8E,EAAgB1oE,EAAUpT,WAG5B87E,EAAc,GAAKn4E,EAAM,GAC3ByP,EAAU6nE,SAASt3E,EAAM,GAAIyP,EAAUsoE,SAAS/3E,EAAM,KAEtDyP,EAAU6nE,SAASt3E,EAAM,GAAIyP,EAAUsoE,SAASI,EAAc,KAE5DA,EAAc,GAAKn4E,EAAM,GAC3ByP,EAAU6nE,SAASt3E,EAAM,GAAIyP,EAAUsoE,SAAS/3E,EAAM,KAEtDyP,EAAU6nE,SAASt3E,EAAM,GAAIyP,EAAUsoE,SAASI,EAAc,KAIhE1oE,EAAU4nE,qBACV,IAAK,IAAI/8E,EAAI,EAAGA,EAAIoV,EAAMoZ,MAAM1tB,QAC1BsU,EAAMoZ,MAAMxuB,GAAGyJ,GAAK/D,EAAM,IAAM0P,EAAMoZ,MAAMxuB,GAAGyJ,GAAK/D,EAAM,GAC5D0P,EAAMoZ,MAAM11B,OAAOkH,EAAG,KAEpBA,EAIN,OADAmV,EAAU4nE,qBACH,CAAC,EAIV5nE,EAAU2oE,2BAA6B,CAACnnC,EAAIC,KAC1C,MAAMmnC,EAAI5oE,EAAU6oE,uBACpB,OAAOpmF,KAAKqmF,MAAMrnC,EAAKD,GAAMonC,EAAE,EAIjC5oE,EAAU6oE,qBAAuB,KAC/B,MAAM1+D,EAAOlK,EAAMoZ,MAAM1tB,OACzB,GAAIwe,EAAO,EACT,OAAQ,EAEV,IAAIkmB,EAAWpwB,EAAMoZ,MAAM,GAAG/kB,EAAI2L,EAAMoZ,MAAM,GAAG/kB,EACjD,IAAK,IAAIzJ,EAAI,EAAGA,EAAIsf,EAAO,EAAGtf,IAAK,CACjC,MAAMk+E,EAAc9oE,EAAMoZ,MAAMxuB,EAAI,GAAGyJ,EAAI2L,EAAMoZ,MAAMxuB,GAAGyJ,EACtDy0E,EAAc14C,IAChBA,EAAW04C,EAEf,CACA,OAAO14C,CAAQ,EAMjBrwB,EAAUwoE,SAAW,SAAUQ,EAAQC,EAAM9+D,EAAMo+D,GACjD,IACI19E,EADAq+E,EAAS7e,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,EAE7ErrB,EAAM,EACV,MAAMmqC,EAAWlpE,EAAMoZ,MAAM1tB,OAK7B,IAAIy9E,EAAY,EACC,IAAbD,IACFC,EAAYnpE,EAAMoZ,MAAM8vD,EAAW,GAAGnwE,GAExC,IAAI1E,EAAI,EACJktC,EAAK,EACLC,EAAK,EACLjtC,EAAK,EACLktC,EAAK,EACL8J,EAAW,EACXi8B,EAAY,EAGhB,IAAK58E,EAAI,EAAGA,EAAIsf,EAAMtf,IAAK,CAEzB,MAAMw+E,EAAOH,EAASr+E,EAYtB,IANEyJ,EADE6V,EAAO,EACL6+D,EAASn+E,GAAKsf,EAAO,IAAQ8+D,EAAOD,GAEpC,IAAOA,EAASC,GAIfjqC,EAAMmqC,GAAY70E,EAAI2L,EAAMoZ,MAAM2lB,GAAK1qC,GAC5C0qC,IAKIA,EAAMmqC,IACR3nC,EAAKvhC,EAAMoZ,MAAM2lB,EAAM,GAAG1qC,EAC1BmtC,EAAKxhC,EAAMoZ,MAAM2lB,GAAK1qC,EACtBE,EAAKyL,EAAMoZ,MAAM2lB,EAAM,GAAGhmC,EAC1B0oC,EAAKzhC,EAAMoZ,MAAM2lB,GAAKhmC,EAItBwyC,EAAWvrC,EAAMoZ,MAAM2lB,EAAM,GAAGwM,SAChCi8B,EAAYxnE,EAAMoZ,MAAM2lB,EAAM,GAAGyoC,UAI7Bj8B,EAAW,OACbA,EAAW,MAETA,EAAW,SACbA,EAAW,SAMjB,GAAIxM,GAAOmqC,EACTZ,EAAMc,GAAQppE,EAAM6mE,SAAWsC,EAAY,OACtC,GAAY,IAARpqC,EAETupC,EAAMc,GAAQppE,EAAM6mE,SAAW7mE,EAAMoZ,MAAM,GAAGrgB,EAAI,MAC7C,CAML,IAAIw1D,GAAKl6D,EAAIktC,IAAOC,EAAKD,GAWzB,GAPEgtB,EADEA,EAAIhjB,EACF,GAAMgjB,EAAIhjB,EAEV,GAAM,IAAOgjB,EAAIhjB,IAAa,EAAMA,GAKtCi8B,EAAY,IAAM,CAEpB,GAAIjZ,EAAI,GAAK,CACX+Z,EAAMc,GAAQ70E,EACd,QACF,CAEE+zE,EAAMc,GAAQ3nC,EACd,QAEJ,CAIA,GAAI+lC,EAAY,IAAM,CAEpBc,EAAMc,IAAS,EAAI7a,GAAKh6D,EAAKg6D,EAAI9sB,EACjC,QACF,CASI8sB,EAAI,GACNA,EAAI,IAAW,EAAJA,KAAW,EAAM,GAAKiZ,GACxBjZ,EAAI,KACbA,EAAI,EAAM,IAAmB,GAAX,EAAMA,MAAY,EAAI,GAAKiZ,IAI/C,MAAM6B,EAAK9a,EAAIA,EACT+a,EAAMD,EAAK9a,EACXgb,EAAK,EAAID,EAAM,EAAID,EAAK,EACxBG,GAAM,EAAIF,EAAM,EAAID,EACpBI,EAAKH,EAAM,EAAID,EAAK9a,EACpBmb,EAAKJ,EAAMD,EAIXp6B,GAAK,EAAMu4B,IADH/lC,EAAKltC,GAInB+zE,EAAMc,GAAQG,EAAKh1E,EAAKi1E,EAAK/nC,EAAKgoC,EAAKx6B,EAAIy6B,EAAKz6B,EAIhD,MAAM91C,EAAM5E,EAAKktC,EAAKltC,EAAKktC,EACrB3yC,EAAMyF,EAAKktC,EAAKltC,EAAKktC,EAC3B6mC,EAAMc,GAAQd,EAAMc,GAAQjwE,EAAMA,EAAMmvE,EAAMc,GAC9Cd,EAAMc,GAAQd,EAAMc,GAAQt6E,EAAMA,EAAMw5E,EAAMc,EAChD,CACF,CACF,CACF,CAqCEO,CAAqB5pE,EAAWC,EAClC,CAQA,IAAI4pE,EAAyB,CAC3BrpE,YALkB,EAAA67D,EAAM77D,YAAYT,EAAQ,wBAM5CA,sEC7jBF,MAAM+pE,EAAkB,KAClBC,EAAW,WACXC,EAAW,WASjB,SAASC,EAAgB31E,EAAGzM,EAAQo2D,GAClC,MAAM5tB,EAAW4tB,EAAO,IAAM3pD,EAAE,GAAKzM,EAAO,IAAMo2D,EAAO,IAAM3pD,EAAE,GAAKzM,EAAO,IAAMo2D,EAAO,IAAM3pD,EAAE,GAAKzM,EAAO,IAC9G,OAAOpF,KAAK6uC,IAAIjB,EAClB,CACA,SAAS65C,EAAa51E,EAAGzM,EAAQo2D,EAAQksB,GACvC,MAAMC,EAAK,IACX,IAAA5b,GAASl6D,EAAGzM,EAAQuiF,GACpB,MAAMl7B,GAAI,IAAA05B,GAAI3qB,EAAQmsB,GACtBD,EAAM,GAAK71E,EAAE,GAAK46C,EAAI+O,EAAO,GAC7BksB,EAAM,GAAK71E,EAAE,GAAK46C,EAAI+O,EAAO,GAC7BksB,EAAM,GAAK71E,EAAE,GAAK46C,EAAI+O,EAAO,EAC/B,CACA,SAASosB,EAAcxR,EAAG5a,EAAQqsB,GAChC,MAAMp7B,GAAI,IAAA05B,GAAI/P,EAAG5a,GACjB,IAAIssB,GAAK,IAAA3B,GAAI3qB,EAAQA,GAOrB,OANW,IAAPssB,IACFA,EAAK,GAEPD,EAAM,GAAKzR,EAAE,GAAK3pB,EAAI+O,EAAO,GAAKssB,EAClCD,EAAM,GAAKzR,EAAE,GAAK3pB,EAAI+O,EAAO,GAAKssB,EAClCD,EAAM,GAAKzR,EAAE,GAAK3pB,EAAI+O,EAAO,GAAKssB,EAC3BD,CACT,CACA,SAASE,EAAwBl2E,EAAGzM,EAAQo2D,EAAQksB,GAClD,MAAMC,EAAK,IACX,IAAA5b,GAASl6D,EAAGzM,EAAQuiF,GACpB,MAAMl7B,GAAI,IAAA05B,GAAI3qB,EAAQmsB,GAChBG,GAAK,IAAA3B,GAAI3qB,EAAQA,GACZ,IAAPssB,GACFJ,EAAM,GAAK71E,EAAE,GAAK46C,EAAI+O,EAAO,GAAKssB,EAClCJ,EAAM,GAAK71E,EAAE,GAAK46C,EAAI+O,EAAO,GAAKssB,EAClCJ,EAAM,GAAK71E,EAAE,GAAK46C,EAAI+O,EAAO,GAAKssB,IAElCJ,EAAM,GAAK71E,EAAE,GACb61E,EAAM,GAAK71E,EAAE,GACb61E,EAAM,GAAK71E,EAAE,GAEjB,CACA,SAASm2E,EAAkB3nC,EAAIC,EAAIl7C,EAAQo2D,GACzC,MAAMysB,EAAS,CACbz/B,cAAc,EACd0/B,eAAe,EACfz7B,EAAGz+C,OAAO+2E,UACVlzE,EAAG,IAECs2E,EAAM,GACNC,EAAW,IAEjB,IAAArc,GAASzrB,EAAID,EAAI8nC,IACjB,IAAApc,GAAS3mE,EAAQi7C,EAAI+nC,GAIrB,MAAMnoC,GAAM,IAAAkmC,GAAI3qB,EAAQ4sB,GAClBC,GAAM,IAAAlC,GAAI3qB,EAAQ2sB,GAIxB,IAAIG,EACAC,EAaJ,OATED,EADED,EAAM,GACGA,EAEDA,EAGVE,EADEtoC,EAAM,GACSA,EAAMonC,EAEPpnC,EAAMonC,EAEpBiB,GAAWC,IAMfN,EAAOx7B,EAAIxM,EAAMooC,EACjBJ,EAAOp2E,EAAE,GAAKwuC,EAAG,GAAK4nC,EAAOx7B,EAAI07B,EAAI,GACrCF,EAAOp2E,EAAE,GAAKwuC,EAAG,GAAK4nC,EAAOx7B,EAAI07B,EAAI,GACrCF,EAAOp2E,EAAE,GAAKwuC,EAAG,GAAK4nC,EAAOx7B,EAAI07B,EAAI,GACrCF,EAAOz/B,cAAe,EACtBy/B,EAAOC,cAAgBD,EAAOx7B,GAAK,GAAOw7B,EAAOx7B,GAAK,GAV7Cw7B,CAYX,CACA,SAASO,EAAmBC,EAAcC,EAAcC,EAAcC,GACpE,MAAMX,EAAS,CACbz/B,cAAc,EACdqgC,GAAI,GACJC,GAAI,GACJpjE,MAAO,MAEHqjE,EAAU,IAChB,OAAML,EAAcE,EAAcG,GAClC,MAAMC,EAAWD,EAAQpnF,KAAIyQ,GAAKpS,KAAK6uC,IAAIz8B,KAG3C,GAAI42E,EAAS,GAAKA,EAAS,GAAKA,EAAS,GAAK3B,EAAiB,CAE7D,MAAMjR,EAAI,GAOV,OANA,IAAArK,GAAS0c,EAAcE,EAAcvS,GACR,KAAzB,IAAA+P,GAAIuC,EAActS,GACpB6R,EAAOviE,MAAQ4hE,EAEfW,EAAOviE,MAAQ6hE,EAEVU,CACT,CAIA,IAAIgB,EAEFA,EADED,EAAS,GAAKA,EAAS,IAAMA,EAAS,GAAKA,EAAS,GAC/C,IACEA,EAAS,GAAKA,EAAS,GACzB,IAEA,IAIT,MAAME,EAAK,GAELC,IAAM,IAAAhD,GAAIuC,EAAcD,GACxBW,IAAM,IAAAjD,GAAIyC,EAAcD,GAG9B,OAAQM,GACN,IAAK,IAEHC,EAAG,GAAK,EACRA,EAAG,IAAME,EAAKV,EAAa,GAAKS,EAAKP,EAAa,IAAMG,EAAQ,GAChEG,EAAG,IAAMC,EAAKP,EAAa,GAAKQ,EAAKV,EAAa,IAAMK,EAAQ,GAChE,MACF,IAAK,IAEHG,EAAG,IAAMC,EAAKP,EAAa,GAAKQ,EAAKV,EAAa,IAAMK,EAAQ,GAChEG,EAAG,GAAK,EACRA,EAAG,IAAME,EAAKV,EAAa,GAAKS,EAAKP,EAAa,IAAMG,EAAQ,GAChE,MACF,IAAK,IAEHG,EAAG,IAAME,EAAKV,EAAa,GAAKS,EAAKP,EAAa,IAAMG,EAAQ,GAChEG,EAAG,IAAMC,EAAKP,EAAa,GAAKQ,EAAKV,EAAa,IAAMK,EAAQ,GAChEG,EAAG,GAAK,EAMZ,OAHAjB,EAAOY,GAAKK,GACZ,OAAIA,EAAIH,EAASd,EAAOa,IACxBb,EAAOz/B,cAAe,EACfy/B,CACT,CAMA,MAAMoB,EAAS,CACbC,SAlKF,SAAkB9tB,EAAQp2D,EAAQyM,GAChC,OAAO2pD,EAAO,IAAM3pD,EAAE,GAAKzM,EAAO,IAAMo2D,EAAO,IAAM3pD,EAAE,GAAKzM,EAAO,IAAMo2D,EAAO,IAAM3pD,EAAE,GAAKzM,EAAO,GACtG,EAiKEoiF,kBACAC,eACAG,gBACAG,0BACAC,oBACAQ,qBACAjB,WACAD,YA4CF,MAAMlqE,EAAiB,CACrBo+C,OAAQ,CAAC,EAAK,EAAK,GACnBp2D,OAAQ,CAAC,EAAK,EAAK,IAKrB,SAASkY,EAAOC,EAAWC,GACzB,IAAIC,EAAgBmqD,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzF38D,OAAOyS,OAAOF,EAAOJ,EAAgBK,GAGrC,EAAAm8D,EAAMvS,IAAI9pD,EAAWC,GACrB,EAAAo8D,EAAMwG,YAAY7iE,EAAWC,EAAO,CAAC,SAAU,UAAW,GAlD5D,SAAkBD,EAAWC,GAE3BA,EAAMG,eAAe3N,KAAK,YAC1BuN,EAAUiqE,gBAAkB31E,GAAK21E,EAAgB31E,EAAG2L,EAAMpY,OAAQoY,EAAMg+C,QACxEj+C,EAAUkqE,aAAe,CAAC51E,EAAG61E,KAC3BD,EAAa51E,EAAG2L,EAAMpY,OAAQoY,EAAMg+C,OAAQksB,EAAM,EAEpDnqE,EAAUqqE,cAAgB,CAACxR,EAAGyR,IAAUD,EAAcxR,EAAG54D,EAAMg+C,OAAQqsB,GACvEtqE,EAAUvN,KAAO49B,IACf,GAAiB,IAAbA,EAGJ,IAAK,IAAIxlC,EAAI,EAAGA,EAAI,EAAGA,IACrBoV,EAAMpY,OAAOgD,IAAMwlC,EAAWpwB,EAAMg+C,OAAOpzD,EAC7C,EAEFmV,EAAUwqE,wBAA0B,CAACl2E,EAAG61E,KACtCK,EAAwBl2E,EAAG2L,EAAMpY,OAAQoY,EAAMg+C,OAAQksB,EAAM,EAE/DnqE,EAAUgsE,iBAAmB,CAAC13E,EAAG0E,EAAG69C,IAC7B1tD,MAAMC,QAAQkL,GAGZ2L,EAAMg+C,OAAO,IAAM3pD,EAAE,GAAK2L,EAAMpY,OAAO,IAAMoY,EAAMg+C,OAAO,IAAM3pD,EAAE,GAAK2L,EAAMpY,OAAO,IAAMoY,EAAMg+C,OAAO,IAAM3pD,EAAE,GAAK2L,EAAMpY,OAAO,IAF/HoY,EAAMg+C,OAAO,IAAM3pD,EAAI2L,EAAMpY,OAAO,IAAMoY,EAAMg+C,OAAO,IAAMjlD,EAAIiH,EAAMpY,OAAO,IAAMoY,EAAMg+C,OAAO,IAAMpH,EAAI52C,EAAMpY,OAAO,IAInImY,EAAUisE,iBAAmBzF,GACZ,CAACvmE,EAAMg+C,OAAO,GAAIh+C,EAAMg+C,OAAO,GAAIh+C,EAAMg+C,OAAO,IAGjEj+C,EAAUyqE,kBAAoB,CAAC3nC,EAAIC,IAAO0nC,EAAkB3nC,EAAIC,EAAI9iC,EAAMpY,OAAQoY,EAAMg+C,QACxFj+C,EAAUirE,mBAAqB,CAACiB,EAAaC,IAAgBlB,EAAmBiB,EAAaC,EAAalsE,EAAMpY,OAAQoY,EAAMg+C,OAChI,CAoBEmuB,CAASpsE,EAAWC,EACtB,CAQA,IAAIosE,EAAa,CACf7rE,YALkB,EAAA67D,EAAM77D,YAAYT,EAAQ,YAM5CA,YACG+rE,oECtPL,MAAM,cACJpJ,EAAa,cACb4J,GACE,EAAAjQ,EAMJ,SAASkQ,EAAwBvsE,EAAWC,GAmB1CA,EAAMG,eAAe3N,KAAK,2BAM1BuN,EAAUwsE,iBAAmB,IAAMvsE,EAAMwsE,cAMzCzsE,EAAU0sE,iBAAmBC,IAC3B1sE,EAAMwsE,cAAgBE,EACtB3sE,EAAU68D,UAAU,EAEtB,MAAM+P,EAAM,GACNC,EAAe,GACfC,EAAW,GACXC,EAAc,IAAevsE,cAWnCR,EAAUgtE,gBAAkB,CAACrJ,EAAKH,EAAMyJ,EAAS9G,EAAY+G,EAASC,KACpE,MAAOtiF,EAAGu5C,EAAGqM,GAAKkzB,EAGlBiJ,EAAI,GAAKn8B,EAAI+yB,EAAK,GAAKA,EAAK,GAAKp/B,EAAIo/B,EAAK,GAAK34E,EAC/C+hF,EAAI,GAAKA,EAAI,GAAKzG,EAAW+G,GAC7BN,EAAI,GAAKA,EAAI,GAAKzG,EAAWgH,GAC7BP,EAAI,GAAKA,EAAI,GAAKzG,EAAW+G,GAG7B,IAAK,IAAIE,EAAK,EAAGA,EAAK,IAAKA,EACzBP,EAAaO,GAAMH,EAAQL,EAAIQ,GACjC,EAWFptE,EAAUqtE,eAAiB,CAAC1J,EAAK97E,EAAQa,EAASwkF,EAASC,KACzD,MAAMtiF,EAAI84E,EAAIuJ,GACR9oC,EAAIu/B,EAAIwJ,GAGdL,EAAS,GAAKjlF,EAAOqlF,GAAWriF,EAAInC,EAAQwkF,GAC5CJ,EAAS,GAAKjlF,EAAOslF,GAAW/oC,EAAI17C,EAAQykF,GAC5CL,EAAS,GAAKA,EAAS,GAAKpkF,EAAQwkF,GACpCJ,EAAS,GAAKA,EAAS,GACvBA,EAAS,GAAKA,EAAS,GACvBA,EAAS,GAAKA,EAAS,GAAKpkF,EAAQykF,GACpCL,EAAS,GAAKA,EAAS,GACvBA,EAAS,GAAKA,EAAS,EAAE,EAiB3B9sE,EAAUstE,aAAe,CAACC,EAAM5J,EAAKH,EAAM37E,EAAQa,EAASukF,EAASptD,EAAQ0iD,EAAO4D,EAAY+G,EAASC,KACvG,MAAM18B,EAAIkzB,EAAI1jE,EAAMutE,aACdC,EAAY,CAAC,EAAG,EAAG,EAAG,GACtBjH,EAAM,GACZ,IAAIkH,EACJ1tE,EAAUgtE,gBAAgBrJ,EAAKH,EAAMyJ,EAAS9G,EAAY+G,EAASC,GACnE,IAAI/+E,EAAQ,EACZ,IAAK,IAAI4wC,EAAM,EAAGA,EAAM,EAAGA,IACrB6tC,EAAa7tC,IAAQuuC,IACvBn/E,GAASq/E,EAAUzuC,IAIvB,MAAM2uC,EAAa,IAAaC,QAAQx/E,GACxC,GAAIu/E,EAAW,GAAK,EAClB,OAGF3tE,EAAUqtE,eAAe1J,EAAK97E,EAAQa,EAASwkF,EAASC,GACxD,MAAMt2B,EAAIhvD,EAAOoY,EAAMutE,aAAe/8B,EAAI/nD,EAAQuX,EAAMutE,aACxD,IAAK,IAAIxuC,EAAM,EAAG2uC,EAAW3uC,IAAQ,EAAGA,GAAO,EAAG,CAChDujC,EAAM9vE,KAAK,GACX,IAAK,IAAIo7E,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAChC,MAAMC,EAAY,IAAaC,QAAQJ,EAAW3uC,EAAM6uC,IAKxD,GAJAH,OAAM5hF,EACFmU,EAAM+tE,cACRN,EAAMX,EAAYkB,eAAerB,EAAIkB,EAAU,IAAKlB,EAAIkB,EAAU,MAAM3sE,YAE9DrV,IAAR4hF,EAAmB,CACrB,MAAMx+B,GAAKq+B,EAAOV,EAAaiB,EAAU,MAAQjB,EAAaiB,EAAU,IAAMjB,EAAaiB,EAAU,KAC/FI,EAAKpB,EAASrrE,MAAqB,EAAfqsE,EAAU,GAA6B,GAApBA,EAAU,GAAK,IACtDtsC,EAAKsrC,EAASrrE,MAAqB,EAAfqsE,EAAU,GAA6B,GAApBA,EAAU,GAAK,IAC5DtH,EAAI0G,GAAWgB,EAAG,GAAKh/B,GAAK1N,EAAG,GAAK0sC,EAAG,IACvC1H,EAAI2G,GAAWe,EAAG,GAAKh/B,GAAK1N,EAAG,GAAK0sC,EAAG,IACvC1H,EAAIvmE,EAAMutE,aAAe32B,EACzB62B,EAAM7tD,EAAOl0B,OAAS,EACtBk0B,EAAOptB,KAAK+zE,EAAI,GAAIA,EAAI,GAAIA,EAAI,IAC5BvmE,EAAM+tE,aACRjB,EAAYoB,WAAWvB,EAAIkB,EAAU,IAAKlB,EAAIkB,EAAU,IAAKJ,EAEjE,CACAnL,EAAM9vE,KAAKi7E,EACb,CACF,GAEF1tE,EAAUu8D,YAAc,CAACC,EAAQC,KAE/B,MAAMC,EAAQF,EAAO,GACrB,IAAKE,EAEH,YADAgG,EAAc,4BAGhB,GAAyB,MAArBziE,EAAMutE,aAAuBvtE,EAAMutE,YAAc,GAAKvtE,EAAMutE,YAAc,EAE5E,YADA9K,EAAc,mCAGhBxvE,QAAQ1N,KAAK,YAGb,MAAMqC,EAAS60E,EAAM0R,YACf1lF,EAAUg0E,EAAM1vE,aAChBw2E,EAAO9G,EAAM3vE,gBACbqzE,EAAS1D,EAAM2D,YACf8F,EAAazJ,EAAMwJ,kBAAkB9F,GACrC6M,EAAUvQ,EAAMpgE,eAAeC,aAAaszC,WAC3Cq9B,EAASC,GAjKlB,WACE,IAAID,EAAU,EACVC,EAAU,EAQd,OAP0B,IAAtBltE,EAAMutE,aACRN,EAAU,EACVC,EAAU,GACqB,IAAtBltE,EAAMutE,cACfN,EAAU,EACVC,EAAU,GAEL,CAACD,EAASC,EACnB,CAsJ6BkB,GAGrBxuD,EAAS,GAGT0iD,EAAQ,GAGd,IAAI9xB,EAAIhuD,KAAKC,MAAMud,EAAMwB,OACrBgvC,GAAK+yB,EAAKvjE,EAAMutE,eAClB/8B,EAAI,GAIN,MAAMkzB,EAAM,CAAC,EAAG,EAAG,GACnBA,EAAI1jE,EAAMutE,aAAe/8B,EACzB,IAAK,IAAI69B,EAAK,EAAGA,EAAKruE,EAAMwsE,cAAc9gF,SAAU2iF,EAAI,CACtD,IAAK,IAAIlqC,EAAI,EAAGA,EAAIo/B,EAAK2J,GAAW,IAAK/oC,EAAG,CAC1Cu/B,EAAIwJ,GAAW/oC,EACf,IAAK,IAAIv5C,EAAI,EAAGA,EAAI24E,EAAK0J,GAAW,IAAKriF,EACvC84E,EAAIuJ,GAAWriF,EACfmV,EAAUstE,aAAartE,EAAMwsE,cAAc6B,GAAK3K,EAAKH,EAAM37E,EAAQa,EAASukF,EAASptD,EAAQ0iD,EAAO4D,EAAY+G,EAASC,EAE7H,CACAJ,EAAY7Q,YACd,CAGA,MAAMqS,EAAW,mBACjBA,EAASz8B,YAAYisB,QAAQ,IAAI7uD,aAAa2Q,GAAS,GACvD0uD,EAASl9B,WAAW0sB,QAAQ,IAAIta,YAAY8e,IAC5C9F,EAAQ,GAAK8R,EACbjC,EAAc,mBACdp5E,QAAQs7E,QAAQ,WAAW,CAE/B,CAMA,MAAM3uE,EAAiB,CACrB4sE,cAAe,GACfe,YAAa,EACb/rE,MAAO,EACPusE,aAAa,GAKf,SAASjuE,EAAOC,EAAWC,GACzB,IAAIC,EAAgBmqD,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzF38D,OAAOyS,OAAOF,EAAOJ,EAAgBK,GAGrC,EAAAm8D,EAAMvS,IAAI9pD,EAAWC,GAGrB,EAAAo8D,EAAMC,KAAKt8D,EAAWC,EAAO,EAAG,GAChC,EAAAo8D,EAAM2K,OAAOhnE,EAAWC,EAAO,CAAC,cAAe,QAAS,gBAGxD,EAAAo8D,EAAMC,KAAKt8D,EAAWC,EAAO,EAAG,GAChCssE,EAAwBvsE,EAAWC,EACrC,CAIoB,EAAAo8D,EAAM77D,YAAYT,EAAQ,mGCrP9C,MAAM,cACJusE,GACE,EAAAjQ,EAgjBJ,MAAMx8D,EAAiB,CACrB9O,SAAU,CAAC,EAAG,EAAG,GACjBvB,WAAY,CAAC,EAAG,EAAG,GACnBwB,OAAQ,CAAC,EAAG,EAAG,GACfy9E,sBAAuB,CAAC,EAAG,GAAI,GAC/B39E,oBAAoB,EACpB49E,wBAAwB,EACxBC,UAAW,GACXntF,cAAe,EACfotF,cAAe,CAAC,IAAM,SACtBngF,aAAc,CAAC,EAAG,GAClBwC,gBAAiB,CAAC,EAAG,EAAG,GACxB49E,sBAAsB,EACtBC,iBAAkB,EAAE,IAAM,IAAM,IAChCC,kBAAmB,CAAC,IAAM,IAAM,IAChCC,eAAgB,CAAC,GAAK,IAAM,IAC5BC,kBAAkB,EAClBC,iBAAkB,KAClBC,WAAY,KACZC,qBAAsB,cAEtBC,oBAAqB,CAAC,EAAG,EAAG,GAC5BC,cAAe,EACfC,eAAgB,CAAC,EAAG,EAAG,GACvBC,kBAAmB,CAAC,EAAG,GAAI,IAK7B,SAASzvE,EAAOC,EAAWC,GACzB,IAAIC,EAAgBmqD,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzF38D,OAAOyS,OAAOF,EAAOJ,EAAgBK,GAGrC,EAAAm8D,EAAMvS,IAAI9pD,EAAWC,GACrB,EAAAo8D,EAAMzuE,IAAIoS,EAAWC,EAAO,CAAC,aAC7B,EAAAo8D,EAAM2K,OAAOhnE,EAAWC,EAAO,CAAC,qBAAsB,yBAA0B,YAAa,gBAAiB,uBAAwB,mBAAoB,kBAC1J,EAAAo8D,EAAMyG,SAAS9iE,EAAWC,EAAO,CAAC,wBAAyB,kBAAmB,WAAY,eAC1F,EAAAo8D,EAAMwG,YAAY7iE,EAAWC,EAAO,CAAC,gBAAiB,gBAAiB,GACvE,EAAAo8D,EAAMwG,YAAY7iE,EAAWC,EAAO,CAAC,SAAU,mBAAoB,oBAAqB,iBAAkB,sBAAuB,iBAAkB,qBAAsB,GArkB3K,SAAmBD,EAAWC,GAE5BA,EAAMG,eAAe3N,KAAK,aAG1B,MAAM5K,EAAS,IAAI67D,aAAa,GAC1B+rB,EAAW,IAAI/rB,aAAa,CAAC,EAAK,GAAM,IACxCgsB,EAAU,IAAIhsB,aAAa,CAAC,EAAK,EAAK,IACtCisB,EAAY,cAAc,IAAIjsB,aAAa,KAC3CksB,EAAa,cAAc,IAAIlsB,aAAa,KAC5CmsB,EAAU,IAAInsB,aAAa,GAC3BosB,EAAU,IAAIpsB,aAAa,GAC3BqsB,EAAU,IAAIrsB,aAAa,GAC3BssB,EAAe,cAAc,IAAItsB,aAAa,KAC9CusB,EAAQ,cAAc,IAAIvsB,aAAa,KACvCnR,EAAc,IAAImR,aAAa,GAC/BpR,EAAgB,IAAIoR,aAAa,GAGvC,SAASwsB,IAEPjwE,EAAMhP,gBAAgB,IAAMgP,EAAMwuE,sBAAsB,GACxDxuE,EAAMhP,gBAAgB,IAAMgP,EAAMwuE,sBAAsB,GACxDxuE,EAAMhP,gBAAgB,IAAMgP,EAAMwuE,sBAAsB,EAC1D,CACAzuE,EAAUmwE,oBAAsB,KAC9B,MAAMC,EAAKpwE,EAAUqwE,gBACrBpwE,EAAMjP,OAAO,GAAKo/E,EAAG,GACrBnwE,EAAMjP,OAAO,GAAKo/E,EAAG,GACrBnwE,EAAMjP,OAAO,GAAKo/E,EAAG,GACrBpwE,EAAU68D,UAAU,EAEtB78D,EAAUswE,YAAc,CAACh8E,EAAG0E,EAAG69C,KACzBviD,IAAM2L,EAAMlP,SAAS,IAAMiI,IAAMiH,EAAMlP,SAAS,IAAM8lD,IAAM52C,EAAMlP,SAAS,KAG/EkP,EAAMlP,SAAS,GAAKuD,EACpB2L,EAAMlP,SAAS,GAAKiI,EACpBiH,EAAMlP,SAAS,GAAK8lD,EAGpB72C,EAAUuwE,kBACVvwE,EAAU68D,WAAU,EAEtB78D,EAAUwwE,cAAgB,CAACl8E,EAAG0E,EAAG69C,KAC3BviD,IAAM2L,EAAMzQ,WAAW,IAAMwJ,IAAMiH,EAAMzQ,WAAW,IAAMqnD,IAAM52C,EAAMzQ,WAAW,KAGrFyQ,EAAMzQ,WAAW,GAAK8E,EACtB2L,EAAMzQ,WAAW,GAAKwJ,EACtBiH,EAAMzQ,WAAW,GAAKqnD,EAGtB72C,EAAUuwE,kBACVvwE,EAAU68D,WAAU,EAEtB78D,EAAUywE,YAAc7H,IACtB,GAAI3oE,EAAMowB,WAAau4C,EACrB,OAEF3oE,EAAMowB,SAAWu4C,EACb3oE,EAAMowB,SAAW,QACnBpwB,EAAMowB,SAAW,MACjBi8C,EAAc,gCAIhB,MAAMoE,EAAMzwE,EAAMwuE,sBAGlBxuE,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAAK2/E,EAAI,GAAKzwE,EAAMowB,SACzDpwB,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAAK2/E,EAAI,GAAKzwE,EAAMowB,SACzDpwB,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAAK2/E,EAAI,GAAKzwE,EAAMowB,SACzDrwB,EAAU68D,UAAU,EAKtB78D,EAAUuwE,gBAAkB,KAC1B,MAAM3tD,EAAK3iB,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAC1C8xB,EAAK5iB,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAC1Cs6B,EAAKprB,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAEhD,GADAkP,EAAMowB,SAAW5tC,KAAKiZ,KAAKknB,EAAKA,EAAKC,EAAKA,EAAKwI,EAAKA,GAChDprB,EAAMowB,SAAW,MAAO,CAC1BpwB,EAAMowB,SAAW,MACjBi8C,EAAc,+BACd,MAAMoE,EAAMzwE,EAAMwuE,sBAGlBxuE,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAAK2/E,EAAI,GAAKzwE,EAAMowB,SACzDpwB,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAAK2/E,EAAI,GAAKzwE,EAAMowB,SACzDpwB,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAAK2/E,EAAI,GAAKzwE,EAAMowB,QAC3D,CACApwB,EAAMwuE,sBAAsB,GAAK7rD,EAAK3iB,EAAMowB,SAC5CpwB,EAAMwuE,sBAAsB,GAAK5rD,EAAK5iB,EAAMowB,SAC5CpwB,EAAMwuE,sBAAsB,GAAKpjD,EAAKprB,EAAMowB,SAC5C6/C,GAAwB,EAO1BlwE,EAAU2wE,MAAQC,IAChB,GAAIA,GAAU,EACZ,OAIF,MAAMhI,EAAI3oE,EAAMowB,SAAWugD,EAC3B5wE,EAAUswE,YAAYrwE,EAAMzQ,WAAW,GAAKo5E,EAAI3oE,EAAMwuE,sBAAsB,GAAIxuE,EAAMzQ,WAAW,GAAKo5E,EAAI3oE,EAAMwuE,sBAAsB,GAAIxuE,EAAMzQ,WAAW,GAAKo5E,EAAI3oE,EAAMwuE,sBAAsB,GAAG,EAErMzuE,EAAU6wE,KAAOr4E,IACf,MAAMs4E,EAAM7wE,EAAMlP,SACZggF,EAAK9wE,EAAMzQ,WACXwhF,EAAK/wE,EAAMjP,OACXigF,EAAa,IAAIvtB,aAAa,CAACstB,EAAG,GAAIA,EAAG,GAAIA,EAAG,GAAI,IAC1D,cAAchB,GACd,MAAMkB,EAAU,IAAIxtB,aAAa,CAACqtB,EAAG,GAAKD,EAAI,GAAIC,EAAG,GAAKD,EAAI,GAAIC,EAAG,GAAKD,EAAI,KAC9E,YAAYd,EAAcA,GAAc,IAAAhqC,GAAmBxtC,GAAQ04E,GACnE,mBAAmBD,EAAYA,EAAYjB,GAC3C/vE,EAAMjP,OAAO,GAAKigF,EAAW,GAC7BhxE,EAAMjP,OAAO,GAAKigF,EAAW,GAC7BhxE,EAAMjP,OAAO,GAAKigF,EAAW,GAC7BjxE,EAAU68D,UAAU,EAEtB78D,EAAUmxE,QAAU34E,IAClB,MAAM0yD,EAAKjrD,EAAMzQ,WACjB,cAAcygF,GAKd,eAAeA,EAAOA,EAAO/kB,GAC7B,YAAY+kB,EAAOA,GAAO,IAAAjqC,GAAmBxtC,GAAQyH,EAAMjP,QAC3D,eAAei/E,EAAOA,EAAO,EAAE/kB,EAAG,IAAKA,EAAG,IAAKA,EAAG,KAGlD,mBAAmB3Y,EAAatyC,EAAMlP,SAAUk/E,GAChDjwE,EAAUswE,YAAY/9B,EAAY,GAAIA,EAAY,GAAIA,EAAY,GAAG,EAEvEvyC,EAAUoxE,IAAM54E,IACd,MAAMzH,EAAWkP,EAAMlP,SACvB,cAAck/E,GAKd,eAAeA,EAAOA,EAAOl/E,GAC7B,YAAYk/E,EAAOA,GAAO,IAAAjqC,GAAmBxtC,GAAQyH,EAAMjP,QAC3D,eAAei/E,EAAOA,EAAO,EAAEl/E,EAAS,IAAKA,EAAS,IAAKA,EAAS,KAGpE,mBAAmBuhD,EAAeryC,EAAMzQ,WAAYygF,GACpDjwE,EAAUwwE,cAAcl+B,EAAc,GAAIA,EAAc,GAAIA,EAAc,GAAG,EAE/EtyC,EAAUqxE,UAAY74E,IACpB,MAAM0yD,EAAKjrD,EAAMzQ,WAGX4gF,EAAKpwE,EAAUqwE,gBACfiB,EAAO,EAAElB,EAAG,IAAKA,EAAG,IAAKA,EAAG,IAClC,cAAcH,GAKd,eAAeA,EAAOA,EAAO/kB,GAC7B,YAAY+kB,EAAOA,GAAO,IAAAjqC,GAAmBxtC,GAAQ84E,GACrD,eAAerB,EAAOA,EAAO,EAAE/kB,EAAG,IAAKA,EAAG,IAAKA,EAAG,KAGlD,mBAAmB3Y,EAAatyC,EAAMlP,SAAUk/E,GAChDjwE,EAAUswE,YAAY/9B,EAAY,GAAIA,EAAY,GAAIA,EAAY,GAAG,EAEvEvyC,EAAUuxE,MAAQ/4E,IAChB,MAAMzH,EAAWkP,EAAMlP,SACjBq/E,EAAKpwE,EAAUqwE,gBACfiB,EAAO,CAAClB,EAAG,GAAIA,EAAG,GAAIA,EAAG,IAC/B,cAAcH,GAKd,eAAeA,EAAOA,EAAOl/E,GAC7B,YAAYk/E,EAAOA,GAAO,IAAAjqC,GAAmBxtC,GAAQ84E,GACrD,eAAerB,EAAOA,EAAO,EAAEl/E,EAAS,IAAKA,EAAS,IAAKA,EAAS,KAGpE,mBAAmBuhD,EAAeryC,EAAMzQ,WAAYygF,GACpDjwE,EAAUwwE,iBAAiBl+B,EAAc,EAE3CtyC,EAAUwxE,KAAOC,IACXA,GAAU,IAGVxxE,EAAMnP,mBACRmP,EAAMze,eAAiBiwF,EAEvBxxE,EAAM0uE,WAAa8C,EAErBzxE,EAAU68D,WAAU,EAEtB78D,EAAUjO,UAAY,CAACuC,EAAG0E,EAAG69C,KAC3B,MAAMzsC,EAAS,CAAC9V,EAAG0E,EAAG69C,IACtB,OAAI52C,EAAMlP,SAAUqZ,EAAQnK,EAAMlP,WAClC,OAAIkP,EAAMzQ,WAAY4a,EAAQnK,EAAMzQ,YACpCwQ,EAAUuwE,kBACVvwE,EAAU68D,UAAU,EAEtB78D,EAAU0xE,eAAiBC,IACzB,MAAMC,EAAQ,IAAI3xE,EAAMjP,OAAQ,GAC1B6gF,EAAS,GACTC,EAAQ,GACRC,EAAQ,GACdH,EAAM,IAAM3xE,EAAMlP,SAAS,GAC3B6gF,EAAM,IAAM3xE,EAAMlP,SAAS,GAC3B6gF,EAAM,IAAM3xE,EAAMlP,SAAS,GAC3B,mBAAmB8gF,EAAQ,IAAI5xE,EAAMlP,SAAU,GAAM4gF,GACrD,mBAAmBG,EAAO,IAAI7xE,EAAMzQ,WAAY,GAAMmiF,GACtD,mBAAmBI,EAAOH,EAAOD,GACjCI,EAAM,IAAMF,EAAO,GACnBE,EAAM,IAAMF,EAAO,GACnBE,EAAM,IAAMF,EAAO,GACnB7xE,EAAUswE,eAAeuB,EAAOpwE,MAAM,EAAG,IACzCzB,EAAUwwE,iBAAiBsB,EAAMrwE,MAAM,EAAG,IAC1CzB,EAAUgyE,aAAaD,EAAMtwE,MAAM,EAAG,GAAG,EAE3CzB,EAAUiyE,aAAe,IAAMhyE,EAAM2uE,cAAc,GAAK3uE,EAAM2uE,cAAc,GAC5E5uE,EAAUkyE,aAAeC,IACvB,IAAIjjC,EAAIijC,EACJjjC,EAAI,QACNA,EAAI,MACJo9B,EAAc,iCAEhBtsE,EAAUoyE,iBAAiBnyE,EAAM2uE,cAAc,GAAI3uE,EAAM2uE,cAAc,GAAK1/B,EAAE,EAEhFlvC,EAAUqyE,2BAA6BF,IACrC,IAAIjjC,EAAIijC,EACJjjC,EAAI,QACNA,EAAI,MACJo9B,EAAc,iCAEhBtsE,EAAUoyE,iBAAiBnyE,EAAMowB,SAAW6e,EAAI,EAAGjvC,EAAMowB,SAAW6e,EAAI,EAAE,EAI5ElvC,EAAUsyE,QAAU95E,MACpBwH,EAAUuyE,QAAU,OACpBvyE,EAAUwyE,iBAAmB,CAACC,EAAOC,KAAR,EAC7B1yE,EAAU2yE,eAAiB,OAC3B3yE,EAAU4yE,mBAAqB,OAC/B5yE,EAAU6yE,iBAAmBt2C,MAG7Bv8B,EAAU8yE,8BAAgCC,IACxC,UAAUA,EAAQ9yE,EAAMmvE,sBACjB2D,GAET/yE,EAAUgzE,4BAA8B,KAEtC,UAAUrD,EAAW3vE,EAAUqwE,iBAC/B,YAAYV,EAAWA,GACvB,iBAAiBC,EAAY,CAAC3vE,EAAMowB,SAAUpwB,EAAMowB,SAAUpwB,EAAMowB,WACpE,cAAcs/C,EAAWA,EAAWC,GACpC,cAAc3vE,EAAMmvE,sBACpB,eAAenvE,EAAMmvE,qBAAsBO,EAAW,CAAC,EAAK,GAAM,GAAK,EAEzE3vE,EAAUizE,SAAWC,MACrBlzE,EAAUmzE,oCAAsCC,IAE9C,MAAMC,EAAO,gBAAgBD,EAAI,GAAIA,EAAI,GAAIA,EAAI,GAAIA,EAAI,IACnDE,EAAQ,cACRC,EAAO,gBAAgB,EAAK,EAAK,EAAK,GAQ5C,OAPA,eAAeD,EAAOD,GAGtB,cAAcE,EAAMF,EAAME,GAC1B,cAAcA,EAAMA,EAAMD,GAGnB,CAACC,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAG,EAEpCvzE,EAAUwzE,yBAA2Bz7C,IACnC/3B,EAAUyzE,yBAAyB17C,GACnC,YAAYA,EAAQA,EAAO,EAE7B/3B,EAAUyzE,yBAA2B17C,IACnC,cAAcA,GAGd,MAAM27C,EAAa,CAAC,IACpB,OAAMzzE,EAAMuvE,kBAAmBvvE,EAAMsvE,eAAgBmE,GACrD37C,EAAO,GAAK27C,EAAW,GACvB37C,EAAO,GAAK27C,EAAW,GACvB37C,EAAO,GAAK27C,EAAW,GACvB37C,EAAO,GAAK93B,EAAMsvE,eAAe,GACjCx3C,EAAO,GAAK93B,EAAMsvE,eAAe,GACjCx3C,EAAO,GAAK93B,EAAMsvE,eAAe,GACjCx3C,EAAO,IAAM93B,EAAMuvE,kBAAkB,GACrCz3C,EAAO,IAAM93B,EAAMuvE,kBAAkB,GACrCz3C,EAAO,KAAO93B,EAAMuvE,kBAAkB,GACtC,eAAez3C,EAAQA,GACvB,SAAS83C,EAAS,EAAI5vE,EAAMqvE,cAAe,EAAIrvE,EAAMqvE,cAAe,EAAIrvE,EAAMqvE,eAC9E,WAAWv3C,EAAQA,EAAQ83C,GAC3B,eAAe93C,EAAQA,EAAQ93B,EAAMovE,oBAAoB,EAE3DrvE,EAAU2zE,oCAAsCC,IAE9C,YAAYjE,EAAWiE,GAYvB,mBAAmB/D,EAAShoF,EAAQ8nF,GACpC3vE,EAAUuwE,kBACV,MAAMsD,EAAU5zE,EAAMowB,SACtBrwB,EAAUswE,YAAYT,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,IAGtD,mBAAmBC,EAASL,EAAUE,GACtC,cAAcG,EAASA,EAASD,GAChC,eAAeC,EAASA,GACxB9vE,EAAU8zE,yBAAyBhE,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,IACnE,mBAAmBC,EAASL,EAASC,GACrC,cAAcI,EAASA,EAASF,GAChC,eAAeE,EAASA,GACxB/vE,EAAUgyE,UAAUjC,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,IACpD/vE,EAAUywE,YAAYoD,EAAQ,EAMhC7zE,EAAU+zE,wCAA0CC,IAElDh0E,EAAUyzE,yBAAyB9D,GAInC,cAAcA,EAAWqE,EAAKrE,GAC9B3vE,EAAU2zE,oCAAoChE,EAAU,EAE1D3vE,EAAUi0E,cAAgBD,IACxB/zE,EAAMkvE,WAAa6E,EACf/zE,EAAMkvE,aACR,UAAUQ,EAAW1vE,EAAMkvE,YAC3BnvE,EAAU2zE,oCAAoChE,GAC9C,eAAe1vE,EAAMkvE,WAAYlvE,EAAMkvE,YACzC,EAEFnvE,EAAUqwE,cAAgB,KACxB,GAAIpwE,EAAMkvE,WACR,OAAOlvE,EAAMkvE,WAEf,YAAYQ,EAAW1vE,EAAMlP,SAE7BkP,EAAMzQ,WAENyQ,EAAMjP,QAGN,eAAe2+E,EAAWA,GAC1B,MAAM53C,EAAS,IAAI2rB,aAAa,IAEhC,OADA,UAAU3rB,EAAQ43C,GACX53C,CAAM,EAEf/3B,EAAUk0E,oBAAsBF,IAC9B/zE,EAAMivE,iBAAmB8E,CAAG,EAE9Bh0E,EAAUm0E,oBAAsB,CAAC53C,EAAQ63C,EAAOC,KAC9C,MAAMt8C,EAAS,IAAI2rB,aAAa,IAEhC,GADA,cAAc3rB,GACV93B,EAAMivE,iBAAkB,CAC1B,MAAMp9E,EAAQ,EAAImO,EAAMqvE,cAKxB,OAJA,SAASO,EAAS/9E,EAAOA,EAAOA,GAChC,UAAUimC,EAAQ93B,EAAMivE,kBACxB,WAAWn3C,EAAQA,EAAQ83C,GAC3B,eAAe93C,EAAQA,GAChBA,CACT,CACA,cAAc43C,GAKd,MAAM2E,EAASr0E,EAAM2uE,cAAc,GAAK3uE,EAAM2uE,cAAc,GACtD2F,EAAS,CAACt0E,EAAM2uE,cAAc,IAAMwF,EAAQ,GAAKE,EAAS,EAAKr0E,EAAM2uE,cAAc,IAAMyF,EAAO,GAAKC,EAAS,GACpH,GAAIr0E,EAAMnP,mBAAoB,CAE5B,MAAM1O,EAAQ6d,EAAMze,cAAgB+6C,EAC9Bl6C,EAAS4d,EAAMze,cACfgzF,GAAQv0E,EAAMxR,aAAa,GAAK,GAAOrM,EACvCqyF,GAAQx0E,EAAMxR,aAAa,GAAK,GAAOrM,EACvCsyF,GAAQz0E,EAAMxR,aAAa,GAAK,GAAOpM,EACvCsyF,GAAQ10E,EAAMxR,aAAa,GAAK,GAAOpM,EAC7C,WAAWstF,EAAW6E,EAAMC,EAAMC,EAAMC,EAAMJ,EAAO,GAAIA,EAAO,IAChE,eAAe5E,EAAWA,EAC5B,KAAO,IAAI1vE,EAAM4uE,qBACf,MAAM,IAAIrlF,MAAM,qDACX,CACL,MAAMorF,EAAMnyF,KAAKoyF,KAAI,IAAA7uC,GAAmB/lC,EAAM0uE,WAAa,GAC3D,IAAIvsF,EACAC,GACiC,IAAjC4d,EAAMyuE,wBACRtsF,EAAQ6d,EAAM2uE,cAAc,GAAKgG,EACjCvyF,EAAS4d,EAAM2uE,cAAc,GAAKgG,EAAMr4C,IAExCn6C,EAAQ6d,EAAM2uE,cAAc,GAAKgG,EAAMr4C,EACvCl6C,EAAS4d,EAAM2uE,cAAc,GAAKgG,GAEpC,MAAMJ,GAAQv0E,EAAMxR,aAAa,GAAK,GAAOrM,EACvCqyF,GAAQx0E,EAAMxR,aAAa,GAAK,GAAOrM,EACvCsyF,GAAQz0E,EAAMxR,aAAa,GAAK,GAAOpM,EACvCsyF,GAAQ10E,EAAMxR,aAAa,GAAK,GAAOpM,EACvCyyF,EAAQP,EAAO,GACfQ,EAAOR,EAAO,GACpB5E,EAAU,GAAK,EAAMmF,GAASL,EAAOD,GACrC7E,EAAU,GAAK,EAAMmF,GAASH,EAAOD,GACrC/E,EAAU,IAAM6E,EAAOC,IAASA,EAAOD,GACvC7E,EAAU,IAAM+E,EAAOC,IAASA,EAAOD,GACvC/E,EAAU,MAAQmF,EAAQC,IAASA,EAAOD,GAC1CnF,EAAU,KAAO,EACjBA,EAAU,KAAO,EAAMmF,EAAQC,GAAQA,EAAOD,GAC9CnF,EAAU,IAAM,CAClB,EAEA,OADA,UAAU53C,EAAQ43C,GACX53C,CAAM,EAEf/3B,EAAUg1E,6BAA+B,CAACz4C,EAAQ63C,EAAOC,KACvD,MAAMY,EAAOj1E,EAAUqwE,gBACjB6E,EAAOl1E,EAAUm0E,oBAAoB53C,EAAQ63C,EAAOC,GAI1D,OADA,cAAca,EAAMD,EAAMC,GACnBA,CAAI,EAEbl1E,EAAU8zE,yBAA2B,CAACx/E,EAAG0E,EAAG69C,KAC1C,GAAI52C,EAAMwuE,sBAAsB,KAAOn6E,GAAK2L,EAAMwuE,sBAAsB,KAAOz1E,GAAKiH,EAAMwuE,sBAAsB,KAAO53B,EACrH,OAEF52C,EAAMwuE,sBAAsB,GAAKn6E,EACjC2L,EAAMwuE,sBAAsB,GAAKz1E,EACjCiH,EAAMwuE,sBAAsB,GAAK53B,EACjC,MAAM65B,EAAMzwE,EAAMwuE,sBAGlBxuE,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAAK2/E,EAAI,GAAKzwE,EAAMowB,SACzDpwB,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAAK2/E,EAAI,GAAKzwE,EAAMowB,SACzDpwB,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAAK2/E,EAAI,GAAKzwE,EAAMowB,SACzD6/C,GAAwB,EAmB1BlwE,EAAUm1E,gBAAkB,CAAC1C,EAAOC,EAAMr+E,EAAO+gF,KAC/C,MAAM1B,EAAa,CAAC,IACpB,OAAMzzE,EAAMuvE,kBAAmBvvE,EAAMsvE,eAAgBmE,GAGrD,MAAM2B,EAAS,cAAc,IAAI3xB,aAAa,KAC9C,YAAY2xB,EAAQA,GAAQ,IAAArvC,GAAmBysC,GAAQxyE,EAAMsvE,gBAC7D,YAAY8F,EAAQA,GAAQ,IAAArvC,GAAmB0sC,GAAOgB,GACtD,YAAY2B,EAAQA,GAAQ,IAAArvC,GAAmB3xC,GAAQ4L,EAAMuvE,mBAC7D,YAAY6F,EAAQA,GAAQ,IAAArvC,IAAoBovC,GAASn1E,EAAMsvE,gBAC/D,MAAM+F,EAAM,IAAI5xB,aAAa,EAAEzjD,EAAMsvE,eAAe,IAAKtvE,EAAMsvE,eAAe,IAAKtvE,EAAMsvE,eAAe,KAClGgG,EAAM,IAAI7xB,aAAazjD,EAAMuvE,mBACnC,mBAAmB8F,EAAKA,EAAKD,GAC7B,mBAAmBE,EAAKA,EAAKF,GAC7Br1E,EAAU8zE,yBAAyBwB,EAAI,GAAIA,EAAI,GAAIA,EAAI,IACvDt1E,EAAUgyE,UAAUuD,EAAI,GAAIA,EAAI,GAAIA,EAAI,IACxCv1E,EAAU68D,UAAU,EAEtB78D,EAAUw1E,mBAAqB,CAACC,EAASnhF,EAAG0E,EAAG69C,KAC7C,MAAM6+B,EAAU,cAAc,IAAIhyB,aAAa,KAC/C,GAAgB,IAAZ+xB,IAA0B,IAANnhF,GAAmB,IAAN0E,GAAmB,IAAN69C,GAAY,CAE5D,MAAMr+C,GAAQ,IAAAwtC,GAAmByvC,GAC3B1vC,EAAI,cACV,kBAAkBA,EAAG,CAACzxC,EAAG0E,EAAG69C,GAAIr+C,GAChC,cAAck9E,EAAS3vC,EACzB,CACA,MAAM4vC,EAAS,IAAIjyB,aAAa,GAChC,mBAAmBiyB,EAAQ,CAAC,EAAK,GAAM,GAAMD,GAC7C,MAAME,EAAS,IAAIlyB,aAAa,GAChC,mBAAmBkyB,EAAQ,CAAC,EAAK,EAAK,GAAMF,GAC5C11E,EAAU8zE,4BAA4B6B,GACtC31E,EAAUgyE,aAAa4D,GACvB51E,EAAU68D,UAAU,EAEtB78D,EAAU61E,qBAAuBx/B,IAC/B,IAAIy/B,EAAK,KACL/kF,EAAW,KACf+kF,EAAK71E,EAAMhP,gBACXF,EAAWkP,EAAMlP,SACjB,MAAM4D,GAAKmhF,EAAG,GACRlhF,GAAKkhF,EAAG,GACR7mF,GAAK6mF,EAAG,GACRlN,IAAMj0E,EAAI5D,EAAS,GAAK6D,EAAI7D,EAAS,GAAK9B,EAAI8B,EAAS,IAGvDR,EAAQ,CAACoE,EAAI0hD,EAAO,GAAKzhD,EAAIyhD,EAAO,GAAKpnD,EAAIonD,EAAO,GAAKuyB,EAAG,OAGlE,IAAK,IAAIn4B,EAAI,EAAGA,EAAI,EAAGA,IACrB,IAAK,IAAIrM,EAAI,EAAGA,EAAI,EAAGA,IACrB,IAAK,IAAIv5C,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,MAAM0lC,EAAO57B,EAAI0hD,EAAOxrD,GAAK+J,EAAIyhD,EAAO,EAAIjS,GAAKn1C,EAAIonD,EAAO,EAAI5F,GAAKm4B,EACrEr4E,EAAM,GAAKggC,EAAOhgC,EAAM,GAAKggC,EAAOhgC,EAAM,GAC1CA,EAAM,GAAKggC,EAAOhgC,EAAM,GAAKggC,EAAOhgC,EAAM,EAC5C,CAGJ,OAAOA,CAAK,CAEhB,CAgDEwlF,CAAU/1E,EAAWC,EACvB,CAQA,IAAI+1E,EAAc,CAChBx1E,YALkB,EAAA67D,EAAM77D,YAAYT,EAAQ,aAM5CA,2FCtmBF,MAAM,WACJk2E,EAAU,MACVC,GACE,WACE,oBACJC,GACE,WACE,cACJ7J,EAAa,cACb5J,EAAa,gBACb0T,GACE,EAAA/Z,EASJ,SAASga,EAAiCC,EAAKC,GAC7C,MAAMC,EAAIF,EAAI,GACR3hF,EAAI2hF,EAAI,GACR1hF,EAAI0hF,EAAI,GACRG,EAAIh0F,KAAKiZ,KAAK86E,EAAIA,EAAI7hF,EAAIA,EAAIC,EAAIA,GAClC45D,EAAIioB,EAAI,KAAQh0F,KAAKi0F,KAAKF,EAAIC,GAAK,EACnCE,EAAInoB,EAAI,KAAQ/rE,KAAKooC,MAAMj2B,EAAGD,GAAK,EACzC4hF,EAAI,GAAKE,EACTF,EAAI,GAAK/nB,EACT+nB,EAAI,GAAKI,CACX,CAYA,SAASC,EAAkCL,EAAKM,GAC9C,GAAIN,EAAI,IAAMM,EAAS,GAErB,OAAON,EAAI,GAKb,MAAMO,EAAUP,EAAI,GAAK9zF,KAAKiZ,KAAKm7E,EAASA,EAASN,EAAI,GAAKA,EAAI,KAAOA,EAAI,GAAK9zF,KAAKqX,IAAIy8E,EAAI,KAE/F,OAAIA,EAAI,IAAM,GAAM9zF,KAAKkW,GAChB49E,EAAI,GAAKO,EAEXP,EAAI,GAAKO,CAClB,CAgBA,SAASC,EAA6CvoB,EAAGwoB,EAAMC,EAAMl/C,GACnE,MAAMm/C,EAAO,GACPC,EAAO,IACb,OAAQH,EAAME,IACd,OAAQD,EAAME,GACd,MAAMC,EAAO,GACPC,EAAO,GACbhB,EAAiCa,EAAME,GACvCf,EAAiCc,EAAME,GAIvC,IAAIC,EAAS9oB,EACb,GAAI4oB,EAAK,GAAK,KAAQC,EAAK,GAAK,KA5BlC,SAA2Ct1C,EAAIK,GAC7C,IAAIm1C,EAAQx1C,EAAKK,EAIjB,IAHIm1C,EAAQ,IACVA,GAASA,GAEJA,GAAS,EAAM90F,KAAKkW,IACzB4+E,GAAS,EAAM90F,KAAKkW,GAKtB,OAHI4+E,EAAQ90F,KAAKkW,KACf4+E,EAAQ,EAAM90F,KAAKkW,GAAK4+E,GAEnBA,CACT,CAgB0CC,CAAkCJ,EAAK,GAAIC,EAAK,IAAM,IAAO50F,KAAKkW,GAAI,CAG5G,IAAI8+E,EAAOh1F,KAAKsM,IAAIqoF,EAAK,GAAIC,EAAK,IAClCI,EAAOh1F,KAAKsM,IAAI,GAAM0oF,GAClBjpB,EAAI,IACN6oB,EAAK,GAAKI,EACVJ,EAAK,GAAK,EACVA,EAAK,GAAK,EACVC,GAAU,IAEVF,EAAK,GAAKK,EACVL,EAAK,GAAK,EACVA,EAAK,GAAK,EACVE,EAAS,EAAMA,EAAS,EAE5B,CAKIF,EAAK,GAAK,KAAQC,EAAK,GAAK,IAC9BD,EAAK,GAAKR,EAAkCS,EAAMD,EAAK,IAC9CC,EAAK,GAAK,KAAQD,EAAK,GAAK,MACrCC,EAAK,GAAKT,EAAkCQ,EAAMC,EAAK,KAEzD,MAAMK,EAAS,GACfA,EAAO,IAAM,EAAIJ,GAAUF,EAAK,GAAKE,EAASD,EAAK,GACnDK,EAAO,IAAM,EAAIJ,GAAUF,EAAK,GAAKE,EAASD,EAAK,GACnDK,EAAO,IAAM,EAAIJ,GAAUF,EAAK,GAAKE,EAASD,EAAK,GAGnD,MAAMM,EAAS,IAtFjB,SAA0CpB,EAAKD,GAC7C,MAAMG,EAAIF,EAAI,GACR/nB,EAAI+nB,EAAI,GACRI,EAAIJ,EAAI,GACdD,EAAI,GAAKG,EAAIh0F,KAAKmX,IAAI40D,GACtB8nB,EAAI,GAAKG,EAAIh0F,KAAKqX,IAAI00D,GAAK/rE,KAAKmX,IAAI+8E,GACpCL,EAAI,GAAKG,EAAIh0F,KAAKqX,IAAI00D,GAAK/rE,KAAKqX,IAAI68E,EACtC,CAgFEiB,CAAiCF,EAAQC,IACzC,OAAQA,EAAQ5/C,EAClB,CAogCA,MAAMl4B,EAAiB,CACrBinE,UAAU,EACV+Q,WAAY5B,EAAW6B,IACvBC,SAAS,EACTjmF,MAAOokF,EAAM8B,OACbC,SAAU,KACVC,gBAAiB,KACjBC,gBAAiB,KACjBC,oBAAoB,EACpBC,oBAAoB,EACpBtR,uBAAuB,EACvBwB,MAAO,KACP+P,UAAW,EACXC,UAAW,KACXl/D,MAAO,KACPm/D,YAAY,EACZC,eAAgB,KAKlB,SAAS14E,EAAOC,EAAWC,GACzB,IAAIC,EAAgBmqD,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzF38D,OAAOyS,OAAOF,EAAOJ,EAAgBK,GAGrC,iBAA0BF,EAAWC,EAAOC,GAG5CD,EAAMsoE,MAAQ,GACdtoE,EAAMoZ,MAAQ,GACdpZ,EAAMg4E,SAAW,CAAC,GAAK,EAAK,EAAK,GACjCh4E,EAAMi4E,gBAAkB,CAAC,EAAK,EAAK,EAAK,GACxCj4E,EAAMk4E,gBAAkB,CAAC,EAAK,EAAK,EAAK,GACxCl4E,EAAMs4E,UAAY,CAAC,EACnB,EAAAlc,EAAMvS,IAAI7pD,EAAMs4E,WAGhB,EAAAlc,EAAMzuE,IAAIoS,EAAWC,EAAO,CAAC,YAAa,iBAG1C,EAAAo8D,EAAM2K,OAAOhnE,EAAWC,EAAO,CAAC,qBAAsB,qBAAsB,aAAc,aAAc,mBACxG,EAAAo8D,EAAM4K,SAASjnE,EAAWC,EAAO,CAAC,WAAY,kBAAmB,mBAAoB,GAGrF,EAAAo8D,EAAMyG,SAAS9iE,EAAWC,EAAO,CAAC,WAAY,kBAAmB,oBA3iCnE,SAAkCD,EAAWC,GAE3CA,EAAMG,eAAe3N,KAAK,4BAG1BuN,EAAUiZ,QAAU,IAAMhZ,EAAMoZ,MAAM1tB,OAItCqU,EAAUwY,YAAc,CAAClkB,EAAG0xC,EAAG0yC,EAAG9jF,IAAMoL,EAAU24E,gBAAgBrkF,EAAG0xC,EAAG0yC,EAAG9jF,EAAG,GAAK,GAInFoL,EAAU24E,gBAAkB,SAAUrkF,EAAG0xC,EAAG0yC,EAAG9jF,GAC7C,IAAI42C,EAAW6e,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,GAC/Eod,EAAYpd,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,EAEpF,GAAI7e,EAAW,GAAOA,EAAW,EAE/B,OADAk3B,EAAc,sCACN,EAEV,GAAI+E,EAAY,GAAOA,EAAY,EAEjC,OADA/E,EAAc,uCACN,EAILziE,EAAM8mE,uBACT/mE,EAAU+nE,YAAYzzE,GAIxB,MAAMilB,EAAO,CACXjlB,IACA0xC,IACA0yC,IACA9jF,IACA42C,WACAi8B,aAIFxnE,EAAMoZ,MAAM5mB,KAAK8mB,GACjBvZ,EAAU4nE,qBAIV,IAAI/8E,EAAI,EACR,KAAOA,EAAIoV,EAAMoZ,MAAM1tB,QACjBsU,EAAMoZ,MAAMxuB,GAAGyJ,IAAMA,EADIzJ,KAQ/B,OAAIA,EAAIoV,EAAMoZ,MAAM1tB,OACXd,GAED,CACV,EAIAmV,EAAU44E,YAAc,CAACtkF,EAAGqiF,EAAGnoB,EAAGqK,IAAM74D,EAAU64E,gBAAgBvkF,EAAGqiF,EAAGnoB,EAAGqK,EAAG,GAAK,GAInF74D,EAAU64E,gBAAkB,SAAUvkF,EAAGqiF,EAAGnoB,EAAGqK,GAC7C,IAAIrtB,EAAW6e,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,GAC/Eod,EAAYpd,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,EACpF,MAAMyuB,EAAM,GACNC,EAAM,CAACpC,EAAGnoB,EAAGqK,GAEnB,OADA,IAAA8d,GAAQoC,EAAKD,GACN94E,EAAUwY,YAAYlkB,EAAGwkF,EAAI,GAAIA,EAAI,GAAIA,EAAI,GAAIttC,EAAUi8B,EACpE,EAIAznE,EAAUgoE,SAAW3uD,IACnB,GAAIpZ,EAAMoZ,QAAUA,EAAO,CACzB,MAAM2/D,EAASn9B,KAAKE,UAAU97C,EAAMoZ,OACpCpZ,EAAMoZ,MAAQA,EACd,MAAM4/D,EAAQp9B,KAAKE,UAAU97C,EAAMoZ,OACnC,GAAIrZ,EAAU4nE,sBAAwBoR,IAAWC,EAE/C,OADAj5E,EAAU68D,YACH,CAEX,CACA,OAAO,CAAK,EAMd78D,EAAU4nE,mBAAqB,KAC7B,MAAMoR,EAASn9B,KAAKE,UAAU97C,EAAMoZ,OACpCpZ,EAAMoZ,MAAM9jB,MAAK,CAACZ,EAAGC,IAAMD,EAAEL,EAAIM,EAAEN,IACnC,MAAM2kF,EAAQp9B,KAAKE,UAAU97C,EAAMoZ,OAC7B+uD,EAAkBpoE,EAAUioE,cAElC,OAAKG,GAAmB4Q,IAAWC,EAI5B7Q,GAHLpoE,EAAU68D,YACH,EAEa,EAIxB78D,EAAUioE,YAAc,KACtB,MAAMC,EAAW,CAAC,GAClBA,EAAS,GAAKjoE,EAAMi5E,aAAa,GACjChR,EAAS,GAAKjoE,EAAMi5E,aAAa,GACjC,MAAM/uE,EAAOlK,EAAMoZ,MAAM1tB,OAUzB,OATIwe,GACFlK,EAAMi5E,aAAa,GAAKj5E,EAAMoZ,MAAM,GAAG/kB,EACvC2L,EAAMi5E,aAAa,GAAKj5E,EAAMoZ,MAAMlP,EAAO,GAAG7V,IAE9C2L,EAAMi5E,aAAa,GAAK,EACxBj5E,EAAMi5E,aAAa,GAAK,IAItBhR,EAAS,KAAOjoE,EAAMi5E,aAAa,IAAMhR,EAAS,KAAOjoE,EAAMi5E,aAAa,MAGhFl5E,EAAU68D,YACH,EAAI,EAKb78D,EAAU+nE,YAAczzE,IAGtB,IAAIzJ,EAAI,EACR,KAAOA,EAAIoV,EAAMoZ,MAAM1tB,QACjBsU,EAAMoZ,MAAMxuB,GAAGyJ,IAAMA,EADIzJ,KAK/B,MAAMs9E,EAASt9E,EAGf,GAAIA,GAAKoV,EAAMoZ,MAAM1tB,OACnB,OAAQ,EAKV,IAAIy8E,GAAkB,EAQtB,OAPAnoE,EAAMoZ,MAAM11B,OAAOkH,EAAG,GACZ,IAANA,GAAWA,IAAMoV,EAAMoZ,MAAM1tB,SAC/By8E,EAAkBpoE,EAAUioE,eAEzBG,GACHpoE,EAAU68D,WAELsL,CAAM,EAIfnoE,EAAUm5E,UAAY,CAACxR,EAAM5tE,KAC3B,GAAI4tE,IAAS5tE,EAAb,CAIAiG,EAAU+nE,YAAYhuE,GACtB,IAAK,IAAIlP,EAAI,EAAGA,EAAIoV,EAAMoZ,MAAM1tB,OAAQd,IACtC,GAAIoV,EAAMoZ,MAAMxuB,GAAGyJ,IAAMqzE,EAAM,CAC7B1nE,EAAMoZ,MAAMxuB,GAAGyJ,EAAIyF,EACnBiG,EAAU4nE,qBACV,KACF,CAPF,CAQA,EAKF5nE,EAAUsZ,gBAAkB,KAC1BrZ,EAAMoZ,MAAQ,GACdrZ,EAAU4nE,oBAAoB,EAKhC5nE,EAAUo5E,cAAgB,CAAC53C,EAAIe,EAAI82C,EAAIr3C,EAAIP,EAAIe,EAAI82C,EAAIj3C,KAErDriC,EAAU4nE,qBACV,IAAK,IAAI/8E,EAAI,EAAGA,EAAIoV,EAAMoZ,MAAM1tB,QAC1BsU,EAAMoZ,MAAMxuB,GAAGyJ,GAAKktC,GAAMvhC,EAAMoZ,MAAMxuB,GAAGyJ,GAAKmtC,EAChDxhC,EAAMoZ,MAAM11B,OAAOkH,EAAG,GAEtBA,IAKJmV,EAAU24E,gBAAgBn3C,EAAIe,EAAI82C,EAAIr3C,EAAI,GAAK,GAC/ChiC,EAAU24E,gBAAgBl3C,EAAIe,EAAI82C,EAAIj3C,EAAI,GAAK,GAC/CriC,EAAU68D,UAAU,EAKtB78D,EAAUu5E,cAAgB,CAAC/3C,EAAIgoC,EAAIgQ,EAAIC,EAAIh4C,EAAIgoC,EAAIiQ,EAAIC,KACrD,MAAMC,EAAO,CAACpQ,EAAIgQ,EAAIC,GAChBI,EAAO,CAACpQ,EAAIiQ,EAAIC,GAChB3C,EAAO,GACPC,EAAO,IACb,IAAAN,GAAQiD,EAAM5C,IACd,IAAAL,GAAQkD,EAAM5C,GACdj3E,EAAUo5E,cAAc53C,EAAIw1C,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIv1C,EAAIw1C,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAG,EAKvFj3E,EAAU85E,SAAWxlF,IACnB,MAAMwkF,EAAM,GAEZ,OADA94E,EAAUjJ,SAASzC,EAAGwkF,GACf,CAACr2F,KAAK6O,MAAM,IAAQwnF,EAAI,GAAK,IAAMr2F,KAAK6O,MAAM,IAAQwnF,EAAI,GAAK,IAAMr2F,KAAK6O,MAAM,IAAQwnF,EAAI,GAAK,IAAM,IAAI,EAKpH94E,EAAUjJ,SAAW,CAACzC,EAAGwkF,KACvB,GAAI74E,EAAM85E,cAAV,CACE,MAAM5Q,EAAWnpE,EAAUiZ,UAErB+lB,EAAMh/B,EAAUg6E,+BAA+B1lF,GACrD,GAAI0qC,EAAM,GAAkB,IAAbmqC,EAAgB,CAC7B,MAAM8O,EAAWj4E,EAAUi6E,yBAC3BnB,EAAI,GAAKb,EAAS,GAClBa,EAAI,GAAKb,EAAS,GAClBa,EAAI,GAAKb,EAAS,EACpB,KAAO,CACL,MAAMiC,EAAU,GAChBl6E,EAAUmZ,aAAa6lB,EAAMmqC,EAAU+Q,GAEvCpB,EAAI,GAAKoB,EAAQ,GACjBpB,EAAI,GAAKoB,EAAQ,GACjBpB,EAAI,GAAKoB,EAAQ,EACnB,CAEF,MACAl6E,EAAUwoE,SAASl0E,EAAGA,EAAG,EAAGwkF,EAAI,EAKlC94E,EAAUm6E,YAAc7lF,IACtB,MAAMwkF,EAAM,GAEZ,OADA94E,EAAUjJ,SAASzC,EAAGwkF,GACfA,EAAI,EAAE,EAKf94E,EAAUo6E,cAAgB9lF,IACxB,MAAMwkF,EAAM,GAEZ,OADA94E,EAAUjJ,SAASzC,EAAGwkF,GACfA,EAAI,EAAE,EAKf94E,EAAUq6E,aAAe/lF,IACvB,MAAMwkF,EAAM,GAEZ,OADA94E,EAAUjJ,SAASzC,EAAGwkF,GACfA,EAAI,EAAE,EAKf94E,EAAUwoE,SAAW,CAAC8R,EAASC,EAAOpwE,EAAMo+D,KAE1C,MAAMS,EAASv4E,OAAO6pF,GAChBrR,EAAOx4E,OAAO8pF,GAKpB,IAAI,IAAA1vF,GAAMm+E,KAAW,IAAAn+E,GAAMo+E,GAAO,CAChC,IAAK,IAAIp+E,EAAI,EAAGA,EAAIsf,EAAMtf,IACxB09E,EAAU,EAAJ19E,EAAQ,GAAKoV,EAAMg4E,SAAS,GAClC1P,EAAU,EAAJ19E,EAAQ,GAAKoV,EAAMg4E,SAAS,GAClC1P,EAAU,EAAJ19E,EAAQ,GAAKoV,EAAMg4E,SAAS,GAEpC,MACF,CACA,IAAIj5C,EAAM,EACV,MAAMmqC,EAAWlpE,EAAMoZ,MAAM1tB,OAK7B,IAAI6uF,EAAQ,EACRC,EAAQ,EACRC,EAAQ,EACK,IAAbvR,IACFqR,EAAQv6E,EAAMoZ,MAAM8vD,EAAW,GAAGnjC,EAClCy0C,EAAQx6E,EAAMoZ,MAAM8vD,EAAW,GAAGuP,EAClCgC,EAAQz6E,EAAMoZ,MAAM8vD,EAAW,GAAGv0E,GAEpC,IAAIN,EAAI,EACJktC,EAAK,EACLC,EAAK,EACT,MAAMu1C,EAAO,CAAC,EAAK,EAAK,GAClBC,EAAO,CAAC,EAAK,EAAK,GACxB,IAAIzrC,EAAW,EACXi8B,EAAY,EAChB,MAAMkT,EAAS,GAGf,IAAIC,EAAgB36E,EAAMnO,QAAUokF,EAAM2E,MACtCD,IAEFA,EAAgB36E,EAAMi5E,aAAa,GAAK,GAE1C,IAAI4B,EAAW,EACXC,EAAS,EACTC,EAAO,EACPJ,IACFE,EAAWr4F,KAAKw4F,MAAMjS,GACtB+R,EAASt4F,KAAKw4F,MAAMhS,IAItB,IAAK,IAAIp+E,EAAI,EAAGA,EAAIsf,EAAMtf,IAAK,CAE7B,MAAMw+E,EAAO,EAAIx+E,EAsBjB,GAjBIsf,EAAO,EACLywE,GACFI,EAAOF,EAAWjwF,GAAKsf,EAAO,IAAQ4wE,EAASD,GAC/CxmF,EAAI,IAAQ0mF,GAEZ1mF,EAAI00E,EAASn+E,GAAKsf,EAAO,IAAQ8+D,EAAOD,GAEjC4R,GACTI,EAAO,IAAOF,EAAWC,GACzBzmF,EAAI,IAAQ0mF,GAEZ1mF,EAAI,IAAO00E,EAASC,GAMlBhpE,EAAMu4E,WAAY,CACpB,MAAMjoF,EAAQ0P,EAAMi5E,aACpB,GAAI5kF,GAAK/D,EAAM,IAAM+D,GAAK/D,EAAM,GAAI,CAClC,MAAMkoF,EAAiBx4E,EAAMw4E,eACvByC,EAAa3qF,EAAM,GAAKA,EAAM,GACpC,GAAIkoF,GAAkB,EACpBnkF,EAAI/D,EAAM,GAAK2qF,EAAa,MACvB,CAEL,MAAMC,GAAM7mF,EAAI/D,EAAM,IAAM2qF,EAEtBE,GAAkB,OAAM3C,EAAiB0C,GAE/C7mF,EAAI/D,EAAM,GAAK6qF,GAAmB3C,EAAiB,GAAKyC,CAC1D,CACF,CACF,CAGA,KAAOl8C,EAAMmqC,GAAY70E,EAAI2L,EAAMoZ,MAAM2lB,GAAK1qC,GAC5C0qC,IAKIA,EAAMmqC,IACR3nC,EAAKvhC,EAAMoZ,MAAM2lB,EAAM,GAAG1qC,EAC1BmtC,EAAKxhC,EAAMoZ,MAAM2lB,GAAK1qC,EAClBsmF,IACFp5C,EAAK/+C,KAAKw4F,MAAMz5C,GAChBC,EAAKh/C,KAAKw4F,MAAMx5C,IAElBu1C,EAAK,GAAK/2E,EAAMoZ,MAAM2lB,EAAM,GAAGgH,EAC/BixC,EAAK,GAAKh3E,EAAMoZ,MAAM2lB,GAAKgH,EAC3BgxC,EAAK,GAAK/2E,EAAMoZ,MAAM2lB,EAAM,GAAG05C,EAC/BzB,EAAK,GAAKh3E,EAAMoZ,MAAM2lB,GAAK05C,EAC3B1B,EAAK,GAAK/2E,EAAMoZ,MAAM2lB,EAAM,GAAGpqC,EAC/BqiF,EAAK,GAAKh3E,EAAMoZ,MAAM2lB,GAAKpqC,EAI3B42C,EAAWvrC,EAAMoZ,MAAM2lB,EAAM,GAAGwM,SAChCi8B,EAAYxnE,EAAMoZ,MAAM2lB,EAAM,GAAGyoC,UAI7Bj8B,EAAW,OACbA,EAAW,MAETA,EAAW,SACbA,EAAW,SAMjB,GAAIl3C,EAAI2L,EAAMi5E,aAAa,GACzB3Q,EAAMc,GAAQ,EACdd,EAAMc,EAAO,GAAK,EAClBd,EAAMc,EAAO,GAAK,EACdppE,EAAM6mE,WACJ9mE,EAAUq7E,yBACZ9S,EAAMc,GAAQppE,EAAMk4E,gBAAgB,GACpC5P,EAAMc,EAAO,GAAKppE,EAAMk4E,gBAAgB,GACxC5P,EAAMc,EAAO,GAAKppE,EAAMk4E,gBAAgB,KAExC5P,EAAMc,GAAQmR,EACdjS,EAAMc,EAAO,GAAKoR,EAClBlS,EAAMc,EAAO,GAAKqR,SAGjB,GAAIpmF,EAAI2L,EAAMi5E,aAAa,KAAM,OAAM5kF,IAAMA,EAAI,EAGtDi0E,EAAMc,GAAQ,EACdd,EAAMc,EAAO,GAAK,EAClBd,EAAMc,EAAO,GAAK,EACdppE,EAAM6mE,WACJ9mE,EAAUs7E,yBACZ/S,EAAMc,GAAQppE,EAAMi4E,gBAAgB,GACpC3P,EAAMc,EAAO,GAAKppE,EAAMi4E,gBAAgB,GACxC3P,EAAMc,EAAO,GAAKppE,EAAMi4E,gBAAgB,IAC/B/O,EAAW,IACpBZ,EAAMc,GAAQppE,EAAMoZ,MAAM,GAAG2sB,EAC7BuiC,EAAMc,EAAO,GAAKppE,EAAMoZ,MAAM,GAAGq/D,EACjCnQ,EAAMc,EAAO,GAAKppE,EAAMoZ,MAAM,GAAGzkB,SAGhC,GAAY,IAARoqC,IAAcv8C,KAAK6uC,IAAIh9B,EAAI00E,GAAU,MAAQ/oE,EAAMu4E,YACxDrP,EAAW,GACbZ,EAAMc,GAAQppE,EAAMoZ,MAAM,GAAG2sB,EAC7BuiC,EAAMc,EAAO,GAAKppE,EAAMoZ,MAAM,GAAGq/D,EACjCnQ,EAAMc,EAAO,GAAKppE,EAAMoZ,MAAM,GAAGzkB,IAEjC2zE,EAAMc,GAAQ,EACdd,EAAMc,EAAO,GAAK,EAClBd,EAAMc,EAAO,GAAK,OAEf,CAML,IAAI7a,EAAI,EAgBR,GAdEA,EADEosB,GACGI,EAAOx5C,IAAOC,EAAKD,IAEnBltC,EAAIktC,IAAOC,EAAKD,GAKrBgtB,EADEA,EAAIhjB,EACF,GAAMgjB,EAAIhjB,EAEV,GAAM,IAAOgjB,EAAIhjB,IAAa,EAAMA,GAKtCi8B,EAAY,IAAM,CAEpB,GAAIjZ,EAAI,GAAK,CACX+Z,EAAMc,GAAQ2N,EAAK,GACnBzO,EAAMc,EAAO,GAAK2N,EAAK,GACvBzO,EAAMc,EAAO,GAAK2N,EAAK,GACvB,QACF,CAEEzO,EAAMc,GAAQ4N,EAAK,GACnB1O,EAAMc,EAAO,GAAK4N,EAAK,GACvB1O,EAAMc,EAAO,GAAK4N,EAAK,GACvB,QAEJ,CAIA,GAAIxP,EAAY,IAAM,CAEpB,GAAIxnE,EAAM43E,aAAe5B,EAAW6B,IAClCvP,EAAMc,IAAS,EAAI7a,GAAKwoB,EAAK,GAAKxoB,EAAIyoB,EAAK,GAC3C1O,EAAMc,EAAO,IAAM,EAAI7a,GAAKwoB,EAAK,GAAKxoB,EAAIyoB,EAAK,GAC/C1O,EAAMc,EAAO,IAAM,EAAI7a,GAAKwoB,EAAK,GAAKxoB,EAAIyoB,EAAK,QAC1C,GAAIh3E,EAAM43E,aAAe5B,EAAWsF,IAAK,CAC9C,MAAM3B,EAAO,GACPC,EAAO,IACb,OAAQ7C,EAAM4C,IACd,OAAQ3C,EAAM4C,GACV55E,EAAM83E,UAAY6B,EAAK,GAAKC,EAAK,GAAK,IAAOA,EAAK,GAAKD,EAAK,GAAK,MAC/DA,EAAK,GAAKC,EAAK,GACjBD,EAAK,IAAM,EAEXC,EAAK,IAAM,GAGf,MAAM2B,EAAS,GACfA,EAAO,IAAM,EAAMhtB,GAAKorB,EAAK,GAAKprB,EAAIqrB,EAAK,GACvC2B,EAAO,GAAK,IACdA,EAAO,IAAM,GAEfA,EAAO,IAAM,EAAMhtB,GAAKorB,EAAK,GAAKprB,EAAIqrB,EAAK,GAC3C2B,EAAO,IAAM,EAAMhtB,GAAKorB,EAAK,GAAKprB,EAAIqrB,EAAK,IAG3C,IAAAlD,GAAQ6E,EAAQb,GAChBpS,EAAMc,GAAQsR,EAAO,GACrBpS,EAAMc,EAAO,GAAKsR,EAAO,GACzBpS,EAAMc,EAAO,GAAKsR,EAAO,EAC3B,MAAO,GAAI16E,EAAM43E,aAAe5B,EAAWwF,IAAK,CAC9C,MAAMvE,EAAO,GACPC,EAAO,IACb,OAAQH,EAAME,IACd,OAAQD,EAAME,GACd,MAAMQ,EAAS,GACfA,EAAO,IAAM,EAAInpB,GAAK0oB,EAAK,GAAK1oB,EAAI2oB,EAAK,GACzCQ,EAAO,IAAM,EAAInpB,GAAK0oB,EAAK,GAAK1oB,EAAI2oB,EAAK,GACzCQ,EAAO,IAAM,EAAInpB,GAAK0oB,EAAK,GAAK1oB,EAAI2oB,EAAK,IAGzC,OAAQQ,EAAQgD,GAChBpS,EAAMc,GAAQsR,EAAO,GACrBpS,EAAMc,EAAO,GAAKsR,EAAO,GACzBpS,EAAMc,EAAO,GAAKsR,EAAO,EAC3B,MAAW16E,EAAM43E,aAAe5B,EAAWyF,WACzC3E,EAA6CvoB,EAAGwoB,EAAMC,EAAM0D,GAC5DpS,EAAMc,GAAQsR,EAAO,GACrBpS,EAAMc,EAAO,GAAKsR,EAAO,GACzBpS,EAAMc,EAAO,GAAKsR,EAAO,IAEzBjY,EAAc,mCAAoCziE,EAAM43E,YAE1D,QACF,CASIrpB,EAAI,GACNA,EAAI,IAAW,EAAJA,KAAa,EAAM,GAAOiZ,GAC5BjZ,EAAI,KACbA,EAAI,EAAM,IAAmB,GAAX,EAAMA,MAAY,EAAI,GAAOiZ,IAIjD,MAAM6B,EAAK9a,EAAIA,EACT+a,EAAMD,EAAK9a,EACXgb,EAAK,EAAMD,EAAM,EAAID,EAAK,EAC1BG,GAAM,EAAIF,EAAM,EAAID,EACpBI,EAAKH,EAAM,EAAID,EAAK9a,EACpBmb,EAAKJ,EAAMD,EACjB,IAAI16D,EACAsgC,EACJ,GAAIjvC,EAAM43E,aAAe5B,EAAW6B,IAClC,IAAK,IAAI1zC,EAAI,EAAGA,EAAI,EAAGA,IAErBx1B,EAAQqoE,EAAK7yC,GAAK4yC,EAAK5yC,GACvB8K,GAAK,EAAMu4B,GAAa74D,EAGxB25D,EAAMc,EAAOjlC,GAAKolC,EAAKwN,EAAK5yC,GAAKqlC,EAAKwN,EAAK7yC,GAAKslC,EAAKx6B,EAAIy6B,EAAKz6B,OAE3D,GAAIjvC,EAAM43E,aAAe5B,EAAWsF,IAAK,CAC9C,MAAM3B,EAAO,GACPC,EAAO,IACb,OAAQ7C,EAAM4C,IACd,OAAQ3C,EAAM4C,GACV55E,EAAM83E,UAAY6B,EAAK,GAAKC,EAAK,GAAK,IAAOA,EAAK,GAAKD,EAAK,GAAK,MAC/DA,EAAK,GAAKC,EAAK,GACjBD,EAAK,IAAM,EAEXC,EAAK,IAAM,GAGf,MAAM2B,EAAS,GACf,IAAK,IAAIp3C,EAAI,EAAGA,EAAI,EAAGA,IAErBx1B,EAAQirE,EAAKz1C,GAAKw1C,EAAKx1C,GACvB8K,GAAK,EAAMu4B,GAAa74D,EAGxB4sE,EAAOp3C,GAAKolC,EAAKoQ,EAAKx1C,GAAKqlC,EAAKoQ,EAAKz1C,GAAKslC,EAAKx6B,EAAIy6B,EAAKz6B,EAC9C,IAAN9K,GAAWo3C,EAAOp3C,GAAK,IACzBo3C,EAAOp3C,IAAM,IAIjB,IAAAuyC,GAAQ6E,EAAQb,GAChBpS,EAAMc,GAAQsR,EAAO,GACrBpS,EAAMc,EAAO,GAAKsR,EAAO,GACzBpS,EAAMc,EAAO,GAAKsR,EAAO,EAC3B,MAAO,GAAI16E,EAAM43E,aAAe5B,EAAWwF,IAAK,CAC9C,MAAMvE,EAAO,GACPC,EAAO,IACb,OAAQH,EAAME,IACd,OAAQD,EAAME,GACd,MAAMQ,EAAS,GACf,IAAK,IAAIvzC,EAAI,EAAGA,EAAI,EAAGA,IAErBx1B,EAAQuoE,EAAK/yC,GAAK8yC,EAAK9yC,GACvB8K,GAAK,EAAMu4B,GAAa74D,EAGxB+oE,EAAOvzC,GAAKolC,EAAK0N,EAAK9yC,GAAKqlC,EAAK0N,EAAK/yC,GAAKslC,EAAKx6B,EAAIy6B,EAAKz6B,GAG1D,OAAQyoC,EAAQgD,GAChBpS,EAAMc,GAAQsR,EAAO,GACrBpS,EAAMc,EAAO,GAAKsR,EAAO,GACzBpS,EAAMc,EAAO,GAAKsR,EAAO,EAC3B,MAAW16E,EAAM43E,aAAe5B,EAAWyF,WAIzC3E,EAA6CvoB,EAAGwoB,EAAMC,EAAM0D,GAC5DpS,EAAMc,GAAQsR,EAAO,GACrBpS,EAAMc,EAAO,GAAKsR,EAAO,GACzBpS,EAAMc,EAAO,GAAKsR,EAAO,IAEzBjY,EAAc,oCAIhB,IAAK,IAAIt+B,EAAI,EAAGA,EAAI,EAAGA,IACrBmkC,EAAMc,EAAOjlC,GAAKmkC,EAAMc,EAAOjlC,GAAK,EAAM,EAAMmkC,EAAMc,EAAOjlC,GAC7DmkC,EAAMc,EAAOjlC,GAAKmkC,EAAMc,EAAOjlC,GAAK,EAAM,EAAMmkC,EAAMc,EAAOjlC,EAEjE,CACF,GAIFpkC,EAAU27E,cAAgB,SAAU3S,EAAQC,EAAM9+D,GAChD,IAAIyxE,EAAYvxB,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,IAAmBA,UAAU,GAC/E,GAAIrqD,EAAU67E,YAAc57E,EAAMs4E,WAAat4E,EAAMq4E,YAAcnuE,GAAQlK,EAAM67E,iBAAmBF,EAClG,OAAO37E,EAAMsoE,MAEf,GAA2B,IAAvBtoE,EAAMoZ,MAAM1tB,OAEd,OADA+2E,EAAc,+DACPziE,EAAMsoE,MAEf,MAAMwT,EAAaH,EAAY,EAAI,EAC/B37E,EAAMq4E,YAAcnuE,GAAQlK,EAAM67E,iBAAmBF,IACvD37E,EAAMsoE,MAAQ,IAAIt5D,WAAW9E,EAAO4xE,GACpC97E,EAAMq4E,UAAYnuE,EAClBlK,EAAM67E,eAAiBF,GAEzB,MAAMI,EAAW,GACjBh8E,EAAUwoE,SAASQ,EAAQC,EAAM9+D,EAAM6xE,GACvC,IAAK,IAAInxF,EAAI,EAAGA,EAAIsf,EAAMtf,IACxBoV,EAAMsoE,MAAM19E,EAAIkxF,EAAa,GAAKt5F,KAAK6O,MAA4B,IAAtB0qF,EAAa,EAAJnxF,EAAQ,GAAa,IAC3EoV,EAAMsoE,MAAM19E,EAAIkxF,EAAa,GAAKt5F,KAAK6O,MAA4B,IAAtB0qF,EAAa,EAAJnxF,EAAQ,GAAa,IAC3EoV,EAAMsoE,MAAM19E,EAAIkxF,EAAa,GAAKt5F,KAAK6O,MAA4B,IAAtB0qF,EAAa,EAAJnxF,EAAQ,GAAa,IACvE+wF,IACF37E,EAAMsoE,MAAM19E,EAAIkxF,EAAa,GAAK,KAItC,OADA97E,EAAMs4E,UAAU1b,WACT58D,EAAMsoE,KACf,EACAvoE,EAAUi8E,uBAAyBpoF,IACjCmM,EAAUsZ,kBACV,MAAM5I,EAAgB7c,EAAM2I,wBAC5B,IAAK,IAAI3R,EAAI,EAAGA,EAAIgJ,EAAMqoF,oBAAqBrxF,IAC7C,OAAQ6lB,GACN,KAAK,EAEDzQ,EAAMoZ,MAAM5mB,KAAK,CACf6B,EAAGzJ,EACHm7C,EAAGnyC,EAAM8yE,aAAa97E,EAAG,GACzB6tF,EAAG7kF,EAAM8yE,aAAa97E,EAAG,GACzB+J,EAAGf,EAAM8yE,aAAa97E,EAAG,GACzB2gD,SAAU,GACVi8B,UAAW,IAEb,MAEJ,KAAK,EAEDxnE,EAAMoZ,MAAM5mB,KAAK,CACf6B,EAAGT,EAAM8yE,aAAa97E,EAAG,GACzBm7C,EAAGnyC,EAAM8yE,aAAa97E,EAAG,GACzB6tF,EAAG7kF,EAAM8yE,aAAa97E,EAAG,GACzB+J,EAAGf,EAAM8yE,aAAa97E,EAAG,GACzB2gD,SAAU,GACVi8B,UAAW,IAEb,MAEJ,KAAK,EAEDxnE,EAAMoZ,MAAM5mB,KAAK,CACf6B,EAAGzJ,EACHm7C,EAAGnyC,EAAM8yE,aAAa97E,EAAG,GACzB6tF,EAAG7kF,EAAM8yE,aAAa97E,EAAG,GACzB+J,EAAGf,EAAM8yE,aAAa97E,EAAG,GACzB2gD,SAAU33C,EAAM8yE,aAAa97E,EAAG,GAChC48E,UAAW5zE,EAAM8yE,aAAa97E,EAAG,KAEnC,MAEJ,KAAK,EAEDoV,EAAMoZ,MAAM5mB,KAAK,CACf6B,EAAGT,EAAM8yE,aAAa97E,EAAG,GACzBm7C,EAAGnyC,EAAM8yE,aAAa97E,EAAG,GACzB6tF,EAAG7kF,EAAM8yE,aAAa97E,EAAG,GACzB+J,EAAGf,EAAM8yE,aAAa97E,EAAG,GACzB2gD,SAAU33C,EAAM8yE,aAAa97E,EAAG,GAChC48E,UAAW5zE,EAAM8yE,aAAa97E,EAAG,KAM3CmV,EAAU4nE,oBAAoB,EAIhC5nE,EAAUm8E,uBAAyB,CAACnT,EAAQC,EAAM9+D,EAAMo+D,KACtD,IAAI6T,EAAM,EACVp8E,EAAUsZ,kBACNnP,EAAO,IACTiyE,GAAOnT,EAAOD,IAAW7+D,EAAO,IAElC,IAAK,IAAItf,EAAI,EAAGA,EAAIsf,EAAMtf,IAAK,CAC7B,MAAM0uB,EAAO,CACXjlB,EAAG00E,EAASoT,EAAMvxF,EAClBm7C,EAAGuiC,EAAU,EAAJ19E,GACT6tF,EAAGnQ,EAAU,EAAJ19E,EAAQ,GACjB+J,EAAG2zE,EAAU,EAAJ19E,EAAQ,GACjB48E,UAAW,EACXj8B,SAAU,IAEZvrC,EAAMoZ,MAAM5mB,KAAK8mB,EACnB,CACAvZ,EAAU4nE,oBAAoB,EAKhC5nE,EAAUmZ,aAAe,CAAC/qB,EAAOmlC,IAC3BnlC,EAAQ,GAAKA,GAAS6R,EAAMoZ,MAAM1tB,QACpC+2E,EAAc,wBACN,IAEVnvC,EAAI,GAAKtzB,EAAMoZ,MAAMjrB,GAAOkG,EAC5Bi/B,EAAI,GAAKtzB,EAAMoZ,MAAMjrB,GAAO43C,EAC5BzS,EAAI,GAAKtzB,EAAMoZ,MAAMjrB,GAAOsqF,EAC5BnlD,EAAI,GAAKtzB,EAAMoZ,MAAMjrB,GAAOwG,EAC5B2+B,EAAI,GAAKtzB,EAAMoZ,MAAMjrB,GAAOo9C,SAC5BjY,EAAI,GAAKtzB,EAAMoZ,MAAMjrB,GAAOq5E,UACrB,GAKTznE,EAAU0nE,aAAe,CAACt5E,EAAOmlC,KAC/B,GAAInlC,EAAQ,GAAKA,GAAS6R,EAAMoZ,MAAM1tB,OAEpC,OADA+2E,EAAc,wBACN,EAEV,MAAMiF,EAAO1nE,EAAMoZ,MAAMjrB,GAAOkG,EAgBhC,OAfA2L,EAAMoZ,MAAMjrB,GAAOkG,EAAIi/B,EAAI,GAC3BtzB,EAAMoZ,MAAMjrB,GAAO43C,EAAIzS,EAAI,GAC3BtzB,EAAMoZ,MAAMjrB,GAAOsqF,EAAInlD,EAAI,GAC3BtzB,EAAMoZ,MAAMjrB,GAAOwG,EAAI2+B,EAAI,GAC3BtzB,EAAMoZ,MAAMjrB,GAAOo9C,SAAWjY,EAAI,GAClCtzB,EAAMoZ,MAAMjrB,GAAOq5E,UAAYl0C,EAAI,GAC/Bo0C,IAASp0C,EAAI,GAGfvzB,EAAU4nE,qBAIV5nE,EAAU68D,WAEL,CAAC,EAIV78D,EAAUq8E,2BAA6B,IACjCp8E,EAAM85E,eAAiB/5E,EAAUiZ,UAC5BjZ,EAAUiZ,UAEfhZ,EAAMq4E,UAIDr4E,EAAMq4E,UAER,SAITt4E,EAAUs8E,gBAAkB,CAACt9C,EAAKzoC,KAChC,MAAM1B,EAAImL,EAAUiZ,UACpB,GAAIpkB,EAAI,GAAKmqC,GAAO,EAAG,CACrB,MAAMu9C,EAAY,GAClBv8E,EAAUmZ,aAAa6lB,EAAMnqC,EAAG0nF,GAChC,IAAK,IAAIn4C,EAAI,EAAGA,EAAI,IAAKA,EACvB7tC,EAAK6tC,GAAKm4C,EAAUn4C,EAAI,GAG1B,YADA7tC,EAAK,GAAK,EAEZ,CACA,MAAM0hF,EAAWj4E,EAAUi6E,yBAC3B1jF,EAAK,GAAK0hF,EAAS,GACnB1hF,EAAK,GAAK0hF,EAAS,GACnB1hF,EAAK,GAAK0hF,EAAS,GACnB1hF,EAAK,GAAK,CAAG,EAIfyJ,EAAUw8E,oBAAsB,CAACC,EAAI75B,KACnC,KAAI65B,GAAM,IAAM75B,EAAhB,CAGA5iD,EAAUsZ,kBACV,IAAK,IAAIzuB,EAAI,EAAGA,EAAI4xF,EAAI5xF,IACtBmV,EAAUwY,YAAYoqC,EAAQ,EAAJ/3D,GAAQ+3D,EAAQ,EAAJ/3D,EAAQ,GAAI+3D,EAAQ,EAAJ/3D,EAAQ,GAAI+3D,EAAQ,EAAJ/3D,EAAQ,GAHhF,CAIA,EAIFmV,EAAUJ,gBAAkB,CAACxG,EAAKrK,KAChC,MAAMwB,EAAQ,CAAC6I,EAAKrK,GACd2tF,EAAgB18E,EAAUpT,WAChC,GAAI8vF,EAAc,KAAOnsF,EAAM,IAAMmsF,EAAc,KAAOnsF,EAAM,GAC9D,OAEF,GAAIA,EAAM,KAAOA,EAAM,GAErB,YADAmyE,EAAc,yCAGhB,MAAM5wE,GAASvB,EAAM,GAAKA,EAAM,KAAOmsF,EAAc,GAAKA,EAAc,IAClEjjF,EAAQlJ,EAAM,GAAKmsF,EAAc,GAAK5qF,EAC5C,IAAK,IAAIjH,EAAI,EAAGA,EAAIoV,EAAMoZ,MAAM1tB,SAAUd,EACxCoV,EAAMoZ,MAAMxuB,GAAGyJ,EAAI2L,EAAMoZ,MAAMxuB,GAAGyJ,EAAIxC,EAAQ2H,EAEhDwG,EAAMi5E,aAAa,GAAK3oF,EAAM,GAC9B0P,EAAMi5E,aAAa,GAAK3oF,EAAM,GAC9ByP,EAAU68D,UAAU,EAItB78D,EAAUyoE,YAAcl4E,IACtB,MAAMm4E,EAAgB1oE,EAAUpT,WAG1BksF,EAAM,GACRpQ,EAAc,GAAKn4E,EAAM,IAC3ByP,EAAUjJ,SAASxG,EAAM,GAAIuoF,GAC7B94E,EAAUwY,YAAYjoB,EAAM,GAAIuoF,EAAI,GAAIA,EAAI,GAAIA,EAAI,MAEpD94E,EAAUjJ,SAAS2xE,EAAc,GAAIoQ,GACrC94E,EAAUwY,YAAYjoB,EAAM,GAAIuoF,EAAI,GAAIA,EAAI,GAAIA,EAAI,KAElDpQ,EAAc,GAAKn4E,EAAM,IAC3ByP,EAAUjJ,SAASxG,EAAM,GAAIuoF,GAC7B94E,EAAUwY,YAAYjoB,EAAM,GAAIuoF,EAAI,GAAIA,EAAI,GAAIA,EAAI,MAEpD94E,EAAUjJ,SAAS2xE,EAAc,GAAIoQ,GACrC94E,EAAUwY,YAAYjoB,EAAM,GAAIuoF,EAAI,GAAIA,EAAI,GAAIA,EAAI,KAItD94E,EAAU4nE,qBACV,IAAK,IAAI/8E,EAAI,EAAGA,EAAIoV,EAAMoZ,MAAM1tB,QAC1BsU,EAAMoZ,MAAMxuB,GAAGyJ,GAAK/D,EAAM,IAAM0P,EAAMoZ,MAAMxuB,GAAGyJ,GAAK/D,EAAM,GAC5D0P,EAAMoZ,MAAM11B,OAAOkH,EAAG,KAEpBA,EAGN,OAAO,CAAC,EAIVmV,EAAU2oE,2BAA6B,CAACnnC,EAAIC,KAC1C,MAAMmnC,EAAI5oE,EAAU6oE,uBACpB,OAAOpmF,KAAKqmF,MAAMrnC,EAAKD,GAAMonC,EAAE,EAIjC5oE,EAAU6oE,qBAAuB,KAC/B,GAAI5oE,EAAMoZ,MAAM1tB,OAAS,EACvB,OAAQ,EAEV,IAAI0kC,EAAW5/B,OAAO+2E,UACtB,IAAK,IAAI38E,EAAI,EAAGA,EAAIoV,EAAMoZ,MAAM1tB,OAAS,EAAGd,IAAK,CAC/C,MAAMk+E,EAAc9oE,EAAMoZ,MAAMxuB,EAAI,GAAGyJ,EAAI2L,EAAMoZ,MAAMxuB,GAAGyJ,EACtDy0E,EAAc14C,IAChBA,EAAW04C,EAEf,CACA,OAAO14C,CAAQ,EAEjBrwB,EAAU28E,uBAAyB,CAACjgB,EAAOC,EAAQigB,EAAWC,KAChC,IAAxB78E,EAAUiZ,UAIVhZ,EAAM85E,cACR/5E,EAAU88E,eAAepgB,EAAOC,EAAQigB,EAAWC,GAEnD78E,EAAU+8E,QAAQrgB,EAAOC,EAAQigB,EAAWC,GAN5CvQ,EAAc,mCAOhB,EAIFtsE,EAAU+8E,QAAU,CAACrgB,EAAOC,EAAQigB,EAAWC,KAC7C,GAA4B,IAAxB78E,EAAUiZ,UAEZ,YADAm9D,EAAgB,oCAGlB,MAAM3D,EAAQhwF,KAAK6O,MAA6B,IAAvB0O,EAAUg9E,WAAqB,IAClDrxF,EAAS+wE,EAAMwf,oBACfe,EAASvgB,EAAMlgE,wBACf0gF,EAAUvgB,EAAO9sB,UACjBstC,EAASzgB,EAAM7sB,UACfipC,EAAM,GACZ,GAAI8D,IAAczG,EAAoBiH,KACpC,IAAK,IAAIvyF,EAAI,EAAGA,EAAIc,EAAQd,IAAK,CAC/B,MAAMyJ,EAAI6oF,EAAOtyF,EAAIoyF,EAASJ,GAC9B78E,EAAUjJ,SAASzC,EAAGwkF,GACtBoE,EAAY,EAAJryF,GAASpI,KAAK6O,MAAe,IAATwnF,EAAI,GAAa,IAC7CoE,EAAY,EAAJryF,EAAQ,GAAKpI,KAAK6O,MAAe,IAATwnF,EAAI,GAAa,IACjDoE,EAAY,EAAJryF,EAAQ,GAAKpI,KAAK6O,MAAe,IAATwnF,EAAI,GAAa,IACjDoE,EAAY,EAAJryF,EAAQ,GAAK4nF,CACvB,CAEF,GAAImK,IAAczG,EAAoB2B,IACpC,IAAK,IAAIjtF,EAAI,EAAGA,EAAIc,EAAQd,IAAK,CAC/B,MAAMyJ,EAAI6oF,EAAOtyF,EAAIoyF,EAASJ,GAC9B78E,EAAUjJ,SAASzC,EAAGwkF,GACtBoE,EAAY,EAAJryF,GAASpI,KAAK6O,MAAe,IAATwnF,EAAI,GAAa,IAC7CoE,EAAY,EAAJryF,EAAQ,GAAKpI,KAAK6O,MAAe,IAATwnF,EAAI,GAAa,IACjDoE,EAAY,EAAJryF,EAAQ,GAAKpI,KAAK6O,MAAe,IAATwnF,EAAI,GAAa,GACnD,CAEF,GAAI8D,IAAczG,EAAoBkH,UACpC,IAAK,IAAIxyF,EAAI,EAAGA,EAAIc,EAAQd,IAAK,CAC/B,MAAMyJ,EAAI6oF,EAAOtyF,EAAIoyF,EAASJ,GAC9B78E,EAAUjJ,SAASzC,EAAGwkF,GACtBoE,EAAQryF,GAAKpI,KAAK6O,MAAe,KAATwnF,EAAI,GAAqB,OAATA,EAAI,GAAuB,MAATA,EAAI,GAAa,GAC7E,CAEF,GAAI8D,IAAczG,EAAoBmH,gBACpC,IAAK,IAAIzyF,EAAI,EAAGA,EAAIc,EAAQd,IAAK,CAC/B,MAAMyJ,EAAI6oF,EAAOtyF,EAAIoyF,EAASJ,GAC9B78E,EAAUjJ,SAASzC,EAAGwkF,GACtBoE,EAAY,EAAJryF,GAASpI,KAAK6O,MAAe,KAATwnF,EAAI,GAAqB,OAATA,EAAI,GAAuB,MAATA,EAAI,GAAa,IAC/EoE,EAAY,EAAJryF,EAAQ,GAAK4nF,CACvB,CACF,EAIFzyE,EAAUu9E,cAAgBC,IACxB,MAAMC,EAAgB5hC,KAAKE,UAAU97C,EAAM43E,YACvC2F,EAASvH,aACXh2E,EAAM43E,WAAa5B,EAAWuH,EAASvH,WAAWyH,oBACzB5xF,IAArBmU,EAAM43E,aACRnV,EAAc,cAAc8a,EAASvH,+CACrCh2E,EAAM43E,WAAa5B,EAAW6B,MAGlC,IAAI6F,EAAaF,IAAkB5hC,KAAKE,UAAU97C,EAAM43E,YACxD,MAAM+F,EAAcD,GAAc9hC,KAAKE,UAAU97C,EAAMg4E,UACvD,GAAIuF,EAASK,SAEX,IADA59E,EAAMg4E,SAAW,GAAGlgE,OAAOylE,EAASK,UAC7B59E,EAAMg4E,SAAStsF,OAAS,GAC7BsU,EAAMg4E,SAASxlF,KAAK,GAGxBkrF,EAAaA,GAAcC,IAAgB/hC,KAAKE,UAAU97C,EAAMg4E,UAChE,MAAM6F,EAAWH,GAAc9hC,KAAKE,UAAU97C,EAAMoZ,OACpD,GAAImkE,EAASxlE,UAAW,CACtB,MAAM7N,EAAOqzE,EAASxlE,UAAUrsB,OAChCsU,EAAMoZ,MAAQ,GACd,MAAMmyB,EAAW,GACXi8B,EAAY,EAClB,IAAK,IAAI58E,EAAI,EAAGA,EAAIsf,EAAMtf,GAAK,EAC7BoV,EAAMoZ,MAAM5mB,KAAK,CACf6B,EAAGkpF,EAASxlE,UAAUntB,GACtBm7C,EAAGw3C,EAASxlE,UAAUntB,EAAI,GAC1B6tF,EAAG8E,EAASxlE,UAAUntB,EAAI,GAC1B+J,EAAG4oF,EAASxlE,UAAUntB,EAAI,GAC1B2gD,WACAi8B,aAGN,CACA,MAAMW,EAAkBpoE,EAAU4nE,qBAC5BmW,GAAgB3V,IAAoBuV,GAAcG,IAAajiC,KAAKE,UAAU97C,EAAMoZ,QAE1F,OADI0kE,GAAc/9E,EAAU68D,WACrBuL,GAAmB2V,CAAY,CAE1C,CAwDEC,CAAyBh+E,EAAWC,EACtC,CAQA,IAAIg+E,EAA6B,CAC/Bz9E,YALkB,EAAA67D,EAAM77D,YAAYT,EAAQ,4BAM5CA,YACG,4DC7rCL,MAAMm+E,EAAYxwF,OAAOuT,OAAO,MAChC,EAAA43D,EAAexpE,QAAO8xB,GAAKA,EAAEnJ,YAAW3oB,QAAO8xB,GAAsB,WAAjBA,EAAE80D,aAAyB7jF,SAAQ+uB,IACrF+8D,EAAU/8D,EAAE/J,MAAQ+J,CAAC,IAKvB,MAAM1J,EAAiB/pB,OAAOyU,KAAK+7E,GACnCzmE,EAAeliB,OAiCf,IAAI4oF,EAAe,CACjBC,UAxBF,SAAmBC,GACZA,EAAOrmE,WAAmC,WAAtBqmE,EAAOpI,aAG3BiI,EAAUG,EAAOjnE,QACpBK,EAAehlB,KAAK4rF,EAAOjnE,MAC3BK,EAAeliB,QAEjB2oF,EAAUG,EAAOjnE,MAAQinE,EAC3B,EAgBEC,mBAZF,SAA4BxoF,GAC1B,MAAM1H,EAAQqpB,EAAeppB,QAAQyH,GACjC1H,GAAS,GACXqpB,EAAe9zB,OAAOyK,EAAO,UAExB8vF,EAAUpoF,EACnB,EAOE6hB,gBAhCF,SAAyB7hB,GACvB,OAAOooF,EAAUpoF,EACnB,EA+BE2hB,2HCxCF,MAAM,gBACJ8mE,EAAe,mBACfC,GACE,WACE,YACJC,GACE,UAyPJ,MAAM5+E,EAAiB,CACrB2tE,YAAaiR,EAAYC,KACzBC,eAAgB,CACdC,QAASH,EAAYC,KACrBG,MAAM,GAERC,mBAAmB,EACnBC,mBAAmB,EACnBC,wBAAwB,GAK1B,SAASj/E,EAAOC,EAAWC,GACzB,IAAIC,EAAgBmqD,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzF38D,OAAOyS,OAAOF,EAAOJ,EAAgBK,GAGrC,WAA8BF,EAAWC,EAAOC,GAChD,EAAAm8D,EAAMzuE,IAAIoS,EAAWC,EAAO,CAAC,gBAC7B,EAAAo8D,EAAM2K,OAAOhnE,EAAWC,EAAO,CAAC,iBAAkB,oBAAqB,oBAAqB,2BAC5F,UAAyBg/E,mCAAmCj/E,EAAWC,GAxQzE,SAAwBD,EAAWC,GAmHjC,SAASi/E,IACP,IAAIC,EACJ,OAAQl/E,EAAMutE,aACZ,KAAKiR,EAAYW,EACfD,EAAU,EACV,MACF,KAAKV,EAAYY,EACfF,EAAU,EACV,MACF,KAAKV,EAAYa,EACfH,EAAU,EACV,MACF,QAKE,YAJAl/E,EAAM0+E,eAAiB,CACrBC,QAAS3+E,EAAMutE,YACfqR,MAAM,IAOZ,MAAMr2F,EAAYwX,EAAUu/E,kBAAkBzyF,eACxC0yF,GAAY,OAA0Bh3F,GAG5C,IAAIo2F,EAAU,EACd,KAAOA,EAAU,GAC0B,IAArCY,EAAUL,EAAU,EAAIP,KADRA,GAKtB,MAAMC,EAAOW,EAAUL,EAAU,EAAIP,GAAW,EAChD3+E,EAAM0+E,eAAiB,CACrBC,UACAC,OAEJ,CAtJA5+E,EAAMG,eAAe3N,KAAK,kBAC1BuN,EAAUy/E,mBAAqBC,IAC7B,MAAMz4F,EAAQ+Y,EAAUu/E,kBACxB,IAAII,EACJ,GAAmB,IAAfD,EAAI/zF,OACNg0F,EAAOD,OACF,GAAIjvF,OAAOmvF,SAASF,GAAM,CAC/B,MAAMG,EAAM54F,EAAMo9E,YAClB,OAAQpkE,EAAMutE,aACZ,KAAKiR,EAAYW,EACfO,EAAO,CAACD,GAAMG,EAAI,GAAKA,EAAI,IAAM,GAAIA,EAAI,GAAKA,EAAI,IAAM,GACxD,MACF,KAAKpB,EAAYY,EACfM,EAAO,EAAEE,EAAI,GAAKA,EAAI,IAAM,EAAGH,GAAMG,EAAI,GAAKA,EAAI,IAAM,GACxD,MACF,KAAKpB,EAAYa,EACfK,EAAO,EAAEE,EAAI,GAAKA,EAAI,IAAM,GAAIA,EAAI,GAAKA,EAAI,IAAM,EAAGH,GAG5D,CACA,MAAM/b,EAAM,CAAC,EAAG,EAAG,GACnB18E,EAAMgG,aAAa0yF,EAAMhc,GACzB,MAAMa,EAAKv9E,EAAMo5E,aACX,QACJue,GACE5+E,EAAU8/E,oBACd,IAAIr+E,EAAQ,EACZ,OAAQm9E,GACN,KAAKH,EAAYsB,EACft+E,GAAQ,OAAWkiE,EAAI,GAAIa,EAAG,GAAIA,EAAG,IACrC,MACF,KAAKia,EAAYuB,EACfv+E,GAAQ,OAAWkiE,EAAI,GAAIa,EAAG,GAAIA,EAAG,IACrC,MACF,KAAKia,EAAYwB,EACfx+E,GAAQ,OAAWkiE,EAAI,GAAIa,EAAG,GAAIA,EAAG,IACrC,MACF,QACE,OAAO,EAEX,OAAO/iE,CAAK,EAEdzB,EAAUkgF,mBAAqBC,IAC7B,MAAMj1B,EAAKi1B,EAAIC,gBACf,OAAQngF,EAAMutE,aACZ,KAAKiR,EAAYsB,EACjB,KAAKtB,EAAYuB,EACjB,KAAKvB,EAAYwB,EACf,CACE,MAAMx+E,EAAQzB,EAAUy/E,mBAAmBv0B,GAC3ClrD,EAAUqgF,SAAS5+E,EACrB,CACA,MACF,KAAKg9E,EAAYW,EACfp/E,EAAUqgF,SAASn1B,EAAG,IACtB,MACF,KAAKuzB,EAAYY,EACfr/E,EAAUqgF,SAASn1B,EAAG,IACtB,MACF,KAAKuzB,EAAYa,EACft/E,EAAUqgF,SAASn1B,EAAG,IAE1B,EAEFlrD,EAAUsgF,UAAYj7F,IACpB2a,EAAUugF,eAAe9B,EAAYW,GACrCp/E,EAAUqgF,SAASh7F,EAAG,EAExB2a,EAAUwgF,UAAYn7F,IACpB2a,EAAUugF,eAAe9B,EAAYY,GACrCr/E,EAAUqgF,SAASh7F,EAAG,EAExB2a,EAAUygF,UAAYp7F,IACpB2a,EAAUugF,eAAe9B,EAAYa,GACrCt/E,EAAUqgF,SAASh7F,EAAG,EAExB2a,EAAU0gF,UAAYr7F,IACpB2a,EAAUugF,eAAe9B,EAAYsB,GACrC//E,EAAUqgF,SAASh7F,EAAG,EAExB2a,EAAU2gF,UAAYt7F,IACpB2a,EAAUugF,eAAe9B,EAAYuB,GACrChgF,EAAUqgF,SAASh7F,EAAG,EAExB2a,EAAU4gF,UAAYv7F,IACpB2a,EAAUugF,eAAe9B,EAAYwB,GACrCjgF,EAAUqgF,SAASh7F,EAAG,EAExB2a,EAAU6gF,qBAAuB,KAC/B,MAAMjgC,EAAM,CAAC,EAAG,EAAG,GACbkgC,EAAO9gF,EAAUu/E,kBAAkBzyF,eACzC,OAAQmT,EAAMutE,aACZ,KAAKiR,EAAYW,EACfx+B,EAAI,GAAK,EACT,MACF,KAAK69B,EAAYY,EACfz+B,EAAI,GAAK,EACT,MACF,KAAK69B,EAAYa,EACf1+B,EAAI,GAAK,EACT,MACF,KAAK69B,EAAYsB,GACf,OAAkBe,EAAM,CAAC,EAAG,EAAG,GAAIlgC,GACnC,MACF,KAAK69B,EAAYuB,GACf,OAAkBc,EAAM,CAAC,EAAG,EAAG,GAAIlgC,GACnC,MACF,KAAK69B,EAAYwB,GACf,OAAkBa,EAAM,CAAC,EAAG,EAAG,GAAIlgC,GAGvC,OAAOA,CAAG,EAwCZ5gD,EAAUugF,eAAiBhjC,IACrBt9C,EAAMutE,cAAgBjwB,IAG1Bt9C,EAAMutE,YAAcjwB,EAChBv9C,EAAUu/E,mBACZL,IAEFl/E,EAAU68D,WAAU,EAEtB78D,EAAU8/E,kBAAoB,UACEh0F,IAAzBmU,EAAM0+E,gBAAgC1+E,EAAM0+E,eAAeC,UAAYH,EAAYC,OAAS1+E,EAAUu/E,mBACzGL,IAEKj/E,EAAM0+E,gBAEf3+E,EAAUqkE,UAAY,KACpB,MAAMp9E,EAAQ+Y,EAAUu/E,kBACxB,IAAKt4F,EACH,OAAO,SAET,IAAKgZ,EAAM8gF,iBACT,OAAO95F,EAAMo9E,YAEf,MAAMG,EAAKvkE,EAAM+gF,oBAAoBv/E,SAC/B,QACJm9E,GACE5+E,EAAU8/E,oBACd,IAAImB,EAAShhF,EAAMwB,MAKnB,OAJIm9E,IAAY3+E,EAAMutE,cAEpByT,EAASjhF,EAAUy/E,mBAAmBx/E,EAAMwB,QAEtCm9E,GACN,KAAKH,EAAYsB,EACfvb,EAAG,GAAKyc,EACRzc,EAAG,GAAKyc,EACR,MACF,KAAKxC,EAAYuB,EACfxb,EAAG,GAAKyc,EACRzc,EAAG,GAAKyc,EACR,MACF,KAAKxC,EAAYwB,EACfzb,EAAG,GAAKyc,EACRzc,EAAG,GAAKyc,EAGZ,OAAOh6F,EAAMq9E,eAAeE,EAAG,EAEjCxkE,EAAUkhF,kBAAoB,WAC5B,IAAIz/E,EAAQ4oD,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAKpqD,EAAMwB,MAClF0/E,EAAgB92B,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,EACxF,MAAMpjE,EAAQ+Y,EAAUu/E,kBACxB,IAAKt4F,EACH,OAAO,SAET,MAAMm5E,EAASn5E,EAAMs9E,oBACf,QACJqa,GACE5+E,EAAU8/E,oBACd,IAAImB,EAASx/E,EAKb,OAJIm9E,IAAY3+E,EAAMutE,cAEpByT,EAASjhF,EAAUy/E,mBAAmBh+E,IAEhCm9E,GACN,KAAKH,EAAYsB,EACf3f,EAAO,GAAK6gB,EAASE,EACrB/gB,EAAO,GAAK6gB,EAASE,EACrB,MACF,KAAK1C,EAAYuB,EACf5f,EAAO,GAAK6gB,EAASE,EACrB/gB,EAAO,GAAK6gB,EAASE,EACrB,MACF,KAAK1C,EAAYwB,EACf7f,EAAO,GAAK6gB,EAASE,EACrB/gB,EAAO,GAAK6gB,EAASE,EAGzB,OAAOl6F,EAAMq9E,eAAelE,EAC9B,EACApgE,EAAUohF,iCAAmC,CAACt+C,EAAIC,KAAO,OAAiCD,EAAIC,EAAI/iC,GAClGA,EAAUqhF,gCAAkC,CAACv+C,EAAIC,KAAO,OAAgCD,EAAIC,EAAI/iC,GAChGA,EAAUu/E,gBAAkB,IAAMv/E,EAAU64C,cAC9C,CA8BEyoC,CAAethF,EAAWC,EAC5B,CAQA,IAAIshF,EAAmB,CACrB/gF,YALkB,EAAA67D,EAAM77D,YAAYT,EAAQ,kBAM5CA,YACGw+E,KACAC,KACA,uGCtSL,MAAM,cACJlS,GACE,EAAAjQ,EAoJJ,MAAMx8D,EAAiB,CACrB2hF,OAAQ,KACRp0D,SAAU,KACVipB,OAAQ,IAAI,KAAeorC,cAK7B,SAAS1hF,EAAOC,EAAWC,GACzB,IAAIC,EAAgBmqD,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzF38D,OAAOyS,OAAOF,EAAOJ,EAAgBK,GAGrC,YAAiBF,EAAWC,EAAOC,GAGnCD,EAAMyhF,YAAc,CAAC,EACrB,EAAArlB,EAAMvS,IAAI7pD,EAAMyhF,aAGhB,EAAArlB,EAAMj9D,IAAIY,EAAWC,EAAO,CAAC,aAC7B,EAAAo8D,EAAM2K,OAAOhnE,EAAWC,EAAO,CAAC,WAChC,EAAAo8D,EAAMyG,SAAS9iE,EAAWC,EAAO,CAAC,UAAW,GApK/C,SAAuBD,EAAWC,GAEhCA,EAAMG,eAAe3N,KAAK,iBAC1BuN,EAAUhb,UAAY,IAAMgb,EAC5BA,EAAU2hF,UAAY,IAAM3hF,EAC5BA,EAAU4hF,YAAc,KACtB,GAAI3hF,EAAM4hF,YACR,OAAO,EAET,GAAI5hF,EAAM6hF,iBACR,OAAO,EAGJ7hF,EAAMmtB,UAETptB,EAAUvD,cAEZ,IAAIslF,EAAW9hF,EAAMmtB,SAAS40D,cAAgB,EAI9C,OADAD,EAAWA,KAAc9hF,EAAMuhF,QAAUvhF,EAAMuhF,OAAOI,eAC/CG,CAAQ,EAQjB/hF,EAAUiiF,gCAAkC,KAAM,EAClDjiF,EAAUkiF,aAAe,iBACzBliF,EAAUvD,YAAc,KACC,OAAnBwD,EAAMmtB,WACRntB,EAAMmtB,SAAWptB,EAAUkiF,gBAEtBjiF,EAAMmtB,UAEfptB,EAAUqkE,UAAY,KACpB,GAAqB,OAAjBpkE,EAAMuhF,OACR,OAAOvhF,EAAMo2C,OAIf,MAAMwpC,EAAM5/E,EAAMuhF,OAAOnd,YACzB,IAAKwb,GAAsB,IAAfA,EAAIl0F,OACd,OAAOk0F,EAIT,GAAIA,EAAI,GAAKA,EAAI,GAIf,OAHA5/E,EAAMkiF,aAAetC,EAAI9nE,SACzB9X,EAAMo2C,OAAS,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,GAClCp2C,EAAMyhF,YAAY7kB,WACXgjB,EAST,IAAK5/E,EAAMkiF,gBADCz6F,EACoB,CAACm4F,EAAK5/E,EAAMkiF,cADxBz6F,EAAK,GAAGtD,KAAI,CAAC83B,EAAGjtB,IAAMvH,EAAKtD,KAAIu6D,GAAOA,EAAI1vD,QACHgmC,QAAO,CAACtgC,EAAGC,IAAMD,GAAKC,EAAE,KAAOA,EAAE,KAAI,IAASoL,EAAU67E,WAAa57E,EAAMyhF,YAAY7F,WAAY,CAC5JvP,EAAc,yBACdrsE,EAAMkiF,aAAetC,EAAIz7F,KAAIkQ,GAAKA,IAClC0L,EAAUoiF,gBACV,MAAMC,EAAO,IAAI3+B,aAAa,IAC9B,eAAe2+B,EAAMpiF,EAAM8yE,QAC3B,qBAA+B8M,EAAKwC,EAAMpiF,EAAMo2C,QAChDp2C,EAAMyhF,YAAY7kB,UACpB,CATYn1E,MAUZ,OAAOuY,EAAMo2C,MAAM,EAErBr2C,EAAUkhF,kBAAoB,CAACz/E,EAAO0wE,KAEpC,MAAM0N,EAAM5/E,EAAMuhF,OAAON,kBAAkBz/E,EAAO0wE,GAElD,IAAK,aAAuB0N,GAC1B,OAAOA,EAET7/E,EAAUoiF,gBACV,MAAMC,EAAO,IAAI3+B,aAAa,IAG9B,OAFA,eAAe2+B,EAAMpiF,EAAM8yE,QACT,qBAA+B8M,EAAKwC,EACtC,EAKlBriF,EAAUsiF,aAAe,IAAMtiF,EAAUqkE,YAAY,GAGrDrkE,EAAUuiF,aAAe,IAAMviF,EAAUqkE,YAAY,GAGrDrkE,EAAUwiF,aAAe,IAAMxiF,EAAUqkE,YAAY,GAGrDrkE,EAAUyiF,aAAe,IAAMziF,EAAUqkE,YAAY,GAGrDrkE,EAAU0iF,aAAe,IAAM1iF,EAAUqkE,YAAY,GAGrDrkE,EAAU2iF,aAAe,IAAM3iF,EAAUqkE,YAAY,GACrDrkE,EAAU67E,SAAW,KACnB,IAAI+G,EAAK3iF,EAAM4iF,MACf,GAAuB,OAAnB5iF,EAAMmtB,SAAmB,CAC3B,MAAM5nC,EAAOya,EAAMmtB,SAASyuD,WAC5B+G,EAAKp9F,EAAOo9F,EAAKp9F,EAAOo9F,CAC1B,CACA,OAAOA,CAAE,EAEX5iF,EAAU8iF,eAAiB,KACzB,IAAIF,EAAK3iF,EAAM4iF,MACf,GAAqB,OAAjB5iF,EAAMuhF,OAAiB,CACzB,IAAIh8F,EAAOya,EAAMuhF,OAAO3F,WACxB+G,EAAKp9F,EAAOo9F,EAAKp9F,EAAOo9F,EACQ,OAA5B3iF,EAAMuhF,OAAOuB,aAEf9iF,EAAMuhF,OAAOwB,oBAAoB/gB,SACjCz8E,EAAOya,EAAMuhF,OAAOuB,WAAWlH,WAC/B+G,EAAKp9F,EAAOo9F,EAAKp9F,EAAOo9F,EAE5B,CACA,GAAuB,OAAnB3iF,EAAMmtB,SAAmB,CAC3B,IAAI5nC,EAAOya,EAAMmtB,SAASyuD,WAC1B+G,EAAKp9F,EAAOo9F,EAAKp9F,EAAOo9F,EACwB,OAA5C3iF,EAAMmtB,SAASzwB,2BACjBnX,EAAOya,EAAMmtB,SAASzwB,yBAAyBk/E,WAC/C+G,EAAKp9F,EAAOo9F,EAAKp9F,EAAOo9F,EAE5B,CACA,OAAOA,CAAE,EAEX5iF,EAAUijF,qBAAuB,MAAMhjF,EAAMuhF,QAASvhF,EAAMuhF,OAAOyB,sBACrE,CA+BEC,CAAcljF,EAAWC,EAC3B,CAQA,IAAIkjF,EAAkB,CACpB3iF,YALkB,EAAA67D,EAAM77D,YAAYT,EAAQ,iBAM5CA,uGC1LF,MAAM,cACJusE,GACE,EAAAjQ,EAyFJ,MAAMx8D,EAAiB,CACrB2hF,OAAQ,KACRp0D,SAAU,KACVipB,OAAQ,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,IAK7B,SAASt2C,EAAOC,EAAWC,GACzB,IAAIC,EAAgBmqD,UAAU1+D,OAAS,QAAsBG,IAAjBu+D,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzF38D,OAAOyS,OAAOF,EAAOJ,EAAgBK,GAGrC,YAAiBF,EAAWC,EAAOC,GAGnCD,EAAMyhF,YAAc,CAAC,EACrB,EAAArlB,EAAMvS,IAAI7pD,EAAMyhF,aAGhB,EAAArlB,EAAMj9D,IAAIY,EAAWC,EAAO,CAAC,aAC7B,EAAAo8D,EAAM2K,OAAOhnE,EAAWC,EAAO,CAAC,WAChC,EAAAo8D,EAAMyG,SAAS9iE,EAAWC,EAAO,CAAC,UAAW,GAzG/C,SAAmBD,EAAWC,GAE5BA,EAAMG,eAAe3N,KAAK,aAC1BuN,EAAUsH,WAAa,IAAMtH,EAC7BA,EAAUkiF,aAAe,iBACzBliF,EAAUvD,YAAc,KACC,OAAnBwD,EAAMmtB,WACRntB,EAAMmtB,SAAWptB,EAAUkiF,gBAEtBjiF,EAAMmtB,UAEfptB,EAAUqkE,UAAY,KACpB,GAAqB,OAAjBpkE,EAAMuhF,OACR,OAAOvhF,EAAMo2C,OAIf,MAAMwpC,EAAM5/E,EAAMuhF,OAAOnd,YACzB,IAAKwb,GAAsB,IAAfA,EAAIl0F,OACd,OAAOk0F,EAIT,GAAIA,EAAI,GAAKA,EAAI,GAIf,OAHA5/E,EAAMkiF,aAAetC,EAAI9nE,SACzB9X,EAAMo2C,OAAS,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,GAClCp2C,EAAMyhF,YAAY7kB,WACXgjB,EAST,IAAK5/E,EAAMkiF,gBADCz6F,EACoB,CAACm4F,EAAK5/E,EAAMkiF,cADxBz6F,EAAK,GAAGtD,KAAI,CAAC83B,EAAGjtB,IAAMvH,EAAKtD,KAAIu6D,GAAOA,EAAI1vD,QACHgmC,QAAO,CAACtgC,EAAGC,IAAMD,GAAKC,EAAE,KAAOA,EAAE,KAAI,IAASoL,EAAU67E,WAAa57E,EAAMyhF,YAAY7F,WAAY,CAC5JvP,EAAc,yBACdrsE,EAAMkiF,aAAetC,EAAIz7F,KAAIkQ,GAAKA,IAClC,MAAM8uF,EAAO,GACb,gBAA0BvD,EAAKuD,GAC/BpjF,EAAUoiF,gBACV,MAAMC,EAAO,IAAI3+B,aAAa,IAC9B,eAAe2+B,EAAMpiF,EAAM8yE,QAC3BqQ,EAAKhxF,SAAQoH,GAAM,mBAAmBA,EAAIA,EAAI6oF,KAG9CpiF,EAAMo2C,OAAO,GAAKp2C,EAAMo2C,OAAO,GAAKp2C,EAAMo2C,OAAO,GAAK5lD,OAAO+2E,UAC7DvnE,EAAMo2C,OAAO,GAAKp2C,EAAMo2C,OAAO,GAAKp2C,EAAMo2C,OAAO,IAAM5lD,OAAO+2E,UAE9DvnE,EAAMo2C,OAASp2C,EAAMo2C,OAAOjyD,KAAI,CAACwkF,EAAG/9E,IAAMA,EAAI,GAAM,EAAIu4F,EAAKnuD,QAAO,CAACtgC,EAAGC,IAAMD,EAAIC,EAAE/J,EAAI,GAAK+J,EAAE/J,EAAI,GAAK8J,GAAGi0E,GAAKwa,EAAKnuD,QAAO,CAACtgC,EAAGC,IAAMD,EAAIC,GAAG/J,EAAI,GAAK,GAAK+J,GAAG/J,EAAI,GAAK,GAAK8J,GAAGi0E,KAC/K3oE,EAAMyhF,YAAY7kB,UACpB,CAjBYn1E,MAkBZ,OAAOuY,EAAMo2C,MAAM,EAErBr2C,EAAU67E,SAAW,KACnB,IAAI+G,EAAK3iF,EAAM4iF,MACf,GAAuB,OAAnB5iF,EAAMmtB,SAAmB,CAC3B,MAAM5nC,EAAOya,EAAMmtB,SAASyuD,WAC5B+G,EAAKp9F,EAAOo9F,EAAKp9F,EAAOo9F,CAC1B,CACA,OAAOA,CAAE,EAEX5iF,EAAU8iF,eAAiB,KACzB,IAAIF,EAAK3iF,EAAM4iF,MACf,GAAqB,OAAjB5iF,EAAMuhF,OAAiB,CACzB,IAAIh8F,EAAOya,EAAMuhF,OAAO3F,WACxB+G,EAAKp9F,EAAOo9F,EAAKp9F,EAAOo9F,EACQ,OAA5B3iF,EAAMuhF,OAAOuB,aAEf9iF,EAAMuhF,OAAOwB,oBAAoB/gB,SACjCz8E,EAAOya,EAAMuhF,OAAOuB,WAAWlH,WAC/B+G,EAAKp9F,EAAOo9F,EAAKp9F,EAAOo9F,EAE5B,CACA,OAAOA,CAAE,CAEb,CA+BES,CAAUrjF,EAAWC,EACvB,CAQA,IAAIqjF,EAAc,CAChB9iF,YALkB,EAAA67D,EAAM77D,YAAYT,EAAQ,aAM5CA,wEChIF,MAAMwjF,EAAc7iF,OAAO,iBACrB8iF,EAAiB9iF,OAAO,oBACxB+iF,EAAe/iF,OAAO,wBACtBgjF,EAAYhjF,OAAO,qBACnBijF,EAAcjjF,OAAO,kBACrBkjF,EAAYrwD,GAAwB,iBAARA,GAA4B,OAARA,GAAgC,mBAARA,EAgDxEswD,EAAmB,IAAIp/E,IAAI,CAC7B,CAAC,QA7CwB,CACzBq/E,UAAYvwD,GAAQqwD,EAASrwD,IAAQA,EAAIgwD,GACzC,SAAAQ,CAAUj6B,GACN,MAAM,MAAEk6B,EAAK,MAAEC,GAAU,IAAIC,eAE7B,OADAC,EAAOr6B,EAAKk6B,GACL,CAACC,EAAO,CAACA,GACpB,EACAG,YAAYC,IACRA,EAAK/4F,QACEg5F,EAAKD,MAqChB,CAAC,QA/BwB,CACzBP,UAAY3iF,GAAUyiF,EAASziF,IAAUwiF,KAAexiF,EACxD,SAAA4iF,EAAU,MAAE5iF,IACR,IAAIojF,EAcJ,OAZIA,EADApjF,aAAiB3X,MACJ,CACTg7F,SAAS,EACTrjF,MAAO,CACH4jD,QAAS5jD,EAAM4jD,QACfjvD,KAAMqL,EAAMrL,KACZogD,MAAO/0C,EAAM+0C,QAKR,CAAEsuC,SAAS,EAAOrjF,SAE5B,CAACojF,EAAY,GACxB,EACA,WAAAH,CAAYG,GACR,GAAIA,EAAWC,QACX,MAAM92F,OAAOyS,OAAO,IAAI3W,MAAM+6F,EAAWpjF,MAAM4jD,SAAUw/B,EAAWpjF,OAExE,MAAMojF,EAAWpjF,KACrB,MAoBJ,SAASgjF,EAAOr6B,EAAK26B,EAAK13B,WAAY23B,EAAiB,CAAC,MACpDD,EAAG/9F,iBAAiB,WAAW,SAASkM,EAAS+xF,GAC7C,IAAKA,IAAOA,EAAGh4F,KACX,OAEJ,IAhBR,SAAyB+3F,EAAgB78F,GACrC,IAAK,MAAM+8F,KAAiBF,EAAgB,CACxC,GAAI78F,IAAW+8F,GAAmC,MAAlBA,EAC5B,OAAO,EAEX,GAAIA,aAAyBj1B,QAAUi1B,EAAcC,KAAKh9F,GACtD,OAAO,CAEf,CACA,OAAO,CACX,CAMai9F,CAAgBJ,EAAgBC,EAAG98F,QAEpC,YADAqL,QAAQC,KAAK,mBAAmBwxF,EAAG98F,6BAGvC,MAAM,GAAExC,EAAE,KAAEmZ,EAAI,KAAEqlD,GAASn2D,OAAOyS,OAAO,CAAE0jD,KAAM,IAAM8gC,EAAGh4F,MACpDi9D,GAAgB+6B,EAAGh4F,KAAKi9D,cAAgB,IAAIxlE,IAAI2gG,GACtD,IAAIC,EACJ,IACI,MAAMC,EAASphC,EAAKpiD,MAAM,GAAI,GAAGwzB,QAAO,CAAC60B,EAAKo7B,IAASp7B,EAAIo7B,IAAOp7B,GAC5Dq7B,EAAWthC,EAAK5uB,QAAO,CAAC60B,EAAKo7B,IAASp7B,EAAIo7B,IAAOp7B,GACvD,OAAQtrD,GACJ,IAAK,MAEGwmF,EAAcG,EAElB,MACJ,IAAK,MAEGF,EAAOphC,EAAKpiD,OAAO,GAAG,IAAMsjF,EAAcJ,EAAGh4F,KAAKwU,OAClD6jF,GAAc,EAElB,MACJ,IAAK,QAEGA,EAAcG,EAAS1sD,MAAMwsD,EAAQr7B,GAEzC,MACJ,IAAK,YAGGo7B,EAAcI,EADA,IAAID,KAAYv7B,IAGlC,MACJ,IAAK,WACD,CACI,MAAM,MAAEo6B,EAAK,MAAEC,GAAU,IAAIC,eAC7BC,EAAOr6B,EAAKm6B,GACZe,EAkKxB,SAAkBl7B,EAAKu7B,GAEnB,OADAC,EAAclmF,IAAI0qD,EAAKu7B,GAChBv7B,CACX,CArKsCy7B,CAASvB,EAAO,CAACA,GACnC,CACA,MACJ,IAAK,UAEGgB,OAAcl5F,EAElB,MACJ,QACI,OAEZ,CACA,MAAOqV,GACH6jF,EAAc,CAAE7jF,QAAO,CAACwiF,GAAc,EAC1C,CACAx5F,QAAQC,QAAQ46F,GACX98E,OAAO/G,IACD,CAAEA,QAAO,CAACwiF,GAAc,MAE9B15F,MAAM+6F,IACP,MAAOQ,EAAWC,GAAiBC,EAAYV,GAC/CP,EAAGkB,YAAYj4F,OAAOyS,OAAOzS,OAAOyS,OAAO,CAAC,EAAGqlF,GAAY,CAAEngG,OAAOogG,GACvD,YAATjnF,IAEAimF,EAAG39F,oBAAoB,UAAW8L,GAClCgzF,EAAcnB,GACVf,KAAa55B,GAAiC,mBAAnBA,EAAI45B,IAC/B55B,EAAI45B,KAEZ,IAECx7E,OAAOC,IAER,MAAOq9E,EAAWC,GAAiBC,EAAY,CAC3CvkF,MAAO,IAAIm3B,UAAU,+BACrB,CAACqrD,GAAc,IAEnBc,EAAGkB,YAAYj4F,OAAOyS,OAAOzS,OAAOyS,OAAO,CAAC,EAAGqlF,GAAY,CAAEngG,OAAOogG,EAAc,GAE1F,IACIhB,EAAGn5F,OACHm5F,EAAGn5F,OAEX,CAIA,SAASs6F,EAAcC,IAHvB,SAAuBA,GACnB,MAAqC,gBAA9BA,EAASrlG,YAAYsV,IAChC,EAEQgwF,CAAcD,IACdA,EAASE,OACjB,CACA,SAASzB,EAAKG,EAAIuB,GACd,OAAOC,EAAYxB,EAAI,GAAIuB,EAC/B,CACA,SAASE,EAAqBC,GAC1B,GAAIA,EACA,MAAM,IAAI38F,MAAM,6CAExB,CACA,SAAS48F,EAAgB3B,GACrB,OAAO4B,EAAuB5B,EAAI,CAC9BjmF,KAAM,YACPvU,MAAK,KACJ27F,EAAcnB,EAAG,GAEzB,CACA,MAAM6B,EAAe,IAAInjF,QACnBojF,EAAkB,yBAA0Bx5B,YAC9C,IAAIy5B,sBAAsB/B,IACtB,MAAMgC,GAAYH,EAAa14F,IAAI62F,IAAO,GAAK,EAC/C6B,EAAalnF,IAAIqlF,EAAIgC,GACJ,IAAbA,GACAL,EAAgB3B,EACpB,IAcR,SAASwB,EAAYxB,EAAI5gC,EAAO,GAAImiC,EAAS,WAAc,GACvD,IAAIU,GAAkB,EACtB,MAAMtB,EAAQ,IAAIuB,MAAMX,EAAQ,CAC5B,GAAAp4F,CAAIg5F,EAAS1B,GAET,GADAgB,EAAqBQ,GACjBxB,IAASzB,EACT,MAAO,MAXvB,SAAyB2B,GACjBmB,GACAA,EAAgBM,WAAWzB,EAEnC,CAQoB0B,CAAgB1B,GAChBgB,EAAgB3B,GAChBiC,GAAkB,CAAI,EAG9B,GAAa,SAATxB,EAAiB,CACjB,GAAoB,IAAhBrhC,EAAKl4D,OACL,MAAO,CAAE1B,KAAM,IAAMm7F,GAEzB,MAAMp/C,EAAIqgD,EAAuB5B,EAAI,CACjCjmF,KAAM,MACNqlD,KAAMA,EAAKz/D,KAAK+8B,GAAMA,EAAE00B,eACzB5rD,KAAK86F,GACR,OAAO/+C,EAAE/7C,KAAK42D,KAAK7a,EACvB,CACA,OAAOigD,EAAYxB,EAAI,IAAI5gC,EAAMqhC,GACrC,EACA,GAAA9lF,CAAIwnF,EAAS1B,EAAMC,GACfe,EAAqBQ,GAGrB,MAAOvlF,EAAOskF,GAAiBC,EAAYP,GAC3C,OAAOkB,EAAuB5B,EAAI,CAC9BjmF,KAAM,MACNqlD,KAAM,IAAIA,EAAMqhC,GAAM9gG,KAAK+8B,GAAMA,EAAE00B,aACnC10C,SACDskF,GAAex7F,KAAK86F,EAC3B,EACA,KAAAtsD,CAAMmuD,EAASG,EAAUC,GACrBd,EAAqBQ,GACrB,MAAMpjF,EAAOugD,EAAKA,EAAKl4D,OAAS,GAChC,GAAI2X,IAASkgF,EACT,OAAO6C,EAAuB5B,EAAI,CAC9BjmF,KAAM,aACPvU,KAAK86F,GAGZ,GAAa,SAATzhF,EACA,OAAO2iF,EAAYxB,EAAI5gC,EAAKpiD,MAAM,GAAI,IAE1C,MAAOmoD,EAAc67B,GAAiBwB,EAAiBD,GACvD,OAAOX,EAAuB5B,EAAI,CAC9BjmF,KAAM,QACNqlD,KAAMA,EAAKz/D,KAAK+8B,GAAMA,EAAE00B,aACxB+T,gBACD67B,GAAex7F,KAAK86F,EAC3B,EACA,SAAAmC,CAAUN,EAASI,GACfd,EAAqBQ,GACrB,MAAO98B,EAAc67B,GAAiBwB,EAAiBD,GACvD,OAAOX,EAAuB5B,EAAI,CAC9BjmF,KAAM,YACNqlD,KAAMA,EAAKz/D,KAAK+8B,GAAMA,EAAE00B,aACxB+T,gBACD67B,GAAex7F,KAAK86F,EAC3B,IAGJ,OA7EJ,SAAuBK,EAAOX,GAC1B,MAAMgC,GAAYH,EAAa14F,IAAI62F,IAAO,GAAK,EAC/C6B,EAAalnF,IAAIqlF,EAAIgC,GACjBF,GACAA,EAAgBrwD,SAASkvD,EAAOX,EAAIW,EAE5C,CAsEI+B,CAAc/B,EAAOX,GACdW,CACX,CAIA,SAAS6B,EAAiBr9B,GACtB,MAAMw9B,EAAYx9B,EAAaxlE,IAAIshG,GACnC,MAAO,CAAC0B,EAAUhjG,KAAKy0E,GAAMA,EAAE,MALnBwuB,EAK+BD,EAAUhjG,KAAKy0E,GAAMA,EAAE,KAJ3D1vE,MAAMwY,UAAUoW,OAAO0gB,MAAM,GAAI4uD,KAD5C,IAAgBA,CAMhB,CACA,MAAM/B,EAAgB,IAAIniF,QAK1B,SAASiiF,EAAMt7B,GACX,OAAOp8D,OAAOyS,OAAO2pD,EAAK,CAAE,CAACy5B,IAAc,GAC/C,CAQA,SAASmC,EAAYvkF,GACjB,IAAK,MAAOrL,EAAMwxF,KAAYzD,EAC1B,GAAIyD,EAAQxD,UAAU3iF,GAAQ,CAC1B,MAAOomF,EAAiB9B,GAAiB6B,EAAQvD,UAAU5iF,GAC3D,MAAO,CACH,CACI3C,KAAM,UACN1I,OACAqL,MAAOomF,GAEX9B,EAER,CAEJ,MAAO,CACH,CACIjnF,KAAM,MACN2C,SAEJmkF,EAAc13F,IAAIuT,IAAU,GAEpC,CACA,SAAS4jF,EAAc5jF,GACnB,OAAQA,EAAM3C,MACV,IAAK,UACD,OAAOqlF,EAAiBj2F,IAAIuT,EAAMrL,MAAMsuF,YAAYjjF,EAAMA,OAC9D,IAAK,MACD,OAAOA,EAAMA,MAEzB,CACA,SAASklF,EAAuB5B,EAAI+C,EAAKnC,GACrC,OAAO,IAAIl7F,SAASC,IAChB,MAAM/E,EAeH,IAAI8D,MAAM,GACZ2xB,KAAK,GACL12B,KAAI,IAAM3B,KAAK6O,MAAM7O,KAAKwzC,SAAWxlC,OAAOg3F,kBAAkB5xC,SAAS,MACvEZ,KAAK,KAjBNwvC,EAAG/9F,iBAAiB,WAAW,SAASghG,EAAE/C,GACjCA,EAAGh4F,MAASg4F,EAAGh4F,KAAKtH,IAAMs/F,EAAGh4F,KAAKtH,KAAOA,IAG9Co/F,EAAG39F,oBAAoB,UAAW4gG,GAClCt9F,EAAQu6F,EAAGh4F,MACf,IACI83F,EAAGn5F,OACHm5F,EAAGn5F,QAEPm5F,EAAGkB,YAAYj4F,OAAOyS,OAAO,CAAE9a,MAAMmiG,GAAMnC,EAAU,GAE7D,6DC7Ue,SAASsC,EAASrgC,GAC/B,IAAIsgC,EAAUC,EAAU38F,EAiBxB,SAAS6I,EAAKY,EAAGL,EAAGwzF,EAAK,EAAGC,EAAKpzF,EAAEhJ,QACjC,GAAIm8F,EAAKC,EAAI,CACX,GAAuB,IAAnBH,EAAStzF,EAAGA,GAAU,OAAOyzF,EACjC,EAAG,CACD,MAAM9zF,EAAO6zF,EAAKC,IAAQ,EACtBF,EAASlzF,EAAEV,GAAMK,GAAK,EAAGwzF,EAAK7zF,EAAM,EACnC8zF,EAAK9zF,CACZ,OAAS6zF,EAAKC,EAChB,CACA,OAAOD,CACT,CAmBA,OAvCiB,IAAbxgC,EAAE37D,QACJi8F,EAAW,IACXC,EAAW,CAACjf,EAAGt0E,KAAM,OAAUgzD,EAAEshB,GAAIt0E,GACrCpJ,EAAQ,CAAC09E,EAAGt0E,IAAMgzD,EAAEshB,GAAKt0E,IAEzBszF,EAAWtgC,IAAM,KAAaA,IAAM,IAAaA,EAAI0gC,EACrDH,EAAWvgC,EACXp8D,EAAQo8D,GAgCH,CAACvzD,OAAMosC,OALd,SAAgBxrC,EAAGL,EAAGwzF,EAAK,EAAGC,EAAKpzF,EAAEhJ,QACnC,MAAMd,EAAIkJ,EAAKY,EAAGL,EAAGwzF,EAAIC,EAAK,GAC9B,OAAOl9F,EAAIi9F,GAAM58F,EAAMyJ,EAAE9J,EAAI,GAAIyJ,IAAMpJ,EAAMyJ,EAAE9J,GAAIyJ,GAAKzJ,EAAI,EAAIA,CAClE,EAEsBmJ,MAjBtB,SAAeW,EAAGL,EAAGwzF,EAAK,EAAGC,EAAKpzF,EAAEhJ,QAClC,GAAIm8F,EAAKC,EAAI,CACX,GAAuB,IAAnBH,EAAStzF,EAAGA,GAAU,OAAOyzF,EACjC,EAAG,CACD,MAAM9zF,EAAO6zF,EAAKC,IAAQ,EACtBF,EAASlzF,EAAEV,GAAMK,IAAM,EAAGwzF,EAAK7zF,EAAM,EACpC8zF,EAAK9zF,CACZ,OAAS6zF,EAAKC,EAChB,CACA,OAAOD,CACT,EAQF,CAEA,SAASE,IACP,OAAO,CACT","sources":["webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/VideoViewport.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/addImageSlicesToViewports.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/addVolumesToViewports.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/colors/colormap.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/drawImageSync.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/calculateTransform.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/canvasToPixel.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/correctShift.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/getDefaultViewport.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/getImageFitScale.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/getImageSize.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/getTransform.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/pixelToCanvas.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/resetCamera.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/resize.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/fitToWindow.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/createVolumeActor.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/setDefaultVolumeVOI.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/vtkClasses/vtkSharedVolumeMapper.js","webpack:///../../../node_modules/@cornerstonejs/core/src/Settings.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/cache/cache.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/constants/epsilon.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/constants/rendering.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/RequestType.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/ViewportStatus.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/BlendModes.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/GeometryType.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/DynamicOperatorType.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/CalibrationTypes.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/getEnabledElement.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/loaders/imageLoader.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/loaders/volumeLoader.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/requestPool/imageLoadPoolManager.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/requestPool/requestPoolManager.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/cacheUtils.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/colormap.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/createLinearRGBTransferFunction.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/getImageSliceDataForVolumeViewport.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/transferFunctionUtils.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/transformWorldToIndex.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/triggerEvent.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/webWorkerManager/webWorkerManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/SVGCursorDescriptor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/BidirectionalTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/base/AnnotationTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/displayTools/Labelmap/labelmapConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/RectangleROIThresholdTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/RectangleROIStartEndThresholdTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/annotationFrameRange.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/annotationHydration.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/boundingBox/getBoundingBoxAroundShape.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/calibrateImageSpacing.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/cine/events.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/cine/playClip.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/clip.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/addContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/removeContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/calculatePerimeter.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/findHandlePolylineIndex.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/generateContourSetsFromLabelmap.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/AnnotationToPointData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/getContourHolesDataCanvas.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/getContourHolesDataWorld.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/updateContourPolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/debounce.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/drawing/getTextBoxCoordsCanvas.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getCalibratedUnits.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getSphereBoundsInfo.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getViewportForAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/isObject.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/aabb/intersectAABB.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/aabb/distanceToPointSquared.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/aabb/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/basic/Calculator.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/basic/BasicStatsCalculator.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/ellipse/pointInEllipse.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/ellipse/getCanvasEllipseCorners.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/distanceToPointSquaredInfo.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/distanceToPointSquared.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/intersectLine.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/isPointOnLineSegment.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/point/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/point/distanceToPointSquared.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/point/mirror.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/isClosed.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/containsPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/containsPoints.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getArea.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getSignedArea.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getWindingDirection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getNormal3.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getNormal2.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/areLineSegmentsIntersecting.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getLineSegmentIntersectionsIndexes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getLinesIntersection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/combinePolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getFirstLineSegmentIntersectionIndexes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/intersectPolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/decimate.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getLineSegmentIntersectionsCoordinates.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getClosestLineSegmentIntersection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getSubPixelSpacingAndXYDirections.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/pointsAreWithinCloseContourProximity.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/addCanvasPointsToArray.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/pointCanProjectOnLine.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/projectTo2D.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/isPointInsidePolyline3D.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/rectangle/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/sphere/pointInSphere.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/vec2/liangBarksyClip.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/planarFreehandROITool/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/planar/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/pointInShapeCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/pointInSurroundingSphereCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/pointToString.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/polyData/utils.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/rectangleROITool/isAxisAlignedRectangle.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/scroll.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/InterpolationManager/InterpolationManager.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/contourAndFindLargestBidirectional.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/createImageIdReferenceMap.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/floodFill.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getHoveredContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getSegmentAtLabelmapBorder.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getSegmentAtWorldPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/invalidateBrushCursor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/utilities.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/throttle.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/touch/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/triggerAnnotationRenderForToolGroupIds.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/filterViewportsWithToolEnabled.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/filterViewportsWithParallelNormals.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/getViewportIdsWithToolToRender.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/filterViewportsWithFrameOfReferenceUID.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewport/isViewportPreScaled.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewport/jumpToWorld.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/vec3/interpolateVec3.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/ColorbarCanvas.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/Colorbar.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/ViewportColorbar.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/windowlevel/getLuminanceFromRegion.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/windowlevel/calculateMinMaxMean.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/windowlevel/extractWindowLevelRegionToolData.ts","webpack:///../../../node_modules/@icr/polyseg-wasm/dist/ICRPolySeg.js","webpack:///../../../node_modules/@icr/polyseg-wasm/dist/index.js","webpack:///../../../node_modules/@kitware/vtk.js/Filters/General/ContourLoopExtraction.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/workers/polySegConverters.js","webpack:///../../../node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js","webpack:///../../../node_modules/@kitware/vtk.js/Common/DataModel/PiecewiseFunction.js","webpack:///../../../node_modules/@kitware/vtk.js/Common/DataModel/Plane.js","webpack:///../../../node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares.js","webpack:///../../../node_modules/@kitware/vtk.js/Rendering/Core/Camera.js","webpack:///../../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction.js","webpack:///../../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps.js","webpack:///../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageMapper.js","webpack:///../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageSlice.js","webpack:///../../../node_modules/@kitware/vtk.js/Rendering/Core/Volume.js","webpack:///../../../node_modules/comlink/dist/esm/comlink.mjs","webpack:///../../../node_modules/d3-array/src/bisector.js"],"sourcesContent":["import { vec3 } from 'gl-matrix';\r\nimport {\r\n  Events as EVENTS,\r\n  VideoEnums as VideoViewportEnum,\r\n  MetadataModules,\r\n} from '../enums';\r\nimport type {\r\n  IVideoViewport,\r\n  VideoViewportProperties,\r\n  Point3,\r\n  Point2,\r\n  ICamera,\r\n  InternalVideoCamera,\r\n  VideoViewportInput,\r\n  VOIRange,\r\n  ICanvasActor,\r\n  IImage,\r\n  ViewReferenceSpecifier,\r\n  ViewReference,\r\n  ReferenceCompatibleOptions,\r\n  ImageSetOptions,\r\n} from '../types';\r\nimport * as metaData from '../metaData';\r\nimport { Transform } from './helpers/cpuFallback/rendering/transform';\r\nimport { triggerEvent } from '../utilities';\r\nimport Viewport from './Viewport';\r\nimport { getOrCreateCanvas } from './helpers';\r\nimport CanvasActor from './CanvasActor';\r\nimport cache from '../cache';\r\n\r\n/**\r\n * A data type for the scalar data for video data.\r\n */\r\nexport type CanvasScalarData = Uint8ClampedArray & {\r\n  frameNumber?: number;\r\n  getRange?: () => [number, number];\r\n};\r\n\r\n/**\r\n * An object representing a single stack viewport, which is a camera\r\n * looking into an internal scene, and an associated target output `canvas`.\r\n */\r\nclass VideoViewport extends Viewport implements IVideoViewport {\r\n  public static frameRangeExtractor = /(\\/frames\\/|[&?]frameNumber=)([^/&?]*)/i;\r\n\r\n  public modality;\r\n  // Viewport Data\r\n  protected imageId: string;\r\n  readonly uid;\r\n  readonly renderingEngineId: string;\r\n  readonly canvasContext: CanvasRenderingContext2D;\r\n  private videoElement?: HTMLVideoElement;\r\n  private videoWidth = 0;\r\n  private videoHeight = 0;\r\n\r\n  private loop = true;\r\n  private mute = true;\r\n  private isPlaying = false;\r\n  private scrollSpeed = 1;\r\n  private playbackRate = 1;\r\n  private scalarData: CanvasScalarData;\r\n\r\n  /**\r\n   * This is used to pause initially so that we get at least one render to allow\r\n   * navigating frames.  Otherwise the viewport is blank initially until the user\r\n   * hits play manually.\r\n   */\r\n  private initialRender: () => void;\r\n\r\n  /**\r\n   * The range is the set of frames to play\r\n   */\r\n  private frameRange: [number, number] = [0, 0];\r\n\r\n  protected metadata;\r\n\r\n  /**\r\n   * The fps, frames per second is used to calculate time/frame mapping values.\r\n   * It is provided by the CINE Module in the metadata, defaulting to 30 if not\r\n   * provided.\r\n   */\r\n  private fps = 30;\r\n\r\n  /** The number of frames in the video */\r\n  private numberOfFrames: number;\r\n\r\n  private videoCamera: InternalVideoCamera = {\r\n    panWorld: [0, 0],\r\n    parallelScale: 1,\r\n  };\r\n\r\n  /**\r\n   * feFilter is an inline string value for the CSS filter on the video\r\n   * CSS filters can reference SVG filters, so for the typical use case here\r\n   * the CSS filter is actually an link link to a SVG filter.\r\n   */\r\n  private feFilter: string;\r\n\r\n  /**\r\n   * An average white point value, used to color balance the image so that\r\n   * the given white is mapped to [255,255,255] via multiplication per channel.\r\n   */\r\n  private averageWhite: [number, number, number];\r\n\r\n  /**\r\n   * The VOI Range is used to apply contrast/brightness adjustments to the image.\r\n   */\r\n  private voiRange: VOIRange = {\r\n    lower: 0,\r\n    upper: 255,\r\n  };\r\n\r\n  constructor(props: VideoViewportInput) {\r\n    super({\r\n      ...props,\r\n      canvas: props.canvas || getOrCreateCanvas(props.element),\r\n    });\r\n    this.canvasContext = this.canvas.getContext('2d');\r\n    this.renderingEngineId = props.renderingEngineId;\r\n\r\n    this.element.setAttribute('data-viewport-uid', this.id);\r\n    this.element.setAttribute(\r\n      'data-rendering-engine-uid',\r\n      this.renderingEngineId\r\n    );\r\n\r\n    this.videoElement = document.createElement('video');\r\n    this.videoElement.muted = this.mute;\r\n    this.videoElement.loop = this.loop;\r\n    this.videoElement.autoplay = true;\r\n    this.videoElement.crossOrigin = 'anonymous';\r\n\r\n    this.addEventListeners();\r\n    this.resize();\r\n  }\r\n\r\n  public static get useCustomRenderingPipeline() {\r\n    return true;\r\n  }\r\n\r\n  private addEventListeners() {\r\n    this.canvas.addEventListener(\r\n      EVENTS.ELEMENT_DISABLED,\r\n      this.elementDisabledHandler\r\n    );\r\n  }\r\n\r\n  private removeEventListeners() {\r\n    this.canvas.removeEventListener(\r\n      EVENTS.ELEMENT_DISABLED,\r\n      this.elementDisabledHandler\r\n    );\r\n  }\r\n\r\n  private elementDisabledHandler() {\r\n    this.removeEventListeners();\r\n    this.videoElement.remove();\r\n  }\r\n\r\n  public getImageDataMetadata(image: IImage | string) {\r\n    const imageId = typeof image === 'string' ? image : image.imageId;\r\n    const imagePlaneModule = metaData.get(MetadataModules.IMAGE_PLANE, imageId);\r\n\r\n    let rowCosines = <Point3>imagePlaneModule.rowCosines;\r\n    let columnCosines = <Point3>imagePlaneModule.columnCosines;\r\n\r\n    // if null or undefined\r\n    if (rowCosines == null || columnCosines == null) {\r\n      rowCosines = <Point3>[1, 0, 0];\r\n      columnCosines = <Point3>[0, 1, 0];\r\n    }\r\n\r\n    const rowCosineVec = vec3.fromValues(\r\n      rowCosines[0],\r\n      rowCosines[1],\r\n      rowCosines[2]\r\n    );\r\n    const colCosineVec = vec3.fromValues(\r\n      columnCosines[0],\r\n      columnCosines[1],\r\n      columnCosines[2]\r\n    );\r\n\r\n    const { rows, columns } = imagePlaneModule;\r\n    const scanAxisNormal = vec3.create();\r\n    vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);\r\n\r\n    let origin = imagePlaneModule.imagePositionPatient;\r\n    // if null or undefined\r\n    if (origin == null) {\r\n      origin = [0, 0, 0];\r\n    }\r\n\r\n    const xSpacing = imagePlaneModule.columnPixelSpacing || 1;\r\n    const ySpacing = imagePlaneModule.rowPixelSpacing || 1;\r\n    const xVoxels = imagePlaneModule.columns;\r\n    const yVoxels = imagePlaneModule.rows;\r\n\r\n    const zSpacing = 1;\r\n    const zVoxels = 1;\r\n\r\n    this.hasPixelSpacing = !!imagePlaneModule.columnPixelSpacing;\r\n    return {\r\n      bitsAllocated: 8,\r\n      numComps: 3,\r\n      origin,\r\n      rows,\r\n      columns,\r\n      direction: [...rowCosineVec, ...colCosineVec, ...scanAxisNormal],\r\n      dimensions: [xVoxels, yVoxels, zVoxels],\r\n      spacing: [xSpacing, ySpacing, zSpacing],\r\n      hasPixelSpacing: this.hasPixelSpacing,\r\n      numVoxels: xVoxels * yVoxels * zVoxels,\r\n      imagePlaneModule,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * This is a wrapper for setVideo to allow generic behaviour\r\n   *\r\n   * @param _groupId - the id for the overall set of image ids.  Unused for video viewport.\r\n   * @param imageIds - a singleton list containing the imageId of a video.\r\n   */\r\n  public setDataIds(imageIds: string[], options?: ImageSetOptions) {\r\n    this.setVideo(\r\n      imageIds[0],\r\n      (options?.viewReference?.sliceIndex as number) || 1\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Sets the video image id to show and hte frame number.\r\n   * Requirements are to have the imageUrlModule in the metadata\r\n   * with the rendered endpoint being the raw video in video/mp4 format.\r\n   */\r\n  public setVideo(imageId: string, frameNumber?: number): Promise<unknown> {\r\n    this.imageId = Array.isArray(imageId) ? imageId[0] : imageId;\r\n    const imageUrlModule = metaData.get(MetadataModules.IMAGE_URL, imageId);\r\n    if (!imageUrlModule?.rendered) {\r\n      throw new Error(\r\n        `Video Image ID ${imageId} does not have a rendered video view`\r\n      );\r\n    }\r\n    const { rendered } = imageUrlModule;\r\n    const generalSeries = metaData.get(MetadataModules.GENERAL_SERIES, imageId);\r\n    this.modality = generalSeries?.Modality;\r\n    this.metadata = this.getImageDataMetadata(imageId);\r\n    let { cineRate, numberOfFrames } = metaData.get(\r\n      MetadataModules.CINE,\r\n      imageId\r\n    );\r\n    this.numberOfFrames = numberOfFrames;\r\n\r\n    return this.setVideoURL(rendered).then(() => {\r\n      if (!numberOfFrames || numberOfFrames === 1) {\r\n        numberOfFrames = Math.round(\r\n          this.videoElement.duration * (cineRate || 30)\r\n        );\r\n      }\r\n      if (!cineRate) {\r\n        cineRate = Math.round(numberOfFrames / this.videoElement.duration);\r\n      }\r\n      this.fps = cineRate;\r\n      this.numberOfFrames = numberOfFrames;\r\n      // 1 based range setting\r\n      this.setFrameRange([1, numberOfFrames]);\r\n      // The initial render allows us to set the frame position - rendering needs\r\n      // to start already playing\r\n      this.initialRender = () => {\r\n        this.initialRender = null;\r\n        this.pause();\r\n        this.setFrameNumber(frameNumber || 1);\r\n      };\r\n\r\n      // This is ugly, but without it, the video often fails to render initially\r\n      // so having a play, followed by a pause fixes things.\r\n      // 25 ms is a tested value that seems to work to prevent exceptions\r\n      return new Promise((resolve) => {\r\n        window.setTimeout(() => {\r\n          this.setFrameNumber(frameNumber || 1);\r\n          resolve(this);\r\n        }, 25);\r\n      });\r\n    });\r\n  }\r\n\r\n  public async setVideoURL(videoURL: string) {\r\n    return new Promise((resolve) => {\r\n      this.videoElement.src = videoURL;\r\n      this.videoElement.preload = 'auto';\r\n\r\n      const loadedMetadataEventHandler = () => {\r\n        this.videoWidth = this.videoElement.videoWidth;\r\n        this.videoHeight = this.videoElement.videoHeight;\r\n        this.videoElement.removeEventListener(\r\n          'loadedmetadata',\r\n          loadedMetadataEventHandler\r\n        );\r\n\r\n        this.refreshRenderValues();\r\n\r\n        resolve(true);\r\n      };\r\n\r\n      this.videoElement.addEventListener(\r\n        'loadedmetadata',\r\n        loadedMetadataEventHandler\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Gets all the image ids associated with this video element.  This will\r\n   * have # of frames elements.\r\n   */\r\n  public getImageIds(): string[] {\r\n    const imageIds = new Array<string>(this.numberOfFrames);\r\n    const baseImageId = this.imageId.replace(/[0-9]+$/, '');\r\n    for (let i = 0; i < this.numberOfFrames; i++) {\r\n      imageIds[i] = `${baseImageId}${i + 1}`;\r\n    }\r\n    return imageIds;\r\n  }\r\n\r\n  public togglePlayPause(): boolean {\r\n    if (this.isPlaying) {\r\n      this.pause();\r\n      return false;\r\n    } else {\r\n      this.play();\r\n      return true;\r\n    }\r\n  }\r\n\r\n  public async play() {\r\n    try {\r\n      if (!this.isPlaying) {\r\n        // Play returns a promise that is true when playing completes.\r\n        await this.videoElement.play();\r\n        this.isPlaying = true;\r\n        this.renderWhilstPlaying();\r\n      }\r\n    } catch (e) {\r\n      // No-op, an exception sometimes gets thrown on the initial play, not\r\n      // quite sure why.  Catching it prevents displaying an error\r\n    }\r\n  }\r\n\r\n  public async pause() {\r\n    try {\r\n      await this.videoElement.pause();\r\n      this.isPlaying = false;\r\n    } catch (e) {\r\n      // No-op - sometimes this happens on startup\r\n    }\r\n  }\r\n\r\n  public async scroll(delta = 1) {\r\n    await this.pause();\r\n\r\n    const videoElement = this.videoElement;\r\n    const renderFrame = this.renderFrame;\r\n\r\n    const currentTime = videoElement.currentTime;\r\n    const newTime = currentTime + (delta * this.scrollSpeed) / this.fps;\r\n\r\n    videoElement.currentTime = newTime;\r\n\r\n    // Need to wait for seek update\r\n    const seekEventListener = (evt) => {\r\n      renderFrame();\r\n\r\n      videoElement.removeEventListener('seeked', seekEventListener);\r\n    };\r\n\r\n    videoElement.addEventListener('seeked', seekEventListener);\r\n  }\r\n\r\n  public async start() {\r\n    const videoElement = this.videoElement;\r\n    const renderFrame = this.renderFrame;\r\n\r\n    videoElement.currentTime = 0;\r\n\r\n    if (videoElement.paused) {\r\n      // Need to wait for seek update\r\n      const seekEventListener = (evt) => {\r\n        renderFrame();\r\n\r\n        videoElement.removeEventListener('seeked', seekEventListener);\r\n      };\r\n\r\n      videoElement.addEventListener('seeked', seekEventListener);\r\n    }\r\n  }\r\n\r\n  public async end() {\r\n    const videoElement = this.videoElement;\r\n    const renderFrame = this.renderFrame;\r\n\r\n    videoElement.currentTime = videoElement.duration;\r\n\r\n    if (videoElement.paused) {\r\n      // Need to wait for seek update\r\n      const seekEventListener = (evt) => {\r\n        renderFrame();\r\n\r\n        videoElement.removeEventListener('seeked', seekEventListener);\r\n      };\r\n\r\n      videoElement.addEventListener('seeked', seekEventListener);\r\n    }\r\n  }\r\n\r\n  public async setTime(timeInSeconds: number) {\r\n    const videoElement = this.videoElement;\r\n    const renderFrame = this.renderFrame;\r\n\r\n    videoElement.currentTime = timeInSeconds;\r\n\r\n    if (videoElement.paused) {\r\n      // Need to wait for seek update\r\n      const seekEventListener = (evt) => {\r\n        renderFrame();\r\n\r\n        videoElement.removeEventListener('seeked', seekEventListener);\r\n      };\r\n\r\n      videoElement.addEventListener('seeked', seekEventListener);\r\n    }\r\n  }\r\n\r\n  // Sets the frame number - note according to DICOM, this is 1 based\r\n  public async setFrameNumber(frame: number) {\r\n    this.setTime((frame - 1) / this.fps);\r\n  }\r\n\r\n  /**\r\n   * Sets the playback frame range.  The video will play over the given set\r\n   * of frames (assuming it is playing).\r\n   * @param frameRange - the minimum to maximum (inclusive) frames to play over\r\n   * @returns\r\n   */\r\n  public setFrameRange(frameRange: number[]) {\r\n    if (!frameRange) {\r\n      this.frameRange = [1, this.numberOfFrames];\r\n      return;\r\n    }\r\n    if (frameRange.length !== 2 || frameRange[0] === frameRange[1]) {\r\n      return;\r\n    }\r\n    this.frameRange = [frameRange[0], frameRange[1]];\r\n  }\r\n\r\n  public getFrameRange(): [number, number] {\r\n    return this.frameRange;\r\n  }\r\n\r\n  public setProperties(props: VideoViewportProperties) {\r\n    if (props.loop !== undefined) {\r\n      this.videoElement.loop = props.loop;\r\n    }\r\n\r\n    if (props.muted !== undefined) {\r\n      this.videoElement.muted = props.muted;\r\n    }\r\n\r\n    if (props.playbackRate !== undefined) {\r\n      this.setPlaybackRate(props.playbackRate);\r\n    }\r\n\r\n    if (props.scrollSpeed !== undefined) {\r\n      this.setScrollSpeed(props.scrollSpeed);\r\n    }\r\n\r\n    if (props.voiRange) {\r\n      this.setVOI(props.voiRange);\r\n    }\r\n  }\r\n\r\n  public setPlaybackRate(rate = 1) {\r\n    this.playbackRate = rate;\r\n    // Minimum playback speed in chrome is 0.0625 compared to normal\r\n    if (rate < 0.0625) {\r\n      this.pause();\r\n      return;\r\n    }\r\n    if (!this.videoElement) {\r\n      return;\r\n    }\r\n    this.videoElement.playbackRate = rate;\r\n    this.play();\r\n  }\r\n\r\n  public setScrollSpeed(\r\n    scrollSpeed = 1,\r\n    unit = VideoViewportEnum.SpeedUnit.FRAME\r\n  ) {\r\n    this.scrollSpeed =\r\n      unit === VideoViewportEnum.SpeedUnit.SECOND\r\n        ? scrollSpeed * this.fps\r\n        : scrollSpeed;\r\n  }\r\n\r\n  public getProperties = (): VideoViewportProperties => {\r\n    return {\r\n      loop: this.videoElement.loop,\r\n      muted: this.videoElement.muted,\r\n      playbackRate: this.playbackRate,\r\n      scrollSpeed: this.scrollSpeed,\r\n      voiRange: { ...this.voiRange },\r\n    };\r\n  };\r\n\r\n  public resetProperties() {\r\n    this.setProperties({\r\n      loop: false,\r\n      muted: true,\r\n    });\r\n  }\r\n\r\n  protected getScalarData(): CanvasScalarData {\r\n    if (this.scalarData?.frameNumber === this.getFrameNumber()) {\r\n      return this.scalarData;\r\n    }\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = this.videoWidth;\r\n    canvas.height = this.videoHeight;\r\n    const context = canvas.getContext('2d');\r\n    context.drawImage(this.videoElement, 0, 0);\r\n    const canvasData = context.getImageData(\r\n      0,\r\n      0,\r\n      this.videoWidth,\r\n      this.videoHeight\r\n    );\r\n    const scalarData = canvasData.data as CanvasScalarData;\r\n    scalarData.getRange = () => [0, 255];\r\n    scalarData.frameNumber = this.getFrameNumber();\r\n    this.scalarData = scalarData;\r\n    return scalarData;\r\n  }\r\n\r\n  public getImageData() {\r\n    const { metadata } = this;\r\n\r\n    const spacing = metadata.spacing;\r\n\r\n    const imageData = {\r\n      dimensions: metadata.dimensions,\r\n      spacing,\r\n      origin: metadata.origin,\r\n      direction: metadata.direction,\r\n      metadata: { Modality: this.modality },\r\n      getScalarData: () => this.getScalarData(),\r\n      imageData: {\r\n        getDirection: () => metadata.direction,\r\n        getDimensions: () => metadata.dimensions,\r\n        getRange: () => [0, 255],\r\n        getScalarData: () => this.getScalarData(),\r\n        getSpacing: () => metadata.spacing,\r\n        worldToIndex: (point: Point3) => {\r\n          const canvasPoint = this.worldToCanvas(point);\r\n          const pixelCoord = this.canvasToIndex(canvasPoint);\r\n          return [pixelCoord[0], pixelCoord[1], 0];\r\n        },\r\n        indexToWorld: (point: Point2, destPoint?: Point3) => {\r\n          const canvasPoint = this.indexToCanvas([point[0], point[1]]);\r\n          return this.canvasToWorld(canvasPoint, destPoint);\r\n        },\r\n      },\r\n      hasPixelSpacing: this.hasPixelSpacing,\r\n      calibration: this.calibration,\r\n      preScale: {\r\n        scaled: false,\r\n      },\r\n    };\r\n    Object.defineProperty(imageData, 'scalarData', {\r\n      get: () => this.getScalarData(),\r\n      enumerable: true,\r\n    });\r\n    return imageData;\r\n  }\r\n\r\n  /**\r\n   * Checks to see if the imageURI is currently being displayed.  The imageURI\r\n   * may contain frame numbers according to the DICOM standard format, which\r\n   * will be stripped to compare the base image URI, and then the values used\r\n   * to check if that frame is currently being displayed.\r\n   *\r\n   * The DICOM standard allows for comma separated values as well, however,\r\n   * this is not supported here, with only a single range or single value\r\n   * being tested.\r\n   *\r\n   * For a single value, the time range +/- 5 frames is permitted to allow\r\n   * the detection to actually succeed when nearby without requiring an exact\r\n   * time frame to be matched.\r\n   *\r\n   * @param imageURI - containing frame number or range.\r\n   * @returns\r\n   */\r\n  public hasImageURI(imageURI: string): boolean {\r\n    // TODO - move annotationFrameRange into core so it can be used here.\r\n    const framesMatch = imageURI.match(VideoViewport.frameRangeExtractor);\r\n    const testURI = framesMatch\r\n      ? imageURI.substring(0, framesMatch.index)\r\n      : imageURI;\r\n    return this.imageId.indexOf(testURI) !== -1;\r\n  }\r\n\r\n  public setVOI(voiRange: VOIRange): void {\r\n    this.voiRange = voiRange;\r\n    this.setColorTransform();\r\n  }\r\n\r\n  public setWindowLevel(windowWidth = 256, windowCenter = 128) {\r\n    const lower = windowCenter - windowWidth / 2;\r\n    const upper = windowCenter + windowWidth / 2 - 1;\r\n    this.setVOI({ lower, upper });\r\n    this.setColorTransform();\r\n  }\r\n\r\n  public setAverageWhite(averageWhite: [number, number, number]) {\r\n    this.averageWhite = averageWhite;\r\n    this.setColorTransform();\r\n  }\r\n\r\n  protected setColorTransform() {\r\n    if (!this.voiRange && !this.averageWhite) {\r\n      this.feFilter = null;\r\n      return;\r\n    }\r\n    const white = this.averageWhite || [255, 255, 255];\r\n    const maxWhite = Math.max(...white);\r\n    const scaleWhite = white.map((c) => maxWhite / c);\r\n    const { lower = 0, upper = 255 } = this.voiRange || {};\r\n    const wlScale = (upper - lower + 1) / 255;\r\n    const wlDelta = lower / 255;\r\n    this.feFilter = `url('data:image/svg+xml,\\\r\n      <svg xmlns=\"http://www.w3.org/2000/svg\">\\\r\n        <filter id=\"colour\" color-interpolation-filters=\"linearRGB\">\\\r\n        <feColorMatrix type=\"matrix\" \\\r\n        values=\"\\\r\n          ${scaleWhite[0] * wlScale} 0 0 0 ${wlDelta} \\\r\n          0 ${scaleWhite[1] * wlScale} 0 0 ${wlDelta} \\\r\n          0 0 ${scaleWhite[2] * wlScale} 0 ${wlDelta} \\\r\n          0 0 0 1 0\" />\\\r\n        </filter>\\\r\n      </svg>#colour')`;\r\n\r\n    this.canvas.style.filter = this.feFilter;\r\n  }\r\n\r\n  public setCamera(camera: ICamera): void {\r\n    const { parallelScale, focalPoint } = camera;\r\n\r\n    // NOTE: the parallel scale should be done first\r\n    // because it affects the focal point later\r\n    if (parallelScale) {\r\n      this.videoCamera.parallelScale =\r\n        this.element.clientHeight / 2 / parallelScale;\r\n    }\r\n\r\n    if (focalPoint !== undefined) {\r\n      const focalPointCanvas = this.worldToCanvas(focalPoint);\r\n      const canvasCenter: Point2 = [\r\n        this.element.clientWidth / 2,\r\n        this.element.clientHeight / 2,\r\n      ];\r\n\r\n      const panWorldDelta: Point2 = [\r\n        (focalPointCanvas[0] - canvasCenter[0]) /\r\n          this.videoCamera.parallelScale,\r\n        (focalPointCanvas[1] - canvasCenter[1]) /\r\n          this.videoCamera.parallelScale,\r\n      ];\r\n\r\n      this.videoCamera.panWorld = [\r\n        this.videoCamera.panWorld[0] - panWorldDelta[0],\r\n        this.videoCamera.panWorld[1] - panWorldDelta[1],\r\n      ];\r\n    }\r\n\r\n    this.canvasContext.fillStyle = 'rgba(0,0,0,1)';\r\n    this.canvasContext.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n    if (this.isPlaying === false) {\r\n      this.renderFrame();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This function returns the imageID associated with either the current\r\n   * frame being displayed, or the range of frames being played.  This may not\r\n   * correspond to any particular imageId that has imageId metadata, as the\r\n   * format is one of:\r\n   * `<DICOMweb URI>/frames/<Start Frame>(-<End Frame>)?`\r\n   * or\r\n   * `<Other URI>[?&]frameNumber=<Start Frame>(-<EndFrame>)?`\r\n   * for a URL parameter.\r\n   *\r\n   * @returns an imageID for video\r\n   */\r\n  public getCurrentImageId() {\r\n    const current = this.imageId.replace(\r\n      '/frames/1',\r\n      this.isPlaying\r\n        ? `/frames/${this.frameRange[0]}-${this.frameRange[1]}`\r\n        : `/frames/${this.getFrameNumber()}`\r\n    );\r\n    return current;\r\n  }\r\n\r\n  /**\r\n   *  Gets a target id that can be used to specify how to show this\r\n   */\r\n  public getReferenceId(specifier: ViewReferenceSpecifier = {}): string {\r\n    const { sliceIndex: sliceIndex } = specifier;\r\n    if (sliceIndex === undefined) {\r\n      return `videoId:${this.getCurrentImageId()}`;\r\n    }\r\n    if (Array.isArray(sliceIndex)) {\r\n      // Just remove the 1 from the end of the base URL - TODO, handle other types\r\n      return `videoId:${this.imageId.substring(0, this.imageId.length - 1)}${\r\n        sliceIndex[0] + 1\r\n      }-${sliceIndex[1] + 1}`;\r\n    }\r\n    const baseTarget = this.imageId.replace(\r\n      '/frames/1',\r\n      `/frames/${1 + sliceIndex}`\r\n    );\r\n    return `videoId:${baseTarget}`;\r\n  }\r\n\r\n  /**\r\n   * Figure out if a given view can be shown in the current viewport.\r\n   */\r\n  public isReferenceViewable(\r\n    viewRef: ViewReference,\r\n    options: ReferenceCompatibleOptions = {}\r\n  ): boolean {\r\n    let { imageURI } = options;\r\n    const { referencedImageId, sliceIndex: sliceIndex } = viewRef;\r\n    if (!super.isReferenceViewable(viewRef)) {\r\n      return false;\r\n    }\r\n\r\n    const imageId = this.getCurrentImageId();\r\n    if (!imageURI) {\r\n      // Remove the dataLoader scheme and frame number\r\n      // TODO - handle more imageURI types.\r\n      const colonIndex = imageId.indexOf(':');\r\n      imageURI = imageId.substring(colonIndex + 1, imageId.length - 1);\r\n    }\r\n\r\n    if (options.withNavigation) {\r\n      return true;\r\n    }\r\n    const currentIndex = this.getSliceIndex();\r\n    if (Array.isArray(sliceIndex)) {\r\n      return currentIndex >= sliceIndex[0] && currentIndex <= sliceIndex[1];\r\n    }\r\n    if (sliceIndex !== undefined) {\r\n      return currentIndex === sliceIndex;\r\n    }\r\n    if (!referencedImageId) {\r\n      return false;\r\n    }\r\n    const match = referencedImageId.match(VideoViewport.frameRangeExtractor);\r\n    if (!match || !match[2]) {\r\n      return true;\r\n    }\r\n    const range = match[2].split('-').map((it) => Number(it));\r\n    const frame = currentIndex + 1;\r\n    return range[0] <= frame && frame <= (range[1] ?? range[0]);\r\n  }\r\n\r\n  /**\r\n   * Gets a view target that species what type of view is required to show\r\n   * the current view, or the one specified in the forTarget modifiers.\r\n   */\r\n  public getViewReference(\r\n    viewRefSpecifier?: ViewReferenceSpecifier\r\n  ): ViewReference {\r\n    let sliceIndex = viewRefSpecifier?.sliceIndex;\r\n    if (!sliceIndex) {\r\n      sliceIndex = this.isPlaying\r\n        ? [this.frameRange[0] - 1, this.frameRange[1] - 1]\r\n        : this.getCurrentImageIdIndex();\r\n    }\r\n    return {\r\n      ...super.getViewReference(viewRefSpecifier),\r\n      referencedImageId: this.getReferenceId(viewRefSpecifier),\r\n      sliceIndex: sliceIndex,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Gets the 1 based frame number (ala DICOM value), eg `1+ currentImageIdIndex`\r\n   */\r\n  public getFrameNumber() {\r\n    // Need to round this as the fps/time isn't exact\r\n    return 1 + this.getCurrentImageIdIndex();\r\n  }\r\n\r\n  public getCurrentImageIdIndex() {\r\n    return Math.round(this.videoElement.currentTime * this.fps);\r\n  }\r\n\r\n  public getSliceIndex() {\r\n    return this.getCurrentImageIdIndex();\r\n  }\r\n\r\n  public getCamera(): ICamera {\r\n    const { parallelScale } = this.videoCamera;\r\n\r\n    const canvasCenter: Point2 = [\r\n      this.element.clientWidth / 2,\r\n      this.element.clientHeight / 2,\r\n    ];\r\n\r\n    // All other viewports have the focal point in canvas coordinates in the center\r\n    // of the canvas, so to make tools work the same, we need to do the same here\r\n    // and convert to the world coordinate system since focal point is in world coordinates.\r\n    const canvasCenterWorld = this.canvasToWorld(canvasCenter);\r\n\r\n    return {\r\n      parallelProjection: true,\r\n      focalPoint: canvasCenterWorld,\r\n      position: [0, 0, 0],\r\n      viewUp: [0, -1, 0],\r\n      parallelScale: this.element.clientHeight / 2 / parallelScale, // Reverse zoom direction back\r\n      viewPlaneNormal: [0, 0, 1],\r\n    };\r\n  }\r\n\r\n  public resetCamera = (): boolean => {\r\n    this.refreshRenderValues();\r\n\r\n    this.canvasContext.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n    if (this.isPlaying === false) {\r\n      // If its not replaying, just re-render the frame on move.\r\n      this.renderFrame();\r\n    }\r\n    return true;\r\n  };\r\n\r\n  public getNumberOfSlices = (): number => {\r\n    const computedSlices = Math.round(\r\n      (this.videoElement.duration * this.fps) / this.scrollSpeed\r\n    );\r\n    return isNaN(computedSlices) ? this.numberOfFrames : computedSlices;\r\n  };\r\n\r\n  public getFrameOfReferenceUID = (): string => {\r\n    // The video itself is the frame of reference.\r\n    return this.videoElement.src;\r\n  };\r\n\r\n  public resize = (): void => {\r\n    const canvas = this.canvas;\r\n    const { clientWidth, clientHeight } = canvas;\r\n\r\n    // Set the canvas to be same resolution as the client.\r\n    if (canvas.width !== clientWidth || canvas.height !== clientHeight) {\r\n      canvas.width = clientWidth;\r\n      canvas.height = clientHeight;\r\n    }\r\n\r\n    this.refreshRenderValues();\r\n\r\n    if (this.isPlaying === false) {\r\n      // If its not playing, just re-render on resize.\r\n      this.renderFrame();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Converts a VideoViewport canvas coordinate to a video coordinate.\r\n   *\r\n   * @param canvasPos - to convert to world\r\n   * @returns World position\r\n   */\r\n  public canvasToWorld = (\r\n    canvasPos: Point2,\r\n    destPos: Point3 = [0, 0, 0]\r\n  ): Point3 => {\r\n    const pan: Point2 = this.videoCamera.panWorld; // In world coordinates\r\n    const worldToCanvasRatio: number = this.getWorldToCanvasRatio();\r\n\r\n    const panOffsetCanvas: Point2 = [\r\n      pan[0] * worldToCanvasRatio,\r\n      pan[1] * worldToCanvasRatio,\r\n    ];\r\n\r\n    const subCanvasPos: Point2 = [\r\n      canvasPos[0] - panOffsetCanvas[0],\r\n      canvasPos[1] - panOffsetCanvas[1],\r\n    ];\r\n\r\n    // Replace the x,y values only in place in the world position\r\n    // as the z is unchanging for video display\r\n    destPos.splice(\r\n      0,\r\n      2,\r\n      subCanvasPos[0] / worldToCanvasRatio,\r\n      subCanvasPos[1] / worldToCanvasRatio\r\n    );\r\n    return destPos;\r\n  };\r\n\r\n  /**\r\n   * Converts `[x, y, 0]` world video coordinate to canvas CSS coordinates.\r\n   *\r\n   * @param  worldPos - world coord to convert to canvas\r\n   * @returns Canvas position\r\n   */\r\n  public worldToCanvas = (worldPos: Point3): Point2 => {\r\n    const pan: Point2 = this.videoCamera.panWorld;\r\n    const worldToCanvasRatio: number = this.getWorldToCanvasRatio();\r\n\r\n    const canvasPos: Point2 = [\r\n      (worldPos[0] + pan[0]) * worldToCanvasRatio,\r\n      (worldPos[1] + pan[1]) * worldToCanvasRatio,\r\n    ];\r\n\r\n    return canvasPos;\r\n  };\r\n\r\n  public getPan(): Point2 {\r\n    const panWorld = this.videoCamera.panWorld;\r\n    return [panWorld[0], panWorld[1]];\r\n  }\r\n\r\n  public getRotation = () => 0;\r\n\r\n  /**\r\n   * Uses the transform to convert canvas coordinates into index coordinates.\r\n   */\r\n  protected canvasToIndex = (canvasPos: Point2): Point2 => {\r\n    const transform = this.getTransform();\r\n    transform.invert();\r\n\r\n    return transform.transformPoint(\r\n      <Point2>canvasPos.map((it) => it * devicePixelRatio)\r\n    );\r\n  };\r\n\r\n  protected indexToCanvas = (indexPos: Point2): Point2 => {\r\n    const transform = this.getTransform();\r\n    return <Point2>(\r\n      transform.transformPoint(indexPos).map((it) => it / devicePixelRatio)\r\n    );\r\n  };\r\n\r\n  /**\r\n   * Sets  initial video camera to center the image area.  The values\r\n   * are set in canvas CSS pixel units and NOT in canvas index units.\r\n   */\r\n  private refreshRenderValues() {\r\n    // this means that each unit (pixel) in the world (video) would be\r\n    // represented by n pixels in the canvas, measured in css pixels\r\n    let worldToCanvasRatio = this.canvas.offsetWidth / this.videoWidth;\r\n\r\n    if (this.videoHeight * worldToCanvasRatio > this.canvas.height) {\r\n      // If by fitting the width, we exceed the height of the viewport, then we need to decrease the\r\n      // size of the viewport further by considering its verticality.\r\n      worldToCanvasRatio = this.canvas.offsetHeight / this.videoHeight;\r\n    }\r\n\r\n    // Set the width as big as possible, this is the portion of the canvas\r\n    // that the video will occupy.\r\n    const drawWidth = Math.floor(this.videoWidth * worldToCanvasRatio);\r\n    const drawHeight = Math.floor(this.videoHeight * worldToCanvasRatio);\r\n\r\n    // calculate x and y offset in order to center the image\r\n    const xOffsetCanvas = (this.canvas.offsetWidth - drawWidth) / 2;\r\n    const yOffsetCanvas = (this.canvas.offsetHeight - drawHeight) / 2;\r\n\r\n    const xOffsetWorld = xOffsetCanvas / worldToCanvasRatio;\r\n    const yOffsetWorld = yOffsetCanvas / worldToCanvasRatio;\r\n\r\n    this.videoCamera.panWorld = [xOffsetWorld, yOffsetWorld];\r\n    this.videoCamera.parallelScale = worldToCanvasRatio;\r\n  }\r\n\r\n  private getWorldToCanvasRatio() {\r\n    return this.videoCamera.parallelScale;\r\n  }\r\n\r\n  private getCanvasToWorldRatio() {\r\n    return 1.0 / this.videoCamera.parallelScale;\r\n  }\r\n\r\n  public customRenderViewportToCanvas = () => {\r\n    this.renderFrame();\r\n  };\r\n\r\n  /**\r\n   * Creates a transform from video index coordinates to canvas coordinates.\r\n   */\r\n  protected getTransform() {\r\n    const panWorld: Point2 = this.videoCamera.panWorld;\r\n    const devicePixelRatio = window.devicePixelRatio || 1;\r\n    const worldToCanvasRatio: number = this.getWorldToCanvasRatio();\r\n    const canvasToWorldRatio: number = this.getCanvasToWorldRatio();\r\n    const halfCanvas = [\r\n      this.canvas.offsetWidth / 2,\r\n      this.canvas.offsetHeight / 2,\r\n    ];\r\n    const halfCanvasWorldCoordinates = [\r\n      halfCanvas[0] * canvasToWorldRatio,\r\n      halfCanvas[1] * canvasToWorldRatio,\r\n    ];\r\n    const transform = new Transform();\r\n\r\n    // Start by converting into canvas index coordinates FROM canvas css pixel coordinates\r\n    transform.scale(devicePixelRatio, devicePixelRatio);\r\n\r\n    // Translate to the center of the canvas (move origin of the transform\r\n    // to the center of the canvas)\r\n    transform.translate(halfCanvas[0], halfCanvas[1]);\r\n\r\n    // Scale\r\n    transform.scale(worldToCanvasRatio, worldToCanvasRatio);\r\n\r\n    // Apply the translation\r\n    transform.translate(panWorld[0], panWorld[1]);\r\n\r\n    // Translate back\r\n    transform.translate(\r\n      -halfCanvasWorldCoordinates[0],\r\n      -halfCanvasWorldCoordinates[1]\r\n    );\r\n    return transform;\r\n  }\r\n\r\n  /**\r\n   * Nothing to do for the clipping planes for video as they don't exist.\r\n   */\r\n  public updateCameraClippingPlanesAndRange() {\r\n    // No-op\r\n  }\r\n\r\n  public addImages(stackInputs: Array<any>) {\r\n    const actors = this.getActors();\r\n    stackInputs.forEach((stackInput) => {\r\n      const image = cache.getImage(stackInput.imageId);\r\n\r\n      const imageActor = this.createActorMapper(image);\r\n      if (imageActor) {\r\n        actors.push({ uid: stackInput.actorUID, actor: imageActor });\r\n        if (stackInput.callback) {\r\n          stackInput.callback({ imageActor, imageId: stackInput.imageId });\r\n        }\r\n      }\r\n    });\r\n    this.setActors(actors);\r\n  }\r\n\r\n  protected createActorMapper(image) {\r\n    return new CanvasActor(this, image);\r\n  }\r\n\r\n  /**\r\n   * Renders the video frame to the viewport.\r\n   */\r\n  private renderFrame = () => {\r\n    const transform = this.getTransform();\r\n    const transformationMatrix: number[] = transform.getMatrix();\r\n\r\n    const ctx = this.canvasContext;\r\n\r\n    ctx.resetTransform();\r\n\r\n    // Need to correct the transform for device pixel ratio scaling.\r\n    ctx.transform(\r\n      transformationMatrix[0],\r\n      transformationMatrix[1],\r\n      transformationMatrix[2],\r\n      transformationMatrix[3],\r\n      transformationMatrix[4],\r\n      transformationMatrix[5]\r\n    );\r\n\r\n    ctx.drawImage(\r\n      this.videoElement,\r\n      0,\r\n      0,\r\n      this.videoWidth || 1024,\r\n      this.videoHeight || 1024\r\n    );\r\n\r\n    for (const actor of this.getActors()) {\r\n      (actor.actor as ICanvasActor).render(this, this.canvasContext);\r\n    }\r\n    this.canvasContext.resetTransform();\r\n\r\n    // This is stack new image to agree with stack/non-volume viewports\r\n    triggerEvent(this.element, EVENTS.STACK_NEW_IMAGE, {\r\n      element: this.element,\r\n      viewportId: this.id,\r\n      viewport: this,\r\n      renderingEngineId: this.renderingEngineId,\r\n      time: this.videoElement.currentTime,\r\n      duration: this.videoElement.duration,\r\n    });\r\n    triggerEvent(this.element, EVENTS.IMAGE_RENDERED, {\r\n      element: this.element,\r\n      viewportId: this.id,\r\n      viewport: this,\r\n      renderingEngineId: this.renderingEngineId,\r\n      time: this.videoElement.currentTime,\r\n      duration: this.videoElement.duration,\r\n    });\r\n\r\n    this.initialRender?.();\r\n\r\n    const frame = this.getFrameNumber();\r\n    if (this.isPlaying) {\r\n      if (frame < this.frameRange[0]) {\r\n        this.setFrameNumber(this.frameRange[0]);\r\n      } else if (frame > this.frameRange[1]) {\r\n        if (this.loop) {\r\n          this.setFrameNumber(this.frameRange[0]);\r\n        } else {\r\n          this.pause();\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  private renderWhilstPlaying = () => {\r\n    this.renderFrame();\r\n\r\n    //wait approximately 16ms and run again\r\n    if (this.isPlaying) {\r\n      requestAnimationFrame(this.renderWhilstPlaying);\r\n    }\r\n  };\r\n}\r\n\r\nexport default VideoViewport;\r\n","import type {\r\n  IStackViewport,\r\n  IStackInput,\r\n  IRenderingEngine,\r\n} from '../../types';\r\n\r\n/**\r\n * For each provided viewport it adds a volume to the viewport using the\r\n * provided renderingEngine\r\n *\r\n *\r\n * @param renderingEngine - The rendering engine to use to get viewports from\r\n * @param volumeInputs - Array of volume inputs including volumeId. Other properties\r\n * such as visibility, callback, blendMode, slabThickness are optional\r\n * @param viewportIds - Array of viewport IDs to add the volume to\r\n * @param immediateRender - If true, the volumes will be rendered immediately\r\n * @returns A promise that resolves when all volumes have been added\r\n */\r\nasync function addImageSlicesToViewports(\r\n  renderingEngine: IRenderingEngine,\r\n  stackInputs: Array<IStackInput>,\r\n  viewportIds: Array<string>\r\n): Promise<void> {\r\n  // Check if all viewports are volumeViewports\r\n  for (const viewportId of viewportIds) {\r\n    const viewport = renderingEngine.getViewport(viewportId);\r\n\r\n    if (!viewport) {\r\n      throw new Error(`Viewport with Id ${viewportId} does not exist`);\r\n    }\r\n\r\n    // if not instance of BaseVolumeViewport, throw\r\n    if (!(viewport as IStackViewport).addImages) {\r\n      console.warn(\r\n        `Viewport with Id ${viewportId} does not have addImages. Cannot add image segmentation to this viewport.`\r\n      );\r\n\r\n      return;\r\n    }\r\n  }\r\n\r\n  const addStackPromises = viewportIds.map(async (viewportId) => {\r\n    const viewport = renderingEngine.getViewport(viewportId) as IStackViewport;\r\n\r\n    return viewport.addImages(stackInputs);\r\n  });\r\n\r\n  await Promise.all(addStackPromises);\r\n}\r\n\r\nexport default addImageSlicesToViewports;\r\n","import BaseVolumeViewport from '../BaseVolumeViewport';\r\nimport type {\r\n  IVolumeViewport,\r\n  IVolumeInput,\r\n  IRenderingEngine,\r\n} from '../../types';\r\n\r\n/**\r\n * For each provided viewport it adds a volume to the viewport using the\r\n * provided renderingEngine\r\n *\r\n *\r\n * @param renderingEngine - The rendering engine to use to get viewports from\r\n * @param volumeInputs - Array of volume inputs including volumeId. Other properties\r\n * such as visibility, callback, blendMode, slabThickness are optional\r\n * @param viewportIds - Array of viewport IDs to add the volume to\r\n * @param immediateRender - If true, the volumes will be rendered immediately\r\n * @returns A promise that resolves when all volumes have been added\r\n */\r\nasync function addVolumesToViewports(\r\n  renderingEngine: IRenderingEngine,\r\n  volumeInputs: Array<IVolumeInput>,\r\n  viewportIds: Array<string>,\r\n  immediateRender = false,\r\n  suppressEvents = false\r\n): Promise<void> {\r\n  // Check if all viewports are volumeViewports\r\n  for (const viewportId of viewportIds) {\r\n    const viewport = renderingEngine.getViewport(viewportId);\r\n\r\n    if (!viewport) {\r\n      throw new Error(`Viewport with Id ${viewportId} does not exist`);\r\n    }\r\n\r\n    // if not instance of BaseVolumeViewport, throw\r\n    if (!(viewport instanceof BaseVolumeViewport)) {\r\n      console.warn(\r\n        `Viewport with Id ${viewportId} is not a BaseVolumeViewport. Cannot add volume to this viewport.`\r\n      );\r\n\r\n      return;\r\n    }\r\n  }\r\n\r\n  const addVolumePromises = viewportIds.map(async (viewportId) => {\r\n    const viewport = renderingEngine.getViewport(viewportId) as IVolumeViewport;\r\n\r\n    await viewport.addVolumes(volumeInputs, immediateRender, suppressEvents);\r\n  });\r\n\r\n  await Promise.all(addVolumePromises);\r\n  return;\r\n}\r\n\r\nexport default addVolumesToViewports;\r\n","import LookupTable from './lookupTable';\r\nimport CPU_COLORMAPS from '../../../../constants/cpuColormaps';\r\nimport {\r\n  CPUFallbackColormap,\r\n  CPUFallbackColormapData,\r\n  Point4,\r\n} from '../../../../types';\r\n\r\nconst COLOR_TRANSPARENT: Point4 = [0, 0, 0, 0];\r\n\r\n/**\r\n *  Generate linearly spaced vectors\r\n *  http://cens.ioc.ee/local/man/matlab/techdoc/ref/linspace.html\r\n * @param {Number} a A number representing the first vector\r\n * @param {Number} b A number representing the second vector\r\n * @param {Number} n The number of linear spaced vectors to generate\r\n * @returns {Array} An array of points representing linear spaced vectors.\r\n * @memberof Colors\r\n */\r\nfunction linspace(a: number, b: number, n: number): number[] {\r\n  n = n === null ? 100 : n;\r\n\r\n  const increment = (b - a) / (n - 1);\r\n  const vector = [];\r\n\r\n  while (n-- > 0) {\r\n    vector.push(a);\r\n    a += increment;\r\n  }\r\n\r\n  // Make sure the last item will always be \"b\" because most of the\r\n  // Time we'll get numbers like 1.0000000000000002 instead of 1.\r\n  vector[vector.length - 1] = b;\r\n\r\n  return vector;\r\n}\r\n\r\n/**\r\n * Returns the \"rank/index\" of the element in a sorted array if found or the highest index if not. Uses (binary search)\r\n * @param {Array} array A sorted array to search in\r\n * @param {any} elem the element in the array to search for\r\n * @returns {number} The rank/index of the element in the given array\r\n * @memberof Colors\r\n */\r\nfunction getRank(array, elem) {\r\n  let left = 0;\r\n  let right = array.length - 1;\r\n\r\n  while (left <= right) {\r\n    const mid = left + Math.floor((right - left) / 2);\r\n    const midElem = array[mid];\r\n\r\n    if (midElem === elem) {\r\n      return mid;\r\n    } else if (elem < midElem) {\r\n      right = mid - 1;\r\n    } else {\r\n      left = mid + 1;\r\n    }\r\n  }\r\n\r\n  return left;\r\n}\r\n\r\n/**\r\n * Find the indices into a sorted array a such that, if the corresponding elements\r\n * In v were inserted before the indices, the order of a would be preserved.\r\n *  http://lagrange.univ-lyon1.fr/docs/numpy/1.11.0/reference/generated/numpy.searchsorted.html\r\n * @param {Array} inputArray The array where the values will be inserted\r\n * @param {Array} values An array of the values to be inserted into the inputArray\r\n * @returns {Array} The indices where elements should be inserted to maintain order.\r\n * @memberof Colors\r\n */\r\nfunction searchSorted(inputArray, values) {\r\n  let i;\r\n  const indexes = [];\r\n  const len = values.length;\r\n\r\n  inputArray.sort(function (a, b) {\r\n    return a - b;\r\n  });\r\n\r\n  for (i = 0; i < len; i++) {\r\n    indexes[i] = getRank(inputArray, values[i]);\r\n  }\r\n\r\n  return indexes;\r\n}\r\n\r\n/**\r\n * Creates an *N* -element 1-d lookup table\r\n * @param {Number} N The number of elements in the result lookup table\r\n * @param {Array} data represented by a list of x,y0,y1 mapping correspondences. Each element in this\r\n * List represents how a value between 0 and 1 (inclusive) represented by x is mapped to\r\n * A corresponding value between 0 and 1 (inclusive). The two values of y are to allow for\r\n * Discontinuous mapping functions (say as might be found in a sawtooth) where y0 represents\r\n * The value of y for values of x <= to that given, and y1 is the value to be used for x >\r\n * Than that given). The list must start with x=0, end with x=1, and all values of x must be\r\n * In increasing order. Values between the given mapping points are determined by simple linear\r\n * Interpolation.\r\n * @param {any} gamma value denotes a \"gamma curve\" value which adjusts the brightness\r\n * at the bottom and top of the map.\r\n * @returns {any[]} an array \"result\" where result[x*(N-1)] gives the closest value for\r\n * Values of x between 0 and 1.\r\n * @memberof Colors\r\n */\r\nfunction makeMappingArray(N, data, gamma) {\r\n  let i;\r\n  const x = [];\r\n  const y0 = [];\r\n  const y1 = [];\r\n  const lut = [];\r\n\r\n  gamma = gamma === null ? 1 : gamma;\r\n\r\n  for (i = 0; i < data.length; i++) {\r\n    const element = data[i];\r\n\r\n    x.push((N - 1) * element[0]);\r\n    y0.push(element[1]);\r\n    y1.push(element[1]);\r\n  }\r\n\r\n  const xLinSpace = linspace(0, 1, N);\r\n\r\n  for (i = 0; i < N; i++) {\r\n    xLinSpace[i] = (N - 1) * Math.pow(xLinSpace[i], gamma);\r\n  }\r\n\r\n  const xLinSpaceIndexes = searchSorted(x, xLinSpace);\r\n\r\n  for (i = 1; i < N - 1; i++) {\r\n    const index = xLinSpaceIndexes[i];\r\n    const colorPercent =\r\n      (xLinSpace[i] - x[index - 1]) / (x[index] - x[index - 1]);\r\n    const colorDelta = y0[index] - y1[index - 1];\r\n\r\n    lut[i] = colorPercent * colorDelta + y1[index - 1];\r\n  }\r\n\r\n  lut[0] = y1[0];\r\n  lut[N - 1] = y0[data.length - 1];\r\n\r\n  return lut;\r\n}\r\n\r\n/**\r\n * Creates a Colormap based on lookup tables using linear segments.\r\n * @param {{red:Array, green:Array, blue:Array}} segmentedData An object with a red, green and blue entries.\r\n * Each entry should be a list of x, y0, y1 tuples, forming rows in a table.\r\n * @param {Number} N The number of elements in the result Colormap\r\n * @param {any} gamma value denotes a \"gamma curve\" value which adjusts the brightness\r\n * at the bottom and top of the Colormap.\r\n * @returns {Array} The created Colormap object\r\n * @description The lookup table is generated using linear interpolation for each\r\n *  Primary color, with the 0-1 domain divided into any number of\r\n * Segments.\r\n * https://github.com/stefanv/matplotlib/blob/3f1a23755e86fef97d51e30e106195f34425c9e3/lib/matplotlib/colors.py#L663\r\n * @memberof Colors\r\n */\r\nfunction createLinearSegmentedColormap(segmentedData, N, gamma) {\r\n  let i;\r\n  const lut = [];\r\n\r\n  N = N === null ? 256 : N;\r\n  gamma = gamma === null ? 1 : gamma;\r\n\r\n  const redLut = makeMappingArray(N, segmentedData.red, gamma);\r\n  const greenLut = makeMappingArray(N, segmentedData.green, gamma);\r\n  const blueLut = makeMappingArray(N, segmentedData.blue, gamma);\r\n\r\n  for (i = 0; i < N; i++) {\r\n    const red = Math.round(redLut[i] * 255);\r\n    const green = Math.round(greenLut[i] * 255);\r\n    const blue = Math.round(blueLut[i] * 255);\r\n    const rgba = [red, green, blue, 255];\r\n\r\n    lut.push(rgba);\r\n  }\r\n\r\n  return lut;\r\n}\r\n\r\n/**\r\n * Return all available colormaps (id and name)\r\n * @returns {Array<{id,key}>} An array of colormaps with an object containing the \"id\" and display \"name\"\r\n * @memberof Colors\r\n */\r\nexport function getColormapsList() {\r\n  const colormaps = [];\r\n  const keys = Object.keys(CPU_COLORMAPS);\r\n\r\n  keys.forEach(function (key) {\r\n    if (CPU_COLORMAPS.hasOwnProperty(key)) {\r\n      const colormap = CPU_COLORMAPS[key];\r\n\r\n      colormaps.push({\r\n        id: key,\r\n        name: colormap.name,\r\n      });\r\n    }\r\n  });\r\n\r\n  colormaps.sort(function (a, b) {\r\n    const aName = a.name.toLowerCase();\r\n    const bName = b.name.toLowerCase();\r\n\r\n    if (aName === bName) {\r\n      return 0;\r\n    }\r\n\r\n    return aName < bName ? -1 : 1;\r\n  });\r\n\r\n  return colormaps;\r\n}\r\n\r\n/**\r\n * Return a colorMap object with the provided id and colormapData\r\n * if the Id matches existent colorMap objects (check colormapsData) the colormapData is ignored.\r\n * if the colormapData is not empty, the colorMap will be added to the colormapsData list. Otherwise, an empty colorMap object is returned.\r\n * @param {string} id The ID of the colormap\r\n * @param {Object} colormapData - An object that can contain a name, numColors, gama, segmentedData and/or colors\r\n * @returns {*} The Colormap Object\r\n * @memberof Colors\r\n */\r\nexport function getColormap(\r\n  id: string,\r\n  colormapData?: CPUFallbackColormapData\r\n): CPUFallbackColormap {\r\n  let colormap = CPU_COLORMAPS[id];\r\n\r\n  if (!colormap) {\r\n    colormap = CPU_COLORMAPS[id] = colormapData || {\r\n      name: '',\r\n      colors: [],\r\n    };\r\n  }\r\n\r\n  if (!colormap.colors && colormap.segmentedData) {\r\n    colormap.colors = createLinearSegmentedColormap(\r\n      colormap.segmentedData,\r\n      colormap.numColors,\r\n      colormap.gamma\r\n    );\r\n  }\r\n\r\n  const cpuFallbackColormap: CPUFallbackColormap = {\r\n    getId() {\r\n      return id;\r\n    },\r\n\r\n    getColorSchemeName() {\r\n      return colormap.name;\r\n    },\r\n\r\n    setColorSchemeName(name) {\r\n      colormap.name = name;\r\n    },\r\n\r\n    getNumberOfColors() {\r\n      return colormap.colors.length;\r\n    },\r\n\r\n    setNumberOfColors(numColors) {\r\n      while (colormap.colors.length < numColors) {\r\n        colormap.colors.push(COLOR_TRANSPARENT);\r\n      }\r\n\r\n      colormap.colors.length = numColors;\r\n    },\r\n\r\n    getColor(index) {\r\n      if (this.isValidIndex(index)) {\r\n        return colormap.colors[index];\r\n      }\r\n\r\n      return COLOR_TRANSPARENT;\r\n    },\r\n\r\n    getColorRepeating(index) {\r\n      const numColors = colormap.colors.length;\r\n\r\n      index = numColors ? index % numColors : 0;\r\n\r\n      return this.getColor(index);\r\n    },\r\n\r\n    setColor(index, rgba) {\r\n      if (this.isValidIndex(index)) {\r\n        colormap.colors[index] = rgba;\r\n      }\r\n    },\r\n\r\n    addColor(rgba) {\r\n      colormap.colors.push(rgba);\r\n    },\r\n\r\n    insertColor(index, rgba) {\r\n      if (this.isValidIndex(index)) {\r\n        colormap.colors.splice(index, 1, rgba);\r\n      }\r\n    },\r\n\r\n    removeColor(index) {\r\n      if (this.isValidIndex(index)) {\r\n        colormap.colors.splice(index, 1);\r\n      }\r\n    },\r\n\r\n    clearColors() {\r\n      colormap.colors = [];\r\n    },\r\n\r\n    buildLookupTable(lut) {\r\n      if (!lut) {\r\n        return;\r\n      }\r\n\r\n      const numColors = colormap.colors.length;\r\n\r\n      lut.setNumberOfTableValues(numColors);\r\n\r\n      for (let i = 0; i < numColors; i++) {\r\n        lut.setTableValue(i, colormap.colors[i]);\r\n      }\r\n    },\r\n\r\n    createLookupTable() {\r\n      const lut = new LookupTable();\r\n\r\n      this.buildLookupTable(lut);\r\n\r\n      return lut;\r\n    },\r\n\r\n    isValidIndex(index) {\r\n      return index >= 0 && index < colormap.colors.length;\r\n    },\r\n  };\r\n\r\n  return cpuFallbackColormap;\r\n}\r\n","import now from './rendering/now';\r\nimport { renderColorImage } from './rendering/renderColorImage';\r\nimport { renderGrayscaleImage } from './rendering/renderGrayscaleImage';\r\nimport { renderPseudoColorImage } from './rendering/renderPseudoColorImage';\r\nimport { CPUFallbackEnabledElement } from '../../../types';\r\n\r\n/**\r\n * Draw an image to a given enabled element synchronously\r\n *\r\n * @param enabledElement - An enabled element to draw into\r\n * @param invalidated - true if pixel data has been invalidated and cached rendering should not be used\r\n */\r\nexport default function (\r\n  enabledElement: CPUFallbackEnabledElement,\r\n  invalidated: boolean\r\n): void {\r\n  const image = enabledElement.image;\r\n\r\n  // Check if enabledElement can be redrawn\r\n  if (!enabledElement.canvas || !enabledElement.image) {\r\n    return;\r\n  }\r\n\r\n  // Start measuring the time needed to draw the image.\r\n  const start = now();\r\n\r\n  image.stats = {\r\n    lastGetPixelDataTime: -1.0,\r\n    lastStoredPixelDataToCanvasImageDataTime: -1.0,\r\n    lastPutImageDataTime: -1.0,\r\n    lastRenderTime: -1.0,\r\n    lastLutGenerateTime: -1.0,\r\n  };\r\n\r\n  if (image) {\r\n    let render = image.render;\r\n\r\n    if (!render) {\r\n      if (enabledElement.viewport.colormap) {\r\n        render = renderPseudoColorImage;\r\n      } else if (image.color) {\r\n        render = renderColorImage;\r\n      } else {\r\n        render = renderGrayscaleImage;\r\n      }\r\n    }\r\n\r\n    render(enabledElement, invalidated);\r\n  }\r\n\r\n  // Calculate how long it took to draw the image/layers\r\n  const renderTimeInMs = now() - start;\r\n\r\n  image.stats.lastRenderTime = renderTimeInMs;\r\n\r\n  enabledElement.invalid = false;\r\n  enabledElement.needsRedraw = false;\r\n}\r\n","import { Transform } from './transform';\r\nimport {\r\n  CPUFallbackEnabledElement,\r\n  CPUFallbackTransform,\r\n} from '../../../../types';\r\n\r\n/**\r\n * Calculate the transform for a Cornerstone enabled element\r\n *\r\n * @param enabledElement - The Cornerstone Enabled Element\r\n * @param scale - The viewport scale\r\n * @returns The current transform\r\n */\r\nexport default function (\r\n  enabledElement: CPUFallbackEnabledElement,\r\n  scale?: number\r\n): CPUFallbackTransform {\r\n  const transform = new Transform();\r\n\r\n  if (!enabledElement.viewport.displayedArea) {\r\n    return transform;\r\n  }\r\n\r\n  // Move to center of canvas\r\n  transform.translate(\r\n    enabledElement.canvas.width / 2,\r\n    enabledElement.canvas.height / 2\r\n  );\r\n\r\n  // Apply the rotation before scaling for non square pixels\r\n  const angle = enabledElement.viewport.rotation;\r\n\r\n  if (angle !== 0) {\r\n    transform.rotate((angle * Math.PI) / 180);\r\n  }\r\n\r\n  // Apply the scale\r\n  let widthScale = enabledElement.viewport.scale;\r\n  let heightScale = enabledElement.viewport.scale;\r\n\r\n  const width =\r\n    enabledElement.viewport.displayedArea.brhc.x -\r\n    (enabledElement.viewport.displayedArea.tlhc.x - 1);\r\n  const height =\r\n    enabledElement.viewport.displayedArea.brhc.y -\r\n    (enabledElement.viewport.displayedArea.tlhc.y - 1);\r\n\r\n  if (enabledElement.viewport.displayedArea.presentationSizeMode === 'NONE') {\r\n    if (\r\n      enabledElement.image.rowPixelSpacing <\r\n      enabledElement.image.columnPixelSpacing\r\n    ) {\r\n      widthScale *=\r\n        enabledElement.image.columnPixelSpacing /\r\n        enabledElement.image.rowPixelSpacing;\r\n    } else if (\r\n      enabledElement.image.columnPixelSpacing <\r\n      enabledElement.image.rowPixelSpacing\r\n    ) {\r\n      heightScale *=\r\n        enabledElement.image.rowPixelSpacing /\r\n        enabledElement.image.columnPixelSpacing;\r\n    }\r\n  } else {\r\n    // These should be good for \"TRUE SIZE\" and \"MAGNIFY\"\r\n    widthScale = enabledElement.viewport.displayedArea.columnPixelSpacing;\r\n    heightScale = enabledElement.viewport.displayedArea.rowPixelSpacing;\r\n\r\n    if (\r\n      enabledElement.viewport.displayedArea.presentationSizeMode ===\r\n      'SCALE TO FIT'\r\n    ) {\r\n      // Fit TRUE IMAGE image (width/height) to window\r\n      const verticalScale =\r\n        enabledElement.canvas.height / (height * heightScale);\r\n      const horizontalScale =\r\n        enabledElement.canvas.width / (width * widthScale);\r\n\r\n      // Apply new scale\r\n      widthScale = heightScale = Math.min(horizontalScale, verticalScale);\r\n\r\n      if (\r\n        enabledElement.viewport.displayedArea.rowPixelSpacing <\r\n        enabledElement.viewport.displayedArea.columnPixelSpacing\r\n      ) {\r\n        widthScale *=\r\n          enabledElement.viewport.displayedArea.columnPixelSpacing /\r\n          enabledElement.viewport.displayedArea.rowPixelSpacing;\r\n      } else if (\r\n        enabledElement.viewport.displayedArea.columnPixelSpacing <\r\n        enabledElement.viewport.displayedArea.rowPixelSpacing\r\n      ) {\r\n        heightScale *=\r\n          enabledElement.viewport.displayedArea.rowPixelSpacing /\r\n          enabledElement.viewport.displayedArea.columnPixelSpacing;\r\n      }\r\n    }\r\n  }\r\n\r\n  transform.scale(widthScale, heightScale);\r\n\r\n  // Unrotate to so we can translate unrotated\r\n  if (angle !== 0) {\r\n    transform.rotate((-angle * Math.PI) / 180);\r\n  }\r\n\r\n  // Apply the pan offset\r\n  transform.translate(\r\n    enabledElement.viewport.translation.x,\r\n    enabledElement.viewport.translation.y\r\n  );\r\n\r\n  // Rotate again so we can apply general scale\r\n  if (angle !== 0) {\r\n    transform.rotate((angle * Math.PI) / 180);\r\n  }\r\n\r\n  if (scale !== undefined) {\r\n    // Apply the font scale\r\n    transform.scale(scale, scale);\r\n  }\r\n\r\n  // Apply Flip if required\r\n  if (enabledElement.viewport.hflip) {\r\n    transform.scale(-1, 1);\r\n  }\r\n\r\n  if (enabledElement.viewport.vflip) {\r\n    transform.scale(1, -1);\r\n  }\r\n\r\n  // Move back from center of image\r\n  transform.translate(-width / 2, -height / 2);\r\n\r\n  return transform;\r\n}\r\n","import getTransform from './getTransform';\r\n\r\nimport { Point2, CPUFallbackEnabledElement } from '../../../../types';\r\n\r\n/**\r\n * Converts a point in the canvas coordinate system to the pixel coordinate system\r\n * system.  This can be used to reset tools' image coordinates after modifications\r\n * have been made in canvas space (e.g. moving a tool by a few cm, independent of\r\n * image resolution).\r\n *\r\n * @param element - The Cornerstone element within which the input point lies\r\n * @param pt - The input point in the canvas coordinate system\r\n *\r\n * @returns The transformed point in the pixel coordinate system\r\n */\r\nexport default function (\r\n  enabledElement: CPUFallbackEnabledElement,\r\n  pt: Point2\r\n): Point2 {\r\n  const transform = getTransform(enabledElement);\r\n\r\n  transform.invert();\r\n\r\n  return transform.transformPoint(pt);\r\n}\r\n","import { CPUFallbackViewport, Point2 } from '../../../../types';\r\n\r\ntype Shift = {\r\n  x: number;\r\n  y: number;\r\n};\r\n/**\r\n * Corrects the shift by accounting for viewport rotation and flips.\r\n *\r\n * @param shift - The shift to correct.\r\n * @param viewportOrientation - Object containing information on the viewport orientation.\r\n */\r\nexport default function (\r\n  shift: Shift,\r\n  viewportOrientation: CPUFallbackViewport\r\n): Shift {\r\n  const { hflip, vflip, rotation } = viewportOrientation;\r\n\r\n  // Apply Flips\r\n  shift.x *= hflip ? -1 : 1;\r\n  shift.y *= vflip ? -1 : 1;\r\n\r\n  // Apply rotations\r\n  if (rotation !== 0) {\r\n    const angle = (rotation * Math.PI) / 180;\r\n\r\n    const cosA = Math.cos(angle);\r\n    const sinA = Math.sin(angle);\r\n\r\n    const newX = shift.x * cosA - shift.y * sinA;\r\n    const newY = shift.x * sinA + shift.y * cosA;\r\n\r\n    shift.x = newX;\r\n    shift.y = newY;\r\n  }\r\n\r\n  return shift;\r\n}\r\n","import createViewport from './createViewport';\r\nimport getImageFitScale from './getImageFitScale';\r\nimport {\r\n  IImage,\r\n  CPUFallbackColormap,\r\n  CPUFallbackViewport,\r\n} from '../../../../types';\r\n\r\n/**\r\n * Creates a new viewport object containing default values for the image and canvas\r\n *\r\n * @param canvas - A Canvas DOM element\r\n * @param image - A Cornerstone Image Object\r\n * @returns viewport - object\r\n */\r\nexport default function (\r\n  canvas: HTMLCanvasElement,\r\n  image: IImage,\r\n  modality?: string,\r\n  colormap?: CPUFallbackColormap\r\n): CPUFallbackViewport {\r\n  if (canvas === undefined) {\r\n    throw new Error(\r\n      'getDefaultViewport: parameter canvas must not be undefined'\r\n    );\r\n  }\r\n\r\n  if (image === undefined) {\r\n    return createViewport();\r\n  }\r\n\r\n  // Fit image to window\r\n  const scale = getImageFitScale(canvas, image, 0).scaleFactor;\r\n\r\n  let voi;\r\n\r\n  if (modality === 'PT' && image.isPreScaled) {\r\n    voi = {\r\n      windowWidth: 5,\r\n      windowCenter: 2.5,\r\n    };\r\n  } else if (\r\n    image.windowWidth !== undefined &&\r\n    image.windowCenter !== undefined\r\n  ) {\r\n    voi = {\r\n      windowWidth: Array.isArray(image.windowWidth)\r\n        ? image.windowWidth[0]\r\n        : image.windowWidth,\r\n      windowCenter: Array.isArray(image.windowCenter)\r\n        ? image.windowCenter[0]\r\n        : image.windowCenter,\r\n    };\r\n  }\r\n\r\n  return {\r\n    scale,\r\n    translation: {\r\n      x: 0,\r\n      y: 0,\r\n    },\r\n    voi,\r\n    invert: image.invert,\r\n    pixelReplication: false,\r\n    rotation: 0,\r\n    hflip: false,\r\n    vflip: false,\r\n    modalityLUT: image.modalityLUT,\r\n    modality,\r\n    voiLUT: image.voiLUT,\r\n    colormap: colormap !== undefined ? colormap : image.colormap,\r\n    displayedArea: {\r\n      tlhc: {\r\n        x: 1,\r\n        y: 1,\r\n      },\r\n      brhc: {\r\n        x: image.columns,\r\n        y: image.rows,\r\n      },\r\n      rowPixelSpacing:\r\n        image.rowPixelSpacing === undefined ? 1 : image.rowPixelSpacing,\r\n      columnPixelSpacing:\r\n        image.columnPixelSpacing === undefined ? 1 : image.columnPixelSpacing,\r\n      presentationSizeMode: 'NONE',\r\n    },\r\n  };\r\n}\r\n","import { validateParameterUndefinedOrNull } from './validator';\r\nimport getImageSize from './getImageSize';\r\nimport { IImage } from '../../../../types';\r\n\r\n/**\r\n * Calculates the horizontal, vertical and minimum scale factor for an image\r\n   @param canvas - The window size where the image is displayed. This can be any HTML element or structure with a width, height fields (e.g. canvas).\r\n * @param image - The cornerstone image object\r\n * @param rotation - The rotation angle of the image.\r\n * @returns The calculated horizontal, vertical and minimum scale factor\r\n */\r\nexport default function (\r\n  canvas: HTMLCanvasElement,\r\n  image: IImage,\r\n  rotation: number | null = null\r\n): {\r\n  verticalScale: number;\r\n  horizontalScale: number;\r\n  scaleFactor: number;\r\n} {\r\n  validateParameterUndefinedOrNull(\r\n    canvas,\r\n    'getImageScale: parameter canvas must not be undefined'\r\n  );\r\n  validateParameterUndefinedOrNull(\r\n    image,\r\n    'getImageScale: parameter image must not be undefined'\r\n  );\r\n\r\n  const imageSize = getImageSize(image, rotation);\r\n  const rowPixelSpacing = image.rowPixelSpacing || 1;\r\n  const columnPixelSpacing = image.columnPixelSpacing || 1;\r\n  let verticalRatio = 1;\r\n  let horizontalRatio = 1;\r\n\r\n  if (rowPixelSpacing < columnPixelSpacing) {\r\n    horizontalRatio = columnPixelSpacing / rowPixelSpacing;\r\n  } else {\r\n    // even if they are equal we want to calculate this ratio (the ration might be 0.5)\r\n    verticalRatio = rowPixelSpacing / columnPixelSpacing;\r\n  }\r\n\r\n  const verticalScale = canvas.height / imageSize.height / verticalRatio;\r\n  const horizontalScale = canvas.width / imageSize.width / horizontalRatio;\r\n\r\n  // Fit image to window\r\n  return {\r\n    verticalScale,\r\n    horizontalScale,\r\n    scaleFactor: Math.min(horizontalScale, verticalScale),\r\n  };\r\n}\r\n","import { validateParameterUndefinedOrNull } from './validator';\r\nimport { IImage } from '../../../../types';\r\n\r\n/**\r\n * Check if the angle is rotated\r\n * @param {Number} rotation the rotation angle\r\n * @returns {Boolean} true if the angle is rotated; Otherwise, false.\r\n * @memberof Internal\r\n */\r\nfunction isRotated(rotation?: number | null): boolean {\r\n  return !(\r\n    rotation === null ||\r\n    rotation === undefined ||\r\n    rotation === 0 ||\r\n    rotation === 180\r\n  );\r\n}\r\n\r\n/**\r\n * Retrieves the current image dimensions given an enabled element\r\n *\r\n * @param {any} image The Cornerstone image.\r\n * @param {Number} rotation Optional. The rotation angle of the image.\r\n * @return {{width:Number, height:Number}} The Image dimensions\r\n * @memberof Internal\r\n */\r\nexport default function (\r\n  image: IImage,\r\n  rotation = null\r\n): { height: number; width: number } {\r\n  validateParameterUndefinedOrNull(\r\n    image,\r\n    'getImageSize: parameter image must not be undefined'\r\n  );\r\n  validateParameterUndefinedOrNull(\r\n    image.width,\r\n    'getImageSize: parameter image must have width'\r\n  );\r\n  validateParameterUndefinedOrNull(\r\n    image.height,\r\n    'getImageSize: parameter image must have height'\r\n  );\r\n\r\n  if (isRotated(rotation)) {\r\n    return {\r\n      height: image.width,\r\n      width: image.height,\r\n    };\r\n  }\r\n\r\n  return {\r\n    width: image.width,\r\n    height: image.height,\r\n  };\r\n}\r\n","import calculateTransform from './calculateTransform';\r\nimport {\r\n  CPUFallbackEnabledElement,\r\n  CPUFallbackTransform,\r\n} from '../../../../types';\r\n\r\nexport default function (\r\n  enabledElement: CPUFallbackEnabledElement\r\n): CPUFallbackTransform {\r\n  // Todo: for some reason using the cached transfer after the first call\r\n  // does not give correct transform.\r\n  // if (enabledElement.transform) {\r\n  //   return enabledElement.transform;\r\n  // }\r\n\r\n  return calculateTransform(enabledElement);\r\n}\r\n","import getTransform from './getTransform';\r\nimport { CPUFallbackEnabledElement, Point2 } from '../../../../types';\r\n\r\n/**\r\n * Converts a point in the pixel coordinate system to the canvas coordinate system\r\n * system.  This can be used to render using canvas context without having the weird\r\n * side effects that come from scaling and non square pixels\r\n *\r\n * @param {HTMLDivElement} element An HTML Element enabled for Cornerstone\r\n * @param {{x: Number, y: Number}} pt The transformed point in the pixel coordinate system\r\n *\r\n * @returns {{x: Number, y: Number}} The input point in the canvas coordinate system\r\n * @memberof PixelCoordinateSystem\r\n */\r\nexport default function (\r\n  enabledElement: CPUFallbackEnabledElement,\r\n  pt: Point2\r\n): Point2 {\r\n  const transform = getTransform(enabledElement);\r\n\r\n  return transform.transformPoint(pt);\r\n}\r\n","import getImageFitScale from './getImageFitScale';\r\nimport { CPUFallbackEnabledElement } from '../../../../types';\r\n\r\n/**\r\n * Resets the camera to the default position. which would be the center of the image.\r\n * with no translation, no flipping, no zoom and proper scale.\r\n */\r\nexport default function (\r\n  enabledElement: CPUFallbackEnabledElement,\r\n  resetPan = true,\r\n  resetZoom = true\r\n): void {\r\n  const { canvas, image, viewport } = enabledElement;\r\n  const scale = getImageFitScale(canvas, image, 0).scaleFactor;\r\n\r\n  viewport.vflip = false;\r\n  viewport.hflip = false;\r\n\r\n  if (resetPan) {\r\n    viewport.translation.x = 0;\r\n    viewport.translation.y = 0;\r\n  }\r\n\r\n  if (resetZoom) {\r\n    viewport.displayedArea.tlhc.x = 1;\r\n    viewport.displayedArea.tlhc.y = 1;\r\n    viewport.displayedArea.brhc.x = image.columns;\r\n    viewport.displayedArea.brhc.y = image.rows;\r\n\r\n    viewport.scale = scale;\r\n  }\r\n}\r\n","import fitToWindow from './fitToWindow';\r\nimport getImageSize from './getImageSize';\r\nimport { CPUFallbackEnabledElement } from '../../../../types';\r\n\r\n/**\r\n * This module is responsible for enabling an element to display images with cornerstone\r\n *\r\n * @param {HTMLDivElement} element The DOM element enabled for Cornerstone\r\n * @param {HTMLDivElement} canvas The Canvas DOM element within the DOM element enabled for Cornerstone\r\n * @returns {void}\r\n */\r\nfunction setCanvasSize(enabledElement: CPUFallbackEnabledElement) {\r\n  const { canvas } = enabledElement;\r\n  const { clientWidth, clientHeight } = canvas;\r\n\r\n  // Set the canvas to be same resolution as the client.\r\n  if (canvas.width !== clientWidth || canvas.height !== clientHeight) {\r\n    canvas.width = clientWidth;\r\n    canvas.height = clientHeight;\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if the image of a given enabled element fitted the window\r\n * before the resize\r\n *\r\n * @param {EnabledElement} enabledElement The Cornerstone Enabled Element\r\n * @param {number} oldCanvasWidth The width of the canvas before the resize\r\n * @param {number} oldCanvasHeight The height of the canvas before the resize\r\n * @return {Boolean} true if it fitted the windows, false otherwise\r\n */\r\nfunction wasFitToWindow(\r\n  enabledElement: CPUFallbackEnabledElement,\r\n  oldCanvasWidth: number,\r\n  oldCanvasHeight: number\r\n): boolean {\r\n  const scale = enabledElement.viewport.scale;\r\n  const imageSize = getImageSize(\r\n    enabledElement.image,\r\n    enabledElement.viewport.rotation\r\n  );\r\n  const imageWidth = Math.round(imageSize.width * scale);\r\n  const imageHeight = Math.round(imageSize.height * scale);\r\n  const x = enabledElement.viewport.translation.x;\r\n  const y = enabledElement.viewport.translation.y;\r\n\r\n  return (\r\n    (imageWidth === oldCanvasWidth && imageHeight <= oldCanvasHeight) ||\r\n    (imageWidth <= oldCanvasWidth &&\r\n      imageHeight === oldCanvasHeight &&\r\n      x === 0 &&\r\n      y === 0)\r\n  );\r\n}\r\n\r\n/**\r\n * Rescale the image relative to the changed size of the canvas\r\n *\r\n * @param {EnabledElement} enabledElement The Cornerstone Enabled Element\r\n * @param {number} oldCanvasWidth The width of the canvas before the resize\r\n * @param {number} oldCanvasHeight The height of the canvas before the resize\r\n * @return {void}\r\n */\r\nfunction relativeRescale(\r\n  enabledElement: CPUFallbackEnabledElement,\r\n  oldCanvasWidth: number,\r\n  oldCanvasHeight: number\r\n): void {\r\n  const scale = enabledElement.viewport.scale;\r\n  const canvasWidth = enabledElement.canvas.width;\r\n  const canvasHeight = enabledElement.canvas.height;\r\n  const relWidthChange = canvasWidth / oldCanvasWidth;\r\n  const relHeightChange = canvasHeight / oldCanvasHeight;\r\n  const relChange = Math.sqrt(relWidthChange * relHeightChange);\r\n\r\n  enabledElement.viewport.scale = relChange * scale;\r\n}\r\n\r\n/**\r\n * Resizes an enabled element and optionally fits the image to window\r\n *\r\n * @param {HTMLDivElement} element The DOM element enabled for Cornerstone\r\n * @param {Boolean} forceFitToWindow true to to force a refit, false to rescale accordingly\r\n * @returns {void}\r\n */\r\nexport default function (\r\n  enabledElement: CPUFallbackEnabledElement,\r\n  forceFitToWindow = false\r\n): void {\r\n  const oldCanvasWidth = enabledElement.canvas.width;\r\n  const oldCanvasHeight = enabledElement.canvas.height;\r\n\r\n  setCanvasSize(enabledElement);\r\n\r\n  if (enabledElement.image === undefined) {\r\n    return;\r\n  }\r\n\r\n  if (\r\n    forceFitToWindow ||\r\n    wasFitToWindow(enabledElement, oldCanvasWidth, oldCanvasHeight)\r\n  ) {\r\n    // Fit the image to the window again if it fitted before the resize\r\n    fitToWindow(enabledElement);\r\n  } else {\r\n    // Adapt the scale of a zoomed or panned image relative to the size change\r\n    relativeRescale(enabledElement, oldCanvasWidth, oldCanvasHeight);\r\n  }\r\n}\r\n","import getImageFitScale from './getImageFitScale';\r\nimport { CPUFallbackEnabledElement } from '../../../../types';\r\n\r\n/**\r\n * Adjusts an image's scale and translation so the image is centered and all pixels\r\n * in the image are viewable.\r\n *\r\n * @param element - The Cornerstone element to update\r\n */\r\nexport default function (enabledElement: CPUFallbackEnabledElement): void {\r\n  const { image } = enabledElement;\r\n\r\n  // The new scale is the minimum of the horizontal and vertical scale values\r\n  enabledElement.viewport.scale = getImageFitScale(\r\n    enabledElement.canvas,\r\n    image,\r\n    enabledElement.viewport.rotation\r\n  ).scaleFactor;\r\n\r\n  enabledElement.viewport.translation.x = 0;\r\n  enabledElement.viewport.translation.y = 0;\r\n}\r\n","import vtkVolume from '@kitware/vtk.js/Rendering/Core/Volume';\r\n\r\nimport { VolumeActor } from './../../types/IActor';\r\nimport { VoiModifiedEventDetail } from './../../types/EventTypes';\r\nimport { loadVolume } from '../../loaders/volumeLoader';\r\nimport createVolumeMapper from './createVolumeMapper';\r\nimport BlendModes from '../../enums/BlendModes';\r\nimport { triggerEvent } from '../../utilities';\r\nimport { Events } from '../../enums';\r\nimport setDefaultVolumeVOI from './setDefaultVolumeVOI';\r\n\r\ninterface createVolumeActorInterface {\r\n  volumeId: string;\r\n  callback?: ({\r\n    volumeActor,\r\n    volumeId,\r\n  }: {\r\n    volumeActor: VolumeActor;\r\n    volumeId: string;\r\n  }) => void;\r\n  blendMode?: BlendModes;\r\n}\r\n\r\n/**\r\n * Given a volumeId, it creates a vtk volume actor and returns it. If\r\n * callback is provided, it will be called with the volume actor and the\r\n * volumeId. If blendMode is provided, it will be set on the volume actor.\r\n *\r\n * @param props - createVolumeActorInterface\r\n * @returns A promise that resolves to a VolumeActor.\r\n */\r\nasync function createVolumeActor(\r\n  props: createVolumeActorInterface,\r\n  element: HTMLDivElement,\r\n  viewportId: string,\r\n  suppressEvents = false,\r\n  useNativeDataType = false\r\n): Promise<VolumeActor> {\r\n  const { volumeId, callback, blendMode } = props;\r\n\r\n  const imageVolume = await loadVolume(volumeId);\r\n\r\n  if (!imageVolume) {\r\n    throw new Error(\r\n      `imageVolume with id: ${imageVolume.volumeId} does not exist`\r\n    );\r\n  }\r\n\r\n  const { imageData, vtkOpenGLTexture } = imageVolume;\r\n\r\n  const volumeMapper = createVolumeMapper(imageData, vtkOpenGLTexture);\r\n\r\n  if (blendMode) {\r\n    volumeMapper.setBlendMode(blendMode);\r\n  }\r\n\r\n  const volumeActor = vtkVolume.newInstance();\r\n  volumeActor.setMapper(volumeMapper);\r\n\r\n  const numberOfComponents = imageData\r\n    .getPointData()\r\n    .getScalars()\r\n    .getNumberOfComponents();\r\n\r\n  if (numberOfComponents === 3) {\r\n    volumeActor.getProperty().setIndependentComponents(false);\r\n  }\r\n\r\n  await setDefaultVolumeVOI(volumeActor, imageVolume, useNativeDataType);\r\n\r\n  if (callback) {\r\n    callback({ volumeActor, volumeId });\r\n  }\r\n\r\n  if (!suppressEvents) {\r\n    triggerVOIModified(element, viewportId, volumeActor, volumeId);\r\n  }\r\n\r\n  return volumeActor;\r\n}\r\n\r\nfunction triggerVOIModified(\r\n  element: HTMLDivElement,\r\n  viewportId: string,\r\n  volumeActor: VolumeActor,\r\n  volumeId: string\r\n) {\r\n  const voiRange = volumeActor\r\n    .getProperty()\r\n    .getRGBTransferFunction(0)\r\n    .getRange();\r\n\r\n  const voiModifiedEventDetail: VoiModifiedEventDetail = {\r\n    viewportId,\r\n    range: {\r\n      lower: voiRange[0],\r\n      upper: voiRange[1],\r\n    },\r\n    volumeId,\r\n  };\r\n\r\n  triggerEvent(element, Events.VOI_MODIFIED, voiModifiedEventDetail);\r\n}\r\n\r\nexport default createVolumeActor;\r\n","import {\r\n  VolumeActor,\r\n  IImageVolume,\r\n  VOIRange,\r\n  ScalingParameters,\r\n} from '../../types';\r\nimport { loadAndCacheImage } from '../../loaders/imageLoader';\r\nimport * as metaData from '../../metaData';\r\nimport { getMinMax, windowLevel } from '../../utilities';\r\nimport { RequestType } from '../../enums';\r\nimport cache from '../../cache';\r\n\r\nconst PRIORITY = 0;\r\nconst REQUEST_TYPE = RequestType.Prefetch;\r\n\r\n/**\r\n * It sets the default window level of an image volume based on the VOI.\r\n * It first look for the VOI in the metadata and if it is not found, it\r\n * loads the middle slice image (middle imageId) and based on its min\r\n * and max pixel values, it calculates the VOI.\r\n * Finally it sets the VOI on the volumeActor transferFunction\r\n * @param volumeActor - The volume actor\r\n * @param imageVolume - The image volume that we want to set the VOI for.\r\n * @param useNativeDataType -  The image data type is native or Float32Array\r\n */\r\nasync function setDefaultVolumeVOI(\r\n  volumeActor: VolumeActor,\r\n  imageVolume: IImageVolume,\r\n  useNativeDataType: boolean\r\n): Promise<void> {\r\n  let voi = getVOIFromMetadata(imageVolume);\r\n\r\n  if (!voi && imageVolume?.imageIds?.length) {\r\n    voi = await getVOIFromMinMax(imageVolume, useNativeDataType);\r\n    voi = handlePreScaledVolume(imageVolume, voi);\r\n  }\r\n  // if (!voi || voi.lower === undefined || voi.upper === undefined) {\r\n  //   throw new Error(\r\n  //     'Could not get VOI from metadata, nor from the min max of the image middle slice'\r\n  //   );\r\n  // }\r\n  if (\r\n    (voi?.lower === 0 && voi?.upper === 0) ||\r\n    voi?.lower === undefined ||\r\n    voi?.upper === undefined\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  volumeActor\r\n    .getProperty()\r\n    .getRGBTransferFunction(0)\r\n    .setMappingRange(voi.lower, voi.upper);\r\n}\r\n\r\nfunction handlePreScaledVolume(imageVolume: IImageVolume, voi: VOIRange) {\r\n  const imageIds = imageVolume.imageIds;\r\n  const imageIdIndex = Math.floor(imageIds.length / 2);\r\n  const imageId = imageIds[imageIdIndex];\r\n\r\n  const generalSeriesModule =\r\n    metaData.get('generalSeriesModule', imageId) || {};\r\n\r\n  /**\r\n   * If the volume is prescaled and the modality is PT Sometimes you get super high\r\n   * values at the peak and it skews the min/max so nothing useful is displayed\r\n   * Therefore, we follow the majority of other viewers and we set the min/max\r\n   * for the scaled PT to be 0, 5\r\n   */\r\n  if (_isCurrentImagePTPrescaled(generalSeriesModule.modality, imageVolume)) {\r\n    return {\r\n      lower: 0,\r\n      upper: 5,\r\n    };\r\n  }\r\n\r\n  return voi;\r\n}\r\n\r\n/**\r\n * Get the VOI from the metadata of the middle slice of the image volume or the metadata of the image volume\r\n * It checks the metadata for the VOI and if it is not found, it returns null\r\n *\r\n * @param imageVolume - The image volume that we want to get the VOI from.\r\n * @returns VOIRange with lower and upper values\r\n */\r\nfunction getVOIFromMetadata(imageVolume: IImageVolume): VOIRange {\r\n  const { imageIds, metadata } = imageVolume;\r\n  let voi;\r\n  if (imageIds.length) {\r\n    const imageIdIndex = Math.floor(imageIds.length / 2);\r\n    const imageId = imageIds[imageIdIndex];\r\n    const voiLutModule = metaData.get('voiLutModule', imageId);\r\n    if (voiLutModule && voiLutModule.windowWidth && voiLutModule.windowCenter) {\r\n      const { windowWidth, windowCenter } = voiLutModule;\r\n      voi = {\r\n        windowWidth: Array.isArray(windowWidth) ? windowWidth[0] : windowWidth,\r\n        windowCenter: Array.isArray(windowCenter)\r\n          ? windowCenter[0]\r\n          : windowCenter,\r\n      };\r\n    }\r\n  } else {\r\n    voi = metadata?.voiLut?.[0];\r\n  }\r\n  if (voi) {\r\n    const { lower, upper } = windowLevel.toLowHighRange(\r\n      Number(voi.windowWidth),\r\n      Number(voi.windowCenter)\r\n    );\r\n    return {\r\n      lower,\r\n      upper,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * It loads the middle slice image (middle imageId) and based on its min\r\n * and max pixel values, it calculates the VOI.\r\n *\r\n * @param imageVolume - The image volume that we want to get the VOI from.\r\n * @param useNativeDataType -  The image data type is native or Float32Array\r\n * @returns The VOIRange with lower and upper values\r\n */\r\nasync function getVOIFromMinMax(\r\n  imageVolume: IImageVolume,\r\n  useNativeDataType: boolean\r\n): Promise<VOIRange> {\r\n  const { imageIds } = imageVolume;\r\n  const scalarData = imageVolume.getScalarData();\r\n\r\n  // Get the middle image from the list of imageIds\r\n  const imageIdIndex = Math.floor(imageIds.length / 2);\r\n  const imageId = imageVolume.imageIds[imageIdIndex];\r\n  const generalSeriesModule =\r\n    metaData.get('generalSeriesModule', imageId) || {};\r\n  const { modality } = generalSeriesModule;\r\n  const modalityLutModule = metaData.get('modalityLutModule', imageId) || {};\r\n\r\n  const numImages = imageIds.length;\r\n  const bytesPerImage = scalarData.byteLength / numImages;\r\n  const voxelsPerImage = scalarData.length / numImages;\r\n  const bytePerPixel = scalarData.BYTES_PER_ELEMENT;\r\n\r\n  const scalingParameters: ScalingParameters = {\r\n    rescaleSlope: modalityLutModule.rescaleSlope,\r\n    rescaleIntercept: modalityLutModule.rescaleIntercept,\r\n    modality,\r\n  };\r\n\r\n  let scalingParametersToUse;\r\n  if (modality === 'PT') {\r\n    const suvFactor = metaData.get('scalingModule', imageId);\r\n\r\n    if (suvFactor) {\r\n      scalingParametersToUse = {\r\n        ...scalingParameters,\r\n        suvbw: suvFactor.suvbw,\r\n      };\r\n    }\r\n  }\r\n\r\n  const byteOffset = imageIdIndex * bytesPerImage;\r\n\r\n  const options = {\r\n    targetBuffer: {\r\n      type: useNativeDataType ? undefined : 'Float32Array',\r\n    },\r\n    priority: PRIORITY,\r\n    requestType: REQUEST_TYPE,\r\n    useNativeDataType,\r\n    preScale: {\r\n      enabled: true,\r\n      scalingParameters: scalingParametersToUse,\r\n    },\r\n  };\r\n\r\n  // Loading the middle slice image for a volume has two scenarios, the first one is that\r\n  // uses the same volumeLoader which might not resolve to an image (since for performance\r\n  // reasons volumes' pixelData is set via offset and length on the volume arrayBuffer\r\n  // when each slice is loaded). The second scenario is that the image might not reach\r\n  // to the volumeLoader, and an already cached image (with Image object) is used\r\n  // instead. For the first scenario, we use the arrayBuffer of the volume to get the correct\r\n  // slice for the imageScalarData, and for the second scenario we use the getPixelData\r\n  // on the Cornerstone IImage object to get the pixel data.\r\n  // Note: we don't want to use the derived or generated images for setting the\r\n  // default VOI, because they are not the original. This is ugly but don't\r\n  // know how to do it better.\r\n  let image = cache.getImage(imageId);\r\n\r\n  if (!imageVolume.referencedImageIds?.length) {\r\n    // we should ignore the cache here,\r\n    // since we want to load the image from with the most\r\n    // recent prescale settings\r\n    image = await loadAndCacheImage(imageId, { ...options, ignoreCache: true });\r\n  }\r\n\r\n  const imageScalarData = image\r\n    ? image.getPixelData()\r\n    : _getImageScalarDataFromImageVolume(\r\n        imageVolume,\r\n        byteOffset,\r\n        bytePerPixel,\r\n        voxelsPerImage\r\n      );\r\n\r\n  // Get the min and max pixel values of the middle slice\r\n  const { min, max } = getMinMax(imageScalarData);\r\n\r\n  return {\r\n    lower: min,\r\n    upper: max,\r\n  };\r\n}\r\n\r\nfunction _getImageScalarDataFromImageVolume(\r\n  imageVolume,\r\n  byteOffset,\r\n  bytePerPixel,\r\n  voxelsPerImage\r\n) {\r\n  const { scalarData } = imageVolume;\r\n  const { buffer } = scalarData;\r\n  if (scalarData.BYTES_PER_ELEMENT !== bytePerPixel) {\r\n    byteOffset *= scalarData.BYTES_PER_ELEMENT / bytePerPixel;\r\n  }\r\n\r\n  const TypedArray = scalarData.constructor;\r\n  const imageScalarData = new TypedArray(voxelsPerImage);\r\n\r\n  const volumeBufferView = new TypedArray(buffer, byteOffset, voxelsPerImage);\r\n\r\n  imageScalarData.set(volumeBufferView);\r\n\r\n  return imageScalarData;\r\n}\r\n\r\nfunction _isCurrentImagePTPrescaled(modality, imageVolume) {\r\n  if (modality !== 'PT' || !imageVolume.isPreScaled) {\r\n    return false;\r\n  }\r\n\r\n  if (!imageVolume.scaling?.PT.suvbw) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport default setDefaultVolumeVOI;\r\n","import macro from '@kitware/vtk.js/macros';\r\nimport vtkVolumeMapper from '@kitware/vtk.js/Rendering/Core/VolumeMapper';\r\n\r\n/**\r\n * vtkSharedVolumeMapper - A derived class of the core vtkVolumeMapper class\r\n * the scalar texture in as an argument. This is so we can share the same texture\r\n * memory across different mappers/actors, so we don't duplicate memory usage.\r\n *\r\n *\r\n *\r\n * @param {*} publicAPI The public API to extend\r\n * @param {*} model The private model to extend.\r\n * @hidden\r\n */\r\nfunction vtkSharedVolumeMapper(publicAPI, model) {\r\n  model.classHierarchy.push('vtkSharedVolumeMapper');\r\n\r\n  const superDelete = publicAPI.delete;\r\n  publicAPI.delete = () => {\r\n    model.scalarTexture = null;\r\n    superDelete();\r\n  };\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Object factory\r\n// ----------------------------------------------------------------------------\r\n\r\n// ----------------------------------------------------------------------------\r\n\r\nconst DEFAULT_VALUES = {\r\n  scalarTexture: null,\r\n};\r\n\r\nexport function extend(publicAPI, model, initialValues = {}) {\r\n  Object.assign(model, DEFAULT_VALUES, initialValues);\r\n\r\n  vtkVolumeMapper.extend(publicAPI, model, initialValues);\r\n\r\n  macro.setGet(publicAPI, model, ['scalarTexture']);\r\n\r\n  // Object methods\r\n  vtkSharedVolumeMapper(publicAPI, model);\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n\r\nexport const newInstance = macro.newInstance(extend, 'vtkSharedVolumeMapper');\r\n\r\n// ----------------------------------------------------------------------------\r\n\r\nexport default { newInstance, extend };\r\n","/*\r\n * Constants\r\n */\r\n\r\nconst DEFAULT_SETTINGS = Symbol('DefaultSettings');\r\nconst RUNTIME_SETTINGS = Symbol('RuntimeSettings');\r\nconst OBJECT_SETTINGS_MAP = Symbol('ObjectSettingsMap');\r\nconst DICTIONARY = Symbol('Dictionary');\r\n\r\n/**\r\n * Settings\r\n */\r\nexport default class Settings {\r\n  constructor(base?: Settings) {\r\n    const dictionary = Object.create(\r\n      (base instanceof Settings && DICTIONARY in base\r\n        ? base[DICTIONARY]\r\n        : null) as object\r\n    );\r\n    Object.seal(\r\n      Object.defineProperty(this, DICTIONARY, {\r\n        value: dictionary,\r\n      })\r\n    );\r\n  }\r\n\r\n  set(key: string, value: unknown): boolean {\r\n    return set(this[DICTIONARY], key, value, null);\r\n  }\r\n\r\n  get(key: string): unknown {\r\n    return get(this[DICTIONARY], key);\r\n  }\r\n\r\n  /**\r\n   * Unset a specific key or a set of keys within a namespace when the key ends with a dot (ASCII #46).\r\n   * If the key is \".\", all keys will be removed and this command works as a reset.\r\n   * @param key - name The key to be unset or a namespace.\r\n   * @returns boolean\r\n   */\r\n  unset(key: string): boolean {\r\n    return unset(this[DICTIONARY], key + '');\r\n  }\r\n\r\n  forEach(callback: (key: string, value: unknown) => void): void {\r\n    iterate(this[DICTIONARY], callback);\r\n  }\r\n\r\n  extend(): Settings {\r\n    return new Settings(this);\r\n  }\r\n\r\n  /**\r\n   * Recursively import all properties from the given plain JavaScript object.\r\n   * This method has the opposite effect of the `dump` method.\r\n   * @param root - The root object whose properties will\r\n   * be imported.\r\n   */\r\n  import(root: Record<string, unknown>): void {\r\n    if (isPlainObject(root)) {\r\n      Object.keys(root).forEach((key) => {\r\n        set(this[DICTIONARY], key, root[key], null);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Build a JSON representation of the current internal state of this settings\r\n   * object. The returned object can be safely passed to `JSON.stringify`\r\n   * function.\r\n   * @returns The JSON representation of the current\r\n   * state of this settings instance\r\n   */\r\n  dump(): Record<string, unknown> {\r\n    const context = {};\r\n    iterate(this[DICTIONARY], (key, value) => {\r\n      if (typeof value !== 'undefined') {\r\n        deepSet(context, key, value);\r\n      }\r\n    });\r\n    return context;\r\n  }\r\n\r\n  static assert(subject: Settings): Settings {\r\n    return subject instanceof Settings\r\n      ? subject\r\n      : Settings.getRuntimeSettings();\r\n  }\r\n\r\n  static getDefaultSettings(subfield = null): Settings | any {\r\n    let defaultSettings = Settings[DEFAULT_SETTINGS];\r\n    if (!(defaultSettings instanceof Settings)) {\r\n      defaultSettings = new Settings();\r\n      Settings[DEFAULT_SETTINGS] = defaultSettings;\r\n    }\r\n\r\n    // Given subfield of 'segmentation' it will return all settings\r\n    // that starts with segmentation.*\r\n    if (subfield) {\r\n      const settingObj = {};\r\n      defaultSettings.forEach((name: string) => {\r\n        if (name.startsWith(subfield)) {\r\n          const setting = name.split(`${subfield}.`)[1];\r\n          settingObj[setting] = defaultSettings.get(name);\r\n        }\r\n      });\r\n      return settingObj;\r\n    }\r\n\r\n    return defaultSettings;\r\n  }\r\n\r\n  static getRuntimeSettings(): Settings {\r\n    let runtimeSettings = Settings[RUNTIME_SETTINGS];\r\n    if (!(runtimeSettings instanceof Settings)) {\r\n      runtimeSettings = new Settings(Settings.getDefaultSettings());\r\n      Settings[RUNTIME_SETTINGS] = runtimeSettings;\r\n    }\r\n    return runtimeSettings;\r\n  }\r\n\r\n  static getObjectSettings(subject: unknown, from?: unknown): Settings {\r\n    let settings = null;\r\n    if (subject instanceof Settings) {\r\n      settings = subject;\r\n    } else if (typeof subject === 'object' && subject !== null) {\r\n      let objectSettingsMap = Settings[OBJECT_SETTINGS_MAP];\r\n      if (!(objectSettingsMap instanceof WeakMap)) {\r\n        objectSettingsMap = new WeakMap();\r\n        Settings[OBJECT_SETTINGS_MAP] = objectSettingsMap;\r\n      }\r\n      settings = objectSettingsMap.get(subject);\r\n      if (!(settings instanceof Settings)) {\r\n        settings = new Settings(\r\n          Settings.assert(Settings.getObjectSettings(from))\r\n        );\r\n        objectSettingsMap.set(subject, settings);\r\n      }\r\n    }\r\n    return settings;\r\n  }\r\n\r\n  static extendRuntimeSettings(): Settings {\r\n    return Settings.getRuntimeSettings().extend();\r\n  }\r\n}\r\n\r\n/*\r\n * Local Helpers\r\n */\r\n\r\nfunction unset(dictionary: Record<string, unknown>, name: string): boolean {\r\n  if (name.endsWith('.')) {\r\n    let deleteCount = 0;\r\n    const namespace = name;\r\n    const base = namespace.slice(0, -1);\r\n    const deleteAll = base.length === 0;\r\n    for (const key in dictionary) {\r\n      if (\r\n        Object.prototype.hasOwnProperty.call(dictionary, key) &&\r\n        (deleteAll || key.startsWith(namespace) || key === base)\r\n      ) {\r\n        delete dictionary[key];\r\n        ++deleteCount;\r\n      }\r\n    }\r\n    return deleteCount > 0;\r\n  }\r\n  return delete dictionary[name];\r\n}\r\n\r\nfunction iterate(\r\n  dictionary: Record<string, unknown>,\r\n  callback: (key: string, value: unknown) => void\r\n): void {\r\n  for (const key in dictionary) {\r\n    callback(key, dictionary[key]);\r\n  }\r\n}\r\n\r\nfunction setAll(\r\n  dictionary: Record<string, unknown>,\r\n  prefix: string,\r\n  record: Record<string, unknown>,\r\n  references: WeakSet<Record<string, unknown>>\r\n): boolean {\r\n  let failCount: number;\r\n  if (references.has(record)) {\r\n    return set(dictionary, prefix, null, references);\r\n  }\r\n  references.add(record);\r\n  failCount = 0;\r\n  for (const field in record) {\r\n    if (Object.prototype.hasOwnProperty.call(record, field)) {\r\n      const key = field.length === 0 ? prefix : `${prefix}.${field}`;\r\n      if (!set(dictionary, key, record[field], references)) {\r\n        ++failCount;\r\n      }\r\n    }\r\n  }\r\n  references.delete(record);\r\n  return failCount === 0;\r\n}\r\n\r\n/**\r\n * Set the key-value pair on a given dictionary. If the given value is a\r\n * plain javascript object, every property of that object will also be set.\r\n * @param dictionary {Record<string, unknown>} The target dictionary\r\n * @param key {string} The given key\r\n * @param value {unknown} The given value\r\n * @param references {WeakSet<Record<string, unknown>>} references is a WeakSet\r\n *  instance used to keep track of which objects have already been iterated\r\n *  through preventing thus possible stack overflows caused by cyclic references\r\n * @returns {boolean} Returns true if every given key-value pair has been\r\n * successfully set\r\n */\r\nfunction set(\r\n  dictionary: Record<string, unknown>,\r\n  key: string,\r\n  value: unknown,\r\n  references: WeakSet<Record<string, unknown>>\r\n): boolean {\r\n  if (isValidKey(key)) {\r\n    if (isPlainObject(value)) {\r\n      return setAll(\r\n        dictionary,\r\n        key,\r\n        value as Record<string, unknown>,\r\n        references instanceof WeakSet ? references : new WeakSet()\r\n      );\r\n    }\r\n    dictionary[key] = value;\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction get(dictionary: Record<string, unknown>, key: string): unknown {\r\n  return dictionary[key];\r\n}\r\n\r\n/**\r\n * Make sure the -provided key correctly formatted.\r\n * e.g.:\r\n *  \"my.cool.property\" (valid)\r\n *  \"my.cool.property.\" (invalid)\r\n *  \".my.cool.property\" (invalid)\r\n *  \"my.cool..property\" (invalid)\r\n * @param key {string} The property name to be used as key within the internal\r\n *  dictionary\r\n * @returns {boolean} True on success, false otherwise\r\n */\r\nfunction isValidKey(key: string): boolean {\r\n  let last: number, current: number, previous: number;\r\n  if (typeof key !== 'string' || (last = key.length - 1) < 0) {\r\n    return false;\r\n  }\r\n  previous = -1;\r\n  while ((current = key.indexOf('.', previous + 1)) >= 0) {\r\n    if (current - previous < 2 || current === last) {\r\n      return false;\r\n    }\r\n    previous = current;\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction isPlainObject(subject: unknown) {\r\n  if (typeof subject === 'object' && subject !== null) {\r\n    const prototype = Object.getPrototypeOf(subject);\r\n    if (prototype === Object.prototype || prototype === null) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction deepSet(context, key, value) {\r\n  const separator = key.indexOf('.');\r\n  if (separator >= 0) {\r\n    const subKey = key.slice(0, separator);\r\n    let subContext = context[subKey];\r\n    if (typeof subContext !== 'object' || subContext === null) {\r\n      const subContextValue = subContext;\r\n      subContext = {};\r\n      if (typeof subContextValue !== 'undefined') {\r\n        subContext[''] = subContextValue;\r\n      }\r\n      context[subKey] = subContext;\r\n    }\r\n    deepSet(subContext, key.slice(separator + 1, key.length), value);\r\n  } else {\r\n    context[key] = value;\r\n  }\r\n}\r\n\r\n/**\r\n * Initial Settings for the repository\r\n */\r\nSettings.getDefaultSettings().set('useCursors', true);\r\n","import {\r\n  ICache,\r\n  IImage,\r\n  IGeometry,\r\n  IImageLoadObject,\r\n  IVolumeLoadObject,\r\n  IGeometryLoadObject,\r\n  ICachedImage,\r\n  ICachedVolume,\r\n  ICachedGeometry,\r\n  EventTypes,\r\n  IImageVolume,\r\n} from '../types';\r\nimport { triggerEvent, imageIdToURI } from '../utilities';\r\nimport eventTarget from '../eventTarget';\r\nimport Events from '../enums/Events';\r\nimport { ImageVolume } from './classes/ImageVolume';\r\n\r\nconst ONE_GB = 1073741824;\r\n\r\n/**\r\n * Stores images, volumes and geometry.\r\n * There are two sizes - the max cache size, that controls the overal maximum\r\n * size, and the instance size, which controls how big any single object can\r\n * be.  Defaults are 3 GB and 2 GB - 8 bytes (just enough to allow allocating it\r\n * without crashing).\r\n * The 3 gb is tuned to the chromium garbage collection cycle to allow image volumes\r\n * to be used/discarded.\r\n */\r\nclass Cache implements ICache {\r\n  // used to store image data (2d)\r\n  private readonly _imageCache = new Map<string, ICachedImage>(); // volatile space\r\n  // used to store volume data (3d)\r\n  private readonly _volumeCache = new Map<string, ICachedVolume>(); // non-volatile space\r\n  // Todo: contour for now, but will be used for surface, etc.\r\n  private readonly _geometryCache: Map<string, ICachedGeometry>;\r\n\r\n  private _imageCacheSize = 0;\r\n  private _volumeCacheSize = 0;\r\n  private _maxCacheSize = 3 * ONE_GB;\r\n  private _maxInstanceSize = 4 * ONE_GB - 8;\r\n\r\n  constructor() {\r\n    // used to store object data (contour, surface, etc.)\r\n    this._geometryCache = new Map();\r\n  }\r\n\r\n  /**\r\n   * Set the maximum cache Size\r\n   *\r\n   * Maximum cache size should be set before adding the data.  If set after,\r\n   * and it is smaller than the current size, will cause issues.\r\n   *\r\n   * @param newMaxCacheSize -  new maximum cache size\r\n   *\r\n   */\r\n  public setMaxCacheSize = (newMaxCacheSize: number): void => {\r\n    if (!newMaxCacheSize || typeof newMaxCacheSize !== 'number') {\r\n      const errorMessage = `New max cacheSize ${this._maxCacheSize} should be defined and should be a number.`;\r\n      throw new Error(errorMessage);\r\n    }\r\n\r\n    this._maxCacheSize = newMaxCacheSize;\r\n  };\r\n\r\n  /**\r\n   * Checks if there is enough space in the cache for requested byte size\r\n   *\r\n   * It returns false, if the sum of volatile (image) cache and unallocated cache\r\n   * is less than the requested byteLength\r\n   *\r\n   * @param byteLength - byte length of requested byte size\r\n   *\r\n   * @returns - boolean indicating if there is enough space in the cache\r\n   */\r\n  public isCacheable = (byteLength: number): boolean => {\r\n    if (byteLength > this._maxInstanceSize) {\r\n      return false;\r\n    }\r\n    const unallocatedSpace = this.getBytesAvailable();\r\n    const imageCacheSize = this._imageCacheSize;\r\n    const availableSpace = unallocatedSpace + imageCacheSize;\r\n\r\n    return availableSpace > byteLength;\r\n  };\r\n\r\n  /**\r\n   * Returns maximum CacheSize allowed\r\n   *\r\n   * @returns maximum allowed cache size\r\n   */\r\n  public getMaxCacheSize = (): number => this._maxCacheSize;\r\n\r\n  /**\r\n   * Returns maximum size of a single instance (volume or single image)\r\n   *\r\n   * @returns maximum instance size\r\n   */\r\n  public getMaxInstanceSize = (): number => this._maxInstanceSize;\r\n\r\n  /**\r\n   * Returns current size of the cache\r\n   *\r\n   * @returns current size of the cache\r\n   */\r\n  public getCacheSize = (): number =>\r\n    this._imageCacheSize + this._volumeCacheSize;\r\n\r\n  /**\r\n   * Returns the unallocated size of the cache\r\n   *\r\n   */\r\n  public getBytesAvailable(): number {\r\n    return this.getMaxCacheSize() - this.getCacheSize();\r\n  }\r\n\r\n  /**\r\n   * Deletes the imageId from the image cache\r\n   *\r\n   * @param imageId - imageId\r\n   *\r\n   */\r\n  private _decacheImage = (imageId: string) => {\r\n    const { imageLoadObject } = this._imageCache.get(imageId);\r\n\r\n    // Cancel any in-progress loading\r\n    if (imageLoadObject.cancelFn) {\r\n      imageLoadObject.cancelFn();\r\n    }\r\n\r\n    if (imageLoadObject.decache) {\r\n      imageLoadObject.decache();\r\n    }\r\n\r\n    this._imageCache.delete(imageId);\r\n  };\r\n\r\n  /**\r\n   * Deletes the volumeId from the volume cache\r\n   *\r\n   * @param volumeId - volumeId\r\n   *\r\n   */\r\n  private _decacheVolume = (volumeId: string) => {\r\n    const cachedVolume = this._volumeCache.get(volumeId);\r\n    const { volumeLoadObject, volume } = cachedVolume;\r\n\r\n    if (volume.cancelLoading) {\r\n      volume.cancelLoading();\r\n    }\r\n\r\n    if (volume.imageData) {\r\n      volume.imageData.delete();\r\n    }\r\n\r\n    // if we had views for the images of the volume, we need to restore them\r\n    // to avoid memory leaks\r\n    this._restoreImagesFromBuffer(volume);\r\n\r\n    if (volumeLoadObject.cancelFn) {\r\n      // Cancel any in-progress loading\r\n      volumeLoadObject.cancelFn();\r\n    }\r\n\r\n    if (volumeLoadObject.decache) {\r\n      volumeLoadObject.decache();\r\n    }\r\n\r\n    this._volumeCache.delete(volumeId);\r\n  };\r\n\r\n  /**\r\n   * Deletes all the images and volumes in the cache\r\n   *\r\n   * Relevant events are fired for each decached image (IMAGE_CACHE_IMAGE_REMOVED) and\r\n   * the decached volume (VOLUME_CACHE_VOLUME_REMOVED).\r\n   *\r\n   * @fires Events.IMAGE_CACHE_IMAGE_REMOVED\r\n   * @fires Events.VOLUME_CACHE_VOLUME_REMOVED\r\n   *\r\n   */\r\n  public purgeCache = (): void => {\r\n    const imageIterator = this._imageCache.keys();\r\n\r\n    /* eslint-disable no-constant-condition */\r\n    while (true) {\r\n      const { value: imageId, done } = imageIterator.next();\r\n\r\n      if (done) {\r\n        break;\r\n      }\r\n\r\n      this.removeImageLoadObject(imageId);\r\n\r\n      triggerEvent(eventTarget, Events.IMAGE_CACHE_IMAGE_REMOVED, { imageId });\r\n    }\r\n\r\n    this.purgeVolumeCache();\r\n  };\r\n\r\n  /**\r\n   * Deletes all the volumes in the cache\r\n   */\r\n  public purgeVolumeCache = (): void => {\r\n    const volumeIterator = this._volumeCache.keys();\r\n\r\n    /* eslint-disable no-constant-condition */\r\n    while (true) {\r\n      const { value: volumeId, done } = volumeIterator.next();\r\n\r\n      if (done) {\r\n        break;\r\n      }\r\n\r\n      this.removeVolumeLoadObject(volumeId);\r\n\r\n      triggerEvent(eventTarget, Events.VOLUME_CACHE_VOLUME_REMOVED, {\r\n        volumeId,\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Purges the cache if necessary based on the requested number of bytes\r\n   *\r\n   * 1) it sorts the volatile (image) cache based on the most recent used images\r\n   * and starts purging from the oldest ones.\r\n   * Note: for a volume, if the volume-related image Ids is provided, it starts\r\n   * by purging the none-related image Ids (those that are not related to the\r\n   * current volume)\r\n   * 2) For a volume, if we purge all images that won't be included in this volume and still\r\n   * don't have enough unallocated space, purge images that will be included\r\n   * in this volume until we have enough space. These will need to be\r\n   * re-fetched, but we must do this not to straddle over the given memory\r\n   * limit, even for a short time, as this may crash the application.\r\n   *\r\n   * @fires Events.IMAGE_CACHE_IMAGE_REMOVED\r\n   *\r\n   * @param numBytes - Number of bytes for the image/volume that is\r\n   * going to be stored inside the cache\r\n   * @param volumeImageIds - list of imageIds that correspond to the\r\n   * volume whose numberOfBytes we want to store in the cache.\r\n   * @returns bytesAvailable or undefined in purging cache\r\n   * does not successfully make enough space for the requested number of bytes\r\n   */\r\n  public decacheIfNecessaryUntilBytesAvailable(\r\n    numBytes: number,\r\n    volumeImageIds?: Array<string>\r\n  ): number | undefined {\r\n    let bytesAvailable = this.getBytesAvailable();\r\n\r\n    // If max cache size has not been exceeded, do nothing\r\n    if (bytesAvailable >= numBytes) {\r\n      return bytesAvailable;\r\n    }\r\n\r\n    let cachedImages = Array.from(this._imageCache.values());\r\n\r\n    // Cache size has been exceeded, create list of images sorted by timeStamp\r\n    // So we can purge the least recently used image\r\n    function compare(a, b) {\r\n      if (a.timeStamp > b.timeStamp) {\r\n        return 1;\r\n      }\r\n      if (a.timeStamp < b.timeStamp) {\r\n        return -1;\r\n      }\r\n\r\n      return 0;\r\n    }\r\n\r\n    cachedImages.sort(compare);\r\n    let cachedImageIds = cachedImages.map((im) => im.imageId);\r\n\r\n    let imageIdsToPurge = cachedImageIds;\r\n\r\n    // if we are making space for a volume, we start by purging the imageIds\r\n    // that are not related to the volume\r\n    if (volumeImageIds) {\r\n      imageIdsToPurge = cachedImageIds.filter(\r\n        (id) => !volumeImageIds.includes(id)\r\n      );\r\n    }\r\n\r\n    // Remove images (that are not related to the volume) from volatile cache\r\n    // until the requested number of bytes become available\r\n    for (const imageId of imageIdsToPurge) {\r\n      this.removeImageLoadObject(imageId);\r\n\r\n      triggerEvent(eventTarget, Events.IMAGE_CACHE_IMAGE_REMOVED, { imageId });\r\n\r\n      bytesAvailable = this.getBytesAvailable();\r\n      if (bytesAvailable >= numBytes) {\r\n        return bytesAvailable;\r\n      }\r\n    }\r\n\r\n    // Remove the imageIds (both volume related and not related)\r\n    cachedImages = Array.from(this._imageCache.values());\r\n    cachedImageIds = cachedImages.map((im) => im.imageId);\r\n\r\n    // Remove volume-image Ids from volatile cache until the requested number of bytes\r\n    // become available\r\n    for (const imageId of cachedImageIds) {\r\n      this.removeImageLoadObject(imageId);\r\n\r\n      triggerEvent(eventTarget, Events.IMAGE_CACHE_IMAGE_REMOVED, { imageId });\r\n\r\n      bytesAvailable = this.getBytesAvailable();\r\n      if (bytesAvailable >= numBytes) {\r\n        return bytesAvailable;\r\n      }\r\n    }\r\n\r\n    // Technically we should not reach here, since isCacheable will throw an\r\n    // error if unallocated + volatile (image) cache cannot fit the upcoming\r\n    // number of bytes\r\n  }\r\n\r\n  /**\r\n   * Puts a new image load object into the cache\r\n   *\r\n   * First, it creates a CachedImage object and put it inside the imageCache for\r\n   * the imageId. After the imageLoadObject promise resolves to an image,\r\n   * it: 1) adds the image into the correct CachedImage object 2) increments the\r\n   * cache size, 3) triggers IMAGE_CACHE_IMAGE_ADDED  4) Purge the cache if\r\n   * necessary -- if the cache size is greater than the maximum cache size, it\r\n   * iterates over the imageCache and decache them one by one until the cache\r\n   * size becomes less than the maximum allowed cache size\r\n   *\r\n   * @fires Events.IMAGE_CACHE_IMAGE_ADDED\r\n   * @fires Events.CACHE_SIZE_EXCEEDED if the cache size exceeds the maximum\r\n   *\r\n   * @param imageId - ImageId for the image\r\n   * @param imageLoadObject - The object that is loading or loaded the image\r\n   */\r\n  public putImageLoadObject(\r\n    imageId: string,\r\n    imageLoadObject: IImageLoadObject\r\n  ): Promise<any> {\r\n    if (imageId === undefined) {\r\n      throw new Error('putImageLoadObject: imageId must not be undefined');\r\n    }\r\n\r\n    if (imageLoadObject.promise === undefined) {\r\n      throw new Error(\r\n        'putImageLoadObject: imageLoadObject.promise must not be undefined'\r\n      );\r\n    }\r\n\r\n    if (this._imageCache.has(imageId)) {\r\n      throw new Error('putImageLoadObject: imageId already in cache');\r\n    }\r\n\r\n    if (\r\n      imageLoadObject.cancelFn &&\r\n      typeof imageLoadObject.cancelFn !== 'function'\r\n    ) {\r\n      throw new Error(\r\n        'putImageLoadObject: imageLoadObject.cancel must be a function'\r\n      );\r\n    }\r\n\r\n    const cachedImage: ICachedImage = {\r\n      loaded: false,\r\n      imageId,\r\n      sharedCacheKey: undefined, // The sharedCacheKey for this imageId.  undefined by default\r\n      imageLoadObject,\r\n      timeStamp: Date.now(),\r\n      sizeInBytes: 0,\r\n    };\r\n\r\n    this._imageCache.set(imageId, cachedImage);\r\n\r\n    return imageLoadObject.promise\r\n      .then((image: IImage) => {\r\n        if (!this._imageCache.get(imageId)) {\r\n          // If the image has been purged before being loaded, we stop here.\r\n          console.warn(\r\n            'The image was purged from the cache before it completed loading.'\r\n          );\r\n          return;\r\n        }\r\n\r\n        if (\r\n          image.sizeInBytes === undefined ||\r\n          Number.isNaN(image.sizeInBytes)\r\n        ) {\r\n          throw new Error(\r\n            'putImageLoadObject: image.sizeInBytes must not be undefined'\r\n          );\r\n        }\r\n        if (image.sizeInBytes.toFixed === undefined) {\r\n          throw new Error(\r\n            'putImageLoadObject: image.sizeInBytes is not a number'\r\n          );\r\n        }\r\n\r\n        // check if there is enough space in unallocated + image Cache\r\n        if (!this.isCacheable(image.sizeInBytes)) {\r\n          throw new Error(Events.CACHE_SIZE_EXCEEDED);\r\n        }\r\n\r\n        // if there is, decache if necessary\r\n        this.decacheIfNecessaryUntilBytesAvailable(image.sizeInBytes);\r\n\r\n        cachedImage.loaded = true;\r\n        cachedImage.image = image;\r\n        cachedImage.sizeInBytes = image.sizeInBytes;\r\n        this.incrementImageCacheSize(cachedImage.sizeInBytes);\r\n        const eventDetails: EventTypes.ImageCacheImageAddedEventDetail = {\r\n          image: cachedImage,\r\n        };\r\n\r\n        triggerEvent(eventTarget, Events.IMAGE_CACHE_IMAGE_ADDED, eventDetails);\r\n\r\n        cachedImage.sharedCacheKey = image.sharedCacheKey;\r\n      })\r\n      .catch((error) => {\r\n        // console.warn(error)\r\n        this._imageCache.delete(imageId);\r\n        throw error;\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Returns the object that is loading a given imageId\r\n   *\r\n   * @param imageId - Image ID\r\n   * @returns IImageLoadObject\r\n   */\r\n  public getImageLoadObject(imageId: string): IImageLoadObject {\r\n    if (imageId === undefined) {\r\n      throw new Error('getImageLoadObject: imageId must not be undefined');\r\n    }\r\n    const cachedImage = this._imageCache.get(imageId);\r\n\r\n    if (cachedImage === undefined) {\r\n      return;\r\n    }\r\n\r\n    // Bump time stamp for cached image\r\n    cachedImage.timeStamp = Date.now();\r\n\r\n    return cachedImage.imageLoadObject;\r\n  }\r\n\r\n  /**\r\n   * It checks the imageCache for the provided imageId, and returns true\r\n   * if the image is loaded, false otherwise. Note, this only checks the imageCache\r\n   * and does not check the volume cache.\r\n   * @param imageId - image Id to check\r\n   * @returns boolean\r\n   */\r\n  public isLoaded(imageId: string): boolean {\r\n    const cachedImage = this._imageCache.get(imageId);\r\n\r\n    if (!cachedImage) {\r\n      return false;\r\n    }\r\n\r\n    return cachedImage.loaded;\r\n  }\r\n\r\n  /**\r\n   * Returns the volume that contains the requested imageId. It will check the\r\n   * imageIds inside the volume to find a match.\r\n   *\r\n   * @param imageId - ImageId\r\n   * @returns - Volume object\r\n   */\r\n  public getVolumeContainingImageId(imageId: string): {\r\n    volume: IImageVolume;\r\n    imageIdIndex: number;\r\n  } {\r\n    const volumeIds = Array.from(this._volumeCache.keys());\r\n    const imageIdToUse = imageIdToURI(imageId);\r\n\r\n    for (const volumeId of volumeIds) {\r\n      const cachedVolume = this._volumeCache.get(volumeId);\r\n      const { volume } = cachedVolume;\r\n\r\n      if (!volume?.imageIds?.length) {\r\n        return;\r\n      }\r\n\r\n      const imageIdIndex = volume.getImageURIIndex(imageIdToUse);\r\n\r\n      if (imageIdIndex > -1) {\r\n        return { volume, imageIdIndex };\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the cached image from the imageCache for the requested imageId.\r\n   * It first strips the imageId to remove the data loading scheme.\r\n   *\r\n   * @param imageId - Image ID\r\n   * @returns cached image\r\n   */\r\n  public getCachedImageBasedOnImageURI(\r\n    imageId: string\r\n  ): ICachedImage | undefined {\r\n    const imageURIToUse = imageIdToURI(imageId);\r\n\r\n    const cachedImageIds = Array.from(this._imageCache.keys());\r\n    const foundImageId = cachedImageIds.find((imageId) => {\r\n      return imageIdToURI(imageId) === imageURIToUse;\r\n    });\r\n\r\n    if (!foundImageId) {\r\n      return;\r\n    }\r\n\r\n    return this._imageCache.get(foundImageId);\r\n  }\r\n  /**\r\n   * Puts a new image load object into the cache\r\n   *\r\n   * First, it creates a CachedVolume object and put it inside the volumeCache for\r\n   * the volumeId. After the volumeLoadObject promise resolves to a volume,\r\n   * it: 1) adds the volume into the correct CachedVolume object inside volumeCache\r\n   * 2) increments the cache size, 3) triggers VOLUME_CACHE_VOLUME_ADDED  4) Purge\r\n   * the cache if necessary -- if the cache size is greater than the maximum cache size, it\r\n   * iterates over the imageCache (not volumeCache) and decache them one by one\r\n   * until the cache size becomes less than the maximum allowed cache size\r\n   *\r\n   * @fires Events.VOLUME_CACHE_VOLUME_ADDED\r\n   *\r\n   * @param volumeId - volumeId of the volume\r\n   * @param volumeLoadObject - The object that is loading or loaded the volume\r\n   */\r\n  public putVolumeLoadObject(\r\n    volumeId: string,\r\n    volumeLoadObject: IVolumeLoadObject\r\n  ): Promise<any> {\r\n    if (volumeId === undefined) {\r\n      throw new Error('putVolumeLoadObject: volumeId must not be undefined');\r\n    }\r\n    if (volumeLoadObject.promise === undefined) {\r\n      throw new Error(\r\n        'putVolumeLoadObject: volumeLoadObject.promise must not be undefined'\r\n      );\r\n    }\r\n    if (this._volumeCache.has(volumeId)) {\r\n      throw new Error(\r\n        `putVolumeLoadObject: volumeId:${volumeId} already in cache`\r\n      );\r\n    }\r\n    if (\r\n      volumeLoadObject.cancelFn &&\r\n      typeof volumeLoadObject.cancelFn !== 'function'\r\n    ) {\r\n      throw new Error(\r\n        'putVolumeLoadObject: volumeLoadObject.cancel must be a function'\r\n      );\r\n    }\r\n\r\n    // todo: @Erik there are two loaded flags, one inside cachedVolume and the other\r\n    // inside the volume.loadStatus.loaded, the actual all pixelData loaded is the\r\n    // loadStatus one. This causes confusion\r\n    const cachedVolume: ICachedVolume = {\r\n      loaded: false,\r\n      volumeId,\r\n      volumeLoadObject,\r\n      timeStamp: Date.now(),\r\n      sizeInBytes: 0,\r\n    };\r\n\r\n    this._volumeCache.set(volumeId, cachedVolume);\r\n\r\n    return volumeLoadObject.promise\r\n      .then((volume: IImageVolume) => {\r\n        if (!this._volumeCache.get(volumeId)) {\r\n          // If the image has been purged before being loaded, we stop here.\r\n          console.warn(\r\n            'The image was purged from the cache before it completed loading.'\r\n          );\r\n          return;\r\n        }\r\n\r\n        if (Number.isNaN(volume.sizeInBytes)) {\r\n          throw new Error(\r\n            'putVolumeLoadObject: volume.sizeInBytes must not be undefined'\r\n          );\r\n        }\r\n        if (volume.sizeInBytes.toFixed === undefined) {\r\n          throw new Error(\r\n            'putVolumeLoadObject: volume.sizeInBytes is not a number'\r\n          );\r\n        }\r\n\r\n        // this.isCacheable is called at the volume loader, before requesting\r\n        // the images of the volume\r\n\r\n        this.decacheIfNecessaryUntilBytesAvailable(\r\n          volume.sizeInBytes,\r\n          // @ts-ignore: // todo ImageVolume does not have imageIds\r\n          volume.imageIds\r\n        );\r\n\r\n        // cachedVolume.loaded = true\r\n        cachedVolume.volume = volume;\r\n        cachedVolume.sizeInBytes = volume.sizeInBytes;\r\n        this.incrementVolumeCacheSize(cachedVolume.sizeInBytes);\r\n\r\n        const eventDetails: EventTypes.VolumeCacheVolumeAddedEventDetail = {\r\n          volume: cachedVolume,\r\n        };\r\n\r\n        triggerEvent(\r\n          eventTarget,\r\n          Events.VOLUME_CACHE_VOLUME_ADDED,\r\n          eventDetails\r\n        );\r\n      })\r\n      .catch((error) => {\r\n        this._volumeCache.delete(volumeId);\r\n        throw error;\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Returns the object that is loading a given volumeId\r\n   *\r\n   * @param volumeId - Volume ID\r\n   * @returns IVolumeLoadObject\r\n   */\r\n  public getVolumeLoadObject = (volumeId: string): IVolumeLoadObject => {\r\n    if (volumeId === undefined) {\r\n      throw new Error('getVolumeLoadObject: volumeId must not be undefined');\r\n    }\r\n    const cachedVolume = this._volumeCache.get(volumeId);\r\n\r\n    if (cachedVolume === undefined) {\r\n      return;\r\n    }\r\n\r\n    // Bump time stamp for cached volume (not used for anything for now)\r\n    cachedVolume.timeStamp = Date.now();\r\n\r\n    return cachedVolume.volumeLoadObject;\r\n  };\r\n\r\n  public getGeometry = (geometryId: string): IGeometry => {\r\n    if (geometryId == null) {\r\n      throw new Error('getGeometry: geometryId must not be undefined');\r\n    }\r\n\r\n    const cachedGeometry = this._geometryCache.get(geometryId);\r\n\r\n    if (cachedGeometry === undefined) {\r\n      return;\r\n    }\r\n\r\n    // Bump time stamp for cached geometry (not used for anything for now)\r\n    cachedGeometry.timeStamp = Date.now();\r\n\r\n    return cachedGeometry.geometry;\r\n  };\r\n\r\n  /**\r\n   * Returns the image associated with the imageId\r\n   *\r\n   * @param imageId - image ID\r\n   * @returns Image\r\n   */\r\n  public getImage = (imageId: string): IImage => {\r\n    if (imageId === undefined) {\r\n      throw new Error('getImage: imageId must not be undefined');\r\n    }\r\n    const cachedImage = this._imageCache.get(imageId);\r\n\r\n    if (cachedImage === undefined) {\r\n      return;\r\n    }\r\n\r\n    // Bump time stamp for cached volume (not used for anything for now)\r\n    cachedImage.timeStamp = Date.now();\r\n\r\n    return cachedImage.image;\r\n  };\r\n\r\n  /**\r\n   * Returns the volume associated with the volumeId\r\n   *\r\n   * @param volumeId - Volume ID\r\n   * @returns Volume\r\n   */\r\n  public getVolume = (volumeId: string): IImageVolume => {\r\n    if (volumeId === undefined) {\r\n      throw new Error('getVolume: volumeId must not be undefined');\r\n    }\r\n    const cachedVolume = this._volumeCache.get(volumeId);\r\n\r\n    if (cachedVolume === undefined) {\r\n      return;\r\n    }\r\n\r\n    // Bump time stamp for cached volume (not used for anything for now)\r\n    cachedVolume.timeStamp = Date.now();\r\n\r\n    return cachedVolume.volume;\r\n  };\r\n\r\n  /**\r\n   * Retrieves an array of image volumes from the cache.\r\n   * @returns An array of image volumes.\r\n   */\r\n  public getVolumes = (): Array<IImageVolume> => {\r\n    const cachedVolumes = Array.from(this._volumeCache.values());\r\n\r\n    return cachedVolumes.map((cachedVolume) => cachedVolume.volume);\r\n  };\r\n\r\n  /**\r\n   * Filters the cached volumes by the specified reference volume ID.\r\n   * @param volumeId - The ID of the reference volume.\r\n   * @returns An array of image volumes that have the specified reference volume ID.\r\n   */\r\n  public filterVolumesByReferenceId = (\r\n    volumeId: string\r\n  ): Array<IImageVolume> => {\r\n    const cachedVolumes = this.getVolumes();\r\n\r\n    return cachedVolumes.filter((volume) => {\r\n      return volume.referencedVolumeId === volumeId;\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Removes the image loader associated with a given Id from the cache\r\n   *\r\n   * It increases the cache size after removing the image.\r\n   *\r\n   * @fires Events.IMAGE_CACHE_IMAGE_REMOVED\r\n   *\r\n   * @param imageId - Image ID\r\n   */\r\n  public removeImageLoadObject = (imageId: string): void => {\r\n    if (imageId === undefined) {\r\n      throw new Error('removeImageLoadObject: imageId must not be undefined');\r\n    }\r\n    const cachedImage = this._imageCache.get(imageId);\r\n\r\n    if (cachedImage === undefined) {\r\n      throw new Error(\r\n        'removeImageLoadObject: imageId was not present in imageCache'\r\n      );\r\n    }\r\n\r\n    this.incrementImageCacheSize(-cachedImage.sizeInBytes);\r\n\r\n    const eventDetails = {\r\n      image: cachedImage,\r\n      imageId,\r\n    };\r\n\r\n    triggerEvent(eventTarget, Events.IMAGE_CACHE_IMAGE_REMOVED, eventDetails);\r\n    this._decacheImage(imageId);\r\n  };\r\n\r\n  /**\r\n   * Removes the volume loader associated with a given Id from the cache\r\n   *\r\n   * It increases the cache size after removing the image.\r\n   *\r\n   * @fires Events.VOLUME_CACHE_VOLUME_REMOVED\r\n   *\r\n   * @param imageId - ImageId\r\n   */\r\n  public removeVolumeLoadObject = (volumeId: string): void => {\r\n    if (volumeId === undefined) {\r\n      throw new Error('removeVolumeLoadObject: volumeId must not be undefined');\r\n    }\r\n    const cachedVolume = this._volumeCache.get(volumeId);\r\n\r\n    if (cachedVolume === undefined) {\r\n      throw new Error(\r\n        'removeVolumeLoadObject: volumeId was not present in volumeCache'\r\n      );\r\n    }\r\n\r\n    this.incrementVolumeCacheSize(-cachedVolume.sizeInBytes);\r\n\r\n    const eventDetails = {\r\n      volume: cachedVolume,\r\n      volumeId,\r\n    };\r\n\r\n    triggerEvent(eventTarget, Events.VOLUME_CACHE_VOLUME_REMOVED, eventDetails);\r\n    this._decacheVolume(volumeId);\r\n  };\r\n\r\n  putGeometryLoadObject = (\r\n    geometryId: string,\r\n    geometryLoadObject: IGeometryLoadObject\r\n  ): Promise<void> => {\r\n    if (geometryId == undefined) {\r\n      throw new Error(\r\n        'putGeometryLoadObject: geometryId must not be undefined'\r\n      );\r\n    }\r\n\r\n    if (this._geometryCache.has(geometryId)) {\r\n      throw new Error(\r\n        'putGeometryLoadObject: geometryId already present in geometryCache'\r\n      );\r\n    }\r\n\r\n    const cachedGeometry: ICachedGeometry = {\r\n      geometryId,\r\n      geometryLoadObject,\r\n      loaded: false,\r\n      timeStamp: Date.now(),\r\n      sizeInBytes: 0,\r\n    };\r\n\r\n    this._geometryCache.set(geometryId, cachedGeometry);\r\n\r\n    return geometryLoadObject.promise\r\n      .then((geometry: IGeometry) => {\r\n        if (!this._geometryCache.has(geometryId)) {\r\n          console.warn(\r\n            'putGeometryLoadObject: geometryId was removed from geometryCache'\r\n          );\r\n          return;\r\n        }\r\n\r\n        if (Number.isNaN(geometry.sizeInBytes)) {\r\n          throw new Error(\r\n            'putGeometryLoadObject: geometry.sizeInBytes is not a number'\r\n          );\r\n        }\r\n\r\n        // Todo: fix is cacheable\r\n\r\n        cachedGeometry.loaded = true;\r\n        cachedGeometry.geometry = geometry;\r\n        cachedGeometry.sizeInBytes = geometry.sizeInBytes;\r\n\r\n        // this._incrementGeometryCacheSize(geometry.sizeInBytes);\r\n\r\n        const eventDetails = {\r\n          geometry,\r\n          geometryId,\r\n        };\r\n\r\n        triggerEvent(\r\n          eventTarget,\r\n          Events.GEOMETRY_CACHE_GEOMETRY_ADDED,\r\n          eventDetails\r\n        );\r\n\r\n        return;\r\n      })\r\n      .catch((error) => {\r\n        this._geometryCache.delete(geometryId);\r\n        throw error;\r\n      });\r\n  };\r\n\r\n  /**\r\n   * Increases the image cache size with the provided increment\r\n   *\r\n   * @param increment - bytes length\r\n   */\r\n  public incrementImageCacheSize = (increment: number) => {\r\n    this._imageCacheSize += increment;\r\n  };\r\n\r\n  /**\r\n   * Increases the cache size with the provided increment\r\n   *\r\n   * @param increment - bytes length\r\n   */\r\n  public incrementVolumeCacheSize = (increment: number) => {\r\n    this._volumeCacheSize += increment;\r\n  };\r\n\r\n  /**\r\n   * Decreases the image cache size with the provided decrement\r\n   *\r\n   * @param decrement - bytes length\r\n   */\r\n  public decrementImageCacheSize = (decrement: number) => {\r\n    this._imageCacheSize -= decrement;\r\n  };\r\n\r\n  /**\r\n   * Decreases the cache size with the provided decrement\r\n   *\r\n   * @param decrement - bytes length\r\n   */\r\n  public decrementVolumeCacheSize = (decrement: number) => {\r\n    this._volumeCacheSize -= decrement;\r\n  };\r\n\r\n  /**\r\n   * This function will restore the images' pixel data from the shared array buffer\r\n   * back to the individual images when the volume is purged from cache. It ensures\r\n   * that each image retrieves its correct portion of data from the buffer based on\r\n   * the previously stored offset and length information.\r\n   *\r\n   * @param volumeId - The volumeId whose images need to be restored.\r\n   */\r\n  private _restoreImagesFromBuffer(volume: IImageVolume) {\r\n    if (!(volume instanceof ImageVolume)) {\r\n      console.warn(\r\n        'Volume is not an ImageVolume. Cannot restore images from buffer.'\r\n      );\r\n      return;\r\n    }\r\n\r\n    // Retrieve the scalar data and the offset map from the volume\r\n    const scalarData = volume.getScalarData();\r\n    const imageCacheOffsetMap = volume.imageCacheOffsetMap;\r\n\r\n    if (imageCacheOffsetMap.size === 0) {\r\n      // This happens during testing and isn't an issue\r\n      // console.warn('No cached images to restore for this volume.');\r\n      return;\r\n    }\r\n\r\n    // Iterate over each image and restore its pixel data from the shared buffer\r\n    for (const [imageId, { offset }] of imageCacheOffsetMap) {\r\n      const image = this.getImage(imageId);\r\n\r\n      if (!image) {\r\n        console.warn(`Image with id ${imageId} not found in cache.`);\r\n        continue;\r\n      }\r\n\r\n      const viewPixelData = image.getPixelData();\r\n      const length = viewPixelData.length;\r\n\r\n      // Create a new view of the buffer for this specific image\r\n      // @ts-ignore\r\n      const pixelData = new viewPixelData.constructor(\r\n        scalarData.buffer,\r\n        offset,\r\n        length\r\n      );\r\n\r\n      // Restore the original getPixelData function and pixelData\r\n      image.getPixelData = () => pixelData;\r\n\r\n      if (image.imageFrame) {\r\n        image.imageFrame.pixelData = pixelData;\r\n      }\r\n\r\n      delete image.bufferView;\r\n\r\n      // Optionally, increment the image cache size again if needed\r\n      this.incrementImageCacheSize(image.sizeInBytes);\r\n    }\r\n\r\n    console.log(`Images restored from buffer for volume ${volume.volumeId}.`);\r\n  }\r\n}\r\n\r\n/**\r\n * This module deals with Caching of images and volumes\r\n * The cache has two main components: a volatile portion for images and a\r\n * non-volatile portion for volumes. Individual 2D images are volatile and\r\n * will be replaced by new images hitting the cache. When you allocate volumes,\r\n * these are non-volatile and reserve a block of memory from the cache.\r\n * Volumes must be released manually.\r\n * We will have a shared block of memory allocated for the entire cache, e.g. 1GB\r\n * which will be shared for images and volumes.\r\n *\r\n * **When a new image is added:**\r\n * We check if there is enough unallocated + volatile space for the single image\r\n *\r\n * if so\r\n * - We allocate the image in image cache, and if necessary oldest images\r\n * are decached to match the maximumCacheSize criteria\r\n * - If a volume contains that imageId, copy it over using TypedArray's set method.\r\n * If no volumes contain the imageId, the image is fetched by image loaders\r\n *\r\n * If not (cache is mostly/completely full with volumes)\r\n * - throw that the cache does not have enough working space to allocate the image\r\n *\r\n *\r\n * **When a new volume is added:**\r\n * Check if there is enough unallocated + volatile space to allocate the volume:\r\n *\r\n * If so:\r\n * - Decache oldest images which won't be included in this volume until\r\n * we have enough free space for the volume\r\n * - If not enough space from previous space, decache images that will be included\r\n * in the volume until we have enough free space (These will need to be re-fetched,\r\n * but we must do this not to straddle over the given memory limit, even for a\r\n * short time, as this may crash the app)\r\n * - At this point, if any of the frames (indexed by imageId) are present in the volatile\r\n * image cache, copy these over to the volume now\r\n *\r\n * If not (cache is mostly/completely full with volumes),\r\n * - throw that the cache does not have enough working space to allocate the volume.\r\n *\r\n */\r\nconst cache = new Cache();\r\nexport default cache;\r\nexport { Cache }; // for documentation\r\n","const EPSILON = 1e-3;\r\n\r\nexport default EPSILON;\r\n","const RENDERING_DEFAULTS = {\r\n  MINIMUM_SLAB_THICKNESS: 5e-2,\r\n  MAXIMUM_RAY_DISTANCE: 1e6,\r\n};\r\n\r\nObject.freeze(RENDERING_DEFAULTS);\r\n\r\nexport default RENDERING_DEFAULTS;\r\n","/**\r\n * Request types for requesting images from the imageLoadPoolManager\r\n */\r\nenum RequestType {\r\n  /** Highest priority for loading*/\r\n  Interaction = 'interaction',\r\n  /** Second highest priority for loading*/\r\n  Thumbnail = 'thumbnail',\r\n  /** Third highest priority for loading, usually used for image loading in the background*/\r\n  Prefetch = 'prefetch',\r\n  /** Lower priority, often used for background computations in the worker */\r\n  Compute = 'compute',\r\n}\r\n\r\nexport default RequestType;\r\n","enum ViewportStatus {\r\n  /** Initial state before any volumes or stacks are available*/\r\n  NO_DATA = 'noData',\r\n  /** Stack/volumes are available but are in progress */\r\n  LOADING = 'loading',\r\n  /** Ready to be rendered */\r\n  PRE_RENDER = 'preRender',\r\n  /** In the midst of a resize */\r\n  RESIZE = 'resize',\r\n  /** Rendered image data */\r\n  RENDERED = 'rendered',\r\n}\r\n\r\nexport default ViewportStatus;\r\n","import vtkConstants from '@kitware/vtk.js/Rendering/Core/VolumeMapper/Constants';\r\n\r\nconst { BlendMode } = vtkConstants;\r\n\r\n/**\r\n * Enums for blendModes for viewport images based on vtk.js\r\n *\r\n * It should be noted that if crosshairs are enabled and can modify the slab thickness,\r\n * then it will not show any difference unless MAXIMUM_INTENSITY_BLEND is set on the viewport\r\n * as the blend.\r\n */\r\nenum BlendModes {\r\n  /** composite blending - suitable for compositing multiple images */\r\n  COMPOSITE = BlendMode.COMPOSITE_BLEND,\r\n  /** maximum intensity projection */\r\n  MAXIMUM_INTENSITY_BLEND = BlendMode.MAXIMUM_INTENSITY_BLEND,\r\n  /** minimum intensity projection */\r\n  MINIMUM_INTENSITY_BLEND = BlendMode.MINIMUM_INTENSITY_BLEND,\r\n  /** average intensity projection */\r\n  AVERAGE_INTENSITY_BLEND = BlendMode.AVERAGE_INTENSITY_BLEND,\r\n}\r\n\r\nexport default BlendModes;\r\n","enum GeometryType {\r\n  CONTOUR = 'contour',\r\n  SURFACE = 'Surface',\r\n}\r\n\r\nexport default GeometryType;\r\n","/**\r\n * DynamicOperatorType enum for cornerstone-render which defines the operator to use for generateImageFromTimeData.\r\n * It can be either SUM, AVERAGE or SUBTRACT.\r\n */\r\nenum DynamicOperatorType {\r\n  /** For summing the time frames. */\r\n  SUM = 'SUM',\r\n  /** For averaging the time frames. */\r\n  AVERAGE = 'AVERAGE',\r\n  /** For subtracting two time frames */\r\n  SUBTRACT = 'SUBTRACT',\r\n}\r\n\r\nexport default DynamicOperatorType;\r\n","/**\r\n * Defines the calibration types available.  These define how the units\r\n * for measurements are specified.\r\n */\r\nexport enum CalibrationTypes {\r\n  /**\r\n   * Not applicable means the units are directly defind by the underlying\r\n   * hardware, such as CT and MR volumetric displays, so no special handling\r\n   * or notification is required.\r\n   */\r\n  NOT_APPLICABLE = '',\r\n  /**\r\n   * ERMF is estimated radiographic magnification factor.  This defines how\r\n   * much the image is magnified at the detector as opposed to the location in\r\n   * the body of interest.  This occurs because the radiation beam is expanding\r\n   * and effectively magnifies the image on the detector compared to where the\r\n   * point of interest in the body is.\r\n   * This suggests that measurements can be partially trusted, but the user\r\n   * still needs to be aware that different depths within the body have differing\r\n   * ERMF values, so precise measurements would still need to be manually calibrated.\r\n   */\r\n  ERMF = 'ERMF',\r\n  /**\r\n   * User calibration means that the user has provided a custom calibration\r\n   * specifying how large the image data is.  This type can occur on\r\n   * volumetric images, eg for scout images that might have invalid spacing\r\n   * tags.\r\n   */\r\n  USER = 'User',\r\n  /**\r\n   * A projection calibration means the raw detector size, without any\r\n   * ERMF applied, meaning that the size in the body cannot be trusted and\r\n   * that a calibration should be applied.\r\n   * This is different from Error in that there is simply no magnification\r\n   * factor applied as opposed to having multiple, inconsistent magnification\r\n   * factors.\r\n   */\r\n  PROJECTION = 'Proj',\r\n  /**\r\n   * A region calibration is used for other types of images, typically\r\n   * ultrasouunds where the distance in the image may mean something other than\r\n   * physical distance, such as mV or Hz or some other measurement values.\r\n   */\r\n  REGION = 'Region',\r\n  /**\r\n   * Error is used to define mismatches between various units, such as when\r\n   * there are two different ERMF values specified.  This is an indication to\r\n   * NOT trust the measurement values but to manually calibrate.\r\n   */\r\n  ERROR = 'Error',\r\n  /** Uncalibrated image */\r\n  UNCALIBRATED = 'Uncalibrated',\r\n}\r\n\r\nexport default CalibrationTypes;\r\n","import getRenderingEngine, {\r\n  getRenderingEngines,\r\n} from './RenderingEngine/getRenderingEngine';\r\nimport { IEnabledElement, IStackViewport, IVolumeViewport } from './types';\r\n\r\n/**\r\n * A convenience method to find an EnabledElement given a reference to its\r\n * associated element. Commonly used in code that's handling a custom\r\n * event emitted by this library.\r\n *\r\n * @example\r\n * Using the renderingEngine to find the enabled element:\r\n * ```javascript\r\n * const element = getRenderingEngine(renderingEngineId)\r\n *    .getViewport(viewportId)\r\n *    .element\r\n *\r\n * const enabledElement = getEnabledElement(element)\r\n * ```\r\n *\r\n * @example\r\n * Using a cornerstone event's \"element\"\r\n * ```javascript\r\n * // Our \"cornerstone events\" contain the source element, which is\r\n * // raised on the viewport's div element\r\n * const { element } = evt.detail\r\n * const enabledElement = getEnabledElement(element)\r\n * ```\r\n *\r\n * @param element - a reference to an EnabledElement/Viewport's div element\r\n * @returns the associated EnabledElement, or undefined if no matching EnabledElement\r\n * can be found\r\n */\r\nexport default function getEnabledElement(\r\n  element: HTMLDivElement | undefined\r\n): IEnabledElement | undefined {\r\n  if (!element) {\r\n    return;\r\n  }\r\n\r\n  const { viewportUid, renderingEngineUid } = element.dataset;\r\n\r\n  return getEnabledElementByIds(viewportUid, renderingEngineUid);\r\n}\r\n\r\n/**\r\n * Similar to {@link getEnabledElement}, but takes the IDs of the\r\n * renderingEngine and viewport as parameters to return the associated\r\n * EnabledElement.\r\n *\r\n * @param viewportId - The Id of the viewport\r\n * @param renderingEngineId - The Id of the rendering engine.\r\n * @returns The enabled element which is an object that contains the viewport, rendering\r\n * engine, viewport Id, rendering engine Id, and the Frame of Reference UID.\r\n */\r\nexport function getEnabledElementByIds(\r\n  viewportId: string,\r\n  renderingEngineId: string\r\n): IEnabledElement {\r\n  if (!renderingEngineId || !viewportId) {\r\n    return;\r\n  }\r\n\r\n  const renderingEngine = getRenderingEngine(renderingEngineId);\r\n\r\n  if (!renderingEngine || renderingEngine.hasBeenDestroyed) {\r\n    return;\r\n  }\r\n\r\n  const viewport = renderingEngine.getViewport(viewportId) as\r\n    | IStackViewport\r\n    | IVolumeViewport;\r\n\r\n  if (!viewport) {\r\n    return;\r\n  }\r\n\r\n  const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n\r\n  return {\r\n    viewport,\r\n    renderingEngine,\r\n    viewportId,\r\n    renderingEngineId,\r\n    FrameOfReferenceUID,\r\n  };\r\n}\r\n\r\n/**\r\n * Retrieves the enabled element by the specified viewport ID. it searches\r\n * through all the rendering engines to find the viewport with the specified\r\n *\r\n * @param viewportId - The ID of the viewport.\r\n * @returns The enabled element associated with the specified viewport ID.\r\n */\r\nexport function getEnabledElementByViewportId(viewportId: string) {\r\n  const renderingEngines = getRenderingEngines();\r\n\r\n  for (let i = 0; i < renderingEngines.length; i++) {\r\n    const renderingEngine = renderingEngines[i];\r\n    const viewport = renderingEngine.getViewport(viewportId);\r\n\r\n    if (viewport) {\r\n      return getEnabledElementByIds(viewportId, renderingEngine.id);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get all the enabled elements from all the rendering engines\r\n * @returns An array of enabled elements.\r\n */\r\nexport function getEnabledElements(): IEnabledElement[] {\r\n  const enabledElements = [];\r\n\r\n  const renderingEngines = getRenderingEngines();\r\n\r\n  renderingEngines.forEach((renderingEngine) => {\r\n    const viewports = renderingEngine.getViewports();\r\n\r\n    viewports.forEach(({ element }) => {\r\n      enabledElements.push(getEnabledElement(element));\r\n    });\r\n  });\r\n\r\n  return enabledElements;\r\n}\r\n","import cache from '../cache/cache';\r\nimport { ImageVolume } from '../cache';\r\nimport Events from '../enums/Events';\r\nimport eventTarget from '../eventTarget';\r\nimport {\r\n  genericMetadataProvider,\r\n  getBufferConfiguration,\r\n  triggerEvent,\r\n  uuidv4,\r\n} from '../utilities';\r\nimport {\r\n  IImage,\r\n  ImageLoaderFn,\r\n  IImageLoadObject,\r\n  EventTypes,\r\n  Point2,\r\n  Point3,\r\n  Mat3,\r\n  PixelDataTypedArrayString,\r\n  PixelDataTypedArray,\r\n} from '../types';\r\nimport imageLoadPoolManager from '../requestPool/imageLoadPoolManager';\r\nimport { metaData } from '../';\r\n\r\nexport interface ImageLoaderOptions {\r\n  priority: number;\r\n  requestType: string;\r\n  additionalDetails?: Record<string, unknown>;\r\n  ignoreCache?: boolean;\r\n}\r\n\r\ninterface DerivedImages {\r\n  imageIds: Array<string>;\r\n  promises: Array<Promise<IImage>>;\r\n}\r\n\r\ntype LocalImageOptions = {\r\n  scalarData?: PixelDataTypedArray;\r\n  targetBufferType?: PixelDataTypedArrayString;\r\n  dimensions?: Point2;\r\n  spacing?: Point3;\r\n  origin?: Point3;\r\n  direction?: Mat3;\r\n  /**\r\n   * Skip creation of the actual buffer object.\r\n   * In fact, this creates a very short buffer, as there are lots of places\r\n   * assuming a buffer exists.\r\n   * This can be used when there are alternative representations of the image data.\r\n   */\r\n  skipCreateBuffer?: boolean;\r\n  /**\r\n   * A method to call to update the image object when it gets added to the cache.\r\n   * This can be used to create alternative representations of the image data,\r\n   * such as a VoxelManager.\r\n   */\r\n  onCacheAdd?: (image: IImage) => void;\r\n};\r\n\r\ntype DerivedImageOptions = LocalImageOptions & {\r\n  imageId?: string;\r\n  targetBufferType?: PixelDataTypedArrayString;\r\n};\r\n\r\n/**\r\n * This module deals with ImageLoaders, loading images and caching images\r\n */\r\nconst imageLoaders = {};\r\nlet unknownImageLoader;\r\n\r\n/**\r\n * Loads an image using a registered Cornerstone Image Loader.\r\n *\r\n * The image loader that is used will be\r\n * determined by the image loader scheme matching against the imageId.\r\n *\r\n * @param imageId - A Cornerstone Image Object's imageId\r\n * @param Options - to be passed to the Image Loader\r\n *\r\n * @returns - An Object which can be used to act after an image is loaded or loading fails\r\n */\r\nfunction loadImageFromImageLoader(\r\n  imageId: string,\r\n  options: ImageLoaderOptions\r\n): IImageLoadObject {\r\n  // Extract the image loader scheme: wadors:https://image1 => wadors\r\n  const colonIndex = imageId.indexOf(':');\r\n  const scheme = imageId.substring(0, colonIndex);\r\n  const loader = imageLoaders[scheme];\r\n  if (loader === undefined || loader === null) {\r\n    if (unknownImageLoader !== undefined) {\r\n      return unknownImageLoader(imageId);\r\n    }\r\n    throw new Error('loadImageFromImageLoader: no image loader for imageId');\r\n  }\r\n  // Load using the registered loader\r\n  const imageLoadObject = loader(imageId, options);\r\n  // Broadcast an image loaded event once the image is loaded\r\n  imageLoadObject.promise.then(\r\n    function (image) {\r\n      triggerEvent(eventTarget, Events.IMAGE_LOADED, { image });\r\n    },\r\n    function (error) {\r\n      const errorObject: EventTypes.ImageLoadedFailedEventDetail = {\r\n        imageId,\r\n        error,\r\n      };\r\n      triggerEvent(eventTarget, Events.IMAGE_LOAD_FAILED, errorObject);\r\n    }\r\n  );\r\n  return imageLoadObject;\r\n}\r\n\r\n/**\r\n * Gets the imageLoadObject by 1) Looking in to the cache to see if the\r\n * imageLoadObject has already been cached, 2) Checks inside the volume cache\r\n * to see if there is a volume that contains the same imageURI for the requested\r\n * imageID 3) Checks inside the imageCache for similar imageURI that might have\r\n * been stored as a result of decaching a volume 4) Finally if none were found\r\n * it request it from the registered imageLoaders.\r\n *\r\n * @param imageId - A Cornerstone Image Object's imageId\r\n * @param options - Options to be passed to the Image Loader\r\n *\r\n * @returns An Object which can be used to act after an image is loaded or loading fails\r\n */\r\nfunction loadImageFromCacheOrVolume(\r\n  imageId: string,\r\n  options: ImageLoaderOptions\r\n): IImageLoadObject {\r\n  if (options.ignoreCache) {\r\n    return loadImageFromImageLoader(imageId, options);\r\n  }\r\n\r\n  // 1. Check inside the image cache for imageId\r\n  let imageLoadObject = cache.getImageLoadObject(imageId);\r\n  if (imageLoadObject !== undefined) {\r\n    return imageLoadObject;\r\n  }\r\n  // 2. Check if there exists a volume in the cache containing the imageId,\r\n  // we copy the pixelData over.\r\n  const cachedVolumeInfo = cache.getVolumeContainingImageId(imageId);\r\n  if (cachedVolumeInfo?.volume?.loadStatus?.loaded) {\r\n    // 2.1 Convert the volume at the specific slice to a cornerstoneImage object.\r\n    // this will copy the pixel data over.\r\n    const { volume, imageIdIndex } = cachedVolumeInfo;\r\n\r\n    if (volume instanceof ImageVolume) {\r\n      imageLoadObject = volume.convertToCornerstoneImage(imageId, imageIdIndex);\r\n    }\r\n    return imageLoadObject;\r\n  }\r\n  // 3. If no volume found, we search inside the imageCache for the imageId\r\n  // that has the same URI which had been cached if the volume was converted\r\n  // to an image\r\n  const cachedImage = cache.getCachedImageBasedOnImageURI(imageId);\r\n  if (cachedImage) {\r\n    imageLoadObject = cachedImage.imageLoadObject;\r\n    return imageLoadObject;\r\n  }\r\n  // 4. if not in image cache nor inside the volume cache, we request the\r\n  // image loaders to load it\r\n  imageLoadObject = loadImageFromImageLoader(imageId, options);\r\n\r\n  return imageLoadObject;\r\n}\r\n\r\n/**\r\n * Loads an image given an imageId and optional priority and returns a promise\r\n * which will resolve to the loaded image object or fail if an error occurred.\r\n * The loaded image is not stored in the cache.\r\n *\r\n *\r\n * @param imageId - A Cornerstone Image Object's imageId\r\n * @param options - Options to be passed to the Image Loader\r\n *\r\n * @returns An Object which can be used to act after an image is loaded or loading fails\r\n */\r\nexport function loadImage(\r\n  imageId: string,\r\n  options: ImageLoaderOptions = { priority: 0, requestType: 'prefetch' }\r\n): Promise<IImage> {\r\n  if (imageId === undefined) {\r\n    throw new Error('loadImage: parameter imageId must not be undefined');\r\n  }\r\n\r\n  return loadImageFromCacheOrVolume(imageId, options).promise;\r\n}\r\n\r\n/**\r\n * Loads an image given an imageId and optional priority and returns a promise\r\n * which will resolve to the loaded image object or fail if an error occurred.\r\n * The image is stored in the cache.\r\n *\r\n * @param imageId -  A Cornerstone Image Object's imageId\r\n * @param options - Options to be passed to the Image Loader\r\n *\r\n * @returns Image Loader Object\r\n */\r\nexport function loadAndCacheImage(\r\n  imageId: string,\r\n  options: ImageLoaderOptions = { priority: 0, requestType: 'prefetch' }\r\n): Promise<IImage> {\r\n  if (imageId === undefined) {\r\n    throw new Error(\r\n      'loadAndCacheImage: parameter imageId must not be undefined'\r\n    );\r\n  }\r\n\r\n  // console.log('LOAD AND CACHE IMAGE', imageId, options)\r\n  const imageLoadObject = loadImageFromCacheOrVolume(imageId, options);\r\n  // if(imageId.includes('pngfile')) console.log(`IMAGE LOAD OBJECT ${imageId} :`, imageLoadObject)\r\n\r\n  // if not inside cache, store it\r\n  if (!cache.getImageLoadObject(imageId)) {\r\n    cache.putImageLoadObject(imageId, imageLoadObject).catch((err) => {\r\n      console.warn(err);\r\n    });\r\n  }\r\n\r\n  return imageLoadObject.promise;\r\n}\r\n\r\n/**\r\n * Load and cache a list of imageIds\r\n *\r\n * @param imageIds - list of imageIds\r\n * @param options - options for loader\r\n *\r\n */\r\nexport function loadAndCacheImages(\r\n  imageIds: Array<string>,\r\n  options: ImageLoaderOptions = { priority: 0, requestType: 'prefetch' }\r\n): Promise<IImage>[] {\r\n  if (!imageIds || imageIds.length === 0) {\r\n    throw new Error(\r\n      'loadAndCacheImages: parameter imageIds must be list of image Ids'\r\n    );\r\n  }\r\n\r\n  const allPromises = imageIds.map((imageId) => {\r\n    return loadAndCacheImage(imageId, options);\r\n  });\r\n\r\n  return allPromises;\r\n}\r\n\r\n/**\r\n * Loads an image given an imageId and optional priority and returns a promise\r\n * which will resolve to the loaded image object or fail if an error occurred.\r\n * The image is stored in the cache.\r\n *\r\n * @param referencedImageId -  A Cornerstone Image Object's imageId\r\n * @param options - Options to be passed to the Image Loader\r\n *\r\n * @returns Image Loader Object\r\n */\r\nexport function createAndCacheDerivedImage(\r\n  referencedImageId: string,\r\n  options: DerivedImageOptions = {},\r\n  preventCache = false\r\n): Promise<IImage> {\r\n  if (referencedImageId === undefined) {\r\n    throw new Error(\r\n      'createAndCacheDerivedImage: parameter imageId must not be undefined'\r\n    );\r\n  }\r\n\r\n  if (options.imageId === undefined) {\r\n    options.imageId = `derived:${uuidv4()}`;\r\n  }\r\n\r\n  const { imageId, skipCreateBuffer, onCacheAdd } = options;\r\n\r\n  const imagePlaneModule = metaData.get('imagePlaneModule', referencedImageId);\r\n\r\n  const length = imagePlaneModule.rows * imagePlaneModule.columns;\r\n\r\n  const { TypedArrayConstructor } = getBufferConfiguration(\r\n    options.targetBufferType,\r\n    length\r\n  );\r\n\r\n  // Use a buffer of size 1 for no data\r\n  const imageScalarData = new TypedArrayConstructor(\r\n    skipCreateBuffer ? 1 : length\r\n  );\r\n  const derivedImageId = imageId;\r\n\r\n  ['imagePlaneModule', 'generalSeriesModule'].forEach((type) => {\r\n    genericMetadataProvider.add(derivedImageId, {\r\n      type,\r\n      metadata: metaData.get(type, referencedImageId),\r\n    });\r\n  });\r\n\r\n  const imagePixelModule = metaData.get('imagePixelModule', referencedImageId);\r\n  // TODO - add a general way to specify this\r\n  genericMetadataProvider.add(derivedImageId, {\r\n    type: 'imagePixelModule',\r\n    metadata: {\r\n      ...imagePixelModule,\r\n      bitsAllocated: 8,\r\n      bitsStored: 8,\r\n      highBit: 7,\r\n      samplesPerPixel: 1,\r\n      pixelRepresentation: 0,\r\n    },\r\n  });\r\n\r\n  const localImage = createAndCacheLocalImage(\r\n    { scalarData: imageScalarData, onCacheAdd, skipCreateBuffer },\r\n    imageId,\r\n    true\r\n  );\r\n\r\n  const imageLoadObject = {\r\n    promise: Promise.resolve(localImage),\r\n  };\r\n\r\n  if (!preventCache) {\r\n    cache.putImageLoadObject(derivedImageId, imageLoadObject);\r\n  }\r\n  return imageLoadObject.promise;\r\n}\r\n\r\n/**\r\n * Load and cache a list of imageIds\r\n *\r\n * @param referencedImageIds - list of imageIds\r\n * @param options\r\n * @param options.getDerivedImageId - function to get the derived imageId\r\n * @param options.targetBufferType - target buffer type\r\n * @param options.skipBufferCreate - avoid creating the buffer\r\n */\r\nexport function createAndCacheDerivedImages(\r\n  referencedImageIds: Array<string>,\r\n  options: DerivedImageOptions & {\r\n    getDerivedImageId?: (referencedImageId: string) => string;\r\n    targetBufferType?: PixelDataTypedArrayString;\r\n  } = {}\r\n): DerivedImages {\r\n  if (referencedImageIds?.length === 0) {\r\n    throw new Error(\r\n      'createAndCacheDerivedImages: parameter imageIds must be list of image Ids'\r\n    );\r\n  }\r\n\r\n  const derivedImageIds = [];\r\n  const allPromises = referencedImageIds.map((referencedImageId) => {\r\n    const newOptions: DerivedImageOptions = {\r\n      imageId:\r\n        options.getDerivedImageId?.(referencedImageId) || `derived:${uuidv4()}`,\r\n      ...options,\r\n    };\r\n    derivedImageIds.push(newOptions.imageId);\r\n    return createAndCacheDerivedImage(referencedImageId, newOptions);\r\n  });\r\n\r\n  return { imageIds: derivedImageIds, promises: allPromises };\r\n}\r\n\r\nexport function createAndCacheLocalImage(\r\n  options: LocalImageOptions,\r\n  imageId: string,\r\n  preventCache = false\r\n): IImage {\r\n  const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\r\n\r\n  const length = imagePlaneModule.rows * imagePlaneModule.columns;\r\n\r\n  const image = {\r\n    imageId: imageId,\r\n    intercept: 0,\r\n    windowCenter: 0,\r\n    windowWidth: 0,\r\n    color: false,\r\n    numComps: 1,\r\n    slope: 1,\r\n    minPixelValue: 0,\r\n    maxPixelValue: 255,\r\n    voiLUTFunction: undefined,\r\n    rows: imagePlaneModule.rows,\r\n    columns: imagePlaneModule.columns,\r\n    getCanvas: undefined, // todo: which canvas?\r\n    height: imagePlaneModule.rows,\r\n    width: imagePlaneModule.columns,\r\n    rgba: undefined, // todo: how\r\n    columnPixelSpacing: imagePlaneModule.columnPixelSpacing,\r\n    rowPixelSpacing: imagePlaneModule.rowPixelSpacing,\r\n    invert: false,\r\n  } as IImage;\r\n\r\n  if (options.scalarData) {\r\n    const imageScalarData = options.scalarData;\r\n\r\n    if (\r\n      !(\r\n        imageScalarData instanceof Uint8Array ||\r\n        imageScalarData instanceof Float32Array ||\r\n        imageScalarData instanceof Uint16Array ||\r\n        imageScalarData instanceof Int16Array\r\n      )\r\n    ) {\r\n      throw new Error(\r\n        'To use createLocalVolume you should pass scalarData of type Uint8Array, Uint16Array, Int16Array or Float32Array'\r\n      );\r\n    }\r\n\r\n    image.sizeInBytes = imageScalarData.byteLength;\r\n    image.getPixelData = () => imageScalarData;\r\n  } else if (options.skipCreateBuffer !== true) {\r\n    const { numBytes, TypedArrayConstructor } = getBufferConfiguration(\r\n      options.targetBufferType,\r\n      length\r\n    );\r\n\r\n    const imageScalarData = new TypedArrayConstructor(length);\r\n\r\n    image.sizeInBytes = numBytes;\r\n    image.getPixelData = () => imageScalarData;\r\n  }\r\n\r\n  // The onCacheAdd may modify the size in bytes for this image, which is ok,\r\n  // as this is used after resolution for cache storage.  It may also do\r\n  // thinks like adding alternative representations such as VoxelManager\r\n  options.onCacheAdd?.(image);\r\n\r\n  const imageLoadObject = {\r\n    promise: Promise.resolve(image),\r\n  };\r\n\r\n  if (!preventCache) {\r\n    cache.putImageLoadObject(image.imageId, imageLoadObject);\r\n  }\r\n\r\n  return image;\r\n}\r\n\r\n/**\r\n * Removes the imageId from the request pool manager and executes the `cancel`\r\n * function if it exists.\r\n *\r\n * @param imageId - A Cornerstone Image Object's imageId\r\n *\r\n */\r\nexport function cancelLoadImage(imageId: string): void {\r\n  const filterFunction = ({ additionalDetails }) => {\r\n    if (additionalDetails.imageId) {\r\n      return additionalDetails.imageId !== imageId;\r\n    }\r\n\r\n    // for volumes\r\n    return true;\r\n  };\r\n\r\n  // Instruct the request pool manager to filter queued\r\n  // requests to ensure requests we no longer need are\r\n  // no longer sent.\r\n  imageLoadPoolManager.filterRequests(filterFunction);\r\n\r\n  // TODO: Cancel decoding and retrieval as well (somehow?)\r\n\r\n  // cancel image loading if in progress\r\n  const imageLoadObject = cache.getImageLoadObject(imageId);\r\n\r\n  if (imageLoadObject) {\r\n    imageLoadObject.cancelFn();\r\n  }\r\n}\r\n\r\n/**\r\n * Removes the imageIds from the request pool manager and calls the `cancel`\r\n * function if it exists.\r\n *\r\n * @param imageIds - Array of Cornerstone Image Object's imageIds\r\n *\r\n */\r\nexport function cancelLoadImages(imageIds: Array<string>): void {\r\n  imageIds.forEach((imageId) => cancelLoadImage(imageId));\r\n}\r\n\r\n/**\r\n * Removes all the ongoing image loads by calling the `cancel` method on each\r\n * imageLoadObject. If no `cancel` method is available, it will be ignored.\r\n *\r\n */\r\nexport function cancelLoadAll(): void {\r\n  const requestPool = imageLoadPoolManager.getRequestPool();\r\n\r\n  Object.keys(requestPool).forEach((type: string) => {\r\n    const requests = requestPool[type];\r\n\r\n    Object.keys(requests).forEach((priority) => {\r\n      const requestDetails = requests[priority].pop();\r\n      const additionalDetails = requestDetails.additionalDetails as any;\r\n      const { imageId, volumeId } = additionalDetails;\r\n\r\n      let loadObject;\r\n\r\n      if (imageId) {\r\n        loadObject = cache.getImageLoadObject(imageId);\r\n      } else if (volumeId) {\r\n        loadObject = cache.getVolumeLoadObject(volumeId);\r\n      }\r\n      if (loadObject) {\r\n        loadObject.cancel();\r\n      }\r\n    });\r\n    // resetting the pool types to be empty\r\n    imageLoadPoolManager.clearRequestStack(type);\r\n\r\n    // TODO: Clear retrieval and decoding queues as well\r\n  });\r\n}\r\n\r\n/**\r\n * Registers an imageLoader plugin with cornerstone for the specified scheme\r\n *\r\n * @param scheme - The scheme to use for this image loader (e.g. 'dicomweb', 'wadouri', 'http')\r\n * @param imageLoader - A Cornerstone Image Loader function\r\n */\r\nexport function registerImageLoader(\r\n  scheme: string,\r\n  imageLoader: ImageLoaderFn\r\n): void {\r\n  imageLoaders[scheme] = imageLoader;\r\n}\r\n/**\r\n * Registers a new unknownImageLoader and returns the previous one\r\n *\r\n * @param imageLoader - A Cornerstone Image Loader\r\n *\r\n * @returns The previous Unknown Image Loader\r\n */\r\nexport function registerUnknownImageLoader(\r\n  imageLoader: ImageLoaderFn\r\n): ImageLoaderFn {\r\n  const oldImageLoader = unknownImageLoader;\r\n  unknownImageLoader = imageLoader;\r\n  return oldImageLoader;\r\n}\r\n/**\r\n * Removes all registered and unknown image loaders. This should be called\r\n * when the application is unmounted to prevent memory leaks.\r\n *\r\n */\r\nexport function unregisterAllImageLoaders(): void {\r\n  Object.keys(imageLoaders).forEach(\r\n    (imageLoader) => delete imageLoaders[imageLoader]\r\n  );\r\n  unknownImageLoader = undefined;\r\n}\r\n\r\n/**\r\n * Creates and caches derived segmentation images based on the referenced imageIds, this\r\n * is a helper function, we don't have segmentation concept in the cornerstone core; however,\r\n * this helper would make it clear that the segmentation images SHOULD be Uint8Array type\r\n * always until we have a better solution.\r\n *\r\n * @param referencedImageIds - An array of referenced image IDs.\r\n * @param options - The options for creating the derived images (default: { targetBufferType: 'Uint8Array' }).\r\n * @returns The derived images.\r\n */\r\nexport function createAndCacheDerivedSegmentationImages(\r\n  referencedImageIds: Array<string>,\r\n  options: DerivedImageOptions = {\r\n    targetBufferType: 'Uint8Array',\r\n  }\r\n): DerivedImages {\r\n  return createAndCacheDerivedImages(referencedImageIds, options);\r\n}\r\n\r\n/**\r\n * Creates and caches a derived segmentation image based on the referenced image ID.\r\n * this is a helper function, we don't have segmentation concept in the cornerstone core; however,\r\n * this helper would make it clear that the segmentation images SHOULD be Uint8Array type\r\n * always until we have a better solution.\r\n *\r\n * @param referencedImageId The ID of the referenced image.\r\n * @param options The options for creating the derived image (default: { targetBufferType: 'Uint8Array' }).\r\n * @returns A promise that resolves to the created derived segmentation image.\r\n */\r\nexport function createAndCacheDerivedSegmentationImage(\r\n  referencedImageId: string,\r\n  options: DerivedImageOptions = {\r\n    targetBufferType: 'Uint8Array',\r\n  }\r\n): Promise<IImage> {\r\n  return createAndCacheDerivedImage(referencedImageId, options);\r\n}\r\n","import '@kitware/vtk.js/Rendering/Profiles/Volume';\r\n\r\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\r\nimport type { vtkImageData as vtkImageDataType } from '@kitware/vtk.js/Common/DataModel/ImageData';\r\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\r\n\r\nimport { ImageVolume } from '../cache/classes/ImageVolume';\r\nimport cache from '../cache/cache';\r\nimport Events from '../enums/Events';\r\nimport eventTarget from '../eventTarget';\r\nimport triggerEvent from '../utilities/triggerEvent';\r\nimport cloneDeep from 'lodash.clonedeep';\r\n\r\nimport {\r\n  createUint16SharedArray,\r\n  createUint8SharedArray,\r\n  createFloat32SharedArray,\r\n  generateVolumePropsFromImageIds,\r\n  getBufferConfiguration,\r\n  uuidv4,\r\n} from '../utilities';\r\nimport {\r\n  Point3,\r\n  Metadata,\r\n  EventTypes,\r\n  Mat3,\r\n  IImageVolume,\r\n  VolumeLoaderFn,\r\n  IDynamicImageVolume,\r\n  PixelDataTypedArray,\r\n  IVolumeLoadObject,\r\n  PixelDataTypedArrayString,\r\n} from '../types';\r\nimport { getConfiguration, getShouldUseSharedArrayBuffer } from '../init';\r\nimport {\r\n  performCacheOptimizationForVolume,\r\n  setupCacheOptimizationEventListener,\r\n} from '../utilities/cacheUtils';\r\n\r\ninterface VolumeLoaderOptions {\r\n  imageIds: Array<string>;\r\n}\r\n\r\ninterface DerivedVolumeOptions {\r\n  volumeId: string;\r\n  targetBuffer?: {\r\n    type: PixelDataTypedArrayString;\r\n    sharedArrayBuffer?: boolean;\r\n  };\r\n}\r\ninterface LocalVolumeOptions {\r\n  metadata: Metadata;\r\n  dimensions: Point3;\r\n  spacing: Point3;\r\n  origin: Point3;\r\n  direction: Mat3;\r\n  scalarData?: PixelDataTypedArray;\r\n  imageIds?: Array<string>;\r\n  referencedImageIds?: Array<string>;\r\n  referencedVolumeId?: string;\r\n  targetBuffer?: {\r\n    type: PixelDataTypedArrayString;\r\n    sharedArrayBuffer?: boolean;\r\n  };\r\n}\r\n\r\n/**\r\n * Adds a single scalar data to a 3D volume\r\n */\r\nfunction addScalarDataToImageData(\r\n  imageData: vtkImageDataType,\r\n  scalarData: PixelDataTypedArray,\r\n  dataArrayAttrs\r\n) {\r\n  const scalarArray = vtkDataArray.newInstance({\r\n    name: `Pixels`,\r\n    values: scalarData,\r\n    ...dataArrayAttrs,\r\n  });\r\n\r\n  imageData.getPointData().setScalars(scalarArray);\r\n}\r\n\r\n/**\r\n * Adds multiple scalar data (time points) to a 4D volume\r\n */\r\nfunction addScalarDataArraysToImageData(\r\n  imageData: vtkImageDataType,\r\n  scalarDataArrays: PixelDataTypedArray[],\r\n  dataArrayAttrs\r\n) {\r\n  scalarDataArrays.forEach((scalarData, i) => {\r\n    const vtkScalarArray = vtkDataArray.newInstance({\r\n      name: `timePoint-${i}`,\r\n      values: scalarData,\r\n      ...dataArrayAttrs,\r\n    });\r\n\r\n    imageData.getPointData().addArray(vtkScalarArray);\r\n  });\r\n\r\n  // Set the first as active otherwise nothing is displayed on the screen\r\n  imageData.getPointData().setActiveScalars('timePoint-0');\r\n}\r\n\r\nfunction createInternalVTKRepresentation(\r\n  volume: IImageVolume\r\n): vtkImageDataType {\r\n  const { dimensions, metadata, spacing, direction, origin } = volume;\r\n  const { PhotometricInterpretation } = metadata;\r\n\r\n  let numComponents = 1;\r\n  if (PhotometricInterpretation === 'RGB') {\r\n    numComponents = 3;\r\n  }\r\n\r\n  const imageData = vtkImageData.newInstance();\r\n  const dataArrayAttrs = { numberOfComponents: numComponents };\r\n\r\n  imageData.setDimensions(dimensions);\r\n  imageData.setSpacing(spacing);\r\n  imageData.setDirection(direction);\r\n  imageData.setOrigin(origin);\r\n\r\n  // Add scalar data to 3D or 4D volume\r\n  if (volume.isDynamicVolume()) {\r\n    const scalarDataArrays = (<IDynamicImageVolume>(\r\n      volume\r\n    )).getScalarDataArrays();\r\n\r\n    addScalarDataArraysToImageData(imageData, scalarDataArrays, dataArrayAttrs);\r\n  } else {\r\n    const scalarData = volume.getScalarData();\r\n\r\n    addScalarDataToImageData(imageData, scalarData, dataArrayAttrs);\r\n  }\r\n\r\n  return imageData;\r\n}\r\n\r\n/**\r\n * This module deals with VolumeLoaders and loading volumes\r\n */\r\n\r\nconst volumeLoaders = {};\r\n\r\nlet unknownVolumeLoader;\r\n\r\n/**\r\n * Load a volume using a registered Cornerstone Volume Loader.\r\n *\r\n * The volume loader that is used will be\r\n * determined by the volume loader scheme matching against the volumeId.\r\n *\r\n * @param volumeId - A Cornerstone Volume Object's volumeId\r\n * @param options - Options to be passed to the Volume Loader. Options\r\n * contain the ImageIds that is passed to the loader\r\n *\r\n * @returns An Object which can be used to act after a volume is loaded or loading fails\r\n *\r\n */\r\nfunction loadVolumeFromVolumeLoader(\r\n  volumeId: string,\r\n  options?: VolumeLoaderOptions\r\n): IVolumeLoadObject {\r\n  const colonIndex = volumeId.indexOf(':');\r\n  const scheme = volumeId.substring(0, colonIndex);\r\n  let loader = volumeLoaders[scheme];\r\n\r\n  if (loader === undefined || loader === null) {\r\n    if (\r\n      unknownVolumeLoader == null ||\r\n      typeof unknownVolumeLoader !== 'function'\r\n    ) {\r\n      throw new Error(\r\n        `No volume loader for scheme ${scheme} has been registered`\r\n      );\r\n    }\r\n\r\n    loader = unknownVolumeLoader;\r\n  }\r\n\r\n  const volumeLoadObject = loader(volumeId, options);\r\n\r\n  setupCacheOptimizationEventListener(volumeId);\r\n\r\n  // Broadcast a volume loaded event once the image is loaded\r\n  volumeLoadObject.promise.then(\r\n    function (volume) {\r\n      triggerEvent(eventTarget, Events.VOLUME_LOADED, { volume });\r\n    },\r\n    function (error) {\r\n      const errorObject: EventTypes.VolumeLoadedFailedEventDetail = {\r\n        volumeId,\r\n        error,\r\n      };\r\n\r\n      triggerEvent(eventTarget, Events.VOLUME_LOADED_FAILED, errorObject);\r\n    }\r\n  );\r\n\r\n  return volumeLoadObject;\r\n}\r\n\r\n/**\r\n * Loads a volume given a volumeId and optional priority and returns a promise which will resolve to\r\n * the loaded image object or fail if an error occurred.  The loaded image is not stored in the cache.\r\n *\r\n * @param volumeId - A Cornerstone Image Object's volumeId\r\n * @param options - Options to be passed to the Volume Loader\r\n *\r\n * @returns An Object which can be used to act after an image is loaded or loading fails\r\n */\r\nexport function loadVolume(\r\n  volumeId: string,\r\n  options: VolumeLoaderOptions = { imageIds: [] }\r\n): Promise<IImageVolume> {\r\n  if (volumeId === undefined) {\r\n    throw new Error('loadVolume: parameter volumeId must not be undefined');\r\n  }\r\n\r\n  let volumeLoadObject = cache.getVolumeLoadObject(volumeId);\r\n\r\n  if (volumeLoadObject !== undefined) {\r\n    return volumeLoadObject.promise;\r\n  }\r\n\r\n  volumeLoadObject = loadVolumeFromVolumeLoader(volumeId, options);\r\n\r\n  return volumeLoadObject.promise.then((volume: IImageVolume) => {\r\n    volume.imageData = createInternalVTKRepresentation(volume);\r\n    return volume;\r\n  });\r\n}\r\n\r\n/**\r\n * Loads an image given an volumeId and optional priority and returns a promise which will resolve to\r\n * the loaded image object or fail if an error occurred. The image is stored in the cache.\r\n *\r\n * @param volumeId - A Cornerstone Image Object's volumeId\r\n * @param options - Options to be passed to the Volume Loader\r\n *\r\n * @returns Volume Loader Object\r\n */\r\nexport async function createAndCacheVolume(\r\n  volumeId: string,\r\n  options?: VolumeLoaderOptions\r\n): Promise<Record<string, any>> {\r\n  if (volumeId === undefined) {\r\n    throw new Error(\r\n      'createAndCacheVolume: parameter volumeId must not be undefined'\r\n    );\r\n  }\r\n\r\n  let volumeLoadObject = cache.getVolumeLoadObject(volumeId);\r\n\r\n  if (volumeLoadObject !== undefined) {\r\n    return volumeLoadObject.promise;\r\n  }\r\n\r\n  volumeLoadObject = loadVolumeFromVolumeLoader(volumeId, options);\r\n\r\n  volumeLoadObject.promise.then((volume: IImageVolume) => {\r\n    volume.imageData = createInternalVTKRepresentation(volume);\r\n  });\r\n\r\n  cache.putVolumeLoadObject(volumeId, volumeLoadObject).catch((err) => {\r\n    throw err;\r\n  });\r\n\r\n  return volumeLoadObject.promise;\r\n}\r\n\r\n/**\r\n * Based on a referencedVolumeId, it will build and cache a new volume. If\r\n * no scalarData is specified in the options, an empty derived volume will be\r\n * created that matches the image metadata of the referenceVolume. If scalarData\r\n * is given, it will be used to generate the intensity values for the derivedVolume.\r\n * Finally, it will save the volume in the cache.\r\n * @param referencedVolumeId - the volumeId from which the new volume will get its metadata\r\n * @param options - DerivedVolumeOptions {uid: derivedVolumeUID, targetBuffer: { type: Float32Array | Uint8Array |\r\n * Uint16Array | Uint32Array  }, scalarData: if provided}\r\n *\r\n * @returns ImageVolume\r\n */\r\nexport async function createAndCacheDerivedVolume(\r\n  referencedVolumeId: string,\r\n  options: DerivedVolumeOptions\r\n): Promise<IImageVolume> {\r\n  const referencedVolume = cache.getVolume(referencedVolumeId);\r\n  if (!referencedVolume) {\r\n    throw new Error(\r\n      `Cannot created derived volume: Referenced volume with id ${referencedVolumeId} does not exist.`\r\n    );\r\n  }\r\n\r\n  let { volumeId } = options;\r\n  const { targetBuffer } = options;\r\n\r\n  if (volumeId === undefined) {\r\n    volumeId = uuidv4();\r\n  }\r\n\r\n  const { metadata, dimensions, spacing, origin, direction } = referencedVolume;\r\n  const scalarData = referencedVolume.getScalarData();\r\n  const scalarLength = scalarData.length;\r\n\r\n  const { volumeScalarData, numBytes } = generateVolumeScalarData(\r\n    targetBuffer,\r\n    scalarLength\r\n  );\r\n\r\n  // Todo: handle more than one component for segmentation (RGB)\r\n  const scalarArray = vtkDataArray.newInstance({\r\n    name: 'Pixels',\r\n    numberOfComponents: 1,\r\n    values: volumeScalarData,\r\n  });\r\n\r\n  const derivedImageData = vtkImageData.newInstance();\r\n\r\n  derivedImageData.setDimensions(dimensions);\r\n  derivedImageData.setSpacing(spacing);\r\n  derivedImageData.setDirection(direction);\r\n  derivedImageData.setOrigin(origin);\r\n  derivedImageData.getPointData().setScalars(scalarArray);\r\n\r\n  const derivedVolume = new ImageVolume({\r\n    volumeId,\r\n    metadata: cloneDeep(metadata),\r\n    dimensions: [dimensions[0], dimensions[1], dimensions[2]],\r\n    spacing,\r\n    origin,\r\n    direction,\r\n    imageData: derivedImageData,\r\n    scalarData: volumeScalarData,\r\n    sizeInBytes: numBytes,\r\n    imageIds: [],\r\n    referencedVolumeId,\r\n  });\r\n\r\n  const volumeLoadObject = {\r\n    promise: Promise.resolve(derivedVolume),\r\n  };\r\n\r\n  await cache.putVolumeLoadObject(volumeId, volumeLoadObject);\r\n\r\n  return derivedVolume;\r\n}\r\n\r\n/**\r\n * Creates and cache a volume based on a set of provided properties including\r\n * dimensions, spacing, origin, direction, metadata, scalarData. It should be noted that\r\n * scalarData should be provided for this function to work. If a volume with the same\r\n * Id exists in the cache it returns it immediately.\r\n * @param options -  { scalarData, metadata, dimensions, spacing, origin, direction }\r\n * @param volumeId - Id of the generated volume\r\n *\r\n * @returns ImageVolume\r\n */\r\nexport function createLocalVolume(\r\n  options: LocalVolumeOptions,\r\n  volumeId: string,\r\n  preventCache = false\r\n): IImageVolume {\r\n  const { metadata, dimensions, spacing, origin, direction, targetBuffer } =\r\n    options;\r\n\r\n  let { scalarData } = options;\r\n\r\n  // Define the valid data types for scalarData\r\n  const validDataTypes = [\r\n    'Uint8Array',\r\n    'Float32Array',\r\n    'Uint16Array',\r\n    'Int16Array',\r\n  ];\r\n\r\n  const scalarLength = dimensions[0] * dimensions[1] * dimensions[2];\r\n\r\n  // Check if scalarData is provided and is of a valid type\r\n  if (!scalarData || !validDataTypes.includes(scalarData.constructor.name)) {\r\n    // Check if targetBuffer is provided and has a valid type\r\n    if (!targetBuffer?.type || !validDataTypes.includes(targetBuffer.type)) {\r\n      throw new Error(\r\n        'createLocalVolume: parameter scalarData must be provided and must be either Uint8Array, Float32Array, Uint16Array or Int16Array'\r\n      );\r\n    }\r\n\r\n    // Generate volume scalar data if scalarData is not provided or invalid\r\n    ({ volumeScalarData: scalarData } = generateVolumeScalarData(\r\n      targetBuffer,\r\n      scalarLength\r\n    ));\r\n  }\r\n\r\n  // Todo: handle default values for spacing, origin, direction if not provided\r\n  if (volumeId === undefined) {\r\n    volumeId = uuidv4();\r\n  }\r\n\r\n  const cachedVolume = cache.getVolume(volumeId);\r\n\r\n  if (cachedVolume) {\r\n    return cachedVolume as IImageVolume;\r\n  }\r\n\r\n  const numBytes = scalarData ? scalarData.buffer.byteLength : scalarLength * 4;\r\n\r\n  // check if there is enough space in unallocated + image Cache\r\n  const isCacheable = cache.isCacheable(numBytes);\r\n  if (!isCacheable) {\r\n    throw new Error(Events.CACHE_SIZE_EXCEEDED);\r\n  }\r\n\r\n  const scalarArray = vtkDataArray.newInstance({\r\n    name: 'Pixels',\r\n    numberOfComponents: 1,\r\n    values: scalarData,\r\n  });\r\n\r\n  const imageData = vtkImageData.newInstance();\r\n\r\n  imageData.setDimensions(dimensions);\r\n  imageData.setSpacing(spacing);\r\n  imageData.setDirection(direction);\r\n  imageData.setOrigin(origin);\r\n  imageData.getPointData().setScalars(scalarArray);\r\n\r\n  const derivedVolume = new ImageVolume({\r\n    volumeId,\r\n    metadata: cloneDeep(metadata),\r\n    dimensions: [dimensions[0], dimensions[1], dimensions[2]],\r\n    spacing,\r\n    origin,\r\n    direction,\r\n    imageData: imageData,\r\n    scalarData,\r\n    sizeInBytes: numBytes,\r\n    referencedImageIds: options.referencedImageIds || [],\r\n    referencedVolumeId: options.referencedVolumeId,\r\n    imageIds: options.imageIds || [],\r\n  });\r\n\r\n  if (preventCache) {\r\n    return derivedVolume;\r\n  }\r\n\r\n  const volumeLoadObject = {\r\n    promise: Promise.resolve(derivedVolume),\r\n  };\r\n  cache.putVolumeLoadObject(volumeId, volumeLoadObject);\r\n\r\n  return derivedVolume;\r\n}\r\n\r\nexport async function createAndCacheVolumeFromImages(\r\n  volumeId: string,\r\n  imageIds: string[],\r\n  options: {\r\n    preventCache?: boolean;\r\n    additionalDetails?: Record<string, any>;\r\n  } = {}\r\n): Promise<IImageVolume> {\r\n  const { preventCache = false } = options;\r\n\r\n  if (imageIds === undefined) {\r\n    throw new Error(\r\n      'createAndCacheVolumeFromImages: parameter imageIds must not be undefined'\r\n    );\r\n  }\r\n\r\n  if (volumeId === undefined) {\r\n    throw new Error(\r\n      'createAndCacheVolumeFromImages: parameter volumeId must not be undefined'\r\n    );\r\n  }\r\n\r\n  const cachedVolume = cache.getVolume(volumeId);\r\n\r\n  if (cachedVolume) {\r\n    return Promise.resolve(cachedVolume);\r\n  }\r\n\r\n  const volumeProps = generateVolumePropsFromImageIds(imageIds, volumeId);\r\n\r\n  // volume is an empty volume, we need to load the data from the imageIds\r\n  // into the volume scalarData\r\n\r\n  // it is important to get the imageIds from the volumeProps\r\n  // since they are sorted\r\n  const imagePromises = volumeProps.imageIds.map((imageId, imageIdIndex) => {\r\n    const imageLoadObject = cache.getImageLoadObject(imageId);\r\n\r\n    return imageLoadObject.promise.then((image) => {\r\n      const pixelData = image.getPixelData();\r\n      const offset = imageIdIndex * image.rows * image.columns;\r\n\r\n      (volumeProps.scalarData as PixelDataTypedArray).set(pixelData, offset);\r\n    });\r\n  });\r\n\r\n  await Promise.all(imagePromises);\r\n\r\n  const volume = new ImageVolume({\r\n    ...volumeProps,\r\n    referencedImageIds: imageIds,\r\n    ...options,\r\n  });\r\n\r\n  // since we generated the volume from images, we can optimize the cache\r\n  // by replacing the pixelData of the images with a view of the volume's\r\n  // scalarData\r\n  performCacheOptimizationForVolume(volume);\r\n\r\n  const volumeLoadObject = {\r\n    promise: Promise.resolve(volume),\r\n  };\r\n\r\n  if (preventCache) {\r\n    return volumeLoadObject.promise;\r\n  }\r\n\r\n  cache.putVolumeLoadObject(volumeId, volumeLoadObject);\r\n\r\n  return volumeLoadObject.promise;\r\n}\r\n\r\n/**\r\n * Registers an volumeLoader plugin with cornerstone for the specified scheme\r\n *\r\n * @param scheme - The scheme to use for this volume loader (e.g. 'dicomweb', 'wadouri', 'http')\r\n * @param volumeLoader - A Cornerstone Volume Loader function\r\n */\r\nexport function registerVolumeLoader(\r\n  scheme: string,\r\n  volumeLoader: VolumeLoaderFn\r\n): void {\r\n  volumeLoaders[scheme] = volumeLoader;\r\n}\r\n\r\n/** Gets the array of volume loader schemes */\r\nexport function getVolumeLoaderSchemes(): string[] {\r\n  return Object.keys(volumeLoaders);\r\n}\r\n\r\n/**\r\n * Registers a new unknownVolumeLoader and returns the previous one\r\n *\r\n * @param volumeLoader - A Cornerstone Volume Loader\r\n *\r\n * @returns The previous Unknown Volume Loader\r\n */\r\nexport function registerUnknownVolumeLoader(\r\n  volumeLoader: VolumeLoaderFn\r\n): VolumeLoaderFn | undefined {\r\n  const oldVolumeLoader = unknownVolumeLoader;\r\n\r\n  unknownVolumeLoader = volumeLoader;\r\n\r\n  return oldVolumeLoader;\r\n}\r\n\r\nexport function getUnknownVolumeLoaderSchema(): string {\r\n  return unknownVolumeLoader.name;\r\n}\r\n\r\n/**\r\n * Creates and caches a derived segmentation volume based on a referenced volume.\r\n * This is basically a utility method since for the segmentations we have to specify\r\n * Uint8Array as the targetBuffer type for now until we support other types.\r\n *\r\n * @param referencedVolumeId - The ID of the referenced volume.\r\n * @param options - The options for creating the derived volume.\r\n * @returns A promise that resolves to the created derived segmentation volume.\r\n */\r\nexport async function createAndCacheDerivedSegmentationVolume(\r\n  referencedVolumeId: string,\r\n  options = {} as DerivedVolumeOptions\r\n): Promise<IImageVolume> {\r\n  return createAndCacheDerivedVolume(referencedVolumeId, {\r\n    ...options,\r\n    targetBuffer: {\r\n      type: 'Uint8Array',\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Creates a local segmentation volume.\r\n *\r\n * @param options - The options for creating the volume.\r\n * @param volumeId - The ID of the volume.\r\n * @param preventCache - Whether to prevent caching the volume.\r\n * @returns A promise that resolves to the created image volume.\r\n */\r\nexport async function createLocalSegmentationVolume(\r\n  options: LocalVolumeOptions,\r\n  volumeId: string,\r\n  preventCache = false\r\n): Promise<IImageVolume> {\r\n  if (!options.scalarData) {\r\n    options.scalarData = new Uint8Array(\r\n      options.dimensions[0] * options.dimensions[1] * options.dimensions[2]\r\n    );\r\n  }\r\n\r\n  return createLocalVolume(options, volumeId, preventCache);\r\n}\r\n\r\n/**\r\n * This function generates volume scalar data based on the provided target buffer and scalar length.\r\n * It checks if the cache can accommodate the data size and throws an error if it exceeds the cache size.\r\n * If a shared array buffer is available in the target buffer, it uses that to create the typed array.\r\n * Otherwise, it creates a typed array based on the scalar length.\r\n *\r\n * @param targetBuffer - The target buffer object which may contain a type and a shared array buffer.\r\n * @param scalarLength - The scalar length for creating the typed array.\r\n * @param useNorm16Texture - A flag to specify whether to use a 16-bit texture or not.\r\n * @returns The volume scalar data as a typed array.\r\n */\r\nfunction generateVolumeScalarData(\r\n  targetBuffer: {\r\n    type: PixelDataTypedArrayString;\r\n    sharedArrayBuffer?: boolean;\r\n  },\r\n  scalarLength: number\r\n) {\r\n  const { useNorm16Texture } = getConfiguration().rendering;\r\n\r\n  const { TypedArrayConstructor, numBytes } = getBufferConfiguration(\r\n    targetBuffer?.type,\r\n    scalarLength,\r\n    {\r\n      use16BitTexture: useNorm16Texture,\r\n      isVolumeBuffer: true,\r\n    }\r\n  );\r\n\r\n  const isCacheable = cache.isCacheable(numBytes);\r\n  if (!isCacheable) {\r\n    throw new Error(Events.CACHE_SIZE_EXCEEDED);\r\n  }\r\n\r\n  let volumeScalarData;\r\n  if (targetBuffer?.sharedArrayBuffer ?? getShouldUseSharedArrayBuffer()) {\r\n    switch (targetBuffer.type) {\r\n      case 'Float32Array':\r\n        volumeScalarData = createFloat32SharedArray(scalarLength);\r\n        break;\r\n      case 'Uint8Array':\r\n        volumeScalarData = createUint8SharedArray(scalarLength);\r\n        break;\r\n      case 'Uint16Array':\r\n        volumeScalarData = createUint16SharedArray(scalarLength);\r\n        break;\r\n      case 'Int16Array':\r\n        volumeScalarData = createUint16SharedArray(scalarLength);\r\n        break;\r\n      default:\r\n        throw new Error(\r\n          'generateVolumeScalarData: SharedArrayBuffer is not supported for the specified target buffer type'\r\n        );\r\n    }\r\n  } else {\r\n    volumeScalarData = new TypedArrayConstructor(scalarLength);\r\n  }\r\n\r\n  return { volumeScalarData, numBytes };\r\n}\r\n","import { RequestPoolManager } from './requestPoolManager';\r\nimport RequestType from '../enums/RequestType';\r\n\r\n/**\r\n * You can use the imageLoadPoolManager to load images, by providing a `requestFn`\r\n * that returns a promise for the image. You can provide a `type` to specify the type of\r\n * request (interaction, thumbnail, prefetch), and you can provide additional details\r\n * that will be passed to the requestFn. Below is an example of a requestFn that loads\r\n * an image from an imageId:\r\n *\r\n * ```javascript\r\n *\r\n * const priority = -5\r\n * const requestType = RequestType.Interaction\r\n * const additionalDetails = { imageId }\r\n * const options = {\r\n *   targetBuffer: {\r\n *     type: 'Float32Array',\r\n *     offset: null,\r\n *     length: null,\r\n *   },\r\n *   preScale: {\r\n *     enabled: true,\r\n *   },\r\n * }\r\n *\r\n * imageLoadPoolManager.addRequest(\r\n *   loadAndCacheImage(imageId, options).then(() => { // set on viewport}),\r\n *   requestType,\r\n *   additionalDetails,\r\n *   priority\r\n * )\r\n * ```\r\n */\r\nconst imageLoadPoolManager = new RequestPoolManager('imageLoadPool');\r\n\r\nimageLoadPoolManager.grabDelay = 0;\r\n\r\nimageLoadPoolManager.setMaxSimultaneousRequests(RequestType.Interaction, 1000);\r\nimageLoadPoolManager.setMaxSimultaneousRequests(RequestType.Thumbnail, 1000);\r\nimageLoadPoolManager.setMaxSimultaneousRequests(RequestType.Prefetch, 1000);\r\n\r\nexport default imageLoadPoolManager;\r\n","import RequestType from '../enums/RequestType';\r\nimport { IImage } from '../types';\r\nimport { uuidv4 } from '../utilities';\r\n\r\ntype AdditionalDetails = {\r\n  imageId?: string;\r\n  volumeId?: string;\r\n};\r\n\r\ntype RequestDetailsInterface = {\r\n  requestFn: () => Promise<IImage | void>;\r\n  type: RequestType;\r\n  additionalDetails: AdditionalDetails;\r\n};\r\n\r\ntype RequestPool = {\r\n  [name in RequestType]: { [key: number]: RequestDetailsInterface[] };\r\n};\r\n\r\n/**\r\n * RequestPool manager class is a base class that manages the request pools.\r\n * It is used imageRetrievalPoolManager, and imageLoadPoolManager to retrieve and load images.\r\n * Previously requestPoolManager was used to manage the retrieval and loading and decoding\r\n * of the images in a way that new requests were sent after the image was both loaded and decoded\r\n * which was not performant since it was waiting for the image to be loaded and decoded before\r\n * sending the next request which is a network request and can be done in parallel.\r\n * Now, we use separate imageRetrievalPoolManager and imageLoadPoolManager\r\n * to improve performance and both are extending the RequestPoolManager class which\r\n * is a basic queueing pool.\r\n *\r\n * A new requestPool can be created by instantiating a new RequestPoolManager class.\r\n *\r\n * ```javascript\r\n * const requestPoolManager = new RequestPoolManager()\r\n * ```\r\n *\r\n * ## ImageLoadPoolManager\r\n *\r\n * You can use the imageLoadPoolManager to load images, by providing a `requestFn`\r\n * that returns a promise for the image. You can provide a `type` to specify the type of\r\n * request (interaction, thumbnail, prefetch), and you can provide additional details\r\n * that will be passed to the requestFn. Below is an example of a requestFn that loads\r\n * an image from an imageId:\r\n *\r\n * ```javascript\r\n *\r\n * const priority = -5\r\n * const requestType = RequestType.Interaction\r\n * const additionalDetails = { imageId }\r\n * const options = {\r\n *   targetBuffer: {\r\n *     type: 'Float32Array',\r\n *     offset: null,\r\n *     length: null,\r\n *   },\r\n *   preScale: {\r\n *      enabled: true,\r\n *    },\r\n * }\r\n *\r\n * imageLoadPoolManager.addRequest(\r\n *   loadAndCacheImage(imageId, options).then(() => { // set on viewport}),\r\n *   requestType,\r\n *   additionalDetails,\r\n *   priority\r\n * )\r\n * ```\r\n * ### ImageRetrievalPoolManager\r\n * You don't need to directly use the imageRetrievalPoolManager to load images\r\n * since the imageLoadPoolManager will automatically use it for retrieval. However,\r\n * maximum number of concurrent requests can be set by calling `setMaxConcurrentRequests`.\r\n */\r\nclass RequestPoolManager {\r\n  private id: string;\r\n  private awake: boolean;\r\n  private requestPool: RequestPool;\r\n  private numRequests = {\r\n    interaction: 0,\r\n    thumbnail: 0,\r\n    prefetch: 0,\r\n    compute: 0,\r\n  };\r\n  /* maximum number of requests of each type. */\r\n  public maxNumRequests: {\r\n    interaction: number;\r\n    thumbnail: number;\r\n    prefetch: number;\r\n    compute: number;\r\n  };\r\n  /* A public property that is used to set the delay between requests. */\r\n  public grabDelay: number;\r\n  private timeoutHandle: number;\r\n\r\n  /**\r\n   * By default a request pool containing three priority groups, one for each\r\n   * of the request types, is created. Maximum number of requests of each type\r\n   * is set to 6.\r\n   */\r\n  constructor(id?: string) {\r\n    this.id = id ? id : uuidv4();\r\n\r\n    this.requestPool = {\r\n      interaction: { 0: [] },\r\n      thumbnail: { 0: [] },\r\n      prefetch: { 0: [] },\r\n      compute: { 0: [] },\r\n    };\r\n\r\n    this.grabDelay = 5;\r\n    this.awake = false;\r\n\r\n    this.numRequests = {\r\n      interaction: 0,\r\n      thumbnail: 0,\r\n      prefetch: 0,\r\n      compute: 0,\r\n    };\r\n\r\n    this.maxNumRequests = {\r\n      interaction: 6,\r\n      thumbnail: 6,\r\n      prefetch: 5,\r\n      // I believe there is a bug right now, where if there are two workers\r\n      // and one wants to run a compute job 6 times and the limit is just 5, then\r\n      // the other worker will never get a chance to run its compute job.\r\n      // we should probably have a separate limit for compute jobs per worker\r\n      // context as there is another layer of parallelism there. For this reason\r\n      // I'm setting the limit to 1000 for now.\r\n      compute: 1000,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * This function sets the maximum number of requests for a given request type.\r\n   * @param type - The type of request you want to set the max number\r\n   * of requests for it can be either of interaction, prefetch, or thumbnail.\r\n   * @param maxNumRequests - The maximum number of requests that can be\r\n   * made at a time.\r\n   */\r\n  public setMaxSimultaneousRequests(\r\n    type: RequestType,\r\n    maxNumRequests: number\r\n  ): void {\r\n    this.maxNumRequests[type] = maxNumRequests;\r\n  }\r\n\r\n  /**\r\n   * It returns the maximum number of requests of a given type that can be made\r\n   * @param type - The type of request.\r\n   * @returns The maximum number of requests of a given type.\r\n   */\r\n  public getMaxSimultaneousRequests(type: RequestType): number {\r\n    return this.maxNumRequests[type];\r\n  }\r\n\r\n  /**\r\n   * Stops further fetching of the requests, all the ongoing requests will still\r\n   * be retrieved\r\n   */\r\n  public destroy(): void {\r\n    if (this.timeoutHandle) {\r\n      window.clearTimeout(this.timeoutHandle);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds the requests to the pool of requests.\r\n   *\r\n   * @param requestFn - A function that returns a promise which resolves in the image\r\n   * @param type - Priority category, it can be either of interaction, prefetch,\r\n   * or thumbnail.\r\n   * @param additionalDetails - Additional details that requests can contain.\r\n   * For instance the volumeId for the volume requests\r\n   * @param priority - Priority number for each category of requests. Its default\r\n   * value is priority 0. The lower the priority number, the higher the priority number\r\n   *\r\n   */\r\n  public addRequest(\r\n    requestFn: () => Promise<IImage | void>,\r\n    type: RequestType,\r\n    additionalDetails: Record<string, unknown>,\r\n    priority = 0\r\n  ): void {\r\n    // Describe the request\r\n    const requestDetails: RequestDetailsInterface = {\r\n      requestFn,\r\n      type,\r\n      additionalDetails,\r\n    };\r\n\r\n    // Check if the priority group exists on the request type\r\n    if (this.requestPool[type][priority] === undefined) {\r\n      this.requestPool[type][priority] = [];\r\n    }\r\n\r\n    // Adding the request to the correct priority group of the request type\r\n    this.requestPool[type][priority].push(requestDetails);\r\n\r\n    this.startGrabbing();\r\n  }\r\n\r\n  /**\r\n   * Filter the requestPoolManager's pool of request based on the result of\r\n   * provided filter function. The provided filter function needs to return false or true\r\n   *\r\n   * @param filterFunction - The filter function for filtering of the requests to keep\r\n   */\r\n  public filterRequests(\r\n    filterFunction: (requestDetails: RequestDetailsInterface) => boolean\r\n  ): void {\r\n    Object.keys(this.requestPool).forEach((type: string) => {\r\n      const requestType = this.requestPool[type];\r\n      Object.keys(requestType).forEach((priority) => {\r\n        requestType[priority] = requestType[priority].filter(\r\n          (requestDetails: RequestDetailsInterface) => {\r\n            return filterFunction(requestDetails);\r\n          }\r\n        );\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Clears the requests specific to the provided type. For instance, the\r\n   * pool of requests of type 'interaction' can be cleared via this function.\r\n   *\r\n   *\r\n   * @param type - category of the request (either interaction, prefetch or thumbnail)\r\n   */\r\n  public clearRequestStack(type: string): void {\r\n    if (!this.requestPool[type]) {\r\n      throw new Error(`No category for the type ${type} found`);\r\n    }\r\n    this.requestPool[type] = { 0: [] };\r\n  }\r\n\r\n  private sendRequests(type) {\r\n    const requestsToSend = this.maxNumRequests[type] - this.numRequests[type];\r\n    let syncImageCount = 0;\r\n\r\n    for (let i = 0; i < requestsToSend; i++) {\r\n      const requestDetails = this.getNextRequest(type);\r\n      if (requestDetails === null) {\r\n        return false;\r\n      } else if (requestDetails) {\r\n        this.numRequests[type]++;\r\n        this.awake = true;\r\n\r\n        let requestResult;\r\n        try {\r\n          requestResult = requestDetails.requestFn();\r\n        } catch (e) {\r\n          // This is the only warning one will get, so need a warn message\r\n          console.warn('sendRequest failed', e);\r\n        }\r\n        if (requestResult?.finally) {\r\n          requestResult.finally(() => {\r\n            this.numRequests[type]--;\r\n            this.startAgain();\r\n          });\r\n        } else {\r\n          // Handle non-async request functions too - typically just short circuit ones\r\n          this.numRequests[type]--;\r\n          syncImageCount++;\r\n        }\r\n      }\r\n    }\r\n    if (syncImageCount) {\r\n      this.startAgain();\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private getNextRequest(type): RequestDetailsInterface | null {\r\n    const interactionPriorities = this.getSortedPriorityGroups(type);\r\n    for (const priority of interactionPriorities) {\r\n      if (this.requestPool[type][priority].length) {\r\n        return this.requestPool[type][priority].shift();\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  protected startGrabbing(): void {\r\n    const hasRemainingInteractionRequests = this.sendRequests(\r\n      RequestType.Interaction\r\n    );\r\n    const hasRemainingThumbnailRequests = this.sendRequests(\r\n      RequestType.Thumbnail\r\n    );\r\n    const hasRemainingPrefetchRequests = this.sendRequests(\r\n      RequestType.Prefetch\r\n    );\r\n    const hasRemainingComputeRequests = this.sendRequests(RequestType.Compute);\r\n\r\n    if (\r\n      !hasRemainingInteractionRequests &&\r\n      !hasRemainingThumbnailRequests &&\r\n      !hasRemainingPrefetchRequests &&\r\n      !hasRemainingComputeRequests\r\n    ) {\r\n      this.awake = false;\r\n    }\r\n  }\r\n\r\n  protected startAgain(): void {\r\n    if (!this.awake) {\r\n      return;\r\n    }\r\n\r\n    if (this.grabDelay !== undefined) {\r\n      // Prevents calling setTimeout hundreds of times when hundreds of requests\r\n      // are added which make it slower and works in an unexpected way when\r\n      // destroy/clearTimeout is called because only the last handle is stored.\r\n      if (!this.timeoutHandle) {\r\n        this.timeoutHandle = window.setTimeout(() => {\r\n          this.timeoutHandle = null;\r\n          this.startGrabbing();\r\n        }, this.grabDelay);\r\n      }\r\n    } else {\r\n      this.startGrabbing();\r\n    }\r\n  }\r\n\r\n  protected getSortedPriorityGroups(type: string): Array<number> {\r\n    const priorities = Object.keys(this.requestPool[type])\r\n      .map(Number)\r\n      .filter((priority) => this.requestPool[type][priority].length)\r\n      .sort((a, b) => a - b);\r\n    return priorities;\r\n  }\r\n\r\n  /**\r\n   * Returns the request pool containing different categories, their priority and\r\n   * the added request details.\r\n   *\r\n   * @returns the request pool which contains different categories, their priority and\r\n   * the added request details\r\n   */\r\n  getRequestPool(): RequestPool {\r\n    return this.requestPool;\r\n  }\r\n}\r\n\r\nexport { RequestPoolManager };\r\n","import cache, { ImageVolume } from '../cache';\r\nimport { Events } from '../enums';\r\nimport eventTarget from '../eventTarget';\r\nimport { getConfiguration, getShouldUseSharedArrayBuffer } from '../init';\r\n\r\n/**\r\n * This function will check if the cache optimization is enabled and if it is\r\n * it will check if the created volume was derived from an already cached stack\r\n * of images, if so it will go back to the image cache and create a view at the\r\n * correct offset of the bigger volume array buffer, this will save memory.\r\n *\r\n * @param volumeId - The volumeId that will be checked for cache optimization\r\n */\r\nexport function setupCacheOptimizationEventListener(volumeId) {\r\n  const { enableCacheOptimization } = getConfiguration();\r\n  const shouldUseSAB = getShouldUseSharedArrayBuffer();\r\n\r\n  const performOptimization = enableCacheOptimization && shouldUseSAB;\r\n  if (!performOptimization) {\r\n    return;\r\n  }\r\n\r\n  eventTarget.addEventListenerOnce(\r\n    Events.IMAGE_VOLUME_LOADING_COMPLETED,\r\n    (evt) => {\r\n      if (evt.detail.volumeId !== volumeId) {\r\n        return;\r\n      }\r\n\r\n      const volume = cache.getVolume(volumeId);\r\n\r\n      performCacheOptimizationForVolume(volume);\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Performs cache optimization for a volume by replacing the pixel data of each image\r\n * in the image cache (if found) with a view of the volume's scalar data.\r\n * @param options - The options for cache optimization.\r\n * @param options.volumeId - The ID of the volume.\r\n */\r\nexport function performCacheOptimizationForVolume(volume) {\r\n  if (!(volume instanceof ImageVolume)) {\r\n    return;\r\n  }\r\n\r\n  const scalarData = volume.getScalarData();\r\n\r\n  volume.imageCacheOffsetMap.size > 0\r\n    ? _processImageCacheOffsetMap(volume, scalarData)\r\n    : _processVolumeImages(volume, scalarData);\r\n}\r\n\r\n/**\r\n * This function will process the volume images and replace the pixel data of each\r\n * image in the image cache (if found) with a view of the volume's scalar data.\r\n * This function is used when the volume is derived from an already cached stack\r\n * of images.\r\n *\r\n * @param volume - The volume to process.\r\n * @param scalarData - The scalar data to use for the volume.\r\n */\r\nfunction _processImageCacheOffsetMap(volume, scalarData) {\r\n  volume.imageCacheOffsetMap.forEach(({ offset }, imageId) => {\r\n    const image = cache.getImage(imageId);\r\n    if (!image) {\r\n      return;\r\n    }\r\n\r\n    _updateImageWithScalarDataView(image, scalarData, offset);\r\n    cache.decrementImageCacheSize(image.sizeInBytes);\r\n  });\r\n}\r\n\r\n/**\r\n * This function will process the volume images and replace the pixel data of each\r\n * image in the image cache (if found) with a view of the volume's scalar data.\r\n * This function is used when the volume is not derived from an already cached stack\r\n * of images.\r\n *\r\n * @param volume - The volume to process.\r\n * @param scalarData - The scalar data to use for the volume.\r\n */\r\nfunction _processVolumeImages(volume, scalarData) {\r\n  let compatibleScalarData = scalarData;\r\n\r\n  const sampleImageIdWithImage = volume.imageIds.find((imageId) => {\r\n    const image = cache.getImage(imageId);\r\n    return image;\r\n  });\r\n\r\n  if (!sampleImageIdWithImage) {\r\n    return;\r\n  }\r\n\r\n  const sampleImage = cache.getImage(sampleImageIdWithImage);\r\n  const samplePixelData =\r\n    sampleImage.imageFrame?.pixelData || sampleImage.getPixelData();\r\n\r\n  // Check if the types of scalarData and pixelData are different.\r\n  if (scalarData.constructor !== samplePixelData.constructor) {\r\n    // If so, create a new typed array of the same type as pixelData and copy the values from scalarData.\r\n    compatibleScalarData = new samplePixelData.constructor(scalarData.length);\r\n\r\n    // Copy values from scalarData to compatibleScalarData.\r\n    compatibleScalarData.set(scalarData);\r\n  }\r\n\r\n  volume.imageIds.forEach((imageId) => {\r\n    const image = cache.getImage(imageId);\r\n    if (!image) {\r\n      return;\r\n    }\r\n\r\n    const index = volume.getImageIdIndex(imageId);\r\n    const offset = index * image.getPixelData().byteLength;\r\n\r\n    _updateImageWithScalarDataView(image, compatibleScalarData, offset);\r\n    cache.decrementImageCacheSize(image.sizeInBytes);\r\n  });\r\n}\r\n\r\nfunction _updateImageWithScalarDataView(image, scalarData, offset) {\r\n  const pixelData = image.imageFrame\r\n    ? image.imageFrame.pixelData\r\n    : image.getPixelData();\r\n\r\n  const view = new pixelData.constructor(\r\n    scalarData.buffer,\r\n    offset,\r\n    pixelData.length\r\n  );\r\n\r\n  image.getPixelData = () => view;\r\n\r\n  if (image.imageFrame) {\r\n    image.imageFrame.pixelData = view;\r\n  }\r\n\r\n  image.bufferView = {\r\n    buffer: scalarData.buffer,\r\n    offset,\r\n  };\r\n}\r\n","import vtkColorMaps from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\r\n\r\nimport { ColormapPublic, ColormapRegistration } from '../types';\r\nimport isEqual from './isEqual';\r\nimport { actorIsA } from './actorCheck';\r\n\r\nconst _colormaps = new Map();\r\n\r\n/**\r\n * Register a colormap\r\n * @param name - name of the colormap\r\n * @param colormap - colormap object\r\n */\r\nfunction registerColormap(colormap: ColormapRegistration) {\r\n  _colormaps.set(colormap.Name, colormap);\r\n}\r\n\r\n/**\r\n * Get a colormap by name\r\n * @param name - name of the colormap\r\n * @returns colormap object\r\n */\r\nfunction getColormap(name) {\r\n  return _colormaps.get(name);\r\n}\r\n\r\n/**\r\n * Get all registered colormap names\r\n * @returns array of colormap names\r\n *\r\n */\r\nfunction getColormapNames() {\r\n  return Array.from(_colormaps.keys());\r\n}\r\n\r\n/**\r\n * Finds a colormap that matches the given RGB points.\r\n *\r\n * @param rgbPoints - The RGB points to match against the colormaps.\r\n * @returns  The matched colormap object or null if no match is found.\r\n */\r\nfunction findMatchingColormap(rgbPoints, actor): ColormapPublic | null {\r\n  const colormapsVTK = vtkColorMaps.rgbPresetNames.map((presetName) =>\r\n    vtkColorMaps.getPresetByName(presetName)\r\n  );\r\n\r\n  const colormapsCS3D = getColormapNames().map((colormapName) =>\r\n    getColormap(colormapName)\r\n  );\r\n\r\n  const colormaps = colormapsVTK.concat(colormapsCS3D);\r\n\r\n  // Find the colormap that matches the given RGB points\r\n  const matchedColormap = colormaps.find((colormap) => {\r\n    const { RGBPoints: presetRGBPoints } = colormap;\r\n\r\n    if (presetRGBPoints.length !== rgbPoints.length) {\r\n      return false;\r\n    }\r\n\r\n    for (let i = 0; i < presetRGBPoints.length; i += 4) {\r\n      if (\r\n        !isEqual(\r\n          presetRGBPoints.slice(i + 1, i + 4),\r\n          rgbPoints.slice(i + 1, i + 4)\r\n        )\r\n      ) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  });\r\n\r\n  if (!matchedColormap) {\r\n    return null;\r\n  }\r\n\r\n  const opacity = [];\r\n  if (actorIsA(actor, 'vtkVolume')) {\r\n    const opacityPoints = actor\r\n      .getProperty()\r\n      .getScalarOpacity(0)\r\n      .getDataPointer();\r\n\r\n    if (!opacityPoints) {\r\n      return {\r\n        name: matchedColormap.Name,\r\n      };\r\n    }\r\n\r\n    for (let i = 0; i < opacityPoints.length; i += 2) {\r\n      opacity.push({\r\n        value: opacityPoints[i],\r\n        opacity: opacityPoints[i + 1],\r\n      });\r\n    }\r\n  }\r\n\r\n  return {\r\n    name: matchedColormap.Name,\r\n    opacity,\r\n  };\r\n}\r\n\r\nexport {\r\n  getColormap,\r\n  getColormapNames,\r\n  registerColormap,\r\n  findMatchingColormap,\r\n};\r\n","import vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\r\nimport { VOIRange } from '../types';\r\n\r\nexport default function createLinearRGBTransferFunction(\r\n  voiRange: VOIRange\r\n): vtkColorTransferFunction {\r\n  const cfun = vtkColorTransferFunction.newInstance();\r\n  let lower = 0;\r\n  let upper = 1024;\r\n  if (\r\n    voiRange &&\r\n    voiRange.lower !== undefined &&\r\n    voiRange.upper !== undefined\r\n  ) {\r\n    lower = voiRange.lower;\r\n    upper = voiRange.upper;\r\n  }\r\n  cfun.addRGBPoint(lower, 0.0, 0.0, 0.0);\r\n  cfun.addRGBPoint(upper, 1.0, 1.0, 1.0);\r\n\r\n  return cfun;\r\n}\r\n","import { ImageSliceData, IVolumeViewport, VolumeActor } from '../types';\r\nimport getSliceRange from './getSliceRange';\r\nimport getTargetVolumeAndSpacingInNormalDir from './getTargetVolumeAndSpacingInNormalDir';\r\n\r\n/**\r\n * It calculates the number of slices and the current slice index for a given\r\n * Volume viewport\r\n * @param viewport - volume viewport\r\n * @returns An object with two properties: numberOfSlices and imageIndex.\r\n */\r\nfunction getImageSliceDataForVolumeViewport(\r\n  viewport: IVolumeViewport\r\n): ImageSliceData {\r\n  const camera = viewport.getCamera();\r\n\r\n  const { spacingInNormalDirection, imageVolume } =\r\n    getTargetVolumeAndSpacingInNormalDir(viewport, camera);\r\n\r\n  if (!imageVolume) {\r\n    return;\r\n  }\r\n\r\n  const { viewPlaneNormal, focalPoint } = camera;\r\n\r\n  const actorEntry = viewport\r\n    .getActors()\r\n    .find(\r\n      (a) =>\r\n        a.referenceId === imageVolume.volumeId || a.uid === imageVolume.volumeId\r\n    );\r\n\r\n  if (!actorEntry) {\r\n    console.warn('No actor found for with actorUID of', imageVolume.volumeId);\r\n  }\r\n\r\n  const volumeActor = actorEntry.actor as VolumeActor;\r\n  const sliceRange = getSliceRange(volumeActor, viewPlaneNormal, focalPoint);\r\n\r\n  const { min, max, current } = sliceRange;\r\n\r\n  // calculate number of steps from min to max with current normal spacing in direction\r\n  const numberOfSlices = Math.round((max - min) / spacingInNormalDirection) + 1;\r\n\r\n  // calculate the imageIndex based on min, max, current\r\n  let imageIndex = ((current - min) / (max - min)) * numberOfSlices;\r\n  imageIndex = Math.floor(imageIndex);\r\n\r\n  // Clamp imageIndex\r\n  if (imageIndex > numberOfSlices - 1) {\r\n    imageIndex = numberOfSlices - 1;\r\n  } else if (imageIndex < 0) {\r\n    imageIndex = 0;\r\n  }\r\n\r\n  return {\r\n    numberOfSlices,\r\n    imageIndex,\r\n  };\r\n}\r\n\r\nexport default getImageSliceDataForVolumeViewport;\r\n","function getTransferFunctionNodes(transferFunction) {\r\n  const size = transferFunction.getSize();\r\n  const values = [];\r\n  for (let index = 0; index < size; index++) {\r\n    const nodeValue1 = [];\r\n\r\n    transferFunction.getNodeValue(index, nodeValue1);\r\n\r\n    values.push(nodeValue1);\r\n  }\r\n\r\n  return values;\r\n}\r\n\r\nfunction setTransferFunctionNodes(transferFunction, nodes) {\r\n  if (!nodes?.length) {\r\n    return;\r\n  }\r\n\r\n  transferFunction.removeAllPoints();\r\n\r\n  nodes.forEach((node) => {\r\n    transferFunction.addRGBPoint(...node);\r\n  });\r\n}\r\n\r\nexport { getTransferFunctionNodes, setTransferFunctionNodes };\r\n","import type Point3 from '../types/Point3';\r\n\r\n/**\r\n * Given an imageData object and a point in physical space, return the index of the\r\n * voxel that contains the point. TODO: this should be pushed to vtk upstream.\r\n * @param imageData - The image data object.\r\n * @param physicalPoint - The point in physical space that you want to transform to\r\n * index space.\r\n * @returns An array of integers.\r\n */\r\nexport default function transformWorldToIndex(imageData, worldPos: Point3) {\r\n  const continuousIndex = imageData.worldToIndex(worldPos);\r\n  const index = continuousIndex.map(Math.round);\r\n\r\n  return index;\r\n}\r\n","import eventTarget from '../eventTarget';\r\n\r\n/**\r\n * Small utility to trigger a custom event for a given EventTarget.\r\n *\r\n * @example\r\n *\r\n * ```javascript\r\n * triggerEvent(element, Events.IMAGE_RENDERED, { element })\r\n * ```\r\n * or it can trigger event on the eventTarget itself\r\n *\r\n * ```javascript\r\n * triggerEvent(eventTarget, CSTOOLS_EVENTS.ANNOTATION_MODIFIED, { viewportId, annotationUID })\r\n * ```\r\n *\r\n * @param el - The element or EventTarget to trigger the event upon\r\n * @param type - The event type name\r\n * @param detail - The event detail to be sent\r\n * @returns false if event is cancelable and at least one of the event handlers\r\n * which received event called Event.preventDefault(). Otherwise it returns true.\r\n */\r\nexport default function triggerEvent(\r\n  el: EventTarget = eventTarget,\r\n  type: string,\r\n  detail: unknown = null\r\n): boolean {\r\n  if (!type) {\r\n    throw new Error('Event type was not defined');\r\n  }\r\n\r\n  const event = new CustomEvent(type, {\r\n    detail,\r\n    cancelable: true,\r\n  });\r\n\r\n  return el.dispatchEvent(event);\r\n}\r\n","import * as Comlink from 'comlink';\r\nimport { RequestType } from '../enums/';\r\nimport { RequestPoolManager } from '../requestPool/requestPoolManager';\r\n\r\nclass CentralizedWorkerManager {\r\n  constructor() {\r\n    this.workerRegistry = {};\r\n    this.workerPoolManager = new RequestPoolManager('webworker');\r\n  }\r\n\r\n  /**\r\n   * Registers a new worker, it doesn't mean that the function will get executed.\r\n   *\r\n   * @param workerName - The name of the worker.\r\n   * @param workerFn - The function that creates a new instance of the worker.\r\n   * @param options - Optional parameters.\r\n   * @param options.maxWorkerInstances - The maximum number of instances of this worker that can be created.\r\n   * For instance if you create a worker with maxWorkerInstances = 2, then only 2 instances of this worker will be created\r\n   * and in case there are 10 tasks that need to be executed, each will get assigned 5 tasks.\r\n   * @param options.overwrite - Whether to overwrite the worker if it's already registered.\r\n   * @param options.autoTerminateOnIdle - Whether to automatically terminate idle workers.\r\n   */\r\n  registerWorker(workerName, workerFn, options = {}) {\r\n    const {\r\n      maxWorkerInstances = 1,\r\n      overwrite = false,\r\n      autoTerminateOnIdle = {\r\n        enabled: false,\r\n        idleTimeThreshold: 3000, // 3 seconds\r\n      },\r\n    } = options;\r\n\r\n    if (this.workerRegistry[workerName] && !overwrite) {\r\n      console.warn(`Worker type '${workerName}' is already registered...`);\r\n      return;\r\n    }\r\n\r\n    if (overwrite && this.workerRegistry[workerName]?.idleCheckIntervalId) {\r\n      clearInterval(this.workerRegistry[workerName].idleCheckIntervalId);\r\n    }\r\n\r\n    const workerProperties = {\r\n      workerFn: null,\r\n      instances: [],\r\n      loadCounters: [],\r\n      lastActiveTime: [],\r\n      // used for termination\r\n      nativeWorkers: [],\r\n      // auto termination\r\n      autoTerminateOnIdle: autoTerminateOnIdle.enabled,\r\n      idleCheckIntervalId: null,\r\n      idleTimeThreshold: autoTerminateOnIdle.idleTimeThreshold,\r\n    };\r\n\r\n    workerProperties.loadCounters = Array(maxWorkerInstances).fill(0);\r\n    workerProperties.lastActiveTime = Array(maxWorkerInstances).fill(null);\r\n\r\n    for (let i = 0; i < maxWorkerInstances; i++) {\r\n      const worker = workerFn();\r\n      workerProperties.instances.push(Comlink.wrap(worker));\r\n      workerProperties.nativeWorkers.push(worker);\r\n      workerProperties.workerFn = workerFn;\r\n    }\r\n\r\n    this.workerRegistry[workerName] = workerProperties;\r\n  }\r\n\r\n  getNextWorkerAPI(workerName) {\r\n    const workerProperties = this.workerRegistry[workerName];\r\n\r\n    if (!workerProperties) {\r\n      console.error(`Worker type '${workerName}' is not registered.`);\r\n      return null;\r\n    }\r\n\r\n    // Find the worker with the minimum load.\r\n    const workerInstances = workerProperties.instances.filter(\r\n      (instance) => instance !== null\r\n    );\r\n\r\n    let minLoadIndex = 0;\r\n    let minLoadValue = workerProperties.loadCounters[0] || 0;\r\n    for (let i = 1; i < workerInstances.length; i++) {\r\n      const currentLoadValue = workerProperties.loadCounters[i] || 0;\r\n      if (currentLoadValue < minLoadValue) {\r\n        minLoadIndex = i;\r\n        minLoadValue = currentLoadValue;\r\n      }\r\n    }\r\n\r\n    // Check and recreate the worker if it was terminated.\r\n    if (workerProperties.instances[minLoadIndex] === null) {\r\n      const worker = workerProperties.workerFn();\r\n      workerProperties.instances[minLoadIndex] = Comlink.wrap(worker);\r\n      workerProperties.nativeWorkers[minLoadIndex] = worker;\r\n    }\r\n\r\n    // Update the load counter.\r\n    workerProperties.loadCounters[minLoadIndex] += 1;\r\n\r\n    // return the worker that has the minimum load.\r\n    return {\r\n      api: workerProperties.instances[minLoadIndex],\r\n      index: minLoadIndex,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Executes a task on a worker.\r\n   *\r\n   * @param workerName - The name of the worker to execute the task on.\r\n   * @param methodName - The name of the method to execute on the worker.\r\n   * @param args - The arguments to pass to the method. Default is an array\r\n   * You should put your transferable objects in the first argument as object\r\n   * and from the second argument you can put your non-transferable objects such\r\n   * as functions, classes, etc.\r\n   * @param options - An object containing options for the request. Default is an empty object.\r\n   * @param options.requestType - The type of the request. Default is RequestType.Compute.\r\n   * @param options.priority - The priority of the request. Default is 0.\r\n   * @param options.options - Additional options for the request. Default is an empty object.\r\n   *\r\n   * @returns A promise that resolves with the result of the task.\r\n   */\r\n  executeTask(\r\n    workerName,\r\n    methodName,\r\n    args = {},\r\n    {\r\n      requestType = RequestType.Compute,\r\n      priority = 0,\r\n      options = {},\r\n      callbacks = [],\r\n    } = {}\r\n  ) {\r\n    return new Promise((resolve, reject) => {\r\n      const requestFn = async () => {\r\n        const { api, index } = this.getNextWorkerAPI(workerName);\r\n        if (!api) {\r\n          const error = new Error(\r\n            `No available worker instance for '${workerName}'`\r\n          );\r\n          console.error(error);\r\n          reject(error);\r\n          return;\r\n        }\r\n\r\n        try {\r\n          // fix if any of the args keys are a function then we need to proxy it\r\n          // for the worker to be able to call it\r\n          let finalCallbacks = [];\r\n          if (callbacks.length) {\r\n            finalCallbacks = callbacks.map((cb) => {\r\n              return Comlink.proxy(cb);\r\n            });\r\n          }\r\n          const workerProperties = this.workerRegistry[workerName];\r\n\r\n          workerProperties.processing = true;\r\n\r\n          const results = await api[methodName](args, ...finalCallbacks);\r\n\r\n          workerProperties.processing = false;\r\n          workerProperties.lastActiveTime[index] = Date.now();\r\n\r\n          // If auto termination is enabled and the interval is not set, set it.\r\n          if (\r\n            workerProperties.autoTerminateOnIdle &&\r\n            !workerProperties.idleCheckIntervalId &&\r\n            workerProperties.idleTimeThreshold\r\n          ) {\r\n            workerProperties.idleCheckIntervalId = setInterval(() => {\r\n              this.terminateIdleWorkers(\r\n                workerName,\r\n                workerProperties.idleTimeThreshold\r\n              );\r\n            }, workerProperties.idleTimeThreshold);\r\n          }\r\n\r\n          resolve(results);\r\n        } catch (err) {\r\n          console.error(\r\n            `Error executing method '${methodName}' on worker '${workerName}':`,\r\n            err\r\n          );\r\n          reject(err);\r\n        } finally {\r\n          this.workerRegistry[workerName].loadCounters[index]--;\r\n        }\r\n      };\r\n\r\n      // I believe there is a bug right now, where if there are two workers\r\n      // and one wants to run a compute job 6 times and the limit is just 5, then\r\n      // the other worker will never get a chance to run its compute job.\r\n      // we should probably have a separate limit for compute jobs per worker\r\n      // context as there is another layer of parallelism there.\r\n      this.workerPoolManager.addRequest(\r\n        requestFn,\r\n        requestType,\r\n        options,\r\n        priority\r\n      );\r\n    });\r\n  }\r\n\r\n  terminateIdleWorkers(workerName, idleTimeThreshold) {\r\n    const workerProperties = this.workerRegistry[workerName];\r\n\r\n    if (workerProperties.processing) {\r\n      return;\r\n    }\r\n\r\n    const now = Date.now();\r\n\r\n    workerProperties.instances.forEach((_, index) => {\r\n      const lastActiveTime = workerProperties.lastActiveTime[index];\r\n      const isWorkerActive =\r\n        lastActiveTime !== null && workerProperties.loadCounters[index] > 0;\r\n      const idleTime = now - lastActiveTime;\r\n\r\n      if (!isWorkerActive && idleTime > idleTimeThreshold) {\r\n        this.terminateWorkerInstance(workerName, index);\r\n      }\r\n    });\r\n  }\r\n\r\n  terminate(workerName) {\r\n    const workerProperties = this.workerRegistry[workerName];\r\n    if (!workerProperties) {\r\n      console.error(`Worker type '${workerName}' is not registered.`);\r\n      return;\r\n    }\r\n\r\n    workerProperties.instances.forEach((_, index) => {\r\n      this.terminateWorkerInstance(workerName, index);\r\n    });\r\n  }\r\n\r\n  // New method to handle individual worker termination\r\n  terminateWorkerInstance(workerName, index) {\r\n    const workerProperties = this.workerRegistry[workerName];\r\n    const workerInstance = workerProperties.instances[index];\r\n\r\n    if (workerInstance !== null) {\r\n      workerInstance[Comlink.releaseProxy]();\r\n      workerProperties.nativeWorkers[index].terminate();\r\n\r\n      // Set the worker instance to null after termination\r\n      workerProperties.instances[index] = null;\r\n      workerProperties.lastActiveTime[index] = null;\r\n    }\r\n  }\r\n}\r\n\r\nexport default CentralizedWorkerManager;\r\n","import { SVGCursorDescriptor } from '../types';\r\n\r\n/*\r\n * Definitions\r\n */\r\n\r\nconst BASE: SVGCursorDescriptor = {\r\n  iconContent: '',\r\n  iconSize: 16,\r\n  viewBox: {\r\n    x: 16,\r\n    y: 16,\r\n  },\r\n  mousePoint: {\r\n    x: 8,\r\n    y: 8,\r\n  },\r\n  mousePointerGroupString: `\r\n    <path stroke=\"{{color}}\" d=\"M8 16L8 0\"></path>\r\n    <path stroke=\"{{color}}\" d=\"M16 8L0 8\"></path>\r\n  `,\r\n};\r\n\r\nconst SEGMENTATION_CURSOR_BOUNDARIES = {\r\n  x: 127,\r\n  y: 60,\r\n};\r\n\r\nconst MINUS_RECT = `\r\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\r\n`;\r\n\r\nconst PLUS_RECT = `\r\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\r\n<rect fill=\"{{color}}\" x=\"95.84\" y=\"9.38\" width=\"15.85\" height=\"47.14\"/>\r\n`;\r\n\r\nconst SCISSOR_ICON = `<path fill=\"{{color}}\" d=\"M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z\" transform=\"translate(-1.17 -0.96)\"/>`;\r\nconst RECTANGLE_ICON = `<path fill=\"{{color}}\" d=\"M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z\" transform=\"translate(-8.86 -2.25)\"/>`;\r\nconst CIRCLE_ICON = `<path fill=\"{{color}}\" d=\"M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z\" transform=\"translate(-8.86 -2.25)\"/>`;\r\n\r\nconst CursorSVG: Record<string, SVGCursorDescriptor> = {\r\n  Angle: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50\r\n    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23\r\n    10l50 50q10 10 10 23z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  ArrowAnnotate: extend(BASE, {\r\n    iconContent: `<g id=\"arrowAnnotate-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <path id=\"arrowAnnotate-arrow\" d=\"M23,7 l-15,15 M7,17 l0,6 6,0\" stroke-width=\"2\" />\r\n  </g>`,\r\n    viewBox: {\r\n      x: 24,\r\n      y: 24,\r\n    },\r\n  }),\r\n  Bidirectional: extend(BASE, {\r\n    iconContent: `<g fill=\"{{color}}\" stroke-width=\"3\" stroke=\"{{color}}\">\r\n    <path d=\"M27.63 3.21L3.12 28.81\"></path>\r\n    <path d=\"M27.63 15.75L15.27 4.43\"></path>\r\n    <path d=\"M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z\" ></path>\r\n    <path d=\"M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z\"></path>\r\n    <path d=\"M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z\"></path>\r\n    <path d=\"M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z\"></path>\r\n  </g>`,\r\n    viewBox: {\r\n      x: 48,\r\n      y: 48,\r\n    },\r\n  }),\r\n  CobbAngle: extend(BASE, {\r\n    iconContent: `<g stroke=\"{{color}}\" stroke-width=\"3\">\r\n    <path d=\"M28.59 2.34L3.82 12.32\"></path>\r\n    <path d=\"M28.59 29.66L3.82 19.68\"></path>\r\n    <path stroke-dasharray=\"2\" fill-opacity=\"0\" d=\"M12.37\r\n      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15\r\n      9.33C13.11 9.24 13.02 9 12.88 8.63\">\r\n    </path>\r\n  </g>`,\r\n    viewBox: {\r\n      x: 32,\r\n      y: 32,\r\n    },\r\n  }),\r\n  CircleROI: extend(BASE, {\r\n    iconContent: `<circle stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" cx=\"16\" cy=\"16\" r=\"14\" />`,\r\n    viewBox: {\r\n      x: 32,\r\n      y: 32,\r\n    },\r\n  }),\r\n  EllipticalROI: extend(BASE, {\r\n    iconContent: `<path stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" d=\"M30.74 15.76C30.74 20.99 24.14 25.23 16\r\n    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14\r\n    6.3 30.74 10.54 30.74 15.76Z\" />`,\r\n    viewBox: {\r\n      x: 32,\r\n      y: 32,\r\n    },\r\n  }),\r\n  FreehandROI: extend(BASE, {\r\n    iconContent: `<g fill=\"{{color}}\" stroke=\"{{color}}\" stroke-width=\"2\">\r\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_3\" cy=\"4.240343\" cx=\"14.306499\"/>\r\n    <line id=\"svg_4\" y2=\"3.58462\" x2=\"12.242186\" y1=\"3.997482\" x1=\"13.432202\"/>\r\n    <line id=\"svg_5\" y2=\"3.268901\" x2=\"10.857882\" y1=\"3.608906\" x1=\"12.387902\"/>\r\n    <line id=\"svg_6\" y2=\"3.147471\" x2=\"9.740724\" y1=\"3.293187\" x1=\"10.955026\"/>\r\n    <line id=\"svg_7\" y2=\"3.147471\" x2=\"8.089274\" y1=\"3.196043\" x1=\"9.983585\"/>\r\n    <line id=\"svg_8\" y2=\"3.268901\" x2=\"6.874972\" y1=\"3.123185\" x1=\"8.307848\"/>\r\n    <line id=\"svg_9\" y2=\"3.657478\" x2=\"5.587812\" y1=\"3.220329\" x1=\"7.020688\"/>\r\n    <line id=\"svg_10\" y2=\"4.046054\" x2=\"4.737801\" y1=\"3.560334\" x1=\"5.854959\"/>\r\n    <line id=\"svg_11\" y2=\"4.337487\" x2=\"4.300652\" y1=\"3.997482\" x1=\"4.834945\"/>\r\n    <line id=\"svg_12\" y2=\"4.726063\" x2=\"3.88779\" y1=\"4.191771\" x1=\"4.470655\"/>\r\n    <line id=\"svg_15\" y2=\"5.3575\" x2=\"3.377783\" y1=\"4.604633\" x1=\"3.960648\"/>\r\n    <line id=\"svg_16\" y2=\"6.183226\" x2=\"2.916348\" y1=\"5.138926\" x1=\"3.547785\"/>\r\n    <line id=\"svg_17\" y2=\"6.960379\" x2=\"2.770632\" y1=\"5.867507\" x1=\"3.037779\"/>\r\n    <line id=\"svg_18\" y2=\"7.713246\" x2=\"2.673488\" y1=\"6.741804\" x1=\"2.819204\"/>\r\n    <line id=\"svg_19\" y2=\"8.684687\" x2=\"2.697774\" y1=\"7.616102\" x1=\"2.673488\"/>\r\n    <line id=\"svg_20\" y2=\"9.753273\" x2=\"2.892062\" y1=\"8.611829\" x1=\"2.697774\"/>\r\n    <line id=\"svg_21\" y2=\"10.724714\" x2=\"3.134923\" y1=\"9.534698\" x1=\"2.84349\"/>\r\n    <line id=\"svg_23\" y2=\"11.647583\" x2=\"3.596357\" y1=\"10.578998\" x1=\"3.086351\"/>\r\n    <line id=\"svg_25\" y2=\"12.521881\" x2=\"4.276366\" y1=\"11.501867\" x1=\"3.499213\"/>\r\n    <line id=\"svg_26\" y2=\"13.930471\" x2=\"5.830673\" y1=\"12.376165\" x1=\"4.13065\"/>\r\n    <line id=\"svg_28\" y2=\"14.707624\" x2=\"7.263549\" y1=\"13.881899\" x1=\"5.733528\"/>\r\n    <line id=\"svg_29\" y2=\"15.339061\" x2=\"8.963571\" y1=\"14.61048\" x1=\"7.06926\"/>\r\n    <line id=\"svg_30\" y2=\"15.581921\" x2=\"10.882168\" y1=\"15.314775\" x1=\"8.817855\"/>\r\n    <line id=\"svg_31\" y2=\"15.460491\" x2=\"12.023612\" y1=\"15.581921\" x1=\"10.785024\"/>\r\n    <line id=\"svg_33\" y2=\"15.120487\" x2=\"13.092197\" y1=\"15.484777\" x1=\"11.877895\"/>\r\n    <line id=\"svg_34\" y2=\"14.586194\" x2=\"13.86935\" y1=\"15.217631\" x1=\"12.897909\"/>\r\n    <line id=\"svg_35\" y2=\"13.833327\" x2=\"14.597931\" y1=\"14.756196\" x1=\"13.699348\"/>\r\n    <line id=\"svg_37\" y2=\"12.716169\" x2=\"15.180796\" y1=\"13.881899\" x1=\"14.549359\"/>\r\n    <line id=\"svg_39\" y2=\"11.429009\" x2=\"15.520801\" y1=\"12.813313\" x1=\"15.15651\"/>\r\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_40\" cy=\"10.967574\" cx=\"15.520801\"/>\r\n  </g>`,\r\n    viewBox: {\r\n      x: 18,\r\n      y: 18,\r\n    },\r\n  }),\r\n  FreehandROISculptor: extend(BASE, {\r\n    iconContent: `<g id=\"icon-freehand-sculpt\" fill=\"none\" stroke-width=\"1.5\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <line id=\"svg_1\" y2=\"2.559367\" x2=\"10.184807\" y1=\"4.467781\" x1=\"8.81711\"/>\r\n    <line id=\"svg_4\" y2=\"1.493836\" x2=\"11.727442\" y1=\"2.766112\" x1=\"10.089386\"/>\r\n    <line id=\"svg_7\" y2=\"1.080346\" x2=\"13.047428\" y1=\"1.748291\" x1=\"11.345759\"/>\r\n    <line id=\"svg_8\" y2=\"1.000829\" x2=\"14.351511\" y1=\"1.112153\" x1=\"12.77707\"/>\r\n    <line id=\"svg_9\" y2=\"1.350705\" x2=\"15.242104\" y1=\"0.905408\" x1=\"13.969828\"/>\r\n    <line id=\"svg_10\" y2=\"2.098167\" x2=\"15.862339\" y1=\"1.14396\" x1=\"14.955842\"/>\r\n    <line id=\"svg_11\" y2=\"3.195505\" x2=\"16.41896\" y1=\"1.939133\" x1=\"15.766918\"/>\r\n    <line id=\"svg_12\" y2=\"4.292843\" x2=\"16.530284\" y1=\"2.925147\" x1=\"16.387153\"/>\r\n    <line id=\"svg_16\" y2=\"5.644637\" x2=\"16.196311\" y1=\"3.831643\" x1=\"16.593898\"/>\r\n    <line id=\"svg_18\" y2=\"7.266789\" x2=\"15.623787\" y1=\"5.19934\" x1=\"16.275829\"/>\r\n    <line id=\"svg_19\" y2=\"10.813258\" x2=\"14.526449\" y1=\"6.726071\" x1=\"15.766918\"/>\r\n    <line id=\"svg_20\" y2=\"5.056209\" x2=\"8.085552\" y1=\"4.181519\" x1=\"8.976145\"/>\r\n    <line id=\"svg_23\" y2=\"5.326568\" x2=\"7.481221\" y1=\"4.78585\" x1=\"8.403621\"/>\r\n    <line id=\"svg_24\" y2=\"5.565119\" x2=\"6.749662\" y1=\"5.294761\" x1=\"7.624352\"/>\r\n    <line id=\"svg_25\" y2=\"5.994512\" x2=\"5.429675\" y1=\"5.533312\" x1=\"6.956407\"/>\r\n    <line id=\"svg_27\" y2=\"6.551133\" x2=\"4.284627\" y1=\"5.962706\" x1=\"5.572807\"/>\r\n    <line id=\"svg_28\" y2=\"7.584858\" x2=\"3.044158\" y1=\"6.392099\" x1=\"4.427758\"/>\r\n    <line id=\"svg_29\" y2=\"8.84123\" x2=\"2.185372\" y1=\"7.489437\" x1=\"3.219096\"/>\r\n    <line id=\"svg_31\" y2=\"10.606513\" x2=\"1.644654\" y1=\"8.602678\" x1=\"2.280792\"/>\r\n    <line id=\"svg_32\" y2=\"13.214679\" x2=\"1.48562\" y1=\"10.352058\" x1=\"1.724171\"/>\r\n    <line id=\"svg_33\" y2=\"14.375631\" x2=\"1.676461\" y1=\"12.992031\" x1=\"1.453813\"/>\r\n    <line id=\"svg_34\" y2=\"15.298031\" x2=\"2.264889\" y1=\"14.152983\" x1=\"1.517427\"/>\r\n    <line id=\"svg_35\" y2=\"16.172721\" x2=\"3.521261\" y1=\"14.948155\" x1=\"1.915013\"/>\r\n    <line id=\"svg_36\" y2=\"16.824762\" x2=\"5.207027\" y1=\"15.997783\" x1=\"3.28271\"/>\r\n    <line id=\"svg_38\" y2=\"17.063314\" x2=\"7.035924\" y1=\"16.745245\" x1=\"4.968475\"/>\r\n    <line id=\"svg_39\" y2=\"16.888376\" x2=\"9.278311\" y1=\"17.047411\" x1=\"6.733758\"/>\r\n    <line id=\"svg_40\" y2=\"16.284045\" x2=\"10.661911\" y1=\"16.983797\" x1=\"8.992048\"/>\r\n    <line id=\"svg_41\" y2=\"15.313934\" x2=\"11.647925\" y1=\"16.395369\" x1=\"10.455166\"/>\r\n    <line id=\"svg_44\" y2=\"13.898527\" x2=\"12.82478\" y1=\"15.425259\" x1=\"11.504794\"/>\r\n    <line id=\"svg_45\" y2=\"12.037824\" x2=\"14.144766\" y1=\"14.312017\" x1=\"12.522614\"/>\r\n    <line id=\"svg_47\" y2=\"10.59061\" x2=\"14.605966\" y1=\"12.228665\" x1=\"13.953925\"/>\r\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_48\" cy=\"3.982726\" cx=\"13.460918\"/>\r\n  </g>`,\r\n    viewBox: {\r\n      x: 18,\r\n      y: 18,\r\n    },\r\n  }),\r\n  Length: extend(BASE, {\r\n    iconContent: `<g id=\"length-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <path id=\"length-dashes\" d=\"m22.5,6 -16.5,16.5\" stroke-width=\"3\" stroke-dasharray=\"0.6666,5\" />\r\n  </g>`,\r\n    viewBox: {\r\n      x: 24,\r\n      y: 24,\r\n    },\r\n  }),\r\n  Probe: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75\r\n    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73\r\n    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5\r\n    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5\r\n    385.5-103 385.5 103 279.5 279.5 103 385.5z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  RectangleROI: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47\r\n    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0\r\n    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119\r\n    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  TextMarker: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M789 559l-170 450q33 0 136.5 2t160.5 2q19 0\r\n    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29\r\n    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15\r\n    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5\r\n    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0\r\n    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11\r\n    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0\r\n    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58\r\n    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  Crosshairs: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26\r\n    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45\r\n    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26\r\n    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5\r\n    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32\r\n    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5\r\n    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26\r\n    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26\r\n    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161\r\n    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161\r\n    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  Eraser: extend(BASE, {\r\n    iconContent: `<path transform=\"translate(0,1792) scale(1,-1)\" fill=\"{{color}}\" d=\"M960 1408l336-384h-768l-336 384h768zm1013-1077q15\r\n    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38\r\n    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38\r\n    0 69.5 20.5t47.5 54.5z\" />`,\r\n    viewBox: {\r\n      x: 2048,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  Magnify: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\r\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\r\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\r\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\r\n    32s176 78.7 176 176-78.7 176-176 176z\" />`,\r\n    viewBox: {\r\n      x: 512,\r\n      y: 512,\r\n    },\r\n  }),\r\n  Pan: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17\r\n    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355\r\n    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59\r\n    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12\r\n    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144\r\n    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19\r\n    45v448q0 42-39 59-13 5-25 5-26 0-45-19z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  Rotate: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39\r\n    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5\r\n    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0\r\n    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109\r\n    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298\r\n    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14\r\n    39 17 39 59z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  StackScroll: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547\r\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0\r\n    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547\r\n    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547\r\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z\" />`,\r\n    viewBox: {\r\n      x: 24,\r\n      y: 28,\r\n    },\r\n  }),\r\n  WindowLevelRegion: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119\r\n    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5\r\n    84.5t84.5 203.5z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  WindowLevel: extend(BASE, {\r\n    iconContent: `\r\n    <path fill=\"{{color}}\" d=\"M14.5,3.5 a1 1 0 0 1 -11,11 Z\" stroke=\"none\" opacity=\"0.8\" />\r\n    <circle cx=\"9\" cy=\"9\" r=\"8\" fill=\"none\" stroke-width=\"2\" stroke=\"{{color}}\" />`,\r\n    viewBox: {\r\n      x: 18,\r\n      y: 18,\r\n    },\r\n  }),\r\n  Zoom: extend(BASE, {\r\n    iconContent: `\r\n  <path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\r\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\r\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\r\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\r\n    32s176 78.7 176 176-78.7 176-176 176z\" />\r\n  <path fill=\"{{color}}\" transform=\"scale(0.22,0.22) translate(1400,0)\" d=\"M1216\r\n    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19\r\n    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26\r\n    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z\" />`,\r\n    viewBox: {\r\n      x: 640,\r\n      y: 512,\r\n    },\r\n  }),\r\n\r\n  /*\r\n   * Segmentation Cursors\r\n   */\r\n\r\n  SegmentationFreeHandEraseInside: extend(BASE, {\r\n    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  SegmentationFreeHandFillInside: extend(BASE, {\r\n    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  SegmentationFreeHandEraseOutside: extend(BASE, {\r\n    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  SegmentationFreeHandFillOutside: extend(BASE, {\r\n    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  SegmentationRectangleEraseInside: extend(BASE, {\r\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  // Default Rectangle Scissors\r\n  RectangleScissor: extend(BASE, {\r\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  'RectangleScissor.FILL_INSIDE': extend(BASE, {\r\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  'RectangleScissor.FILL_OUTSIDE': extend(BASE, {\r\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  'RectangleScissor.ERASE_OUTSIDE': extend(BASE, {\r\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  'RectangleScissor.ERASE_INSIDE': extend(BASE, {\r\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  CircleScissor: extend(BASE, {\r\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  'CircleScissor.FILL_INSIDE': extend(BASE, {\r\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  'CircleScissor.ERASE_OUTSIDE': extend(BASE, {\r\n    iconContent: `${CIRCLE_ICON} ${MINUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  'CircleScissor.FILL_OUTSIDE': extend(BASE, {\r\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n};\r\n\r\n/*\r\n * Utils\r\n */\r\n\r\nfunction extend(\r\n  base: SVGCursorDescriptor,\r\n  values: Record<string, unknown>\r\n): SVGCursorDescriptor {\r\n  return Object.assign(Object.create(base), values);\r\n}\r\n\r\n/**\r\n * Registers a cursor to the list, so that it will be used for the given `toolName`.\r\n * Overwrites the given cursor if it is already set.\r\n *\r\n * @param toolName - The name of the tool to assign a cursor to.\r\n * @param iconContent - The SVG icon content of the cursor.\r\n * @param viewBox - The viewBox of the cursor object.\r\n */\r\nfunction registerCursor(\r\n  toolName: string,\r\n  iconContent: string,\r\n  viewBox: { x: number; y: number }\r\n) {\r\n  CursorSVG[toolName] = extend(BASE, {\r\n    iconContent,\r\n    viewBox,\r\n  });\r\n}\r\n\r\nfunction getDefinedSVGCursorDescriptor(\r\n  name: string\r\n): SVGCursorDescriptor | undefined {\r\n  return CursorSVG[name];\r\n}\r\n\r\n/*\r\n * Exports\r\n */\r\nconst svgCursorNames = Object.keys(CursorSVG);\r\n\r\nexport {\r\n  getDefinedSVGCursorDescriptor,\r\n  registerCursor,\r\n  svgCursorNames,\r\n  CursorSVG,\r\n};\r\n","import { vec2, vec3 } from 'gl-matrix';\r\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\r\nimport { roundNumber } from '../../utilities';\r\nimport { AnnotationTool } from '../base';\r\nimport throttle from '../../utilities/throttle';\r\nimport {\r\n  addAnnotation,\r\n  getAnnotations,\r\n  removeAnnotation,\r\n} from '../../stateManagement/annotation/annotationState';\r\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\r\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\r\nimport {\r\n  triggerAnnotationCompleted,\r\n  triggerAnnotationModified,\r\n} from '../../stateManagement/annotation/helpers/state';\r\nimport {\r\n  drawLine as drawLineSvg,\r\n  drawHandles as drawHandlesSvg,\r\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\r\n} from '../../drawingSvg';\r\nimport { state } from '../../store';\r\nimport { Events } from '../../enums';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport * as lineSegment from '../../utilities/math/line';\r\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\r\nimport {\r\n  resetElementCursor,\r\n  hideElementCursor,\r\n} from '../../cursors/elementCursor';\r\nimport {\r\n  EventTypes,\r\n  ToolHandle,\r\n  TextBoxHandle,\r\n  PublicToolProps,\r\n  ToolProps,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\nimport { BidirectionalAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\n\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\n\r\nconst { transformWorldToIndex } = csUtils;\r\n\r\n/**\r\n * BidirectionalTool let you draw annotations that measures the length and\r\n * width at the same time in `mm` unit. It is consisted of two perpendicular lines and\r\n * a text box. You can use the BidirectionalTool in all planes even in oblique\r\n * reconstructed planes. Note: annotation tools in cornerstone3DTools exists in the exact location\r\n * in the physical 3d space, as a result, by default, all annotations that are\r\n * drawing in the same frameOfReference will get shared between viewports that\r\n * are in the same frameOfReference.\r\n *\r\n * The resulting annotation's data (statistics) and metadata (the\r\n * state of the viewport while drawing was happening) will get added to the\r\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\r\n * or similar methods.\r\n *\r\n * ```js\r\n * cornerstoneTools.addTool(BidirectionalTool)\r\n *\r\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\r\n *\r\n * toolGroup.addTool(BidirectionalTool.toolName)\r\n *\r\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\r\n *\r\n * toolGroup.setToolActive(BidirectionalTool.toolName, {\r\n *   bindings: [\r\n *    {\r\n *       mouseButton: MouseBindings.Primary, // Left Click\r\n *     },\r\n *   ],\r\n * })\r\n * ```\r\n *\r\n * Read more in the Docs section of the website.\r\n */\r\n\r\nclass BidirectionalTool extends AnnotationTool {\r\n  static toolName;\r\n\r\n  touchDragCallback: any;\r\n  mouseDragCallback: any;\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: string[];\r\n    handleIndex?: number;\r\n    movingTextBox: boolean;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n  preventHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        preventHandleOutsideImage: false,\r\n        getTextLines: defaultGetTextLines,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n\r\n    this._throttledCalculateCachedStats = throttle(\r\n      this._calculateCachedStats,\r\n      100,\r\n      { trailing: true }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the current imageId to create\r\n   * a Bidirectional Annotation and stores it in the annotationManager\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation(\r\n    evt: EventTypes.InteractionEventType\r\n  ): BidirectionalAnnotation {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    const referencedImageId = this.getReferencedImageId(\r\n      viewport,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      viewUp\r\n    );\r\n\r\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n\r\n    const annotation: BidirectionalAnnotation = {\r\n      highlighted: true,\r\n      invalidated: true,\r\n      metadata: {\r\n        toolName: this.getToolName(),\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID,\r\n        referencedImageId,\r\n        ...viewport.getViewReference({ points: [worldPos] }),\r\n      },\r\n      data: {\r\n        handles: {\r\n          points: [\r\n            // long\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            // short\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n          ],\r\n          textBox: {\r\n            hasMoved: false,\r\n            worldPosition: <Types.Point3>[0, 0, 0],\r\n            worldBoundingBox: {\r\n              topLeft: <Types.Point3>[0, 0, 0],\r\n              topRight: <Types.Point3>[0, 0, 0],\r\n              bottomLeft: <Types.Point3>[0, 0, 0],\r\n              bottomRight: <Types.Point3>[0, 0, 0],\r\n            },\r\n          },\r\n          activeHandleIndex: null,\r\n        },\r\n        label: '',\r\n        cachedStats: {},\r\n      },\r\n    };\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex: 1,\r\n      movingTextBox: false,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n    };\r\n    this._activateDraw(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  }\r\n\r\n  /**\r\n   * It returns if the canvas point is near the provided annotation in the provided\r\n   * element or not. A proximity is passed to the function to determine the\r\n   * proximity of the point to the annotation in number of pixels.\r\n   *\r\n   * @param element - HTML Element\r\n   * @param annotation - Annotation\r\n   * @param canvasCoords - Canvas coordinates\r\n   * @param proximity - Proximity to tool to consider\r\n   * @returns Boolean, whether the canvas point is near tool\r\n   */\r\n  isPointNearTool = (\r\n    element: HTMLDivElement,\r\n    annotation: BidirectionalAnnotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): boolean => {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const { data } = annotation;\r\n    const { points } = data.handles;\r\n\r\n    // Check long axis\r\n    let canvasPoint1 = viewport.worldToCanvas(points[0]);\r\n    let canvasPoint2 = viewport.worldToCanvas(points[1]);\r\n\r\n    let line = {\r\n      start: {\r\n        x: canvasPoint1[0],\r\n        y: canvasPoint1[1],\r\n      },\r\n      end: {\r\n        x: canvasPoint2[0],\r\n        y: canvasPoint2[1],\r\n      },\r\n    };\r\n\r\n    let distanceToPoint = lineSegment.distanceToPoint(\r\n      [line.start.x, line.start.y],\r\n      [line.end.x, line.end.y],\r\n      [canvasCoords[0], canvasCoords[1]]\r\n    );\r\n\r\n    if (distanceToPoint <= proximity) {\r\n      return true;\r\n    }\r\n\r\n    // Check short axis\r\n    canvasPoint1 = viewport.worldToCanvas(points[2]);\r\n    canvasPoint2 = viewport.worldToCanvas(points[3]);\r\n\r\n    line = {\r\n      start: {\r\n        x: canvasPoint1[0],\r\n        y: canvasPoint1[1],\r\n      },\r\n      end: {\r\n        x: canvasPoint2[0],\r\n        y: canvasPoint2[1],\r\n      },\r\n    };\r\n\r\n    distanceToPoint = lineSegment.distanceToPoint(\r\n      [line.start.x, line.start.y],\r\n      [line.end.x, line.end.y],\r\n      [canvasCoords[0], canvasCoords[1]]\r\n    );\r\n\r\n    if (distanceToPoint <= proximity) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Handles the toolSelected callback for bidirectional tool\r\n   * @param evt - EventTypes.MouseDownEventType\r\n   * @param annotation - Bidirectional annotation\r\n   * @param interactionType - interaction type (mouse, touch)\r\n   */\r\n  toolSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: BidirectionalAnnotation\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      movingTextBox: false,\r\n    };\r\n\r\n    this._activateModify(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  /**\r\n   * Executes the callback for when mouse has selected a handle (anchor point) of\r\n   * the bidirectional tool or when the text box has been selected.\r\n   *\r\n   * @param evt - EventTypes.MouseDownEventType\r\n   * @param annotation - Bidirectional annotation\r\n   * @param handle - Handle index or selected textBox information\r\n   * @param interactionType - interaction type (mouse, touch)\r\n   */\r\n  handleSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: BidirectionalAnnotation,\r\n    handle: ToolHandle\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const data = annotation.data;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    let movingTextBox = false;\r\n    let handleIndex;\r\n\r\n    if ((handle as TextBoxHandle).worldPosition) {\r\n      movingTextBox = true;\r\n    } else {\r\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\r\n    }\r\n\r\n    // Find viewports to render on drag.\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    hideElementCursor(element);\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex,\r\n      movingTextBox,\r\n    };\r\n    this._activateModify(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  /**\r\n   * Handles the mouse up action for the bidirectional tool. It can be at the end\r\n   * of the annotation drawing (MouseUpEventType) or when the user clicks and release\r\n   * the mouse button instantly which let to the annotation to draw without holding\r\n   * the mouse button (MouseClickEventType).\r\n   *\r\n   * @param evt - mouse up or mouse click event types\r\n   */\r\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (newAnnotation && !hasMoved) {\r\n      return;\r\n    }\r\n\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateModify(element);\r\n    this._deactivateDraw(element);\r\n\r\n    resetElementCursor(element);\r\n\r\n    const { renderingEngine } = getEnabledElement(element);\r\n\r\n    if (this.editData.handleIndex !== undefined) {\r\n      const { points } = data.handles;\r\n      const firstLineSegmentLength = vec3.distance(points[0], points[1]);\r\n      const secondLineSegmentLength = vec3.distance(points[2], points[3]);\r\n\r\n      if (secondLineSegmentLength > firstLineSegmentLength) {\r\n        // Switch points so [0,1] is the long axis and [2,3] is the short axis.\r\n\r\n        const longAxis = [[...points[2]], [...points[3]]];\r\n\r\n        const shortAxisPoint0 = [...points[0]];\r\n        const shortAxisPoint1 = [...points[1]];\r\n\r\n        // shortAxis[0->1] should be perpendicular (counter-clockwise) to longAxis[0->1]\r\n        const longAxisVector = vec2.create();\r\n\r\n        vec2.set(\r\n          longAxisVector,\r\n          longAxis[1][0] - longAxis[0][0],\r\n          longAxis[1][1] - longAxis[1][0]\r\n        );\r\n\r\n        const counterClockWisePerpendicularToLongAxis = vec2.create();\r\n\r\n        vec2.set(\r\n          counterClockWisePerpendicularToLongAxis,\r\n          -longAxisVector[1],\r\n          longAxisVector[0]\r\n        );\r\n\r\n        const currentShortAxisVector = vec2.create();\r\n\r\n        vec2.set(\r\n          currentShortAxisVector,\r\n          shortAxisPoint1[0] - shortAxisPoint0[0],\r\n          shortAxisPoint1[1] - shortAxisPoint0[0]\r\n        );\r\n\r\n        let shortAxis;\r\n\r\n        if (\r\n          vec2.dot(\r\n            currentShortAxisVector,\r\n            counterClockWisePerpendicularToLongAxis\r\n          ) > 0\r\n        ) {\r\n          shortAxis = [shortAxisPoint0, shortAxisPoint1];\r\n        } else {\r\n          shortAxis = [shortAxisPoint1, shortAxisPoint0];\r\n        }\r\n\r\n        data.handles.points = [\r\n          longAxis[0],\r\n          longAxis[1],\r\n          shortAxis[0],\r\n          shortAxis[1],\r\n        ];\r\n      }\r\n    }\r\n\r\n    if (\r\n      this.isHandleOutsideImage &&\r\n      this.configuration.preventHandleOutsideImage\r\n    ) {\r\n      removeAnnotation(annotation.annotationUID);\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    if (newAnnotation) {\r\n      triggerAnnotationCompleted(annotation);\r\n    }\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n  };\r\n\r\n  /**\r\n   * @param evt - mouse move event type or mouse drag\r\n   */\r\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    this.isDrawing = true;\r\n\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine, viewport } = enabledElement;\r\n    const { worldToCanvas } = viewport;\r\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\r\n    const { data } = annotation;\r\n\r\n    const worldPos = currentPoints.world;\r\n\r\n    // Update first move handle\r\n    data.handles.points[handleIndex] = [...worldPos];\r\n\r\n    const canvasCoordPoints = data.handles.points.map(worldToCanvas);\r\n\r\n    const canvasCoords = {\r\n      longLineSegment: {\r\n        start: {\r\n          x: canvasCoordPoints[0][0],\r\n          y: canvasCoordPoints[0][1],\r\n        },\r\n        end: {\r\n          x: canvasCoordPoints[1][0],\r\n          y: canvasCoordPoints[1][1],\r\n        },\r\n      },\r\n      shortLineSegment: {\r\n        start: {\r\n          x: canvasCoordPoints[2][0],\r\n          y: canvasCoordPoints[2][1],\r\n        },\r\n        end: {\r\n          x: canvasCoordPoints[3][0],\r\n          y: canvasCoordPoints[3][1],\r\n        },\r\n      },\r\n    };\r\n\r\n    // ~~ calculate worldPos of our short axis handles\r\n    // short axis is perpendicular to long axis, and we set its length to be 2/3 of long axis\r\n    // (meaning each)\r\n    const dist = vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);\r\n\r\n    const shortAxisDistFromCenter = dist / 3;\r\n    // Calculate long line's incline\r\n    const dx =\r\n      canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;\r\n    const dy =\r\n      canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;\r\n    const length = Math.sqrt(dx * dx + dy * dy);\r\n    const vectorX = dx / length;\r\n    const vectorY = dy / length;\r\n    // middle point between long line segment's points\r\n    const xMid =\r\n      (canvasCoords.longLineSegment.start.x +\r\n        canvasCoords.longLineSegment.end.x) /\r\n      2;\r\n    const yMid =\r\n      (canvasCoords.longLineSegment.start.y +\r\n        canvasCoords.longLineSegment.end.y) /\r\n      2;\r\n    // short points 1/3 distance from center of long points\r\n    const startX = xMid + shortAxisDistFromCenter * vectorY;\r\n    const startY = yMid - shortAxisDistFromCenter * vectorX;\r\n    const endX = xMid - shortAxisDistFromCenter * vectorY;\r\n    const endY = yMid + shortAxisDistFromCenter * vectorX;\r\n\r\n    // Update perpendicular line segment's points\r\n    data.handles.points[2] = viewport.canvasToWorld([startX, startY]);\r\n    data.handles.points[3] = viewport.canvasToWorld([endX, endY]);\r\n\r\n    annotation.invalidated = true;\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    this.editData.hasMoved = true;\r\n  };\r\n\r\n  /**\r\n   * Mouse drag to edit annotation callback\r\n   * @param evt - mouse drag event\r\n   */\r\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    this.isDrawing = true;\r\n\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n    if (movingTextBox) {\r\n      const { deltaPoints } = eventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n\r\n      const { textBox } = data.handles;\r\n      const { worldPosition } = textBox;\r\n\r\n      worldPosition[0] += worldPosDelta[0];\r\n      worldPosition[1] += worldPosDelta[1];\r\n      worldPosition[2] += worldPosDelta[2];\r\n\r\n      textBox.hasMoved = true;\r\n    } else if (handleIndex === undefined) {\r\n      // Moving tool\r\n      const { deltaPoints } = eventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n      const points = data.handles.points;\r\n\r\n      points.forEach((point) => {\r\n        point[0] += worldPosDelta[0];\r\n        point[1] += worldPosDelta[1];\r\n        point[2] += worldPosDelta[2];\r\n      });\r\n      annotation.invalidated = true;\r\n    } else {\r\n      this._dragModifyHandle(evt);\r\n      annotation.invalidated = true;\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  /**\r\n   * Mouse dragging a handle callback\r\n   * @param evt - mouse drag event\r\n   */\r\n  _dragModifyHandle = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const { annotation, handleIndex: movingHandleIndex } = this.editData;\r\n    const { data } = annotation;\r\n\r\n    // Moving handle\r\n    const worldPos = currentPoints.world;\r\n    const canvasCoordHandlesCurrent = [\r\n      viewport.worldToCanvas(data.handles.points[0]),\r\n      viewport.worldToCanvas(data.handles.points[1]),\r\n      viewport.worldToCanvas(data.handles.points[2]),\r\n      viewport.worldToCanvas(data.handles.points[3]),\r\n    ];\r\n\r\n    const firstLineSegment = {\r\n      start: {\r\n        x: canvasCoordHandlesCurrent[0][0],\r\n        y: canvasCoordHandlesCurrent[0][1],\r\n      },\r\n      end: {\r\n        x: canvasCoordHandlesCurrent[1][0],\r\n        y: canvasCoordHandlesCurrent[1][1],\r\n      },\r\n    };\r\n    const secondLineSegment = {\r\n      start: {\r\n        x: canvasCoordHandlesCurrent[2][0],\r\n        y: canvasCoordHandlesCurrent[2][1],\r\n      },\r\n      end: {\r\n        x: canvasCoordHandlesCurrent[3][0],\r\n        y: canvasCoordHandlesCurrent[3][1],\r\n      },\r\n    };\r\n\r\n    // Handle we've selected's proposed point\r\n    const proposedPoint = <Types.Point3>[...worldPos];\r\n    const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);\r\n\r\n    if (movingHandleIndex === 0 || movingHandleIndex === 1) {\r\n      const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;\r\n\r\n      const fixedHandleCanvasCoord =\r\n        canvasCoordHandlesCurrent[fixedHandleIndex];\r\n\r\n      const fixedHandleToProposedCoordVec = vec2.set(\r\n        vec2.create(),\r\n        proposedCanvasCoord[0] - fixedHandleCanvasCoord[0],\r\n        proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]\r\n      );\r\n\r\n      const fixedHandleToOldCoordVec = vec2.set(\r\n        vec2.create(),\r\n        canvasCoordHandlesCurrent[movingHandleIndex][0] -\r\n          fixedHandleCanvasCoord[0],\r\n        canvasCoordHandlesCurrent[movingHandleIndex][1] -\r\n          fixedHandleCanvasCoord[1]\r\n      );\r\n\r\n      // normalize vector\r\n      vec2.normalize(\r\n        fixedHandleToProposedCoordVec,\r\n        fixedHandleToProposedCoordVec\r\n      );\r\n      vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);\r\n\r\n      // Check whether this\r\n      const proposedFirstLineSegment = {\r\n        start: {\r\n          x: fixedHandleCanvasCoord[0],\r\n          y: fixedHandleCanvasCoord[1],\r\n        },\r\n        end: {\r\n          x: proposedCanvasCoord[0],\r\n          y: proposedCanvasCoord[1],\r\n        },\r\n      };\r\n\r\n      // Note: this is the case when we are modifying the long axis line segment\r\n      // and we make it shorter and shorter until its second half size becomes zero\r\n      // which basically means that any more modification would make the long axis\r\n      // second half disappear. In this case, we just bail out and do not update\r\n      // since we don't want to disrupt the bidirectional shape.\r\n      if (\r\n        this._movingLongAxisWouldPutItThroughShortAxis(\r\n          proposedFirstLineSegment,\r\n          secondLineSegment\r\n        )\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      const centerOfRotation = fixedHandleCanvasCoord;\r\n\r\n      const angle = this._getSignedAngle(\r\n        fixedHandleToOldCoordVec,\r\n        fixedHandleToProposedCoordVec\r\n      );\r\n\r\n      // rotate handles around the center of rotation, first translate to origin,\r\n      // then rotate, then translate back\r\n      let firstPointX = canvasCoordHandlesCurrent[2][0];\r\n      let firstPointY = canvasCoordHandlesCurrent[2][1];\r\n\r\n      let secondPointX = canvasCoordHandlesCurrent[3][0];\r\n      let secondPointY = canvasCoordHandlesCurrent[3][1];\r\n\r\n      // translate to origin\r\n      firstPointX -= centerOfRotation[0];\r\n      firstPointY -= centerOfRotation[1];\r\n\r\n      secondPointX -= centerOfRotation[0];\r\n      secondPointY -= centerOfRotation[1];\r\n\r\n      // rotate\r\n      const rotatedFirstPoint =\r\n        firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);\r\n      const rotatedFirstPointY =\r\n        firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);\r\n\r\n      const rotatedSecondPoint =\r\n        secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);\r\n      const rotatedSecondPointY =\r\n        secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);\r\n\r\n      // translate back\r\n      firstPointX = rotatedFirstPoint + centerOfRotation[0];\r\n      firstPointY = rotatedFirstPointY + centerOfRotation[1];\r\n\r\n      secondPointX = rotatedSecondPoint + centerOfRotation[0];\r\n      secondPointY = rotatedSecondPointY + centerOfRotation[1];\r\n\r\n      // update handles\r\n      const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);\r\n      const newSecondPoint = viewport.canvasToWorld([\r\n        secondPointX,\r\n        secondPointY,\r\n      ]);\r\n\r\n      // the fixed handle is the one that is not being moved so we\r\n      // don't need to update it\r\n      data.handles.points[movingHandleIndex] = proposedPoint;\r\n      data.handles.points[2] = newFirstPoint;\r\n      data.handles.points[3] = newSecondPoint;\r\n    } else {\r\n      // Translation manipulator\r\n      const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;\r\n\r\n      const canvasCoordsCurrent = {\r\n        longLineSegment: {\r\n          start: firstLineSegment.start,\r\n          end: firstLineSegment.end,\r\n        },\r\n        shortLineSegment: {\r\n          start: secondLineSegment.start,\r\n          end: secondLineSegment.end,\r\n        },\r\n      };\r\n\r\n      const longLineSegmentVec = vec2.subtract(\r\n        vec2.create(),\r\n        [\r\n          canvasCoordsCurrent.longLineSegment.end.x,\r\n          canvasCoordsCurrent.longLineSegment.end.y,\r\n        ],\r\n        [\r\n          canvasCoordsCurrent.longLineSegment.start.x,\r\n          canvasCoordsCurrent.longLineSegment.start.y,\r\n        ]\r\n      );\r\n\r\n      const longLineSegmentVecNormalized = vec2.normalize(\r\n        vec2.create(),\r\n        longLineSegmentVec\r\n      );\r\n\r\n      const proposedToCurrentVec = vec2.subtract(\r\n        vec2.create(),\r\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\r\n        [\r\n          canvasCoordHandlesCurrent[movingHandleIndex][0],\r\n          canvasCoordHandlesCurrent[movingHandleIndex][1],\r\n        ]\r\n      );\r\n\r\n      const movementLength = vec2.length(proposedToCurrentVec);\r\n\r\n      const angle = this._getSignedAngle(\r\n        longLineSegmentVecNormalized,\r\n        proposedToCurrentVec\r\n      );\r\n\r\n      const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;\r\n\r\n      const newTranslatedPoint = vec2.scaleAndAdd(\r\n        vec2.create(),\r\n        [\r\n          canvasCoordHandlesCurrent[translateHandleIndex][0],\r\n          canvasCoordHandlesCurrent[translateHandleIndex][1],\r\n        ],\r\n        longLineSegmentVecNormalized,\r\n        movementAlongLineSegmentLength\r\n      );\r\n\r\n      // don't update if it passes through the other line segment\r\n      if (\r\n        this._movingLongAxisWouldPutItThroughShortAxis(\r\n          {\r\n            start: {\r\n              x: proposedCanvasCoord[0],\r\n              y: proposedCanvasCoord[1],\r\n            },\r\n            end: {\r\n              x: newTranslatedPoint[0],\r\n              y: newTranslatedPoint[1],\r\n            },\r\n          },\r\n          {\r\n            start: {\r\n              x: canvasCoordsCurrent.longLineSegment.start.x,\r\n              y: canvasCoordsCurrent.longLineSegment.start.y,\r\n            },\r\n            end: {\r\n              x: canvasCoordsCurrent.longLineSegment.end.x,\r\n              y: canvasCoordsCurrent.longLineSegment.end.y,\r\n            },\r\n          }\r\n        )\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      const intersectionPoint = lineSegment.intersectLine(\r\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\r\n        [newTranslatedPoint[0], newTranslatedPoint[1]],\r\n        [firstLineSegment.start.x, firstLineSegment.start.y],\r\n        [firstLineSegment.end.x, firstLineSegment.end.y]\r\n      );\r\n\r\n      // don't update if it doesn't intersect\r\n      if (!intersectionPoint) {\r\n        return;\r\n      }\r\n\r\n      data.handles.points[translateHandleIndex] = viewport.canvasToWorld(\r\n        newTranslatedPoint as Types.Point2\r\n      );\r\n      data.handles.points[movingHandleIndex] = proposedPoint;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Cancels an ongoing drawing of a bidirectional annotation\r\n   * @param element - HTML Element\r\n   */\r\n  cancel = (element: HTMLDivElement) => {\r\n    // If it is mid-draw or mid-modify\r\n    if (this.isDrawing) {\r\n      this.isDrawing = false;\r\n      this._deactivateDraw(element);\r\n      this._deactivateModify(element);\r\n      resetElementCursor(element);\r\n\r\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\r\n      const { data } = annotation;\r\n\r\n      annotation.highlighted = false;\r\n      data.handles.activeHandleIndex = null;\r\n\r\n      const { renderingEngine } = getEnabledElement(element);\r\n\r\n      triggerAnnotationRenderForViewportIds(\r\n        renderingEngine,\r\n        viewportIdsToRender\r\n      );\r\n\r\n      if (newAnnotation) {\r\n        triggerAnnotationCompleted(annotation);\r\n      }\r\n\r\n      this.editData = null;\r\n      return annotation.annotationUID;\r\n    }\r\n  };\r\n\r\n  _activateDraw = (element) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\r\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.addEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragDrawCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _deactivateDraw = (element) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\r\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.removeEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragDrawCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _activateModify = (element) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.addEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragModifyCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _deactivateModify = (element) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.removeEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragModifyCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the bidirectional annotation in each\r\n   * request animation frame. It calculates the updated cached statistics if\r\n   * data is invalidated and cache it.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = true;\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n    let annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    annotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    );\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const targetId = this.getTargetId(viewport);\r\n\r\n    const renderingEngine = viewport.getRenderingEngine();\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[i] as BidirectionalAnnotation;\r\n      const { annotationUID, data } = annotation;\r\n      const { points, activeHandleIndex } = data.handles;\r\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\r\n        annotation,\r\n        styleSpecifier,\r\n      });\r\n\r\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\r\n      // force to recalculate the stats from the points\r\n      if (\r\n        !data.cachedStats[targetId] ||\r\n        data.cachedStats[targetId].unit == null\r\n      ) {\r\n        data.cachedStats[targetId] = {\r\n          length: null,\r\n          width: null,\r\n          unit: null,\r\n        };\r\n\r\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\r\n      } else if (annotation.invalidated) {\r\n        this._throttledCalculateCachedStats(\r\n          annotation,\r\n          renderingEngine,\r\n          enabledElement\r\n        );\r\n      }\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n\r\n      let activeHandleCanvasCoords;\r\n\r\n      if (!isAnnotationVisible(annotationUID)) {\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        !isAnnotationLocked(annotation) &&\r\n        !this.editData &&\r\n        activeHandleIndex !== null\r\n      ) {\r\n        // Not locked or creating and hovering over handle, so render handle.\r\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\r\n      }\r\n\r\n      if (activeHandleCanvasCoords) {\r\n        const handleGroupUID = '0';\r\n\r\n        drawHandlesSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          handleGroupUID,\r\n          activeHandleCanvasCoords,\r\n          {\r\n            color,\r\n          }\r\n        );\r\n      }\r\n\r\n      const dataId1 = `${annotationUID}-line-1`;\r\n      const dataId2 = `${annotationUID}-line-2`;\r\n\r\n      const lineUID = '0';\r\n      drawLineSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        lineUID,\r\n        canvasCoordinates[0],\r\n        canvasCoordinates[1],\r\n        {\r\n          color,\r\n          lineDash,\r\n          lineWidth,\r\n          shadow,\r\n        },\r\n        dataId1\r\n      );\r\n\r\n      const secondLineUID = '1';\r\n      drawLineSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        secondLineUID,\r\n        canvasCoordinates[2],\r\n        canvasCoordinates[3],\r\n        {\r\n          color,\r\n          lineDash,\r\n          lineWidth,\r\n          shadow,\r\n        },\r\n        dataId2\r\n      );\r\n\r\n      renderStatus = true;\r\n\r\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\r\n      if (!options.visibility) {\r\n        data.handles.textBox = {\r\n          hasMoved: false,\r\n          worldPosition: <Types.Point3>[0, 0, 0],\r\n          worldBoundingBox: {\r\n            topLeft: <Types.Point3>[0, 0, 0],\r\n            topRight: <Types.Point3>[0, 0, 0],\r\n            bottomLeft: <Types.Point3>[0, 0, 0],\r\n            bottomRight: <Types.Point3>[0, 0, 0],\r\n          },\r\n        };\r\n        continue;\r\n      }\r\n\r\n      const textLines = this.configuration.getTextLines(data, targetId);\r\n      if (!textLines || textLines.length === 0) {\r\n        continue;\r\n      }\r\n\r\n      let canvasTextBoxCoords;\r\n\r\n      if (!data.handles.textBox.hasMoved) {\r\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\r\n\r\n        data.handles.textBox.worldPosition =\r\n          viewport.canvasToWorld(canvasTextBoxCoords);\r\n      }\r\n\r\n      const textBoxPosition = viewport.worldToCanvas(\r\n        data.handles.textBox.worldPosition\r\n      );\r\n\r\n      const textBoxUID = '1';\r\n      const boundingBox = drawLinkedTextBoxSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        textBoxUID,\r\n        textLines,\r\n        textBoxPosition,\r\n        canvasCoordinates,\r\n        {},\r\n        options\r\n      );\r\n\r\n      const { x: left, y: top, width, height } = boundingBox;\r\n\r\n      data.handles.textBox.worldBoundingBox = {\r\n        topLeft: viewport.canvasToWorld([left, top]),\r\n        topRight: viewport.canvasToWorld([left + width, top]),\r\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\r\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\r\n      };\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  _movingLongAxisWouldPutItThroughShortAxis = (\r\n    firstLineSegment,\r\n    secondLineSegment\r\n  ) => {\r\n    const vectorInSecondLineDirection = vec2.create();\r\n\r\n    vec2.set(\r\n      vectorInSecondLineDirection,\r\n      secondLineSegment.end.x - secondLineSegment.start.x,\r\n      secondLineSegment.end.y - secondLineSegment.start.y\r\n    );\r\n\r\n    vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);\r\n\r\n    const extendedSecondLineSegment = {\r\n      start: {\r\n        x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,\r\n        y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,\r\n      },\r\n      end: {\r\n        x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,\r\n        y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,\r\n      },\r\n    };\r\n\r\n    // Add some buffer in the secondLineSegment when finding the proposedIntersectionPoint\r\n    // Of points to stop us getting stack when rotating quickly.\r\n\r\n    const proposedIntersectionPoint = lineSegment.intersectLine(\r\n      [extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y],\r\n      [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y],\r\n      [firstLineSegment.start.x, firstLineSegment.start.y],\r\n      [firstLineSegment.end.x, firstLineSegment.end.y]\r\n    );\r\n\r\n    const wouldPutThroughShortAxis = !proposedIntersectionPoint;\r\n\r\n    return wouldPutThroughShortAxis;\r\n  };\r\n\r\n  _calculateLength(pos1, pos2) {\r\n    const dx = pos1[0] - pos2[0];\r\n    const dy = pos1[1] - pos2[1];\r\n    const dz = pos1[2] - pos2[2];\r\n\r\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\r\n  }\r\n\r\n  _calculateCachedStats = (annotation, renderingEngine, enabledElement) => {\r\n    const { data } = annotation;\r\n    const { element } = enabledElement.viewport;\r\n\r\n    const worldPos1 = data.handles.points[0];\r\n    const worldPos2 = data.handles.points[1];\r\n    const worldPos3 = data.handles.points[2];\r\n    const worldPos4 = data.handles.points[3];\r\n\r\n    const { cachedStats } = data;\r\n    const targetIds = Object.keys(cachedStats);\r\n\r\n    for (let i = 0; i < targetIds.length; i++) {\r\n      const targetId = targetIds[i];\r\n\r\n      const image = this.getTargetIdImage(targetId, renderingEngine);\r\n\r\n      // If image does not exists for the targetId, skip. This can be due\r\n      // to various reasons such as if the target was a volumeViewport, and\r\n      // the volumeViewport has been decached in the meantime.\r\n      if (!image) {\r\n        continue;\r\n      }\r\n\r\n      const { imageData, dimensions } = image;\r\n      const index1 = transformWorldToIndex(imageData, worldPos1);\r\n      const index2 = transformWorldToIndex(imageData, worldPos2);\r\n      const index3 = transformWorldToIndex(imageData, worldPos3);\r\n      const index4 = transformWorldToIndex(imageData, worldPos4);\r\n\r\n      const handles1 = [index1, index2];\r\n      const handles2 = [index3, index4];\r\n\r\n      const { scale: scale1, units: units1 } = getCalibratedLengthUnitsAndScale(\r\n        image,\r\n        handles1\r\n      );\r\n\r\n      const { scale: scale2, units: units2 } = getCalibratedLengthUnitsAndScale(\r\n        image,\r\n        handles2\r\n      );\r\n\r\n      const dist1 = this._calculateLength(worldPos1, worldPos2) / scale1;\r\n      const dist2 = this._calculateLength(worldPos3, worldPos4) / scale2;\r\n      const length = dist1 > dist2 ? dist1 : dist2;\r\n      const width = dist1 > dist2 ? dist2 : dist1;\r\n\r\n      const lengthUnit = dist1 > dist2 ? units1 : units2;\r\n      const widthUnit = dist1 > dist2 ? units2 : units1;\r\n\r\n      this._isInsideVolume(index1, index2, index3, index4, dimensions)\r\n        ? (this.isHandleOutsideImage = false)\r\n        : (this.isHandleOutsideImage = true);\r\n\r\n      cachedStats[targetId] = {\r\n        length,\r\n        width,\r\n        unit: units1,\r\n        lengthUnit,\r\n        widthUnit,\r\n      };\r\n    }\r\n\r\n    annotation.invalidated = false;\r\n\r\n    // Dispatching annotation modified\r\n    triggerAnnotationModified(annotation, element);\r\n\r\n    return cachedStats;\r\n  };\r\n\r\n  _isInsideVolume = (index1, index2, index3, index4, dimensions): boolean => {\r\n    return (\r\n      csUtils.indexWithinDimensions(index1, dimensions) &&\r\n      csUtils.indexWithinDimensions(index2, dimensions) &&\r\n      csUtils.indexWithinDimensions(index3, dimensions) &&\r\n      csUtils.indexWithinDimensions(index4, dimensions)\r\n    );\r\n  };\r\n\r\n  _getSignedAngle = (vector1, vector2) => {\r\n    return Math.atan2(\r\n      vector1[0] * vector2[1] - vector1[1] * vector2[0],\r\n      vector1[0] * vector2[0] + vector1[1] * vector2[1]\r\n    );\r\n  };\r\n}\r\n\r\nfunction defaultGetTextLines(data, targetId): string[] {\r\n  const { cachedStats, label } = data;\r\n  const { length, width, unit, lengthUnit, widthUnit } = cachedStats[targetId];\r\n\r\n  const textLines = [];\r\n  if (label) {\r\n    textLines.push(label);\r\n  }\r\n  if (length === undefined) {\r\n    return textLines;\r\n  }\r\n\r\n  // spaceBetweenSlices & pixelSpacing &\r\n  // magnitude in each direction? Otherwise, this is \"px\"?\r\n  textLines.push(\r\n    `L: ${roundNumber(length)} ${lengthUnit || unit}`,\r\n    `W: ${roundNumber(width)} ${widthUnit || unit}`\r\n  );\r\n\r\n  return textLines;\r\n}\r\n\r\nBidirectionalTool.toolName = 'Bidirectional';\r\nexport default BidirectionalTool;\r\n","import {\r\n  BaseVolumeViewport,\r\n  cache,\r\n  getEnabledElement,\r\n  metaData,\r\n  utilities as csUtils,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { vec2 } from 'gl-matrix';\r\n\r\nimport AnnotationDisplayTool from './AnnotationDisplayTool';\r\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\r\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\r\nimport {\r\n  Annotation,\r\n  Annotations,\r\n  EventTypes,\r\n  ToolHandle,\r\n  InteractionTypes,\r\n  ToolProps,\r\n  PublicToolProps,\r\n} from '../../types';\r\nimport { addAnnotation } from '../../stateManagement/annotation/annotationState';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\r\n\r\n/**\r\n * Abstract class for tools which create and display annotations on the\r\n * cornerstone3D canvas. In addition, it provides a base class for segmentation\r\n * tools that require drawing an annotation before running the segmentation strategy\r\n * for instance threshold segmentation based on an area and a threshold.\r\n * Annotation tools make use of drawing utilities to draw SVG elements on the viewport.\r\n *\r\n * To create a new annotation tool, derive from this class and implement the\r\n * abstract methods.\r\n */\r\nabstract class AnnotationTool extends AnnotationDisplayTool {\r\n  /**\r\n   * Creates a base annotation object, adding in any annotation base data provided\r\n   */\r\n  public static createAnnotation(...annotationBaseData): Annotation {\r\n    let annotation: Annotation = {\r\n      annotationUID: null as string,\r\n      highlighted: true,\r\n      invalidated: true,\r\n      metadata: {\r\n        toolName: this.toolName,\r\n      },\r\n      data: {\r\n        text: '',\r\n        handles: {\r\n          points: new Array<Types.Point3>(),\r\n          textBox: {\r\n            hasMoved: false,\r\n            worldPosition: <Types.Point3>[0, 0, 0],\r\n            worldBoundingBox: {\r\n              topLeft: <Types.Point3>[0, 0, 0],\r\n              topRight: <Types.Point3>[0, 0, 0],\r\n              bottomLeft: <Types.Point3>[0, 0, 0],\r\n              bottomRight: <Types.Point3>[0, 0, 0],\r\n            },\r\n          },\r\n        },\r\n        label: '',\r\n      },\r\n    } as unknown as Annotation;\r\n    for (const baseData of annotationBaseData) {\r\n      annotation = csUtils.deepMerge(annotation, baseData);\r\n    }\r\n    return annotation;\r\n  }\r\n\r\n  /**\r\n   * Creates a new annotation for the given viewport.  This just adds the\r\n   * viewport reference data to the metadata, and otherwise returns the\r\n   * static class createAnnotation data.\r\n   */\r\n  public static createAnnotationForViewport(viewport, ...annotationBaseData) {\r\n    return this.createAnnotation(\r\n      { metadata: viewport.getViewReference() },\r\n      ...annotationBaseData\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Creates and adds an annotation of the given type, firing the annotation\r\n   * modified event on the new annotation.\r\n   * This implicitly uses the static class when you call it on the correct\r\n   * base class.  For example, you can call the KeyImageTool.createAnnotation\r\n   * method on KeyImageTool.toolName by calling KeyImageTool.createAndAddAnnotation\r\n   *\r\n   */\r\n  public static createAndAddAnnotation(viewport, ...annotationBaseData) {\r\n    const annotation = this.createAnnotationForViewport(\r\n      viewport,\r\n      ...annotationBaseData\r\n    );\r\n    addAnnotation(annotation, viewport.element);\r\n    triggerAnnotationModified(annotation, viewport.element);\r\n  }\r\n\r\n  static toolName;\r\n  // ===================================================================\r\n  // Abstract Methods - Must be implemented.\r\n  // ===================================================================\r\n\r\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\r\n    super(toolProps, defaultToolProps);\r\n\r\n    if (toolProps.configuration?.getTextLines) {\r\n      this.configuration.getTextLines = toolProps.configuration.getTextLines;\r\n    }\r\n\r\n    if (toolProps.configuration?.statsCalculator) {\r\n      this.configuration.statsCalculator =\r\n        toolProps.configuration.statsCalculator;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @abstract addNewAnnotation Creates a new annotation based on the clicked mouse position\r\n   *\r\n   * @param evt - The normalized mouse event\r\n   * @param interactionType -  The interaction type used to add the annotation.\r\n   */\r\n  abstract addNewAnnotation(\r\n    evt: EventTypes.InteractionEventType,\r\n    interactionType: InteractionTypes\r\n  ): Annotation;\r\n\r\n  /**\r\n   * @abstract cancel Used to cancel the ongoing tool drawing and manipulation\r\n   *\r\n   */\r\n  abstract cancel(element: HTMLDivElement);\r\n\r\n  /**\r\n   * handleSelectedCallback Custom callback for when a handle is selected.\r\n   *\r\n   * @param evt - The normalized mouse event\r\n   * @param annotation - The annotation selected.\r\n   * @param handle - The selected handle (either Types.Point3 in space for annotations, or TextBoxHandle object for text boxes).\r\n   * @param interactionType - The interaction type the handle was selected with.\r\n   */\r\n  abstract handleSelectedCallback(\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: Annotation,\r\n    handle: ToolHandle,\r\n    interactionType: InteractionTypes\r\n  ): void;\r\n\r\n  /**\r\n   * Custom callback for when an annotation is selected\r\n   *\r\n   * @param evt - The normalized mouse event\r\n   * @param annotation - The `Annotation` to check.\r\n   * @param interactionType - The interaction type used to select the tool.\r\n   */\r\n  abstract toolSelectedCallback(\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: Annotation,\r\n    interactionType: InteractionTypes,\r\n    canvasCoords?: Types.Point2\r\n  ): void;\r\n\r\n  /**\r\n   * Returns true if the provided canvas coordinate tool is near the annotation\r\n   *\r\n   * @param element - The HTML element\r\n   * @param annotation - The annotation to check\r\n   * @param canvasCoords - The canvas coordinate to check\r\n   * @param proximity - The minimum proximity to consider the point near\r\n   * @param interactionType - The interaction type used to select the tool.\r\n   *\r\n   * @returns boolean if the point is near.\r\n   */\r\n  abstract isPointNearTool(\r\n    element: HTMLDivElement,\r\n    annotation: Annotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number,\r\n    interactionType: string\r\n  ): boolean;\r\n\r\n  /**\r\n   * @virtual Event handler for Cornerstone MOUSE_MOVE event.\r\n   *\r\n   *\r\n   * @param evt - The normalized mouse event\r\n   * @param filteredAnnotations - The annotations to check for hover interactions\r\n   * @returns True if the annotation needs to be re-drawn by the annotationRenderingEngine.\r\n   */\r\n  public mouseMoveCallback = (\r\n    evt: EventTypes.MouseMoveEventType,\r\n    filteredAnnotations?: Annotations\r\n  ): boolean => {\r\n    if (!filteredAnnotations) {\r\n      return false;\r\n    }\r\n\r\n    const { element, currentPoints } = evt.detail;\r\n    const canvasCoords = currentPoints.canvas;\r\n    let annotationsNeedToBeRedrawn = false;\r\n\r\n    for (const annotation of filteredAnnotations) {\r\n      // Do not do anything if the annotation is locked or hidden.\r\n      if (\r\n        isAnnotationLocked(annotation) ||\r\n        !isAnnotationVisible(annotation.annotationUID)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      const { data } = annotation;\r\n      const activateHandleIndex = data.handles\r\n        ? data.handles.activeHandleIndex\r\n        : undefined;\r\n\r\n      // Perform tool specific imagePointNearToolOrHandle to determine if the mouse\r\n      // is near the tool or its handles or its textBox.\r\n      const near = this._imagePointNearToolOrHandle(\r\n        element,\r\n        annotation,\r\n        canvasCoords,\r\n        6 // Todo: This should come from the state\r\n      );\r\n\r\n      const nearToolAndNotMarkedActive = near && !annotation.highlighted;\r\n      const notNearToolAndMarkedActive = !near && annotation.highlighted;\r\n      if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\r\n        annotation.highlighted = !annotation.highlighted;\r\n        annotationsNeedToBeRedrawn = true;\r\n      } else if (\r\n        data.handles &&\r\n        data.handles.activeHandleIndex !== activateHandleIndex\r\n      ) {\r\n        // Active handle index has changed, re-render.\r\n        annotationsNeedToBeRedrawn = true;\r\n      }\r\n    }\r\n\r\n    return annotationsNeedToBeRedrawn;\r\n  };\r\n\r\n  /**\r\n   * It checks if the mouse click is near TextBoxHandle or AnnotationHandle itself, and\r\n   * return either it. It prioritize TextBoxHandle over AnnotationHandle. If\r\n   * the mouse click is not near any of the handles, it does not return anything.\r\n   *\r\n   * @param element - The element that the tool is attached to.\r\n   * @param annotation - The annotation object associated with the annotation\r\n   * @param canvasCoords - The coordinates of the mouse click on canvas\r\n   * @param proximity - The distance from the mouse cursor to the point\r\n   * that is considered \"near\".\r\n   * @returns The handle that is closest to the cursor, or null if the cursor\r\n   * is not near any of the handles.\r\n   */\r\n  getHandleNearImagePoint(\r\n    element: HTMLDivElement,\r\n    annotation: Annotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): ToolHandle | undefined {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    const { data } = annotation;\r\n    const { isCanvasAnnotation } = data;\r\n    const { points, textBox } = data.handles;\r\n\r\n    if (textBox) {\r\n      const { worldBoundingBox } = textBox;\r\n      if (worldBoundingBox) {\r\n        const canvasBoundingBox = {\r\n          topLeft: viewport.worldToCanvas(worldBoundingBox.topLeft),\r\n          topRight: viewport.worldToCanvas(worldBoundingBox.topRight),\r\n          bottomLeft: viewport.worldToCanvas(worldBoundingBox.bottomLeft),\r\n          bottomRight: viewport.worldToCanvas(worldBoundingBox.bottomRight),\r\n        };\r\n\r\n        if (\r\n          canvasCoords[0] >= canvasBoundingBox.topLeft[0] &&\r\n          canvasCoords[0] <= canvasBoundingBox.bottomRight[0] &&\r\n          canvasCoords[1] >= canvasBoundingBox.topLeft[1] &&\r\n          canvasCoords[1] <= canvasBoundingBox.bottomRight[1]\r\n        ) {\r\n          data.handles.activeHandleIndex = null;\r\n          return textBox as ToolHandle;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i < points?.length; i++) {\r\n      const point = points[i];\r\n      const annotationCanvasCoordinate = isCanvasAnnotation\r\n        ? point.slice(0, 2)\r\n        : viewport.worldToCanvas(point);\r\n\r\n      const near =\r\n        vec2.distance(\r\n          canvasCoords,\r\n          annotationCanvasCoordinate as Types.Point2\r\n        ) < proximity;\r\n\r\n      if (near === true) {\r\n        data.handles.activeHandleIndex = i;\r\n        return point;\r\n      }\r\n    }\r\n\r\n    data.handles.activeHandleIndex = null;\r\n  }\r\n\r\n  /**\r\n   * It returns the style for the text box\r\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\r\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\r\n   * met (hierarchy is checked from most specific to least specific which is\r\n   * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\r\n   * @param annotation - The annotation for the tool that is\r\n   * currently active.\r\n   * @returns An object of the style settings for the text box.\r\n   */\r\n  public getLinkedTextBoxStyle(\r\n    specifications: StyleSpecifier,\r\n    annotation?: Annotation\r\n  ): Record<string, unknown> {\r\n    // Todo: this function can be used to set different styles for different toolMode\r\n    // for the textBox.\r\n\r\n    return {\r\n      visibility: this.getStyle(\r\n        'textBoxVisibility',\r\n        specifications,\r\n        annotation\r\n      ),\r\n      fontFamily: this.getStyle(\r\n        'textBoxFontFamily',\r\n        specifications,\r\n        annotation\r\n      ),\r\n      fontSize: this.getStyle('textBoxFontSize', specifications, annotation),\r\n      color: this.getStyle('textBoxColor', specifications, annotation),\r\n      shadow: this.getStyle('textBoxShadow', specifications, annotation),\r\n      background: this.getStyle(\r\n        'textBoxBackground',\r\n        specifications,\r\n        annotation\r\n      ),\r\n      lineWidth: this.getStyle(\r\n        'textBoxLinkLineWidth',\r\n        specifications,\r\n        annotation\r\n      ),\r\n      lineDash: this.getStyle(\r\n        'textBoxLinkLineDash',\r\n        specifications,\r\n        annotation\r\n      ),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Returns true if the viewport is scaled to SUV units\r\n   * @param viewport - The viewport\r\n   * @param targetId - The annotation targetId\r\n   * @param imageId - The annotation imageId\r\n   * @returns\r\n   */\r\n  isSuvScaled(\r\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\r\n    targetId: string,\r\n    imageId?: string\r\n  ): boolean {\r\n    if (viewport instanceof BaseVolumeViewport) {\r\n      const volumeId = csUtils.getVolumeId(targetId);\r\n      const volume = cache.getVolume(volumeId);\r\n      return volume?.scaling?.PT !== undefined;\r\n    }\r\n    const scalingModule: Types.ScalingParameters | undefined =\r\n      imageId && metaData.get('scalingModule', imageId);\r\n    return typeof scalingModule?.suvbw === 'number';\r\n  }\r\n\r\n  /**\r\n   * Get the style that will be applied to all annotations such as length, cobb\r\n   * angle, arrow annotate, etc. when rendered on a canvas or svg layer\r\n   */\r\n  protected getAnnotationStyle(context: {\r\n    annotation: Annotation;\r\n    styleSpecifier: StyleSpecifier;\r\n  }) {\r\n    const { annotation, styleSpecifier } = context;\r\n    const getStyle = (property) =>\r\n      this.getStyle(property, styleSpecifier, annotation);\r\n    const { annotationUID } = annotation;\r\n    const visibility = isAnnotationVisible(annotationUID);\r\n    const locked = isAnnotationLocked(annotation);\r\n\r\n    const lineWidth = getStyle('lineWidth') as number;\r\n    const lineDash = getStyle('lineDash') as string;\r\n    const color = getStyle('color') as string;\r\n    const shadow = getStyle('shadow') as boolean;\r\n    const textboxStyle = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\r\n\r\n    return {\r\n      visibility,\r\n      locked,\r\n      color,\r\n      lineWidth,\r\n      lineDash,\r\n      lineOpacity: 1,\r\n      fillColor: color,\r\n      fillOpacity: 0,\r\n      shadow,\r\n      textbox: textboxStyle,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Returns true if the `canvasCoords` are near a handle or selectable part of the tool\r\n   *\r\n   * @param element - The HTML element\r\n   * @param annotation - The annotation to check\r\n   * @param canvasCoords - The canvas coordinates to check\r\n   * @param proximity - The proximity to consider\r\n   *\r\n   * @returns If the point is near.\r\n   */\r\n  private _imagePointNearToolOrHandle(\r\n    element: HTMLDivElement,\r\n    annotation: Annotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): boolean {\r\n    // Based on the tool instance type, check if the point is near the tool handles\r\n    const handleNearImagePoint = this.getHandleNearImagePoint(\r\n      element,\r\n      annotation,\r\n      canvasCoords,\r\n      proximity\r\n    );\r\n\r\n    if (handleNearImagePoint) {\r\n      return true;\r\n    }\r\n\r\n    // If the point is not near the handles, check if the point is near the tool\r\n    const toolNewImagePoint = this.isPointNearTool(\r\n      element,\r\n      annotation,\r\n      canvasCoords,\r\n      proximity,\r\n      'mouse'\r\n    );\r\n\r\n    if (toolNewImagePoint) {\r\n      return true;\r\n    }\r\n  }\r\n}\r\n\r\nAnnotationTool.toolName = 'AnnotationTool';\r\nexport default AnnotationTool;\r\n","import { LabelmapConfig } from '../../../types/LabelmapTypes';\r\n\r\nconst defaultLabelmapConfig: LabelmapConfig = {\r\n  renderOutline: true,\r\n  outlineWidthActive: 3,\r\n  outlineWidthInactive: 2,\r\n  activeSegmentOutlineWidthDelta: 0,\r\n  renderFill: true,\r\n  renderFillInactive: true,\r\n  fillAlpha: 0.7,\r\n  fillAlphaInactive: 0.65,\r\n  outlineOpacity: 1,\r\n  outlineOpacityInactive: 0.85,\r\n};\r\n\r\nfunction getDefaultLabelmapConfig(): LabelmapConfig {\r\n  return defaultLabelmapConfig;\r\n}\r\n\r\n// Checks if the labelmap config is valid, which means\r\n// if all the required fields are present and have the correct type\r\nfunction isValidLabelmapConfig(config): boolean {\r\n  return (\r\n    config &&\r\n    typeof config.renderOutline === 'boolean' &&\r\n    typeof config.outlineWidthActive === 'number' &&\r\n    typeof config.outlineWidthInactive === 'number' &&\r\n    typeof config.activeSegmentOutlineWidthDelta === 'number' &&\r\n    typeof config.renderFill === 'boolean' &&\r\n    typeof config.renderFillInactive === 'boolean' &&\r\n    typeof config.fillAlpha === 'number' &&\r\n    typeof config.fillAlphaInactive === 'number' &&\r\n    typeof config.outlineOpacity === 'number' &&\r\n    typeof config.outlineOpacityInactive === 'number'\r\n  );\r\n}\r\n\r\nexport default getDefaultLabelmapConfig;\r\nexport { isValidLabelmapConfig };\r\n","import {\r\n  getEnabledElement,\r\n  cache,\r\n  StackViewport,\r\n  utilities as csUtils,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\r\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\r\n\r\nimport {\r\n  drawHandles as drawHandlesSvg,\r\n  drawRect as drawRectSvg,\r\n} from '../../drawingSvg';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport { hideElementCursor } from '../../cursors/elementCursor';\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\r\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\r\nimport {\r\n  PublicToolProps,\r\n  ToolProps,\r\n  EventTypes,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\nimport { RectangleROIThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\nimport RectangleROITool from '../annotation/RectangleROITool';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\n\r\n/**\r\n * This tool is exactly the RectangleROITool but only draws a rectangle on the image,\r\n * and by using utility functions such as thresholdByRange and thresholdByROIStat it can be used to\r\n * create a segmentation. This tool, however, does not calculate the statistics\r\n * as RectangleROITool does.\r\n */\r\nclass RectangleROIThresholdTool extends RectangleROITool {\r\n  static toolName;\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: string[];\r\n    handleIndex?: number;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        shadow: true,\r\n        preventHandleOutsideImage: false,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the enabledElement it creates\r\n   * the edit data for the tool.\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    const targetId = this.getTargetId(viewport);\r\n    let referencedImageId, volumeId;\r\n\r\n    if (viewport instanceof StackViewport) {\r\n      referencedImageId = targetId.split('imageId:')[1];\r\n    } else {\r\n      volumeId = csUtils.getVolumeId(targetId);\r\n      const imageVolume = cache.getVolume(volumeId);\r\n      referencedImageId = csUtils.getClosestImageId(\r\n        imageVolume,\r\n        worldPos,\r\n        viewPlaneNormal\r\n      );\r\n    }\r\n\r\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n    // Todo: how not to store enabledElement on the annotation, segmentationModule needs the element to\r\n    // decide on the active segmentIndex, active segmentationIndex etc.\r\n    const annotation = {\r\n      highlighted: true,\r\n      invalidated: true,\r\n      metadata: {\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        enabledElement,\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID,\r\n        referencedImageId,\r\n        toolName: this.getToolName(),\r\n        volumeId,\r\n      },\r\n      data: {\r\n        label: '',\r\n        handles: {\r\n          // No need a textBox\r\n          textBox: {\r\n            hasMoved: false,\r\n            worldPosition: null,\r\n            worldBoundingBox: null,\r\n          },\r\n          points: [\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n          ],\r\n          activeHandleIndex: null,\r\n        },\r\n        segmentationId: null,\r\n      },\r\n    };\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex: 3,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n    };\r\n    this._activateDraw(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the RectangleROI Threshold annotation in each\r\n   * request animation frame.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n    let annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    annotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    );\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[i] as RectangleROIThresholdAnnotation;\r\n      const { annotationUID, data } = annotation;\r\n      const { points, activeHandleIndex } = data.handles;\r\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\r\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\r\n      const color = 'rgb(255, 255, 255)'\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n\r\n      // Todo: This is not correct way to add the event trigger,\r\n      // this will trigger on all mouse hover too. Problem is that we don't\r\n      // have a cached stats mechanism for this tool yet?\r\n      triggerAnnotationModified(annotation, element);\r\n\r\n      let activeHandleCanvasCoords;\r\n\r\n      if (!isAnnotationVisible(annotationUID)) {\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        !isAnnotationLocked(annotation) &&\r\n        !this.editData &&\r\n        activeHandleIndex !== null\r\n      ) {\r\n        // Not locked or creating and hovering over handle, so render handle.\r\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\r\n      }\r\n\r\n      if (activeHandleCanvasCoords) {\r\n        const handleGroupUID = '0';\r\n\r\n        drawHandlesSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          handleGroupUID,\r\n          activeHandleCanvasCoords,\r\n          {\r\n            color,\r\n          }\r\n        );\r\n      }\r\n\r\n      const rectangleUID = '0';\r\n      drawRectSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        rectangleUID,\r\n        canvasCoordinates[0],\r\n        canvasCoordinates[3],\r\n        {\r\n          color,\r\n          lineDash,\r\n          lineWidth,\r\n        }\r\n      );\r\n\r\n      renderStatus = true;\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n}\r\n\r\nRectangleROIThresholdTool.toolName = 'RectangleROIThreshold';\r\nexport default RectangleROIThresholdTool;\r\n","import {\r\n  getEnabledElement,\r\n  cache,\r\n  StackViewport,\r\n  metaData,\r\n  utilities as csUtils,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { vec3 } from 'gl-matrix';\r\nimport {\r\n  addAnnotation,\r\n  getAnnotations,\r\n  removeAnnotation,\r\n} from '../../stateManagement';\r\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\r\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\r\nimport {\r\n  drawHandles as drawHandlesSvg,\r\n  drawRect as drawRectSvg,\r\n} from '../../drawingSvg';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport throttle from '../../utilities/throttle';\r\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\r\nimport {\r\n  hideElementCursor,\r\n  resetElementCursor,\r\n} from '../../cursors/elementCursor';\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\nimport { triggerAnnotationCompleted } from '../../stateManagement/annotation/helpers/state';\r\n\r\nimport {\r\n  PublicToolProps,\r\n  ToolProps,\r\n  EventTypes,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\nimport { RectangleROIStartEndThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\nimport RectangleROITool from '../annotation/RectangleROITool';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\nimport { pointInShapeCallback } from '../../utilities/';\r\n\r\nconst { transformWorldToIndex } = csUtils;\r\n\r\n/**\r\n * This tool is similar to the RectangleROIThresholdTool which\r\n * only draws a rectangle on the image, and by using utility functions\r\n * such as thresholdByRange and thresholdByROIStat it can be used to\r\n * create a segmentation. The only difference is that it only acts on the\r\n * acquisition plane and not the 3D volume, and accepts a start and end\r\n * slice, and renders a dashed rectangle on the image between the start and end\r\n * but a solid rectangle on start and end slice. Utility functions should be used\r\n * to modify the start and end slice.\r\n * // Todo: right now only the first slice has grabbable handles, need to make\r\n * // it so that the handles are grabbable on all slices.\r\n */\r\nclass RectangleROIStartEndThresholdTool extends RectangleROITool {\r\n  static toolName;\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: string[];\r\n    handleIndex?: number;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      configuration: {\r\n        numSlicesToPropagate: 10,\r\n        computePointsInsideVolume: false,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n\r\n    this._throttledCalculateCachedStats = throttle(\r\n      this._calculateCachedStatsTool,\r\n      100,\r\n      { trailing: true }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the enabledElement it creates\r\n   * the edit data for the tool.\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    let referencedImageId, imageVolume, volumeId;\r\n    if (viewport instanceof StackViewport) {\r\n      throw new Error('Stack Viewport Not implemented');\r\n    } else {\r\n      const targetId = this.getTargetId(viewport);\r\n      volumeId = csUtils.getVolumeId(targetId);\r\n      imageVolume = cache.getVolume(volumeId);\r\n      referencedImageId = csUtils.getClosestImageId(\r\n        imageVolume,\r\n        worldPos,\r\n        viewPlaneNormal\r\n      );\r\n    }\r\n\r\n    if (!referencedImageId) {\r\n      throw new Error('This tool does not work on non-acquisition planes');\r\n    }\r\n\r\n    const startIndex = viewport.getCurrentImageIdIndex();\r\n    const spacingInNormal = csUtils.getSpacingInNormalDirection(\r\n      imageVolume,\r\n      viewPlaneNormal\r\n    );\r\n\r\n    // We cannot simply add numSlicesToPropagate to startIndex because\r\n    // the order of imageIds can be from top to bottom or bottom to top and\r\n    // we want to make sure it is always propagated in the direction of the\r\n    // view and also to make sure we don't go out of bounds.\r\n    const endIndex = this._getEndSliceIndex(\r\n      imageVolume,\r\n      worldPos,\r\n      spacingInNormal,\r\n      viewPlaneNormal\r\n    );\r\n\r\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n\r\n    const annotation = {\r\n      highlighted: true,\r\n      invalidated: true,\r\n      metadata: {\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        enabledElement,\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID,\r\n        referencedImageId,\r\n        toolName: this.getToolName(),\r\n        volumeId,\r\n        spacingInNormal,\r\n      },\r\n      data: {\r\n        label: '',\r\n        startSlice: startIndex,\r\n        endSlice: endIndex,\r\n        cachedStats: {\r\n          pointsInVolume: [],\r\n          projectionPoints: [],\r\n          projectionPointsImageIds: [referencedImageId],\r\n        },\r\n        handles: {\r\n          // No need a textBox\r\n          textBox: {\r\n            hasMoved: false,\r\n            worldPosition: null,\r\n            worldBoundingBox: null,\r\n          },\r\n          points: [\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n          ],\r\n          activeHandleIndex: null,\r\n        },\r\n        labelmapUID: null,\r\n      },\r\n    };\r\n\r\n    // update the projection points in 3D space, since we are projecting\r\n    // the points to the slice plane, we need to make sure the points are\r\n    // computed for later export\r\n    this._computeProjectionPoints(annotation, imageVolume);\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex: 3,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n    };\r\n    this._activateDraw(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  };\r\n\r\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (newAnnotation && !hasMoved) {\r\n      return;\r\n    }\r\n\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateModify(element);\r\n    this._deactivateDraw(element);\r\n\r\n    resetElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n\r\n    if (\r\n      this.isHandleOutsideImage &&\r\n      this.configuration.preventHandleOutsideImage\r\n    ) {\r\n      removeAnnotation(annotation.annotationUID);\r\n    }\r\n\r\n    const targetId = this.getTargetId(enabledElement.viewport);\r\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\r\n\r\n    if (this.configuration.calculatePointsInsideVolume) {\r\n      this._computePointsInsideVolume(annotation, imageVolume, enabledElement);\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(\r\n      enabledElement.renderingEngine,\r\n      viewportIdsToRender\r\n    );\r\n\r\n    if (newAnnotation) {\r\n      triggerAnnotationCompleted(annotation);\r\n    }\r\n  };\r\n\r\n  // Todo: make it work for planes other than acquisition planes\r\n  _computeProjectionPoints(\r\n    annotation: RectangleROIStartEndThresholdAnnotation,\r\n    imageVolume: Types.IImageVolume\r\n  ): void {\r\n    const { data, metadata } = annotation;\r\n    const { viewPlaneNormal, spacingInNormal } = metadata;\r\n    const { imageData } = imageVolume;\r\n    const { startSlice, endSlice } = data;\r\n    const { points } = data.handles;\r\n\r\n    const startIJK = transformWorldToIndex(imageData, points[0]);\r\n\r\n    if (startIJK[2] !== startSlice) {\r\n      throw new Error('Start slice does not match');\r\n    }\r\n\r\n    // substitute the end slice index 2 with startIJK index 2\r\n    const endIJK = vec3.fromValues(startIJK[0], startIJK[1], endSlice);\r\n\r\n    const startWorld = vec3.create();\r\n    imageData.indexToWorldVec3(startIJK, startWorld);\r\n\r\n    const endWorld = vec3.create();\r\n    imageData.indexToWorldVec3(endIJK, endWorld);\r\n\r\n    // distance between start and end slice in the world coordinate\r\n    const distance = vec3.distance(startWorld, endWorld);\r\n\r\n    // for each point inside points, navigate in the direction of the viewPlaneNormal\r\n    // with amount of spacingInNormal, and calculate the next slice until we reach the distance\r\n    const newProjectionPoints = [];\r\n    for (let dist = 0; dist < distance; dist += spacingInNormal) {\r\n      newProjectionPoints.push(\r\n        points.map((point) => {\r\n          const newPoint = vec3.create();\r\n          vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);\r\n          return Array.from(newPoint);\r\n        })\r\n      );\r\n    }\r\n\r\n    data.cachedStats.projectionPoints = newProjectionPoints;\r\n\r\n    // Find the imageIds for the projection points\r\n    const projectionPointsImageIds = [];\r\n    for (const RectanglePoints of newProjectionPoints) {\r\n      const imageId = csUtils.getClosestImageId(\r\n        imageVolume,\r\n        RectanglePoints[0],\r\n        viewPlaneNormal\r\n      );\r\n      projectionPointsImageIds.push(imageId);\r\n    }\r\n\r\n    data.cachedStats.projectionPointsImageIds = projectionPointsImageIds;\r\n  }\r\n\r\n  //This function return all the points inside the ROI for every slices between startSlice and endSlice\r\n  _computePointsInsideVolume(annotation, imageVolume, enabledElement) {\r\n    const { data } = annotation;\r\n    const projectionPoints = data.cachedStats.projectionPoints;\r\n\r\n    const pointsInsideVolume: Types.Point3[][] = [[]];\r\n\r\n    for (let i = 0; i < projectionPoints.length; i++) {\r\n      // If image does not exists for the targetId, skip. This can be due\r\n      // to various reasons such as if the target was a volumeViewport, and\r\n      // the volumeViewport has been decached in the meantime.\r\n      if (!imageVolume) {\r\n        continue;\r\n      }\r\n\r\n      const projectionPoint = projectionPoints[i][0];\r\n\r\n      const worldPos1 = data.handles.points[0];\r\n      const worldPos2 = data.handles.points[3];\r\n\r\n      const { dimensions, imageData } = imageVolume;\r\n\r\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\r\n      //We only need to change the Z of our bounds so we are getting the Z from the current projection point\r\n      const worldProjectionPointIndex = transformWorldToIndex(\r\n        imageData,\r\n        projectionPoint\r\n      );\r\n\r\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\r\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\r\n      worldPos1Index[2] = Math.floor(worldProjectionPointIndex[2]);\r\n\r\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\r\n\r\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\r\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\r\n      worldPos2Index[2] = Math.floor(worldProjectionPointIndex[2]);\r\n\r\n      // Check if one of the indexes are inside the volume, this then gives us\r\n      // Some area to do stats over.\r\n\r\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\r\n        this.isHandleOutsideImage = false;\r\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\r\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\r\n\r\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\r\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\r\n\r\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\r\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\r\n\r\n        const boundsIJK = [\r\n          [iMin, iMax],\r\n          [jMin, jMax],\r\n          [kMin, kMax],\r\n        ] as [Types.Point2, Types.Point2, Types.Point2];\r\n\r\n        const pointsInShape = pointInShapeCallback(\r\n          imageData,\r\n          () => true,\r\n          null,\r\n          boundsIJK\r\n        );\r\n\r\n        //@ts-ignore\r\n        pointsInsideVolume.push(pointsInShape);\r\n      }\r\n    }\r\n    data.cachedStats.pointsInVolume = pointsInsideVolume;\r\n  }\r\n\r\n  _calculateCachedStatsTool(annotation, enabledElement) {\r\n    const data = annotation.data;\r\n    const { viewport } = enabledElement;\r\n\r\n    const { cachedStats } = data;\r\n    const targetId = this.getTargetId(viewport);\r\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\r\n\r\n    // Todo: this shouldn't be here, this is a performance issue\r\n    // Since we are extending the RectangleROI class, we need to\r\n    // bring the logic for handle to some cachedStats calculation\r\n    this._computeProjectionPoints(annotation, imageVolume);\r\n\r\n    annotation.invalidated = false;\r\n\r\n    // Dispatching annotation modified\r\n    triggerAnnotationModified(annotation, viewport.element);\r\n\r\n    return cachedStats;\r\n  }\r\n\r\n  /**\r\n   * it is used to draw the rectangleROIStartEnd annotation in each\r\n   * request animation frame.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n    const { viewport } = enabledElement;\r\n\r\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const sliceIndex = viewport.getCurrentImageIdIndex();\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[\r\n        i\r\n      ] as RectangleROIStartEndThresholdAnnotation;\r\n      const { annotationUID, data } = annotation;\r\n      const { startSlice, endSlice } = data;\r\n      const { points, activeHandleIndex } = data.handles;\r\n\r\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\r\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\r\n      const color = 'rgb(255, 255, 255)'\r\n      // range of slices to render based on the start and end slice, like\r\n      // np.arange\r\n\r\n      // if indexIJK is outside the start/end slice, we don't render\r\n      if (\r\n        sliceIndex < Math.min(startSlice, endSlice) ||\r\n        sliceIndex > Math.max(startSlice, endSlice)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\r\n\r\n      if (annotation.invalidated) {\r\n        this._throttledCalculateCachedStats(annotation, enabledElement);\r\n      }\r\n\r\n      // if it is inside the start/end slice, but not exactly the first or\r\n      // last slice, we render the line in dash, but not the handles\r\n      let firstOrLastSlice = false;\r\n      if (sliceIndex === startSlice || sliceIndex === endSlice) {\r\n        firstOrLastSlice = true;\r\n      }\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n\r\n      let activeHandleCanvasCoords;\r\n\r\n      if (!isAnnotationVisible(annotationUID)) {\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        !isAnnotationLocked(annotation) &&\r\n        !this.editData &&\r\n        activeHandleIndex !== null &&\r\n        firstOrLastSlice\r\n      ) {\r\n        // Not locked or creating and hovering over handle, so render handle.\r\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\r\n      }\r\n\r\n      if (activeHandleCanvasCoords) {\r\n        const handleGroupUID = '0';\r\n\r\n        drawHandlesSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          handleGroupUID,\r\n          activeHandleCanvasCoords,\r\n          {\r\n            color,\r\n          }\r\n        );\r\n      }\r\n\r\n      let lineDashToUse = lineDash;\r\n\r\n      if (!firstOrLastSlice) {\r\n        lineDashToUse = 2;\r\n      }\r\n\r\n      const rectangleUID = '0';\r\n      drawRectSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        rectangleUID,\r\n        canvasCoordinates[0],\r\n        canvasCoordinates[3],\r\n        {\r\n          color,\r\n          lineDash: lineDashToUse,\r\n          lineWidth,\r\n        }\r\n      );\r\n\r\n      renderStatus = true;\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  _getEndSliceIndex(\r\n    imageVolume: Types.IImageVolume,\r\n    worldPos: Types.Point3,\r\n    spacingInNormal: number,\r\n    viewPlaneNormal: Types.Point3\r\n  ): number | undefined {\r\n    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\r\n\r\n    // get end position by moving from worldPos in the direction of viewplaneNormal\r\n    // with amount of numSlicesToPropagate * spacingInNormal\r\n    const endPos = vec3.create();\r\n    vec3.scaleAndAdd(\r\n      endPos,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      numSlicesToPropagate * spacingInNormal\r\n    );\r\n\r\n    const halfSpacingInNormalDirection = spacingInNormal / 2;\r\n    // Loop through imageIds of the imageVolume and find the one that is closest to endPos\r\n    const { imageIds } = imageVolume;\r\n    let imageIdIndex;\r\n    for (let i = 0; i < imageIds.length; i++) {\r\n      const imageId = imageIds[i];\r\n\r\n      const { imagePositionPatient } = metaData.get(\r\n        'imagePlaneModule',\r\n        imageId\r\n      );\r\n\r\n      const dir = vec3.create();\r\n      vec3.sub(dir, endPos, imagePositionPatient);\r\n\r\n      const dot = vec3.dot(dir, viewPlaneNormal);\r\n\r\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\r\n        imageIdIndex = i;\r\n      }\r\n    }\r\n\r\n    return imageIdIndex;\r\n  }\r\n}\r\n\r\nRectangleROIStartEndThresholdTool.toolName = 'RectangleROIStartEndThreshold';\r\nexport default RectangleROIStartEndThresholdTool;\r\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\r\nimport Events from '../enums/Events';\r\nimport { Annotation } from '../types';\r\n\r\nexport type FramesRange = [number, number] | number;\r\n\r\n/**\r\n * This class handles the annotation frame range values for multiframes.\r\n * Mostly used for the Video viewport, it allows references to\r\n * a range of frame values.\r\n */\r\nexport default class AnnotationFrameRange {\r\n  protected static frameRangeExtractor =\r\n    /(\\/frames\\/|[&?]frameNumber=)([^/&?]*)/i;\r\n\r\n  protected static imageIdToFrames(imageId: string): FramesRange {\r\n    const match = imageId.match(this.frameRangeExtractor);\r\n    if (!match || !match[2]) {\r\n      return null;\r\n    }\r\n    const range = match[2].split('-').map((it) => Number(it));\r\n    if (range.length === 1) {\r\n      return range[0];\r\n    }\r\n    return range as FramesRange;\r\n  }\r\n\r\n  public static framesToString(range) {\r\n    if (Array.isArray(range)) {\r\n      return `${range[0]}-${range[1]}`;\r\n    }\r\n    return String(range);\r\n  }\r\n\r\n  protected static framesToImageId(\r\n    imageId: string,\r\n    range: FramesRange | string\r\n  ): string {\r\n    const match = imageId.match(this.frameRangeExtractor);\r\n    if (!match || !match[2]) {\r\n      return null;\r\n    }\r\n    const newRangeString = this.framesToString(range);\r\n    return imageId.replace(\r\n      this.frameRangeExtractor,\r\n      `${match[1]}${newRangeString}`\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Sets the range of frames to associate with the given annotation.\r\n   * The range can be a single frame number (1 based according to DICOM),\r\n   * or a range of values in the format `min-max` where min, max are inclusive\r\n   * Modifies the referencedImageID to specify the updated URL.\r\n   */\r\n  public static setFrameRange(\r\n    annotation: Annotation,\r\n    range: FramesRange | string,\r\n    eventBase?: { viewportId; renderingEngineId }\r\n  ) {\r\n    const { referencedImageId } = annotation.metadata;\r\n    annotation.metadata.referencedImageId = this.framesToImageId(\r\n      referencedImageId,\r\n      range\r\n    );\r\n    const eventDetail = {\r\n      ...eventBase,\r\n      annotation,\r\n    };\r\n    triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);\r\n  }\r\n\r\n  public static getFrameRange(\r\n    annotation: Annotation\r\n  ): number | [number, number] {\r\n    return this.imageIdToFrames(annotation.metadata.referencedImageId);\r\n  }\r\n}\r\n","import {\r\n  Types,\r\n  utilities,\r\n  BaseVolumeViewport,\r\n  StackViewport,\r\n  cache,\r\n  metaData,\r\n} from '@cornerstonejs/core';\r\nimport { Annotation } from '../types';\r\nimport { addAnnotation } from '../stateManagement';\r\nimport { vec3 } from 'gl-matrix';\r\n\r\nfunction annotationHydration(\r\n  viewport: Types.IViewport,\r\n  toolName: string,\r\n  worldPoints: Types.Point3[],\r\n  options?: {\r\n    FrameOfReferenceUID?: string;\r\n    annotationUID?: string;\r\n  }\r\n): Annotation {\r\n  const viewReference = viewport.getViewReference();\r\n  const { viewPlaneNormal, FrameOfReferenceUID } = viewReference;\r\n  const annotation = {\r\n    annotationUID: options?.annotationUID || utilities.uuidv4(),\r\n    data: {\r\n      handles: {\r\n        points: worldPoints,\r\n      },\r\n    },\r\n    highlighted: false,\r\n    autoGenerated: false,\r\n    invalidated: false,\r\n    isLocked: false,\r\n    isVisible: true,\r\n    metadata: {\r\n      toolName,\r\n      viewPlaneNormal,\r\n      FrameOfReferenceUID,\r\n      referencedImageId: getReferencedImageId(\r\n        viewport,\r\n        worldPoints[0],\r\n        viewPlaneNormal\r\n      ),\r\n      ...options,\r\n    },\r\n  };\r\n  addAnnotation(annotation, viewport.element);\r\n  return annotation;\r\n}\r\n\r\nfunction getReferencedImageId(\r\n  viewport: Types.IViewport,\r\n  worldPos: Types.Point3,\r\n  viewPlaneNormal: Types.Point3\r\n): string {\r\n  let referencedImageId;\r\n\r\n  if (viewport instanceof StackViewport) {\r\n    referencedImageId = getClosestImageIdForStackViewport(\r\n      viewport,\r\n      worldPos,\r\n      viewPlaneNormal\r\n    );\r\n  } else if (viewport instanceof BaseVolumeViewport) {\r\n    const targetId = getTargetId(viewport);\r\n    const volumeId = utilities.getVolumeId(targetId);\r\n    const imageVolume = cache.getVolume(volumeId);\r\n\r\n    referencedImageId = utilities.getClosestImageId(\r\n      imageVolume,\r\n      worldPos,\r\n      viewPlaneNormal\r\n    );\r\n  } else {\r\n    throw new Error(\r\n      'getReferencedImageId: viewport must be a StackViewport or BaseVolumeViewport'\r\n    );\r\n  }\r\n\r\n  return referencedImageId;\r\n}\r\n\r\nfunction getTargetId(viewport: Types.IViewport): string | undefined {\r\n  const targetId = viewport.getReferenceId?.();\r\n  if (targetId) {\r\n    return targetId;\r\n  }\r\n  if (viewport instanceof BaseVolumeViewport) {\r\n    return `volumeId:${getTargetVolumeId(viewport)}`;\r\n  }\r\n  throw new Error('getTargetId: viewport must have a getTargetId method');\r\n}\r\n\r\nfunction getTargetVolumeId(viewport: Types.IViewport): string | undefined {\r\n  const actorEntries = viewport.getActors();\r\n\r\n  if (!actorEntries) {\r\n    return;\r\n  }\r\n  return actorEntries.find(\r\n    (actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume'\r\n  )?.uid;\r\n}\r\n\r\nfunction getClosestImageIdForStackViewport(\r\n  viewport: StackViewport,\r\n  worldPos: Types.Point3,\r\n  viewPlaneNormal: Types.Point3\r\n): string {\r\n  const imageIds = viewport.getImageIds();\r\n  if (!imageIds || !imageIds.length) {\r\n    return;\r\n  }\r\n\r\n  const distanceImagePairs = imageIds.map((imageId) => {\r\n    const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\r\n    const distance = calculateDistanceToImage(\r\n      worldPos,\r\n      imagePositionPatient,\r\n      viewPlaneNormal\r\n    );\r\n    return { imageId, distance };\r\n  });\r\n\r\n  distanceImagePairs.sort((a, b) => a.distance - b.distance);\r\n\r\n  return distanceImagePairs[0].imageId;\r\n}\r\n\r\nfunction calculateDistanceToImage(\r\n  worldPos: Types.Point3,\r\n  ImagePositionPatient: Types.Point3,\r\n  viewPlaneNormal: Types.Point3\r\n): number {\r\n  const dir = vec3.create();\r\n  vec3.sub(dir, worldPos, ImagePositionPatient);\r\n\r\n  const dot = vec3.dot(dir, viewPlaneNormal);\r\n\r\n  return Math.abs(dot);\r\n}\r\nexport { annotationHydration, getClosestImageIdForStackViewport };\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport { CONSTANTS } from '@cornerstonejs/core';\r\n\r\nconst { EPSILON } = CONSTANTS;\r\n\r\n/** Bounding box type */\r\ntype BoundingBox =\r\n  | [Types.Point2, Types.Point2, null]\r\n  | [Types.Point2, Types.Point2, Types.Point2];\r\n\r\nfunction calculateBoundingBox(\r\n  points,\r\n  dimensions,\r\n  isWorld = false\r\n): BoundingBox {\r\n  let xMin = Infinity;\r\n  let xMax = isWorld ? -Infinity : 0;\r\n  let yMin = Infinity;\r\n  let yMax = isWorld ? -Infinity : 0;\r\n  let zMin = Infinity;\r\n  let zMax = isWorld ? -Infinity : 0;\r\n\r\n  const is3D = points[0]?.length === 3;\r\n\r\n  // use for loop for performance\r\n  for (let i = 0; i < points.length; i++) {\r\n    const p = points[i];\r\n    xMin = Math.min(p[0], xMin);\r\n    xMax = Math.max(p[0], xMax);\r\n    yMin = Math.min(p[1], yMin);\r\n    yMax = Math.max(p[1], yMax);\r\n\r\n    if (is3D) {\r\n      zMin = Math.min(p[2] ?? zMin, zMin);\r\n      zMax = Math.max(p[2] ?? zMax, zMax);\r\n    }\r\n  }\r\n\r\n  if (dimensions) {\r\n    xMin = Math.max(isWorld ? dimensions[0] + EPSILON : 0, xMin);\r\n    xMax = Math.min(\r\n      isWorld ? dimensions[0] - EPSILON : dimensions[0] - 1,\r\n      xMax\r\n    );\r\n    yMin = Math.max(isWorld ? dimensions[1] + EPSILON : 0, yMin);\r\n    yMax = Math.min(\r\n      isWorld ? dimensions[1] - EPSILON : dimensions[1] - 1,\r\n      yMax\r\n    );\r\n\r\n    if (is3D && dimensions.length === 3) {\r\n      zMin = Math.max(isWorld ? dimensions[2] + EPSILON : 0, zMin);\r\n      zMax = Math.min(\r\n        isWorld ? dimensions[2] - EPSILON : dimensions[2] - 1,\r\n        zMax\r\n      );\r\n    }\r\n  } else if (!isWorld) {\r\n    // still need to bound to 0 and Infinity if no dimensions are provided for ijk\r\n    xMin = Math.max(0, xMin);\r\n    xMax = Math.min(Infinity, xMax);\r\n    yMin = Math.max(0, yMin);\r\n    yMax = Math.min(Infinity, yMax);\r\n\r\n    if (is3D) {\r\n      zMin = Math.max(0, zMin);\r\n      zMax = Math.min(Infinity, zMax);\r\n    }\r\n  }\r\n\r\n  return is3D\r\n    ? [\r\n        [xMin, xMax],\r\n        [yMin, yMax],\r\n        [zMin, zMax],\r\n      ]\r\n    : [[xMin, xMax], [yMin, yMax], null];\r\n}\r\n\r\n/**\r\n * With a given vertices (points) coordinates in 2D or 3D in IJK, it calculates the minimum and maximum\r\n * coordinate in each axis, and returns them. If clipBounds are provided it also\r\n * clip the min, max to the provided width, height and depth\r\n *\r\n * @param points - shape corner points coordinates either in IJK (image coordinate)\r\n * @param dimensions - bounds to clip the min, max\r\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\r\n */\r\nexport function getBoundingBoxAroundShapeIJK(\r\n  points: Types.Point2[] | Types.Point3[],\r\n  dimensions?: Types.Point2 | Types.Point3\r\n): BoundingBox {\r\n  return calculateBoundingBox(points, dimensions, false);\r\n}\r\n\r\n/**\r\n * With a given vertices (points) coordinates in 2D or 3D in World Coordinates, it calculates the minimum and maximum\r\n * coordinate in each axis, and returns them. If clipBounds are provided it also\r\n * clip the min, max to the provided width, height and depth\r\n *\r\n * @param points - shape corner points coordinates either in IJK (image coordinate)\r\n * @param clipBounds - bounds to clip the min, max\r\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\r\n */\r\nexport function getBoundingBoxAroundShapeWorld(\r\n  points: Types.Point2[] | Types.Point3[],\r\n  clipBounds?: Types.Point2 | Types.Point3\r\n): BoundingBox {\r\n  return calculateBoundingBox(points, clipBounds, true);\r\n}\r\n","import { utilities, Enums } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nconst { calibratedPixelSpacingMetadataProvider } = utilities;\r\n\r\n/**\r\n * It adds the provided spacing to the Cornerstone internal calibratedPixelSpacing\r\n * metadata provider, then it invalidates all the tools that have the imageId as\r\n * their reference imageIds. Finally, it triggers a re-render for invalidated annotations.\r\n * @param imageId - ImageId for the calibrated image\r\n * @param rowPixelSpacing - Spacing in row direction\r\n * @param calibrationOrScale - either the calibration object or a scale value\r\n */\r\nexport default function calibrateImageSpacing(\r\n  imageId: string,\r\n  renderingEngine: Types.IRenderingEngine,\r\n  calibrationOrScale: Types.IImageCalibration | number\r\n): void {\r\n  // Handle simple parameter version\r\n  if (typeof calibrationOrScale === 'number') {\r\n    calibrationOrScale = {\r\n      type: Enums.CalibrationTypes.USER,\r\n      scale: calibrationOrScale,\r\n    };\r\n  }\r\n  // 1. Add the calibratedPixelSpacing metadata to the metadata\r\n  calibratedPixelSpacingMetadataProvider.add(imageId, calibrationOrScale);\r\n\r\n  // 2. Update the actor for stackViewports\r\n  const viewports = renderingEngine.getStackViewports();\r\n\r\n  // 2.1 If imageId is already being used in a stackViewport -> update actor\r\n  viewports.forEach((viewport) => {\r\n    const imageIds = viewport.getImageIds();\r\n    if (imageIds.includes(imageId)) {\r\n      viewport.calibrateSpacing(imageId);\r\n    }\r\n  });\r\n\r\n  // 2.2 If imageId is cached but not being displayed in a viewport, stackViewport\r\n  // will handle using the calibratedPixelSpacing since it has been added\r\n  // to the provider\r\n}\r\n","/**\r\n * CINE Tool Events\r\n */\r\nenum Events {\r\n  CLIP_STOPPED = 'CORNERSTONE_CINE_TOOL_STOPPED',\r\n  CLIP_STARTED = 'CORNERSTONE_CINE_TOOL_STARTED',\r\n}\r\n\r\nexport default Events;\r\n","import { glMatrix, vec3 } from 'gl-matrix';\r\nimport {\r\n  utilities as csUtils,\r\n  getEnabledElement,\r\n  StackViewport,\r\n  VolumeViewport,\r\n  cache,\r\n  BaseVolumeViewport,\r\n  Enums,\r\n} from '@cornerstonejs/core';\r\n\r\nimport { Types } from '@cornerstonejs/core';\r\nimport CINE_EVENTS from './events';\r\nimport { addToolState, getToolState, getToolStateByViewportId } from './state';\r\nimport { CINETypes } from '../../types';\r\nimport scroll from '../scroll';\r\n\r\nconst { ViewportStatus } = Enums;\r\nconst { triggerEvent } = csUtils;\r\n\r\nconst debounced = true;\r\nconst dynamicVolumesPlayingMap = new Map();\r\n\r\n/**\r\n * Starts playing a clip or adjusts the frame rate of an already playing clip.  framesPerSecond is\r\n * optional and defaults to 30 if not specified.  A negative framesPerSecond will play the clip in reverse.\r\n * The element must be a stack of images\r\n * @param element - HTML Element\r\n * @param framesPerSecond - Number of frames per second\r\n */\r\nfunction playClip(\r\n  element: HTMLDivElement,\r\n  playClipOptions: CINETypes.PlayClipOptions\r\n): void {\r\n  let playClipTimeouts;\r\n  let playClipIsTimeVarying;\r\n\r\n  if (element === undefined) {\r\n    throw new Error('playClip: element must not be undefined');\r\n  }\r\n\r\n  const enabledElement = getEnabledElement(element);\r\n\r\n  if (!enabledElement) {\r\n    throw new Error(\r\n      'playClip: element must be a valid Cornerstone enabled element'\r\n    );\r\n  }\r\n\r\n  if (!playClipOptions) {\r\n    playClipOptions = {};\r\n  }\r\n\r\n  // 4D Cine is enabled by default\r\n  playClipOptions.dynamicCineEnabled =\r\n    playClipOptions.dynamicCineEnabled ?? true;\r\n\r\n  const { viewport } = enabledElement;\r\n  const volume = _getVolumeFromViewport(viewport);\r\n  const playClipContext = _createCinePlayContext(viewport, playClipOptions);\r\n  let playClipData = getToolState(element);\r\n\r\n  const isDynamicCinePlaying =\r\n    playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume();\r\n\r\n  // If user is trying to play CINE for a 4D volume it first needs\r\n  // to stop CINE that has may be playing for any other viewport.\r\n  if (isDynamicCinePlaying) {\r\n    _stopDynamicVolumeCine(element);\r\n  }\r\n\r\n  if (!playClipData) {\r\n    playClipData = {\r\n      intervalId: undefined,\r\n      framesPerSecond: 30,\r\n      lastFrameTimeStamp: undefined,\r\n      ignoreFrameTimeVector: false,\r\n      usingFrameTimeVector: false,\r\n      frameTimeVector: playClipOptions.frameTimeVector ?? undefined,\r\n      speed: playClipOptions.frameTimeVectorSpeedMultiplier ?? 1,\r\n      reverse: playClipOptions.reverse ?? false,\r\n      loop: playClipOptions.loop ?? true,\r\n    };\r\n    addToolState(element, playClipData);\r\n  } else {\r\n    // Make sure the specified clip is not running before any property update.\r\n    // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\r\n    // prevent stopping a 4D CINE in case it is playing on another viewport.\r\n    _stopClip(element, {\r\n      stopDynamicCine: !isDynamicCinePlaying,\r\n      viewportId: viewport.id,\r\n    });\r\n  }\r\n\r\n  playClipData.dynamicCineEnabled = playClipOptions.dynamicCineEnabled;\r\n\r\n  // If a framesPerSecond is specified and is valid, update the playClipData now\r\n  if (\r\n    playClipOptions.framesPerSecond < 0 ||\r\n    playClipOptions.framesPerSecond > 0\r\n  ) {\r\n    playClipData.framesPerSecond = Number(playClipOptions.framesPerSecond);\r\n    playClipData.reverse = playClipData.framesPerSecond < 0;\r\n    // If framesPerSecond is given, frameTimeVector will be ignored...\r\n    playClipData.ignoreFrameTimeVector = true;\r\n  }\r\n\r\n  // Determine if frame time vector should be used instead of a fixed frame rate...\r\n  if (\r\n    playClipData.ignoreFrameTimeVector !== true &&\r\n    playClipData.frameTimeVector &&\r\n    playClipData.frameTimeVector.length === playClipContext.numScrollSteps &&\r\n    playClipContext.frameTimeVectorEnabled\r\n  ) {\r\n    const { timeouts, isTimeVarying } = _getPlayClipTimeouts(\r\n      playClipData.frameTimeVector,\r\n      playClipData.speed\r\n    );\r\n\r\n    playClipTimeouts = timeouts;\r\n    playClipIsTimeVarying = isTimeVarying;\r\n  }\r\n\r\n  // This function encapsulates the frame rendering logic...\r\n  const playClipAction = () => {\r\n    const { numScrollSteps, currentStepIndex } = playClipContext;\r\n    let newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);\r\n    const newStepIndexOutOfRange =\r\n      newStepIndex < 0 || newStepIndex >= numScrollSteps;\r\n\r\n    if (!playClipData.loop && newStepIndexOutOfRange) {\r\n      // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\r\n      // prevent stopping a 4D CINE in case it is playing on another viewport.\r\n      _stopClip(element, {\r\n        stopDynamicCine: !isDynamicCinePlaying,\r\n        viewportId: viewport.id,\r\n      });\r\n\r\n      const eventDetail = { element };\r\n\r\n      triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, eventDetail);\r\n      return;\r\n    }\r\n\r\n    // Loop around if newStepIndex is out of range\r\n    if (newStepIndex >= numScrollSteps) {\r\n      newStepIndex = 0;\r\n    } else if (newStepIndex < 0) {\r\n      newStepIndex = numScrollSteps - 1;\r\n    }\r\n\r\n    const delta = newStepIndex - currentStepIndex;\r\n\r\n    if (delta) {\r\n      playClipContext.scroll(delta);\r\n    }\r\n  };\r\n\r\n  if (isDynamicCinePlaying) {\r\n    dynamicVolumesPlayingMap.set(volume.volumeId, element);\r\n  }\r\n\r\n  // If playClipTimeouts array is available, not empty and its elements are NOT uniform ...\r\n  // ... (at least one timeout is different from the others), use alternate setTimeout implementation\r\n  if (\r\n    playClipTimeouts &&\r\n    playClipTimeouts.length > 0 &&\r\n    playClipIsTimeVarying\r\n  ) {\r\n    playClipData.usingFrameTimeVector = true;\r\n    playClipData.intervalId = window.setTimeout(\r\n      function playClipTimeoutHandler() {\r\n        playClipData.intervalId = window.setTimeout(\r\n          playClipTimeoutHandler,\r\n          playClipTimeouts[playClipContext.currentStepIndex]\r\n        );\r\n        playClipAction();\r\n      },\r\n      0\r\n    );\r\n  } else {\r\n    // ... otherwise user setInterval implementation which is much more efficient.\r\n    playClipData.usingFrameTimeVector = false;\r\n    playClipData.intervalId = window.setInterval(\r\n      playClipAction,\r\n      1000 / Math.abs(playClipData.framesPerSecond)\r\n    );\r\n  }\r\n\r\n  const eventDetail = {\r\n    element,\r\n  };\r\n\r\n  triggerEvent(element, CINE_EVENTS.CLIP_STARTED, eventDetail);\r\n}\r\n\r\n/**\r\n * Stops an already playing clip.\r\n * @param element - HTML Element\r\n */\r\nfunction stopClip(element: HTMLDivElement, options = {} as any): void {\r\n  _stopClip(element, {\r\n    stopDynamicCine: true,\r\n    ...options,\r\n  });\r\n}\r\n\r\nfunction _stopClip(\r\n  element: HTMLDivElement,\r\n  options = { stopDynamicCine: true, viewportId: undefined }\r\n) {\r\n  const { stopDynamicCine, viewportId } = options;\r\n  const enabledElement = getEnabledElement(element);\r\n\r\n  let toolState;\r\n  if (!enabledElement) {\r\n    if (viewportId) {\r\n      toolState = getToolStateByViewportId(viewportId);\r\n    } else {\r\n      return;\r\n    }\r\n  } else {\r\n    const { viewport } = enabledElement;\r\n    toolState = getToolState(viewport.element);\r\n  }\r\n\r\n  if (toolState) {\r\n    _stopClipWithData(toolState);\r\n  }\r\n\r\n  if (\r\n    stopDynamicCine &&\r\n    enabledElement?.viewport instanceof BaseVolumeViewport\r\n  ) {\r\n    _stopDynamicVolumeCine(element);\r\n  }\r\n}\r\n\r\n/**\r\n * [private] Stops any CINE playing for the dynamic volume loaded on this viewport\r\n * @param element - HTML Element\r\n */\r\nfunction _stopDynamicVolumeCine(element) {\r\n  const { viewport } = getEnabledElement(element);\r\n  const volume = _getVolumeFromViewport(viewport);\r\n\r\n  // If the current viewport has a 4D volume loaded it may be playing\r\n  // if it is also loaded on another viewport and user has started CINE\r\n  // for that one. This guarantees the other viewport will also be stopped.\r\n  if (volume?.isDynamicVolume()) {\r\n    const dynamicCineElement = dynamicVolumesPlayingMap.get(volume.volumeId);\r\n\r\n    dynamicVolumesPlayingMap.delete(volume.volumeId);\r\n\r\n    if (dynamicCineElement && dynamicCineElement !== element) {\r\n      stopClip(<HTMLDivElement>dynamicCineElement);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * [private] Turns a Frame Time Vector (0018,1065) array into a normalized array of timeouts. Each element\r\n * ... of the resulting array represents the amount of time each frame will remain on the screen.\r\n * @param vector - A Frame Time Vector (0018,1065) as specified in section C.7.6.5.1.2 of DICOM standard.\r\n * @param speed - A speed factor which will be applied to each element of the resulting array.\r\n * @returns An array with timeouts for each animation frame.\r\n */\r\nfunction _getPlayClipTimeouts(vector: number[], speed: number) {\r\n  let i;\r\n  let sample;\r\n  let delay;\r\n  let sum = 0;\r\n  const limit = vector.length;\r\n  const timeouts = [];\r\n\r\n  // Initialize time varying to false\r\n  let isTimeVarying = false;\r\n\r\n  if (typeof speed !== 'number' || speed <= 0) {\r\n    speed = 1;\r\n  }\r\n\r\n  // First element of a frame time vector must be discarded\r\n  for (i = 1; i < limit; i++) {\r\n    // eslint-disable-next-line no-bitwise\r\n    delay = (Number(vector[i]) / speed) | 0; // Integral part only\r\n    timeouts.push(delay);\r\n    if (i === 1) {\r\n      // Use first item as a sample for comparison\r\n      sample = delay;\r\n    } else if (delay !== sample) {\r\n      isTimeVarying = true;\r\n    }\r\n\r\n    sum += delay;\r\n  }\r\n\r\n  if (timeouts.length > 0) {\r\n    if (isTimeVarying) {\r\n      // If it's a time varying vector, make the last item an average...\r\n      // eslint-disable-next-line no-bitwise\r\n      delay = (sum / timeouts.length) | 0;\r\n    } else {\r\n      delay = timeouts[0];\r\n    }\r\n\r\n    timeouts.push(delay);\r\n  }\r\n\r\n  return { timeouts, isTimeVarying };\r\n}\r\n\r\n/**\r\n * [private] Performs the heavy lifting of stopping an ongoing animation.\r\n * @param element - HTML Element\r\n * @param playClipData - The data from playClip that needs to be stopped.\r\n */\r\nfunction _stopClipWithData(playClipData) {\r\n  const id = playClipData.intervalId;\r\n\r\n  if (typeof id !== 'undefined') {\r\n    playClipData.intervalId = undefined;\r\n    if (playClipData.usingFrameTimeVector) {\r\n      clearTimeout(id);\r\n    } else {\r\n      clearInterval(id);\r\n    }\r\n  }\r\n}\r\n\r\nfunction _getVolumesFromViewport(viewport): Types.IImageVolume[] {\r\n  return viewport\r\n    .getActors()\r\n    .map((actor) => cache.getVolume(actor.uid))\r\n    .filter((volume) => !!volume);\r\n}\r\n\r\nfunction _getVolumeFromViewport(viewport): Types.IImageVolume {\r\n  const volumes = _getVolumesFromViewport(viewport);\r\n  const dynamicVolume = volumes.find((volume) => volume.isDynamicVolume());\r\n\r\n  return dynamicVolume ?? volumes[0];\r\n}\r\n\r\nfunction _createStackViewportCinePlayContext(\r\n  viewport: StackViewport,\r\n  waitForRendered: number\r\n): CINETypes.CinePlayContext {\r\n  const imageIds = viewport.getImageIds();\r\n\r\n  return {\r\n    get numScrollSteps(): number {\r\n      return imageIds.length;\r\n    },\r\n    get currentStepIndex(): number {\r\n      return viewport.getTargetImageIdIndex();\r\n    },\r\n    get frameTimeVectorEnabled(): boolean {\r\n      // It is always in acquired orientation\r\n      return true;\r\n    },\r\n    waitForRenderedCount: 0,\r\n    scroll(delta: number): void {\r\n      if (\r\n        this.waitForRenderedCount <= waitForRendered &&\r\n        viewport.viewportStatus !== ViewportStatus.RENDERED\r\n      ) {\r\n        this.waitForRenderedCount++;\r\n        return;\r\n      }\r\n      this.waitForRenderedCount = 0;\r\n      scroll(viewport, { delta, debounceLoading: debounced });\r\n    },\r\n  };\r\n}\r\n\r\nfunction _createVolumeViewportCinePlayContext(\r\n  viewport: VolumeViewport,\r\n  volume: Types.IImageVolume\r\n): CINETypes.CinePlayContext {\r\n  const { volumeId } = volume;\r\n  const cachedScrollInfo = {\r\n    viewPlaneNormal: vec3.create(),\r\n    scrollInfo: null,\r\n  };\r\n\r\n  const getScrollInfo = () => {\r\n    const camera = viewport.getCamera();\r\n    const updateCache =\r\n      !cachedScrollInfo.scrollInfo ||\r\n      !vec3.equals(camera.viewPlaneNormal, cachedScrollInfo.viewPlaneNormal);\r\n\r\n    // Number of steps would change only after rotating the volume so it\r\n    // caches the result and recomputes only when necessary. Until it is\r\n    // rotated the current frame is updated locally\r\n    if (updateCache) {\r\n      const scrollInfo = csUtils.getVolumeViewportScrollInfo(\r\n        viewport,\r\n        volumeId\r\n      );\r\n\r\n      cachedScrollInfo.viewPlaneNormal = camera.viewPlaneNormal;\r\n      cachedScrollInfo.scrollInfo = scrollInfo;\r\n    }\r\n\r\n    return cachedScrollInfo.scrollInfo;\r\n  };\r\n\r\n  return {\r\n    get numScrollSteps(): number {\r\n      return getScrollInfo().numScrollSteps;\r\n    },\r\n    get currentStepIndex(): number {\r\n      return getScrollInfo().currentStepIndex;\r\n    },\r\n    get frameTimeVectorEnabled(): boolean {\r\n      const camera = viewport.getCamera();\r\n      const volumeViewPlaneNormal = volume.direction\r\n        .slice(6, 9)\r\n        .map((x) => -x) as Types.Point3;\r\n      const dot = vec3.dot(volumeViewPlaneNormal, camera.viewPlaneNormal);\r\n\r\n      // Check if the volume is in acquired orientation\r\n      // it may be flipped or rotated in plane\r\n      return glMatrix.equals(dot, 1);\r\n    },\r\n    scroll(delta: number): void {\r\n      getScrollInfo().currentStepIndex += delta;\r\n      scroll(viewport, { delta });\r\n    },\r\n  };\r\n}\r\n\r\nfunction _createDynamicVolumeViewportCinePlayContext(\r\n  volume: Types.IDynamicImageVolume\r\n): CINETypes.CinePlayContext {\r\n  return {\r\n    get numScrollSteps(): number {\r\n      return volume.numTimePoints;\r\n    },\r\n    get currentStepIndex(): number {\r\n      return volume.timePointIndex;\r\n    },\r\n    get frameTimeVectorEnabled(): boolean {\r\n      // Looping throught time does not uses frameTimeVector\r\n      return false;\r\n    },\r\n    scroll(delta: number): void {\r\n      // Updating this property (setter) makes it move to the desired time point\r\n      volume.timePointIndex += delta;\r\n    },\r\n  };\r\n}\r\n\r\nfunction _createCinePlayContext(\r\n  viewport,\r\n  playClipOptions: CINETypes.PlayClipOptions\r\n): CINETypes.CinePlayContext {\r\n  if (viewport instanceof StackViewport) {\r\n    return _createStackViewportCinePlayContext(\r\n      viewport,\r\n      playClipOptions.waitForRendered ?? 30\r\n    );\r\n  }\r\n\r\n  if (viewport instanceof VolumeViewport) {\r\n    const volume = _getVolumeFromViewport(viewport);\r\n\r\n    if (playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume()) {\r\n      return _createDynamicVolumeViewportCinePlayContext(\r\n        <Types.IDynamicImageVolume>volume\r\n      );\r\n    }\r\n\r\n    return _createVolumeViewportCinePlayContext(viewport, volume);\r\n  }\r\n\r\n  throw new Error('Unknown viewport type');\r\n}\r\n\r\nexport { playClip, stopClip };\r\n","/**\r\n * Clips a value to an upper and lower bound.\r\n * @export @public @method\r\n * @name clip\r\n *\r\n * @param  {number} val  The value to clip.\r\n * @param  {number} low  The lower bound.\r\n * @param  {number} high The upper bound.\r\n * @returns {number}      The clipped value.\r\n */\r\nexport function clip(val, low, high) {\r\n  return Math.min(Math.max(low, val), high);\r\n}\r\n\r\n/**\r\n * Clips a value within a box.\r\n * @export @public @method\r\n * @name clipToBox\r\n *\r\n * @param  {Object} point The point to clip\r\n * @param  {Object} box   The bounding box to clip to.\r\n * @returns {Object}       The clipped point.\r\n */\r\nexport function clipToBox(point, box) {\r\n  // Clip an {x, y} point to a box of size {width, height}\r\n  point.x = clip(point.x, 0, box.width);\r\n  point.y = clip(point.y, 0, box.height);\r\n}\r\n\r\nexport default clip;\r\n","import { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\r\nimport { ContourSegmentationAnnotation } from '../../types';\r\n\r\n/**\r\n * Adds a contour segmentation annotation to the specified segmentation.\r\n * @param annotation - The contour segmentation annotation to add.\r\n */\r\nexport function addContourSegmentationAnnotation(\r\n  annotation: ContourSegmentationAnnotation\r\n) {\r\n  if (annotation.parentAnnotationUID) {\r\n    // Don't add it for parent annotations - this happens during interpolation\r\n    return;\r\n  }\r\n  if (!annotation.data.segmentation) {\r\n    throw new Error(\r\n      'addContourSegmentationAnnotation: annotation does not have a segmentation data'\r\n    );\r\n  }\r\n\r\n  const { segmentationId, segmentIndex } = annotation.data.segmentation;\r\n  const segmentation = getSegmentation(segmentationId);\r\n\r\n  if (!segmentation.representationData.CONTOUR) {\r\n    segmentation.representationData.CONTOUR = { annotationUIDsMap: new Map() };\r\n  }\r\n\r\n  const { annotationUIDsMap } = segmentation.representationData.CONTOUR;\r\n\r\n  let annotationsUIDsSet = annotationUIDsMap.get(segmentIndex);\r\n\r\n  if (!annotationsUIDsSet) {\r\n    annotationsUIDsSet = new Set();\r\n    annotationUIDsMap.set(segmentIndex, annotationsUIDsSet);\r\n  }\r\n\r\n  annotationUIDsMap.set(\r\n    segmentIndex,\r\n    annotationsUIDsSet.add(annotation.annotationUID)\r\n  );\r\n}\r\n","import { state } from '../../stateManagement/segmentation';\r\nimport { ContourSegmentationAnnotation } from '../../types';\r\n\r\n/**\r\n * Removes a contour segmentation annotation from the given annotation.\r\n * If the annotation does not have a segmentation data, this method returns\r\n * quietly.  This can occur for interpolated segmentations that have not yet\r\n * been converted to real segmentations or other in-process segmentations.\r\n * @param annotation - The contour segmentation annotation to remove.\r\n */\r\nexport function removeContourSegmentationAnnotation(\r\n  annotation: ContourSegmentationAnnotation\r\n) {\r\n  if (!annotation.data.segmentation) {\r\n    throw new Error(\r\n      'removeContourSegmentationAnnotation: annotation does not have a segmentation data'\r\n    );\r\n  }\r\n\r\n  const { segmentationId, segmentIndex } = annotation.data.segmentation;\r\n  const segmentation = state.getSegmentation(segmentationId);\r\n  const { annotationUIDsMap } = segmentation?.representationData.CONTOUR || {};\r\n  const annotationsUIDsSet = annotationUIDsMap?.get(segmentIndex);\r\n\r\n  if (!annotationsUIDsSet) {\r\n    return;\r\n  }\r\n\r\n  annotationsUIDsSet.delete(annotation.annotationUID);\r\n\r\n  // Delete segmentIndex Set if there is no more annotations\r\n  if (!annotationsUIDsSet.size) {\r\n    annotationUIDsMap.delete(segmentIndex);\r\n  }\r\n}\r\n","/**\r\n * Calculates the perimeter of a polyline.\r\n *\r\n * @param polyline - The polyline represented as an array of points.\r\n * @param closed - Indicates whether the polyline is closed or not.\r\n * @returns The perimeter of the polyline.\r\n */\r\nfunction calculatePerimeter(polyline: number[][], closed: boolean): number {\r\n  let perimeter = 0;\r\n\r\n  for (let i = 0; i < polyline.length - 1; i++) {\r\n    const point1 = polyline[i];\r\n    const point2 = polyline[i + 1];\r\n    perimeter += Math.sqrt(\r\n      Math.pow(point2[0] - point1[0], 2) + Math.pow(point2[1] - point1[1], 2)\r\n    );\r\n  }\r\n\r\n  if (closed) {\r\n    const firstPoint = polyline[0];\r\n    const lastPoint = polyline[polyline.length - 1];\r\n    perimeter += Math.sqrt(\r\n      Math.pow(lastPoint[0] - firstPoint[0], 2) +\r\n        Math.pow(lastPoint[1] - firstPoint[1], 2)\r\n    );\r\n  }\r\n\r\n  return perimeter;\r\n}\r\n\r\nexport default calculatePerimeter;\r\n","import { utilities as csUtils } from '@cornerstonejs/core';\r\nimport { vec3 } from 'gl-matrix';\r\n\r\nimport { ContourAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\n\r\nconst { isEqual } = csUtils;\r\n\r\n/**\r\n * Finds the index in the polyline of the specified handle.  If the handle\r\n * doesn't match a polyline point, then finds the closest polyline point.\r\n *\r\n * Assumes polyline is in the same orientation as the handles.\r\n *\r\n * @param annotation - to find the polyline and handles in\r\n * @param handleIndex - the index of hte handle to look for.\r\n *     Negative values are treated relative to the end of the handle index.\r\n * @returns Index in polyline of the closest handle\r\n *     * 0 for handleIndex 0\r\n *     * length for `handleIndex===handles length`\r\n */\r\nexport default function findHandlePolylineIndex(\r\n  annotation: ContourAnnotation,\r\n  handleIndex: number\r\n): number {\r\n  const { polyline } = annotation.data.contour;\r\n  const { points } = annotation.data.handles;\r\n  const { length } = points;\r\n  if (handleIndex === length) {\r\n    return polyline.length;\r\n  }\r\n  if (handleIndex < 0) {\r\n    handleIndex = (handleIndex + length) % length;\r\n  }\r\n  if (handleIndex === 0) {\r\n    return 0;\r\n  }\r\n  const handle = points[handleIndex];\r\n  const index = polyline.findIndex((point) => isEqual(handle, point));\r\n  if (index !== -1) {\r\n    return index;\r\n  }\r\n  // Need to find nearest\r\n  let closestDistance = Infinity;\r\n  return polyline.reduce((closestIndex, point, testIndex) => {\r\n    const distance = vec3.squaredDistance(point, handle);\r\n    if (distance < closestDistance) {\r\n      closestDistance = distance;\r\n      return testIndex;\r\n    }\r\n    return closestIndex;\r\n  }, -1);\r\n}\r\n","import { cache as cornerstoneCache } from '@cornerstonejs/core';\r\nimport vtkImageMarchingSquares from '@kitware/vtk.js/Filters/General/ImageMarchingSquares';\r\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\r\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\r\n\r\nimport { getDeduplicatedVTKPolyDataPoints } from '../contours';\r\nimport { findContoursFromReducedSet } from './contourFinder';\r\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\r\n\r\nconst { Labelmap } = SegmentationRepresentations;\r\n\r\nfunction generateContourSetsFromLabelmap({ segmentations }) {\r\n  const { representationData, segments = [0, 1] } = segmentations;\r\n  const { volumeId: segVolumeId } = representationData[Labelmap];\r\n\r\n  // Get segmentation volume\r\n  const vol = cornerstoneCache.getVolume(segVolumeId);\r\n  if (!vol) {\r\n    console.warn(`No volume found for ${segVolumeId}`);\r\n    return;\r\n  }\r\n\r\n  const numSlices = vol.dimensions[2];\r\n\r\n  // NOTE: Workaround for marching squares not finding closed contours at\r\n  // boundary of image volume, clear pixels along x-y border of volume\r\n  const segData = vol.imageData.getPointData().getScalars().getData();\r\n  const pixelsPerSlice = vol.dimensions[0] * vol.dimensions[1];\r\n\r\n  for (let z = 0; z < numSlices; z++) {\r\n    for (let y = 0; y < vol.dimensions[1]; y++) {\r\n      const index = y * vol.dimensions[0] + z * pixelsPerSlice;\r\n      segData[index] = 0;\r\n      segData[index + vol.dimensions[0] - 1] = 0;\r\n    }\r\n  }\r\n\r\n  // end workaround\r\n  //\r\n  //\r\n  const ContourSets = [];\r\n\r\n  const { FrameOfReferenceUID } = vol.metadata;\r\n  // Iterate through all segments in current segmentation set\r\n  const numSegments = segments.length;\r\n  for (let segIndex = 0; segIndex < numSegments; segIndex++) {\r\n    const segment = segments[segIndex];\r\n\r\n    // Skip empty segments\r\n    if (!segment) {\r\n      continue;\r\n    }\r\n\r\n    const sliceContours = [];\r\n    const scalars = vtkDataArray.newInstance({\r\n      name: 'Scalars',\r\n      numberOfComponents: 1,\r\n      size: pixelsPerSlice * numSlices,\r\n      dataType: 'Uint8Array',\r\n    });\r\n    const { containedSegmentIndices } = segment;\r\n    for (let sliceIndex = 0; sliceIndex < numSlices; sliceIndex++) {\r\n      // Check if the slice is empty before running marching cube\r\n      if (\r\n        isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex)\r\n      ) {\r\n        continue;\r\n      }\r\n      const frameStart = sliceIndex * pixelsPerSlice;\r\n\r\n      try {\r\n        // Modify segData for this specific segment directly\r\n        for (let i = 0; i < pixelsPerSlice; i++) {\r\n          const value = segData[i + frameStart];\r\n          if (value === segIndex || containedSegmentIndices?.has(value)) {\r\n            (scalars as any).setValue(i + frameStart, 1);\r\n          } else {\r\n            (scalars as any).setValue(i, 0);\r\n          }\r\n        }\r\n\r\n        const mSquares = vtkImageMarchingSquares.newInstance({\r\n          slice: sliceIndex,\r\n        });\r\n\r\n        // filter out the scalar data so that only it has background and\r\n        // the current segment index\r\n        const imageDataCopy = vtkImageData.newInstance();\r\n\r\n        imageDataCopy.shallowCopy(vol.imageData);\r\n        imageDataCopy.getPointData().setScalars(scalars);\r\n\r\n        // Connect pipeline\r\n        mSquares.setInputData(imageDataCopy);\r\n        const cValues = [1];\r\n        mSquares.setContourValues(cValues);\r\n        mSquares.setMergePoints(false);\r\n\r\n        // Perform marching squares\r\n        const msOutput = mSquares.getOutputData();\r\n\r\n        // Clean up output from marching squares\r\n        const reducedSet = getDeduplicatedVTKPolyDataPoints(msOutput);\r\n        if (reducedSet.points?.length) {\r\n          const contours = findContoursFromReducedSet(reducedSet.lines);\r\n\r\n          sliceContours.push({\r\n            contours,\r\n            polyData: reducedSet,\r\n            FrameNumber: sliceIndex + 1,\r\n            sliceIndex,\r\n            FrameOfReferenceUID,\r\n          });\r\n        }\r\n      } catch (e) {\r\n        console.warn(sliceIndex);\r\n        console.warn(e);\r\n      }\r\n    }\r\n\r\n    const metadata = {\r\n      FrameOfReferenceUID,\r\n    };\r\n\r\n    const ContourSet = {\r\n      label: segment.label,\r\n      color: segment.color,\r\n      metadata,\r\n      sliceContours,\r\n    };\r\n\r\n    ContourSets.push(ContourSet);\r\n  }\r\n\r\n  return ContourSets;\r\n}\r\n\r\nfunction isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex) {\r\n  const startIdx = sliceIndex * pixelsPerSlice;\r\n  const endIdx = startIdx + pixelsPerSlice;\r\n\r\n  for (let i = startIdx; i < endIdx; i++) {\r\n    if (segData[i] === segIndex) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport { generateContourSetsFromLabelmap };\r\n","import RectangleROIStartEndThreshold from './RectangleROIStartEndThreshold';\r\n\r\nfunction validateAnnotation(annotation) {\r\n  if (!annotation?.data) {\r\n    throw new Error('Tool data is empty');\r\n  }\r\n\r\n  if (!annotation.metadata || annotation.metadata.referenceImageId) {\r\n    throw new Error('Tool data is not associated with any imageId');\r\n  }\r\n}\r\n\r\nclass AnnotationToPointData {\r\n  static TOOL_NAMES: Record<string, any> = {};\r\n\r\n  constructor() {\r\n    // empty\r\n  }\r\n\r\n  static convert(annotation, index, metadataProvider) {\r\n    validateAnnotation(annotation);\r\n\r\n    const { toolName } = annotation.metadata;\r\n    const toolClass = AnnotationToPointData.TOOL_NAMES[toolName];\r\n\r\n    if (!toolClass) {\r\n      throw new Error(\r\n        `Unknown tool type: ${toolName}, cannot convert to RTSSReport`\r\n      );\r\n    }\r\n\r\n    // Each toolData should become a list of contours, ContourSequence\r\n    // contains a list of contours with their pointData, their geometry\r\n    // type and their length.\r\n    const ContourSequence = toolClass.getContourSequence(\r\n      annotation,\r\n      metadataProvider\r\n    );\r\n\r\n    // Todo: random rgb color for now, options should be passed in\r\n    const color = [\r\n      Math.floor(Math.random() * 255),\r\n      Math.floor(Math.random() * 255),\r\n      Math.floor(Math.random() * 255),\r\n    ];\r\n\r\n    return {\r\n      ReferencedROINumber: index + 1,\r\n      ROIDisplayColor: color,\r\n      ContourSequence,\r\n    };\r\n  }\r\n\r\n  static register(toolClass) {\r\n    AnnotationToPointData.TOOL_NAMES[toolClass.toolName] = toolClass;\r\n  }\r\n}\r\n\r\nAnnotationToPointData.register(RectangleROIStartEndThreshold);\r\n\r\nexport default AnnotationToPointData;\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport type { Annotation } from '../../types';\r\nimport getContourHolesDataWorld from './getContourHolesDataWorld';\r\n\r\n/**\r\n * Get the polylines for the child annotations (holes)\r\n * @param annotation - Annotation\r\n * @param viewport - Viewport used to convert the points from world to canvas space\r\n * @returns An array that contains all child polylines\r\n */\r\nexport default function getContourHolesDataCanvas(\r\n  annotation: Annotation,\r\n  viewport: Types.IViewport\r\n): Types.Point2[][] {\r\n  const worldHoleContours = getContourHolesDataWorld(annotation);\r\n  const canvasHoleContours = [];\r\n\r\n  worldHoleContours.forEach((worldHoleContour) => {\r\n    const numPoints = worldHoleContour.length;\r\n\r\n    // Pre-allocated arrays are 3-4x faster than multiple \"push()\" calls\r\n    const canvasHoleContour: Types.Point2[] = new Array(numPoints);\r\n\r\n    // Using FOR loop instead of map() for better performance when processing large arrays\r\n    for (let i = 0; i < numPoints; i++) {\r\n      canvasHoleContour[i] = viewport.worldToCanvas(worldHoleContour[i]);\r\n    }\r\n\r\n    canvasHoleContours.push(canvasHoleContour);\r\n  });\r\n\r\n  return canvasHoleContours;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport type { Annotation, ContourAnnotation } from '../../types';\r\nimport { getAnnotation } from '../../stateManagement';\r\n\r\n/**\r\n * Get child polylines data in world space for contour annotations that represent the holes\r\n * @param annotation - Annotation\r\n * @param viewport - Viewport used to convert the points from world to canvas space\r\n * @returns An array that contains all child polylines (holes) in world space\r\n */\r\nexport default function getContourHolesDataWorld(\r\n  annotation: Annotation\r\n): Types.Point3[][] {\r\n  const childAnnotationUIDs = annotation.childAnnotationUIDs ?? [];\r\n\r\n  return childAnnotationUIDs.map(\r\n    (uid) => (getAnnotation(uid) as ContourAnnotation).data.contour.polyline\r\n  );\r\n}\r\n","import { utilities as csUtils } from '@cornerstonejs/core';\r\nimport { Types } from '@cornerstonejs/core';\r\nimport type { ContourAnnotation } from '../../types';\r\nimport type { ContourWindingDirection } from '../../types/ContourAnnotation';\r\nimport * as math from '../math';\r\nimport {\r\n  getParentAnnotation,\r\n  invalidateAnnotation,\r\n} from '../../stateManagement';\r\n\r\n/**\r\n * Update the contour polyline data\r\n * @param annotation - Contour annotation\r\n * @param viewport - Viewport\r\n * @param polylineData - Polyline data (points, winding direction and closed)\r\n * @param transforms - Methods to convert points to/from canvas and world spaces\r\n * @param options - Options\r\n *   - decimate: allow to set some parameters to decimate the polyline reducing\r\n *   the amount of points stored which also affects how fast it will draw the\r\n *   annotation in a viewport, compute the winding direction, append/remove\r\n *   contours and create holes. A higher `epsilon` value results in a polyline\r\n *   with less points.\r\n */\r\nexport default function updateContourPolyline(\r\n  annotation: ContourAnnotation,\r\n  polylineData: {\r\n    points: Types.Point2[];\r\n    closed?: boolean;\r\n    targetWindingDirection?: ContourWindingDirection;\r\n  },\r\n  transforms: {\r\n    canvasToWorld: (point: Types.Point2) => Types.Point3;\r\n    worldToCanvas: (point: Types.Point3) => Types.Point2;\r\n  },\r\n  options?: {\r\n    decimate?: {\r\n      enabled?: boolean;\r\n      epsilon?: number;\r\n    };\r\n  }\r\n) {\r\n  const { canvasToWorld, worldToCanvas } = transforms;\r\n  const { data } = annotation;\r\n  const { targetWindingDirection } = polylineData;\r\n  let { points: polyline } = polylineData;\r\n\r\n  // Decimate the polyline to reduce tha amount of points\r\n  if (options?.decimate?.enabled) {\r\n    polyline = math.polyline.decimate(\r\n      polylineData.points,\r\n      options?.decimate?.epsilon\r\n    );\r\n  }\r\n\r\n  let { closed } = polylineData;\r\n  const numPoints = polyline.length;\r\n  const polylineWorldPoints = new Array(numPoints);\r\n  const currentPolylineWindingDirection =\r\n    math.polyline.getWindingDirection(polyline);\r\n  const parentAnnotation = getParentAnnotation(annotation) as ContourAnnotation;\r\n\r\n  if (closed === undefined) {\r\n    let currentClosedState = false;\r\n\r\n    // With two points it is just a line and do not make sense to consider it closed\r\n    if (polyline.length > 3) {\r\n      const lastToFirstDist = math.point.distanceToPointSquared(\r\n        polyline[0],\r\n        polyline[numPoints - 1]\r\n      );\r\n\r\n      currentClosedState = csUtils.isEqual(0, lastToFirstDist);\r\n    }\r\n\r\n    closed = currentClosedState;\r\n  }\r\n\r\n  // It must be in the opposite direction if it is a child annotation (hole)\r\n  let windingDirection = parentAnnotation\r\n    ? parentAnnotation.data.contour.windingDirection * -1\r\n    : targetWindingDirection;\r\n\r\n  if (windingDirection === undefined) {\r\n    windingDirection = currentPolylineWindingDirection;\r\n  }\r\n\r\n  if (windingDirection !== currentPolylineWindingDirection) {\r\n    polyline.reverse();\r\n  }\r\n\r\n  const handlePoints = data.handles.points.map((p) => worldToCanvas(p));\r\n\r\n  if (handlePoints.length > 2) {\r\n    const currentHandlesWindingDirection =\r\n      math.polyline.getWindingDirection(handlePoints);\r\n\r\n    if (currentHandlesWindingDirection !== windingDirection) {\r\n      data.handles.points.reverse();\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < numPoints; i++) {\r\n    polylineWorldPoints[i] = canvasToWorld(polyline[i]);\r\n  }\r\n\r\n  data.contour.polyline = polylineWorldPoints;\r\n  data.contour.closed = closed;\r\n  data.contour.windingDirection = windingDirection;\r\n\r\n  invalidateAnnotation(annotation);\r\n}\r\n","import isObject from './isObject';\r\n\r\n/**\r\n * Creates a debounced function that delays invoking `func` until after `wait`\r\n * milliseconds have elapsed since the last time the debounced function was\r\n * invoked, or until the next browser frame is drawn. The debounced function\r\n * comes with a `cancel` method to cancel delayed `func` invocations and a\r\n * `flush` method to immediately invoke them. Provide `options` to indicate\r\n * whether `func` should be invoked on the leading and/or trailing edge of the\r\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\r\n * debounced function. Subsequent calls to the debounced function return the\r\n * result of the last `func` invocation.\r\n *\r\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\r\n * invoked on the trailing edge of the timeout only if the debounced function\r\n * is invoked more than once during the `wait` timeout.\r\n *\r\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\r\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\r\n *\r\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\r\n * invocation will be deferred until the next frame is drawn (typically about\r\n * 16ms).\r\n *\r\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\r\n * for details over the differences between `debounce` and `throttle`.\r\n *\r\n * @param {Function} func The function to debounce.\r\n * @param {number} [wait=0]\r\n *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is\r\n *  used (if available).\r\n * @param {Object} [options={}] The options object.\r\n * @param {boolean} [options.leading=false]\r\n *  Specify invoking on the leading edge of the timeout.\r\n * @param {number} [options.maxWait]\r\n *  The maximum time `func` is allowed to be delayed before it's invoked.\r\n * @param {boolean} [options.trailing=true]\r\n *  Specify invoking on the trailing edge of the timeout.\r\n * @returns {Function} Returns the new debounced function.\r\n * @example\r\n *\r\n * // Avoid costly calculations while the window size is in flux.\r\n * jQuery(window).on('resize', debounce(calculateLayout, 150))\r\n *\r\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\r\n * jQuery(element).on('click', debounce(sendMail, 300, {\r\n *   'leading': true,\r\n *   'trailing': false\r\n * }))\r\n *\r\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\r\n * const debounced = debounce(batchLog, 250, { 'maxWait': 1000 })\r\n * const source = new EventSource('/stream')\r\n * jQuery(source).on('message', debounced)\r\n *\r\n * // Cancel the trailing debounced invocation.\r\n * jQuery(window).on('popstate', debounced.cancel)\r\n *\r\n * // Check for pending invocations.\r\n * const status = debounced.pending() ? \"Pending...\" : \"Ready\"\r\n */\r\nfunction debounce(func, wait, options) {\r\n  let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\r\n\r\n  let lastInvokeTime = 0;\r\n  let leading = false;\r\n  let maxing = false;\r\n  let trailing = true;\r\n\r\n  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\r\n  const useRAF =\r\n    !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';\r\n\r\n  if (typeof func !== 'function') {\r\n    throw new TypeError('Expected a function');\r\n  }\r\n  wait = Number(wait) || 0;\r\n  if (isObject(options)) {\r\n    leading = Boolean(options.leading);\r\n    maxing = 'maxWait' in options;\r\n    maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;\r\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\r\n  }\r\n\r\n  function invokeFunc(time) {\r\n    const args = lastArgs;\r\n    const thisArg = lastThis;\r\n\r\n    lastArgs = lastThis = undefined;\r\n    lastInvokeTime = time;\r\n    result = func.apply(thisArg, args);\r\n\r\n    return result;\r\n  }\r\n\r\n  function startTimer(pendingFunc, wait) {\r\n    if (useRAF) {\r\n      return window.requestAnimationFrame(pendingFunc);\r\n    }\r\n\r\n    return setTimeout(pendingFunc, wait);\r\n  }\r\n\r\n  function cancelTimer(id) {\r\n    if (useRAF) {\r\n      return window.cancelAnimationFrame(id);\r\n    }\r\n    clearTimeout(id);\r\n  }\r\n\r\n  function leadingEdge(time) {\r\n    // Reset any `maxWait` timer.\r\n    lastInvokeTime = time;\r\n    // Start the timer for the trailing edge.\r\n    timerId = startTimer(timerExpired, wait);\r\n\r\n    // Invoke the leading edge.\r\n    return leading ? invokeFunc(time) : result;\r\n  }\r\n\r\n  function remainingWait(time) {\r\n    const timeSinceLastCall = time - lastCallTime;\r\n    const timeSinceLastInvoke = time - lastInvokeTime;\r\n    const timeWaiting = wait - timeSinceLastCall;\r\n\r\n    return maxing\r\n      ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\r\n      : timeWaiting;\r\n  }\r\n\r\n  function shouldInvoke(time) {\r\n    const timeSinceLastCall = time - lastCallTime;\r\n    const timeSinceLastInvoke = time - lastInvokeTime;\r\n\r\n    // Either this is the first call, activity has stopped and we're at the\r\n    // trailing edge, the system time has gone backwards and we're treating\r\n    // it as the trailing edge, or we've hit the `maxWait` limit.\r\n    return (\r\n      lastCallTime === undefined ||\r\n      timeSinceLastCall >= wait ||\r\n      timeSinceLastCall < 0 ||\r\n      (maxing && timeSinceLastInvoke >= maxWait)\r\n    );\r\n  }\r\n\r\n  function timerExpired() {\r\n    const time = Date.now();\r\n\r\n    if (shouldInvoke(time)) {\r\n      return trailingEdge(time);\r\n    }\r\n    // Restart the timer.\r\n    timerId = startTimer(timerExpired, remainingWait(time));\r\n  }\r\n\r\n  function trailingEdge(time) {\r\n    timerId = undefined;\r\n\r\n    // Only invoke if we have `lastArgs` which means `func` has been\r\n    // debounced at least once.\r\n    if (trailing && lastArgs) {\r\n      return invokeFunc(time);\r\n    }\r\n    lastArgs = lastThis = undefined;\r\n\r\n    return result;\r\n  }\r\n\r\n  function cancel() {\r\n    if (timerId !== undefined) {\r\n      cancelTimer(timerId);\r\n    }\r\n    lastInvokeTime = 0;\r\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\r\n  }\r\n\r\n  function flush() {\r\n    return timerId === undefined ? result : trailingEdge(Date.now());\r\n  }\r\n\r\n  function pending() {\r\n    return timerId !== undefined;\r\n  }\r\n\r\n  function debounced(...args) {\r\n    const time = Date.now();\r\n    const isInvoking = shouldInvoke(time);\r\n\r\n    lastArgs = args;\r\n    lastThis = this; // eslint-disable-line consistent-this\r\n    lastCallTime = time;\r\n\r\n    if (isInvoking) {\r\n      if (timerId === undefined) {\r\n        return leadingEdge(lastCallTime);\r\n      }\r\n      if (maxing) {\r\n        // Handle invocations in a tight loop.\r\n        timerId = startTimer(timerExpired, wait);\r\n\r\n        return invokeFunc(lastCallTime);\r\n      }\r\n    }\r\n    if (timerId === undefined) {\r\n      timerId = startTimer(timerExpired, wait);\r\n    }\r\n\r\n    return result;\r\n  }\r\n  debounced.cancel = cancel;\r\n  debounced.flush = flush;\r\n  debounced.pending = pending;\r\n\r\n  return debounced;\r\n}\r\n\r\nexport default debounce;\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Determine the coordinates that will place the textbox to the right of the\r\n * annotation.\r\n *\r\n * @param annotationCanvasPoints - The canvas points of the annotation's handles.\r\n * @returns - The coordinates for default placement of the textbox.\r\n */\r\nexport default function getTextBoxCoordsCanvas(\r\n  annotationCanvasPoints: Array<Types.Point2>\r\n): Types.Point2 {\r\n  const corners = _determineCorners(annotationCanvasPoints);\r\n  const centerY = (corners.top[1] + corners.bottom[1]) / 2;\r\n  const textBoxCanvas = <Types.Point2>[corners.right[0], centerY];\r\n\r\n  return textBoxCanvas;\r\n}\r\n\r\n/**\r\n * Determine the handles that have the min/max x and y values.\r\n *\r\n * @param canvasPoints - The canvas points of the annotation's handles.\r\n * @returns - The top, left, bottom, and right handles.\r\n */\r\nfunction _determineCorners(canvasPoints: Array<Types.Point2>) {\r\n  const handlesLeftToRight = [canvasPoints[0], canvasPoints[1]].sort(_compareX);\r\n  const handlesTopToBottom = [canvasPoints[0], canvasPoints[1]].sort(_compareY);\r\n  const right = handlesLeftToRight[handlesLeftToRight.length - 1];\r\n  const top = handlesTopToBottom[0];\r\n  const bottom = handlesTopToBottom[handlesTopToBottom.length - 1];\r\n\r\n  return {\r\n    top,\r\n    bottom,\r\n    right,\r\n  };\r\n\r\n  function _compareX(a, b) {\r\n    return a[0] < b[0] ? -1 : 1;\r\n  }\r\n  function _compareY(a, b) {\r\n    return a[1] < b[1] ? -1 : 1;\r\n  }\r\n}\r\n","import { Enums, utilities } from '@cornerstonejs/core';\r\n\r\nconst { CalibrationTypes } = Enums;\r\nconst PIXEL_UNITS = 'px';\r\n\r\nconst SUPPORTED_REGION_DATA_TYPES = [\r\n  1, // Tissue\r\n];\r\n\r\nconst SUPPORTED_LENGTH_VARIANT = [\r\n  '3,3', // x: cm  &  y:cm\r\n];\r\n\r\nconst SUPPORTED_PROBE_VARIANT = [\r\n  '4,3', // x: seconds  &  y : cm\r\n];\r\n\r\nconst UNIT_MAPPING = {\r\n  3: 'cm',\r\n  4: 'seconds',\r\n};\r\n\r\nconst EPS = 1e-3;\r\nconst SQUARE = '\\xb2';\r\n/**\r\n * Extracts the calibrated length units, area units, and the scale\r\n * for converting from internal spacing to image spacing.\r\n *\r\n * @param handles - to detect if spacing information is different between points\r\n * @param image - to extract the calibration from\r\n * @returns Object containing the units, area units, and scale\r\n */\r\nconst getCalibratedLengthUnitsAndScale = (image, handles) => {\r\n  const { calibration, hasPixelSpacing } = image;\r\n  let units = hasPixelSpacing ? 'mm' : PIXEL_UNITS;\r\n  let areaUnits = units + SQUARE;\r\n  let scale = 1;\r\n  let calibrationType = '';\r\n\r\n  if (\r\n    !calibration ||\r\n    (!calibration.type && !calibration.sequenceOfUltrasoundRegions)\r\n  ) {\r\n    return { units, areaUnits, scale };\r\n  }\r\n\r\n  if (calibration.type === CalibrationTypes.UNCALIBRATED) {\r\n    return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\r\n  }\r\n\r\n  if (calibration.sequenceOfUltrasoundRegions) {\r\n    let imageIndex1, imageIndex2;\r\n    if (Array.isArray(handles) && handles.length === 2) {\r\n      [imageIndex1, imageIndex2] = handles;\r\n    } else if (typeof handles === 'function') {\r\n      const points = handles();\r\n      imageIndex1 = points[0];\r\n      imageIndex2 = points[1];\r\n    }\r\n\r\n    let regions = calibration.sequenceOfUltrasoundRegions.filter(\r\n      (region) =>\r\n        imageIndex1[0] >= region.regionLocationMinX0 &&\r\n        imageIndex1[0] <= region.regionLocationMaxX1 &&\r\n        imageIndex1[1] >= region.regionLocationMinY0 &&\r\n        imageIndex1[1] <= region.regionLocationMaxY1 &&\r\n        imageIndex2[0] >= region.regionLocationMinX0 &&\r\n        imageIndex2[0] <= region.regionLocationMaxX1 &&\r\n        imageIndex2[1] >= region.regionLocationMinY0 &&\r\n        imageIndex2[1] <= region.regionLocationMaxY1\r\n    );\r\n\r\n    // If we are not in a region at all we should show the underlying calibration\r\n    // which might be the mm spacing for the image\r\n    if (!regions?.length) {\r\n      return { units, areaUnits, scale };\r\n    }\r\n\r\n    // if we are in a region then it is the question of whether we support it\r\n    // or not. If we do not support it we should show px\r\n\r\n    regions = regions.filter(\r\n      (region) =>\r\n        SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\r\n        SUPPORTED_LENGTH_VARIANT.includes(\r\n          `${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`\r\n        )\r\n    );\r\n\r\n    if (!regions.length) {\r\n      return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\r\n    }\r\n\r\n    // Todo: expand on this logic\r\n    const region = regions[0];\r\n\r\n    const physicalDeltaX = Math.abs(region.physicalDeltaX);\r\n    const physicalDeltaY = Math.abs(region.physicalDeltaY);\r\n\r\n    // if we are in a supported region then we should check if the\r\n    // physicalDeltaX and physicalDeltaY are the same. If they are not\r\n    // then we should show px again, but if they are the same then we should\r\n    // show the units\r\n    const isSamePhysicalDelta = utilities.isEqual(\r\n      physicalDeltaX,\r\n      physicalDeltaY,\r\n      EPS\r\n    );\r\n\r\n    if (isSamePhysicalDelta) {\r\n      // 1 to 1 aspect ratio, we use just one of them\r\n      scale = 1 / (physicalDeltaX * 10);\r\n      calibrationType = 'US Region';\r\n      units = 'mm';\r\n      areaUnits = 'mm' + SQUARE;\r\n    } else {\r\n      // here we are showing at the aspect ratio of the physical delta\r\n      // if they are not the same, then we should show px, but the correct solution\r\n      // is to grab each point separately and scale them individually\r\n      // Todo: implement this\r\n      return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\r\n    }\r\n  } else if (calibration.scale) {\r\n    scale = calibration.scale;\r\n  }\r\n\r\n  // everything except REGION/Uncalibrated\r\n  const types = [\r\n    CalibrationTypes.ERMF,\r\n    CalibrationTypes.USER,\r\n    CalibrationTypes.ERROR,\r\n    CalibrationTypes.PROJECTION,\r\n  ];\r\n\r\n  if (types.includes(calibration?.type)) {\r\n    calibrationType = calibration.type;\r\n  }\r\n\r\n  return {\r\n    units: units + (calibrationType ? ` ${calibrationType}` : ''),\r\n    areaUnits: areaUnits + (calibrationType ? ` ${calibrationType}` : ''),\r\n    scale,\r\n  };\r\n};\r\n\r\nconst getCalibratedProbeUnitsAndValue = (image, handles) => {\r\n  const [imageIndex] = handles;\r\n  const { calibration } = image;\r\n  let units = ['raw'];\r\n  let values = [null];\r\n  let calibrationType = '';\r\n\r\n  if (\r\n    !calibration ||\r\n    (!calibration.type && !calibration.sequenceOfUltrasoundRegions)\r\n  ) {\r\n    return { units, values };\r\n    // Todo: add support for other scenarios\r\n  }\r\n\r\n  if (calibration.sequenceOfUltrasoundRegions) {\r\n    // for Probe tool\r\n    const supportedRegionsMetadata =\r\n      calibration.sequenceOfUltrasoundRegions.filter(\r\n        (region) =>\r\n          SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\r\n          SUPPORTED_PROBE_VARIANT.includes(\r\n            `${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`\r\n          )\r\n      );\r\n\r\n    if (!supportedRegionsMetadata?.length) {\r\n      return { units, values };\r\n    }\r\n\r\n    const region = supportedRegionsMetadata.find(\r\n      (region) =>\r\n        imageIndex[0] >= region.regionLocationMinX0 &&\r\n        imageIndex[0] <= region.regionLocationMaxX1 &&\r\n        imageIndex[1] >= region.regionLocationMinY0 &&\r\n        imageIndex[1] <= region.regionLocationMaxY1\r\n    );\r\n\r\n    if (!region) {\r\n      return { units, values };\r\n    }\r\n\r\n    // Todo: I think this is a ok assumption for now that if the referencePixelX0 and referencePixelY0\r\n    // are not defined, then we can assume 0 for them\r\n    const { referencePixelX0 = 0, referencePixelY0 = 0 } = region;\r\n    const { physicalDeltaX, physicalDeltaY } = region;\r\n\r\n    const yValue =\r\n      (imageIndex[1] - region.regionLocationMinY0 - referencePixelY0) *\r\n      physicalDeltaY;\r\n\r\n    const xValue =\r\n      (imageIndex[0] - region.regionLocationMinX0 - referencePixelX0) *\r\n      physicalDeltaX;\r\n\r\n    calibrationType = 'US Region';\r\n    values = [xValue, yValue];\r\n    units = [\r\n      UNIT_MAPPING[region.physicalUnitsXDirection],\r\n      UNIT_MAPPING[region.physicalUnitsYDirection],\r\n    ];\r\n  }\r\n\r\n  return {\r\n    units,\r\n    values,\r\n    calibrationType,\r\n  };\r\n};\r\n\r\n/** Gets the aspect ratio of the screen display relative to the image\r\n * display in order to square up measurement values.\r\n * That is, suppose the spacing on the image is 1, 0.5 (x,y spacing)\r\n * This is displayed at 1, 1 spacing on screen, then the\r\n * aspect value will be 1/0.5 = 2\r\n */\r\nconst getCalibratedAspect = (image) => image.calibration?.aspect || 1;\r\n\r\nexport {\r\n  getCalibratedLengthUnitsAndScale,\r\n  getCalibratedAspect,\r\n  getCalibratedProbeUnitsAndValue,\r\n};\r\n","import { utilities as csUtils } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\r\nimport { vec3 } from 'gl-matrix';\r\nimport { BoundsIJK } from '../types';\r\nimport { getBoundingBoxAroundShapeIJK } from './boundingBox';\r\n\r\nconst { transformWorldToIndex } = csUtils;\r\n\r\n/**\r\n * Given an imageData, and the great circle top and bottom points of a sphere,\r\n * this function will run the callback for each point of the imageData that is\r\n * within the sphere defined by the great circle points. If the viewport\r\n * is provided, region of interest will be an accurate approximation of the\r\n * sphere (using viewport camera), and the resulting performance will be\r\n * better.\r\n *\r\n * @privateRemarks great circle also known as orthodrome is the intersection of\r\n * the sphere and the plane that passes through the center of the sphere\r\n *\r\n * @param imageData - The volume imageData\r\n * @param circlePoints - bottom and top points of the great circle in world coordinates\r\n * @param callback - A callback function that will be called for each point in the shape.\r\n */\r\nfunction getSphereBoundsInfo(\r\n  circlePoints: [Types.Point3, Types.Point3],\r\n  imageData: vtkImageData,\r\n  viewport\r\n): {\r\n  boundsIJK: BoundsIJK;\r\n  centerWorld: Types.Point3;\r\n  radiusWorld: number;\r\n  topLeftWorld: Types.Point3;\r\n  bottomRightWorld: Types.Point3;\r\n} {\r\n  const [bottom, top] = circlePoints;\r\n\r\n  // Sphere center in world\r\n  const centerWorld = vec3.fromValues(\r\n    (bottom[0] + top[0]) / 2,\r\n    (bottom[1] + top[1]) / 2,\r\n    (bottom[2] + top[2]) / 2\r\n  );\r\n\r\n  // sphere radius in world\r\n  const radiusWorld = vec3.distance(bottom, top) / 2;\r\n\r\n  if (!viewport) {\r\n    throw new Error(\r\n      'viewport is required in order to calculate the sphere bounds'\r\n    );\r\n  }\r\n\r\n  const { boundsIJK, topLeftWorld, bottomRightWorld } =\r\n    _computeBoundsIJKWithCamera(\r\n      imageData,\r\n      viewport,\r\n      circlePoints,\r\n      centerWorld,\r\n      radiusWorld\r\n    );\r\n\r\n  return {\r\n    boundsIJK,\r\n    centerWorld: centerWorld as Types.Point3,\r\n    radiusWorld,\r\n    topLeftWorld: topLeftWorld as Types.Point3,\r\n    bottomRightWorld: bottomRightWorld as Types.Point3,\r\n  };\r\n}\r\n\r\nfunction _computeBoundsIJKWithCamera(\r\n  imageData,\r\n  viewport,\r\n  circlePoints,\r\n  centerWorld,\r\n  radiusWorld\r\n) {\r\n  const [bottom, top] = circlePoints;\r\n\r\n  const dimensions = imageData.getDimensions() as Types.Point3;\r\n\r\n  const camera = viewport.getCamera();\r\n\r\n  // Calculate viewRight from the camera, this will get used in order to\r\n  // calculate circles topLeft and bottomRight on different planes of intersection\r\n  // between sphere and viewPlane\r\n  const viewUp = vec3.fromValues(\r\n    camera.viewUp[0],\r\n    camera.viewUp[1],\r\n    camera.viewUp[2]\r\n  );\r\n  const viewPlaneNormal = vec3.fromValues(\r\n    camera.viewPlaneNormal[0],\r\n    camera.viewPlaneNormal[1],\r\n    camera.viewPlaneNormal[2]\r\n  );\r\n  const viewRight = vec3.create();\r\n\r\n  vec3.cross(viewRight, viewUp, viewPlaneNormal);\r\n\r\n  // we need to find the bounding box of the sphere in the image, e.g., the\r\n  // topLeftWorld and bottomRightWorld points of the bounding box.\r\n  // We go from the sphereCenter in the normal direction of amount radius, and\r\n  // we go left to find the topLeftWorld point of the bounding box. Next we go\r\n  // in the opposite direction and go right to find the bottomRightWorld point\r\n  // of the bounding box.\r\n  const topLeftWorld = vec3.create();\r\n  const bottomRightWorld = vec3.create();\r\n\r\n  vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\r\n  vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\r\n\r\n  // go in the direction of viewRight with the value of radius\r\n  vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\r\n  vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\r\n\r\n  // In order to correctly come up with the boundsIJK, we need to consider\r\n  // all the points IJK to get the bounds, since the viewport might have\r\n  // rotate views and we cannot guarantee that the topLeft and bottomRight in the\r\n  // world, are the ones that will define the bounds in IJK\r\n  const topLeftIJK = transformWorldToIndex(\r\n    imageData,\r\n    topLeftWorld as Types.Point3\r\n  );\r\n  const bottomRightIJK = transformWorldToIndex(\r\n    imageData,\r\n    bottomRightWorld as Types.Point3\r\n  );\r\n\r\n  const pointsIJK = circlePoints.map((p) =>\r\n    transformWorldToIndex(imageData, p)\r\n  );\r\n\r\n  // get the bounding box of the sphere in the image\r\n  const boundsIJK = getBoundingBoxAroundShapeIJK(\r\n    [topLeftIJK, bottomRightIJK, ...pointsIJK],\r\n    dimensions\r\n  );\r\n\r\n  return { boundsIJK, topLeftWorld, bottomRightWorld };\r\n}\r\n\r\nexport { getSphereBoundsInfo };\r\n","import type { Annotation } from '../types';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport getViewportsForAnnotation from './getViewportsForAnnotation';\r\n\r\n/**\r\n * Finds a matching viewport in terms of the orientation of the annotation data\r\n * and the frame of reference.  This doesn't mean the annotation IS being displayed\r\n * in the viewport, just that it could be by navigating the slice, and/or pan/zoom,\r\n * without changing the orientation.\r\n *\r\n * @param annotation - to find a viewport that it could display in\r\n * @returns The viewport to display in\r\n */\r\nexport default function getViewportForAnnotation(\r\n  annotation: Annotation\r\n): Types.IStackViewport | Types.IVolumeViewport | undefined {\r\n  const viewports = getViewportsForAnnotation(annotation);\r\n\r\n  return viewports.length ? viewports[0] : undefined;\r\n}\r\n","import { utilities } from '@cornerstonejs/core';\r\n\r\nimport {\r\n  getAnnotationNearPoint,\r\n  getAnnotationNearPointOnEnabledElement,\r\n} from './getAnnotationNearPoint';\r\n\r\n// Lodash/common JS functionality\r\nimport debounce from './debounce';\r\nimport throttle from './throttle';\r\nimport isObject from './isObject';\r\nimport clip from './clip';\r\nimport calibrateImageSpacing from './calibrateImageSpacing';\r\nimport {\r\n  getCalibratedLengthUnitsAndScale,\r\n  getCalibratedProbeUnitsAndValue,\r\n  getCalibratedAspect,\r\n} from './getCalibratedUnits';\r\nimport triggerAnnotationRenderForViewportIds from './triggerAnnotationRenderForViewportIds';\r\nimport triggerAnnotationRenderForToolGroupIds from './triggerAnnotationRenderForToolGroupIds';\r\nimport triggerAnnotationRender from './triggerAnnotationRender';\r\nimport jumpToSlice from './viewport/jumpToSlice';\r\n\r\nimport pointInShapeCallback from './pointInShapeCallback';\r\nimport { getSphereBoundsInfo } from './getSphereBoundsInfo';\r\nimport scroll from './scroll';\r\nimport { pointToString } from './pointToString';\r\nimport annotationFrameRange from './annotationFrameRange';\r\nimport pointInSurroundingSphereCallback from './pointInSurroundingSphereCallback';\r\nimport getViewportForAnnotation from './getViewportForAnnotation';\r\nimport {\r\n  annotationHydration,\r\n  getClosestImageIdForStackViewport,\r\n} from './annotationHydration';\r\n// name spaces\r\nimport * as contours from './contours';\r\nimport * as segmentation from './segmentation';\r\nimport * as drawing from './drawing';\r\nimport * as math from './math';\r\nimport * as planar from './planar';\r\nimport * as viewportFilters from './viewportFilters';\r\nimport * as orientation from './orientation';\r\nimport * as cine from './cine';\r\nimport * as boundingBox from './boundingBox';\r\nimport * as planarFreehandROITool from './planarFreehandROITool';\r\nimport * as rectangleROITool from './rectangleROITool';\r\nimport { stackPrefetch, stackContextPrefetch } from './stackPrefetch';\r\nimport * as viewport from './viewport';\r\nimport * as touch from './touch';\r\nimport * as dynamicVolume from './dynamicVolume';\r\nimport * as polyDataUtils from './polyData/utils';\r\nimport * as voi from './voi';\r\nimport * as contourSegmentation from './contourSegmentation';\r\n\r\nconst roundNumber = utilities.roundNumber;\r\n\r\n// Events\r\nimport { triggerEvent } from '@cornerstonejs/core';\r\n\r\nexport {\r\n  math,\r\n  planar,\r\n  viewportFilters,\r\n  drawing,\r\n  debounce,\r\n  dynamicVolume,\r\n  throttle,\r\n  orientation,\r\n  isObject,\r\n  touch,\r\n  triggerEvent,\r\n  calibrateImageSpacing,\r\n  getCalibratedLengthUnitsAndScale,\r\n  getCalibratedProbeUnitsAndValue,\r\n  getCalibratedAspect,\r\n  segmentation,\r\n  contours,\r\n  triggerAnnotationRenderForViewportIds,\r\n  triggerAnnotationRenderForToolGroupIds,\r\n  triggerAnnotationRender,\r\n  pointInShapeCallback,\r\n  getSphereBoundsInfo,\r\n  getAnnotationNearPoint,\r\n  getViewportForAnnotation,\r\n  getAnnotationNearPointOnEnabledElement,\r\n  jumpToSlice,\r\n  pointInSurroundingSphereCallback,\r\n  viewport,\r\n  cine,\r\n  clip,\r\n  boundingBox,\r\n  rectangleROITool,\r\n  planarFreehandROITool,\r\n  stackPrefetch,\r\n  stackContextPrefetch,\r\n  scroll,\r\n  roundNumber,\r\n  pointToString,\r\n  polyDataUtils,\r\n  voi,\r\n  annotationFrameRange,\r\n  contourSegmentation,\r\n  annotationHydration,\r\n  getClosestImageIdForStackViewport,\r\n};\r\n","/**\r\n * Checks if `value` is the\r\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\r\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\r\n *\r\n * @since 0.1.0\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\r\n * @example\r\n *\r\n * isObject({})\r\n * // => true\r\n *\r\n * isObject([1, 2, 3])\r\n * // => true\r\n *\r\n * isObject(Function)\r\n * // => true\r\n *\r\n * isObject(null)\r\n * // => false\r\n */\r\nfunction isObject(value) {\r\n  const type = typeof value;\r\n\r\n  return value !== null && (type === 'object' || type === 'function');\r\n}\r\n\r\nexport default isObject;\r\n","import { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Check if two axis-aligned bounding boxes intersect\r\n * @param aabb1 - First AABB\r\n * @param aabb2 - Second AABB\r\n * @returns True if they intersect or false otherwise\r\n */\r\nexport default function intersectAABB(\r\n  aabb1: Types.AABB2,\r\n  aabb2: Types.AABB2\r\n): boolean {\r\n  return (\r\n    aabb1.minX <= aabb2.maxX &&\r\n    aabb1.maxX >= aabb2.minX &&\r\n    aabb1.minY <= aabb2.maxY &&\r\n    aabb1.maxY >= aabb2.minY\r\n  );\r\n}\r\n","import { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Calculates the distance of a point to an AABB using 2D Box SDF (Signed Distance Field)\r\n *\r\n * The SDF of a Box\r\n * https://www.youtube.com/watch?v=62-pRVZuS5c\r\n *\r\n * @param aabb - Axis-aligned bound box\r\n * @param point - 2D point\r\n * @returns The closest distance between the 2D point and the AABB\r\n */\r\nexport default function distanceToPointSquared(\r\n  aabb: Types.AABB2,\r\n  point: Types.Point2\r\n): number {\r\n  const aabbWidth = aabb.maxX - aabb.minX;\r\n  const aabbHeight = aabb.maxY - aabb.minY;\r\n  const aabbSize = [aabbWidth, aabbHeight];\r\n  const aabbCenter: Types.Point2 = [\r\n    aabb.minX + aabbWidth / 2,\r\n    aabb.minY + aabbHeight / 2,\r\n  ];\r\n\r\n  // Translates the point as the center of the AABB is the new origin.\r\n  // THe point is also mirroed to the first quadrant to simplify the math.\r\n  const translatedPoint = [\r\n    Math.abs(point[0] - aabbCenter[0]),\r\n    Math.abs(point[1] - aabbCenter[1]),\r\n  ];\r\n\r\n  // Calculate the distance from the point to the vertical and horizontal AABB borders\r\n  const dx = translatedPoint[0] - aabbSize[0] * 0.5;\r\n  const dy = translatedPoint[1] - aabbSize[1] * 0.5;\r\n\r\n  // dx >  0 && dy >  0: diagonal line connecting the point to AABB's corner\r\n  // dx >  0 && dy <= 0: a line parallel to x-axis connecting the point to AABB's right side\r\n  // dx <= 0 && dy >  0: a line parallel to y-axis connecting the point to AABB's top side\r\n  // dx <= 0 && dy <= 0: the point is inside the AABB\r\n  if (dx > 0 && dy > 0) {\r\n    return dx * dx + dy * dy;\r\n  }\r\n\r\n  const dist = Math.max(dx, 0) + Math.max(dy, 0);\r\n\r\n  return dist * dist;\r\n}\r\n","import { Types } from '@cornerstonejs/core';\r\nimport distanceToPointSquared from './distanceToPointSquared';\r\n\r\n/**\r\n * Calculates the squared distance of a point to an AABB using\r\n * 2D Box SDF (Signed Distance Field)\r\n *\r\n * The SDF of a Box\r\n * https://www.youtube.com/watch?v=62-pRVZuS5c\r\n *\r\n * @param aabb - Axis-aligned bound box (minX, minY, maxX and maxY)\r\n * @param point - 2D point\r\n * @returns The squared distance between the 2D point and the AABB\r\n */\r\nexport default function distanceToPoint(\r\n  aabb: Types.AABB2,\r\n  point: Types.Point2\r\n): number {\r\n  return Math.sqrt(distanceToPointSquared(aabb, point));\r\n}\r\n","import { NamedStatistics } from '../../../types';\r\n\r\nabstract class Calculator {\r\n  static run: ({ value }) => void;\r\n  /**\r\n   * Gets the statistics as both an array of values, as well as the named values.\r\n   */\r\n  static getStatistics: () => NamedStatistics;\r\n}\r\n\r\nexport default Calculator;\r\n","import { utilities } from '@cornerstonejs/core';\r\nimport { NamedStatistics } from '../../../types';\r\nimport Calculator from './Calculator';\r\n\r\nconst { PointsManager } = utilities;\r\n\r\nexport default class BasicStatsCalculator extends Calculator {\r\n  private static max = [-Infinity];\r\n  private static min = [Infinity];\r\n  private static sum = [0];\r\n  private static count = 0;\r\n\r\n  // private static sumSquares = [0];\r\n  // Values for Welford's algorithm\r\n  private static runMean = [0];\r\n  private static m2 = [0];\r\n\r\n  // Collect the points to be returned\r\n  private static pointsInShape = PointsManager.create3(1024);\r\n\r\n  public static statsInit(options: { noPointsCollection: boolean }) {\r\n    if (options.noPointsCollection) {\r\n      BasicStatsCalculator.pointsInShape = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This callback is used when we verify if the point is in the annotation drawn\r\n   * so we can get every point in the shape to calculate the statistics\r\n   */\r\n  static statsCallback = ({ value: newValue, pointLPS = null }): void => {\r\n    if (\r\n      Array.isArray(newValue) &&\r\n      newValue.length > 1 &&\r\n      this.max.length === 1\r\n    ) {\r\n      this.max.push(this.max[0], this.max[0]);\r\n      this.min.push(this.min[0], this.min[0]);\r\n      this.sum.push(this.sum[0], this.sum[0]);\r\n      this.runMean.push(0, 0);\r\n      // this.sumSquares.push(this.sumSquares[0], this.sumSquares[0]);\r\n      this.m2.push(this.m2[0], this.m2[0]);\r\n    }\r\n\r\n    this.pointsInShape?.push(pointLPS);\r\n    const newArray = Array.isArray(newValue) ? newValue : [newValue];\r\n\r\n    this.count += 1;\r\n    this.max.map((it, idx) => {\r\n      const value = newArray[idx];\r\n\r\n      const delta = value - this.runMean[idx];\r\n      this.sum[idx] += value;\r\n      this.runMean[idx] += delta / this.count;\r\n      const delta2 = value - this.runMean[idx];\r\n      this.m2[idx] += delta * delta2;\r\n      // this.sumSquares[idx] += value * value;\r\n\r\n      this.min[idx] = Math.min(this.min[idx], value);\r\n      this.max[idx] = Math.max(it, value);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Basic function that calculates statistics for a given array of points.\r\n   * @returns An object that contains :\r\n   * max : The maximum value of the array\r\n   * mean : mean of the array\r\n   * stdDev : standard deviation of the array\r\n   * array : An array of hte above values, in order.\r\n   */\r\n\r\n  static getStatistics = (options?: { unit: string }): NamedStatistics => {\r\n    const mean = this.sum.map((sum) => sum / this.count);\r\n    const stdDev = this.m2.map((squaredDiffSum) =>\r\n      Math.sqrt(squaredDiffSum / this.count)\r\n    );\r\n    // const stdDevWithSumSquare = this.sumSquares.map((it, idx) =>\r\n    //   Math.sqrt(this.sumSquares[idx] / this.count - mean[idx] ** 2)\r\n    // );\r\n\r\n    const unit = options?.unit || null;\r\n\r\n    const named: NamedStatistics = {\r\n      max: {\r\n        name: 'max',\r\n        label: 'Max Pixel',\r\n        value: singleArrayAsNumber(this.max),\r\n        unit,\r\n      },\r\n      min: {\r\n        name: 'min',\r\n        label: 'Min Pixel',\r\n        value: singleArrayAsNumber(this.min),\r\n        unit,\r\n      },\r\n      mean: {\r\n        name: 'mean',\r\n        label: 'Mean Pixel',\r\n        value: singleArrayAsNumber(mean),\r\n        unit,\r\n      },\r\n      stdDev: {\r\n        name: 'stdDev',\r\n        label: 'Standard Deviation',\r\n        value: singleArrayAsNumber(stdDev),\r\n        unit,\r\n      },\r\n      // stdDevWithSumSquare: {\r\n      //   name: 'stdDevWithSumSquare',\r\n      //   value: singleArrayAsNumber(stdDevWithSumSquare),\r\n      //   unit,\r\n      // },\r\n      count: {\r\n        name: 'count',\r\n        label: 'Pixel Count',\r\n        value: this.count,\r\n        unit: null,\r\n      },\r\n      pointsInShape: this.pointsInShape,\r\n      array: [],\r\n    };\r\n    named.array.push(\r\n      named.max,\r\n      named.mean,\r\n      named.stdDev,\r\n      // Use the stdDev twice to preserve old ordering - this is updated to be\r\n      // correct value with Welford's algorithm now.\r\n      named.stdDev,\r\n      named.count\r\n    );\r\n\r\n    this.max = [-Infinity];\r\n    this.min = [Infinity];\r\n    this.sum = [0];\r\n    // this.sumSquares = [0];\r\n    this.m2 = [0];\r\n    this.runMean = [0];\r\n    this.count = 0;\r\n    this.pointsInShape = PointsManager.create3(1024);\r\n\r\n    return named;\r\n  };\r\n}\r\n\r\nfunction singleArrayAsNumber(val: number[]) {\r\n  return val.length === 1 ? val[0] : val;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\ninterface Inverts {\r\n  invXRadiusSq?: number;\r\n  invYRadiusSq?: number;\r\n  invZRadiusSq?: number;\r\n  fast?: boolean;\r\n  /**\r\n   * If you call the pointInEllipse.precalculateInverts first, then you\r\n   * can call precalculated directly instead of having the extra time for\r\n   * the if conditions.\r\n   */\r\n  precalculated?: (pointLPS: Types.Point3) => boolean;\r\n}\r\n\r\n/**\r\n * Given an ellipse and a point, return true if the point is inside the ellipse\r\n * @param ellipse - The ellipse object to check against.\r\n * @param pointLPS - The point in LPS space to test.\r\n * @param inverts - An object to cache the inverted radius squared values, if you\r\n * are testing multiple points against the same ellipse then it is recommended to\r\n * pass in the same object to cache the values. However, there is a simpler way\r\n * to do this by passing in the fast flag as true, then on the first iteration\r\n * the values will be cached and on subsequent iterations the cached values will\r\n * be used.\r\n *\r\n * @returns A boolean value.\r\n */\r\nexport default function pointInEllipse(\r\n  ellipse,\r\n  pointLPS,\r\n  inverts: Inverts = {}\r\n) {\r\n  if (!inverts.precalculated) {\r\n    precalculatePointInEllipse(ellipse, inverts);\r\n  }\r\n  return inverts.precalculated(pointLPS);\r\n}\r\n\r\n/**\r\n * This will perform some precalculations to make things faster.\r\n * Ideally, use the 'precalculated' function inside inverts to call the\r\n * test function.  This minimizes re-reading of variables and only needs the\r\n * LPS passed each time.\r\n * That is:\r\n *\r\n * ```\r\n *    const inverts = precalculatePointInEllipse(ellipse);\r\n *    if( inverts.precalculated(pointLPS) ) ...\r\n * ```\r\n */\r\nconst precalculatePointInEllipse = (ellipse, inverts: Inverts = {}) => {\r\n  const { xRadius, yRadius, zRadius } = ellipse;\r\n\r\n  // This will run only once since we are caching the values in the same\r\n  // object that is passed in.\r\n  if (\r\n    inverts.invXRadiusSq === undefined ||\r\n    inverts.invYRadiusSq === undefined ||\r\n    inverts.invZRadiusSq === undefined\r\n  ) {\r\n    inverts.invXRadiusSq = xRadius !== 0 ? 1 / xRadius ** 2 : 0;\r\n    inverts.invYRadiusSq = yRadius !== 0 ? 1 / yRadius ** 2 : 0;\r\n    inverts.invZRadiusSq = zRadius !== 0 ? 1 / zRadius ** 2 : 0;\r\n  }\r\n\r\n  const { invXRadiusSq, invYRadiusSq, invZRadiusSq } = inverts;\r\n  const { center } = ellipse;\r\n  const [centerL, centerP, centerS] = center;\r\n\r\n  inverts.precalculated = (pointLPS) => {\r\n    // Calculate the sum of normalized squared distances\r\n    const dx = pointLPS[0] - centerL;\r\n    let inside = dx * dx * invXRadiusSq;\r\n    if (inside > 1) {\r\n      return false;\r\n    }\r\n\r\n    const dy = pointLPS[1] - centerP;\r\n    inside += dy * dy * invYRadiusSq;\r\n    if (inside > 1) {\r\n      return false;\r\n    }\r\n\r\n    const dz = pointLPS[2] - centerS;\r\n    inside += dz * dz * invZRadiusSq;\r\n\r\n    // Check if the point is inside the ellipse\r\n    return inside <= 1;\r\n  };\r\n\r\n  return inverts;\r\n};\r\n\r\nexport { precalculatePointInEllipse };\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\nexport type CanvasCoordinates = [\r\n  Types.Point2, // bottom\r\n  Types.Point2, // top\r\n  Types.Point2, // left\r\n  Types.Point2 // right\r\n];\r\n\r\n/**\r\n * It takes the canvas coordinates of the ellipse corners and returns the top left and bottom right\r\n * corners of it\r\n *\r\n * @param ellipseCanvasPoints - The coordinates of the ellipse in the canvas.\r\n * @returns An array of two points.\r\n */\r\nexport default function getCanvasEllipseCorners(\r\n  ellipseCanvasPoints: CanvasCoordinates\r\n): Array<Types.Point2> {\r\n  const [bottom, top, left, right] = ellipseCanvasPoints;\r\n\r\n  const topLeft = <Types.Point2>[left[0], top[1]];\r\n  const bottomRight = <Types.Point2>[right[0], bottom[1]];\r\n\r\n  return [topLeft, bottomRight];\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport * as math from '../';\r\n\r\n/**\r\n * Calculate the closest point and the squared distance between a reference point and a line segment.\r\n *\r\n * It projects the reference point onto the line segment but it shall be bounded by the\r\n * start/end points since this is a line segment and not a line which could be extended.\r\n *\r\n * @param lineStart - Start point of the line segment\r\n * @param lineEnd - End point of the line segment\r\n * @param point - Reference point\r\n * @returns Closest point and the squared distance between a `point` and a line\r\n *   segment defined by `lineStart` and `lineEnd` points\r\n */\r\nexport default function distanceToPointSquaredInfo(\r\n  lineStart: Types.Point2,\r\n  lineEnd: Types.Point2,\r\n  point: Types.Point2\r\n): {\r\n  point: Types.Point2;\r\n  distanceSquared: number;\r\n} {\r\n  let closestPoint: Types.Point2;\r\n  const distanceSquared = math.point.distanceToPointSquared(lineStart, lineEnd);\r\n\r\n  // Check if lineStart equal to the lineEnd which means the closest point\r\n  // is any of these two points\r\n  if (lineStart[0] === lineEnd[0] && lineStart[1] === lineEnd[1]) {\r\n    closestPoint = lineStart;\r\n  }\r\n\r\n  if (!closestPoint) {\r\n    const dotProduct =\r\n      ((point[0] - lineStart[0]) * (lineEnd[0] - lineStart[0]) +\r\n        (point[1] - lineStart[1]) * (lineEnd[1] - lineStart[1])) /\r\n      distanceSquared;\r\n\r\n    if (dotProduct < 0) {\r\n      closestPoint = lineStart;\r\n    } else if (dotProduct > 1) {\r\n      closestPoint = lineEnd;\r\n    } else {\r\n      closestPoint = [\r\n        lineStart[0] + dotProduct * (lineEnd[0] - lineStart[0]),\r\n        lineStart[1] + dotProduct * (lineEnd[1] - lineStart[1]),\r\n      ];\r\n    }\r\n  }\r\n\r\n  return {\r\n    point: [...closestPoint],\r\n    distanceSquared: math.point.distanceToPointSquared(point, closestPoint),\r\n  };\r\n}\r\n","import { Types } from '@cornerstonejs/core';\r\nimport distanceToPointSquaredInfo from './distanceToPointSquaredInfo';\r\n\r\n/**\r\n * Calculates the distance-squared of a point to a line segment\r\n *\r\n * @param lineStart - x,y coordinates of the start of the line\r\n * @param lineEnd - x,y coordinates of the end of the line\r\n * @param point - x,y of the point\r\n * @returns distance-squared\r\n */\r\nexport default function distanceToPointSquared(\r\n  lineStart: Types.Point2,\r\n  lineEnd: Types.Point2,\r\n  point: Types.Point2\r\n): number {\r\n  return distanceToPointSquaredInfo(lineStart, lineEnd, point).distanceSquared;\r\n}\r\n","import distanceToPointSquared from './distanceToPointSquared';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Calculates the distance of a point to a line\r\n *\r\n * @param lineStart - x,y coordinates of the start of the line\r\n * @param lineEnd - x,y coordinates of the end of the line\r\n * @param point - x,y of the point\r\n * @returns distance\r\n */\r\nexport default function distanceToPoint(\r\n  lineStart: Types.Point2,\r\n  lineEnd: Types.Point2,\r\n  point: Types.Point2\r\n): number {\r\n  if (lineStart.length !== 2 || lineEnd.length !== 2 || point.length !== 2) {\r\n    throw Error(\r\n      'lineStart, lineEnd, and point should have 2 elements of [x, y]'\r\n    );\r\n  }\r\n\r\n  return Math.sqrt(distanceToPointSquared(lineStart, lineEnd, point));\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\n// Returns sign of number\r\nfunction sign(x: any) {\r\n  return typeof x === 'number'\r\n    ? x\r\n      ? x < 0\r\n        ? -1\r\n        : 1\r\n      : x === x\r\n      ? 0\r\n      : NaN\r\n    : NaN;\r\n}\r\n\r\n/**\r\n * Calculates the intersection point between two lines in the 2D plane\r\n *\r\n * @param line1Start - x,y coordinates of the start of the first line\r\n * @param line1End - x,y coordinates of the end of the first line\r\n * @param line2Start - x,y coordinates of the start of the second line\r\n * @param line2End - x,y coordinates of the end of the second line\r\n * @returns [x,y] - point x,y of the point\r\n */\r\n\r\nexport default function intersectLine(\r\n  line1Start: Types.Point2,\r\n  line1End: Types.Point2,\r\n  line2Start: Types.Point2,\r\n  line2End: Types.Point2\r\n): number[] {\r\n  const [x1, y1] = line1Start;\r\n  const [x2, y2] = line1End;\r\n  const [x3, y3] = line2Start;\r\n  const [x4, y4] = line2End;\r\n\r\n  // Compute a1, b1, c1, where line joining points 1 and 2 is \"a1 x  +  b1 y  +  c1  =  0\"\r\n  const a1 = y2 - y1;\r\n  const b1 = x1 - x2;\r\n  const c1 = x2 * y1 - x1 * y2;\r\n\r\n  // Compute r3 and r4\r\n  const r3 = a1 * x3 + b1 * y3 + c1;\r\n  const r4 = a1 * x4 + b1 * y4 + c1;\r\n\r\n  /* Check signs of r3 and r4.  If both point 3 and point 4 lie on\r\n   * same side of line 1, the line segments do not intersect.\r\n   */\r\n\r\n  if (r3 !== 0 && r4 !== 0 && sign(r3) === sign(r4)) {\r\n    return;\r\n  }\r\n\r\n  // Compute a2, b2, c2\r\n  const a2 = y4 - y3;\r\n  const b2 = x3 - x4;\r\n  const c2 = x4 * y3 - x3 * y4;\r\n\r\n  // Compute r1 and r2\r\n  const r1 = a2 * x1 + b2 * y1 + c2;\r\n  const r2 = a2 * x2 + b2 * y2 + c2;\r\n\r\n  /* Check signs of r1 and r2.  If both point 1 and point 2 lie\r\n   * on same side of second line segment, the line segments do\r\n   * not intersect.\r\n   */\r\n\r\n  if (r1 !== 0 && r2 !== 0 && sign(r1) === sign(r2)) {\r\n    return;\r\n  }\r\n\r\n  /* Line segments intersect: compute intersection point.\r\n   */\r\n\r\n  const denom = a1 * b2 - a2 * b1;\r\n  let num;\r\n\r\n  /* The denom/2 is to get rounding instead of truncating.  It\r\n   * is added or subtracted to the numerator, depending upon the\r\n   * sign of the numerator.\r\n   */\r\n\r\n  num = b1 * c2 - b2 * c1;\r\n  const x = num / denom;\r\n\r\n  num = a2 * c1 - a1 * c2;\r\n  const y = num / denom;\r\n\r\n  const intersectionPoint = [x, y];\r\n\r\n  return intersectionPoint;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\nconst ORIENTATION_TOLERANCE = 1e-2;\r\n\r\n/**\r\n * Test if a point is on a line segment\r\n * @param lineStart - Line segment start point\r\n * @param lineEnd - Line segment end point\r\n * @param point - Point to test\r\n * @returns True if the point lies on the line segment or false otherwise\r\n */\r\nexport default function isPointOnLineSegment(\r\n  lineStart: Types.Point2,\r\n  lineEnd: Types.Point2,\r\n  point: Types.Point2\r\n): boolean {\r\n  // The code below runs ~4x faster than calling `line.distanceToPointSquared()` (155 vs 598 ms)\r\n\r\n  // No Math.min/max call for better performance when testing thousands of points\r\n  const minX = lineStart[0] <= lineEnd[0] ? lineStart[0] : lineEnd[0];\r\n  const maxX = lineStart[0] >= lineEnd[0] ? lineStart[0] : lineEnd[0];\r\n  const minY = lineStart[1] <= lineEnd[1] ? lineStart[1] : lineEnd[1];\r\n  const maxY = lineStart[1] >= lineEnd[1] ? lineStart[1] : lineEnd[1];\r\n\r\n  // Checks if the point lies inside the AABB\r\n  const aabbContainsPoint =\r\n    point[0] >= minX - ORIENTATION_TOLERANCE &&\r\n    point[0] <= maxX + ORIENTATION_TOLERANCE &&\r\n    point[1] >= minY - ORIENTATION_TOLERANCE &&\r\n    point[1] <= maxY + ORIENTATION_TOLERANCE;\r\n\r\n  if (!aabbContainsPoint) {\r\n    return false;\r\n  }\r\n\r\n  // Now that we know the point is inside the AABB we check if it lies on the line segment\r\n  const orientation =\r\n    (lineEnd[1] - lineStart[1]) * (point[0] - lineEnd[0]) -\r\n    (lineEnd[0] - lineStart[0]) * (point[1] - lineEnd[1]);\r\n  const absOrientation = orientation >= 0 ? orientation : -orientation;\r\n\r\n  // The orientation must be zero for points that lies on the same line\r\n  return absOrientation <= ORIENTATION_TOLERANCE;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport distanceToPointSquared from './distanceToPointSquared';\r\n\r\ntype Point = Types.Point2 | Types.Point3;\r\n\r\n/**\r\n * Calculates the distance of a point to another point\r\n *\r\n * @param p1 - x,y or x,y,z of the point\r\n * @param p2 - x,y or x,y,z of the point\r\n * @returns distance\r\n */\r\nexport default function distanceToPoint(p1: Point, p2: Point): number {\r\n  return Math.sqrt(distanceToPointSquared(p1, p2));\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\ntype Point = Types.Point2 | Types.Point3;\r\n\r\n/**\r\n * Calculates the distance squared of a point to another point\r\n *\r\n * @param p1 - x,y or x,y,z of the point\r\n * @param p2 - x,y or x,y,z of the point\r\n * @returns distance\r\n */\r\nexport default function distanceToPointSquared(p1: Point, p2: Point): number {\r\n  if (p1.length !== p2.length) {\r\n    throw Error('Both points should have the same dimensionality');\r\n  }\r\n\r\n  const [x1, y1, z1 = 0] = p1;\r\n  const [x2, y2, z2 = 0] = p2;\r\n  const dx = x2 - x1;\r\n  const dy = y2 - y1;\r\n  const dz = z2 - z1;\r\n\r\n  // Time to square 10M numbers:\r\n  //   (n * n) = 161ms | (n ** 2) = 199ms | Math.pow(n, 2) = 29529ms\r\n  return dx * dx + dy * dy + dz * dz;\r\n}\r\n","import { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Get a mirrored point along the line created by two points where one of them\r\n * is the static (\"anchor\") point and the other one is the point to be mirroed.\r\n * @param mirrorPoint - 2D Point to be mirroed\r\n * @param staticPoint - Static 2D point\r\n * @returns Mirroed 2D point\r\n */\r\nexport default function mirror(\r\n  mirrorPoint: Types.Point2,\r\n  staticPoint: Types.Point2\r\n): Types.Point2 {\r\n  const [x1, y1] = mirrorPoint;\r\n  const [x2, y2] = staticPoint;\r\n\r\n  const newX = 2 * x2 - x1;\r\n  const newY = 2 * y2 - y1;\r\n\r\n  return [newX, newY];\r\n}\r\n","import { glMatrix } from 'gl-matrix';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport * as math from '..';\r\n\r\n/**\r\n * A polyline is considered closed if the start and end points are at the same position\r\n *\r\n * @param polyline - Polyline points (2D)\r\n * @returns True if the polyline is already closed or false otherwise\r\n */\r\nexport default function isClosed(polyline: Types.Point2[]): boolean {\r\n  if (polyline.length < 3) {\r\n    return false;\r\n  }\r\n\r\n  const numPolylinePoints = polyline.length;\r\n\r\n  const firstPoint = polyline[0];\r\n  const lastPoint = polyline[numPolylinePoints - 1];\r\n  const distFirstToLastPoints = math.point.distanceToPointSquared(\r\n    firstPoint,\r\n    lastPoint\r\n  );\r\n\r\n  return glMatrix.equals(0, distFirstToLastPoints);\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport isClosed from './isClosed';\r\n\r\n/**\r\n * Checks if a 2D point is inside the polyline.\r\n *\r\n * A point is inside a curve/polygon if the number of intersections between the horizontal\r\n * ray emanating from the given point and to the right and the line segments is odd.\r\n * https://www.eecs.umich.edu/courses/eecs380/HANDOUTS/PROJ2/InsidePoly.html\r\n *\r\n * Note that a point on the polyline is considered inside.\r\n *\r\n * @param polyline - Polyline points (2D)\r\n * @param point - 2D Point\r\n * @returns True if the point is inside the polyline or false otherwise\r\n */\r\nexport default function containsPoint(\r\n  polyline: Types.Point2[],\r\n  point: Types.Point2,\r\n  options: {\r\n    closed?: boolean;\r\n    holes?: Types.Point2[][];\r\n  } = {\r\n    closed: undefined,\r\n  }\r\n): boolean {\r\n  if (polyline.length < 3) {\r\n    return false;\r\n  }\r\n\r\n  const numPolylinePoints = polyline.length;\r\n  let numIntersections = 0;\r\n\r\n  const { closed, holes } = options;\r\n\r\n  if (holes?.length) {\r\n    for (const hole of holes) {\r\n      if (containsPoint(hole, point)) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Test intersection against [end, start] line segment if it should be closed\r\n  const shouldClose = !(closed === undefined ? isClosed(polyline) : closed);\r\n  const maxSegmentIndex = polyline.length - (shouldClose ? 1 : 2);\r\n\r\n  for (let i = 0; i <= maxSegmentIndex; i++) {\r\n    const p1 = polyline[i];\r\n\r\n    // Calculating the next point index without using % (mod) operator like in\r\n    // `(i + 1) % numPolylinePoints` to make it 20% faster\r\n    const p2Index = i === numPolylinePoints - 1 ? 0 : i + 1;\r\n    const p2 = polyline[p2Index];\r\n\r\n    // Calculating min/max without using Math.min/max to make it ~3% faster\r\n    const maxX = p1[0] >= p2[0] ? p1[0] : p2[0];\r\n    const maxY = p1[1] >= p2[1] ? p1[1] : p2[1];\r\n    const minY = p1[1] <= p2[1] ? p1[1] : p2[1];\r\n\r\n    const mayIntersectLineSegment =\r\n      point[0] <= maxX && point[1] >= minY && point[1] < maxY;\r\n\r\n    if (mayIntersectLineSegment) {\r\n      const isVerticalLine = p1[0] === p2[0];\r\n      let intersects = isVerticalLine;\r\n\r\n      if (!intersects) {\r\n        const xIntersection =\r\n          ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];\r\n\r\n        intersects = point[0] <= xIntersection;\r\n      }\r\n\r\n      numIntersections += intersects ? 1 : 0;\r\n    }\r\n  }\r\n\r\n  return !!(numIntersections % 2);\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport containsPoint from './containsPoint';\r\n\r\n/**\r\n * Checks if a polyline contains a set of points.\r\n *\r\n * @param polyline - Polyline points (2D)\r\n * @param points - 2D points to verify\r\n * @returns True if all points are inside the polyline or false otherwise\r\n */\r\nexport default function containsPoints(\r\n  polyline: Types.Point2[],\r\n  points: Types.Point2[]\r\n): boolean {\r\n  for (let i = 0, numPoint = points.length; i < numPoint; i++) {\r\n    if (!containsPoint(polyline, points[i])) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Calculates the area of an array of `Point2` points using the shoelace algorithm.\r\n *\r\n * The units of the area are in the same units as the points are in. E.g. if\r\n * the points are in canvas, then the result is in canvas pixels ^2; If they are\r\n * in mm, then the result is in mm^2; etc.\r\n */\r\nexport default function getArea(points: Types.Point2[]): number {\r\n  // Shoelace algorithm.\r\n  const n = points.length;\r\n  let area = 0.0;\r\n  let j = n - 1;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);\r\n    j = i; // j is previous vertex to i\r\n  }\r\n\r\n  // Return absolute value of half the sum (half as summing up traingles).\r\n  return Math.abs(area / 2.0);\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Returns the area with signal of a 2D polyline\r\n * https://www.youtube.com/watch?v=GpsKrAipXm8&t=1900s\r\n *\r\n * This functions has a runtime very close to `getArea` and it is recommended to\r\n * be called only if you need the area signal (eg: calculate polygon normal or\r\n * winding direction). If you do not need the area signal you should always call\r\n * `getArea`.\r\n *\r\n * @param polyline - Polyline points (2D)\r\n * @returns Area of the polyline (with signal)\r\n */\r\nexport default function getSignedArea(polyline: Types.Point2[]): number {\r\n  if (polyline.length < 3) {\r\n    return 0;\r\n  }\r\n\r\n  // Reference point can be any point on the same plane\r\n  const refPoint = polyline[0];\r\n  let area = 0;\r\n\r\n  // Takes three points (reference point and two other points from each line\r\n  // segment) and calculate the area with cross product. The magnitude of the\r\n  // vector returned by a cross product is equal to the area of the parallelogram\r\n  // that the vectors span which is two times the area of the triangle.\r\n  //\r\n  // Not calling vec3 mathods makes the function run much faster since polylines\r\n  // may have thousands of points when using freehand ROI tool and that would\r\n  // increase considerably the number of function calls.\r\n  for (let i = 0, len = polyline.length; i < len; i++) {\r\n    const p1 = polyline[i];\r\n    // Using ternary instead of % (mod) operator to make it faster\r\n    const p2Index = i === len - 1 ? 0 : i + 1;\r\n    const p2 = polyline[p2Index];\r\n    const aX = p1[0] - refPoint[0];\r\n    const aY = p1[1] - refPoint[1];\r\n    const bX = p2[0] - refPoint[0];\r\n    const bY = p2[1] - refPoint[1];\r\n\r\n    // Cross product between vectors \"a\" and \"b\" which returns (0, 0, crossProd)\r\n    // for 2D vectors.\r\n    area += aX * bY - aY * bX;\r\n  }\r\n\r\n  // Divide by two because cross product returns two times the area for each triangle\r\n  area *= 0.5;\r\n\r\n  return area;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport getSignedArea from './getSignedArea';\r\n\r\n/**\r\n * Calculate the winding direction (CW or CCW) of a polyline\r\n * @param polyline - Polyline (2D)\r\n * @returns 1 for CW or -1 for CCW polylines\r\n */\r\nexport default function getWindingDirection(polyline: Types.Point2[]): number {\r\n  const signedArea = getSignedArea(polyline);\r\n\r\n  // Return 1 or -1 which is also possible to convert into ContourOrientation\r\n  return signedArea >= 0 ? 1 : -1;\r\n}\r\n","import { vec3 } from 'gl-matrix';\r\nimport { Types } from '@cornerstonejs/core';\r\n\r\nfunction _getAreaVector(polyline: Types.Point3[]): Types.Point3 {\r\n  const vecArea = vec3.create();\r\n\r\n  // Reference point can be any point on the same plane\r\n  const refPoint = polyline[0];\r\n\r\n  // Takes three points, reference point and two other points from each line\r\n  // segment, and calculate the area with cross product. The magnitude of the\r\n  // vector returned by a cross product is equal to the area of the parallelogram\r\n  // that the vectors span which is two times the area of the triangle.\r\n  //\r\n  // Not calling vec3 mathods makes the function run much faster since polylines\r\n  // may have thousands of points when using freehand ROI tool and that would\r\n  // increase considerably the number of function calls.\r\n  for (let i = 0, len = polyline.length; i < len; i++) {\r\n    const p1 = polyline[i];\r\n    // Using ternary instead of % (mod) operator to make it faster\r\n    const p2Index = i === len - 1 ? 0 : i + 1;\r\n    const p2 = polyline[p2Index];\r\n\r\n    const aX = p1[0] - refPoint[0];\r\n    const aY = p1[1] - refPoint[1];\r\n    const aZ = p1[2] - refPoint[2];\r\n    const bX = p2[0] - refPoint[0];\r\n    const bY = p2[1] - refPoint[1];\r\n    const bZ = p2[2] - refPoint[2];\r\n\r\n    // Cross product without calling vec3.cross() for better performance\r\n    vecArea[0] += aY * bZ - aZ * bY;\r\n    vecArea[1] += aZ * bX - aX * bZ;\r\n    vecArea[2] += aX * bY - aY * bX;\r\n  }\r\n\r\n  // Divide by two because cross product returns two times the area for each triangle\r\n  vec3.scale(vecArea, vecArea, 0.5);\r\n\r\n  // The magnitude of the vector is the area of the polyline\r\n  return <Types.Point3>vecArea;\r\n}\r\n\r\n/**\r\n * Calculate the normal of a 3D planar polyline\r\n * @param polyline - Planar polyline in 3D space\r\n * @returns Normal of the 3D planar polyline\r\n */\r\nexport default function getNormal3(polyline: Types.Point3[]): Types.Point3 {\r\n  const vecArea = _getAreaVector(polyline);\r\n\r\n  return vec3.normalize(vecArea, vecArea) as Types.Point3;\r\n}\r\n","import { Types } from '@cornerstonejs/core';\r\nimport getSignedArea from './getSignedArea';\r\n\r\n/**\r\n * Calculate the normal of a 2D polyline\r\n * https://www.youtube.com/watch?v=GpsKrAipXm8&t=1982s\r\n *\r\n * @param polyline - Planar polyline in 2D space\r\n * @returns Normal of the 2D planar polyline\r\n */\r\nexport default function getNormal2(polyline: Types.Point2[]): Types.Point3 {\r\n  const area = getSignedArea(polyline);\r\n\r\n  // The normal of a 2D polyline is (0, 0, 1) or (0, 0, -1) depending if it\r\n  // is CW or CCW polyline\r\n  return [0, 0, area / Math.abs(area)] as Types.Point3;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\n// ATTENTION: this is an internal function and it should not be added to \"polyline\"\r\n// namespace.\r\n//\r\n// TODO: there is a similar function in math.lineSegment.intersectLine but we\r\n// need to investigate why it is 6x slower than this one when thousands of\r\n// intersections are calculated. Also that one may return [NaN, NaN] for\r\n// collinear points.\r\n\r\n/**\r\n * Checks whether the line (`p1`,`q1`) intersects the line (`p2`,`q2`) via an\r\n * orientation algorithm.\r\n *\r\n * Credit and details: geeksforgeeks.org/check-if-two-given-line-segments-intersect/\r\n *\r\n * @param p1 - Start point of line segment 1\r\n * @param q1 - End point of line segment 1\r\n * @param p2 - Start point of line segment 2\r\n * @param q2 - End point of line segment 2\r\n * @returns True if the line segments intersect or false otherwise\r\n */\r\nexport default function areLineSegmentsIntersecting(\r\n  p1: Types.Point2,\r\n  q1: Types.Point2,\r\n  p2: Types.Point2,\r\n  q2: Types.Point2\r\n): boolean {\r\n  let result = false;\r\n\r\n  // Line 1 AABB\r\n  const line1MinX = p1[0] < q1[0] ? p1[0] : q1[0];\r\n  const line1MinY = p1[1] < q1[1] ? p1[1] : q1[1];\r\n  const line1MaxX = p1[0] > q1[0] ? p1[0] : q1[0];\r\n  const line1MaxY = p1[1] > q1[1] ? p1[1] : q1[1];\r\n\r\n  // Line 2 AABB\r\n  const line2MinX = p2[0] < q2[0] ? p2[0] : q2[0];\r\n  const line2MinY = p2[1] < q2[1] ? p2[1] : q2[1];\r\n  const line2MaxX = p2[0] > q2[0] ? p2[0] : q2[0];\r\n  const line2MaxY = p2[1] > q2[1] ? p2[1] : q2[1];\r\n\r\n  // If AABBs do not intersect it is impossible for the lines to intersect.\r\n  // Checking AABB before doing any math makes it run ~12% faster.\r\n  if (\r\n    line1MinX > line2MaxX ||\r\n    line1MaxX < line2MinX ||\r\n    line1MinY > line2MaxY ||\r\n    line1MaxY < line2MinY\r\n  ) {\r\n    return false;\r\n  }\r\n\r\n  const orient = [\r\n    orientation(p1, q1, p2),\r\n    orientation(p1, q1, q2),\r\n    orientation(p2, q2, p1),\r\n    orientation(p2, q2, q1),\r\n  ];\r\n\r\n  // General Case\r\n  if (orient[0] !== orient[1] && orient[2] !== orient[3]) {\r\n    return true;\r\n  }\r\n\r\n  // Special Cases\r\n  if (orient[0] === 0 && onSegment(p1, p2, q1)) {\r\n    // If p1, q1 and p2 are colinear and p2 lies on segment p1q1\r\n    result = true;\r\n  } else if (orient[1] === 0 && onSegment(p1, q2, q1)) {\r\n    // If p1, q1 and p2 are colinear and q2 lies on segment p1q1\r\n    result = true;\r\n  } else if (orient[2] === 0 && onSegment(p2, p1, q2)) {\r\n    // If p2, q2 and p1 are colinear and p1 lies on segment p2q2\r\n    result = true;\r\n  } else if (orient[3] === 0 && onSegment(p2, q1, q2)) {\r\n    // If p2, q2 and q1 are colinear and q1 lies on segment p2q2\r\n    result = true;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Checks the orientation of 3 points, returns a 0, 1 or 2 based on\r\n * the orientation of the points.\r\n */\r\nfunction orientation(\r\n  p: Types.Point2,\r\n  q: Types.Point2,\r\n  r: Types.Point2\r\n): number {\r\n  // Take the cross product between vectors PQ and QR\r\n  const orientationValue =\r\n    (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\r\n\r\n  if (orientationValue === 0) {\r\n    return 0; // Colinear\r\n  }\r\n\r\n  return orientationValue > 0 ? 1 : 2;\r\n}\r\n\r\n/**\r\n * Checks if point `q` lies on the segment (`p`,`r`).\r\n */\r\nfunction onSegment(p: Types.Point2, q: Types.Point2, r: Types.Point2): boolean {\r\n  if (\r\n    q[0] <= Math.max(p[0], r[0]) &&\r\n    q[0] >= Math.min(p[0], r[0]) &&\r\n    q[1] <= Math.max(p[1], r[1]) &&\r\n    q[1] >= Math.min(p[1], r[1])\r\n  ) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\r\n\r\n/**\r\n * Get all intersections between a polyline and a line segment.\r\n * @param polyline - Polyline points\r\n * @param p1 - Start point of line segment\r\n * @param q1 - End point of line segment\r\n * @param closed - Test the intersection against the line segment that connects\r\n * the last to the first point when set to true\r\n * @returns Start/end point indexes of all line segments that intersect (p1, q1)\r\n */\r\nexport default function getLineSegmentIntersectionsIndexes(\r\n  polyline: Types.Point2[],\r\n  p1: Types.Point2,\r\n  q1: Types.Point2,\r\n  closed = true\r\n): Types.Point2[] {\r\n  const intersections: Types.Point2[] = [];\r\n  const numPoints = polyline.length;\r\n  const maxI = numPoints - (closed ? 1 : 2);\r\n\r\n  for (let i = 0; i <= maxI; i++) {\r\n    const p2 = polyline[i];\r\n    // Do not use % operator for better performance\r\n    const j = i === numPoints - 1 ? 0 : i + 1;\r\n    const q2 = polyline[j];\r\n\r\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\r\n      intersections.push([i, j]);\r\n    }\r\n  }\r\n\r\n  return intersections;\r\n}\r\n","import { Types } from '@cornerstonejs/core';\r\nimport * as mathLine from '../line';\r\n\r\n// ATTENTION: this is an internal function and it should not be added to \"polyline\" namespace\r\n\r\n// Tested with +1M random overlapping line segments and any tolerance below this\r\n// one may return invalid results.\r\nconst PARALLEL_LINES_TOLERANCE = 1e-2;\r\n\r\n/**\r\n * It returns the intersection between two lines (not line segments) or a midpoint\r\n * when the line segments overlap. This function calculates the intersection between\r\n * lines because it considers that getFirstLineSegmentIntersectionIndexes,\r\n * getLineSegmentIntersectionsCoordinates or getLineSegmentIntersectionsIndexes\r\n * has already been called first which guarantees.\r\n *\r\n * @param p1 - Line segment 1 start\r\n * @param q1 - Line segment 1 end\r\n * @param p2 - Line segment 2 start\r\n * @param q2 - Line segment 21 end\r\n * @returns The intersection between two lines or a midpoint when they overlap\r\n */\r\nexport default function getLinesIntersection(\r\n  p1: Types.Point2,\r\n  q1: Types.Point2,\r\n  p2: Types.Point2,\r\n  q2: Types.Point2\r\n) {\r\n  const diffQ1P1 = [q1[0] - p1[0], q1[1] - p1[1]];\r\n  const diffQ2P2 = [q2[0] - p2[0], q2[1] - p2[1]];\r\n  const denominator = diffQ2P2[1] * diffQ1P1[0] - diffQ2P2[0] * diffQ1P1[1];\r\n  const absDenominator = denominator >= 0 ? denominator : -denominator;\r\n\r\n  if (absDenominator < PARALLEL_LINES_TOLERANCE) {\r\n    // No Math.min/max calls for better performance.\r\n    const line1AABB = [\r\n      p1[0] < q1[0] ? p1[0] : q1[0], // 0: minX\r\n      p1[0] > q1[0] ? p1[0] : q1[0], // 1: maxX\r\n      p1[1] < q1[1] ? p1[1] : q1[1], // 2: minY\r\n      p1[1] > q1[1] ? p1[1] : q1[1], // 3: maxY\r\n    ];\r\n\r\n    // No Math.min/max calls for better performance.\r\n    const line2AABB = [\r\n      p2[0] < q2[0] ? p2[0] : q2[0], // 0: minX\r\n      p2[0] > q2[0] ? p2[0] : q2[0], // 1: maxX\r\n      p2[1] < q2[1] ? p2[1] : q2[1], // 2: minY\r\n      p2[1] > q2[1] ? p2[1] : q2[1], // 3: maxY\r\n    ];\r\n\r\n    const aabbIntersects =\r\n      line1AABB[0] <= line2AABB[1] && // minX1 <= maxX2\r\n      line1AABB[1] >= line2AABB[0] && // maxX1 >= minX2\r\n      line1AABB[2] <= line2AABB[3] && // minY1 <= maxY2\r\n      line1AABB[3] >= line2AABB[2]; // maxY1 >= minY2\r\n\r\n    if (!aabbIntersects) {\r\n      return;\r\n    }\r\n\r\n    // Three tests are enough to know if the lines overlap\r\n    const overlap =\r\n      mathLine.isPointOnLineSegment(p1, q1, p2) ||\r\n      mathLine.isPointOnLineSegment(p1, q1, q2) ||\r\n      mathLine.isPointOnLineSegment(p2, q2, p1);\r\n\r\n    if (!overlap) {\r\n      return;\r\n    }\r\n\r\n    // min/max seems to be inverted but that is correct because it is looking\r\n    // for the intersection range. No Math.min/max calls for better performance.\r\n    const minX = line1AABB[0] > line2AABB[0] ? line1AABB[0] : line2AABB[0];\r\n    const maxX = line1AABB[1] < line2AABB[1] ? line1AABB[1] : line2AABB[1];\r\n    const minY = line1AABB[2] > line2AABB[2] ? line1AABB[2] : line2AABB[2];\r\n    const maxY = line1AABB[3] < line2AABB[3] ? line1AABB[3] : line2AABB[3];\r\n    const midX = (minX + maxX) * 0.5;\r\n    const midY = (minY + maxY) * 0.5;\r\n\r\n    return [midX, midY];\r\n  }\r\n\r\n  let a = p1[1] - p2[1];\r\n  let b = p1[0] - p2[0];\r\n  const numerator1 = diffQ2P2[0] * a - diffQ2P2[1] * b;\r\n  const numerator2 = diffQ1P1[0] * a - diffQ1P1[1] * b;\r\n  a = numerator1 / denominator;\r\n  b = numerator2 / denominator;\r\n\r\n  const resultX = p1[0] + a * diffQ1P1[0];\r\n  const resultY = p1[1] + a * diffQ1P1[1];\r\n\r\n  return [resultX, resultY];\r\n}\r\n","import { Types } from '@cornerstonejs/core';\r\nimport * as mathPoint from '../point';\r\nimport getLineSegmentIntersectionsIndexes from './getLineSegmentIntersectionsIndexes';\r\nimport containsPoint from './containsPoint';\r\nimport getNormal2 from './getNormal2';\r\nimport { glMatrix, vec3 } from 'gl-matrix';\r\nimport getLinesIntersection from './getLinesIntersection';\r\n\r\nenum PolylinePointType {\r\n  Vertex,\r\n  Intersection,\r\n}\r\n\r\n// Position of the point related to the intersection region\r\nenum PolylinePointPosition {\r\n  Outside = -1,\r\n  Edge = 0,\r\n  Inside = 1,\r\n}\r\n\r\n// Direction from last point to the intersection point to know if it is entering\r\n// or exiting the intersection region\r\nenum PolylinePointDirection {\r\n  Exiting = -1,\r\n  Unknown = 0,\r\n  Entering = 1,\r\n}\r\n\r\ntype PolylinePoint = {\r\n  type: PolylinePointType;\r\n  coordinates: Types.Point2;\r\n  position?: PolylinePointPosition;\r\n  visited: boolean;\r\n  next: PolylinePoint;\r\n};\r\n\r\ntype PolylineIntersectionPoint = PolylinePoint & {\r\n  direction: PolylinePointDirection;\r\n  cloned?: boolean;\r\n};\r\n\r\n/**\r\n * Ensure all polyline point objects are pointing to the next object in case\r\n * it is still not point to anyone.\r\n * @param polylinePoints - Array that contains all polyline points (vertices and intersections)\r\n */\r\nfunction ensuresNextPointers(polylinePoints: PolylinePoint[]) {\r\n  // Make sure all nodes point to a valid node\r\n  for (let i = 0, len = polylinePoints.length; i < len; i++) {\r\n    const currentPoint = polylinePoints[i];\r\n\r\n    if (!currentPoint.next) {\r\n      currentPoint.next = polylinePoints[i === len - 1 ? 0 : i + 1];\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Creates one linked list per polyline that contains all vertices and intersections\r\n * found while walking along the edges.\r\n *\r\n * @param targetPolyline - Target polyline\r\n * @param sourcePolyline - Source polyline\r\n * @returns Two linked lists with all vertices and intersections.\r\n */\r\nfunction getSourceAndTargetPointsList(\r\n  targetPolyline: Types.Point2[],\r\n  sourcePolyline: Types.Point2[]\r\n) {\r\n  const targetPolylinePoints: PolylinePoint[] = [];\r\n  const sourcePolylinePoints: PolylinePoint[] = [];\r\n  const sourceIntersectionsCache = new Map<\r\n    number,\r\n    PolylineIntersectionPoint[]\r\n  >();\r\n\r\n  const isFirstPointInside = containsPoint(sourcePolyline, targetPolyline[0]);\r\n\r\n  let intersectionPointDirection = isFirstPointInside\r\n    ? PolylinePointDirection.Exiting\r\n    : PolylinePointDirection.Entering;\r\n\r\n  // Store all vertices and intersection for target contour\r\n  for (let i = 0, len = targetPolyline.length; i < len; i++) {\r\n    const p1 = targetPolyline[i];\r\n    const pointInside = containsPoint(sourcePolyline, p1);\r\n    const vertexPoint: PolylinePoint = {\r\n      type: PolylinePointType.Vertex,\r\n      coordinates: p1,\r\n      position: pointInside\r\n        ? PolylinePointPosition.Inside\r\n        : PolylinePointPosition.Outside,\r\n      visited: false,\r\n      next: null,\r\n    };\r\n\r\n    targetPolylinePoints.push(vertexPoint);\r\n\r\n    const q1 = targetPolyline[i === len - 1 ? 0 : i + 1];\r\n    const intersectionsInfo = getLineSegmentIntersectionsIndexes(\r\n      sourcePolyline,\r\n      p1,\r\n      q1\r\n    ).map((intersectedLineSegment) => {\r\n      const sourceLineSegmentId: number = intersectedLineSegment[0];\r\n      const p2 = sourcePolyline[intersectedLineSegment[0]];\r\n      const q2 = sourcePolyline[intersectedLineSegment[1]];\r\n\r\n      // lineSegment.intersectLine returns the midpoint of the four points\r\n      // when the lines are parallel or co-incident.  Otherwise it will return\r\n      // an extension of the line.\r\n      const intersectionCoordinate = getLinesIntersection(\r\n        p1,\r\n        q1,\r\n        p2,\r\n        q2\r\n      ) as Types.Point2;\r\n\r\n      const targetStartPointDistSquared = mathPoint.distanceToPointSquared(\r\n        p1,\r\n        intersectionCoordinate\r\n      );\r\n\r\n      return {\r\n        sourceLineSegmentId,\r\n        coordinate: intersectionCoordinate,\r\n        targetStartPointDistSquared,\r\n      };\r\n    });\r\n\r\n    intersectionsInfo.sort(\r\n      (left, right) =>\r\n        left.targetStartPointDistSquared - right.targetStartPointDistSquared\r\n    );\r\n\r\n    intersectionsInfo.forEach((intersectionInfo) => {\r\n      const { sourceLineSegmentId, coordinate: intersectionCoordinate } =\r\n        intersectionInfo;\r\n\r\n      // Intersection point to be added to the target polyline list\r\n      const targetEdgePoint: PolylineIntersectionPoint = {\r\n        type: PolylinePointType.Intersection,\r\n        coordinates: intersectionCoordinate,\r\n        position: PolylinePointPosition.Edge,\r\n        direction: intersectionPointDirection,\r\n        visited: false,\r\n        next: null,\r\n      };\r\n\r\n      // Intersection point to be added to the source polyline list.\r\n      // At this point there is no way to know if the point is entering or\r\n      // exiting the intersection region but that is not going to be used\r\n      // hence it is set to \"unknown\".\r\n      const sourceEdgePoint: PolylineIntersectionPoint = {\r\n        ...targetEdgePoint,\r\n        direction: PolylinePointDirection.Unknown,\r\n        cloned: true,\r\n      };\r\n\r\n      if (intersectionPointDirection === PolylinePointDirection.Entering) {\r\n        targetEdgePoint.next = sourceEdgePoint;\r\n      } else {\r\n        sourceEdgePoint.next = targetEdgePoint;\r\n      }\r\n\r\n      let sourceIntersectionPoints =\r\n        sourceIntersectionsCache.get(sourceLineSegmentId);\r\n\r\n      if (!sourceIntersectionPoints) {\r\n        sourceIntersectionPoints = [];\r\n        sourceIntersectionsCache.set(\r\n          sourceLineSegmentId,\r\n          sourceIntersectionPoints\r\n        );\r\n      }\r\n\r\n      targetPolylinePoints.push(targetEdgePoint);\r\n      sourceIntersectionPoints.push(sourceEdgePoint);\r\n\r\n      // Switches from \"exiting\" to \"entering\" and vice-versa\r\n      intersectionPointDirection *= -1;\r\n    });\r\n  }\r\n\r\n  // Store all vertices and intersections for source contour\r\n  for (let i = 0, len = sourcePolyline.length; i < len; i++) {\r\n    const lineSegmentId: number = i;\r\n    const p1 = sourcePolyline[i];\r\n    const vertexPoint: PolylinePoint = {\r\n      type: PolylinePointType.Vertex,\r\n      coordinates: p1,\r\n      visited: false,\r\n      next: null,\r\n    };\r\n\r\n    sourcePolylinePoints.push(vertexPoint);\r\n\r\n    const sourceIntersectionPoints =\r\n      sourceIntersectionsCache.get(lineSegmentId);\r\n\r\n    if (!sourceIntersectionPoints?.length) {\r\n      continue;\r\n    }\r\n\r\n    // Calculate the distance between each intersection point to the start point\r\n    // of the line segment, sort them by distance and return a sorted array that\r\n    // contains all intersection points.\r\n    sourceIntersectionPoints\r\n      .map((intersectionPoint) => ({\r\n        intersectionPoint,\r\n        lineSegStartDistSquared: mathPoint.distanceToPointSquared(\r\n          p1,\r\n          intersectionPoint.coordinates\r\n        ),\r\n      }))\r\n      .sort(\r\n        (left, right) =>\r\n          left.lineSegStartDistSquared - right.lineSegStartDistSquared\r\n      )\r\n      .map(({ intersectionPoint }) => intersectionPoint)\r\n      .forEach((intersectionPoint) =>\r\n        sourcePolylinePoints.push(intersectionPoint)\r\n      );\r\n  }\r\n\r\n  ensuresNextPointers(targetPolylinePoints);\r\n  ensuresNextPointers(sourcePolylinePoints);\r\n\r\n  return { targetPolylinePoints, sourcePolylinePoints };\r\n}\r\n\r\n/**\r\n * Get the next unvisited polyline points that is outside the intersection region.\r\n * @param polylinePoints - All polyline points (vertices and intersections)\r\n * @returns Any unvisited point that is outside the intersection region if it\r\n * exists or `undefined` otherwise\r\n */\r\nfunction getUnvisitedOutsidePoint(polylinePoints: PolylinePoint[]) {\r\n  for (let i = 0, len = polylinePoints.length; i < len; i++) {\r\n    const point = polylinePoints[i];\r\n\r\n    if (!point.visited && point.position === PolylinePointPosition.Outside) {\r\n      return point;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Merge two planar polylines (2D)\r\n */\r\nfunction mergePolylines(\r\n  targetPolyline: Types.Point2[],\r\n  sourcePolyline: Types.Point2[]\r\n) {\r\n  const targetNormal = getNormal2(targetPolyline);\r\n  const sourceNormal = getNormal2(sourcePolyline);\r\n  const dotNormals = vec3.dot(sourceNormal, targetNormal);\r\n\r\n  // Both polylines need to be CW or CCW to be merged and one of them needs to\r\n  // be reversed if theirs orientation are not the same\r\n  if (!glMatrix.equals(1, dotNormals)) {\r\n    sourcePolyline = sourcePolyline.slice().reverse();\r\n  }\r\n\r\n  const { targetPolylinePoints } = getSourceAndTargetPointsList(\r\n    targetPolyline,\r\n    sourcePolyline\r\n  );\r\n  const startPoint: PolylinePoint =\r\n    getUnvisitedOutsidePoint(targetPolylinePoints);\r\n\r\n  // Source polyline contains target polyline\r\n  if (!startPoint) {\r\n    return targetPolyline.slice();\r\n  }\r\n\r\n  const mergedPolyline = [startPoint.coordinates];\r\n  let currentPoint = startPoint.next;\r\n\r\n  while (currentPoint !== startPoint) {\r\n    if (\r\n      currentPoint.type === PolylinePointType.Intersection &&\r\n      (<PolylineIntersectionPoint>currentPoint).cloned\r\n    ) {\r\n      currentPoint = currentPoint.next;\r\n      continue;\r\n    }\r\n\r\n    mergedPolyline.push(currentPoint.coordinates);\r\n    currentPoint = currentPoint.next;\r\n  }\r\n\r\n  return mergedPolyline;\r\n}\r\n\r\n/**\r\n * Subtract two planar polylines (2D)\r\n */\r\nfunction subtractPolylines(\r\n  targetPolyline: Types.Point2[],\r\n  sourcePolyline: Types.Point2[]\r\n): Types.Point2[][] {\r\n  const targetNormal = getNormal2(targetPolyline);\r\n  const sourceNormal = getNormal2(sourcePolyline);\r\n  const dotNormals = vec3.dot(sourceNormal, targetNormal);\r\n\r\n  // The polylines need to have different orientation (CW+CCW or CCW+CW) to be\r\n  // subtracted and one of them needs to be reversed if theirs orientation are\r\n  // the same\r\n  if (!glMatrix.equals(-1, dotNormals)) {\r\n    sourcePolyline = sourcePolyline.slice().reverse();\r\n  }\r\n\r\n  const { targetPolylinePoints } = getSourceAndTargetPointsList(\r\n    targetPolyline,\r\n    sourcePolyline\r\n  );\r\n  let startPoint: PolylinePoint = null;\r\n  const subtractedPolylines = [];\r\n\r\n  while ((startPoint = getUnvisitedOutsidePoint(targetPolylinePoints))) {\r\n    const subtractedPolyline = [startPoint.coordinates];\r\n    let currentPoint = startPoint.next;\r\n\r\n    startPoint.visited = true;\r\n\r\n    while (currentPoint !== startPoint) {\r\n      currentPoint.visited = true;\r\n\r\n      if (\r\n        currentPoint.type === PolylinePointType.Intersection &&\r\n        (<PolylineIntersectionPoint>currentPoint).cloned\r\n      ) {\r\n        currentPoint = currentPoint.next;\r\n        continue;\r\n      }\r\n\r\n      subtractedPolyline.push(currentPoint.coordinates);\r\n      currentPoint = currentPoint.next;\r\n    }\r\n\r\n    subtractedPolylines.push(subtractedPolyline);\r\n  }\r\n\r\n  return subtractedPolylines;\r\n}\r\n\r\nexport { mergePolylines, subtractPolylines };\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\r\n\r\n/**\r\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\r\n * `points`, and returns the first value.\r\n *\r\n * @param points - Polyline points\r\n * @param p1 - First point of the line segment that is being tested\r\n * @param q1 - Second point of the line segment that is being tested\r\n * @param closed - Test the intersection with the line segment that connects\r\n *   the last and first points of the polyline\r\n * @returns Indexes of the line segment points from the polyline that intersects [p1, q1]\r\n */\r\nexport default function getFirstLineSegmentIntersectionIndexes(\r\n  points: Types.Point2[],\r\n  p1: Types.Point2,\r\n  q1: Types.Point2,\r\n  closed = true\r\n): Types.Point2 | undefined {\r\n  let initialI;\r\n  let j;\r\n\r\n  if (closed) {\r\n    j = points.length - 1;\r\n    initialI = 0;\r\n  } else {\r\n    j = 0;\r\n    initialI = 1;\r\n  }\r\n\r\n  for (let i = initialI; i < points.length; i++) {\r\n    const p2 = points[j];\r\n    const q2 = points[i];\r\n\r\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\r\n      return [j, i];\r\n    }\r\n\r\n    j = i;\r\n  }\r\n}\r\n","import { Types } from '@cornerstonejs/core';\r\nimport getFirstLineSegmentIntersectionIndexes from './getFirstLineSegmentIntersectionIndexes';\r\n\r\n/**\r\n * Check if two polylines intersect comparing line segment by line segment.\r\n * @param sourcePolyline - Source polyline\r\n * @param targetPolyline - Target polyline\r\n * @returns True if the polylines intersect or false otherwise\r\n */\r\nexport default function intersectPolyline(\r\n  sourcePolyline: Types.Point2[],\r\n  targetPolyline: Types.Point2[]\r\n): boolean {\r\n  // Naive way to detect intersection between polylines in O(n^2).\r\n  // TODO: Implement Bentley Ottmann sweep line algorithm or maybe some\r\n  // algorithm that uses r-tree may make it run faster\r\n  for (let i = 0, sourceLen = sourcePolyline.length; i < sourceLen; i++) {\r\n    const sourceP1 = sourcePolyline[i];\r\n    const sourceP2Index = i === sourceLen - 1 ? 0 : i + 1;\r\n    const sourceP2 = sourcePolyline[sourceP2Index];\r\n\r\n    const intersectionPointIndexes = getFirstLineSegmentIntersectionIndexes(\r\n      targetPolyline,\r\n      sourceP1,\r\n      sourceP2\r\n    );\r\n\r\n    if (intersectionPointIndexes?.length === 2) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport * as mathLine from '../line';\r\n\r\nconst DEFAULT_EPSILON = 0.1;\r\n\r\n/**\r\n * RamerDouglasPeucker algorithm implementation to decimate a polyline\r\n * to a similar polyline with fewer points\r\n *\r\n * https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\r\n * https://rosettacode.org/wiki/Ramer-Douglas-Peucker_line_simplification\r\n * https://karthaus.nl/rdp/\r\n *\r\n * @param polyline - Polyline to decimate\r\n * @param epsilon - A maximum given distance 'epsilon' to decide if a point\r\n * should or shouldn't be added the decimated polyline version. In each\r\n * iteration the polyline is split into two polylines and the distance of each\r\n * point from those new polylines are checked against the line that connects\r\n * the first and last points.\r\n * @returns Decimated polyline\r\n */\r\nexport default function decimate(\r\n  polyline: Types.Point2[],\r\n  epsilon = DEFAULT_EPSILON\r\n) {\r\n  const numPoints = polyline.length;\r\n\r\n  // The polyline must have at least a start and end points\r\n  if (numPoints < 3) {\r\n    return polyline;\r\n  }\r\n\r\n  const epsilonSquared = epsilon * epsilon;\r\n  const partitionQueue = [[0, numPoints - 1]];\r\n\r\n  // Used a boolean array to set each point that will be in the decimated polyline\r\n  // because pre-allocated arrays are 3-4x faster than thousands of push() calls\r\n  // to add all points to a new array.\r\n  const polylinePointFlags = new Array(numPoints).fill(false);\r\n\r\n  // Start and end points are always added to the decimated polyline\r\n  let numDecimatedPoints = 2;\r\n\r\n  // Add start and end points to the decimated polyline\r\n  polylinePointFlags[0] = true;\r\n  polylinePointFlags[numPoints - 1] = true;\r\n\r\n  // Iterative approach using a queue instead of recursion to reduce the number\r\n  // of function calls (performance)\r\n  while (partitionQueue.length) {\r\n    const [startIndex, endIndex] = partitionQueue.pop();\r\n\r\n    // Return if there is no point between the start and end points\r\n    if (endIndex - startIndex === 1) {\r\n      continue;\r\n    }\r\n\r\n    const startPoint = polyline[startIndex];\r\n    const endPoint = polyline[endIndex];\r\n    let maxDistSquared = -Infinity;\r\n    let maxDistIndex = -1;\r\n\r\n    // Search for the furthest point\r\n    for (let i = startIndex + 1; i < endIndex; i++) {\r\n      const currentPoint = polyline[i];\r\n      const distSquared = mathLine.distanceToPointSquared(\r\n        startPoint,\r\n        endPoint,\r\n        currentPoint\r\n      );\r\n\r\n      if (distSquared > maxDistSquared) {\r\n        maxDistSquared = distSquared;\r\n        maxDistIndex = i;\r\n      }\r\n    }\r\n\r\n    // Do not add any of the points because the fursthest one is very close to\r\n    // the line based on the epsilon value\r\n    if (maxDistSquared < epsilonSquared) {\r\n      continue;\r\n    }\r\n\r\n    // Update the flag for the furthest point because it will be added to the\r\n    // decimated polyline\r\n    polylinePointFlags[maxDistIndex] = true;\r\n    numDecimatedPoints++;\r\n\r\n    // Partition the points into two parts using maxDistIndex as the pivot point\r\n    // and process both sides\r\n    partitionQueue.push([maxDistIndex, endIndex]);\r\n    partitionQueue.push([startIndex, maxDistIndex]);\r\n  }\r\n\r\n  // A pre-allocated array is 3-4x faster then multiple push() calls\r\n  const decimatedPolyline: Types.Point2[] = new Array(numDecimatedPoints);\r\n\r\n  for (let srcIndex = 0, dstIndex = 0; srcIndex < numPoints; srcIndex++) {\r\n    if (polylinePointFlags[srcIndex]) {\r\n      decimatedPolyline[dstIndex++] = polyline[srcIndex];\r\n    }\r\n  }\r\n\r\n  return decimatedPolyline;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport getLineSegmentIntersectionsIndexes from './getLineSegmentIntersectionsIndexes';\r\nimport getLinesIntersection from './getLinesIntersection';\r\n\r\n/**\r\n * Returns all intersections points between a line segment and a polyline\r\n */\r\nexport default function getLineSegmentIntersectionsCoordinates(\r\n  points: Types.Point2[],\r\n  p1: Types.Point2,\r\n  q1: Types.Point2,\r\n  closed = true\r\n): Types.Point2[] {\r\n  const result = [];\r\n  const polylineIndexes = getLineSegmentIntersectionsIndexes(\r\n    points,\r\n    p1,\r\n    q1,\r\n    closed\r\n  );\r\n\r\n  for (let i = 0; i < polylineIndexes.length; i++) {\r\n    const p2 = points[polylineIndexes[i][0]];\r\n    const q2 = points[polylineIndexes[i][1]];\r\n    const intersection = getLinesIntersection(p1, q1, p2, q2);\r\n    result.push(intersection);\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { vec2 } from 'gl-matrix';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\r\n\r\n/**\r\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\r\n * `points`, and returns the closest value.\r\n * @param points - Polyline points\r\n * @param p1 - Start point of the line segment\r\n * @param q1 - End point of the line segment\r\n * @param closed - Test the intersection against the line that connects the first to the last when closed\r\n * @returns The closest line segment from polyline that intersects the line segment [p1, q1]\r\n */\r\nexport default function getClosestLineSegmentIntersection(\r\n  points: Types.Point2[],\r\n  p1: Types.Point2,\r\n  q1: Types.Point2,\r\n  closed = true\r\n): { segment: Types.Point2; distance: number } | undefined {\r\n  let initialQ2Index;\r\n  let p2Index;\r\n\r\n  if (closed) {\r\n    p2Index = points.length - 1;\r\n    initialQ2Index = 0;\r\n  } else {\r\n    p2Index = 0;\r\n    initialQ2Index = 1;\r\n  }\r\n\r\n  const intersections = [];\r\n\r\n  for (let q2Index = initialQ2Index; q2Index < points.length; q2Index++) {\r\n    const p2 = points[p2Index];\r\n    const q2 = points[q2Index];\r\n\r\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\r\n      intersections.push([p2Index, q2Index]);\r\n    }\r\n\r\n    p2Index = q2Index;\r\n  }\r\n\r\n  if (intersections.length === 0) {\r\n    return;\r\n  }\r\n\r\n  // Find intersection closest to the start point\r\n  const distances = [];\r\n\r\n  intersections.forEach((intersection) => {\r\n    const intersectionPoints = [\r\n      points[intersection[0]],\r\n      points[intersection[1]],\r\n    ];\r\n\r\n    const midpoint = [\r\n      (intersectionPoints[0][0] + intersectionPoints[1][0]) / 2,\r\n      (intersectionPoints[0][1] + intersectionPoints[1][1]) / 2,\r\n    ];\r\n\r\n    distances.push(vec2.distance(<vec2>midpoint, p1));\r\n  });\r\n\r\n  const minDistance = Math.min(...distances);\r\n  const indexOfMinDistance = distances.indexOf(minDistance);\r\n\r\n  return {\r\n    segment: intersections[indexOfMinDistance],\r\n    distance: minDistance,\r\n  };\r\n}\r\n","import { StackViewport } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport { vec3 } from 'gl-matrix';\r\n\r\nconst EPSILON = 1e-3;\r\n\r\n/**\r\n * Gets the desired spacing for points in the polyline for the\r\n * `PlanarFreehandROITool` in the x and y canvas directions, as well as\r\n * returning these canvas directions in world space.\r\n *\r\n * @param viewport - The Cornerstone3D `StackViewport` or `VolumeViewport`.\r\n * @param subPixelResolution - The number to divide the image pixel spacing by\r\n * to get the sub pixel spacing. E.g. `10` will return spacings 10x smaller than\r\n * the native image spacing.\r\n * @returns The spacings of the X and Y directions, and the 3D directions of the\r\n * x and y directions.\r\n */\r\nconst getSubPixelSpacingAndXYDirections = (\r\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\r\n  subPixelResolution: number\r\n): { spacing: Types.Point2; xDir: Types.Point3; yDir: Types.Point3 } => {\r\n  let spacing;\r\n  let xDir;\r\n  let yDir;\r\n\r\n  if (viewport instanceof StackViewport) {\r\n    // Check XY directions\r\n    const imageData = viewport.getImageData();\r\n\r\n    xDir = imageData.direction.slice(0, 3);\r\n    yDir = imageData.direction.slice(3, 6);\r\n\r\n    spacing = imageData.spacing;\r\n  } else {\r\n    // Check volume directions\r\n    const imageData = viewport.getImageData();\r\n    const { direction, spacing: volumeSpacing } = imageData;\r\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\r\n\r\n    // Calculate size of spacing vector in normal direction\r\n    const iVector = direction.slice(0, 3) as Types.Point3;\r\n    const jVector = direction.slice(3, 6) as Types.Point3;\r\n    const kVector = direction.slice(6, 9) as Types.Point3;\r\n\r\n    const viewRight = vec3.create(); // Get the X direction of the viewport\r\n\r\n    vec3.cross(viewRight, <vec3>viewUp, <vec3>viewPlaneNormal);\r\n\r\n    const absViewRightDotI = Math.abs(vec3.dot(viewRight, iVector));\r\n    const absViewRightDotJ = Math.abs(vec3.dot(viewRight, jVector));\r\n    const absViewRightDotK = Math.abs(vec3.dot(viewRight, kVector));\r\n\r\n    // Get X spacing\r\n    let xSpacing;\r\n    if (Math.abs(1 - absViewRightDotI) < EPSILON) {\r\n      xSpacing = volumeSpacing[0];\r\n      xDir = iVector;\r\n    } else if (Math.abs(1 - absViewRightDotJ) < EPSILON) {\r\n      xSpacing = volumeSpacing[1];\r\n      xDir = jVector;\r\n    } else if (Math.abs(1 - absViewRightDotK) < EPSILON) {\r\n      xSpacing = volumeSpacing[2];\r\n      xDir = kVector;\r\n    } else {\r\n      throw new Error('No support yet for oblique plane planar contours');\r\n    }\r\n\r\n    const absViewUpDotI = Math.abs(vec3.dot(viewUp, iVector));\r\n    const absViewUpDotJ = Math.abs(vec3.dot(viewUp, jVector));\r\n    const absViewUpDotK = Math.abs(vec3.dot(viewUp, kVector));\r\n\r\n    // Get Y spacing\r\n    let ySpacing;\r\n    if (Math.abs(1 - absViewUpDotI) < EPSILON) {\r\n      ySpacing = volumeSpacing[0];\r\n      yDir = iVector;\r\n    } else if (Math.abs(1 - absViewUpDotJ) < EPSILON) {\r\n      ySpacing = volumeSpacing[1];\r\n      yDir = jVector;\r\n    } else if (Math.abs(1 - absViewUpDotK) < EPSILON) {\r\n      ySpacing = volumeSpacing[2];\r\n      yDir = kVector;\r\n    } else {\r\n      throw new Error('No support yet for oblique plane planar contours');\r\n    }\r\n\r\n    spacing = [xSpacing, ySpacing];\r\n  }\r\n\r\n  const subPixelSpacing: Types.Point2 = [\r\n    spacing[0] / subPixelResolution,\r\n    spacing[1] / subPixelResolution,\r\n  ];\r\n\r\n  return { spacing: subPixelSpacing, xDir, yDir };\r\n};\r\n\r\nexport default getSubPixelSpacingAndXYDirections;\r\n","import { vec2 } from 'gl-matrix';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Returns true if points `p1` and `p2` are within `closeContourProximity`.\r\n */\r\nconst pointsAreWithinCloseContourProximity = (\r\n  p1: Types.Point2,\r\n  p2: Types.Point2,\r\n  closeContourProximity: number\r\n): boolean => {\r\n  return vec2.dist(p1, p2) < closeContourProximity;\r\n};\r\n\r\nexport default pointsAreWithinCloseContourProximity;\r\n","import { getEnabledElement } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport { vec2, vec3 } from 'gl-matrix';\r\nimport { PlanarFreehandROICommonData } from './planarFreehandROIInternalTypes';\r\n\r\n/**\r\n * Adds one or more points to the array at a resolution defined by the underlying image.\r\n */\r\nconst addCanvasPointsToArray = (\r\n  element: HTMLDivElement,\r\n  canvasPoints: Types.Point2[],\r\n  newCanvasPoint: Types.Point2,\r\n  commonData: PlanarFreehandROICommonData\r\n): number => {\r\n  const { xDir, yDir, spacing } = commonData;\r\n  const enabledElement = getEnabledElement(element);\r\n  const { viewport } = enabledElement;\r\n\r\n  if (!canvasPoints.length) {\r\n    canvasPoints.push(newCanvasPoint);\r\n    console.log('>>>>> !canvasPoints. :: RETURN');\r\n    return 1;\r\n  }\r\n\r\n  const lastWorldPos = viewport.canvasToWorld(\r\n    canvasPoints[canvasPoints.length - 1]\r\n  );\r\n  const newWorldPos = viewport.canvasToWorld(newCanvasPoint);\r\n  const worldPosDiff = vec3.create();\r\n\r\n  vec3.subtract(worldPosDiff, newWorldPos, lastWorldPos);\r\n\r\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\r\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\r\n\r\n  const numPointsToAdd = Math.max(\r\n    Math.floor(xDist / spacing[0]),\r\n    Math.floor(yDist / spacing[0])\r\n  );\r\n\r\n  if (numPointsToAdd > 1) {\r\n    const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\r\n\r\n    const canvasDist = vec2.dist(lastCanvasPoint, newCanvasPoint);\r\n\r\n    const canvasDir = vec2.create();\r\n\r\n    vec2.subtract(canvasDir, newCanvasPoint, lastCanvasPoint);\r\n\r\n    vec2.set(canvasDir, canvasDir[0] / canvasDist, canvasDir[1] / canvasDist);\r\n\r\n    const distPerPoint = canvasDist / numPointsToAdd;\r\n\r\n    for (let i = 1; i <= numPointsToAdd; i++) {\r\n      canvasPoints.push([\r\n        lastCanvasPoint[0] + distPerPoint * canvasDir[0] * i,\r\n        lastCanvasPoint[1] + distPerPoint * canvasDir[1] * i,\r\n      ]);\r\n    }\r\n  } else {\r\n    canvasPoints.push(newCanvasPoint);\r\n  }\r\n\r\n  return numPointsToAdd;\r\n};\r\n\r\nexport default addCanvasPointsToArray;\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport { vec2 } from 'gl-matrix';\r\n\r\n/**\r\n * Returns `true` if the point `p` can project onto point (`p1`, `p2`), and if\r\n * this projected point is less than `proximity` units away.\r\n */\r\nconst pointCanProjectOnLine = (\r\n  p: Types.Point2,\r\n  p1: Types.Point2,\r\n  p2: Types.Point2,\r\n  proximity: number\r\n): boolean => {\r\n  // Perfom checks in order of computational complexity.\r\n  const p1p = [p[0] - p1[0], p[1] - p1[1]];\r\n  const p1p2 = [p2[0] - p1[0], p2[1] - p1[1]];\r\n\r\n  const dot = p1p[0] * p1p2[0] + p1p[1] * p1p2[1];\r\n\r\n  // Dot product needs to be positive to be a candidate for projection onto line segment.\r\n  if (dot < 0) {\r\n    return false;\r\n  }\r\n\r\n  const p1p2Mag = Math.sqrt(p1p2[0] * p1p2[0] + p1p2[1] * p1p2[1]);\r\n\r\n  if (p1p2Mag === 0) {\r\n    return false;\r\n  }\r\n\r\n  const projectionVectorMag = dot / p1p2Mag;\r\n  const p1p2UnitVector = [p1p2[0] / p1p2Mag, p1p2[1] / p1p2Mag];\r\n  const projectionVector = [\r\n    p1p2UnitVector[0] * projectionVectorMag,\r\n    p1p2UnitVector[1] * projectionVectorMag,\r\n  ];\r\n  const projectionPoint = <Types.Point2>[\r\n    p1[0] + projectionVector[0],\r\n    p1[1] + projectionVector[1],\r\n  ];\r\n\r\n  const distance = vec2.distance(p, projectionPoint);\r\n\r\n  if (distance > proximity) {\r\n    // point is too far away.\r\n    return false;\r\n  }\r\n\r\n  // Check projects onto line segment.\r\n  if (vec2.distance(p1, projectionPoint) > vec2.distance(p1, p2)) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nexport default pointCanProjectOnLine;\r\n","import { utilities } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nconst epsilon = 1e-6;\r\n\r\n/**\r\n * Projects a polyline from 3D to 2D by reducing one dimension.\r\n *\r\n * @param polyline - The polyline to be projected.\r\n * @returns An object containing the shared dimension index and the projected polyline in 2D.\r\n * @throws Error if a shared dimension index cannot be found for the polyline.\r\n */\r\nexport function projectTo2D(polyline: Types.Point3[]) {\r\n  // We need to reduce one dimension to 2D, so basically\r\n  // we need to find the dimension index that is shared by all points\r\n  // Use the first three points, two is enough but three is more robust\r\n  let sharedDimensionIndex;\r\n\r\n  const testPoints = utilities.getRandomSampleFromArray(polyline, 50);\r\n\r\n  for (let i = 0; i < 3; i++) {\r\n    if (\r\n      testPoints.every(\r\n        (point, index, array) => Math.abs(point[i] - array[0][i]) < epsilon\r\n      )\r\n    ) {\r\n      sharedDimensionIndex = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (sharedDimensionIndex === undefined) {\r\n    throw new Error(\r\n      'Cannot find a shared dimension index for polyline, probably oblique plane'\r\n    );\r\n  }\r\n\r\n  // convert polyline list and point to 2D\r\n  const points2D = [] as Types.Point2[];\r\n\r\n  const firstDim = (sharedDimensionIndex + 1) % 3;\r\n  const secondDim = (sharedDimensionIndex + 2) % 3;\r\n\r\n  for (let i = 0; i < polyline.length; i++) {\r\n    points2D.push([polyline[i][firstDim], polyline[i][secondDim]]);\r\n  }\r\n\r\n  return {\r\n    sharedDimensionIndex,\r\n    projectedPolyline: points2D,\r\n  };\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport containsPoint from './containsPoint';\r\nimport { projectTo2D } from './projectTo2D';\r\n\r\n/**\r\n * Determines whether a 3D point is inside a polyline in 3D space.\r\n *\r\n * The algorithm works by reducing the polyline and point to 2D space, and then\r\n * using the 2D algorithm to determine whether the point is inside the polyline.\r\n *\r\n * @param point - The 3D point to test.\r\n * @param polyline - The polyline represented as an array of 3D points.\r\n * @param options.holesPolyline - An array of polylines representing each hole, so it\r\n * is an array of arrays of 3D points.\r\n * @returns A boolean indicating whether the point is inside the polyline.\r\n * @throws An error if a shared dimension index cannot be found for the polyline points.\r\n */\r\nexport function isPointInsidePolyline3D(\r\n  point: Types.Point3,\r\n  polyline: Types.Point3[],\r\n  options: { holes?: Types.Point3[][] } = {}\r\n) {\r\n  const { sharedDimensionIndex, projectedPolyline } = projectTo2D(polyline);\r\n\r\n  const { holes } = options;\r\n  const projectedHoles = [] as Types.Point2[][];\r\n\r\n  if (holes) {\r\n    for (let i = 0; i < holes.length; i++) {\r\n      const hole = holes[i];\r\n      const hole2D = [] as Types.Point2[];\r\n\r\n      for (let j = 0; j < hole.length; j++) {\r\n        hole2D.push([\r\n          hole[j][(sharedDimensionIndex + 1) % 3],\r\n          hole[j][(sharedDimensionIndex + 2) % 3],\r\n        ]);\r\n      }\r\n\r\n      projectedHoles.push(hole2D);\r\n    }\r\n  }\r\n\r\n  const point2D = [\r\n    point[(sharedDimensionIndex + 1) % 3],\r\n    point[(sharedDimensionIndex + 2) % 3],\r\n  ] as Types.Point2;\r\n\r\n  return containsPoint(projectedPolyline, point2D, { holes: projectedHoles });\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport * as lineSegment from '../line';\r\n\r\ntype rectLineSegments = {\r\n  top: Types.Point2[];\r\n  right: Types.Point2[];\r\n  bottom: Types.Point2[];\r\n  left: Types.Point2[];\r\n};\r\n\r\n/**\r\n * Given a rectangle left, top, width and height, return an object containing the\r\n * line segments that make up the rectangle's four sides\r\n * @param left - The x-coordinate of the left edge of the rectangle.\r\n * @param top - The y-coordinate of the top edge of the rectangle.\r\n * @param width - The width of the rectangle.\r\n * @param height - The height of the rectangle.\r\n * @returns An object with four keys, each of which contains an array of two\r\n * points.\r\n */\r\nfunction rectToLineSegments(\r\n  left: number,\r\n  top: number,\r\n  width: number,\r\n  height: number\r\n): rectLineSegments {\r\n  const topLineStart: Types.Point2 = [left, top];\r\n  const topLineEnd: Types.Point2 = [left + width, top];\r\n\r\n  const rightLineStart: Types.Point2 = [left + width, top];\r\n  const rightLineEnd: Types.Point2 = [left + width, top + height];\r\n\r\n  const bottomLineStart: Types.Point2 = [left + width, top + height];\r\n  const bottomLineEnd: Types.Point2 = [left, top + height];\r\n\r\n  const leftLineStart: Types.Point2 = [left, top + height];\r\n  const leftLineEnd: Types.Point2 = [left, top];\r\n\r\n  const lineSegments = {\r\n    top: [topLineStart, topLineEnd],\r\n    right: [rightLineStart, rightLineEnd],\r\n    bottom: [bottomLineStart, bottomLineEnd],\r\n    left: [leftLineStart, leftLineEnd],\r\n  };\r\n\r\n  return lineSegments;\r\n}\r\n\r\n/**\r\n * Calculates distance of the point to the rectangle. It calculates the minimum\r\n * distance between the point and each line segment of the rectangle.\r\n *\r\n * @param rect - coordinates of the rectangle [left, top, width, height]\r\n * @param point - [x,y] coordinates of a point\r\n * @returns\r\n */\r\nexport default function distanceToPoint(\r\n  rect: number[],\r\n  point: Types.Point2\r\n): number {\r\n  if (rect.length !== 4 || point.length !== 2) {\r\n    throw Error(\r\n      'rectangle:[left, top, width, height] or point: [x,y] not defined correctly'\r\n    );\r\n  }\r\n\r\n  const [left, top, width, height] = rect;\r\n\r\n  let minDistance = 655535;\r\n  const lineSegments = rectToLineSegments(left, top, width, height);\r\n\r\n  Object.keys(lineSegments).forEach((segment) => {\r\n    const [lineStart, lineEnd] = lineSegments[segment];\r\n    const distance = lineSegment.distanceToPoint(lineStart, lineEnd, point);\r\n\r\n    if (distance < minDistance) {\r\n      minDistance = distance;\r\n    }\r\n  });\r\n\r\n  return minDistance;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport { vec3 } from 'gl-matrix';\r\n\r\ntype Sphere = {\r\n  center: Types.Point3 | vec3;\r\n  radius: number;\r\n  // Square of the radius\r\n  radius2?: number;\r\n};\r\n\r\n/**\r\n * Checks if a point is inside a sphere. Note: this is similar to the\r\n * `pointInEllipse` function, but since we don't need checks for the\r\n * ellipse's rotation in different views, we can use a simpler equation\r\n * which would be faster (no if statements).\r\n *\r\n * This is safe to call for point in circle as long as you don't call it with\r\n * anything off-plane - that is, a circle is a degenerate sphere that is\r\n * intersected with the primary plane.\r\n *\r\n * @param sphere - Sphere object with center and radius and radius squared\r\n *     as radius2 if you are calling this a huge number of times.\r\n * @param pointLPS - the point to check in world coordinates\r\n * @returns boolean\r\n */\r\nexport default function pointInSphere(sphere: Sphere, pointLPS: vec3): boolean {\r\n  const { center, radius } = sphere;\r\n  const radius2 = sphere.radius2 || radius * radius;\r\n\r\n  return (\r\n    (pointLPS[0] - center[0]) * (pointLPS[0] - center[0]) +\r\n      (pointLPS[1] - center[1]) * (pointLPS[1] - center[1]) +\r\n      (pointLPS[2] - center[2]) * (pointLPS[2] - center[2]) <=\r\n    radius2\r\n  );\r\n}\r\n","// Pulled from source: https://github.com/w8r/liang-barsky\r\n// MIT Licensed.\r\n\r\n/**\r\n * Fast, destructive implementation of Liang-Barsky line clipping algorithm.\r\n * It clips a 2D segment by a rectangle.\r\n * @author Alexander Milevski <info@w8r.name>\r\n * @license MIT\r\n */\r\n\r\nconst EPSILON = 1e-6;\r\nconst INSIDE = 1;\r\nconst OUTSIDE = 0;\r\n\r\nfunction clipT(num, denom, c) {\r\n  const [tE, tL] = c;\r\n  if (Math.abs(denom) < EPSILON) {\r\n    return num < 0;\r\n  }\r\n  const t = num / denom;\r\n\r\n  if (denom > 0) {\r\n    if (t > tL) {\r\n      return 0;\r\n    }\r\n    if (t > tE) {\r\n      c[0] = t;\r\n    }\r\n  } else {\r\n    if (t < tE) {\r\n      return 0;\r\n    }\r\n    if (t < tL) {\r\n      c[1] = t;\r\n    }\r\n  }\r\n  return 1;\r\n}\r\n\r\n/**\r\n * @param  {Point} a\r\n * @param  {Point} b\r\n * @param  {BoundingBox} box [xmin, ymin, xmax, ymax]\r\n * @param  {Point?} [da]\r\n * @param  {Point?} [db]\r\n * @return {number}\r\n */\r\nexport default function clip(a, b, box, da?, db?) {\r\n  const [x1, y1] = a;\r\n  const [x2, y2] = b;\r\n  const dx = x2 - x1;\r\n  const dy = y2 - y1;\r\n\r\n  if (da === undefined || db === undefined) {\r\n    da = a;\r\n    db = b;\r\n  } else {\r\n    da[0] = a[0];\r\n    da[1] = a[1];\r\n    db[0] = b[0];\r\n    db[1] = b[1];\r\n  }\r\n\r\n  if (\r\n    Math.abs(dx) < EPSILON &&\r\n    Math.abs(dy) < EPSILON &&\r\n    x1 >= box[0] &&\r\n    x1 <= box[2] &&\r\n    y1 >= box[1] &&\r\n    y1 <= box[3]\r\n  ) {\r\n    return INSIDE;\r\n  }\r\n\r\n  const c = [0, 1];\r\n  if (\r\n    clipT(box[0] - x1, dx, c) &&\r\n    clipT(x1 - box[2], -dx, c) &&\r\n    clipT(box[1] - y1, dy, c) &&\r\n    clipT(y1 - box[3], -dy, c)\r\n  ) {\r\n    const [tE, tL] = c;\r\n    if (tL < 1) {\r\n      db[0] = x1 + tL * dx;\r\n      db[1] = y1 + tL * dy;\r\n    }\r\n    if (tE > 0) {\r\n      da[0] += tE * dx;\r\n      da[1] += tE * dy;\r\n    }\r\n    return INSIDE;\r\n  }\r\n  return OUTSIDE;\r\n}\r\n","import smoothAnnotation from './smoothAnnotation';\r\n\r\nexport default {\r\n  smoothAnnotation,\r\n};\r\n\r\nexport { smoothAnnotation };\r\n","import filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\r\nimport getWorldWidthAndHeightFromCorners from './getWorldWidthAndHeightFromCorners';\r\nimport filterAnnotationsForDisplay from './filterAnnotationsForDisplay';\r\nimport getPointInLineOfSightWithCriteria from './getPointInLineOfSightWithCriteria';\r\nimport { isPlaneIntersectingAABB } from './isPlaneIntersectingAABB';\r\n\r\nexport default {\r\n  filterAnnotationsWithinSlice,\r\n  getWorldWidthAndHeightFromCorners,\r\n  filterAnnotationsForDisplay,\r\n  getPointInLineOfSightWithCriteria,\r\n  isPlaneIntersectingAABB,\r\n};\r\n\r\nexport {\r\n  filterAnnotationsWithinSlice,\r\n  getWorldWidthAndHeightFromCorners,\r\n  filterAnnotationsForDisplay,\r\n  getPointInLineOfSightWithCriteria,\r\n  isPlaneIntersectingAABB,\r\n};\r\n","import { vec3 } from 'gl-matrix';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\r\nimport BoundsIJK from '../types/BoundsIJK';\r\n\r\nexport type PointInShape = {\r\n  value: number;\r\n  index: number;\r\n  pointIJK: vec3;\r\n  pointLPS: vec3 | number[];\r\n};\r\n\r\nexport type PointInShapeCallback = ({\r\n  value,\r\n  index,\r\n  pointIJK,\r\n  pointLPS,\r\n}: {\r\n  value: number;\r\n  index: number;\r\n  pointIJK: vec3;\r\n  pointLPS: vec3;\r\n}) => void;\r\n\r\nexport type ShapeFnCriteria = (pointLPS: vec3, pointIJK: vec3) => boolean;\r\n\r\n/**\r\n * For each point in the image (If boundsIJK is not provided, otherwise, for each\r\n * point in the provided bounding box), It runs the provided callback IF the point\r\n * passes the provided criteria to be inside the shape (which is defined by the\r\n * provided pointInShapeFn)\r\n *\r\n * @param imageData - The image data object.\r\n * @param dimensions - The dimensions of the image.\r\n * @param pointInShapeFn - A function that takes a point in LPS space and returns\r\n * true if the point is in the shape and false if it is not.\r\n * @param callback - A function that will be called for\r\n * every point in the shape.\r\n * @param boundsIJK - The bounds of the volume in IJK coordinates.\r\n */\r\nexport default function pointInShapeCallback(\r\n  imageData: vtkImageData | Types.CPUImageData,\r\n  pointInShapeFn: ShapeFnCriteria,\r\n  callback?: PointInShapeCallback,\r\n  boundsIJK?: BoundsIJK\r\n): Array<PointInShape> {\r\n  let iMin, iMax, jMin, jMax, kMin, kMax;\r\n\r\n  let scalarData;\r\n  const { numComps } = imageData as any;\r\n\r\n  // if getScalarData is a method on imageData\r\n  if ((imageData as Types.CPUImageData).getScalarData) {\r\n    scalarData = (imageData as Types.CPUImageData).getScalarData();\r\n  } else {\r\n    scalarData = (imageData as vtkImageData)\r\n      .getPointData()\r\n      .getScalars()\r\n      .getData();\r\n  }\r\n\r\n  if (!scalarData) {\r\n    console.warn('No scalar data found for imageData', imageData);\r\n    return;\r\n  }\r\n\r\n  const dimensions = imageData.getDimensions();\r\n\r\n  if (!boundsIJK) {\r\n    iMin = 0;\r\n    iMax = dimensions[0];\r\n    jMin = 0;\r\n    jMax = dimensions[1];\r\n    kMin = 0;\r\n    kMax = dimensions[2];\r\n  } else {\r\n    [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = boundsIJK;\r\n  }\r\n\r\n  const start = vec3.fromValues(iMin, jMin, kMin);\r\n\r\n  const direction = imageData.getDirection();\r\n  const rowCosines = direction.slice(0, 3);\r\n  const columnCosines = direction.slice(3, 6);\r\n  const scanAxisNormal = direction.slice(6, 9);\r\n\r\n  const spacing = imageData.getSpacing();\r\n  const [rowSpacing, columnSpacing, scanAxisSpacing] = spacing;\r\n\r\n  // @ts-ignore will be fixed in vtk-master\r\n  const worldPosStart = imageData.indexToWorld(start);\r\n\r\n  const rowStep = vec3.fromValues(\r\n    rowCosines[0] * rowSpacing,\r\n    rowCosines[1] * rowSpacing,\r\n    rowCosines[2] * rowSpacing\r\n  );\r\n\r\n  const columnStep = vec3.fromValues(\r\n    columnCosines[0] * columnSpacing,\r\n    columnCosines[1] * columnSpacing,\r\n    columnCosines[2] * columnSpacing\r\n  );\r\n\r\n  const scanAxisStep = vec3.fromValues(\r\n    scanAxisNormal[0] * scanAxisSpacing,\r\n    scanAxisNormal[1] * scanAxisSpacing,\r\n    scanAxisNormal[2] * scanAxisSpacing\r\n  );\r\n\r\n  const xMultiple =\r\n    numComps ||\r\n    scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];\r\n  const yMultiple = dimensions[0] * xMultiple;\r\n  const zMultiple = dimensions[1] * yMultiple;\r\n\r\n  const pointsInShape: Array<PointInShape> = [];\r\n\r\n  const currentPos = vec3.clone(worldPosStart);\r\n\r\n  for (let k = kMin; k <= kMax; k++) {\r\n    const startPosJ = vec3.clone(currentPos);\r\n\r\n    for (let j = jMin; j <= jMax; j++) {\r\n      const startPosI = vec3.clone(currentPos);\r\n\r\n      for (let i = iMin; i <= iMax; i++) {\r\n        const pointIJK: Types.Point3 = [i, j, k];\r\n\r\n        // The current world position (pointLPS) is now in currentPos\r\n        if (pointInShapeFn(currentPos as Types.Point3, pointIJK)) {\r\n          const index = k * zMultiple + j * yMultiple + i * xMultiple;\r\n          let value;\r\n          if (xMultiple > 2) {\r\n            value = [\r\n              scalarData[index],\r\n              scalarData[index + 1],\r\n              scalarData[index + 2],\r\n            ];\r\n          } else {\r\n            value = scalarData[index];\r\n          }\r\n\r\n          pointsInShape.push({\r\n            value,\r\n            index,\r\n            pointIJK,\r\n            pointLPS: currentPos.slice(),\r\n          });\r\n          if (callback) {\r\n            callback({ value, index, pointIJK, pointLPS: currentPos });\r\n          }\r\n        }\r\n\r\n        // Increment currentPos by rowStep for the next iteration\r\n        vec3.add(currentPos, currentPos, rowStep);\r\n      }\r\n\r\n      // Reset currentPos to the start of the next J line and increment by columnStep\r\n      vec3.copy(currentPos, startPosI);\r\n      vec3.add(currentPos, currentPos, columnStep);\r\n    }\r\n\r\n    // Reset currentPos to the start of the next K slice and increment by scanAxisStep\r\n    vec3.copy(currentPos, startPosJ);\r\n    vec3.add(currentPos, currentPos, scanAxisStep);\r\n  }\r\n\r\n  return pointsInShape;\r\n}\r\n","import { utilities as csUtils } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\r\nimport { vec3 } from 'gl-matrix';\r\nimport { pointInSphere } from './math/sphere';\r\nimport pointInShapeCallback, {\r\n  PointInShapeCallback,\r\n} from './pointInShapeCallback';\r\nimport { BoundsIJK } from '../types';\r\nimport { getBoundingBoxAroundShape } from './boundingBox';\r\n\r\nconst { transformWorldToIndex } = csUtils;\r\n\r\n/**\r\n * Given an imageData, and the great circle top and bottom points of a sphere,\r\n * this function will run the callback for each point of the imageData that is\r\n * within the sphere defined by the great circle points. If the viewport\r\n * is provided, region of interest will be an accurate approximation of the\r\n * sphere (using viewport camera), and the resulting performance will be\r\n * better.\r\n *\r\n * @privateRemarks great circle also known as orthodrome is the intersection of\r\n * the sphere and the plane that passes through the center of the sphere\r\n *\r\n * @param imageData - The volume imageData\r\n * @param circlePoints - bottom and top points of the great circle in world coordinates\r\n * @param callback - A callback function that will be called for each point in the shape.\r\n */\r\nexport default function pointInSurroundingSphereCallback(\r\n  imageData: vtkImageData,\r\n  circlePoints: [Types.Point3, Types.Point3],\r\n  callback: PointInShapeCallback,\r\n  viewport?: Types.IVolumeViewport\r\n): void {\r\n  // We can run the sphere equation to determine if a point is inside\r\n  // the sphere; however, since the imageData dimensions can be quite large, we\r\n  // can narrow down the search by estimating the bounds of the sphere in index\r\n  // space.\r\n  const { boundsIJK, centerWorld, radiusWorld } = _getBounds(\r\n    circlePoints,\r\n    imageData,\r\n    viewport\r\n  );\r\n\r\n  const sphereObj = {\r\n    center: centerWorld,\r\n    radius: radiusWorld,\r\n  };\r\n\r\n  pointInShapeCallback(\r\n    imageData,\r\n    (pointLPS) => pointInSphere(sphereObj, pointLPS),\r\n    callback,\r\n    boundsIJK\r\n  );\r\n}\r\n\r\nfunction _getBounds(\r\n  circlePoints: [Types.Point3, Types.Point3],\r\n  imageData: vtkImageData,\r\n  viewport\r\n): {\r\n  boundsIJK: BoundsIJK;\r\n  centerWorld: Types.Point3;\r\n  radiusWorld: number;\r\n} {\r\n  const [bottom, top] = circlePoints;\r\n\r\n  // Sphere center in world\r\n  const centerWorld = vec3.fromValues(\r\n    (bottom[0] + top[0]) / 2,\r\n    (bottom[1] + top[1]) / 2,\r\n    (bottom[2] + top[2]) / 2\r\n  );\r\n\r\n  // sphere radius in world\r\n  const radiusWorld = vec3.distance(bottom, top) / 2;\r\n\r\n  let boundsIJK;\r\n\r\n  if (!viewport) {\r\n    // If no viewport is provide (no camera), we can estimate the bounding box\r\n    // of the sphere in index space.\r\n    // This is done by calculating the maximum value for radius in the index\r\n    // space (since the radius is in world space, we need to convert it to index, and\r\n    // each dimensions can have a different scale factor). Therefore, by finding\r\n    // the minimum spacing value in the imageData, we can calculate the maximum\r\n    // radius in index space and use that to calculate the bounds of the sphere\r\n    // This will not be accurate, but it is a good first approximation.\r\n    // sphere center in index\r\n    const centerIJK = transformWorldToIndex(\r\n      imageData,\r\n      centerWorld as Types.Point3\r\n    );\r\n\r\n    const spacings = imageData.getSpacing();\r\n    const minSpacing = Math.min(...spacings);\r\n\r\n    const maxRadiusIJK = Math.ceil(radiusWorld / minSpacing);\r\n\r\n    boundsIJK = [\r\n      [centerIJK[0] - maxRadiusIJK, centerIJK[0] + maxRadiusIJK],\r\n      [centerIJK[1] - maxRadiusIJK, centerIJK[1] + maxRadiusIJK],\r\n      [centerIJK[2] - maxRadiusIJK, centerIJK[2] + maxRadiusIJK],\r\n    ];\r\n\r\n    return {\r\n      boundsIJK,\r\n      centerWorld: centerWorld as Types.Point3,\r\n      radiusWorld,\r\n    };\r\n  }\r\n\r\n  boundsIJK = _computeBoundsIJKWithCamera(\r\n    imageData,\r\n    viewport,\r\n    circlePoints,\r\n    centerWorld,\r\n    radiusWorld\r\n  );\r\n\r\n  return {\r\n    boundsIJK,\r\n    centerWorld: centerWorld as Types.Point3,\r\n    radiusWorld,\r\n  };\r\n}\r\n\r\nfunction _computeBoundsIJKWithCamera(\r\n  imageData,\r\n  viewport,\r\n  circlePoints,\r\n  centerWorld,\r\n  radiusWorld\r\n) {\r\n  const [bottom, top] = circlePoints;\r\n\r\n  const dimensions = imageData.getDimensions() as Types.Point3;\r\n  const camera = viewport.getCamera();\r\n\r\n  // Calculate viewRight from the camera, this will get used in order to\r\n  // calculate circles topLeft and bottomRight on different planes of intersection\r\n  // between sphere and viewPlane\r\n  const viewUp = vec3.fromValues(\r\n    camera.viewUp[0],\r\n    camera.viewUp[1],\r\n    camera.viewUp[2]\r\n  );\r\n  const viewPlaneNormal = vec3.fromValues(\r\n    camera.viewPlaneNormal[0],\r\n    camera.viewPlaneNormal[1],\r\n    camera.viewPlaneNormal[2]\r\n  );\r\n  const viewRight = vec3.create();\r\n\r\n  vec3.cross(viewRight, viewUp, viewPlaneNormal);\r\n\r\n  // we need to find the bounding box of the sphere in the image, e.g., the\r\n  // topLeftWorld and bottomRightWorld points of the bounding box.\r\n  // We go from the sphereCenter in the normal direction of amount radius, and\r\n  // we go left to find the topLeftWorld point of the bounding box. Next we go\r\n  // in the opposite direction and go right to find the bottomRightWorld point\r\n  // of the bounding box.\r\n  const topLeftWorld = vec3.create();\r\n  const bottomRightWorld = vec3.create();\r\n\r\n  vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\r\n  vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\r\n\r\n  // go in the direction of viewRight with the value of radius\r\n  vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\r\n  vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\r\n\r\n  // convert the world coordinates to index coordinates\r\n\r\n  const sphereCornersIJK = [\r\n    <Types.Point3>transformWorldToIndex(imageData, <Types.Point3>topLeftWorld),\r\n    <Types.Point3>(\r\n      transformWorldToIndex(imageData, <Types.Point3>bottomRightWorld)\r\n    ),\r\n  ];\r\n\r\n  // get the bounding box of the sphere in the image\r\n  const boundsIJK = getBoundingBoxAroundShape(sphereCornersIJK, dimensions);\r\n\r\n  return boundsIJK;\r\n}\r\n","export function pointToString(point, decimals = 5) {\r\n  return (\r\n    parseFloat(point[0]).toFixed(decimals) +\r\n    ',' +\r\n    parseFloat(point[1]).toFixed(decimals) +\r\n    ',' +\r\n    parseFloat(point[2]).toFixed(decimals) +\r\n    ','\r\n  );\r\n}\r\n","import vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport { vec3 } from 'gl-matrix';\r\n\r\n/**\r\n * Gets a point from an array of numbers given its index\r\n * @param points - array of number, each point defined by three consecutive numbers\r\n * @param idx - index of the point to retrieve\r\n * @returns\r\n */\r\nexport function getPoint(points, idx): Types.Point3 {\r\n  const idx3 = idx * 3;\r\n  if (idx3 < points.length) {\r\n    return vec3.fromValues(\r\n      points[idx3],\r\n      points[idx3 + 1],\r\n      points[idx3 + 2]\r\n    ) as Types.Point3;\r\n  }\r\n}\r\n\r\n/**\r\n * Extract contour point sets from the outline of a poly data actor\r\n * @param polyData - vtk polyData\r\n * @returns\r\n */\r\nexport function getPolyDataPointIndexes(polyData: vtkPolyData) {\r\n  const linesData = polyData.getLines().getData();\r\n  let idx = 0;\r\n  const lineSegments = new Map<number, number[]>();\r\n\r\n  // Populate lineSegments map\r\n  while (idx < linesData.length) {\r\n    const segmentSize = linesData[idx++];\r\n    const segment = [];\r\n    for (let i = 0; i < segmentSize; i++) {\r\n      segment.push(linesData[idx + i]);\r\n    }\r\n    lineSegments.set(segment[0], segment);\r\n    idx += segmentSize;\r\n  }\r\n\r\n  const contours = [];\r\n\r\n  // Function to find an available starting point\r\n  const findStartingPoint = (map) => {\r\n    for (const [key, value] of map.entries()) {\r\n      if (value !== undefined) {\r\n        return key;\r\n      }\r\n    }\r\n    return -1;\r\n  };\r\n\r\n  // Build contours\r\n  let startPoint = findStartingPoint(lineSegments);\r\n  while (startPoint !== -1) {\r\n    const contour = [startPoint];\r\n    while (lineSegments.has(startPoint)) {\r\n      const nextPoint = lineSegments.get(startPoint)[1];\r\n      if (lineSegments.has(nextPoint)) {\r\n        contour.push(nextPoint);\r\n      }\r\n      lineSegments.delete(startPoint);\r\n      startPoint = nextPoint;\r\n    }\r\n    contours.push(contour);\r\n    startPoint = findStartingPoint(lineSegments);\r\n  }\r\n\r\n  return contours.length ? contours : undefined;\r\n}\r\n\r\n/**\r\n * Extract contour points from a poly data object\r\n * @param polyData - vtk polyData\r\n * @returns\r\n */\r\nexport function getPolyDataPoints(polyData: vtkPolyData) {\r\n  const contoursIndexes = getPolyDataPointIndexes(polyData);\r\n  if (!contoursIndexes) {\r\n    return;\r\n  }\r\n\r\n  const rawPointsData = polyData.getPoints().getData();\r\n  return contoursIndexes.map((contourIndexes) =>\r\n    contourIndexes.map((index) => getPoint(rawPointsData, index))\r\n  );\r\n}\r\n","import { vec3 } from 'gl-matrix';\r\nimport { utilities as csUtils } from '@cornerstonejs/core';\r\n\r\nconst { isEqual } = csUtils;\r\n\r\nconst iAxis = vec3.fromValues(1, 0, 0);\r\nconst jAxis = vec3.fromValues(0, 1, 0);\r\nconst kAxis = vec3.fromValues(0, 0, 1);\r\n\r\nconst axisList = [iAxis, jAxis, kAxis];\r\n\r\n/**\r\n * Determines whether a given rectangle in a 3D space (defined by its corner\r\n * points in IJK coordinates) is aligned with the IJK axes.\r\n * @param rectangleCornersIJK - The corner points of the rectangle in IJK coordinates\r\n * @returns True if the rectangle is aligned with the IJK axes, false otherwise\r\n */\r\nfunction isAxisAlignedRectangle(rectangleCornersIJK) {\r\n  const rectangleVec1 = vec3.subtract(\r\n    vec3.create(),\r\n    rectangleCornersIJK[0],\r\n    rectangleCornersIJK[1]\r\n  );\r\n\r\n  const rectangleVec2 = vec3.subtract(\r\n    vec3.create(),\r\n    rectangleCornersIJK[0],\r\n    rectangleCornersIJK[2]\r\n  );\r\n\r\n  // Calculate the angles with IJK axes for both vectors\r\n  const anglesVec1 = calculateAnglesWithAxes(rectangleVec1, axisList);\r\n  const anglesVec2 = calculateAnglesWithAxes(rectangleVec2, axisList);\r\n\r\n  // Check if all angles are aligned (0, 90, 180, or 270 degrees)\r\n  // we could do csUtils.isEqual(angle % 90, 0) but this is more explicit for reading\r\n  const isAligned = [...anglesVec1, ...anglesVec2].every(\r\n    (angle) =>\r\n      isEqual(angle, 0) ||\r\n      isEqual(angle, 90) ||\r\n      isEqual(angle, 180) ||\r\n      isEqual(angle, 270)\r\n  );\r\n\r\n  return isAligned;\r\n}\r\n\r\n// Function to calculate angle with IJK axes\r\nfunction calculateAnglesWithAxes(vec, axes) {\r\n  return axes.map((axis) => (vec3.angle(vec, axis) * 180) / Math.PI);\r\n}\r\n\r\nexport { isAxisAlignedRectangle };\r\n","import {\r\n  StackViewport,\r\n  Types,\r\n  VolumeViewport,\r\n  eventTarget,\r\n  EVENTS,\r\n  utilities as csUtils,\r\n  getEnabledElement,\r\n} from '@cornerstonejs/core';\r\nimport { ScrollOptions, EventTypes } from '../types';\r\n\r\n/**\r\n * It scrolls one slice in the Stack or Volume Viewport, it uses the options provided\r\n * to determine the slice to scroll to. For Stack Viewport, it scrolls in the 1 or -1\r\n * direction, for Volume Viewport, it uses the camera and focal point to determine the\r\n * slice to scroll to based on the spacings.\r\n * @param viewport - The viewport in which to scroll\r\n * @param options - Options to use for scrolling, including direction, invert, and volumeId\r\n * @returns\r\n */\r\nexport default function scroll(\r\n  viewport: Types.IViewport,\r\n  options: ScrollOptions\r\n): void {\r\n  // check if viewport is disabled then throw error\r\n  const enabledElement = getEnabledElement(viewport.element);\r\n\r\n  if (!enabledElement) {\r\n    throw new Error('Scroll::Viewport is not enabled (it might be disabled)');\r\n  }\r\n\r\n  if (\r\n    viewport instanceof StackViewport &&\r\n    viewport.getImageIds().length === 0\r\n  ) {\r\n    throw new Error('Scroll::Stack Viewport has no images');\r\n  }\r\n\r\n  const { volumeId, delta, scrollSlabs } = options;\r\n\r\n  if (viewport instanceof VolumeViewport) {\r\n    scrollVolume(viewport, volumeId, delta, scrollSlabs);\r\n  } else {\r\n    (viewport as Types.IStackViewport).scroll(\r\n      delta,\r\n      options.debounceLoading,\r\n      options.loop\r\n    );\r\n  }\r\n}\r\n\r\nexport function scrollVolume(\r\n  viewport: VolumeViewport,\r\n  volumeId: string,\r\n  delta: number,\r\n  scrollSlabs = false\r\n) {\r\n  const useSlabThickness = scrollSlabs;\r\n\r\n  const { numScrollSteps, currentStepIndex, sliceRangeInfo } =\r\n    csUtils.getVolumeViewportScrollInfo(viewport, volumeId, useSlabThickness);\r\n\r\n  if (!sliceRangeInfo) {\r\n    return;\r\n  }\r\n\r\n  const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;\r\n  const { focalPoint, viewPlaneNormal, position } = camera;\r\n\r\n  const { newFocalPoint, newPosition } = csUtils.snapFocalPointToSlice(\r\n    focalPoint,\r\n    position,\r\n    sliceRange,\r\n    viewPlaneNormal,\r\n    spacingInNormalDirection,\r\n    delta\r\n  );\r\n\r\n  viewport.setCamera({\r\n    focalPoint: newFocalPoint,\r\n    position: newPosition,\r\n  });\r\n  viewport.render();\r\n\r\n  const desiredStepIndex = currentStepIndex + delta;\r\n\r\n  const VolumeScrollEventDetail: EventTypes.VolumeScrollOutOfBoundsEventDetail =\r\n    {\r\n      volumeId,\r\n      viewport,\r\n      delta,\r\n      desiredStepIndex,\r\n      currentStepIndex,\r\n      numScrollSteps,\r\n      currentImageId: viewport.getCurrentImageId(),\r\n    };\r\n\r\n  if (\r\n    (desiredStepIndex > numScrollSteps || desiredStepIndex < 0) &&\r\n    viewport.getCurrentImageId() // Check that we are in the plane of acquistion\r\n  ) {\r\n    // One common use case of this trigger might be to load the next\r\n    // volume in a time series or the next segment of a partially loaded volume.\r\n\r\n    csUtils.triggerEvent(\r\n      eventTarget,\r\n      EVENTS.VOLUME_SCROLL_OUT_OF_BOUNDS,\r\n      VolumeScrollEventDetail\r\n    );\r\n  } else {\r\n    csUtils.triggerEvent(\r\n      eventTarget,\r\n      EVENTS.VOLUME_VIEWPORT_SCROLL,\r\n      VolumeScrollEventDetail\r\n    );\r\n  }\r\n}\r\n","import { utilities as csUtils } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport {\r\n  AnnotationCompletedEventType,\r\n  AnnotationModifiedEventType,\r\n  AnnotationRemovedEventType,\r\n} from '../../../types/EventTypes';\r\nimport { state as annotationState } from '../../../stateManagement/annotation';\r\nimport type AnnotationGroupSelector from '../../../types/AnnotationGroupSelector';\r\nimport getInterpolationDataCollection from '../../contours/interpolation/getInterpolationDataCollection';\r\nimport type {\r\n  InterpolationViewportData,\r\n  AcceptInterpolationSelector,\r\n} from '../../../types/InterpolationTypes';\r\nimport interpolate from '../../contours/interpolation/interpolate';\r\nimport deleteRelatedAnnotations from './deleteRelatedAnnotations';\r\nimport { InterpolationROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\r\nimport ChangeTypes from '../../../enums/ChangeTypes';\r\nimport getViewportForAnnotation from '../../getViewportForAnnotation';\r\nimport { addContourSegmentationAnnotation } from '../../contourSegmentation/addContourSegmentationAnnotation';\r\n\r\nconst { uuidv4 } = csUtils;\r\n\r\nconst ChangeTypesForInterpolation = [\r\n  ChangeTypes.HandlesUpdated,\r\n  ChangeTypes.InterpolationUpdated,\r\n];\r\n\r\nexport default class InterpolationManager {\r\n  static toolNames = [];\r\n\r\n  static addTool(toolName: string) {\r\n    if (!this.toolNames.includes(toolName)) {\r\n      this.toolNames.push(toolName);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Accepts the autogenerated interpolations, marking them as non-autogenerated.\r\n   * Can provide a selector to choose which ones to accept.\r\n   *\r\n   * Rules for which items to select:\r\n   * 1. Only choose annotations having the same segment index and segmentationID\r\n   * 2. Exclude all contours having the same interpolation UID as any other contours\r\n   *    on the same slice.\r\n   * 3. Exclude autogenerated annotations\r\n   * 4. Exclude any reset interpolationUIDs (this is a manual operation to allow\r\n   *    creating a new interpolation)\r\n   * 5. Find the set of interpolationUID's remaining\r\n   *    a. If the set is of size 0, assign a new interpolationUID\r\n   *    b. If the set is of size 1, assign that interpolationUID\r\n   *    c. Otherwise (optional, otherwise do b for size>1 randomly),\r\n   *       for every remaining annotation, find the one whose center\r\n   *       point is closest to the center point of the new annotation.\r\n   *       Choose that interpolationUID\r\n   *\r\n   * To allow creating new interpolated groups, the idea is to just use a new\r\n   * segment index, then have an operation to update the segment index of an\r\n   * interpolation set.  That way the user can easily draw/see the difference,\r\n   * and then merge them as required.\r\n   * However, the base rules allow creating two contours on a single image to\r\n   * create a separate set.\r\n   */\r\n  static acceptAutoGenerated(\r\n    annotationGroupSelector: AnnotationGroupSelector,\r\n    selector: AcceptInterpolationSelector = {}\r\n  ) {\r\n    const { toolNames, segmentationId, segmentIndex, sliceIndex } = selector;\r\n    for (const toolName of toolNames || InterpolationManager.toolNames) {\r\n      const annotations = annotationState.getAnnotations(\r\n        toolName,\r\n        annotationGroupSelector\r\n      ) as InterpolationROIAnnotation[];\r\n      if (!annotations?.length) {\r\n        continue;\r\n      }\r\n      for (const annotation of annotations) {\r\n        const { interpolationUID, data, autoGenerated, metadata } = annotation;\r\n        if (interpolationUID) {\r\n          annotation.interpolationCompleted = true;\r\n        }\r\n        if (!autoGenerated) {\r\n          continue;\r\n        }\r\n        if (segmentIndex && segmentIndex !== data.segmentation.segmentIndex) {\r\n          continue;\r\n        }\r\n        if (\r\n          sliceIndex !== undefined &&\r\n          metadata &&\r\n          sliceIndex !== metadata.sliceIndex\r\n        ) {\r\n          continue;\r\n        }\r\n        if (\r\n          segmentationId &&\r\n          segmentationId !== data.segmentation.segmentationId\r\n        ) {\r\n          continue;\r\n        }\r\n        addContourSegmentationAnnotation(annotation);\r\n        annotation.autoGenerated = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * When an annotation is completed, if the configuration includes interpolation,\r\n   * then find matching interpolations and interpolation between this segmentation\r\n   * and the other segmentations of the same type.\r\n   */\r\n  static handleAnnotationCompleted = (evt: AnnotationCompletedEventType) => {\r\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\r\n    if (!annotation?.metadata) {\r\n      return;\r\n    }\r\n    const { toolName, originalToolName } = annotation.metadata;\r\n\r\n    if (\r\n      !this.toolNames.includes(toolName) &&\r\n      !this.toolNames.includes(originalToolName)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    const viewport = getViewportForAnnotation(annotation);\r\n    if (!viewport) {\r\n      console.warn('Unable to find viewport for', annotation);\r\n      return;\r\n    }\r\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\r\n    const viewportData: InterpolationViewportData = {\r\n      viewport,\r\n      sliceData,\r\n      annotation,\r\n      interpolationUID: annotation.interpolationUID,\r\n    };\r\n    const hasInterpolationUID = !!annotation.interpolationUID;\r\n    // If any update, triggered on an annotation, then it will be treated as non-autogenerated.\r\n    annotation.autoGenerated = false;\r\n    if (hasInterpolationUID) {\r\n      // This has already been configured with matching details, so just run\r\n      //  the interpolation again.\r\n      deleteRelatedAnnotations(viewportData);\r\n      interpolate(viewportData);\r\n      return;\r\n    }\r\n    const filterData = [\r\n      {\r\n        key: 'segmentIndex',\r\n        value: annotation.data.segmentation.segmentIndex,\r\n        parentKey: (annotation) => annotation.data.segmentation,\r\n      },\r\n      {\r\n        key: 'viewPlaneNormal',\r\n        value: annotation.metadata.viewPlaneNormal,\r\n        parentKey: (annotation) => annotation.metadata,\r\n      },\r\n      {\r\n        key: 'viewUp',\r\n        value: annotation.metadata.viewUp,\r\n        parentKey: (annotation) => annotation.metadata,\r\n      },\r\n    ];\r\n    let interpolationAnnotations = getInterpolationDataCollection(\r\n      viewportData,\r\n      filterData\r\n    );\r\n    // Skip other type of annotation interpolationUID's that are co-located\r\n    const { sliceIndex } = annotation.metadata;\r\n    const skipUIDs = new Set<string>();\r\n    interpolationAnnotations.forEach((interpolationAnnotation) => {\r\n      if (\r\n        interpolationAnnotation.interpolationCompleted ||\r\n        interpolationAnnotation.metadata.sliceIndex === sliceIndex\r\n      ) {\r\n        const { interpolationUID } = interpolationAnnotation;\r\n        skipUIDs.add(interpolationUID);\r\n      }\r\n    });\r\n    interpolationAnnotations = interpolationAnnotations.filter(\r\n      (interpolationAnnotation) =>\r\n        !skipUIDs.has(interpolationAnnotation.interpolationUID)\r\n    );\r\n\r\n    // Assign a new interpolationUID (this is checked above, so will be empty initially)\r\n    annotation.interpolationUID =\r\n      interpolationAnnotations[0]?.interpolationUID || uuidv4();\r\n    viewportData.interpolationUID = annotation.interpolationUID;\r\n    interpolate(viewportData);\r\n  };\r\n\r\n  /**\r\n   * This method gets called when an annotation changes.  It will then trigger\r\n   * related already interpolated annotations to be updated with the modified data.\r\n   */\r\n  static handleAnnotationUpdate = (evt: AnnotationModifiedEventType) => {\r\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\r\n    const { changeType = ChangeTypes.HandlesUpdated } = evt.detail;\r\n    if (!annotation?.metadata) {\r\n      return;\r\n    }\r\n    const { toolName, originalToolName } = annotation.metadata;\r\n\r\n    if (\r\n      (!this.toolNames.includes(toolName) &&\r\n        !this.toolNames.includes(originalToolName)) ||\r\n      !ChangeTypesForInterpolation.includes(changeType)\r\n    ) {\r\n      return;\r\n    }\r\n    const viewport = getViewportForAnnotation(annotation);\r\n    if (!viewport) {\r\n      console.warn(\r\n        'Unable to find matching viewport for annotation interpolation',\r\n        annotation\r\n      );\r\n      return;\r\n    }\r\n    if (annotation.autoGenerated) {\r\n      // Dont fire the annotation changed events here, as that leads to recursion,\r\n      // although this is in fact completing the event, so trigger the segmentation add\r\n      addContourSegmentationAnnotation(annotation);\r\n      annotation.autoGenerated = false;\r\n    }\r\n\r\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\r\n    const viewportData: InterpolationViewportData = {\r\n      viewport,\r\n      sliceData,\r\n      annotation,\r\n      interpolationUID: annotation.interpolationUID,\r\n      isInterpolationUpdate: changeType === ChangeTypes.InterpolationUpdated,\r\n    };\r\n    interpolate(viewportData);\r\n  };\r\n\r\n  /**\r\n   * Delete interpolated annotations when their endpoints are deleted.\r\n   */\r\n  static handleAnnotationDelete = (evt: AnnotationRemovedEventType) => {\r\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\r\n    if (!annotation?.metadata) {\r\n      return;\r\n    }\r\n    const { toolName } = annotation.metadata;\r\n\r\n    if (!this.toolNames.includes(toolName) || annotation.autoGenerated) {\r\n      return;\r\n    }\r\n    const viewport = getViewportForAnnotation(annotation);\r\n\r\n    if (!viewport) {\r\n      console.warn(\r\n        \"No viewport, can't delete interpolated results\",\r\n        annotation\r\n      );\r\n      return;\r\n    }\r\n\r\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\r\n    const viewportData: InterpolationViewportData = {\r\n      viewport,\r\n      sliceData,\r\n      annotation,\r\n      interpolationUID: annotation.interpolationUID,\r\n    };\r\n    // If any update, triggered on an annotation, then it will be treated as non-interpolated.\r\n    annotation.autoGenerated = false;\r\n    deleteRelatedAnnotations(viewportData);\r\n  };\r\n}\r\n\r\nfunction getSliceData(viewport): Types.ImageSliceData {\r\n  const sliceData: Types.ImageSliceData = {\r\n    numberOfSlices: viewport.getNumberOfSlices(),\r\n    imageIndex: viewport.getCurrentImageIdIndex(),\r\n  };\r\n  return sliceData;\r\n}\r\n","import { generateContourSetsFromLabelmap } from '../contours';\r\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\r\nimport findLargestBidirectional from './findLargestBidirectional';\r\n\r\nconst { Labelmap } = SegmentationRepresentations;\r\n\r\n/**\r\n * Generates a contour object over the segment, and then uses the contouring to\r\n * find the largest bidirectional object that can be applied within the acquisition\r\n * plane that is within the segment index, or the contained segment indices.\r\n *\r\n * @param segmentation.segments - a list of segments to apply the contour to.\r\n * @param segmentation.segments.containedSegmentIndices - a set of segment indexes equivalent to the primary segment\r\n * @param segmentation.segments.label - the label for the segment\r\n * @param segmentation.segments.color - the color to use for the segment label\r\n */\r\nexport default function contourAndFindLargestBidirectional(segmentation) {\r\n  const contours = generateContourSetsFromLabelmap({\r\n    segmentations: segmentation,\r\n  });\r\n\r\n  if (!contours?.length || !contours[0].sliceContours.length) {\r\n    return;\r\n  }\r\n\r\n  const {\r\n    representationData,\r\n    segments = [\r\n      null,\r\n      { label: 'Unspecified', color: null, containedSegmentIndices: null },\r\n    ],\r\n  } = segmentation;\r\n  const { volumeId: segVolumeId } = representationData[Labelmap];\r\n\r\n  const segmentIndex = segments.findIndex((it) => !!it);\r\n  if (segmentIndex === -1) {\r\n    return;\r\n  }\r\n  segments[segmentIndex].segmentIndex = segmentIndex;\r\n  return findLargestBidirectional(\r\n    contours[0],\r\n    segVolumeId,\r\n    segments[segmentIndex]\r\n  );\r\n}\r\n","/**\r\n * Creates a map that associates each imageId with a set of segmentation imageIds.\r\n * Note that this function assumes that the imageIds and segmentationImageIds arrays\r\n * are the same length and same order.\r\n *\r\n * @param imageIdsArray - An array of imageIds.\r\n * @param segmentationImageIds - An array of segmentation imageIds.\r\n * @returns A map that maps each imageId to a set of segmentation imageIds.\r\n */\r\nfunction createImageIdReferenceMap(\r\n  imageIdsArray: string[],\r\n  segmentationImageIds: string[]\r\n): Map<string, string> {\r\n  const imageIdReferenceMap = new Map<string, string>(\r\n    imageIdsArray.map((imageId, index) => {\r\n      return [imageId, segmentationImageIds[index]];\r\n    })\r\n  );\r\n\r\n  return imageIdReferenceMap;\r\n}\r\n\r\nexport { createImageIdReferenceMap };\r\n","import type {\r\n  FloodFillResult,\r\n  FloodFillGetter,\r\n  FloodFillOptions,\r\n} from '../../types';\r\nimport { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * floodFill.js - Taken from MIT OSS lib - https://github.com/tuzz/n-dimensional-flood-fill\r\n * Refactored to ES6.  Fixed the bounds/visits checks to use integer keys, restricting the\r\n * total search spacing to +/- 32k in each dimension, but resulting in about a hundred time\r\n * performance gain for larger regions since JavaScript does not have a hash map to allow the\r\n * map to work on keys.\r\n *\r\n * @param getter The getter to the elements of your data structure,\r\n *                          e.g. getter(x,y) for a 2D interprettation of your structure.\r\n * @param seed The seed for your fill. The dimensionality is infered\r\n *                        by the number of dimensions of the seed.\r\n * @param options.onFlood - An optional callback to execute when each pixel is flooded.\r\n *                             e.g. onFlood(x,y).\r\n * @param options.onBoundary - An optional callback to execute whenever a boundary is reached.\r\n *                                a boundary could be another segmentIndex, or the edge of your\r\n *                                data structure (i.e. when your getter returns undefined).\r\n * @param options.equals - An optional equality method for your datastructure.\r\n *                            Default is simply value1 = value2.\r\n * @param options.diagonals - Whether you allow flooding through diagonals. Defaults to false.\r\n *\r\n * @returns Flood fill results\r\n */\r\nfunction floodFill(\r\n  getter: FloodFillGetter,\r\n  seed: Types.Point2 | Types.Point3,\r\n  options: FloodFillOptions = {}\r\n): FloodFillResult {\r\n  const onFlood = options.onFlood;\r\n  const onBoundary = options.onBoundary;\r\n  const equals = options.equals;\r\n  const diagonals = options.diagonals || false;\r\n  const startNode = get(seed);\r\n  const permutations = prunedPermutations();\r\n  const stack = [];\r\n  const flooded = [];\r\n  const visits = new Set();\r\n  const bounds = new Map();\r\n\r\n  stack.push({ currentArgs: seed });\r\n\r\n  while (stack.length > 0) {\r\n    flood(stack.pop());\r\n  }\r\n\r\n  return {\r\n    flooded,\r\n    boundaries: boundaries(),\r\n  };\r\n\r\n  function flood(job) {\r\n    const getArgs = job.currentArgs;\r\n    const prevArgs = job.previousArgs;\r\n\r\n    if (visited(getArgs)) {\r\n      return;\r\n    }\r\n    markAsVisited(getArgs);\r\n\r\n    if (member(getArgs)) {\r\n      markAsFlooded(getArgs);\r\n      pushAdjacent(getArgs);\r\n    } else {\r\n      markAsBoundary(prevArgs);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Indicates if the key has been visited.\r\n   * @param key is a 2 or 3 element vector with values -32768...32767\r\n   */\r\n  function visited(key) {\r\n    const [x, y, z = 0] = key;\r\n    // Use an integer key value for checking visited, since JavaScript does not\r\n    // provide a generic hash key indexed hash map.\r\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\r\n    return visits.has(iKey);\r\n  }\r\n\r\n  function markAsVisited(key) {\r\n    const [x, y, z = 0] = key;\r\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\r\n    visits.add(iKey);\r\n  }\r\n\r\n  function member(getArgs) {\r\n    const node = get(getArgs);\r\n\r\n    return equals ? equals(node, startNode) : node === startNode;\r\n  }\r\n\r\n  function markAsFlooded(getArgs) {\r\n    flooded.push(getArgs);\r\n    if (onFlood) {\r\n      //@ts-ignore\r\n      onFlood(...getArgs);\r\n    }\r\n  }\r\n\r\n  function markAsBoundary(prevArgs) {\r\n    const [x, y, z = 0] = prevArgs;\r\n    // Use an integer key value for checking visited, since JavaScript does not\r\n    // provide a generic hash key indexed hash map.\r\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\r\n    bounds.set(iKey, prevArgs);\r\n    if (onBoundary) {\r\n      //@ts-ignore\r\n      onBoundary(...prevArgs);\r\n    }\r\n  }\r\n\r\n  function pushAdjacent(getArgs) {\r\n    for (let i = 0; i < permutations.length; i += 1) {\r\n      const perm = permutations[i];\r\n      const nextArgs = getArgs.slice(0);\r\n\r\n      for (let j = 0; j < getArgs.length; j += 1) {\r\n        nextArgs[j] += perm[j];\r\n      }\r\n\r\n      stack.push({\r\n        currentArgs: nextArgs,\r\n        previousArgs: getArgs,\r\n      });\r\n    }\r\n  }\r\n\r\n  function get(getArgs) {\r\n    //@ts-ignore\r\n    return getter(...getArgs);\r\n  }\r\n\r\n  // This is a significant performance hit - should be done as a wrapper\r\n  // only when needed.\r\n  // function safely(f, args) {\r\n  //   try {\r\n  //     return f(...args);\r\n  //   } catch (error) {\r\n  //     return;\r\n  //   }\r\n  // }\r\n\r\n  function prunedPermutations() {\r\n    const permutations = permute(seed.length);\r\n\r\n    return permutations.filter(function (perm) {\r\n      const count = countNonZeroes(perm);\r\n\r\n      return count !== 0 && (count === 1 || diagonals);\r\n    });\r\n  }\r\n\r\n  function permute(length) {\r\n    const perms = [];\r\n\r\n    const permutation = function (string) {\r\n      return string.split('').map(function (c) {\r\n        return parseInt(c, 10) - 1;\r\n      });\r\n    };\r\n\r\n    for (let i = 0; i < Math.pow(3, length); i += 1) {\r\n      const string = lpad(i.toString(3), '0', length);\r\n\r\n      perms.push(permutation(string));\r\n    }\r\n\r\n    return perms;\r\n  }\r\n\r\n  function boundaries() {\r\n    const array = Array.from(bounds.values());\r\n    array.reverse();\r\n    return array;\r\n  }\r\n}\r\n\r\nfunction defaultEquals(a, b) {\r\n  return a === b;\r\n}\r\n\r\nfunction countNonZeroes(array) {\r\n  let count = 0;\r\n\r\n  for (let i = 0; i < array.length; i += 1) {\r\n    if (array[i] !== 0) {\r\n      count += 1;\r\n    }\r\n  }\r\n\r\n  return count;\r\n}\r\n\r\nfunction lpad(string, character, length) {\r\n  const array = new Array(length + 1);\r\n  const pad = array.join(character);\r\n\r\n  return (pad + string).slice(-length);\r\n}\r\n\r\nexport default floodFill;\r\n","import { getAnnotation } from '../../stateManagement';\r\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\r\n\r\n/**\r\n * Retrieves the index of the hovered contour segmentation annotation for a given segmentation ID.\r\n *\r\n * @param segmentationId - The ID of the segmentation.\r\n * @returns The index of the hovered contour segmentation annotation, or undefined if none is found.\r\n */\r\nexport function getHoveredContourSegmentationAnnotation(segmentationId) {\r\n  const segmentation = getSegmentation(segmentationId);\r\n  const { annotationUIDsMap } = segmentation.representationData.CONTOUR;\r\n\r\n  for (const [segmentIndex, annotationUIDs] of annotationUIDsMap.entries()) {\r\n    const highlightedAnnotationUID = Array.from(annotationUIDs).find(\r\n      (annotationUID) => getAnnotation(annotationUID).highlighted\r\n    );\r\n\r\n    if (highlightedAnnotationUID) {\r\n      return segmentIndex;\r\n    }\r\n  }\r\n\r\n  return undefined;\r\n}\r\n","import { cache, utilities } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport {\r\n  getSegmentation,\r\n  getSegmentationIdRepresentations,\r\n} from '../../stateManagement/segmentation/segmentationState';\r\nimport {\r\n  LabelmapSegmentationDataStack,\r\n  LabelmapSegmentationDataVolume,\r\n} from '../../types/LabelmapTypes';\r\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\r\n\r\ntype Options = {\r\n  viewport?: Types.IViewport;\r\n  searchRadius?: number;\r\n};\r\n\r\n/**\r\n * Retrieves the segment index at the border of a labelmap in a segmentation.\r\n *\r\n * @param segmentationId - The ID of the segmentation.\r\n * @param worldPoint - The world coordinates of the point.\r\n * @param options - Additional options.\r\n * @param options.viewport - The viewport to use.\r\n * @param options.searchRadius - The search radius to use.\r\n * @returns The segment index at the labelmap border, or undefined if not found.\r\n */\r\nexport function getSegmentAtLabelmapBorder(\r\n  segmentationId: string,\r\n  worldPoint: Types.Point3,\r\n  { viewport, searchRadius }: Options\r\n): number {\r\n  const segmentation = getSegmentation(segmentationId);\r\n\r\n  const labelmapData = segmentation.representationData.LABELMAP;\r\n\r\n  if (isVolumeSegmentation(labelmapData)) {\r\n    const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\r\n    const segmentationVolume = cache.getVolume(volumeId);\r\n\r\n    if (!segmentationVolume) {\r\n      return;\r\n    }\r\n\r\n    const imageData = segmentationVolume.imageData;\r\n\r\n    const segmentIndex = imageData.getScalarValueFromWorld(worldPoint);\r\n\r\n    const canvasPoint = viewport.worldToCanvas(worldPoint);\r\n\r\n    const onEdge = isSegmentOnEdgeCanvas(\r\n      canvasPoint as Types.Point2,\r\n      segmentIndex,\r\n      viewport,\r\n      imageData,\r\n      searchRadius\r\n    );\r\n\r\n    return onEdge ? segmentIndex : undefined;\r\n  }\r\n\r\n  // stack segmentation case\r\n  const { imageIdReferenceMap } = labelmapData as LabelmapSegmentationDataStack;\r\n\r\n  const currentImageId = (viewport as Types.IStackViewport).getCurrentImageId();\r\n\r\n  const segmentationImageId = imageIdReferenceMap.get(currentImageId);\r\n  const image = cache.getImage(segmentationImageId);\r\n\r\n  if (!image) {\r\n    return;\r\n  }\r\n\r\n  // find the first segmentationRepresentationUID for the segmentationId, since\r\n  // that is what we use as actorUID in the viewport\r\n\r\n  const segmentationRepresentations = getSegmentationIdRepresentations(\r\n    segmentation.segmentationId\r\n  );\r\n\r\n  const { segmentationRepresentationUID } = segmentationRepresentations[0];\r\n  const segmentationActor = viewport.getActor(segmentationRepresentationUID);\r\n  const imageData = segmentationActor?.actor.getMapper().getInputData();\r\n  const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\r\n\r\n  const dimensions = imageData.getDimensions();\r\n  const voxelManager = (imageData.voxelManager ||\r\n    utilities.VoxelManager.createVolumeVoxelManager(\r\n      dimensions,\r\n      imageData.getPointData().getScalars().getData()\r\n    )) as utilities.VoxelManager<number>;\r\n\r\n  const segmentIndex = voxelManager.getAtIJKPoint(indexIJK as Types.Point3);\r\n\r\n  const onEdge = isSegmentOnEdgeIJK(\r\n    indexIJK as Types.Point3,\r\n    dimensions,\r\n    voxelManager,\r\n    segmentIndex\r\n  );\r\n\r\n  return onEdge ? segmentIndex : undefined;\r\n}\r\n\r\n/**\r\n * Checks if a segment is on the edge of a labelmap.\r\n * @param getNeighborIndex - A function that returns the neighbor index given the delta values.\r\n * @param segmentIndex - The index of the segment to check.\r\n * @param searchRadius - The radius within which to search for neighboring segments. Default is 1.\r\n * @returns A boolean indicating whether the segment is on the edge.\r\n */\r\nfunction isSegmentOnEdge(\r\n  getNeighborIndex: (\r\n    deltaI: number,\r\n    deltaJ: number,\r\n    deltaK: number\r\n  ) => number | undefined,\r\n  segmentIndex: number,\r\n  searchRadius = 1 // Default search radius\r\n): boolean {\r\n  const neighborRange = Array.from(\r\n    { length: 2 * searchRadius + 1 },\r\n    (_, i) => i - searchRadius\r\n  );\r\n\r\n  for (const deltaI of neighborRange) {\r\n    for (const deltaJ of neighborRange) {\r\n      for (const deltaK of neighborRange) {\r\n        if (deltaI === 0 && deltaJ === 0 && deltaK === 0) {\r\n          continue; // Skipping the central point\r\n        }\r\n\r\n        const neighborIndex = getNeighborIndex(deltaI, deltaJ, deltaK);\r\n\r\n        if (neighborIndex !== undefined && segmentIndex !== neighborIndex) {\r\n          return true; // On the edge\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return false; // No edge neighbors found\r\n}\r\n\r\nfunction isSegmentOnEdgeIJK(\r\n  indexIJK: Types.Point3,\r\n  dimensions: Types.Point3,\r\n  voxelManager: any,\r\n  segmentIndex: number,\r\n  searchRadius?: number\r\n): boolean {\r\n  const getNeighborIndex = (deltaI: number, deltaJ: number, deltaK: number) => {\r\n    const neighborIJK = [\r\n      indexIJK[0] + deltaI,\r\n      indexIJK[1] + deltaJ,\r\n      indexIJK[2] + deltaK,\r\n    ];\r\n\r\n    return voxelManager.getAtIJK(...neighborIJK);\r\n  };\r\n\r\n  return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\r\n}\r\n\r\nfunction isSegmentOnEdgeCanvas(\r\n  canvasPoint: Types.Point2,\r\n  segmentIndex: number,\r\n  viewport: Types.IViewport,\r\n  imageData: any,\r\n  searchRadius?: number\r\n): boolean {\r\n  const getNeighborIndex = (deltaI: number, deltaJ: number) => {\r\n    const neighborCanvas = [canvasPoint[0] + deltaI, canvasPoint[1] + deltaJ];\r\n\r\n    const worldPoint = viewport.canvasToWorld(neighborCanvas as Types.Point2);\r\n    return imageData.getScalarValueFromWorld(worldPoint);\r\n  };\r\n\r\n  return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\r\n}\r\n","import { cache, utilities } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport { SegmentationRepresentations } from '../../enums';\r\nimport {\r\n  getSegmentation,\r\n  getSegmentationIdRepresentations,\r\n} from '../../stateManagement/segmentation/segmentationState';\r\nimport {\r\n  LabelmapSegmentationDataStack,\r\n  LabelmapSegmentationDataVolume,\r\n} from '../../types/LabelmapTypes';\r\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\r\nimport { ContourSegmentationAnnotation, Segmentation } from '../../types';\r\nimport { getAnnotation } from '../../stateManagement';\r\nimport { isPointInsidePolyline3D } from '../math/polyline';\r\n\r\ntype Options = {\r\n  representationType?: SegmentationRepresentations;\r\n  viewport?: Types.IViewport;\r\n};\r\n\r\n/**\r\n * Get the segment at the specified world point in the viewport.\r\n * @param segmentationId - The ID of the segmentation to get the segment for.\r\n * @param worldPoint - The world point to get the segment for.\r\n *\r\n * @returns The index of the segment at the world point, or undefined if not found.\r\n */\r\nexport function getSegmentAtWorldPoint(\r\n  segmentationId: string,\r\n  worldPoint: Types.Point3,\r\n  options = {} as Options\r\n): number {\r\n  const segmentation = getSegmentation(segmentationId);\r\n\r\n  const representationData = segmentation.representationData;\r\n\r\n  // if representationType is not provided, we will use the first representation\r\n  const desiredRepresentation =\r\n    options?.representationType ?? Object.keys(representationData)[0];\r\n\r\n  if (!desiredRepresentation) {\r\n    throw new Error(\r\n      `Segmentation ${segmentationId} does not have any representations`\r\n    );\r\n  }\r\n\r\n  switch (desiredRepresentation) {\r\n    case SegmentationRepresentations.Labelmap:\r\n      return getSegmentAtWorldForLabelmap(segmentation, worldPoint, options);\r\n    case SegmentationRepresentations.Contour:\r\n      return getSegmentAtWorldForContour(segmentation, worldPoint, options);\r\n    default:\r\n      return;\r\n  }\r\n}\r\n\r\n/**\r\n * Retrieves the segment index at a given world point for a labelmap.\r\n *\r\n * @param labelmapData - The labelmap segmentation data.\r\n * @param worldPoint - The world point to retrieve the segment at.\r\n *\r\n * @returns The segment index at the given world point, or undefined if not found.\r\n */\r\nexport function getSegmentAtWorldForLabelmap(\r\n  segmentation: Segmentation,\r\n  worldPoint: Types.Point3,\r\n  { viewport }: Options\r\n): number | undefined {\r\n  const labelmapData = segmentation.representationData.LABELMAP;\r\n\r\n  if (isVolumeSegmentation(labelmapData)) {\r\n    const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\r\n    const segmentationVolume = cache.getVolume(volumeId);\r\n\r\n    if (!segmentationVolume) {\r\n      return;\r\n    }\r\n\r\n    const segmentIndex =\r\n      segmentationVolume.imageData.getScalarValueFromWorld(worldPoint);\r\n\r\n    return segmentIndex;\r\n  }\r\n\r\n  // stack segmentation case\r\n  const { imageIdReferenceMap } = labelmapData as LabelmapSegmentationDataStack;\r\n\r\n  const currentImageId = (viewport as Types.IStackViewport).getCurrentImageId();\r\n\r\n  const segmentationImageId = imageIdReferenceMap.get(currentImageId);\r\n  const image = cache.getImage(segmentationImageId);\r\n\r\n  if (!image) {\r\n    return;\r\n  }\r\n\r\n  // find the first segmentationRepresentationUID for the segmentationId, since\r\n  // that is what we use as actorUID in the viewport\r\n\r\n  const segmentationRepresentations = getSegmentationIdRepresentations(\r\n    segmentation.segmentationId\r\n  );\r\n\r\n  const { segmentationRepresentationUID } = segmentationRepresentations[0];\r\n\r\n  const segmentationActor = viewport.getActor(segmentationRepresentationUID);\r\n  const imageData = segmentationActor?.actor.getMapper().getInputData();\r\n  const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\r\n\r\n  const dimensions = imageData.getDimensions();\r\n  const voxelManager = (imageData.voxelManager ||\r\n    utilities.VoxelManager.createVolumeVoxelManager(\r\n      dimensions,\r\n      imageData.getPointData().getScalars().getData()\r\n    )) as utilities.VoxelManager<number>;\r\n\r\n  const segmentIndex = voxelManager.getAtIJKPoint(indexIJK as Types.Point3);\r\n\r\n  return segmentIndex;\r\n}\r\n\r\n/**\r\n * Retrieves the segment index at a given world point for contour segmentation.\r\n *\r\n * @param segmentation - The segmentation data.\r\n * @param worldPoint - The world point to check.\r\n * @param options - The options for segmentation.\r\n * @returns The segment index at the given world point, or undefined if not found.\r\n */\r\nexport function getSegmentAtWorldForContour(\r\n  segmentation: Segmentation,\r\n  worldPoint: Types.Point3,\r\n  { viewport }: Options\r\n): number {\r\n  const contourData = segmentation.representationData.CONTOUR;\r\n\r\n  const segmentIndices = Array.from(contourData.annotationUIDsMap.keys());\r\n  const { viewPlaneNormal } = viewport.getCamera();\r\n\r\n  for (const segmentIndex of segmentIndices) {\r\n    const annotationsSet = contourData.annotationUIDsMap.get(segmentIndex);\r\n\r\n    if (!annotationsSet) {\r\n      continue;\r\n    }\r\n\r\n    for (const annotationUID of annotationsSet) {\r\n      const annotation = getAnnotation(\r\n        annotationUID\r\n      ) as ContourSegmentationAnnotation;\r\n\r\n      if (!annotation) {\r\n        continue;\r\n      }\r\n\r\n      const { polyline } = annotation.data.contour;\r\n\r\n      if (\r\n        !utilities.isEqual(viewPlaneNormal, annotation.metadata.viewPlaneNormal)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // This function checks whether we are inside the contour. It does not\r\n      // check if we are exactly on the contour, which is highly unlikely given\r\n      // the canvas pixel resolution of 1 decimal place we have by design.\r\n      if (isPointInsidePolyline3D(worldPoint, polyline)) {\r\n        return Number(segmentIndex);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { getToolGroup } from '../../store/ToolGroupManager';\r\nimport BrushTool from '../../tools/segmentation/BrushTool';\r\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\r\nimport { getRenderingEngine } from '@cornerstonejs/core';\r\nimport { getBrushToolInstances } from './utilities';\r\n\r\n/**\r\n * Invalidates the brush cursor for a specific tool group.\r\n * This function triggers the update of the brush being rendered.\r\n * It also triggers an annotation render for any viewports on the tool group.\r\n *\r\n * @param toolGroupId - The ID of the tool group.\r\n */\r\nexport function invalidateBrushCursor(toolGroupId: string): void {\r\n  const toolGroup = getToolGroup(toolGroupId);\r\n\r\n  if (toolGroup === undefined) {\r\n    return;\r\n  }\r\n\r\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\r\n\r\n  brushBasedToolInstances.forEach((tool: BrushTool) => {\r\n    // Invalidate the brush being rendered so it can update.\r\n    tool.invalidateBrushCursor();\r\n  });\r\n\r\n  // Trigger an annotation render for any viewports on the toolgroup\r\n  const viewportsInfo = toolGroup.getViewportsInfo();\r\n\r\n  const viewportsInfoArray = Object.keys(viewportsInfo).map(\r\n    (key) => viewportsInfo[key]\r\n  );\r\n\r\n  if (!viewportsInfoArray.length) {\r\n    return;\r\n  }\r\n\r\n  const { renderingEngineId } = viewportsInfoArray[0];\r\n\r\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\r\n  // ourselves here.\r\n  const viewportIds = toolGroup.getViewportIds();\r\n\r\n  const renderingEngine = getRenderingEngine(renderingEngineId);\r\n\r\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\r\n}\r\n","import { Types } from '@cornerstonejs/core';\r\nimport { utilities as csUtils } from '@cornerstonejs/core';\r\nimport { getToolGroup } from '../../store/ToolGroupManager';\r\nimport BrushTool from '../../tools/segmentation/BrushTool';\r\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\r\n\r\nexport type ThresholdInformation = {\r\n  volume: Types.IImageVolume;\r\n  lower: number;\r\n  upper: number;\r\n};\r\n\r\nexport function getBrushToolInstances(toolGroupId: string, toolName?: string) {\r\n  const toolGroup = getToolGroup(toolGroupId);\r\n\r\n  if (toolGroup === undefined) {\r\n    return;\r\n  }\r\n\r\n  const toolInstances = toolGroup._toolInstances;\r\n\r\n  if (!Object.keys(toolInstances).length) {\r\n    return;\r\n  }\r\n\r\n  if (toolName && toolInstances[toolName]) {\r\n    return [toolInstances[toolName]];\r\n  }\r\n\r\n  // For each tool that has BrushTool as base class, set the brush size.\r\n  const brushBasedToolInstances = Object.values(toolInstances).filter(\r\n    (toolInstance) => toolInstance instanceof BrushTool\r\n  ) as BrushTool[];\r\n\r\n  return brushBasedToolInstances;\r\n}\r\n\r\nconst equalsCheck = (a, b) => {\r\n  return JSON.stringify(a) === JSON.stringify(b);\r\n};\r\n\r\n/**\r\n * Given the center of a voxel in world coordinates, calculate the voxel\r\n * corners in world coords to calculate the voxel overlap in another volume\r\n */\r\nexport function getVoxelOverlap(\r\n  imageData,\r\n  dimensions,\r\n  voxelSpacing,\r\n  voxelCenter\r\n) {\r\n  const voxelCornersWorld = [];\r\n  for (let i = 0; i < 2; i++) {\r\n    for (let j = 0; j < 2; j++) {\r\n      for (let k = 0; k < 2; k++) {\r\n        const point = [...voxelCenter]; // Create a new point from voxelCenter\r\n        point[0] = point[0] + ((i * 2 - 1) * voxelSpacing[0]) / 2;\r\n        point[1] = point[1] + ((j * 2 - 1) * voxelSpacing[1]) / 2;\r\n        point[2] = point[2] + ((k * 2 - 1) * voxelSpacing[2]) / 2;\r\n        voxelCornersWorld.push(point);\r\n      }\r\n    }\r\n  }\r\n  const voxelCornersIJK = voxelCornersWorld.map(\r\n    (world) => csUtils.transformWorldToIndex(imageData, world) as Types.Point3\r\n  );\r\n  const overlapBounds = getBoundingBoxAroundShapeIJK(\r\n    voxelCornersIJK,\r\n    dimensions\r\n  );\r\n\r\n  return overlapBounds;\r\n}\r\n\r\n/**\r\n * Prepare a list of volume information objects for callback functions\r\n */\r\nexport function processVolumes(\r\n  segmentationVolume: Types.IImageVolume,\r\n  thresholdVolumeInformation: ThresholdInformation[]\r\n) {\r\n  const { spacing: segmentationSpacing } = segmentationVolume;\r\n  const scalarData = segmentationVolume.getScalarData();\r\n\r\n  // prepare a list of volume information objects for callback functions\r\n  const volumeInfoList = [];\r\n  let baseVolumeIdx = 0;\r\n  for (let i = 0; i < thresholdVolumeInformation.length; i++) {\r\n    const { imageData, spacing, dimensions } =\r\n      thresholdVolumeInformation[i].volume;\r\n\r\n    const volumeSize =\r\n      thresholdVolumeInformation[i].volume.getScalarData().length;\r\n    // discover the index of the volume the segmentation data is based on\r\n    if (\r\n      volumeSize === scalarData.length &&\r\n      equalsCheck(spacing, segmentationSpacing)\r\n    ) {\r\n      baseVolumeIdx = i;\r\n    }\r\n\r\n    // prepare information used in callback functions\r\n    const referenceValues = imageData.getPointData().getScalars().getData();\r\n    const lower = thresholdVolumeInformation[i].lower;\r\n    const upper = thresholdVolumeInformation[i].upper;\r\n\r\n    volumeInfoList.push({\r\n      imageData,\r\n      referenceValues,\r\n      lower,\r\n      upper,\r\n      spacing,\r\n      dimensions,\r\n      volumeSize,\r\n    });\r\n  }\r\n\r\n  return {\r\n    volumeInfoList,\r\n    baseVolumeIdx,\r\n  };\r\n}\r\n","import debounce from './debounce';\r\nimport isObject from './isObject';\r\n\r\n/**\r\n * Creates a throttled function that only invokes `func` at most once per\r\n * every `wait` milliseconds (or once per browser frame). The throttled function\r\n * comes with a `cancel` method to cancel delayed `func` invocations and a\r\n * `flush` method to immediately invoke them. Provide `options` to indicate\r\n * whether `func` should be invoked on the leading and/or trailing edge of the\r\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\r\n * throttled function. Subsequent calls to the throttled function return the\r\n * result of the last `func` invocation.\r\n *\r\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\r\n * invoked on the trailing edge of the timeout only if the throttled function\r\n * is invoked more than once during the `wait` timeout.\r\n *\r\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\r\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\r\n *\r\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\r\n * invocation will be deferred until the next frame is drawn (typically about\r\n * 16ms).\r\n *\r\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\r\n * for details over the differences between `throttle` and `debounce`.\r\n *\r\n * @param {Function} func The function to throttle.\r\n * @param {number} [wait=0]\r\n *  The number of milliseconds to throttle invocations to; if omitted,\r\n *  `requestAnimationFrame` is used (if available).\r\n * @param {Object} [options={}] The options object.\r\n * @param {boolean} [options.leading=true]\r\n *  Specify invoking on the leading edge of the timeout.\r\n * @param {boolean} [options.trailing=true]\r\n *  Specify invoking on the trailing edge of the timeout.\r\n * @returns {Function} Returns the new throttled function.\r\n * @example\r\n *\r\n * // Avoid excessively updating the position while scrolling.\r\n * jQuery(window).on('scroll', throttle(updatePosition, 100))\r\n *\r\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\r\n * const throttled = throttle(renewToken, 300000, { 'trailing': false })\r\n * jQuery(element).on('click', throttled)\r\n *\r\n * // Cancel the trailing throttled invocation.\r\n * jQuery(window).on('popstate', throttled.cancel)\r\n */\r\nfunction throttle(func, wait, options) {\r\n  let leading = true;\r\n  let trailing = true;\r\n\r\n  if (typeof func !== 'function') {\r\n    throw new TypeError('Expected a function');\r\n  }\r\n  if (isObject(options)) {\r\n    leading = 'leading' in options ? Boolean(options.leading) : leading;\r\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\r\n  }\r\n\r\n  return debounce(func, wait, {\r\n    leading,\r\n    trailing,\r\n    maxWait: wait,\r\n  });\r\n}\r\n\r\nexport default throttle;\r\n","import { IDistance, IPoints, ITouchPoints } from '../../types';\r\nimport { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Returns the difference between multiple `IPoints` instances.\r\n * @param currentPoints - The current points.\r\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\r\n *\r\n * @returns The difference in IPoints format\r\n */\r\nfunction getDeltaPoints(\r\n  currentPoints: IPoints[],\r\n  lastPoints: IPoints[]\r\n): IPoints {\r\n  const curr = getMeanPoints(currentPoints);\r\n  const last = getMeanPoints(lastPoints);\r\n  return {\r\n    page: _subtractPoints2D(curr.page, last.page),\r\n    client: _subtractPoints2D(curr.client, last.client),\r\n    canvas: _subtractPoints2D(curr.canvas, last.canvas),\r\n    world: _subtractPoints3D(curr.world, last.world),\r\n  };\r\n}\r\n\r\n/**\r\n * Returns the distance between multiple `IPoints` instances.\r\n * @param currentPoints - The current points.\r\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\r\n *\r\n * @returns The distance difference in IDistance format\r\n */\r\nfunction getDeltaDistance(\r\n  currentPoints: IPoints[],\r\n  lastPoints: IPoints[]\r\n): IDistance {\r\n  const curr = getMeanPoints(currentPoints);\r\n  const last = getMeanPoints(lastPoints);\r\n  return {\r\n    page: _getDistance2D(curr.page, last.page),\r\n    client: _getDistance2D(curr.client, last.client),\r\n    canvas: _getDistance2D(curr.canvas, last.canvas),\r\n    world: _getDistance3D(curr.world, last.world),\r\n  };\r\n}\r\n\r\nfunction getDeltaRotation(\r\n  currentPoints: ITouchPoints[],\r\n  lastPoints: ITouchPoints[]\r\n) {\r\n  // TODO\r\n}\r\n\r\n/**\r\n * Returns the distance difference between multiple `IPoints` instances.\r\n * @param currentPoints - The current points.\r\n * @param lastPoints -- The last points.\r\n *\r\n * @returns The difference in IPoints format\r\n */\r\nfunction getDeltaDistanceBetweenIPoints(\r\n  currentPoints: IPoints[],\r\n  lastPoints: IPoints[]\r\n): IDistance {\r\n  const currentDistance = _getMeanDistanceBetweenAllIPoints(currentPoints);\r\n  const lastDistance = _getMeanDistanceBetweenAllIPoints(lastPoints);\r\n  const deltaDistance = {\r\n    page: currentDistance.page - lastDistance.page,\r\n    client: currentDistance.client - lastDistance.client,\r\n    canvas: currentDistance.canvas - lastDistance.canvas,\r\n    world: currentDistance.world - lastDistance.world,\r\n  };\r\n  return deltaDistance;\r\n}\r\n\r\n/**\r\n * Copies a set of points.\r\n * @param points - The `IPoints` instance to copy.\r\n *\r\n * @returns A copy of the points.\r\n */\r\nfunction copyPointsList(points: ITouchPoints[]): ITouchPoints[] {\r\n  return JSON.parse(JSON.stringify(points));\r\n}\r\n\r\nfunction copyPoints(points: ITouchPoints): ITouchPoints {\r\n  return JSON.parse(JSON.stringify(points));\r\n}\r\n\r\nfunction getMeanPoints(points: IPoints[]): IPoints {\r\n  return points.reduce(\r\n    (prev, curr) => {\r\n      return {\r\n        page: [\r\n          prev.page[0] + curr.page[0] / points.length,\r\n          prev.page[1] + curr.page[1] / points.length,\r\n        ],\r\n        client: [\r\n          prev.client[0] + curr.client[0] / points.length,\r\n          prev.client[1] + curr.client[1] / points.length,\r\n        ],\r\n        canvas: [\r\n          prev.canvas[0] + curr.canvas[0] / points.length,\r\n          prev.canvas[1] + curr.canvas[1] / points.length,\r\n        ],\r\n        world: [\r\n          prev.world[0] + curr.world[0] / points.length,\r\n          prev.world[1] + curr.world[1] / points.length,\r\n          prev.world[2] + curr.world[2] / points.length,\r\n        ],\r\n      };\r\n    },\r\n    {\r\n      page: [0, 0],\r\n      client: [0, 0],\r\n      canvas: [0, 0],\r\n      world: [0, 0, 0],\r\n    }\r\n  );\r\n}\r\n\r\nfunction getMeanTouchPoints(points: ITouchPoints[]): ITouchPoints {\r\n  return points.reduce(\r\n    (prev, curr) => {\r\n      return {\r\n        page: [\r\n          prev.page[0] + curr.page[0] / points.length,\r\n          prev.page[1] + curr.page[1] / points.length,\r\n        ],\r\n        client: [\r\n          prev.client[0] + curr.client[0] / points.length,\r\n          prev.client[1] + curr.client[1] / points.length,\r\n        ],\r\n        canvas: [\r\n          prev.canvas[0] + curr.canvas[0] / points.length,\r\n          prev.canvas[1] + curr.canvas[1] / points.length,\r\n        ],\r\n        world: [\r\n          prev.world[0] + curr.world[0] / points.length,\r\n          prev.world[1] + curr.world[1] / points.length,\r\n          prev.world[2] + curr.world[2] / points.length,\r\n        ],\r\n        touch: {\r\n          identifier: null,\r\n          radiusX: prev.touch.radiusX + curr.touch.radiusX / points.length,\r\n          radiusY: prev.touch.radiusY + curr.touch.radiusY / points.length,\r\n          force: prev.touch.force + curr.touch.force / points.length,\r\n          rotationAngle:\r\n            prev.touch.rotationAngle + curr.touch.rotationAngle / points.length,\r\n        },\r\n      };\r\n    },\r\n    {\r\n      page: [0, 0],\r\n      client: [0, 0],\r\n      canvas: [0, 0],\r\n      world: [0, 0, 0],\r\n      touch: {\r\n        identifier: null,\r\n        radiusX: 0,\r\n        radiusY: 0,\r\n        force: 0,\r\n        rotationAngle: 0,\r\n      },\r\n    }\r\n  );\r\n}\r\n/**\r\n * _subtractPoints - Subtracts `point1` from `point0`.\r\n * @param point0 - The first point.\r\n * @param point1 - The second point to subtract from the first.\r\n *\r\n * @returns The difference.\r\n */\r\nfunction _subtractPoints2D(\r\n  point0: Types.Point2,\r\n  point1: Types.Point2\r\n): Types.Point2 {\r\n  return [point0[0] - point1[0], point0[1] - point1[1]];\r\n}\r\n\r\nfunction _subtractPoints3D(\r\n  point0: Types.Point3,\r\n  point1: Types.Point3\r\n): Types.Point3 {\r\n  return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\r\n}\r\n\r\nfunction _getMeanDistanceBetweenAllIPoints(points: IPoints[]): IDistance {\r\n  // get mean distance between all unordered pairs of points\r\n  const pairedDistance: IDistance[] = [];\r\n  for (let i = 0; i < points.length; i++) {\r\n    for (let j = 0; j < points.length; j++) {\r\n      if (i < j) {\r\n        pairedDistance.push({\r\n          page: _getDistance2D(points[i].page, points[j].page),\r\n          client: _getDistance2D(points[i].client, points[j].client),\r\n          canvas: _getDistance2D(points[i].canvas, points[j].canvas),\r\n          world: _getDistance3D(points[i].world, points[j].world),\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  // take the average distance\r\n  return pairedDistance.reduce(\r\n    (prev, curr) => {\r\n      return {\r\n        page: prev.page + curr.page / pairedDistance.length,\r\n        client: prev.client + curr.client / pairedDistance.length,\r\n        canvas: prev.canvas + curr.canvas / pairedDistance.length,\r\n        world: prev.world + curr.world / pairedDistance.length,\r\n      };\r\n    },\r\n    {\r\n      page: 0,\r\n      client: 0,\r\n      canvas: 0,\r\n      world: 0,\r\n    }\r\n  );\r\n}\r\n\r\nfunction _getDistance2D(point0: Types.Point2, point1: Types.Point2): number {\r\n  return Math.sqrt(\r\n    Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2)\r\n  );\r\n}\r\n\r\nfunction _getDistance3D(point0: Types.Point3, point1: Types.Point3): number {\r\n  return Math.sqrt(\r\n    Math.pow(point0[0] - point1[0], 2) +\r\n      Math.pow(point0[1] - point1[1], 2) +\r\n      Math.pow(point0[2] - point1[2], 2)\r\n  );\r\n}\r\n\r\nexport {\r\n  getMeanPoints,\r\n  getMeanTouchPoints,\r\n  copyPoints,\r\n  copyPointsList,\r\n  getDeltaDistanceBetweenIPoints,\r\n  getDeltaPoints,\r\n  getDeltaDistance,\r\n  getDeltaRotation,\r\n};\r\n","import { getRenderingEngine, type Types } from '@cornerstonejs/core';\r\nimport triggerAnnotationRender from './triggerAnnotationRender';\r\nimport { getToolGroup } from '../store/ToolGroupManager';\r\n\r\n/**\r\n * Triggers annotation rendering for the specified tool group IDs.\r\n *\r\n * @param toolGroupIds - An array of tool group IDs.\r\n */\r\nexport function triggerAnnotationRenderForToolGroupIds(\r\n  toolGroupIds: string[]\r\n): void {\r\n  toolGroupIds.forEach((toolGroupId) => {\r\n    const toolGroup = getToolGroup(toolGroupId);\r\n\r\n    if (!toolGroup) {\r\n      console.warn(`ToolGroup not available for ${toolGroupId}`);\r\n      return;\r\n    }\r\n\r\n    const viewportsInfo = toolGroup.getViewportsInfo();\r\n\r\n    viewportsInfo.forEach((viewportInfo) => {\r\n      const { renderingEngineId, viewportId } = viewportInfo;\r\n\r\n      const renderingEngine = getRenderingEngine(renderingEngineId);\r\n      if (!renderingEngine) {\r\n        console.warn(`RenderingEngine not available for ${renderingEngineId}`);\r\n        return;\r\n      }\r\n\r\n      const viewport = renderingEngine.getViewport(viewportId);\r\n      triggerAnnotationRender(viewport.element);\r\n    });\r\n  });\r\n}\r\n\r\nexport default triggerAnnotationRenderForToolGroupIds;\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport type { IToolGroup } from '../../types';\r\nimport { ToolGroupManager } from '../../store';\r\nimport { ToolModes } from '../../enums';\r\n\r\nconst { Active, Passive, Enabled } = ToolModes;\r\n\r\n/**\r\n * Given an array of viewports, returns a list of viewports that have the the specified tool enabled.\r\n *\r\n * @param viewports - An array of viewports.\r\n * @param toolName - The name of the tool to filter on.\r\n *\r\n * @returns A filtered array of viewports.\r\n */\r\nexport default function filterViewportsWithToolEnabled(\r\n  viewports: Array<Types.IViewport>,\r\n  toolName: string\r\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\r\n  const numViewports = viewports.length;\r\n\r\n  const viewportsWithToolEnabled = [];\r\n\r\n  for (let vp = 0; vp < numViewports; vp++) {\r\n    const viewport = viewports[vp];\r\n\r\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\r\n      viewport.id,\r\n      viewport.renderingEngineId\r\n    );\r\n\r\n    if (!toolGroup) {\r\n      continue;\r\n    }\r\n\r\n    const hasTool = _toolGroupHasActiveEnabledOrPassiveTool(\r\n      toolGroup,\r\n      toolName\r\n    );\r\n\r\n    if (hasTool) {\r\n      viewportsWithToolEnabled.push(viewport);\r\n    }\r\n  }\r\n\r\n  return viewportsWithToolEnabled;\r\n}\r\n\r\n/**\r\n * Given a toolGroup, return true if it contains the tool with the given `toolName` and it is\r\n * active, passive or enabled.\r\n *\r\n * @param toolGroup - The `toolGroup` to check.\r\n * @param toolName - The name of the tool.\r\n *\r\n * @returns True if the tool is enabled, passive or active in the `toolGroup`.\r\n */\r\nfunction _toolGroupHasActiveEnabledOrPassiveTool(\r\n  toolGroup: IToolGroup,\r\n  toolName: string\r\n) {\r\n  const { toolOptions } = toolGroup;\r\n  const tool = toolOptions[toolName];\r\n\r\n  if (!tool) {\r\n    return false;\r\n  }\r\n\r\n  const toolMode = tool.mode;\r\n\r\n  return toolMode === Active || toolMode === Passive || toolMode === Enabled;\r\n}\r\n","import { vec3 } from 'gl-matrix';\r\n\r\n/**\r\n * It filters the viewports that are looking in the same view as the camera\r\n * It basically checks if the viewPlaneNormal is parallel to the camera viewPlaneNormal\r\n * @param viewports - Array of viewports to filter\r\n * @param camera - Camera to compare against\r\n * @returns - Array of viewports with the same view\r\n */\r\nexport function filterViewportsWithParallelNormals(\r\n  viewports,\r\n  camera,\r\n  EPS = 0.999\r\n) {\r\n  return viewports.filter((viewport) => {\r\n    const vpCamera = viewport.getCamera();\r\n\r\n    const isParallel =\r\n      Math.abs(vec3.dot(vpCamera.viewPlaneNormal, camera.viewPlaneNormal)) >\r\n      EPS;\r\n\r\n    return isParallel;\r\n  });\r\n}\r\n\r\nexport default filterViewportsWithParallelNormals;\r\n","import { getEnabledElement } from '@cornerstonejs/core';\r\nimport filterViewportsWithFrameOfReferenceUID from './filterViewportsWithFrameOfReferenceUID';\r\nimport filterViewportsWithToolEnabled from './filterViewportsWithToolEnabled';\r\nimport filterViewportsWithParallelNormals from './filterViewportsWithParallelNormals';\r\n\r\n/**\r\n * Given a cornerstone3D enabled `element`, and a `toolName`, find all viewportIds\r\n * looking at the same Frame Of Reference that have the tool with the given `toolName`\r\n * active, passive or enabled.\r\n *\r\n * @param element - The target cornerstone3D enabled element.\r\n * @param toolName - The string toolName.\r\n * @param requireParallelNormals - If true, only return viewports that have parallel normals.\r\n *\r\n * @returns An array of viewportIds.\r\n */\r\nexport default function getViewportIdsWithToolToRender(\r\n  element: HTMLDivElement,\r\n  toolName: string,\r\n  requireParallelNormals = true\r\n): string[] {\r\n  const enabledElement = getEnabledElement(element);\r\n  const { renderingEngine, FrameOfReferenceUID } = enabledElement;\r\n  // console.log('FORUID TO MATCH : ', FrameOfReferenceUID)\r\n\r\n  let viewports = renderingEngine.getViewports();\r\n\r\n  viewports = filterViewportsWithFrameOfReferenceUID(\r\n    viewports,\r\n    FrameOfReferenceUID\r\n  );\r\n  viewports = filterViewportsWithToolEnabled(viewports, toolName);\r\n\r\n  const viewport = renderingEngine.getViewport(enabledElement.viewportId);\r\n\r\n  if (requireParallelNormals) {\r\n    viewports = filterViewportsWithParallelNormals(\r\n      viewports,\r\n      viewport.getCamera()\r\n    );\r\n  }\r\n\r\n  const viewportIds = viewports.map((vp) => vp.id);\r\n\r\n  return viewportIds;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Given an array of viewports, returns a list of viewports that are viewing a\r\n * world space with the given `FrameOfReferenceUID`.\r\n *\r\n * @param viewports - An array of viewports.\r\n * @param FrameOfReferenceUID - The UID defining a particular world space/Frame Of Reference.\r\n *\r\n * @returns A filtered array of viewports.\r\n */\r\nexport default function filterViewportsWithFrameOfReferenceUID(\r\n  viewports: Array<Types.IViewport>,\r\n  FrameOfReferenceUID: string\r\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\r\n  const numViewports = viewports.length;\r\n  const viewportsWithFrameOfReferenceUID = [];\r\n\r\n  for (let vp = 0; vp < numViewports; vp++) {\r\n    const viewport = viewports[vp];\r\n\r\n    console.log(`VIEWPORT ${vp} WITH FORUID ${viewport.getFrameOfReferenceUID()}`)\r\n    if (viewport.getFrameOfReferenceUID() === FrameOfReferenceUID) {\r\n      viewportsWithFrameOfReferenceUID.push(viewport);\r\n    }\r\n  }\r\n\r\n  return viewportsWithFrameOfReferenceUID;\r\n}\r\n","import {\r\n  cache,\r\n  StackViewport,\r\n  Types,\r\n  BaseVolumeViewport,\r\n} from '@cornerstonejs/core';\r\n\r\nfunction isViewportPreScaled(\r\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\r\n  targetId: string\r\n): boolean {\r\n  if (viewport instanceof BaseVolumeViewport) {\r\n    const targetIdTokens = targetId.split('volumeId:');\r\n    const volumeId =\r\n      targetIdTokens.length > 1\r\n        ? targetIdTokens[1].split('?')[0]\r\n        : targetIdTokens[0];\r\n    const volume = cache.getVolume(volumeId);\r\n    return !!volume?.scaling && Object.keys(volume.scaling).length > 0;\r\n  } else if (viewport instanceof StackViewport) {\r\n    const { preScale } = viewport.getImageData() || {};\r\n    return !!preScale?.scaled;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport { isViewportPreScaled };\r\n","import { VolumeViewport } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { vec3 } from 'gl-matrix';\r\n\r\n// Todo: merge this utility functionality with Crosshair _jump\r\n/**\r\n * Uses the viewport's current camera to jump to a specific world coordinate\r\n * @param enabledElement - enabled element\r\n * @param jumpWorld - location in the world to jump to\r\n * @returns True if successful\r\n */\r\nexport default function jumpToWorld(\r\n  viewport: Types.IVolumeViewport,\r\n  jumpWorld: Types.Point3\r\n): true | undefined {\r\n  // if not instance of volumeViewport, return\r\n  if (!(viewport instanceof VolumeViewport)) {\r\n    return;\r\n  }\r\n\r\n  const { focalPoint } = viewport.getCamera();\r\n\r\n  const delta: Types.Point3 = [0, 0, 0];\r\n  vec3.sub(delta, jumpWorld, focalPoint);\r\n\r\n  _applyShift(viewport, delta);\r\n\r\n  return true;\r\n}\r\n\r\nfunction _applyShift(viewport, delta) {\r\n  const camera = viewport.getCamera();\r\n  const normal = camera.viewPlaneNormal;\r\n\r\n  const dotProd = vec3.dot(delta, normal);\r\n  const projectedDelta = vec3.fromValues(normal[0], normal[1], normal[2]);\r\n\r\n  vec3.scale(projectedDelta, projectedDelta, dotProd);\r\n\r\n  if (\r\n    Math.abs(projectedDelta[0]) > 1e-3 ||\r\n    Math.abs(projectedDelta[1]) > 1e-3 ||\r\n    Math.abs(projectedDelta[2]) > 1e-3\r\n  ) {\r\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\r\n    const newPosition: Types.Point3 = [0, 0, 0];\r\n\r\n    vec3.add(newFocalPoint, camera.focalPoint, projectedDelta);\r\n    vec3.add(newPosition, camera.position, projectedDelta);\r\n\r\n    viewport.setCamera({\r\n      focalPoint: newFocalPoint,\r\n      position: newPosition,\r\n    });\r\n    viewport.render();\r\n  }\r\n}\r\n","/**\r\n * Linear interpolation between two vec3.\r\n * Can be used, for example, to interpolate between two RGB colors.\r\n * @param a - First vec3\r\n * @param b - Second vec3\r\n * @param t - Time \"t\".\r\n *   - Vector A is returned for values smaller than or equel to 0.\r\n *   - Vector B is returned for values greater than or equal to 1.\r\n *   - An interpolation between vectors A and B is returned otherwise.\r\n * @returns\r\n */\r\nconst interpolateVec3 = (a, b, t) => {\r\n  return [\r\n    a[0] * (1 - t) + b[0] * t,\r\n    a[1] * (1 - t) + b[1] * t,\r\n    a[2] * (1 - t) + b[2] * t,\r\n  ];\r\n};\r\n\r\nexport { interpolateVec3 as default, interpolateVec3 };\r\n","import { IColorMapPreset } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\r\nimport { utilities } from '@cornerstonejs/core';\r\nimport interpolateVec3 from '../../math/vec3/interpolateVec3';\r\nimport { ColorbarCanvasProps } from './types/ColorbarCanvasProps';\r\nimport type { ColorbarImageRange, ColorbarVOIRange } from './types';\r\nimport type { ColorbarSize } from './types/ColorbarSize';\r\nimport {\r\n  isRangeValid,\r\n  areColorbarRangesEqual,\r\n  isColorbarSizeValid,\r\n  areColorbarSizesEqual,\r\n} from './common';\r\n\r\nconst { clamp } = utilities;\r\n\r\n/**\r\n * Canvas referenced by the color bar where the colormap is rendered. It may\r\n * show the full image range or only the VOI range.\r\n */\r\nclass ColorbarCanvas {\r\n  private _canvas: HTMLCanvasElement;\r\n  private _imageRange: ColorbarImageRange;\r\n  private _voiRange: ColorbarVOIRange;\r\n  private _colormap: IColorMapPreset;\r\n  private _showFullImageRange: boolean;\r\n\r\n  constructor(props: ColorbarCanvasProps) {\r\n    ColorbarCanvas.validateProps(props);\r\n\r\n    const {\r\n      colormap,\r\n      size = { width: 20, height: 100 },\r\n      imageRange = { lower: 0, upper: 1 },\r\n      voiRange = { lower: 0, upper: 1 },\r\n      container,\r\n      showFullPixelValueRange = false,\r\n    } = props;\r\n\r\n    this._colormap = colormap;\r\n    this._imageRange = imageRange;\r\n    this._voiRange = voiRange;\r\n    this._showFullImageRange = showFullPixelValueRange;\r\n    this._canvas = this._createRootElement(size);\r\n\r\n    if (container) {\r\n      this.appendTo(container);\r\n    }\r\n  }\r\n\r\n  public get colormap(): IColorMapPreset {\r\n    return this._colormap;\r\n  }\r\n\r\n  public set colormap(colormap: IColorMapPreset) {\r\n    this._colormap = colormap;\r\n    this.render();\r\n  }\r\n\r\n  public get size(): ColorbarSize {\r\n    const { width, height } = this._canvas;\r\n    return { width, height };\r\n  }\r\n\r\n  public set size(size: ColorbarSize) {\r\n    const { _canvas: canvas } = this;\r\n\r\n    if (!isColorbarSizeValid(size) || areColorbarSizesEqual(canvas, size)) {\r\n      return;\r\n    }\r\n\r\n    this._setCanvasSize(canvas, size);\r\n    this.render();\r\n  }\r\n\r\n  public get imageRange(): ColorbarImageRange {\r\n    return { ...this._imageRange };\r\n  }\r\n\r\n  public set imageRange(imageRange: ColorbarImageRange) {\r\n    if (\r\n      !isRangeValid(imageRange) ||\r\n      areColorbarRangesEqual(imageRange, this._imageRange)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    this._imageRange = imageRange;\r\n    this.render();\r\n  }\r\n\r\n  public get voiRange(): ColorbarVOIRange {\r\n    return { ...this._voiRange };\r\n  }\r\n\r\n  public set voiRange(voiRange: ColorbarVOIRange) {\r\n    if (\r\n      !isRangeValid(voiRange) ||\r\n      areColorbarRangesEqual(voiRange, this._voiRange)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    this._voiRange = voiRange;\r\n    this.render();\r\n  }\r\n\r\n  public get showFullImageRange(): boolean {\r\n    return this._showFullImageRange;\r\n  }\r\n\r\n  public set showFullImageRange(showFullImageRange: boolean) {\r\n    if (showFullImageRange === this._showFullImageRange) {\r\n      return;\r\n    }\r\n\r\n    this._showFullImageRange = showFullImageRange;\r\n    this.render();\r\n  }\r\n\r\n  public appendTo(container: HTMLElement) {\r\n    container.appendChild(this._canvas);\r\n    this.render();\r\n  }\r\n\r\n  public dispose() {\r\n    const { _canvas: canvas } = this;\r\n    const { parentElement } = canvas;\r\n\r\n    parentElement?.removeChild(canvas);\r\n  }\r\n\r\n  private static validateProps(props: ColorbarCanvasProps) {\r\n    const { size, imageRange, voiRange } = props;\r\n\r\n    if (size && !isColorbarSizeValid(size)) {\r\n      throw new Error('Invalid \"size\"');\r\n    }\r\n\r\n    if (imageRange && !isRangeValid(imageRange)) {\r\n      throw new Error('Invalid \"imageRange\"');\r\n    }\r\n\r\n    if (voiRange && !isRangeValid(voiRange)) {\r\n      throw new Error('Invalid \"voiRange\"');\r\n    }\r\n  }\r\n\r\n  private _setCanvasSize(canvas: HTMLCanvasElement, size: ColorbarSize) {\r\n    const { width, height } = size;\r\n\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n\r\n    Object.assign(canvas.style, {\r\n      width: `${width}px`,\r\n      height: `${height}px`,\r\n    });\r\n  }\r\n\r\n  private _createRootElement(size: ColorbarSize) {\r\n    const canvas = document.createElement('canvas');\r\n\r\n    Object.assign(canvas.style, {\r\n      position: 'absolute',\r\n      top: '0',\r\n      left: '0',\r\n      pointerEvents: 'none',\r\n      boxSizing: 'border-box',\r\n    });\r\n\r\n    this._setCanvasSize(canvas, size);\r\n\r\n    return canvas;\r\n  }\r\n\r\n  private render(): void {\r\n    if (!this._canvas.isConnected) {\r\n      return;\r\n    }\r\n\r\n    const { _colormap: colormap } = this;\r\n    const { RGBPoints: rgbPoints } = colormap;\r\n    const colorsCount = rgbPoints.length / 4;\r\n\r\n    // Returns a color point from rgbPoints. Each point has position, red,\r\n    // green and blue components which means each point has an offset equal\r\n    // to `4 * index`\r\n    const getColorPoint = (index) => {\r\n      const offset = 4 * index;\r\n\r\n      // It can get out of bounds when `voiRange.upper` is smaller than\r\n      // `imageRange.upper`. It's also checking if is smaller than zero\r\n      // for safety only because that should never happens.\r\n      if (index < 0 || index >= colorsCount) {\r\n        return;\r\n      }\r\n\r\n      return {\r\n        index,\r\n        position: rgbPoints[offset],\r\n        color: [\r\n          rgbPoints[offset + 1],\r\n          rgbPoints[offset + 2],\r\n          rgbPoints[offset + 3],\r\n        ],\r\n      };\r\n    };\r\n\r\n    const { width, height } = this._canvas;\r\n    const canvasContext = this._canvas.getContext('2d');\r\n    const isHorizontal = width > height;\r\n    const maxValue = isHorizontal ? width : height;\r\n    const { _voiRange: voiRange } = this;\r\n    const range = this._showFullImageRange ? this._imageRange : { ...voiRange };\r\n\r\n    const { windowWidth } = utilities.windowLevel.toWindowLevel(\r\n      voiRange.lower,\r\n      voiRange.upper\r\n    );\r\n\r\n    let previousColorPoint = undefined;\r\n    let currentColorPoint = getColorPoint(0);\r\n\r\n    // Starts from `range.lower` incrementing by incRawPixelValue on each iteration\r\n    const incRawPixelValue = (range.upper - range.lower) / (maxValue - 1);\r\n    let rawPixelValue = range.lower;\r\n\r\n    for (let i = 0; i < maxValue; i++) {\r\n      const tVoiRange = (rawPixelValue - voiRange.lower) / windowWidth;\r\n\r\n      // Find the color in a linear way (O(n) complexity).\r\n      // currentColorPoint shall move to the next color until tVoiRange is smaller\r\n      // than or equal to next color position.\r\n      if (currentColorPoint) {\r\n        for (let i = currentColorPoint.index; i < colorsCount; i++) {\r\n          if (tVoiRange <= currentColorPoint.position) {\r\n            break;\r\n          }\r\n\r\n          previousColorPoint = currentColorPoint;\r\n          currentColorPoint = getColorPoint(i + 1);\r\n        }\r\n      }\r\n\r\n      let normColor;\r\n\r\n      // For:\r\n      //   - firstColorPoint = getColorPoint(0)\r\n      //   - secondColorPoint = getColorPoint(1)\r\n      //   - lastColorPoint = getColorPoint(colorsCount - 1)\r\n      // Then\r\n      //   - previousColorPoint shall be undefined when tVoiRange < firstColorPoint.position\r\n      //   - currentColorPoint shall be undefined when tVoiRange > lastColorPoint.position\r\n      //   - previousColorPoint and currentColorPoint will be defined when\r\n      //     currentColorPoint.position is between secondColorPoint.position and\r\n      //     lastColorPoint.position.\r\n      if (!previousColorPoint) {\r\n        normColor = [...currentColorPoint.color];\r\n      } else if (!currentColorPoint) {\r\n        normColor = [...previousColorPoint.color];\r\n      } else {\r\n        const tColorRange =\r\n          (tVoiRange - previousColorPoint.position) /\r\n          (currentColorPoint.position - previousColorPoint.position);\r\n\r\n        normColor = interpolateVec3(\r\n          previousColorPoint.color,\r\n          currentColorPoint.color,\r\n          tColorRange\r\n        );\r\n      }\r\n\r\n      const color = normColor.map((color) =>\r\n        clamp(Math.round(color * 255), 0, 255)\r\n      );\r\n\r\n      canvasContext.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;\r\n\r\n      if (isHorizontal) {\r\n        canvasContext.fillRect(i, 0, 1, height);\r\n      } else {\r\n        canvasContext.fillRect(0, height - i - 1, width, 1);\r\n      }\r\n\r\n      rawPixelValue += incRawPixelValue;\r\n    }\r\n  }\r\n}\r\n\r\nexport { ColorbarCanvas as default, ColorbarCanvas };\r\n","import { IColorMapPreset } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\r\nimport { vec2 } from 'gl-matrix';\r\nimport { utilities as csUtils, Types } from '@cornerstonejs/core';\r\nimport type { ColorbarProps, ColorbarVOIRange } from './types';\r\nimport { isRangeValid, areColorbarRangesEqual } from './common';\r\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\r\nimport { ColorbarCanvas } from './ColorbarCanvas';\r\nimport { ColorbarTicks } from './ColorbarTicks';\r\nimport isRangeTextPositionValid from './common/isRangeTextPositionValid';\r\nimport Widget from '../../../widgets/Widget';\r\n\r\nconst DEFAULTS = {\r\n  MULTIPLIER: 1,\r\n  RANGE_TEXT_POSITION: ColorbarRangeTextPosition.Right,\r\n  TICKS_BAR_SIZE: 50,\r\n};\r\n\r\ntype ColorbarPoints = {\r\n  page: Types.Point2;\r\n  client: Types.Point2;\r\n  local: Types.Point2;\r\n};\r\n\r\n/**\r\n * A base colorbar class that is not associated with any viewport. It is\r\n * possible to click and drag to change the VOI range, shows the ticks during\r\n * interaction and it can show full image range or VOI range.\r\n */\r\nclass Colorbar extends Widget {\r\n  private _colormaps: Map<string, IColorMapPreset>;\r\n  private _activeColormapName: string;\r\n  private _eventListenersManager: csUtils.eventListener.MultiTargetEventListenerManager;\r\n  private _canvas: ColorbarCanvas;\r\n  private _ticksBar: ColorbarTicks;\r\n  private _rangeTextPosition: ColorbarRangeTextPosition;\r\n\r\n  private _isMouseOver = false;\r\n  private _isInteracting = false;\r\n\r\n  constructor(props: ColorbarProps) {\r\n    super(props);\r\n\r\n    this._eventListenersManager =\r\n      new csUtils.eventListener.MultiTargetEventListenerManager();\r\n    this._colormaps = Colorbar.getColormapsMap(props);\r\n    this._activeColormapName = Colorbar.getInitialColormapName(props);\r\n    this._canvas = this._createCanvas(props);\r\n    this._ticksBar = this._createTicksBar(props);\r\n    this._rangeTextPosition =\r\n      props.ticks?.position ?? DEFAULTS.RANGE_TEXT_POSITION;\r\n\r\n    this._canvas.appendTo(this.rootElement);\r\n    this._ticksBar.appendTo(this.rootElement);\r\n\r\n    this._addRootElementEventListeners();\r\n  }\r\n\r\n  /**\r\n   * Returns the active LUT name\r\n   */\r\n  public get activeColormapName() {\r\n    return this._activeColormapName;\r\n  }\r\n\r\n  /**\r\n   * Set the current active LUT name and re-renders the color bar\r\n   */\r\n  public set activeColormapName(colormapName: string) {\r\n    if (colormapName === this._activeColormapName) {\r\n      return;\r\n    }\r\n\r\n    const colormap = this._colormaps.get(colormapName);\r\n\r\n    if (!colormap) {\r\n      console.warn(`Invalid colormap name (${colormapName})`);\r\n      return;\r\n    }\r\n\r\n    this._activeColormapName = colormapName;\r\n    this._canvas.colormap = colormap;\r\n  }\r\n\r\n  public get imageRange() {\r\n    return this._canvas.imageRange;\r\n  }\r\n\r\n  public set imageRange(imageRange: ColorbarVOIRange) {\r\n    this._canvas.imageRange = imageRange;\r\n    this._ticksBar.imageRange = imageRange;\r\n  }\r\n\r\n  public get voiRange() {\r\n    return this._canvas.voiRange;\r\n  }\r\n\r\n  public set voiRange(voiRange: ColorbarVOIRange) {\r\n    const { voiRange: currentVoiRange } = this._canvas;\r\n\r\n    if (\r\n      !isRangeValid(voiRange) ||\r\n      areColorbarRangesEqual(voiRange, currentVoiRange)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    this._canvas.voiRange = voiRange;\r\n    this._ticksBar.voiRange = voiRange;\r\n    this.onVoiChange(voiRange);\r\n  }\r\n\r\n  public get showFullImageRange() {\r\n    return this._canvas.showFullImageRange;\r\n  }\r\n\r\n  public set showFullImageRange(value: boolean) {\r\n    this._canvas.showFullImageRange = value;\r\n    this._ticksBar.showFullPixelValueRange = value;\r\n  }\r\n\r\n  public destroy() {\r\n    super.destroy();\r\n    this._eventListenersManager.reset();\r\n  }\r\n\r\n  protected createRootElement(): HTMLElement {\r\n    const rootElement = document.createElement('div');\r\n\r\n    Object.assign(rootElement.style, {\r\n      position: 'relative',\r\n      fontSize: '0',\r\n      width: '100%',\r\n      height: '100%',\r\n    });\r\n\r\n    return rootElement;\r\n  }\r\n\r\n  protected onContainerResize() {\r\n    super.onContainerResize();\r\n    this.updateTicksBar();\r\n    this._canvas.size = this.containerSize;\r\n  }\r\n\r\n  protected getVOIMultipliers(): [number, number] {\r\n    return [DEFAULTS.MULTIPLIER, DEFAULTS.MULTIPLIER];\r\n  }\r\n\r\n  protected onVoiChange(voiRange: ColorbarVOIRange) {\r\n    // no-op\r\n  }\r\n\r\n  protected showTicks() {\r\n    this.updateTicksBar();\r\n    this._ticksBar.visible = true;\r\n  }\r\n\r\n  protected hideTicks() {\r\n    if (this._isInteracting || this._isMouseOver) {\r\n      return;\r\n    }\r\n\r\n    this._ticksBar.visible = false;\r\n  }\r\n\r\n  private static getColormapsMap(props: ColorbarProps) {\r\n    const { colormaps } = props;\r\n\r\n    return colormaps.reduce(\r\n      (items, item) => items.set(item.Name, item),\r\n      new Map<string, IColorMapPreset>()\r\n    );\r\n  }\r\n\r\n  private static getInitialColormapName(props: ColorbarProps) {\r\n    const { activeColormapName, colormaps } = props;\r\n    const colormapExists =\r\n      !!activeColormapName &&\r\n      colormaps.some((cm) => cm.Name === activeColormapName);\r\n\r\n    return colormapExists ? activeColormapName : colormaps[0].Name;\r\n  }\r\n\r\n  private _createCanvas(props: ColorbarProps) {\r\n    const { imageRange, voiRange, showFullPixelValueRange } = props;\r\n    const colormap = this._colormaps.get(this._activeColormapName);\r\n\r\n    return new ColorbarCanvas({\r\n      colormap,\r\n      imageRange,\r\n      voiRange: voiRange,\r\n      showFullPixelValueRange,\r\n    });\r\n  }\r\n\r\n  public _createTicksBar(props: ColorbarProps): ColorbarTicks {\r\n    const ticksProps = props.ticks;\r\n\r\n    return new ColorbarTicks({\r\n      imageRange: props.imageRange,\r\n      voiRange: props.voiRange,\r\n      ticks: ticksProps,\r\n      showFullPixelValueRange: props.showFullPixelValueRange,\r\n    });\r\n  }\r\n\r\n  private _getPointsFromMouseEvent(evt: MouseEvent): ColorbarPoints {\r\n    const { rootElement: element } = this;\r\n    const clientPoint: Types.Point2 = [evt.clientX, evt.clientY];\r\n    const pagePoint: Types.Point2 = [evt.pageX, evt.pageY];\r\n    const rect = element.getBoundingClientRect();\r\n    const localPoints: Types.Point2 = [\r\n      pagePoint[0] - rect.left - window.pageXOffset,\r\n      pagePoint[1] - rect.top - window.pageYOffset,\r\n    ];\r\n\r\n    return { client: clientPoint, page: pagePoint, local: localPoints };\r\n  }\r\n\r\n  private updateTicksBar() {\r\n    const { width: containerWidth, height: containerHeight } =\r\n      this.containerSize;\r\n\r\n    // ResizeObserver have not triggered any event when this happen\r\n    if (containerWidth === 0 && containerHeight === 0) {\r\n      return;\r\n    }\r\n\r\n    const { _ticksBar: ticksBar, _rangeTextPosition: rangeTextPosition } = this;\r\n    const isHorizontal = containerWidth >= containerHeight;\r\n    const width = isHorizontal ? containerWidth : DEFAULTS.TICKS_BAR_SIZE;\r\n    const height = isHorizontal ? DEFAULTS.TICKS_BAR_SIZE : containerHeight;\r\n\r\n    if (\r\n      !isRangeTextPositionValid(\r\n        containerWidth,\r\n        containerHeight,\r\n        rangeTextPosition\r\n      )\r\n    ) {\r\n      throw new Error(\r\n        'Invalid rangeTextPosition value for the current colobar orientation'\r\n      );\r\n    }\r\n\r\n    let ticksBarTop;\r\n    let ticksBarLeft;\r\n\r\n    ticksBar.size = { width, height };\r\n\r\n    if (isHorizontal) {\r\n      ticksBarLeft = 0;\r\n      ticksBarTop =\r\n        rangeTextPosition === ColorbarRangeTextPosition.Top\r\n          ? -height\r\n          : containerHeight;\r\n    } else {\r\n      ticksBarTop = 0;\r\n      ticksBarLeft =\r\n        rangeTextPosition === ColorbarRangeTextPosition.Left\r\n          ? -width\r\n          : containerWidth;\r\n    }\r\n\r\n    ticksBar.top = ticksBarTop;\r\n    ticksBar.left = ticksBarLeft;\r\n  }\r\n\r\n  private _mouseOverCallback = (evt) => {\r\n    this._isMouseOver = true;\r\n    this.showTicks();\r\n    evt.stopPropagation();\r\n  };\r\n\r\n  private _mouseOutCallback = (evt) => {\r\n    this._isMouseOver = false;\r\n    this.hideTicks();\r\n    evt.stopPropagation();\r\n  };\r\n\r\n  private _mouseDownCallback = (evt: MouseEvent) => {\r\n    this._isInteracting = true;\r\n    this.showTicks();\r\n    this._addVOIEventListeners(evt);\r\n    evt.stopPropagation();\r\n  };\r\n\r\n  private _mouseDragCallback = (evt, initialState) => {\r\n    const multipliers = this.getVOIMultipliers();\r\n    const currentPoints = this._getPointsFromMouseEvent(evt);\r\n    const { points: startPoints, voiRange: startVOIRange } = initialState;\r\n    const canvasDelta = vec2.sub(\r\n      vec2.create(),\r\n      currentPoints.local,\r\n      startPoints.local\r\n    );\r\n\r\n    const wwDelta = canvasDelta[0] * multipliers[0];\r\n    const wcDelta = canvasDelta[1] * multipliers[1];\r\n\r\n    if (!wwDelta && !wcDelta) {\r\n      return;\r\n    }\r\n\r\n    const { lower: voiLower, upper: voiUpper } = startVOIRange;\r\n    let { windowWidth, windowCenter } = csUtils.windowLevel.toWindowLevel(\r\n      voiLower,\r\n      voiUpper\r\n    );\r\n\r\n    windowWidth = Math.max(windowWidth + wwDelta, 1);\r\n    windowCenter += wcDelta;\r\n\r\n    const newVoiRange = csUtils.windowLevel.toLowHighRange(\r\n      windowWidth,\r\n      windowCenter\r\n    );\r\n\r\n    this.voiRange = newVoiRange;\r\n    evt.stopPropagation();\r\n    evt.preventDefault();\r\n  };\r\n\r\n  private _mouseUpCallback = (evt) => {\r\n    this._isInteracting = false;\r\n    this.hideTicks();\r\n    this._removeVOIEventListeners();\r\n    evt.stopPropagation();\r\n  };\r\n\r\n  private _addRootElementEventListeners() {\r\n    const { _eventListenersManager: manager } = this;\r\n    const { rootElement: element } = this;\r\n\r\n    manager.addEventListener(element, 'mouseover', this._mouseOverCallback);\r\n    manager.addEventListener(element, 'mouseout', this._mouseOutCallback);\r\n    manager.addEventListener(\r\n      element,\r\n      'mousedown',\r\n      this._mouseDownCallback as EventListener\r\n    );\r\n  }\r\n\r\n  private _addVOIEventListeners(evt: MouseEvent) {\r\n    const { _eventListenersManager: manager } = this;\r\n    const points = this._getPointsFromMouseEvent(evt);\r\n    const voiRange = { ...this._canvas.voiRange };\r\n    const initialDragState = { points, voiRange };\r\n\r\n    this._removeVOIEventListeners();\r\n\r\n    manager.addEventListener(document, 'voi.mouseup', this._mouseUpCallback);\r\n    manager.addEventListener(document, 'voi.mousemove', (evt) =>\r\n      this._mouseDragCallback(evt, initialDragState)\r\n    );\r\n  }\r\n\r\n  private _removeVOIEventListeners() {\r\n    const { _eventListenersManager: manager } = this;\r\n\r\n    manager.removeEventListener(document, 'voi.mouseup');\r\n    manager.removeEventListener(document, 'voi.mousemove');\r\n  }\r\n}\r\n\r\nexport { Colorbar as default, Colorbar };\r\n","import {\r\n  eventTarget,\r\n  VolumeViewport,\r\n  StackViewport,\r\n  Types,\r\n  Enums,\r\n  utilities,\r\n  getEnabledElement,\r\n} from '@cornerstonejs/core';\r\nimport { Colorbar } from './Colorbar';\r\nimport type { ViewportColorbarProps, ColorbarVOIRange } from './types';\r\nimport { getVOIMultipliers } from '../../getVOIMultipliers';\r\n\r\nconst { Events } = Enums;\r\nconst defaultImageRange = { lower: -1000, upper: 1000 };\r\n/**\r\n * A colorbar associated with a viewport that updates automatically when the\r\n * viewport VOI changes or when the stack/volume are updated..\r\n */\r\nclass ViewportColorbar extends Colorbar {\r\n  private _element: HTMLDivElement;\r\n  private _volumeId: string;\r\n\r\n  private _hideTicksTime: number;\r\n  private _hideTicksTimeoutId: number;\r\n\r\n  constructor(props: ViewportColorbarProps) {\r\n    const { element, volumeId } = props;\r\n    const imageRange = ViewportColorbar._getImageRange(element, volumeId);\r\n    const voiRange = ViewportColorbar._getVOIRange(element, volumeId);\r\n\r\n    super({ ...props, imageRange, voiRange });\r\n\r\n    this._element = element;\r\n    this._volumeId = volumeId;\r\n\r\n    this._addCornerstoneEventListener();\r\n  }\r\n\r\n  public get element() {\r\n    return this._element;\r\n  }\r\n\r\n  public get enabledElement() {\r\n    return getEnabledElement(this._element);\r\n  }\r\n\r\n  protected getVOIMultipliers(): [number, number] {\r\n    const { viewport } = this.enabledElement;\r\n    return getVOIMultipliers(viewport, this._volumeId);\r\n  }\r\n\r\n  protected onVoiChange(voiRange: ColorbarVOIRange) {\r\n    super.onVoiChange(voiRange);\r\n\r\n    const { viewport } = this.enabledElement;\r\n\r\n    if (viewport instanceof StackViewport) {\r\n      viewport.setProperties({\r\n        voiRange: voiRange,\r\n      });\r\n      viewport.render();\r\n    } else if (viewport instanceof VolumeViewport) {\r\n      const { _volumeId: volumeId } = this;\r\n      const viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(\r\n        volumeId,\r\n        viewport.renderingEngineId\r\n      );\r\n\r\n      viewport.setProperties({ voiRange }, volumeId);\r\n      viewportsContainingVolumeUID.forEach((vp) => vp.render());\r\n    }\r\n  }\r\n\r\n  private static _getImageRange(element, volumeId?) {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    const actor = volumeId\r\n      ? viewport.getActor(volumeId)\r\n      : viewport.getDefaultActor();\r\n\r\n    if (!actor) {\r\n      return defaultImageRange;\r\n    }\r\n\r\n    const imageData = actor.actor.getMapper().getInputData();\r\n    const imageRange = imageData.getPointData().getScalars().getRange();\r\n\r\n    return imageRange[0] === 0 && imageRange[1] === 0\r\n      ? defaultImageRange\r\n      : { lower: imageRange[0], upper: imageRange[1] };\r\n  }\r\n\r\n  private static _getVOIRange(element, volumeId) {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    const volumeActor = volumeId\r\n      ? viewport.getActor(volumeId)\r\n      : viewport.getDefaultActor();\r\n\r\n    if (!volumeActor || !utilities.isImageActor(volumeActor)) {\r\n      return defaultImageRange;\r\n    }\r\n\r\n    const voiRange = (volumeActor.actor as Types.ImageActor)\r\n      .getProperty()\r\n      .getRGBTransferFunction(0)\r\n      .getRange();\r\n\r\n    return voiRange[0] === 0 && voiRange[1] === 0\r\n      ? defaultImageRange\r\n      : { lower: voiRange[0], upper: voiRange[1] };\r\n  }\r\n\r\n  private autoHideTicks = () => {\r\n    // Avoiding calling setTimeout multiple times when manipulating the VOI\r\n    // via WindowLevel tool for better performance\r\n    if (this._hideTicksTimeoutId) {\r\n      return;\r\n    }\r\n\r\n    const timeLeft = this._hideTicksTime - Date.now();\r\n\r\n    if (timeLeft <= 0) {\r\n      this.hideTicks();\r\n    } else {\r\n      this._hideTicksTimeoutId = window.setTimeout(() => {\r\n        // Recursive call until there is no more time left\r\n        this._hideTicksTimeoutId = 0;\r\n        this.autoHideTicks();\r\n      }, timeLeft);\r\n    }\r\n  };\r\n\r\n  private showAndAutoHideTicks(interval = 1000) {\r\n    this._hideTicksTime = Date.now() + interval;\r\n    this.showTicks();\r\n    this.autoHideTicks();\r\n  }\r\n\r\n  private _stackNewImageCallback = () => {\r\n    this.imageRange = ViewportColorbar._getImageRange(this._element);\r\n  };\r\n\r\n  private _imageVolumeModifiedCallback = (\r\n    evt: Types.EventTypes.ImageVolumeModifiedEvent\r\n  ) => {\r\n    const { volumeId } = evt.detail.imageVolume;\r\n\r\n    if (volumeId !== this._volumeId) {\r\n      return;\r\n    }\r\n\r\n    const { _element: element } = this;\r\n    this.imageRange = ViewportColorbar._getImageRange(element, volumeId);\r\n  };\r\n\r\n  private _viewportVOIModifiedCallback = (\r\n    evt: Types.EventTypes.VoiModifiedEvent\r\n  ) => {\r\n    const { viewportId, volumeId, range: voiRange, colormap } = evt.detail;\r\n    const { viewport } = this.enabledElement;\r\n    if (viewportId !== viewport.id || volumeId !== this._volumeId) {\r\n      return;\r\n    }\r\n\r\n    this.voiRange = voiRange;\r\n\r\n    if (colormap) {\r\n      this.activeColormapName = colormap.name;\r\n    }\r\n    this.showAndAutoHideTicks();\r\n  };\r\n\r\n  private _viewportColormapModifiedCallback = (\r\n    evt: Types.EventTypes.ColormapModifiedEvent\r\n  ) => {\r\n    const { viewportId, colormap, volumeId } = evt.detail;\r\n    const { viewport } = this.enabledElement;\r\n\r\n    if (viewportId !== viewport.id || volumeId !== this._volumeId) {\r\n      return;\r\n    }\r\n\r\n    this.activeColormapName = colormap.name;\r\n  };\r\n\r\n  private _addCornerstoneEventListener() {\r\n    const { _element: element } = this;\r\n\r\n    eventTarget.addEventListener(\r\n      Events.IMAGE_VOLUME_MODIFIED,\r\n      this._imageVolumeModifiedCallback\r\n    );\r\n\r\n    element.addEventListener(\r\n      Events.STACK_NEW_IMAGE,\r\n      this._stackNewImageCallback\r\n    );\r\n\r\n    element.addEventListener(\r\n      Events.VOI_MODIFIED,\r\n      this._viewportVOIModifiedCallback as EventListener\r\n    );\r\n\r\n    element.addEventListener(\r\n      Events.COLORMAP_MODIFIED,\r\n      this._viewportColormapModifiedCallback as EventListener\r\n    );\r\n  }\r\n}\r\n\r\nexport { ViewportColorbar as default, ViewportColorbar };\r\n","/**\r\n * Specify the position of the text/ticks.\r\n * Left/Right are the valid options for a vertical colorbars and Top/Bottom\r\n * for the horizontal ones.\r\n */\r\nexport enum ColorbarRangeTextPosition {\r\n  Top = 'top',\r\n  Left = 'left',\r\n  Bottom = 'bottom',\r\n  Right = 'right',\r\n}\r\n","/**\r\n * Extracts the luminance values from a specified region of an image.\r\n *\r\n * @param {Object} imageData - The image data object containing pixel information.\r\n * @param {Uint8Array} imageData.scalarData - The pixel data array.\r\n * @param {boolean} imageData.color - A flag indicating if the image is in color (true) or grayscale (false).\r\n * @param {number} imageData.columns - The number of columns (width) in the image.\r\n * @param {number} x - The x-coordinate of the top-left corner of the region.\r\n * @param {number} y - The y-coordinate of the top-left corner of the region.\r\n * @param {number} width - The width of the region.\r\n * @param {number} height - The height of the region.\r\n * @returns {number[]} An array containing the luminance values of the specified region.\r\n */\r\nfunction getLuminanceFromRegion(imageData, x, y, width, height) {\r\n  const luminance = [];\r\n  let index = 0;\r\n  const pixelData = imageData.scalarData;\r\n  let spIndex, row, column;\r\n\r\n  if (imageData.color) {\r\n    for (row = 0; row < height; row++) {\r\n      for (column = 0; column < width; column++) {\r\n        spIndex = ((row + y) * imageData.columns + (column + x)) * 4;\r\n        const red = pixelData[spIndex];\r\n        const green = pixelData[spIndex + 1];\r\n        const blue = pixelData[spIndex + 2];\r\n\r\n        luminance[index++] = 0.2126 * red + 0.7152 * green + 0.0722 * blue;\r\n      }\r\n    }\r\n  } else {\r\n    for (row = 0; row < height; row++) {\r\n      for (column = 0; column < width; column++) {\r\n        spIndex = (row + y) * imageData.columns + (column + x);\r\n        luminance[index++] = pixelData[spIndex];\r\n      }\r\n    }\r\n  }\r\n\r\n  return luminance;\r\n}\r\n\r\nexport { getLuminanceFromRegion };\r\n","function calculateMinMaxMean(pixelLuminance, globalMin, globalMax) {\r\n  const numPixels = pixelLuminance.length;\r\n  let min = globalMax;\r\n  let max = globalMin;\r\n  let sum = 0;\r\n\r\n  if (numPixels < 2) {\r\n    return {\r\n      min,\r\n      max,\r\n      mean: (globalMin + globalMax) / 2,\r\n    };\r\n  }\r\n\r\n  for (let index = 0; index < numPixels; index++) {\r\n    const spv = pixelLuminance[index];\r\n\r\n    min = Math.min(min, spv);\r\n    max = Math.max(max, spv);\r\n    sum += spv;\r\n  }\r\n\r\n  return {\r\n    min,\r\n    max,\r\n    mean: sum / numPixels,\r\n  };\r\n}\r\n\r\nexport { calculateMinMaxMean };\r\n","import {\r\n  VolumeViewport,\r\n  utilities as csUtils,\r\n  cache,\r\n  StackViewport,\r\n} from '@cornerstonejs/core';\r\n\r\nfunction extractWindowLevelRegionToolData(viewport) {\r\n  if (viewport instanceof VolumeViewport) {\r\n    return extractImageDataVolume(viewport);\r\n  }\r\n  if (viewport instanceof StackViewport) {\r\n    return extractImageDataStack(viewport);\r\n  }\r\n\r\n  throw new Error('Viewport not supported');\r\n}\r\n\r\nfunction extractImageDataVolume(viewport) {\r\n  const { scalarData, width, height } =\r\n    csUtils.getCurrentVolumeViewportSlice(viewport);\r\n  const { min: minPixelValue, max: maxPixelValue } =\r\n    csUtils.getMinMax(scalarData);\r\n  const volumeId = viewport.getVolumeId();\r\n  const volume = cache.getVolume(volumeId);\r\n  // @ts-ignore\r\n  const { metadata, cornerstoneImageMetaData } = volume;\r\n  const { Rows: rows, Columns: columns } = metadata;\r\n  const { color } = cornerstoneImageMetaData;\r\n  return {\r\n    scalarData,\r\n    width,\r\n    height,\r\n    minPixelValue,\r\n    maxPixelValue,\r\n    rows,\r\n    columns,\r\n    color,\r\n  };\r\n}\r\n\r\nfunction extractImageDataStack(viewport) {\r\n  const imageData = viewport.getImageData();\r\n  const { scalarData } = imageData;\r\n  const { min: minPixelValue, max: maxPixelValue } =\r\n    csUtils.getMinMax(scalarData);\r\n  const width = imageData.dimensions[0];\r\n  const height = imageData.dimensions[1];\r\n  const { rows, columns, color } = viewport.getCornerstoneImage();\r\n\r\n  return {\r\n    scalarData,\r\n    width,\r\n    height,\r\n    minPixelValue,\r\n    maxPixelValue,\r\n    rows,\r\n    columns,\r\n    color,\r\n  };\r\n}\r\n\r\nexport { extractWindowLevelRegionToolData };\r\n","\nvar ICRPolySegApp = (() => {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n  \n  return (\nfunction(ICRPolySegApp) {\n  ICRPolySegApp = ICRPolySegApp || {};\n\nvar Module=typeof ICRPolySegApp!=\"undefined\"?ICRPolySegApp:{};var readyPromiseResolve,readyPromiseReject;Module[\"ready\"]=new Promise(function(resolve,reject){readyPromiseResolve=resolve;readyPromiseReject=reject});var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram=\"./this.program\";var quit_=(status,toThrow)=>{throw toThrow};var ENVIRONMENT_IS_WEB=true;var ENVIRONMENT_IS_WORKER=false;var scriptDirectory=\"\";function locateFile(path){if(Module[\"locateFile\"]){return Module[\"locateFile\"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle;if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!=\"undefined\"&&document.currentScript){scriptDirectory=document.currentScript.src}if(_scriptDir){scriptDirectory=_scriptDir}if(scriptDirectory.indexOf(\"blob:\")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1)}else{scriptDirectory=\"\"}{read_=url=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);xhr.responseType=\"arraybuffer\";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=(url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,true);xhr.responseType=\"arraybuffer\";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}setWindowTitle=title=>document.title=title}else{}var out=Module[\"print\"]||console.log.bind(console);var err=Module[\"printErr\"]||console.warn.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module[\"arguments\"])arguments_=Module[\"arguments\"];if(Module[\"thisProgram\"])thisProgram=Module[\"thisProgram\"];if(Module[\"quit\"])quit_=Module[\"quit\"];var POINTER_SIZE=4;var wasmBinary;if(Module[\"wasmBinary\"])wasmBinary=Module[\"wasmBinary\"];var noExitRuntime=Module[\"noExitRuntime\"]||true;if(typeof WebAssembly!=\"object\"){abort(\"no native wasm support detected\")}var wasmMemory;var ABORT=false;var EXITSTATUS;var UTF8Decoder=typeof TextDecoder!=\"undefined\"?new TextDecoder(\"utf8\"):undefined;function UTF8ArrayToString(heapOrArray,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}var str=\"\";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):\"\"}function stringToUTF8Array(str,heap,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}}heap[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferAndViews(buf){buffer=buf;Module[\"HEAP8\"]=HEAP8=new Int8Array(buf);Module[\"HEAP16\"]=HEAP16=new Int16Array(buf);Module[\"HEAP32\"]=HEAP32=new Int32Array(buf);Module[\"HEAPU8\"]=HEAPU8=new Uint8Array(buf);Module[\"HEAPU16\"]=HEAPU16=new Uint16Array(buf);Module[\"HEAPU32\"]=HEAPU32=new Uint32Array(buf);Module[\"HEAPF32\"]=HEAPF32=new Float32Array(buf);Module[\"HEAPF64\"]=HEAPF64=new Float64Array(buf)}var INITIAL_MEMORY=Module[\"INITIAL_MEMORY\"]||16777216;var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;function keepRuntimeAlive(){return noExitRuntime}function preRun(){if(Module[\"preRun\"]){if(typeof Module[\"preRun\"]==\"function\")Module[\"preRun\"]=[Module[\"preRun\"]];while(Module[\"preRun\"].length){addOnPreRun(Module[\"preRun\"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function postRun(){if(Module[\"postRun\"]){if(typeof Module[\"postRun\"]==\"function\")Module[\"postRun\"]=[Module[\"postRun\"]];while(Module[\"postRun\"].length){addOnPostRun(Module[\"postRun\"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module[\"monitorRunDependencies\"]){Module[\"monitorRunDependencies\"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module[\"monitorRunDependencies\"]){Module[\"monitorRunDependencies\"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}function abort(what){if(Module[\"onAbort\"]){Module[\"onAbort\"](what)}what=\"Aborted(\"+what+\")\";err(what);ABORT=true;EXITSTATUS=1;what+=\". Build with -sASSERTIONS for more info.\";var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}var dataURIPrefix=\"data:application/octet-stream;base64,\";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}var wasmBinaryFile;wasmBinaryFile=\"ICRPolySeg.wasm\";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinary(file){try{if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw\"both async and sync fetching of the wasm failed\"}catch(err){abort(err)}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch==\"function\"){return fetch(wasmBinaryFile,{credentials:\"same-origin\"}).then(function(response){if(!response[\"ok\"]){throw\"failed to load wasm binary file at '\"+wasmBinaryFile+\"'\"}return response[\"arrayBuffer\"]()}).catch(function(){return getBinary(wasmBinaryFile)})}}return Promise.resolve().then(function(){return getBinary(wasmBinaryFile)})}function createWasm(){var info={\"a\":asmLibraryArg};function receiveInstance(instance,module){var exports=instance.exports;Module[\"asm\"]=exports;wasmMemory=Module[\"asm\"][\"Q\"];updateGlobalBufferAndViews(wasmMemory.buffer);wasmTable=Module[\"asm\"][\"T\"];addOnInit(Module[\"asm\"][\"R\"]);removeRunDependency(\"wasm-instantiate\")}addRunDependency(\"wasm-instantiate\");function receiveInstantiationResult(result){receiveInstance(result[\"instance\"])}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){return WebAssembly.instantiate(binary,info)}).then(function(instance){return instance}).then(receiver,function(reason){err(\"failed to asynchronously prepare wasm: \"+reason);abort(reason)})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming==\"function\"&&!isDataURI(wasmBinaryFile)&&typeof fetch==\"function\"){return fetch(wasmBinaryFile,{credentials:\"same-origin\"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiationResult,function(reason){err(\"wasm streaming compile failed: \"+reason);err(\"falling back to ArrayBuffer instantiation\");return instantiateArrayBuffer(receiveInstantiationResult)})})}else{return instantiateArrayBuffer(receiveInstantiationResult)}}if(Module[\"instantiateWasm\"]){try{var exports=Module[\"instantiateWasm\"](info,receiveInstance);return exports}catch(e){err(\"Module.instantiateWasm callback failed with error: \"+e);readyPromiseReject(e)}}instantiateAsync().catch(readyPromiseReject);return{}}var ASM_CONSTS={638383:$0=>{if(Module.updateProgress){Module.updateProgress($0)}}};function ExitStatus(status){this.name=\"ExitStatus\";this.message=\"Program terminated with exit(\"+status+\")\";this.status=status}function callRuntimeCallbacks(callbacks){while(callbacks.length>0){callbacks.shift()(Module)}}function ExceptionInfo(excPtr){this.excPtr=excPtr;this.ptr=excPtr-24;this.set_type=function(type){HEAPU32[this.ptr+4>>2]=type};this.get_type=function(){return HEAPU32[this.ptr+4>>2]};this.set_destructor=function(destructor){HEAPU32[this.ptr+8>>2]=destructor};this.get_destructor=function(){return HEAPU32[this.ptr+8>>2]};this.set_refcount=function(refcount){HEAP32[this.ptr>>2]=refcount};this.set_caught=function(caught){caught=caught?1:0;HEAP8[this.ptr+12>>0]=caught};this.get_caught=function(){return HEAP8[this.ptr+12>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;HEAP8[this.ptr+13>>0]=rethrown};this.get_rethrown=function(){return HEAP8[this.ptr+13>>0]!=0};this.init=function(type,destructor){this.set_adjusted_ptr(0);this.set_type(type);this.set_destructor(destructor);this.set_refcount(0);this.set_caught(false);this.set_rethrown(false)};this.add_ref=function(){var value=HEAP32[this.ptr>>2];HEAP32[this.ptr>>2]=value+1};this.release_ref=function(){var prev=HEAP32[this.ptr>>2];HEAP32[this.ptr>>2]=prev-1;return prev===1};this.set_adjusted_ptr=function(adjustedPtr){HEAPU32[this.ptr+16>>2]=adjustedPtr};this.get_adjusted_ptr=function(){return HEAPU32[this.ptr+16>>2]};this.get_exception_ptr=function(){var isPointer=___cxa_is_pointer_type(this.get_type());if(isPointer){return HEAPU32[this.excPtr>>2]}var adjusted=this.get_adjusted_ptr();if(adjusted!==0)return adjusted;return this.excPtr}}var exceptionLast=0;var uncaughtExceptionCount=0;function ___cxa_throw(ptr,type,destructor){var info=new ExceptionInfo(ptr);info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw ptr}var SYSCALLS={varargs:undefined,get:function(){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr:function(ptr){var ret=UTF8ToString(ptr);return ret}};function ___syscall_getcwd(buf,size){}function ___syscall_getdents64(fd,dirp,count){}function ___syscall_openat(dirfd,path,flags,varargs){SYSCALLS.varargs=varargs}function ___syscall_readlinkat(dirfd,path,buf,bufsize){}function ___syscall_stat64(path,buf){}var structRegistrations={};function runDestructors(destructors){while(destructors.length){var ptr=destructors.pop();var del=destructors.pop();del(ptr)}}function simpleReadValueFromPointer(pointer){return this[\"fromWireType\"](HEAP32[pointer>>2])}var awaitingDependencies={};var registeredTypes={};var typeDependencies={};var char_0=48;var char_9=57;function makeLegalFunctionName(name){if(undefined===name){return\"_unknown\"}name=name.replace(/[^a-zA-Z0-9_]/g,\"$\");var f=name.charCodeAt(0);if(f>=char_0&&f<=char_9){return\"_\"+name}return name}function createNamedFunction(name,body){name=makeLegalFunctionName(name);return new Function(\"body\",\"return function \"+name+\"() {\\n\"+'    \"use strict\";'+\"    return body.apply(this, arguments);\\n\"+\"};\\n\")(body)}function extendError(baseErrorType,errorName){var errorClass=createNamedFunction(errorName,function(message){this.name=errorName;this.message=message;var stack=new Error(message).stack;if(stack!==undefined){this.stack=this.toString()+\"\\n\"+stack.replace(/^Error(:[^\\n]*)?\\n/,\"\")}});errorClass.prototype=Object.create(baseErrorType.prototype);errorClass.prototype.constructor=errorClass;errorClass.prototype.toString=function(){if(this.message===undefined){return this.name}else{return this.name+\": \"+this.message}};return errorClass}var InternalError=undefined;function throwInternalError(message){throw new InternalError(message)}function whenDependentTypesAreResolved(myTypes,dependentTypes,getTypeConverters){myTypes.forEach(function(type){typeDependencies[type]=dependentTypes});function onComplete(typeConverters){var myTypeConverters=getTypeConverters(typeConverters);if(myTypeConverters.length!==myTypes.length){throwInternalError(\"Mismatched type converter count\")}for(var i=0;i<myTypes.length;++i){registerType(myTypes[i],myTypeConverters[i])}}var typeConverters=new Array(dependentTypes.length);var unregisteredTypes=[];var registered=0;dependentTypes.forEach((dt,i)=>{if(registeredTypes.hasOwnProperty(dt)){typeConverters[i]=registeredTypes[dt]}else{unregisteredTypes.push(dt);if(!awaitingDependencies.hasOwnProperty(dt)){awaitingDependencies[dt]=[]}awaitingDependencies[dt].push(()=>{typeConverters[i]=registeredTypes[dt];++registered;if(registered===unregisteredTypes.length){onComplete(typeConverters)}})}});if(0===unregisteredTypes.length){onComplete(typeConverters)}}function __embind_finalize_value_object(structType){var reg=structRegistrations[structType];delete structRegistrations[structType];var rawConstructor=reg.rawConstructor;var rawDestructor=reg.rawDestructor;var fieldRecords=reg.fields;var fieldTypes=fieldRecords.map(field=>field.getterReturnType).concat(fieldRecords.map(field=>field.setterArgumentType));whenDependentTypesAreResolved([structType],fieldTypes,fieldTypes=>{var fields={};fieldRecords.forEach((field,i)=>{var fieldName=field.fieldName;var getterReturnType=fieldTypes[i];var getter=field.getter;var getterContext=field.getterContext;var setterArgumentType=fieldTypes[i+fieldRecords.length];var setter=field.setter;var setterContext=field.setterContext;fields[fieldName]={read:ptr=>{return getterReturnType[\"fromWireType\"](getter(getterContext,ptr))},write:(ptr,o)=>{var destructors=[];setter(setterContext,ptr,setterArgumentType[\"toWireType\"](destructors,o));runDestructors(destructors)}}});return[{name:reg.name,\"fromWireType\":function(ptr){var rv={};for(var i in fields){rv[i]=fields[i].read(ptr)}rawDestructor(ptr);return rv},\"toWireType\":function(destructors,o){for(var fieldName in fields){if(!(fieldName in o)){throw new TypeError('Missing field:  \"'+fieldName+'\"')}}var ptr=rawConstructor();for(fieldName in fields){fields[fieldName].write(ptr,o[fieldName])}if(destructors!==null){destructors.push(rawDestructor,ptr)}return ptr},\"argPackAdvance\":8,\"readValueFromPointer\":simpleReadValueFromPointer,destructorFunction:rawDestructor}]})}function __embind_register_bigint(primitiveType,name,size,minRange,maxRange){}function getShiftFromSize(size){switch(size){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError(\"Unknown type size: \"+size)}}function embind_init_charCodes(){var codes=new Array(256);for(var i=0;i<256;++i){codes[i]=String.fromCharCode(i)}embind_charCodes=codes}var embind_charCodes=undefined;function readLatin1String(ptr){var ret=\"\";var c=ptr;while(HEAPU8[c]){ret+=embind_charCodes[HEAPU8[c++]]}return ret}var BindingError=undefined;function throwBindingError(message){throw new BindingError(message)}function registerType(rawType,registeredInstance,options={}){if(!(\"argPackAdvance\"in registeredInstance)){throw new TypeError(\"registerType registeredInstance requires argPackAdvance\")}var name=registeredInstance.name;if(!rawType){throwBindingError('type \"'+name+'\" must have a positive integer typeid pointer')}if(registeredTypes.hasOwnProperty(rawType)){if(options.ignoreDuplicateRegistrations){return}else{throwBindingError(\"Cannot register type '\"+name+\"' twice\")}}registeredTypes[rawType]=registeredInstance;delete typeDependencies[rawType];if(awaitingDependencies.hasOwnProperty(rawType)){var callbacks=awaitingDependencies[rawType];delete awaitingDependencies[rawType];callbacks.forEach(cb=>cb())}}function __embind_register_bool(rawType,name,size,trueValue,falseValue){var shift=getShiftFromSize(size);name=readLatin1String(name);registerType(rawType,{name:name,\"fromWireType\":function(wt){return!!wt},\"toWireType\":function(destructors,o){return o?trueValue:falseValue},\"argPackAdvance\":8,\"readValueFromPointer\":function(pointer){var heap;if(size===1){heap=HEAP8}else if(size===2){heap=HEAP16}else if(size===4){heap=HEAP32}else{throw new TypeError(\"Unknown boolean type size: \"+name)}return this[\"fromWireType\"](heap[pointer>>shift])},destructorFunction:null})}var emval_free_list=[];var emval_handle_array=[{},{value:undefined},{value:null},{value:true},{value:false}];function __emval_decref(handle){if(handle>4&&0===--emval_handle_array[handle].refcount){emval_handle_array[handle]=undefined;emval_free_list.push(handle)}}function count_emval_handles(){var count=0;for(var i=5;i<emval_handle_array.length;++i){if(emval_handle_array[i]!==undefined){++count}}return count}function get_first_emval(){for(var i=5;i<emval_handle_array.length;++i){if(emval_handle_array[i]!==undefined){return emval_handle_array[i]}}return null}function init_emval(){Module[\"count_emval_handles\"]=count_emval_handles;Module[\"get_first_emval\"]=get_first_emval}var Emval={toValue:handle=>{if(!handle){throwBindingError(\"Cannot use deleted val. handle = \"+handle)}return emval_handle_array[handle].value},toHandle:value=>{switch(value){case undefined:return 1;case null:return 2;case true:return 3;case false:return 4;default:{var handle=emval_free_list.length?emval_free_list.pop():emval_handle_array.length;emval_handle_array[handle]={refcount:1,value:value};return handle}}}};function __embind_register_emval(rawType,name){name=readLatin1String(name);registerType(rawType,{name:name,\"fromWireType\":function(handle){var rv=Emval.toValue(handle);__emval_decref(handle);return rv},\"toWireType\":function(destructors,value){return Emval.toHandle(value)},\"argPackAdvance\":8,\"readValueFromPointer\":simpleReadValueFromPointer,destructorFunction:null})}function floatReadValueFromPointer(name,shift){switch(shift){case 2:return function(pointer){return this[\"fromWireType\"](HEAPF32[pointer>>2])};case 3:return function(pointer){return this[\"fromWireType\"](HEAPF64[pointer>>3])};default:throw new TypeError(\"Unknown float type: \"+name)}}function __embind_register_float(rawType,name,size){var shift=getShiftFromSize(size);name=readLatin1String(name);registerType(rawType,{name:name,\"fromWireType\":function(value){return value},\"toWireType\":function(destructors,value){return value},\"argPackAdvance\":8,\"readValueFromPointer\":floatReadValueFromPointer(name,shift),destructorFunction:null})}function new_(constructor,argumentList){if(!(constructor instanceof Function)){throw new TypeError(\"new_ called with constructor type \"+typeof constructor+\" which is not a function\")}var dummy=createNamedFunction(constructor.name||\"unknownFunctionName\",function(){});dummy.prototype=constructor.prototype;var obj=new dummy;var r=constructor.apply(obj,argumentList);return r instanceof Object?r:obj}function craftInvokerFunction(humanName,argTypes,classType,cppInvokerFunc,cppTargetFunc){var argCount=argTypes.length;if(argCount<2){throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\")}var isClassMethodFunc=argTypes[1]!==null&&classType!==null;var needsDestructorStack=false;for(var i=1;i<argTypes.length;++i){if(argTypes[i]!==null&&argTypes[i].destructorFunction===undefined){needsDestructorStack=true;break}}var returns=argTypes[0].name!==\"void\";var argsList=\"\";var argsListWired=\"\";for(var i=0;i<argCount-2;++i){argsList+=(i!==0?\", \":\"\")+\"arg\"+i;argsListWired+=(i!==0?\", \":\"\")+\"arg\"+i+\"Wired\"}var invokerFnBody=\"return function \"+makeLegalFunctionName(humanName)+\"(\"+argsList+\") {\\n\"+\"if (arguments.length !== \"+(argCount-2)+\") {\\n\"+\"throwBindingError('function \"+humanName+\" called with ' + arguments.length + ' arguments, expected \"+(argCount-2)+\" args!');\\n\"+\"}\\n\";if(needsDestructorStack){invokerFnBody+=\"var destructors = [];\\n\"}var dtorStack=needsDestructorStack?\"destructors\":\"null\";var args1=[\"throwBindingError\",\"invoker\",\"fn\",\"runDestructors\",\"retType\",\"classParam\"];var args2=[throwBindingError,cppInvokerFunc,cppTargetFunc,runDestructors,argTypes[0],argTypes[1]];if(isClassMethodFunc){invokerFnBody+=\"var thisWired = classParam.toWireType(\"+dtorStack+\", this);\\n\"}for(var i=0;i<argCount-2;++i){invokerFnBody+=\"var arg\"+i+\"Wired = argType\"+i+\".toWireType(\"+dtorStack+\", arg\"+i+\"); // \"+argTypes[i+2].name+\"\\n\";args1.push(\"argType\"+i);args2.push(argTypes[i+2])}if(isClassMethodFunc){argsListWired=\"thisWired\"+(argsListWired.length>0?\", \":\"\")+argsListWired}invokerFnBody+=(returns?\"var rv = \":\"\")+\"invoker(fn\"+(argsListWired.length>0?\", \":\"\")+argsListWired+\");\\n\";if(needsDestructorStack){invokerFnBody+=\"runDestructors(destructors);\\n\"}else{for(var i=isClassMethodFunc?1:2;i<argTypes.length;++i){var paramName=i===1?\"thisWired\":\"arg\"+(i-2)+\"Wired\";if(argTypes[i].destructorFunction!==null){invokerFnBody+=paramName+\"_dtor(\"+paramName+\"); // \"+argTypes[i].name+\"\\n\";args1.push(paramName+\"_dtor\");args2.push(argTypes[i].destructorFunction)}}}if(returns){invokerFnBody+=\"var ret = retType.fromWireType(rv);\\n\"+\"return ret;\\n\"}else{}invokerFnBody+=\"}\\n\";args1.push(invokerFnBody);var invokerFunction=new_(Function,args1).apply(null,args2);return invokerFunction}function ensureOverloadTable(proto,methodName,humanName){if(undefined===proto[methodName].overloadTable){var prevFunc=proto[methodName];proto[methodName]=function(){if(!proto[methodName].overloadTable.hasOwnProperty(arguments.length)){throwBindingError(\"Function '\"+humanName+\"' called with an invalid number of arguments (\"+arguments.length+\") - expects one of (\"+proto[methodName].overloadTable+\")!\")}return proto[methodName].overloadTable[arguments.length].apply(this,arguments)};proto[methodName].overloadTable=[];proto[methodName].overloadTable[prevFunc.argCount]=prevFunc}}function exposePublicSymbol(name,value,numArguments){if(Module.hasOwnProperty(name)){if(undefined===numArguments||undefined!==Module[name].overloadTable&&undefined!==Module[name].overloadTable[numArguments]){throwBindingError(\"Cannot register public name '\"+name+\"' twice\")}ensureOverloadTable(Module,name,name);if(Module.hasOwnProperty(numArguments)){throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\"+numArguments+\")!\")}Module[name].overloadTable[numArguments]=value}else{Module[name]=value;if(undefined!==numArguments){Module[name].numArguments=numArguments}}}function heap32VectorToArray(count,firstElement){var array=[];for(var i=0;i<count;i++){array.push(HEAPU32[firstElement+i*4>>2])}return array}function replacePublicSymbol(name,value,numArguments){if(!Module.hasOwnProperty(name)){throwInternalError(\"Replacing nonexistant public symbol\")}if(undefined!==Module[name].overloadTable&&undefined!==numArguments){Module[name].overloadTable[numArguments]=value}else{Module[name]=value;Module[name].argCount=numArguments}}function dynCallLegacy(sig,ptr,args){var f=Module[\"dynCall_\"+sig];return args&&args.length?f.apply(null,[ptr].concat(args)):f.call(null,ptr)}var wasmTableMirror=[];function getWasmTableEntry(funcPtr){var func=wasmTableMirror[funcPtr];if(!func){if(funcPtr>=wasmTableMirror.length)wasmTableMirror.length=funcPtr+1;wasmTableMirror[funcPtr]=func=wasmTable.get(funcPtr)}return func}function dynCall(sig,ptr,args){if(sig.includes(\"j\")){return dynCallLegacy(sig,ptr,args)}var rtn=getWasmTableEntry(ptr).apply(null,args);return rtn}function getDynCaller(sig,ptr){var argCache=[];return function(){argCache.length=0;Object.assign(argCache,arguments);return dynCall(sig,ptr,argCache)}}function embind__requireFunction(signature,rawFunction){signature=readLatin1String(signature);function makeDynCaller(){if(signature.includes(\"j\")){return getDynCaller(signature,rawFunction)}return getWasmTableEntry(rawFunction)}var fp=makeDynCaller();if(typeof fp!=\"function\"){throwBindingError(\"unknown function pointer with signature \"+signature+\": \"+rawFunction)}return fp}var UnboundTypeError=undefined;function getTypeName(type){var ptr=___getTypeName(type);var rv=readLatin1String(ptr);_free(ptr);return rv}function throwUnboundTypeError(message,types){var unboundTypes=[];var seen={};function visit(type){if(seen[type]){return}if(registeredTypes[type]){return}if(typeDependencies[type]){typeDependencies[type].forEach(visit);return}unboundTypes.push(type);seen[type]=true}types.forEach(visit);throw new UnboundTypeError(message+\": \"+unboundTypes.map(getTypeName).join([\", \"]))}function __embind_register_function(name,argCount,rawArgTypesAddr,signature,rawInvoker,fn){var argTypes=heap32VectorToArray(argCount,rawArgTypesAddr);name=readLatin1String(name);rawInvoker=embind__requireFunction(signature,rawInvoker);exposePublicSymbol(name,function(){throwUnboundTypeError(\"Cannot call \"+name+\" due to unbound types\",argTypes)},argCount-1);whenDependentTypesAreResolved([],argTypes,function(argTypes){var invokerArgsArray=[argTypes[0],null].concat(argTypes.slice(1));replacePublicSymbol(name,craftInvokerFunction(name,invokerArgsArray,null,rawInvoker,fn),argCount-1);return[]})}function integerReadValueFromPointer(name,shift,signed){switch(shift){case 0:return signed?function readS8FromPointer(pointer){return HEAP8[pointer]}:function readU8FromPointer(pointer){return HEAPU8[pointer]};case 1:return signed?function readS16FromPointer(pointer){return HEAP16[pointer>>1]}:function readU16FromPointer(pointer){return HEAPU16[pointer>>1]};case 2:return signed?function readS32FromPointer(pointer){return HEAP32[pointer>>2]}:function readU32FromPointer(pointer){return HEAPU32[pointer>>2]};default:throw new TypeError(\"Unknown integer type: \"+name)}}function __embind_register_integer(primitiveType,name,size,minRange,maxRange){name=readLatin1String(name);if(maxRange===-1){maxRange=4294967295}var shift=getShiftFromSize(size);var fromWireType=value=>value;if(minRange===0){var bitshift=32-8*size;fromWireType=value=>value<<bitshift>>>bitshift}var isUnsignedType=name.includes(\"unsigned\");var checkAssertions=(value,toTypeName)=>{};var toWireType;if(isUnsignedType){toWireType=function(destructors,value){checkAssertions(value,this.name);return value>>>0}}else{toWireType=function(destructors,value){checkAssertions(value,this.name);return value}}registerType(primitiveType,{name:name,\"fromWireType\":fromWireType,\"toWireType\":toWireType,\"argPackAdvance\":8,\"readValueFromPointer\":integerReadValueFromPointer(name,shift,minRange!==0),destructorFunction:null})}function __embind_register_memory_view(rawType,dataTypeIndex,name){var typeMapping=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];var TA=typeMapping[dataTypeIndex];function decodeMemoryView(handle){handle=handle>>2;var heap=HEAPU32;var size=heap[handle];var data=heap[handle+1];return new TA(buffer,data,size)}name=readLatin1String(name);registerType(rawType,{name:name,\"fromWireType\":decodeMemoryView,\"argPackAdvance\":8,\"readValueFromPointer\":decodeMemoryView},{ignoreDuplicateRegistrations:true})}function __embind_register_std_string(rawType,name){name=readLatin1String(name);var stdStringIsUTF8=name===\"std::string\";registerType(rawType,{name:name,\"fromWireType\":function(value){var length=HEAPU32[value>>2];var payload=value+4;var str;if(stdStringIsUTF8){var decodeStartPtr=payload;for(var i=0;i<=length;++i){var currentBytePtr=payload+i;if(i==length||HEAPU8[currentBytePtr]==0){var maxRead=currentBytePtr-decodeStartPtr;var stringSegment=UTF8ToString(decodeStartPtr,maxRead);if(str===undefined){str=stringSegment}else{str+=String.fromCharCode(0);str+=stringSegment}decodeStartPtr=currentBytePtr+1}}}else{var a=new Array(length);for(var i=0;i<length;++i){a[i]=String.fromCharCode(HEAPU8[payload+i])}str=a.join(\"\")}_free(value);return str},\"toWireType\":function(destructors,value){if(value instanceof ArrayBuffer){value=new Uint8Array(value)}var length;var valueIsOfTypeString=typeof value==\"string\";if(!(valueIsOfTypeString||value instanceof Uint8Array||value instanceof Uint8ClampedArray||value instanceof Int8Array)){throwBindingError(\"Cannot pass non-string to std::string\")}if(stdStringIsUTF8&&valueIsOfTypeString){length=lengthBytesUTF8(value)}else{length=value.length}var base=_malloc(4+length+1);var ptr=base+4;HEAPU32[base>>2]=length;if(stdStringIsUTF8&&valueIsOfTypeString){stringToUTF8(value,ptr,length+1)}else{if(valueIsOfTypeString){for(var i=0;i<length;++i){var charCode=value.charCodeAt(i);if(charCode>255){_free(ptr);throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\")}HEAPU8[ptr+i]=charCode}}else{for(var i=0;i<length;++i){HEAPU8[ptr+i]=value[i]}}}if(destructors!==null){destructors.push(_free,base)}return base},\"argPackAdvance\":8,\"readValueFromPointer\":simpleReadValueFromPointer,destructorFunction:function(ptr){_free(ptr)}})}var UTF16Decoder=typeof TextDecoder!=\"undefined\"?new TextDecoder(\"utf-16le\"):undefined;function UTF16ToString(ptr,maxBytesToRead){var endPtr=ptr;var idx=endPtr>>1;var maxIdx=idx+maxBytesToRead/2;while(!(idx>=maxIdx)&&HEAPU16[idx])++idx;endPtr=idx<<1;if(endPtr-ptr>32&&UTF16Decoder)return UTF16Decoder.decode(HEAPU8.subarray(ptr,endPtr));var str=\"\";for(var i=0;!(i>=maxBytesToRead/2);++i){var codeUnit=HEAP16[ptr+i*2>>1];if(codeUnit==0)break;str+=String.fromCharCode(codeUnit)}return str}function stringToUTF16(str,outPtr,maxBytesToWrite){if(maxBytesToWrite===undefined){maxBytesToWrite=2147483647}if(maxBytesToWrite<2)return 0;maxBytesToWrite-=2;var startPtr=outPtr;var numCharsToWrite=maxBytesToWrite<str.length*2?maxBytesToWrite/2:str.length;for(var i=0;i<numCharsToWrite;++i){var codeUnit=str.charCodeAt(i);HEAP16[outPtr>>1]=codeUnit;outPtr+=2}HEAP16[outPtr>>1]=0;return outPtr-startPtr}function lengthBytesUTF16(str){return str.length*2}function UTF32ToString(ptr,maxBytesToRead){var i=0;var str=\"\";while(!(i>=maxBytesToRead/4)){var utf32=HEAP32[ptr+i*4>>2];if(utf32==0)break;++i;if(utf32>=65536){var ch=utf32-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}else{str+=String.fromCharCode(utf32)}}return str}function stringToUTF32(str,outPtr,maxBytesToWrite){if(maxBytesToWrite===undefined){maxBytesToWrite=2147483647}if(maxBytesToWrite<4)return 0;var startPtr=outPtr;var endPtr=startPtr+maxBytesToWrite-4;for(var i=0;i<str.length;++i){var codeUnit=str.charCodeAt(i);if(codeUnit>=55296&&codeUnit<=57343){var trailSurrogate=str.charCodeAt(++i);codeUnit=65536+((codeUnit&1023)<<10)|trailSurrogate&1023}HEAP32[outPtr>>2]=codeUnit;outPtr+=4;if(outPtr+4>endPtr)break}HEAP32[outPtr>>2]=0;return outPtr-startPtr}function lengthBytesUTF32(str){var len=0;for(var i=0;i<str.length;++i){var codeUnit=str.charCodeAt(i);if(codeUnit>=55296&&codeUnit<=57343)++i;len+=4}return len}function __embind_register_std_wstring(rawType,charSize,name){name=readLatin1String(name);var decodeString,encodeString,getHeap,lengthBytesUTF,shift;if(charSize===2){decodeString=UTF16ToString;encodeString=stringToUTF16;lengthBytesUTF=lengthBytesUTF16;getHeap=()=>HEAPU16;shift=1}else if(charSize===4){decodeString=UTF32ToString;encodeString=stringToUTF32;lengthBytesUTF=lengthBytesUTF32;getHeap=()=>HEAPU32;shift=2}registerType(rawType,{name:name,\"fromWireType\":function(value){var length=HEAPU32[value>>2];var HEAP=getHeap();var str;var decodeStartPtr=value+4;for(var i=0;i<=length;++i){var currentBytePtr=value+4+i*charSize;if(i==length||HEAP[currentBytePtr>>shift]==0){var maxReadBytes=currentBytePtr-decodeStartPtr;var stringSegment=decodeString(decodeStartPtr,maxReadBytes);if(str===undefined){str=stringSegment}else{str+=String.fromCharCode(0);str+=stringSegment}decodeStartPtr=currentBytePtr+charSize}}_free(value);return str},\"toWireType\":function(destructors,value){if(!(typeof value==\"string\")){throwBindingError(\"Cannot pass non-string to C++ string type \"+name)}var length=lengthBytesUTF(value);var ptr=_malloc(4+length+charSize);HEAPU32[ptr>>2]=length>>shift;encodeString(value,ptr+4,length+charSize);if(destructors!==null){destructors.push(_free,ptr)}return ptr},\"argPackAdvance\":8,\"readValueFromPointer\":simpleReadValueFromPointer,destructorFunction:function(ptr){_free(ptr)}})}function __embind_register_value_object(rawType,name,constructorSignature,rawConstructor,destructorSignature,rawDestructor){structRegistrations[rawType]={name:readLatin1String(name),rawConstructor:embind__requireFunction(constructorSignature,rawConstructor),rawDestructor:embind__requireFunction(destructorSignature,rawDestructor),fields:[]}}function __embind_register_value_object_field(structType,fieldName,getterReturnType,getterSignature,getter,getterContext,setterArgumentType,setterSignature,setter,setterContext){structRegistrations[structType].fields.push({fieldName:readLatin1String(fieldName),getterReturnType:getterReturnType,getter:embind__requireFunction(getterSignature,getter),getterContext:getterContext,setterArgumentType:setterArgumentType,setter:embind__requireFunction(setterSignature,setter),setterContext:setterContext})}function __embind_register_void(rawType,name){name=readLatin1String(name);registerType(rawType,{isVoid:true,name:name,\"argPackAdvance\":0,\"fromWireType\":function(){return undefined},\"toWireType\":function(destructors,o){return undefined}})}function requireRegisteredType(rawType,humanName){var impl=registeredTypes[rawType];if(undefined===impl){throwBindingError(humanName+\" has unknown type \"+getTypeName(rawType))}return impl}function __emval_as(handle,returnType,destructorsRef){handle=Emval.toValue(handle);returnType=requireRegisteredType(returnType,\"emval::as\");var destructors=[];var rd=Emval.toHandle(destructors);HEAPU32[destructorsRef>>2]=rd;return returnType[\"toWireType\"](destructors,handle)}var emval_symbols={};function getStringOrSymbol(address){var symbol=emval_symbols[address];if(symbol===undefined){return readLatin1String(address)}return symbol}var emval_methodCallers=[];function __emval_call_void_method(caller,handle,methodName,args){caller=emval_methodCallers[caller];handle=Emval.toValue(handle);methodName=getStringOrSymbol(methodName);caller(handle,methodName,null,args)}function emval_get_global(){if(typeof globalThis==\"object\"){return globalThis}return function(){return Function}()(\"return this\")()}function __emval_get_global(name){if(name===0){return Emval.toHandle(emval_get_global())}else{name=getStringOrSymbol(name);return Emval.toHandle(emval_get_global()[name])}}function emval_addMethodCaller(caller){var id=emval_methodCallers.length;emval_methodCallers.push(caller);return id}function emval_lookupTypes(argCount,argTypes){var a=new Array(argCount);for(var i=0;i<argCount;++i){a[i]=requireRegisteredType(HEAPU32[argTypes+i*POINTER_SIZE>>2],\"parameter \"+i)}return a}var emval_registeredMethods=[];function __emval_get_method_caller(argCount,argTypes){var types=emval_lookupTypes(argCount,argTypes);var retType=types[0];var signatureName=retType.name+\"_$\"+types.slice(1).map(function(t){return t.name}).join(\"_\")+\"$\";var returnId=emval_registeredMethods[signatureName];if(returnId!==undefined){return returnId}var params=[\"retType\"];var args=[retType];var argsList=\"\";for(var i=0;i<argCount-1;++i){argsList+=(i!==0?\", \":\"\")+\"arg\"+i;params.push(\"argType\"+i);args.push(types[1+i])}var functionName=makeLegalFunctionName(\"methodCaller_\"+signatureName);var functionBody=\"return function \"+functionName+\"(handle, name, destructors, args) {\\n\";var offset=0;for(var i=0;i<argCount-1;++i){functionBody+=\"    var arg\"+i+\" = argType\"+i+\".readValueFromPointer(args\"+(offset?\"+\"+offset:\"\")+\");\\n\";offset+=types[i+1][\"argPackAdvance\"]}functionBody+=\"    var rv = handle[name](\"+argsList+\");\\n\";for(var i=0;i<argCount-1;++i){if(types[i+1][\"deleteObject\"]){functionBody+=\"    argType\"+i+\".deleteObject(arg\"+i+\");\\n\"}}if(!retType.isVoid){functionBody+=\"    return retType.toWireType(destructors, rv);\\n\"}functionBody+=\"};\\n\";params.push(functionBody);var invokerFunction=new_(Function,params).apply(null,args);returnId=emval_addMethodCaller(invokerFunction);emval_registeredMethods[signatureName]=returnId;return returnId}function __emval_get_property(handle,key){handle=Emval.toValue(handle);key=Emval.toValue(key);return Emval.toHandle(handle[key])}function __emval_incref(handle){if(handle>4){emval_handle_array[handle].refcount+=1}}function craftEmvalAllocator(argCount){var argsList=\"\";for(var i=0;i<argCount;++i){argsList+=(i!==0?\", \":\"\")+\"arg\"+i}var getMemory=()=>HEAPU32;var functionBody=\"return function emval_allocator_\"+argCount+\"(constructor, argTypes, args) {\\n\"+\"  var HEAPU32 = getMemory();\\n\";for(var i=0;i<argCount;++i){functionBody+=\"var argType\"+i+\" = requireRegisteredType(HEAPU32[((argTypes)>>2)], 'parameter \"+i+\"');\\n\"+\"var arg\"+i+\" = argType\"+i+\".readValueFromPointer(args);\\n\"+\"args += argType\"+i+\"['argPackAdvance'];\\n\"+\"argTypes += 4;\\n\"}functionBody+=\"var obj = new constructor(\"+argsList+\");\\n\"+\"return valueToHandle(obj);\\n\"+\"}\\n\";return new Function(\"requireRegisteredType\",\"Module\",\"valueToHandle\",\"getMemory\",functionBody)(requireRegisteredType,Module,Emval.toHandle,getMemory)}var emval_newers={};function __emval_new(handle,argCount,argTypes,args){handle=Emval.toValue(handle);var newer=emval_newers[argCount];if(!newer){newer=craftEmvalAllocator(argCount);emval_newers[argCount]=newer}return newer(handle,argTypes,args)}function __emval_new_cstring(v){return Emval.toHandle(getStringOrSymbol(v))}function __emval_run_destructors(handle){var destructors=Emval.toValue(handle);runDestructors(destructors);__emval_decref(handle)}function __emval_take_value(type,arg){type=requireRegisteredType(type,\"_emval_take_value\");var v=type[\"readValueFromPointer\"](arg);return Emval.toHandle(v)}function _abort(){abort(\"\")}var readEmAsmArgsArray=[];function readEmAsmArgs(sigPtr,buf){readEmAsmArgsArray.length=0;var ch;buf>>=2;while(ch=HEAPU8[sigPtr++]){buf+=ch!=105&buf;readEmAsmArgsArray.push(ch==105?HEAP32[buf]:HEAPF64[buf++>>1]);++buf}return readEmAsmArgsArray}function runEmAsmFunction(code,sigPtr,argbuf){var args=readEmAsmArgs(sigPtr,argbuf);return ASM_CONSTS[code].apply(null,args)}function _emscripten_asm_const_int(code,sigPtr,argbuf){return runEmAsmFunction(code,sigPtr,argbuf)}function getHeapMax(){return 2147483648}function _emscripten_get_heap_max(){return getHeapMax()}function _emscripten_memcpy_big(dest,src,num){HEAPU8.copyWithin(dest,src,src+num)}function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=HEAPU8.length;requestedSize=requestedSize>>>0;var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}let alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=emscripten_realloc_buffer(newSize);if(replacement){return true}}return false}var ENV={};function getExecutableName(){return thisProgram||\"./this.program\"}function getEnvStrings(){if(!getEnvStrings.strings){var lang=(typeof navigator==\"object\"&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\";var env={\"USER\":\"web_user\",\"LOGNAME\":\"web_user\",\"PATH\":\"/\",\"PWD\":\"/\",\"HOME\":\"/home/web_user\",\"LANG\":lang,\"_\":getExecutableName()};for(var x in ENV){if(ENV[x]===undefined)delete env[x];else env[x]=ENV[x]}var strings=[];for(var x in env){strings.push(x+\"=\"+env[x])}getEnvStrings.strings=strings}return getEnvStrings.strings}function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i)}if(!dontAddNull)HEAP8[buffer>>0]=0}function _environ_get(__environ,environ_buf){var bufSize=0;getEnvStrings().forEach(function(string,i){var ptr=environ_buf+bufSize;HEAPU32[__environ+i*4>>2]=ptr;writeAsciiToMemory(string,ptr);bufSize+=string.length+1});return 0}function _environ_sizes_get(penviron_count,penviron_buf_size){var strings=getEnvStrings();HEAPU32[penviron_count>>2]=strings.length;var bufSize=0;strings.forEach(function(string){bufSize+=string.length+1});HEAPU32[penviron_buf_size>>2]=bufSize;return 0}function _fd_close(fd){return 52}function _fd_read(fd,iov,iovcnt,pnum){return 52}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){return 70}var printCharBuffers=[null,[],[]];function printChar(stream,curr){var buffer=printCharBuffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}}function _fd_write(fd,iov,iovcnt,pnum){var num=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;for(var j=0;j<len;j++){printChar(fd,HEAPU8[ptr+j])}num+=len}HEAPU32[pnum>>2]=num;return 0}function __isLeapYear(year){return year%4===0&&(year%100!==0||year%400===0)}function __arraySum(array,index){var sum=0;for(var i=0;i<=index;sum+=array[i++]){}return sum}var __MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];var __MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];function __addDays(date,days){var newDate=new Date(date.getTime());while(days>0){var leap=__isLeapYear(newDate.getFullYear());var currentMonth=newDate.getMonth();var daysInCurrentMonth=(leap?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR)[currentMonth];if(days>daysInCurrentMonth-newDate.getDate()){days-=daysInCurrentMonth-newDate.getDate()+1;newDate.setDate(1);if(currentMonth<11){newDate.setMonth(currentMonth+1)}else{newDate.setMonth(0);newDate.setFullYear(newDate.getFullYear()+1)}}else{newDate.setDate(newDate.getDate()+days);return newDate}}return newDate}function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}function writeArrayToMemory(array,buffer){HEAP8.set(array,buffer)}function _strftime(s,maxsize,format,tm){var tm_zone=HEAP32[tm+40>>2];var date={tm_sec:HEAP32[tm>>2],tm_min:HEAP32[tm+4>>2],tm_hour:HEAP32[tm+8>>2],tm_mday:HEAP32[tm+12>>2],tm_mon:HEAP32[tm+16>>2],tm_year:HEAP32[tm+20>>2],tm_wday:HEAP32[tm+24>>2],tm_yday:HEAP32[tm+28>>2],tm_isdst:HEAP32[tm+32>>2],tm_gmtoff:HEAP32[tm+36>>2],tm_zone:tm_zone?UTF8ToString(tm_zone):\"\"};var pattern=UTF8ToString(format);var EXPANSION_RULES_1={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"};for(var rule in EXPANSION_RULES_1){pattern=pattern.replace(new RegExp(rule,\"g\"),EXPANSION_RULES_1[rule])}var WEEKDAYS=[\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"];var MONTHS=[\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"];function leadingSomething(value,digits,character){var str=typeof value==\"number\"?value.toString():value||\"\";while(str.length<digits){str=character[0]+str}return str}function leadingNulls(value,digits){return leadingSomething(value,digits,\"0\")}function compareByDay(date1,date2){function sgn(value){return value<0?-1:value>0?1:0}var compare;if((compare=sgn(date1.getFullYear()-date2.getFullYear()))===0){if((compare=sgn(date1.getMonth()-date2.getMonth()))===0){compare=sgn(date1.getDate()-date2.getDate())}}return compare}function getFirstWeekStartDate(janFourth){switch(janFourth.getDay()){case 0:return new Date(janFourth.getFullYear()-1,11,29);case 1:return janFourth;case 2:return new Date(janFourth.getFullYear(),0,3);case 3:return new Date(janFourth.getFullYear(),0,2);case 4:return new Date(janFourth.getFullYear(),0,1);case 5:return new Date(janFourth.getFullYear()-1,11,31);case 6:return new Date(janFourth.getFullYear()-1,11,30)}}function getWeekBasedYear(date){var thisDate=__addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);var janFourthThisYear=new Date(thisDate.getFullYear(),0,4);var janFourthNextYear=new Date(thisDate.getFullYear()+1,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);if(compareByDay(firstWeekStartThisYear,thisDate)<=0){if(compareByDay(firstWeekStartNextYear,thisDate)<=0){return thisDate.getFullYear()+1}return thisDate.getFullYear()}return thisDate.getFullYear()-1}var EXPANSION_RULES_2={\"%a\":function(date){return WEEKDAYS[date.tm_wday].substring(0,3)},\"%A\":function(date){return WEEKDAYS[date.tm_wday]},\"%b\":function(date){return MONTHS[date.tm_mon].substring(0,3)},\"%B\":function(date){return MONTHS[date.tm_mon]},\"%C\":function(date){var year=date.tm_year+1900;return leadingNulls(year/100|0,2)},\"%d\":function(date){return leadingNulls(date.tm_mday,2)},\"%e\":function(date){return leadingSomething(date.tm_mday,2,\" \")},\"%g\":function(date){return getWeekBasedYear(date).toString().substring(2)},\"%G\":function(date){return getWeekBasedYear(date)},\"%H\":function(date){return leadingNulls(date.tm_hour,2)},\"%I\":function(date){var twelveHour=date.tm_hour;if(twelveHour==0)twelveHour=12;else if(twelveHour>12)twelveHour-=12;return leadingNulls(twelveHour,2)},\"%j\":function(date){return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900)?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,date.tm_mon-1),3)},\"%m\":function(date){return leadingNulls(date.tm_mon+1,2)},\"%M\":function(date){return leadingNulls(date.tm_min,2)},\"%n\":function(){return\"\\n\"},\"%p\":function(date){if(date.tm_hour>=0&&date.tm_hour<12){return\"AM\"}return\"PM\"},\"%S\":function(date){return leadingNulls(date.tm_sec,2)},\"%t\":function(){return\"\\t\"},\"%u\":function(date){return date.tm_wday||7},\"%U\":function(date){var days=date.tm_yday+7-date.tm_wday;return leadingNulls(Math.floor(days/7),2)},\"%V\":function(date){var val=Math.floor((date.tm_yday+7-(date.tm_wday+6)%7)/7);if((date.tm_wday+371-date.tm_yday-2)%7<=2){val++}if(!val){val=52;var dec31=(date.tm_wday+7-date.tm_yday-1)%7;if(dec31==4||dec31==5&&__isLeapYear(date.tm_year%400-1)){val++}}else if(val==53){var jan1=(date.tm_wday+371-date.tm_yday)%7;if(jan1!=4&&(jan1!=3||!__isLeapYear(date.tm_year)))val=1}return leadingNulls(val,2)},\"%w\":function(date){return date.tm_wday},\"%W\":function(date){var days=date.tm_yday+7-(date.tm_wday+6)%7;return leadingNulls(Math.floor(days/7),2)},\"%y\":function(date){return(date.tm_year+1900).toString().substring(2)},\"%Y\":function(date){return date.tm_year+1900},\"%z\":function(date){var off=date.tm_gmtoff;var ahead=off>=0;off=Math.abs(off)/60;off=off/60*100+off%60;return(ahead?\"+\":\"-\")+String(\"0000\"+off).slice(-4)},\"%Z\":function(date){return date.tm_zone},\"%%\":function(){return\"%\"}};pattern=pattern.replace(/%%/g,\"\\0\\0\");for(var rule in EXPANSION_RULES_2){if(pattern.includes(rule)){pattern=pattern.replace(new RegExp(rule,\"g\"),EXPANSION_RULES_2[rule](date))}}pattern=pattern.replace(/\\0\\0/g,\"%\");var bytes=intArrayFromString(pattern,false);if(bytes.length>maxsize){return 0}writeArrayToMemory(bytes,s);return bytes.length-1}function _strftime_l(s,maxsize,format,tm,loc){return _strftime(s,maxsize,format,tm)}function _proc_exit(code){EXITSTATUS=code;if(!keepRuntimeAlive()){if(Module[\"onExit\"])Module[\"onExit\"](code);ABORT=true}quit_(code,new ExitStatus(code))}function exitJS(status,implicit){EXITSTATUS=status;_proc_exit(status)}function handleException(e){if(e instanceof ExitStatus||e==\"unwind\"){return EXITSTATUS}quit_(1,e)}InternalError=Module[\"InternalError\"]=extendError(Error,\"InternalError\");embind_init_charCodes();BindingError=Module[\"BindingError\"]=extendError(Error,\"BindingError\");init_emval();UnboundTypeError=Module[\"UnboundTypeError\"]=extendError(Error,\"UnboundTypeError\");var asmLibraryArg={\"b\":___cxa_throw,\"J\":___syscall_getcwd,\"F\":___syscall_getdents64,\"L\":___syscall_openat,\"E\":___syscall_readlinkat,\"G\":___syscall_stat64,\"x\":__embind_finalize_value_object,\"A\":__embind_register_bigint,\"O\":__embind_register_bool,\"N\":__embind_register_emval,\"v\":__embind_register_float,\"g\":__embind_register_function,\"d\":__embind_register_integer,\"c\":__embind_register_memory_view,\"u\":__embind_register_std_string,\"m\":__embind_register_std_wstring,\"y\":__embind_register_value_object,\"e\":__embind_register_value_object_field,\"P\":__embind_register_void,\"r\":__emval_as,\"i\":__emval_call_void_method,\"a\":__emval_decref,\"p\":__emval_get_global,\"j\":__emval_get_method_caller,\"s\":__emval_get_property,\"f\":__emval_incref,\"o\":__emval_new,\"w\":__emval_new_cstring,\"q\":__emval_run_destructors,\"k\":__emval_take_value,\"n\":_abort,\"h\":_emscripten_asm_const_int,\"D\":_emscripten_get_heap_max,\"M\":_emscripten_memcpy_big,\"C\":_emscripten_resize_heap,\"H\":_environ_get,\"I\":_environ_sizes_get,\"l\":_fd_close,\"K\":_fd_read,\"z\":_fd_seek,\"t\":_fd_write,\"B\":_strftime_l};var asm=createWasm();var ___wasm_call_ctors=Module[\"___wasm_call_ctors\"]=function(){return(___wasm_call_ctors=Module[\"___wasm_call_ctors\"]=Module[\"asm\"][\"R\"]).apply(null,arguments)};var _main=Module[\"_main\"]=function(){return(_main=Module[\"_main\"]=Module[\"asm\"][\"S\"]).apply(null,arguments)};var _malloc=Module[\"_malloc\"]=function(){return(_malloc=Module[\"_malloc\"]=Module[\"asm\"][\"U\"]).apply(null,arguments)};var _free=Module[\"_free\"]=function(){return(_free=Module[\"_free\"]=Module[\"asm\"][\"V\"]).apply(null,arguments)};var ___getTypeName=Module[\"___getTypeName\"]=function(){return(___getTypeName=Module[\"___getTypeName\"]=Module[\"asm\"][\"W\"]).apply(null,arguments)};var __embind_initialize_bindings=Module[\"__embind_initialize_bindings\"]=function(){return(__embind_initialize_bindings=Module[\"__embind_initialize_bindings\"]=Module[\"asm\"][\"X\"]).apply(null,arguments)};var ___cxa_is_pointer_type=Module[\"___cxa_is_pointer_type\"]=function(){return(___cxa_is_pointer_type=Module[\"___cxa_is_pointer_type\"]=Module[\"asm\"][\"Y\"]).apply(null,arguments)};var dynCall_viij=Module[\"dynCall_viij\"]=function(){return(dynCall_viij=Module[\"dynCall_viij\"]=Module[\"asm\"][\"Z\"]).apply(null,arguments)};var dynCall_vij=Module[\"dynCall_vij\"]=function(){return(dynCall_vij=Module[\"dynCall_vij\"]=Module[\"asm\"][\"_\"]).apply(null,arguments)};var dynCall_iij=Module[\"dynCall_iij\"]=function(){return(dynCall_iij=Module[\"dynCall_iij\"]=Module[\"asm\"][\"$\"]).apply(null,arguments)};var dynCall_viji=Module[\"dynCall_viji\"]=function(){return(dynCall_viji=Module[\"dynCall_viji\"]=Module[\"asm\"][\"aa\"]).apply(null,arguments)};var dynCall_jiji=Module[\"dynCall_jiji\"]=function(){return(dynCall_jiji=Module[\"dynCall_jiji\"]=Module[\"asm\"][\"ba\"]).apply(null,arguments)};var dynCall_viijii=Module[\"dynCall_viijii\"]=function(){return(dynCall_viijii=Module[\"dynCall_viijii\"]=Module[\"asm\"][\"ca\"]).apply(null,arguments)};var dynCall_iiiiij=Module[\"dynCall_iiiiij\"]=function(){return(dynCall_iiiiij=Module[\"dynCall_iiiiij\"]=Module[\"asm\"][\"da\"]).apply(null,arguments)};var dynCall_iiiiijj=Module[\"dynCall_iiiiijj\"]=function(){return(dynCall_iiiiijj=Module[\"dynCall_iiiiijj\"]=Module[\"asm\"][\"ea\"]).apply(null,arguments)};var dynCall_iiiiiijj=Module[\"dynCall_iiiiiijj\"]=function(){return(dynCall_iiiiiijj=Module[\"dynCall_iiiiiijj\"]=Module[\"asm\"][\"fa\"]).apply(null,arguments)};var ___start_em_js=Module[\"___start_em_js\"]=638316;var ___stop_em_js=Module[\"___stop_em_js\"]=638383;var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function callMain(args){var entryFunction=Module[\"_main\"];var argc=0;var argv=0;try{var ret=entryFunction(argc,argv);exitJS(ret,true);return ret}catch(e){return handleException(e)}}function run(args){args=args||arguments_;if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module[\"calledRun\"]=true;if(ABORT)return;initRuntime();preMain();readyPromiseResolve(Module);if(Module[\"onRuntimeInitialized\"])Module[\"onRuntimeInitialized\"]();if(shouldRunNow)callMain(args);postRun()}if(Module[\"setStatus\"]){Module[\"setStatus\"](\"Running...\");setTimeout(function(){setTimeout(function(){Module[\"setStatus\"](\"\")},1);doRun()},1)}else{doRun()}}if(Module[\"preInit\"]){if(typeof Module[\"preInit\"]==\"function\")Module[\"preInit\"]=[Module[\"preInit\"]];while(Module[\"preInit\"].length>0){Module[\"preInit\"].pop()()}}var shouldRunNow=true;if(Module[\"noInitialRun\"])shouldRunNow=false;run();\n\n\n  return ICRPolySegApp.ready\n}\n);\n})();\nexport default ICRPolySegApp;","import launcher from './ICRPolySeg.js';\r\nimport wasm from './ICRPolySeg.wasm';\r\n\r\nexport default class ICRPolySeg {\r\n  constructor() {\r\n    this._instance;\r\n  }\r\n\r\n  get instance() {\r\n    if (this._instance) {\r\n      return this._instance;\r\n    }\r\n\r\n    throw new Error('ICRPolySeg is not initialized.');\r\n  }\r\n\r\n  async initialize(params = {}) {\r\n    this._instance = await launcher({\r\n      locateFile: (f) => {\r\n        if (f.endsWith('.wasm')) {\r\n          return wasm;\r\n        }\r\n        return f;\r\n      },\r\n      ...params\r\n    });\r\n  }\r\n}\r\n","import { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\n\nconst Dir = {\n  Forward: 1,\n  Backward: -1\n};\nconst visited = new Set();\nfunction vtkContourLoopExtraction(publicAPI, model) {\n  publicAPI.requestData = (inData, outData) => {\n    const [input] = inData;\n    if (!outData[0]) {\n      outData[0] = vtkPolyData.newInstance();\n    }\n    const [output] = outData;\n    publicAPI.extractContours(input, output);\n    output.modified();\n  };\n  publicAPI.traverseLoop = (pd, dir, startLineId, startPtId, loopPoints) => {\n    let lineId = startLineId;\n    let lastPtId = startPtId;\n    let terminated = false;\n    let numInserted = 0;\n    while (!terminated) {\n      const {\n        cellPointIds\n      } = pd.getCellPoints(lineId);\n      if (!cellPointIds) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      lastPtId = cellPointIds[0] !== lastPtId ? cellPointIds[0] : cellPointIds[1];\n      numInserted++;\n\n      // parametric point value\n      const t = dir * numInserted;\n      loopPoints.push({\n        t,\n        ptId: lastPtId\n      });\n      const lineCell = pd.getPointCells(lastPtId);\n      if (lineCell.length !== 2 || lastPtId === startPtId) {\n        // looped\n        return lastPtId;\n      }\n      if (lineCell.length === 2) {\n        // continue along loop\n        lineId = lineCell[0] !== lineId ? lineCell[0] : lineCell[1];\n        visited.add(lineId);\n      } else {\n        // empty or invalid cell\n        terminated = true;\n      }\n    }\n    return lastPtId;\n  };\n  publicAPI.extractContours = (input, output) => {\n    const loops = [];\n    visited.clear();\n    const inLines = input.getLines();\n    output.getPoints().setData(Float32Array.from(input.getPoints().getData()));\n\n    // TODO skip if cached input mtime hasn't changed.\n    // iterate over input lines\n    for (let li = 0; li < inLines.getNumberOfCells(); li++) {\n      if (visited.has(li)) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      const {\n        cellPointIds\n      } = input.getCellPoints(li);\n      if (!cellPointIds) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      visited.add(li);\n      const startPtId = cellPointIds[0];\n      const loopPoints = [];\n      loopPoints.push({\n        t: 0,\n        ptId: startPtId\n      });\n      const endPtId = publicAPI.traverseLoop(input, Dir.Forward, li, startPtId, loopPoints);\n      if (startPtId !== endPtId) {\n        // didn't find a loop. Go other direction to see where we end up\n        publicAPI.traverseLoop(input, Dir.Backward, li, startPtId, loopPoints);\n        loopPoints.sort((a, b) => a.t < b.t ? -1 : 1);\n        // make closed contour\n        if (loopPoints.length && loopPoints[0].ptId !== loopPoints[loopPoints.length - 1]?.ptId) {\n          loopPoints.push({\n            ...loopPoints[loopPoints.length - 1]\n          });\n        }\n      }\n      if (loopPoints.length) {\n        loops.push(loopPoints);\n      }\n    }\n\n    // clear output lines\n    const outLines = output.getLines();\n    outLines.resize(0);\n    loops.forEach(loop => {\n      outLines.insertNextCell(loop.map(pt => pt.ptId));\n    });\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  macro.algo(publicAPI, model, 1, 1);\n  vtkContourLoopExtraction(publicAPI);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkContourLoopExtraction');\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\nexport { index as default, extend, newInstance };\n","import { expose } from 'comlink';\r\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\r\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\r\nimport ICRPolySeg from '@icr/polyseg-wasm';\r\nimport { utilities } from '@cornerstonejs/core';\r\nimport vtkPlane from '@kitware/vtk.js/Common/DataModel/Plane';\r\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\r\nimport vtkContourLoopExtraction from '@kitware/vtk.js/Filters/General/ContourLoopExtraction';\r\nimport vtkCutter from '@kitware/vtk.js/Filters/Core/Cutter';\r\n\r\nimport { getBoundingBoxAroundShapeWorld } from '../utilities/boundingBox';\r\nimport { pointInShapeCallback } from '../utilities';\r\nimport {\r\n  containsPoint,\r\n  getAABB,\r\n  projectTo2D,\r\n} from '../utilities/math/polyline';\r\nimport { isPlaneIntersectingAABB } from '../utilities/planar';\r\n\r\n/**\r\n * Object containing methods for converting between different representations of\r\n * segmentations (e.g., contour, labelmap, surface, etc.) These logics\r\n * are used in a webworker to avoid blocking the main thread. You can\r\n * search for workerManager.executeTask('polySeg', ...) to see\r\n * how these methods are used.\r\n *\r\n * See also the webworker docs at packages/docs/docs/concepts/cornerstone-core/web-worker.md\r\n * to learn more about how to use webworkers in the context of Cornerstone.\r\n */\r\nconst polySegConverters = {\r\n  /**\r\n   * The polySeg instance that is used to convert between different representations\r\n   */\r\n  polySeg: null,\r\n  /**\r\n   * Utilities to keep track of the initialization state of the polySeg instance\r\n   * and avoid initializing it multiple times\r\n   */\r\n  polySegInitializing: false,\r\n  polySegInitializingPromise: null,\r\n  /**\r\n   * This method initializes the polySeg instance and sets it to this.polySeg\r\n   */\r\n  async initializePolySeg(progressCallback) {\r\n    if (this.polySegInitializing) {\r\n      await this.polySegInitializingPromise;\r\n      return;\r\n    }\r\n\r\n    if (this.polySeg?.instance) {\r\n      return;\r\n    }\r\n\r\n    this.polySegInitializing = true;\r\n    this.polySegInitializingPromise = new Promise((resolve) => {\r\n      this.polySeg = new ICRPolySeg();\r\n      this.polySeg\r\n        .initialize({\r\n          updateProgress: progressCallback,\r\n        })\r\n        .then(() => {\r\n          this.polySegInitializing = false;\r\n          resolve();\r\n        });\r\n    });\r\n\r\n    await this.polySegInitializingPromise;\r\n  },\r\n  /**\r\n   * Converts a contour to a surface using the PolySeg library.\r\n   * @param {Object} args - The arguments for the conversion.\r\n   * @param {Array} args.polylines - The polylines representing the contour.\r\n   * @param {Array} args.numPointsArray - The number of points in each polyline.\r\n   * @param {...Function} callbacks - Optional callback functions.\r\n   * @returns {Promise} - A promise that resolves to the converted surface.\r\n   */\r\n  async convertContourToSurface(args, ...callbacks) {\r\n    const { polylines, numPointsArray } = args;\r\n    const [progressCallback] = callbacks;\r\n    await this.initializePolySeg(progressCallback);\r\n    const results = await this.polySeg.instance.convertContourRoiToSurface(\r\n      polylines,\r\n      numPointsArray\r\n    );\r\n\r\n    return results;\r\n  },\r\n  /**\r\n   * Converts a labelmap to a surface using the specified arguments.\r\n   * @param {Object} args - The arguments for the conversion.\r\n   * @param {Array} args.scalarData - The scalar data of the labelmap.\r\n   * @param {Array} args.dimensions - The dimensions of the labelmap.\r\n   * @param {Array} args.spacing - The spacing of the labelmap.\r\n   * @param {Array} args.direction - The direction of the labelmap.\r\n   * @param {Array} args.origin - The origin of the labelmap.\r\n   * @param {number} args.segmentIndex - The segment index of the labelmap.\r\n   * @param {Function} progressCallback - The callback function for progress updates.\r\n   * @returns {Promise} - A promise that resolves with the converted surface results.\r\n   */\r\n  async convertLabelmapToSurface(args, ...callbacks) {\r\n    const [progressCallback] = callbacks;\r\n    await this.initializePolySeg(progressCallback);\r\n\r\n    const results = this.polySeg.instance.convertLabelmapToSurface(\r\n      args.scalarData,\r\n      args.dimensions,\r\n      args.spacing,\r\n      args.direction,\r\n      args.origin,\r\n      [args.segmentIndex]\r\n    );\r\n    return results;\r\n  },\r\n  /**\r\n   * Converts a contour to a volume labelmap.\r\n   * @param {Object} args - The arguments for the conversion.\r\n   * @param {Array} args.segmentIndices - The indices of the segments.\r\n   * @param {Array} args.scalarData - The scalar data.\r\n   * @param {Map} args.annotationUIDsInSegmentMap - The map of annotation UIDs in segment.\r\n   * @param {Array} args.dimensions - The dimensions of the image data.\r\n   * @param {Array} args.origin - The origin of the image data.\r\n   * @param {Array} args.direction - The direction of the image data.\r\n   * @param {Array} args.spacing - The spacing of the image data.\r\n   * @param {...Function} callbacks - Optional callbacks.\r\n   * @param {Function} callbacks[0] - The progress callback.\r\n   * @returns {Array} - The scalar data of the segmentation voxel manager.\r\n   */\r\n  async convertContourToVolumeLabelmap(args, ...callbacks) {\r\n    const [progressCallback] = callbacks;\r\n    const polySeg = await new ICRPolySeg();\r\n    await polySeg.initialize({\r\n      updateProgress: progressCallback,\r\n    });\r\n\r\n    const {\r\n      segmentIndices,\r\n      scalarData,\r\n      annotationUIDsInSegmentMap,\r\n      dimensions,\r\n      origin,\r\n      direction,\r\n      spacing,\r\n    } = args;\r\n\r\n    const segmentationVoxelManager =\r\n      utilities.VoxelManager.createVolumeVoxelManager(dimensions, scalarData);\r\n\r\n    const imageData = vtkImageData.newInstance();\r\n    imageData.setDimensions(dimensions);\r\n    imageData.setOrigin(origin);\r\n    imageData.setDirection(direction);\r\n    imageData.setSpacing(spacing);\r\n\r\n    const scalarArray = vtkDataArray.newInstance({\r\n      name: 'Pixels',\r\n      numberOfComponents: 1,\r\n      values: scalarData,\r\n    });\r\n\r\n    imageData.getPointData().setScalars(scalarArray);\r\n\r\n    imageData.modified();\r\n\r\n    for (const index of segmentIndices) {\r\n      const annotations = annotationUIDsInSegmentMap.get(index);\r\n\r\n      for (const annotation of annotations) {\r\n        if (!annotation.polyline) {\r\n          continue;\r\n        }\r\n\r\n        const { polyline, holesPolyline } = annotation;\r\n        const bounds = getBoundingBoxAroundShapeWorld(polyline);\r\n\r\n        const [iMin, jMin, kMin] = utilities.transformWorldToIndex(imageData, [\r\n          bounds[0][0],\r\n          bounds[1][0],\r\n          bounds[2][0],\r\n        ]);\r\n\r\n        const [iMax, jMax, kMax] = utilities.transformWorldToIndex(imageData, [\r\n          bounds[0][1],\r\n          bounds[1][1],\r\n          bounds[2][1],\r\n        ]);\r\n\r\n        const { projectedPolyline, sharedDimensionIndex } =\r\n          projectTo2D(polyline);\r\n\r\n        const holes = holesPolyline?.map((hole) => {\r\n          const { projectedPolyline: projectedHole } = projectTo2D(hole);\r\n          return projectedHole;\r\n        });\r\n\r\n        const firstDim = (sharedDimensionIndex + 1) % 3;\r\n        const secondDim = (sharedDimensionIndex + 2) % 3;\r\n\r\n        // Run the pointInShapeCallback for the combined bounding box\r\n        pointInShapeCallback(\r\n          imageData,\r\n          (pointLPS) => {\r\n            const point2D = [pointLPS[firstDim], pointLPS[secondDim]];\r\n\r\n            // Check if the point is inside any of the polylines for this segment\r\n            const isInside = containsPoint(projectedPolyline, point2D, {\r\n              holes,\r\n            });\r\n\r\n            return isInside;\r\n          },\r\n          ({ pointIJK }) => {\r\n            segmentationVoxelManager.setAtIJKPoint(pointIJK, index);\r\n          },\r\n          [\r\n            [iMin, iMax],\r\n            [jMin, jMax],\r\n            [kMin, kMax],\r\n          ]\r\n        );\r\n      }\r\n    }\r\n\r\n    return segmentationVoxelManager.scalarData;\r\n  },\r\n  /**\r\n   * Converts a contour to a stack labelmap.\r\n   * @param {Object} args - The arguments for the conversion.\r\n   * @param {Array} callbacks - Optional callbacks for progress updates.\r\n   * @returns {Promise<Object>} - The converted segmentations information.\r\n   */\r\n  async convertContourToStackLabelmap(args, ...callbacks) {\r\n    const [progressCallback] = callbacks;\r\n    const polySeg = await new ICRPolySeg();\r\n    await polySeg.initialize({\r\n      updateProgress: progressCallback,\r\n    });\r\n\r\n    const { segmentationsInfo, annotationUIDsInSegmentMap, segmentIndices } =\r\n      args;\r\n\r\n    const segmentationVoxelManagers = new Map();\r\n\r\n    segmentationsInfo.forEach((segmentationInfo, referencedImageId) => {\r\n      const { dimensions, scalarData, direction, spacing, origin } =\r\n        segmentationInfo;\r\n      const manager = utilities.VoxelManager.createVolumeVoxelManager(\r\n        dimensions,\r\n        scalarData\r\n      );\r\n\r\n      const imageData = vtkImageData.newInstance();\r\n      imageData.setDimensions(dimensions);\r\n      imageData.setOrigin(origin);\r\n      imageData.setDirection(direction);\r\n      imageData.setSpacing(spacing);\r\n\r\n      const scalarArray = vtkDataArray.newInstance({\r\n        name: 'Pixels',\r\n        numberOfComponents: 1,\r\n        values: scalarData,\r\n      });\r\n\r\n      imageData.getPointData().setScalars(scalarArray);\r\n\r\n      imageData.modified();\r\n\r\n      segmentationVoxelManagers.set(referencedImageId, { manager, imageData });\r\n    });\r\n\r\n    for (const index of segmentIndices) {\r\n      const annotations = annotationUIDsInSegmentMap.get(index);\r\n\r\n      for (const annotation of annotations) {\r\n        if (!annotation.polyline) {\r\n          continue;\r\n        }\r\n\r\n        const { polyline, holesPolyline, referencedImageId } = annotation;\r\n        const bounds = getBoundingBoxAroundShapeWorld(polyline);\r\n\r\n        const { manager: segmentationVoxelManager, imageData } =\r\n          segmentationVoxelManagers.get(referencedImageId);\r\n\r\n        const [iMin, jMin, kMin] = utilities.transformWorldToIndex(imageData, [\r\n          bounds[0][0],\r\n          bounds[1][0],\r\n          bounds[2][0],\r\n        ]);\r\n\r\n        const [iMax, jMax, kMax] = utilities.transformWorldToIndex(imageData, [\r\n          bounds[0][1],\r\n          bounds[1][1],\r\n          bounds[2][1],\r\n        ]);\r\n\r\n        const { projectedPolyline, sharedDimensionIndex } =\r\n          projectTo2D(polyline);\r\n\r\n        const holes = holesPolyline?.map((hole) => {\r\n          const { projectedPolyline: projectedHole } = projectTo2D(hole);\r\n          return projectedHole;\r\n        });\r\n\r\n        const firstDim = (sharedDimensionIndex + 1) % 3;\r\n        const secondDim = (sharedDimensionIndex + 2) % 3;\r\n\r\n        // Run the pointInShapeCallback for the combined bounding box\r\n        pointInShapeCallback(\r\n          imageData,\r\n          (pointLPS) => {\r\n            const point2D = [pointLPS[firstDim], pointLPS[secondDim]];\r\n\r\n            // Check if the point is inside any of the polylines for this segment\r\n            const isInside = containsPoint(projectedPolyline, point2D, {\r\n              holes,\r\n            });\r\n\r\n            return isInside;\r\n          },\r\n          ({ pointIJK }) => {\r\n            segmentationVoxelManager.setAtIJKPoint(pointIJK, index);\r\n          },\r\n          [\r\n            [iMin, iMax],\r\n            [jMin, jMax],\r\n            [kMin, kMax],\r\n          ]\r\n        );\r\n      }\r\n    }\r\n\r\n    segmentationsInfo.forEach((segmentationInfo, referencedImageId) => {\r\n      const { manager: segmentationVoxelManager } =\r\n        segmentationVoxelManagers.get(referencedImageId);\r\n\r\n      segmentationInfo.scalarData = segmentationVoxelManager.scalarData;\r\n    });\r\n    return segmentationsInfo;\r\n  },\r\n  /**\r\n   * Converts a surface to a volume labelmap.\r\n   *\r\n   * @param {Object} args - The arguments for the conversion.\r\n   * @param {Array} args.points - The points defining the surface.\r\n   * @param {Array} args.polys - The polygons defining the surface.\r\n   * @param {Array} args.dimensions - The dimensions of the volume.\r\n   * @param {Array} args.spacing - The spacing between voxels in the volume.\r\n   * @param {Array} args.direction - The direction of the volume.\r\n   * @param {Array} args.origin - The origin of the volume.\r\n   * @param {Function} progressCallback - The callback function for reporting progress.\r\n   * @returns {Promise} - A promise that resolves with the converted labelmap.\r\n   */\r\n  async convertSurfaceToVolumeLabelmap(args, ...callbacks) {\r\n    const [progressCallback] = callbacks;\r\n    await this.initializePolySeg(progressCallback);\r\n\r\n    const results = this.polySeg.instance.convertSurfaceToLabelmap(\r\n      args.points,\r\n      args.polys,\r\n      args.dimensions,\r\n      args.spacing,\r\n      args.direction,\r\n      args.origin\r\n    );\r\n\r\n    return results;\r\n  },\r\n  /**\r\n   * Converts surfaces to a volume labelmap.\r\n   * @param {Object} args - The arguments for the conversion.\r\n   * @param {Map} args.segmentsInfo - A map containing information about the segments.\r\n   * @param {Function} progressCallback - A callback function for reporting progress.\r\n   * @returns {Uint8Array} - The resulting volume labelmap.\r\n   */\r\n  async convertSurfacesToVolumeLabelmap(args, ...callbacks) {\r\n    const [progressCallback] = callbacks;\r\n    await this.initializePolySeg(progressCallback);\r\n\r\n    const { segmentsInfo } = args;\r\n\r\n    const promises = Array.from(segmentsInfo.keys()).map((segmentIndex) => {\r\n      const { points, polys } = segmentsInfo.get(segmentIndex);\r\n      const result = this.polySeg.instance.convertSurfaceToLabelmap(\r\n        points,\r\n        polys,\r\n        args.dimensions,\r\n        args.spacing,\r\n        args.direction,\r\n        args.origin\r\n      );\r\n\r\n      return {\r\n        ...result,\r\n        segmentIndex,\r\n      };\r\n    });\r\n\r\n    const results = await Promise.all(promises);\r\n\r\n    const targetImageData = vtkImageData.newInstance();\r\n    targetImageData.setDimensions(args.dimensions);\r\n    targetImageData.setOrigin(args.origin);\r\n    targetImageData.setSpacing(args.spacing);\r\n    targetImageData.setDirection(args.direction);\r\n\r\n    const totalSize =\r\n      args.dimensions[0] * args.dimensions[1] * args.dimensions[2];\r\n\r\n    const scalarArray = vtkDataArray.newInstance({\r\n      name: 'Pixels',\r\n      numberOfComponents: 1,\r\n      values: new Uint8Array(totalSize),\r\n    });\r\n\r\n    targetImageData.getPointData().setScalars(scalarArray);\r\n    targetImageData.modified();\r\n\r\n    // we need to then consolidate the results into a single volume\r\n    // by looping into each voxel with pointInShapeCallback\r\n    // and check if the voxel is inside any of the reconstructed\r\n    // labelmaps\r\n\r\n    const segmentationVoxelManager =\r\n      utilities.VoxelManager.createVolumeVoxelManager(\r\n        args.dimensions,\r\n        targetImageData.getPointData().getScalars().getData()\r\n      );\r\n\r\n    const outputVolumesInfo = results.map((result) => {\r\n      const { data, dimensions, direction, origin, spacing } = result;\r\n      const volume = vtkImageData.newInstance();\r\n      volume.setDimensions(dimensions);\r\n      volume.setOrigin(origin);\r\n      volume.setSpacing(spacing);\r\n      volume.setDirection(direction);\r\n\r\n      const scalarArray = vtkDataArray.newInstance({\r\n        name: 'Pixels',\r\n        numberOfComponents: 1,\r\n        values: data,\r\n      });\r\n\r\n      volume.getPointData().setScalars(scalarArray);\r\n\r\n      volume.modified();\r\n\r\n      const voxelManager = utilities.VoxelManager.createVolumeVoxelManager(\r\n        dimensions,\r\n        data\r\n      );\r\n\r\n      const extent = volume.getExtent(); // e.g., [0, 176, 0, 268, 0, 337] for dimensions of [177, 269, 338]\r\n\r\n      return {\r\n        volume,\r\n        voxelManager,\r\n        extent,\r\n        scalarData: data,\r\n        segmentIndex: result.segmentIndex,\r\n      };\r\n    });\r\n\r\n    pointInShapeCallback(\r\n      targetImageData,\r\n      () => true, // we want to loop into all voxels\r\n      ({ pointIJK, pointLPS }) => {\r\n        // Check if the point is inside any of the reconstructed labelmaps\r\n        // Todo: we can optimize this by returning early if the bounding box\r\n        // of the point is outside the bounding box of the labelmap\r\n\r\n        try {\r\n          for (const volumeInfo of outputVolumesInfo) {\r\n            const { volume, extent, voxelManager, segmentIndex } = volumeInfo;\r\n\r\n            const index = volume.worldToIndex(pointLPS);\r\n\r\n            // check if the ijk point is inside the volume\r\n            if (\r\n              index[0] < extent[0] ||\r\n              index[0] > extent[1] ||\r\n              index[1] < extent[2] ||\r\n              index[1] > extent[3] ||\r\n              index[2] < extent[4] ||\r\n              index[2] > extent[5]\r\n            ) {\r\n              continue;\r\n            }\r\n\r\n            const roundedIndex = index.map(Math.round);\r\n            const value = voxelManager.getAtIJK(...roundedIndex);\r\n            if (value > 0) {\r\n              segmentationVoxelManager.setAtIJKPoint(pointIJK, segmentIndex);\r\n              break;\r\n            }\r\n          }\r\n        } catch (error) {\r\n          // right now there is weird error if the point is outside the volume\r\n        }\r\n      }\r\n    );\r\n\r\n    return segmentationVoxelManager.scalarData;\r\n  },\r\n  getSurfacesAABBs({ surfacesInfo }) {\r\n    const aabbs = new Map();\r\n    for (const { points, id } of surfacesInfo) {\r\n      const aabb = getAABB(points, { numDimensions: 3 });\r\n      aabbs.set(id, aabb);\r\n    }\r\n    return aabbs;\r\n  },\r\n  /**\r\n   * Cuts the surfaces into planes.\r\n   *\r\n   * @param {Object} options - The options object.\r\n   * @param {Array} options.planesInfo - The information about the planes.\r\n   * @param {Array} options.surfacesInfo - The information about the surfaces.\r\n   * @param {Function} progressCallback - The callback function for progress updates.\r\n   * @param {Function} updateCacheCallback - The callback function for updating the cache.\r\n   */\r\n  cutSurfacesIntoPlanes(\r\n    { planesInfo, surfacesInfo, surfacesAABB = new Map() },\r\n    progressCallback,\r\n    updateCacheCallback\r\n  ) {\r\n    const numberOfPlanes = planesInfo.length;\r\n    const cutter = vtkCutter.newInstance();\r\n\r\n    const plane1 = vtkPlane.newInstance();\r\n\r\n    cutter.setCutFunction(plane1);\r\n\r\n    const surfacePolyData = vtkPolyData.newInstance();\r\n\r\n    try {\r\n      for (const [index, planeInfo] of planesInfo.entries()) {\r\n        const { sliceIndex, planes } = planeInfo;\r\n\r\n        const polyDataResults = new Map();\r\n        for (const polyDataInfo of surfacesInfo) {\r\n          const { points, polys, id } = polyDataInfo;\r\n\r\n          const aabb3 =\r\n            surfacesAABB.get(id) || getAABB(points, { numDimensions: 3 });\r\n\r\n          if (!surfacesAABB.has(id)) {\r\n            surfacesAABB.set(id, aabb3);\r\n          }\r\n\r\n          const { minX, minY, minZ, maxX, maxY, maxZ } = aabb3;\r\n\r\n          const { origin, normal } = planes[0];\r\n\r\n          // Check if the plane intersects the AABB\r\n          if (\r\n            !isPlaneIntersectingAABB(\r\n              origin,\r\n              normal,\r\n              minX,\r\n              minY,\r\n              minZ,\r\n              maxX,\r\n              maxY,\r\n              maxZ\r\n            )\r\n          ) {\r\n            continue;\r\n          }\r\n\r\n          surfacePolyData.getPoints().setData(points, 3);\r\n          surfacePolyData.getPolys().setData(polys, 3);\r\n          surfacePolyData.modified();\r\n\r\n          cutter.setInputData(surfacePolyData);\r\n          plane1.setOrigin(origin);\r\n          plane1.setNormal(normal);\r\n\r\n          try {\r\n            cutter.update();\r\n          } catch (e) {\r\n            console.warn('Error during clipping', e);\r\n            continue;\r\n          }\r\n\r\n          const polyData = cutter.getOutputData();\r\n\r\n          const cutterOutput = polyData;\r\n          cutterOutput.buildLinks();\r\n          const loopExtraction = vtkContourLoopExtraction.newInstance();\r\n          loopExtraction.setInputData(cutterOutput);\r\n\r\n          const loopOutput = loopExtraction.getOutputData();\r\n          if (polyData) {\r\n            polyDataResults.set(id, {\r\n              points: loopOutput.getPoints().getData(),\r\n              lines: loopOutput.getLines().getData(),\r\n              numberOfCells: loopOutput.getLines().getNumberOfCells(),\r\n            });\r\n          }\r\n        }\r\n\r\n        progressCallback({ progress: (index + 1) / numberOfPlanes });\r\n\r\n        updateCacheCallback({ sliceIndex, polyDataResults });\r\n      }\r\n    } catch (e) {\r\n      console.warn('Error during processing', e);\r\n    } finally {\r\n      // Cleanup on completion\r\n      surfacesInfo = null;\r\n      plane1.delete();\r\n    }\r\n  },\r\n};\r\n\r\nexpose(polySegConverters);\r\n","import { m as macro } from '../../macros2.js';\nimport { b as roundVector, c as clampVector } from '../Core/Math/index.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkDataSet from './DataSet.js';\nimport vtkStructuredData from './StructuredData.js';\nimport { StructuredType } from './StructuredData/Constants.js';\nimport { mat3, mat4, vec3 } from 'gl-matrix';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageData(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageData');\n  publicAPI.setExtent = function () {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return false;\n    }\n    for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {\n      inExtent[_key] = arguments[_key];\n    }\n    const extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;\n    if (extentArray.length !== 6) {\n      return false;\n    }\n    const changeDetected = model.extent.some((item, index) => item !== extentArray[index]);\n    if (changeDetected) {\n      model.extent = extentArray.slice();\n      model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);\n      publicAPI.modified();\n    }\n    return changeDetected;\n  };\n  publicAPI.setDimensions = function () {\n    let i;\n    let j;\n    let k;\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return;\n    }\n    if (arguments.length === 1) {\n      const array = arguments.length <= 0 ? undefined : arguments[0];\n      i = array[0];\n      j = array[1];\n      k = array[2];\n    } else if (arguments.length === 3) {\n      i = arguments.length <= 0 ? undefined : arguments[0];\n      j = arguments.length <= 1 ? undefined : arguments[1];\n      k = arguments.length <= 2 ? undefined : arguments[2];\n    } else {\n      vtkErrorMacro('Bad dimension specification');\n      return;\n    }\n    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);\n  };\n  publicAPI.getDimensions = () => [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];\n  publicAPI.getNumberOfCells = () => {\n    const dims = publicAPI.getDimensions();\n    let nCells = 1;\n    for (let i = 0; i < 3; i++) {\n      if (dims[i] === 0) {\n        return 0;\n      }\n      if (dims[i] > 1) {\n        nCells *= dims[i] - 1;\n      }\n    }\n    return nCells;\n  };\n  publicAPI.getNumberOfPoints = () => {\n    const dims = publicAPI.getDimensions();\n    return dims[0] * dims[1] * dims[2];\n  };\n  publicAPI.getPoint = index => {\n    const dims = publicAPI.getDimensions();\n    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {\n      vtkErrorMacro('Requesting a point from an empty image.');\n      return null;\n    }\n    const ijk = new Float64Array(3);\n    switch (model.dataDescription) {\n      case StructuredType.EMPTY:\n        return null;\n      case StructuredType.SINGLE_POINT:\n        break;\n      case StructuredType.X_LINE:\n        ijk[0] = index;\n        break;\n      case StructuredType.Y_LINE:\n        ijk[1] = index;\n        break;\n      case StructuredType.Z_LINE:\n        ijk[2] = index;\n        break;\n      case StructuredType.XY_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0];\n        break;\n      case StructuredType.YZ_PLANE:\n        ijk[1] = index % dims[1];\n        ijk[2] = index / dims[1];\n        break;\n      case StructuredType.XZ_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[2] = index / dims[0];\n        break;\n      case StructuredType.XYZ_GRID:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0] % dims[1];\n        ijk[2] = index / (dims[0] * dims[1]);\n        break;\n      default:\n        vtkErrorMacro('Invalid dataDescription');\n        break;\n    }\n    const coords = [0, 0, 0];\n    publicAPI.indexToWorld(ijk, coords);\n    return coords;\n  };\n\n  // vtkCell *GetCell(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCell(vtkIdType cellId, vtkGenericCell *cell) VTK_OVERRIDE;\n  // void GetCellBounds(vtkIdType cellId, double bounds[6]) VTK_OVERRIDE;\n  // virtual vtkIdType FindPoint(double x, double y, double z)\n  // {\n  //   return this->vtkDataSet::FindPoint(x, y, z);\n  // }\n  // vtkIdType FindPoint(double x[3]) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkIdType cellId, double tol2,\n  //   int& subId, double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkGenericCell *gencell,\n  //   vtkIdType cellId, double tol2, int& subId,\n  //   double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkCell *FindAndGetCell(double x[3], vtkCell *cell, vtkIdType cellId,\n  //                                 double tol2, int& subId, double pcoords[3],\n  //                                 double *weights) VTK_OVERRIDE;\n  // int GetCellType(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCellPoints(vtkIdType cellId, vtkIdList *ptIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetCellPoints(cellId,ptIds,this->DataDescription,\n  //                                     this->GetDimensions());}\n  // void GetPointCells(vtkIdType ptId, vtkIdList *cellIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetPointCells(ptId,cellIds,this->GetDimensions());}\n  // void ComputeBounds() VTK_OVERRIDE;\n  // int GetMaxCellSize() VTK_OVERRIDE {return 8;}; //voxel is the largest\n\n  publicAPI.getBounds = () => publicAPI.extentToBounds(publicAPI.getSpatialExtent());\n  publicAPI.extentToBounds = ex => vtkBoundingBox.transformBounds(ex, model.indexToWorld);\n  publicAPI.getSpatialExtent = () => vtkBoundingBox.inflate([...model.extent], 0.5);\n\n  // Internal, shouldn't need to call this manually.\n  publicAPI.computeTransforms = () => {\n    mat4.fromTranslation(model.indexToWorld, model.origin);\n    model.indexToWorld[0] = model.direction[0];\n    model.indexToWorld[1] = model.direction[1];\n    model.indexToWorld[2] = model.direction[2];\n    model.indexToWorld[4] = model.direction[3];\n    model.indexToWorld[5] = model.direction[4];\n    model.indexToWorld[6] = model.direction[5];\n    model.indexToWorld[8] = model.direction[6];\n    model.indexToWorld[9] = model.direction[7];\n    model.indexToWorld[10] = model.direction[8];\n    mat4.scale(model.indexToWorld, model.indexToWorld, model.spacing);\n    mat4.invert(model.worldToIndex, model.indexToWorld);\n  };\n  publicAPI.indexToWorld = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.indexToWorld);\n    return aout;\n  };\n  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;\n  publicAPI.worldToIndex = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.worldToIndex);\n    return aout;\n  };\n  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;\n  publicAPI.indexToWorldBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.indexToWorld, bout);\n  };\n  publicAPI.worldToIndexBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.worldToIndex, bout);\n  };\n\n  // Make sure the transform is correct\n  publicAPI.onModified(publicAPI.computeTransforms);\n  publicAPI.computeTransforms();\n  publicAPI.getCenter = () => vtkBoundingBox.getCenter(publicAPI.getBounds());\n  publicAPI.computeHistogram = function (worldBounds) {\n    let voxelFunc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const bounds = [0, 0, 0, 0, 0, 0];\n    publicAPI.worldToIndexBounds(worldBounds, bounds);\n    const point1 = [0, 0, 0];\n    const point2 = [0, 0, 0];\n    vtkBoundingBox.computeCornerPoints(bounds, point1, point2);\n    roundVector(point1, point1);\n    roundVector(point2, point2);\n    const dimensions = publicAPI.getDimensions();\n    clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);\n    clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);\n    const yStride = dimensions[0];\n    const zStride = dimensions[0] * dimensions[1];\n    const pixels = publicAPI.getPointData().getScalars().getData();\n    let maximum = -Infinity;\n    let minimum = Infinity;\n    let sumOfSquares = 0;\n    let isum = 0;\n    let inum = 0;\n    for (let z = point1[2]; z <= point2[2]; z++) {\n      for (let y = point1[1]; y <= point2[1]; y++) {\n        let index = point1[0] + y * yStride + z * zStride;\n        for (let x = point1[0]; x <= point2[0]; x++) {\n          if (!voxelFunc || voxelFunc([x, y, z], bounds)) {\n            const pixel = pixels[index];\n            if (pixel > maximum) maximum = pixel;\n            if (pixel < minimum) minimum = pixel;\n            sumOfSquares += pixel * pixel;\n            isum += pixel;\n            inum += 1;\n          }\n          ++index;\n        }\n      }\n    }\n    const average = inum > 0 ? isum / inum : 0;\n    const variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;\n    const sigma = Math.sqrt(variance);\n    return {\n      minimum,\n      maximum,\n      average,\n      variance,\n      sigma,\n      count: inum\n    };\n  };\n\n  // TODO: use the unimplemented `vtkDataSetAttributes` for scalar length, that is currently also a TODO (GetNumberOfComponents).\n  // Scalar data could be tuples for color information?\n  publicAPI.computeIncrements = function (extent) {\n    let numberOfComponents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    const increments = [];\n    let incr = numberOfComponents;\n\n    // Calculate array increment offsets\n    // similar to c++ vtkImageData::ComputeIncrements\n    for (let idx = 0; idx < 3; ++idx) {\n      increments[idx] = incr;\n      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;\n    }\n    return increments;\n  };\n\n  /**\n   * @param {Number[]} index the localized `[i,j,k]` pixel array position. Float values will be rounded.\n   * @return {Number} the corresponding flattened index in the scalar array\n   */\n  publicAPI.computeOffsetIndex = _ref => {\n    let [i, j, k] = _ref;\n    const extent = publicAPI.getExtent();\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    const increments = publicAPI.computeIncrements(extent, numberOfComponents);\n    // Use the array increments to find the pixel index\n    // similar to c++ vtkImageData::GetArrayPointer\n    // Math.floor to catch \"practically 0\" e^-15 scenarios.\n    return Math.floor((Math.round(i) - extent[0]) * increments[0] + (Math.round(j) - extent[2]) * increments[1] + (Math.round(k) - extent[4]) * increments[2]);\n  };\n\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @return {Number|NaN} the corresponding pixel's index in the scalar array\n   */\n  publicAPI.getOffsetIndexFromWorld = xyz => {\n    const extent = publicAPI.getExtent();\n    const index = publicAPI.worldToIndex(xyz);\n\n    // Confirm indexed i,j,k coords are within the bounds of the volume\n    for (let idx = 0; idx < 3; ++idx) {\n      if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {\n        vtkErrorMacro(`GetScalarPointer: Pixel ${index} is not in memory. Current extent = ${extent}`);\n        return NaN;\n      }\n    }\n\n    // Assumed the index here is within 0 <-> scalarData.length, but doesn't hurt to check upstream\n    return publicAPI.computeOffsetIndex(index);\n  };\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @param {Number?} comp the scalar component index for multi-component scalars\n   * @return {Number|NaN} the corresponding pixel's scalar value\n   */\n  publicAPI.getScalarValueFromWorld = function (xyz) {\n    let comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    if (comp < 0 || comp >= numberOfComponents) {\n      vtkErrorMacro(`GetScalarPointer: Scalar Component ${comp} is not within bounds. Current Scalar numberOfComponents: ${numberOfComponents}`);\n      return NaN;\n    }\n    const offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);\n    if (Number.isNaN(offsetIndex)) {\n      // VTK Error Macro will have been tripped already, no need to do it again,\n      return offsetIndex;\n    }\n    return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  direction: null,\n  // a mat3\n  indexToWorld: null,\n  // a mat4\n  worldToIndex: null,\n  // a mat4\n  spacing: [1.0, 1.0, 1.0],\n  origin: [0.0, 0.0, 0.0],\n  extent: [0, -1, 0, -1, 0, -1],\n  dataDescription: StructuredType.EMPTY\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkDataSet.extend(publicAPI, model, initialValues);\n  if (!model.direction) {\n    model.direction = mat3.identity(new Float64Array(9));\n  } else if (Array.isArray(model.direction)) {\n    model.direction = new Float64Array(model.direction.slice(0, 9));\n  }\n  model.indexToWorld = new Float64Array(16);\n  model.worldToIndex = new Float64Array(16);\n\n  // Set/Get methods\n  macro.get(publicAPI, model, ['indexToWorld', 'worldToIndex']);\n  macro.setGetArray(publicAPI, model, ['origin', 'spacing'], 3);\n  macro.setGetArray(publicAPI, model, ['direction'], 9);\n  macro.getArray(publicAPI, model, ['extent'], 6);\n\n  // Object specific methods\n  vtkImageData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageData');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageData$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageData$1 as default, extend, newInstance };\n","import { m as macro } from '../../macros2.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkPiecewiseFunction methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPiecewiseFunction(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPiecewiseFunction');\n\n  // Return the number of points which specify this function\n  publicAPI.getSize = () => model.nodes.length;\n\n  // Return the type of function stored in object:\n  // Function Types:\n  //    0 : Constant        (No change in slope between end points)\n  //    1 : NonDecreasing   (Always increasing or zero slope)\n  //    2 : NonIncreasing   (Always decreasing or zero slope)\n  //    3 : Varied          (Contains both decreasing and increasing slopes)\n  //    4 : Unknown         (Error condition)\n  //\n  publicAPI.getType = () => {\n    let value;\n    let prevValue = 0.0;\n    let functionType = 0;\n    if (model.nodes.length > 0) {\n      prevValue = model.nodes[0].y;\n    }\n    for (let i = 1; i < model.nodes.length; i++) {\n      value = model.nodes[i].y;\n\n      // Do not change the function type if equal\n      if (value !== prevValue) {\n        if (value > prevValue) {\n          switch (functionType) {\n            case 0:\n            case 1:\n              // NonDecreasing\n              functionType = 1;\n              break;\n            case 2:\n            default:\n              // Varied\n              functionType = 3;\n              break;\n          }\n        } else {\n          // value < prev_value\n          switch (functionType) {\n            case 0:\n            case 2:\n              // NonIncreasing\n              functionType = 2;\n              break;\n            case 1:\n            default:\n              // Varied\n              functionType = 3;\n              break;\n          }\n        }\n      }\n      prevValue = value;\n\n      // Exit loop if we find a Varied function\n      if (functionType === 3) {\n        break;\n      }\n    }\n    switch (functionType) {\n      case 0:\n        return 'Constant';\n      case 1:\n        return 'NonDecreasing';\n      case 2:\n        return 'NonIncreasing';\n      case 3:\n      default:\n        return 'Varied';\n    }\n  };\n\n  // Since we no longer store the data in an array, we must\n  // copy out of the vector into an array. No modified check -\n  // could be added if performance is a problem\n  publicAPI.getDataPointer = () => {\n    const size = model.nodes.length;\n    model.function = null;\n    if (size > 0) {\n      model.function = [];\n      for (let i = 0; i < size; i++) {\n        model.function[2 * i] = model.nodes[i].x;\n        model.function[2 * i + 1] = model.nodes[i].y;\n      }\n    }\n    return model.function;\n  };\n\n  // Returns the first point location which starts a non-zero segment of the\n  // function. Note that the value at this point may be zero.\n  publicAPI.getFirstNonZeroValue = () => {\n    // Check if no points specified\n    if (model.nodes.length === 0) {\n      return 0;\n    }\n    let allZero = 1;\n    let x = 0.0;\n    let i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].y !== 0.0) {\n        allZero = 0;\n        break;\n      }\n    }\n\n    // If every specified point has a zero value then return\n    // a large value\n    if (allZero) {\n      x = Number.MAX_VALUE;\n    } else if (i > 0) {\n      // A point was found with a non-zero value\n      // Return the value of the point that precedes this one\n      x = model.nodes[i - 1].x;\n    } else if (model.clamping) {\n      // If this is the first point in the function, return its\n      // value is clamping is off, otherwise VTK_DOUBLE_MIN if\n      // clamping is on.\n      x = -Number.MAX_VALUE;\n    } else {\n      x = model.nodes[0].x;\n    }\n    return x;\n  };\n\n  // For a specified index value, get the node parameters\n  publicAPI.getNodeValue = (index, val) => {\n    const size = model.nodes.length;\n    if (index < 0 || index >= size) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    val[0] = model.nodes[index].x;\n    val[1] = model.nodes[index].y;\n    val[2] = model.nodes[index].midpoint;\n    val[3] = model.nodes[index].sharpness;\n    return 1;\n  };\n\n  // For a specified index value, get the node parameters\n  publicAPI.setNodeValue = (index, val) => {\n    const size = model.nodes.length;\n    if (index < 0 || index >= size) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    const oldX = model.nodes[index].x;\n    model.nodes[index].x = val[0];\n    model.nodes[index].y = val[1];\n    model.nodes[index].midpoint = val[2];\n    model.nodes[index].sharpness = val[3];\n    if (oldX !== val[0]) {\n      // The point has been moved, the order of points or the range might have\n      // been modified.\n      publicAPI.sortAndUpdateRange();\n      // No need to call Modified() here because SortAndUpdateRange() has done it\n      // already.\n    } else {\n      publicAPI.modified();\n    }\n    return 1;\n  };\n\n  // Adds a point to the function. If a duplicate point is inserted\n  // then the function value at that location is set to the new value.\n  // This is the legacy version that assumes midpoint = 0.5 and\n  // sharpness = 0.0\n  publicAPI.addPoint = (x, y) => publicAPI.addPointLong(x, y, 0.5, 0.0);\n\n  // Adds a point to the function and returns the array index of the point.\n  publicAPI.addPointLong = (x, y, midpoint, sharpness) => {\n    // Error check\n    if (midpoint < 0.0 || midpoint > 1.0) {\n      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');\n      return -1;\n    }\n    if (sharpness < 0.0 || sharpness > 1.0) {\n      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');\n      return -1;\n    }\n\n    // remove any node already at this X location\n    if (!model.allowDuplicateScalars) {\n      publicAPI.removePoint(x);\n    }\n\n    // Create the new node\n    const node = {\n      x,\n      y,\n      midpoint,\n      sharpness\n    };\n\n    // Add it, then sort to get everything in order\n    model.nodes.push(node);\n    publicAPI.sortAndUpdateRange();\n\n    // Now find this node so we can return the index\n    let i;\n    for (i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    // If we didn't find it, something went horribly wrong so\n    // return -1\n    if (i < model.nodes.length) {\n      return i;\n    }\n    return -1;\n  };\n  publicAPI.setNodes = nodes => {\n    if (model.nodes !== nodes) {\n      model.nodes = nodes;\n      publicAPI.sortAndUpdateRange();\n    }\n  };\n\n  // Sort the vector in increasing order, then fill in\n  // the Range\n  publicAPI.sortAndUpdateRange = () => {\n    model.nodes.sort((a, b) => a.x - b.x);\n    const modifiedInvoked = publicAPI.updateRange();\n    // If range is updated, Modified() has been called, don't call it again.\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.updateRange = () => {\n    const oldRange = model.range.slice();\n    const size = model.nodes.length;\n    if (size) {\n      model.range[0] = model.nodes[0].x;\n      model.range[1] = model.nodes[size - 1].x;\n    } else {\n      model.range[0] = 0;\n      model.range[1] = 0;\n    }\n    // If the rage is the same, then no need to call Modified()\n    if (oldRange[0] === model.range[0] && oldRange[1] === model.range[1]) {\n      return false;\n    }\n    publicAPI.modified();\n    return true;\n  };\n\n  // Removes a point from the function. If no point is found then function\n  // remains the same.\n  publicAPI.removePoint = x => {\n    // First find the node since we need to know its\n    // index as our return value\n    let i;\n    for (i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    // If the node doesn't exist, we return -1\n    if (i >= model.nodes.length) {\n      return -1;\n    }\n    const retVal = i;\n\n    // If the first or last point has been removed, then we update the range\n    // No need to sort here as the order of points hasn't changed.\n    let modifiedInvoked = false;\n    model.nodes.splice(i, 1);\n    if (i === 0 || i === model.nodes.length) {\n      modifiedInvoked = publicAPI.updateRange();\n    }\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n    return retVal;\n  };\n\n  // Removes all points from the function.\n  publicAPI.removeAllPoints = () => {\n    model.nodes = [];\n    publicAPI.sortAndUpdateRange();\n  };\n\n  // Add in end points of line and remove any points between them\n  // Legacy method with no way to specify midpoint and sharpness\n  publicAPI.addSegment = (x1, y1, x2, y2) => {\n    // First, find all points in this range and remove them\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {\n        model.nodes.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n\n    // Now add the points\n    publicAPI.addPoint(x1, y1, 0.5, 0.0);\n    publicAPI.addPoint(x2, y2, 0.5, 0.0);\n  };\n\n  // Return the value of the function at a position\n  publicAPI.getValue = x => {\n    const table = [];\n    publicAPI.getTable(x, x, 1, table);\n    return table[0];\n  };\n\n  // Remove all points outside the range, and make sure a point\n  // exists at each end of the range. Used as a convenience method\n  // for transfer function editors\n  publicAPI.adjustRange = range => {\n    if (range.length < 2) {\n      return 0;\n    }\n    const functionRange = publicAPI.getRange();\n\n    // Make sure we have points at each end of the range\n    if (functionRange[0] < range[0]) {\n      publicAPI.addPoint(range[0], publicAPI.getValue(range[0]));\n    } else {\n      publicAPI.addPoint(range[0], publicAPI.getValue(functionRange[0]));\n    }\n    if (functionRange[1] > range[1]) {\n      publicAPI.addPoint(range[1], publicAPI.getValue(range[1]));\n    } else {\n      publicAPI.addPoint(range[1], publicAPI.getValue(functionRange[1]));\n    }\n\n    // Remove all points out-of-range\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {\n        model.nodes.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n    publicAPI.sortAndUpdateRange();\n    return 1;\n  };\n\n  //--------------------------------------------------------------------------\n  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {\n    const d = publicAPI.findMinimumXDistance();\n    return Math.ceil((x2 - x1) / d);\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.findMinimumXDistance = () => {\n    const size = model.nodes.length;\n    if (size < 2) {\n      return -1.0;\n    }\n    let distance = model.nodes[1].x - model.nodes[0].x;\n    for (let i = 0; i < size - 1; i++) {\n      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;\n      if (currentDist < distance) {\n        distance = currentDist;\n      }\n    }\n    return distance;\n  };\n\n  // Returns a table of function values evaluated at regular intervals\n  /* eslint-disable prefer-destructuring */\n  /* eslint-disable no-continue */\n  publicAPI.getTable = function (xStart, xEnd, size, table) {\n    let stride = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    let i;\n    let idx = 0;\n    const numNodes = model.nodes.length;\n\n    // Need to keep track of the last value so that\n    // we can fill in table locations past this with\n    // this value if Clamping is On.\n    let lastValue = 0.0;\n    if (numNodes !== 0) {\n      lastValue = model.nodes[numNodes - 1].y;\n    }\n    let x = 0.0;\n    let x1 = 0.0;\n    let x2 = 0.0;\n    let y1 = 0.0;\n    let y2 = 0.0;\n    let midpoint = 0.0;\n    let sharpness = 0.0;\n\n    // For each table entry\n    for (i = 0; i < size; i++) {\n      // Find our location in the table\n      const tidx = stride * i;\n\n      // Find our X location. If we are taking only 1 sample, make\n      // it halfway between start and end (usually start and end will\n      // be the same in this case)\n      if (size > 1) {\n        x = xStart + i / (size - 1.0) * (xEnd - xStart);\n      } else {\n        x = 0.5 * (xStart + xEnd);\n      }\n\n      // Do we need to move to the next node?\n      while (idx < numNodes && x > model.nodes[idx].x) {\n        idx++;\n        // If we are at a valid point index, fill in\n        // the value at this node, and the one before (the\n        // two that surround our current sample location)\n        // idx cannot be 0 since we just incremented it.\n        if (idx < numNodes) {\n          x1 = model.nodes[idx - 1].x;\n          x2 = model.nodes[idx].x;\n          y1 = model.nodes[idx - 1].y;\n          y2 = model.nodes[idx].y;\n\n          // We only need the previous midpoint and sharpness\n          // since these control this region\n          midpoint = model.nodes[idx - 1].midpoint;\n          sharpness = model.nodes[idx - 1].sharpness;\n\n          // Move midpoint away from extreme ends of range to avoid\n          // degenerate math\n          if (midpoint < 0.00001) {\n            midpoint = 0.00001;\n          }\n          if (midpoint > 0.99999) {\n            midpoint = 0.99999;\n          }\n        }\n      }\n\n      // Are we at the end? If so, just use the last value\n      if (idx >= numNodes) {\n        table[tidx] = model.clamping ? lastValue : 0.0;\n      } else if (idx === 0) {\n        // Are we before the first node? If so, duplicate this nodes values\n        table[tidx] = model.clamping ? model.nodes[0].y : 0.0;\n      } else {\n        // Otherwise, we are between two nodes - interpolate\n        // Our first attempt at a normalized location [0,1] -\n        // we will be modifying this based on midpoint and\n        // sharpness to get the curve shape we want and to have\n        // it pass through (y1+y2)/2 at the midpoint.\n        let s = (x - x1) / (x2 - x1);\n\n        // Readjust based on the midpoint - linear adjustment\n        if (s < midpoint) {\n          s = 0.5 * s / midpoint;\n        } else {\n          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);\n        }\n\n        // override for sharpness > 0.99\n        // In this case we just want piecewise constant\n        if (sharpness > 0.99) {\n          // Use the first value since we are below the midpoint\n          if (s < 0.5) {\n            table[tidx] = y1;\n            continue;\n          } else {\n            // Use the second value at or above the midpoint\n            table[tidx] = y2;\n            continue;\n          }\n        }\n\n        // Override for sharpness < 0.01\n        // In this case we want piecewise linear\n        if (sharpness < 0.01) {\n          // Simple linear interpolation\n          table[tidx] = (1 - s) * y1 + s * y2;\n          continue;\n        }\n\n        // We have a sharpness between [0.01, 0.99] - we will\n        // used a modified hermite curve interpolation where we\n        // derive the slope based on the sharpness, and we compress\n        // the curve non-linearly based on the sharpness\n\n        // First, we will adjust our position based on sharpness in\n        // order to make the curve sharper (closer to piecewise constant)\n        if (s < 0.5) {\n          s = 0.5 * (s * 2) ** (1.0 + 10 * sharpness);\n        } else if (s > 0.5) {\n          s = 1.0 - 0.5 * ((1.0 - s) * 2) ** (1 + 10 * sharpness);\n        }\n\n        // Compute some coefficients we will need for the hermite curve\n        const ss = s * s;\n        const sss = ss * s;\n        const h1 = 2 * sss - 3 * ss + 1;\n        const h2 = -2 * sss + 3 * ss;\n        const h3 = sss - 2 * ss + s;\n        const h4 = sss - ss;\n\n        // Use one slope for both end points\n        const slope = y2 - y1;\n        const t = (1.0 - sharpness) * slope;\n\n        // Compute the value\n        table[tidx] = h1 * y1 + h2 * y2 + h3 * t + h4 * t;\n\n        // Final error check to make sure we don't go outside\n        // the Y range\n        const min = y1 < y2 ? y1 : y2;\n        const max = y1 > y2 ? y1 : y2;\n        table[tidx] = table[tidx] < min ? min : table[tidx];\n        table[tidx] = table[tidx] > max ? max : table[tidx];\n      }\n    }\n  };\n}\n/* eslint-enable prefer-destructuring */\n/* eslint-enable no-continue */\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // model.function = NULL;\n  range: [0, 0],\n  clamping: true,\n  allowDuplicateScalars: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n\n  // Internal objects initialization\n  model.nodes = [];\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['allowDuplicateScalars', 'clamping']);\n  macro.setArray(publicAPI, model, ['range'], 2);\n\n  // Create get macros for array\n  macro.getArray(publicAPI, model, ['range']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkPiecewiseFunction(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPiecewiseFunction');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPiecewiseFunction$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkPiecewiseFunction$1 as default, extend, newInstance };\n","import { s as subtract, d as dot, j as cross, k as add } from '../Core/Math/index.js';\nimport { m as macro } from '../../macros2.js';\n\nconst PLANE_TOLERANCE = 1.0e-6;\nconst COINCIDE = 'coincide';\nconst DISJOINT = 'disjoint';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction evaluate(normal, origin, x) {\n  return normal[0] * (x[0] - origin[0]) + normal[1] * (x[1] - origin[1]) + normal[2] * (x[2] - origin[2]);\n}\nfunction distanceToPlane(x, origin, normal) {\n  const distance = normal[0] * (x[0] - origin[0]) + normal[1] * (x[1] - origin[1]) + normal[2] * (x[2] - origin[2]);\n  return Math.abs(distance);\n}\nfunction projectPoint(x, origin, normal, xproj) {\n  const xo = [];\n  subtract(x, origin, xo);\n  const t = dot(normal, xo);\n  xproj[0] = x[0] - t * normal[0];\n  xproj[1] = x[1] - t * normal[1];\n  xproj[2] = x[2] - t * normal[2];\n}\nfunction projectVector(v, normal, vproj) {\n  const t = dot(v, normal);\n  let n2 = dot(normal, normal);\n  if (n2 === 0) {\n    n2 = 1.0;\n  }\n  vproj[0] = v[0] - t * normal[0] / n2;\n  vproj[1] = v[1] - t * normal[1] / n2;\n  vproj[2] = v[2] - t * normal[2] / n2;\n  return vproj;\n}\nfunction generalizedProjectPoint(x, origin, normal, xproj) {\n  const xo = [];\n  subtract(x, origin, xo);\n  const t = dot(normal, xo);\n  const n2 = dot(normal, normal);\n  if (n2 !== 0) {\n    xproj[0] = x[0] - t * normal[0] / n2;\n    xproj[1] = x[1] - t * normal[1] / n2;\n    xproj[2] = x[2] - t * normal[2] / n2;\n  } else {\n    xproj[0] = x[0];\n    xproj[1] = x[1];\n    xproj[2] = x[2];\n  }\n}\nfunction intersectWithLine(p1, p2, origin, normal) {\n  const outObj = {\n    intersection: false,\n    betweenPoints: false,\n    t: Number.MAX_VALUE,\n    x: []\n  };\n  const p21 = [];\n  const p1Origin = [];\n  // Compute line vector\n  subtract(p2, p1, p21);\n  subtract(origin, p1, p1Origin);\n\n  // Compute denominator.  If ~0, line and plane are parallel.\n  // const num = vtkMath.dot(normal, origin) - vtkMath.dot(normal, p1);\n  const num = dot(normal, p1Origin);\n  const den = dot(normal, p21);\n\n  // If denominator with respect to numerator is \"zero\", then the line and\n  // plane are considered parallel.\n  let fabsden;\n  let fabstolerance;\n\n  // Trying to avoid an expensive call to fabs()\n  if (den < 0.0) {\n    fabsden = -den;\n  } else {\n    fabsden = den;\n  }\n  if (num < 0.0) {\n    fabstolerance = -num * PLANE_TOLERANCE;\n  } else {\n    fabstolerance = num * PLANE_TOLERANCE;\n  }\n  if (fabsden <= fabstolerance) {\n    return outObj;\n  }\n\n  // Where on the line between p1 and p2 is the intersection\n  // If between 0 and 1, it is between the two points. If < 0 it's before p1, if > 1 it's after p2\n  outObj.t = num / den;\n  outObj.x[0] = p1[0] + outObj.t * p21[0];\n  outObj.x[1] = p1[1] + outObj.t * p21[1];\n  outObj.x[2] = p1[2] + outObj.t * p21[2];\n  outObj.intersection = true;\n  outObj.betweenPoints = outObj.t >= 0.0 && outObj.t <= 1.0;\n  return outObj;\n}\nfunction intersectWithPlane(plane1Origin, plane1Normal, plane2Origin, plane2Normal) {\n  const outObj = {\n    intersection: false,\n    l0: [],\n    l1: [],\n    error: null\n  };\n  const cross$1 = [];\n  cross(plane1Normal, plane2Normal, cross$1);\n  const absCross = cross$1.map(n => Math.abs(n));\n\n  // test if the two planes are parallel\n  if (absCross[0] + absCross[1] + absCross[2] < PLANE_TOLERANCE) {\n    // test if disjoint or coincide\n    const v = [];\n    subtract(plane1Origin, plane2Origin, v);\n    if (dot(plane1Normal, v) === 0) {\n      outObj.error = COINCIDE;\n    } else {\n      outObj.error = DISJOINT;\n    }\n    return outObj;\n  }\n\n  // Plane1 and Plane2 intersect in a line\n  // first determine max abs coordinate of the cross product\n  let maxc;\n  if (absCross[0] > absCross[1] && absCross[0] > absCross[2]) {\n    maxc = 'x';\n  } else if (absCross[1] > absCross[2]) {\n    maxc = 'y';\n  } else {\n    maxc = 'z';\n  }\n\n  // To get a point on the intersect line, zero the max coord, and solve for the other two\n  const iP = []; // intersectionPoint\n  // the constants in the 2 plane equations\n  const d1 = -dot(plane1Normal, plane1Origin);\n  const d2 = -dot(plane2Normal, plane2Origin);\n\n  // eslint-disable-next-line default-case\n  switch (maxc) {\n    case 'x':\n      // intersect with x=0\n      iP[0] = 0;\n      iP[1] = (d2 * plane1Normal[2] - d1 * plane2Normal[2]) / cross$1[0];\n      iP[2] = (d1 * plane2Normal[1] - d2 * plane1Normal[1]) / cross$1[0];\n      break;\n    case 'y':\n      // intersect with y=0\n      iP[0] = (d1 * plane2Normal[2] - d2 * plane1Normal[2]) / cross$1[1];\n      iP[1] = 0;\n      iP[2] = (d2 * plane1Normal[0] - d1 * plane2Normal[0]) / cross$1[1];\n      break;\n    case 'z':\n      // intersect with z=0\n      iP[0] = (d2 * plane1Normal[1] - d1 * plane2Normal[1]) / cross$1[2];\n      iP[1] = (d1 * plane2Normal[0] - d2 * plane1Normal[0]) / cross$1[2];\n      iP[2] = 0;\n      break;\n  }\n  outObj.l0 = iP;\n  add(iP, cross$1, outObj.l1);\n  outObj.intersection = true;\n  return outObj;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  evaluate,\n  distanceToPlane,\n  projectPoint,\n  projectVector,\n  generalizedProjectPoint,\n  intersectWithLine,\n  intersectWithPlane,\n  DISJOINT,\n  COINCIDE\n};\n\n// ----------------------------------------------------------------------------\n// vtkPlane methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPlane(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPlane');\n  publicAPI.distanceToPlane = x => distanceToPlane(x, model.origin, model.normal);\n  publicAPI.projectPoint = (x, xproj) => {\n    projectPoint(x, model.origin, model.normal, xproj);\n  };\n  publicAPI.projectVector = (v, vproj) => projectVector(v, model.normal, vproj);\n  publicAPI.push = distance => {\n    if (distance === 0.0) {\n      return;\n    }\n    for (let i = 0; i < 3; i++) {\n      model.origin[i] += distance * model.normal[i];\n    }\n  };\n  publicAPI.generalizedProjectPoint = (x, xproj) => {\n    generalizedProjectPoint(x, model.origin, model.normal, xproj);\n  };\n  publicAPI.evaluateFunction = (x, y, z) => {\n    if (!Array.isArray(x)) {\n      return model.normal[0] * (x - model.origin[0]) + model.normal[1] * (y - model.origin[1]) + model.normal[2] * (z - model.origin[2]);\n    }\n    return model.normal[0] * (x[0] - model.origin[0]) + model.normal[1] * (x[1] - model.origin[1]) + model.normal[2] * (x[2] - model.origin[2]);\n  };\n  publicAPI.evaluateGradient = xyz => {\n    const retVal = [model.normal[0], model.normal[1], model.normal[2]];\n    return retVal;\n  };\n  publicAPI.intersectWithLine = (p1, p2) => intersectWithLine(p1, p2, model.origin, model.normal);\n  publicAPI.intersectWithPlane = (planeOrigin, planeNormal) => intersectWithPlane(planeOrigin, planeNormal, model.origin, model.normal);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  normal: [0.0, 0.0, 1.0],\n  origin: [0.0, 0.0, 0.0]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  macro.obj(publicAPI, model);\n  macro.setGetArray(publicAPI, model, ['normal', 'origin'], 3);\n  vtkPlane(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPlane');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPlane$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkPlane$1 as default, extend, newInstance, vtkPlane };\n","import { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport vtkCaseTable from './ImageMarchingSquares/caseTable.js';\n\nconst {\n  vtkErrorMacro,\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageMarchingSquares methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMarchingSquares(publicAPI, model) {\n  /**\n   * Get the X,Y kernels based on the set slicing mode.\n   * @returns {[number, number]}\n   */\n  function getKernels() {\n    let kernelX = 0; // default K slicing mode\n    let kernelY = 1;\n    if (model.slicingMode === 1) {\n      kernelX = 0;\n      kernelY = 2;\n    } else if (model.slicingMode === 0) {\n      kernelX = 1;\n      kernelY = 2;\n    }\n    return [kernelX, kernelY];\n  }\n\n  // Set our className\n  model.classHierarchy.push('vtkImageMarchingSquares');\n\n  /**\n   * Get the list of contour values.\n   * @returns {number[]}\n   */\n  publicAPI.getContourValues = () => model.contourValues;\n\n  /**\n   * Set the list contour values.\n   * @param {number[]} cValues\n   */\n  publicAPI.setContourValues = cValues => {\n    model.contourValues = cValues;\n    publicAPI.modified();\n  };\n  const ids = [];\n  const pixelScalars = [];\n  const pixelPts = [];\n  const edgeLocator = vtkEdgeLocator.newInstance();\n\n  /**\n   * Retrieve scalars and pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelScalars = (ijk, dims, scalars, increments, kernelX, kernelY) => {\n    const [i, j, k] = ijk;\n\n    // First get the indices for the pixel\n    ids[0] = k * dims[1] * dims[0] + j * dims[0] + i; // i, j, k\n    ids[1] = ids[0] + increments[kernelX]; // i+1, j, k\n    ids[2] = ids[0] + increments[kernelY]; // i, j+1, k\n    ids[3] = ids[2] + increments[kernelX]; // i+1, j+1, k\n\n    // Now retrieve the scalars\n    for (let ii = 0; ii < 4; ++ii) {\n      pixelScalars[ii] = scalars[ids[ii]];\n    }\n  };\n\n  /**\n   * Retrieve pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing spacing of the image\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelPoints = (ijk, origin, spacing, kernelX, kernelY) => {\n    const i = ijk[kernelX];\n    const j = ijk[kernelY];\n\n    // (i,i+1),(j,j+1),(k,k+1) - i varies fastest; then j; then k\n    pixelPts[0] = origin[kernelX] + i * spacing[kernelX]; // 0\n    pixelPts[1] = origin[kernelY] + j * spacing[kernelY];\n    pixelPts[2] = pixelPts[0] + spacing[kernelX]; // 1\n    pixelPts[3] = pixelPts[1];\n    pixelPts[4] = pixelPts[0]; // 2\n    pixelPts[5] = pixelPts[1] + spacing[kernelY];\n    pixelPts[6] = pixelPts[2]; // 3\n    pixelPts[7] = pixelPts[5];\n  };\n\n  /**\n   * Produce points and lines for the polydata.\n   * @param {number[]} cVal list of contour values\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing sapcing of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {number[]} points list of points\n   * @param {number[]} lines list of lines\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.produceLines = (cVal, ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY) => {\n    const k = ijk[model.slicingMode];\n    const CASE_MASK = [1, 2, 8, 4]; // case table is actually for quad\n    const xyz = [];\n    let pId;\n    publicAPI.getPixelScalars(ijk, dims, scalars, increments, kernelX, kernelY);\n    let index = 0;\n    for (let idx = 0; idx < 4; idx++) {\n      if (pixelScalars[idx] >= cVal) {\n        index |= CASE_MASK[idx]; // eslint-disable-line no-bitwise\n      }\n    }\n\n    const pixelLines = vtkCaseTable.getCase(index);\n    if (pixelLines[0] < 0) {\n      return; // don't get the pixel coordinates, nothing to do\n    }\n\n    publicAPI.getPixelPoints(ijk, origin, spacing, kernelX, kernelY);\n    const z = origin[model.slicingMode] + k * spacing[model.slicingMode];\n    for (let idx = 0; pixelLines[idx] >= 0; idx += 2) {\n      lines.push(2);\n      for (let eid = 0; eid < 2; eid++) {\n        const edgeVerts = vtkCaseTable.getEdge(pixelLines[idx + eid]);\n        pId = undefined;\n        if (model.mergePoints) {\n          pId = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])?.value;\n        }\n        if (pId === undefined) {\n          const t = (cVal - pixelScalars[edgeVerts[0]]) / (pixelScalars[edgeVerts[1]] - pixelScalars[edgeVerts[0]]);\n          const x0 = pixelPts.slice(edgeVerts[0] * 2, (edgeVerts[0] + 1) * 2);\n          const x1 = pixelPts.slice(edgeVerts[1] * 2, (edgeVerts[1] + 1) * 2);\n          xyz[kernelX] = x0[0] + t * (x1[0] - x0[0]);\n          xyz[kernelY] = x0[1] + t * (x1[1] - x0[1]);\n          xyz[model.slicingMode] = z;\n          pId = points.length / 3;\n          points.push(xyz[0], xyz[1], xyz[2]);\n          if (model.mergePoints) {\n            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);\n          }\n        }\n        lines.push(pId);\n      }\n    }\n  };\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    if (model.slicingMode == null || model.slicingMode < 0 || model.slicingMode > 2) {\n      vtkErrorMacro('Invalid or missing slicing mode');\n      return;\n    }\n    console.time('msquares');\n\n    // Retrieve output and volume data\n    const origin = input.getOrigin();\n    const spacing = input.getSpacing();\n    const dims = input.getDimensions();\n    const extent = input.getExtent();\n    const increments = input.computeIncrements(extent);\n    const scalars = input.getPointData().getScalars().getData();\n    const [kernelX, kernelY] = getKernels();\n\n    // Points - dynamic array\n    const points = [];\n\n    // Cells - dynamic array\n    const lines = [];\n\n    // Ensure slice is valid\n    let k = Math.round(model.slice);\n    if (k >= dims[model.slicingMode]) {\n      k = 0;\n    }\n\n    // Loop over all contour values, and then pixels, determine case and process\n    const ijk = [0, 0, 0];\n    ijk[model.slicingMode] = k;\n    for (let cv = 0; cv < model.contourValues.length; ++cv) {\n      for (let j = 0; j < dims[kernelY] - 1; ++j) {\n        ijk[kernelY] = j;\n        for (let i = 0; i < dims[kernelX] - 1; ++i) {\n          ijk[kernelX] = i;\n          publicAPI.produceLines(model.contourValues[cv], ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY);\n        }\n      }\n      edgeLocator.initialize();\n    }\n\n    // Update output\n    const polydata = vtkPolyData.newInstance();\n    polydata.getPoints().setData(new Float32Array(points), 3);\n    polydata.getLines().setData(new Uint32Array(lines));\n    outData[0] = polydata;\n    vtkDebugMacro('Produced output');\n    console.timeEnd('msquares');\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  contourValues: [],\n  slicingMode: 2,\n  slice: 0,\n  mergePoints: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['slicingMode', 'slice', 'mergePoints']);\n\n  // Object specific methods\n  macro.algo(publicAPI, model, 1, 1);\n  vtkImageMarchingSquares(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageMarchingSquares');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageMarchingSquares$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageMarchingSquares$1 as default, extend, newInstance };\n","import { mat4, vec4, vec3, quat } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport { r as radiansFromDegrees, k as add, j as cross } from '../../Common/Core/Math/index.js';\n\nconst {\n  vtkDebugMacro\n} = macro;\n\n/* eslint-disable new-cap */\n\n/*\n * Convenience function to access elements of a gl-matrix.  If it turns\n * out I have rows and columns swapped everywhere, then I'll just change\n * the order of 'row' and 'col' parameters in this function\n */\n// function getMatrixElement(matrix, row, col) {\n//   const idx = (row * 4) + col;\n//   return matrix[idx];\n// }\n\n// ----------------------------------------------------------------------------\n// vtkCamera methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCamera(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCamera');\n\n  // Set up private variables and methods\n  const origin = new Float64Array(3);\n  const dopbasis = new Float64Array([0.0, 0.0, -1.0]);\n  const upbasis = new Float64Array([0.0, 1.0, 0.0]);\n  const tmpMatrix = mat4.identity(new Float64Array(16));\n  const tmpMatrix2 = mat4.identity(new Float64Array(16));\n  const tmpvec1 = new Float64Array(3);\n  const tmpvec2 = new Float64Array(3);\n  const tmpvec3 = new Float64Array(3);\n  const rotateMatrix = mat4.identity(new Float64Array(16));\n  const trans = mat4.identity(new Float64Array(16));\n  const newPosition = new Float64Array(3);\n  const newFocalPoint = new Float64Array(3);\n\n  // Internal Functions that don't need to be public\n  function computeViewPlaneNormal() {\n    // VPN is -DOP\n    model.viewPlaneNormal[0] = -model.directionOfProjection[0];\n    model.viewPlaneNormal[1] = -model.directionOfProjection[1];\n    model.viewPlaneNormal[2] = -model.directionOfProjection[2];\n  }\n  publicAPI.orthogonalizeViewUp = () => {\n    const vt = publicAPI.getViewMatrix();\n    model.viewUp[0] = vt[4];\n    model.viewUp[1] = vt[5];\n    model.viewUp[2] = vt[6];\n    publicAPI.modified();\n  };\n  publicAPI.setPosition = (x, y, z) => {\n    if (x === model.position[0] && y === model.position[1] && z === model.position[2]) {\n      return;\n    }\n    model.position[0] = x;\n    model.position[1] = y;\n    model.position[2] = z;\n\n    // recompute the focal distance\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n  publicAPI.setFocalPoint = (x, y, z) => {\n    if (x === model.focalPoint[0] && y === model.focalPoint[1] && z === model.focalPoint[2]) {\n      return;\n    }\n    model.focalPoint[0] = x;\n    model.focalPoint[1] = y;\n    model.focalPoint[2] = z;\n\n    // recompute the focal distance\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n  publicAPI.setDistance = d => {\n    if (model.distance === d) {\n      return;\n    }\n    model.distance = d;\n    if (model.distance < 1e-20) {\n      model.distance = 1e-20;\n      vtkDebugMacro('Distance is set to minimum.');\n    }\n\n    // we want to keep the camera pointing in the same direction\n    const vec = model.directionOfProjection;\n\n    // recalculate FocalPoint\n    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  // This method must be called when the focal point or camera position changes\n  publicAPI.computeDistance = () => {\n    const dx = model.focalPoint[0] - model.position[0];\n    const dy = model.focalPoint[1] - model.position[1];\n    const dz = model.focalPoint[2] - model.position[2];\n    model.distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n    if (model.distance < 1e-20) {\n      model.distance = 1e-20;\n      vtkDebugMacro('Distance is set to minimum.');\n      const vec = model.directionOfProjection;\n\n      // recalculate FocalPoint\n      model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n      model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n      model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    }\n    model.directionOfProjection[0] = dx / model.distance;\n    model.directionOfProjection[1] = dy / model.distance;\n    model.directionOfProjection[2] = dz / model.distance;\n    computeViewPlaneNormal();\n  };\n\n  //----------------------------------------------------------------------------\n  // Move the position of the camera along the view plane normal. Moving\n  // towards the focal point (e.g., > 1) is a dolly-in, moving away\n  // from the focal point (e.g., < 1) is a dolly-out.\n  publicAPI.dolly = amount => {\n    if (amount <= 0.0) {\n      return;\n    }\n\n    // dolly moves the camera towards the focus\n    const d = model.distance / amount;\n    publicAPI.setPosition(model.focalPoint[0] - d * model.directionOfProjection[0], model.focalPoint[1] - d * model.directionOfProjection[1], model.focalPoint[2] - d * model.directionOfProjection[2]);\n  };\n  publicAPI.roll = angle => {\n    const eye = model.position;\n    const at = model.focalPoint;\n    const up = model.viewUp;\n    const viewUpVec4 = new Float64Array([up[0], up[1], up[2], 0.0]);\n    mat4.identity(rotateMatrix);\n    const viewDir = new Float64Array([at[0] - eye[0], at[1] - eye[1], at[2] - eye[2]]);\n    mat4.rotate(rotateMatrix, rotateMatrix, radiansFromDegrees(angle), viewDir);\n    vec4.transformMat4(viewUpVec4, viewUpVec4, rotateMatrix);\n    model.viewUp[0] = viewUpVec4[0];\n    model.viewUp[1] = viewUpVec4[1];\n    model.viewUp[2] = viewUpVec4[2];\n    publicAPI.modified();\n  };\n  publicAPI.azimuth = angle => {\n    const fp = model.focalPoint;\n    mat4.identity(trans);\n\n    // translate the focal point to the origin,\n    // rotate about view up,\n    // translate back again\n    mat4.translate(trans, trans, fp);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), model.viewUp);\n    mat4.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);\n\n    // apply the transform to the position\n    vec3.transformMat4(newPosition, model.position, trans);\n    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);\n  };\n  publicAPI.yaw = angle => {\n    const position = model.position;\n    mat4.identity(trans);\n\n    // translate the camera to the origin,\n    // rotate about axis,\n    // translate back again\n    mat4.translate(trans, trans, position);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), model.viewUp);\n    mat4.translate(trans, trans, [-position[0], -position[1], -position[2]]);\n\n    // apply the transform to the position\n    vec3.transformMat4(newFocalPoint, model.focalPoint, trans);\n    publicAPI.setFocalPoint(newFocalPoint[0], newFocalPoint[1], newFocalPoint[2]);\n  };\n  publicAPI.elevation = angle => {\n    const fp = model.focalPoint;\n\n    // get the eye / camera position from the viewMatrix\n    const vt = publicAPI.getViewMatrix();\n    const axis = [-vt[0], -vt[1], -vt[2]];\n    mat4.identity(trans);\n\n    // translate the focal point to the origin,\n    // rotate about view up,\n    // translate back again\n    mat4.translate(trans, trans, fp);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), axis);\n    mat4.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);\n\n    // apply the transform to the position\n    vec3.transformMat4(newPosition, model.position, trans);\n    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);\n  };\n  publicAPI.pitch = angle => {\n    const position = model.position;\n    const vt = publicAPI.getViewMatrix();\n    const axis = [vt[0], vt[1], vt[2]];\n    mat4.identity(trans);\n\n    // translate the camera to the origin,\n    // rotate about axis,\n    // translate back again\n    mat4.translate(trans, trans, position);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), axis);\n    mat4.translate(trans, trans, [-position[0], -position[1], -position[2]]);\n\n    // apply the transform to the focal point\n    vec3.transformMat4(newFocalPoint, model.focalPoint, trans);\n    publicAPI.setFocalPoint(...newFocalPoint);\n  };\n  publicAPI.zoom = factor => {\n    if (factor <= 0) {\n      return;\n    }\n    if (model.parallelProjection) {\n      model.parallelScale /= factor;\n    } else {\n      model.viewAngle /= factor;\n    }\n    publicAPI.modified();\n  };\n  publicAPI.translate = (x, y, z) => {\n    const offset = [x, y, z];\n    add(model.position, offset, model.position);\n    add(model.focalPoint, offset, model.focalPoint);\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n  publicAPI.applyTransform = transformMat4 => {\n    const vuOld = [...model.viewUp, 1.0];\n    const posNew = [];\n    const fpNew = [];\n    const vuNew = [];\n    vuOld[0] += model.position[0];\n    vuOld[1] += model.position[1];\n    vuOld[2] += model.position[2];\n    vec4.transformMat4(posNew, [...model.position, 1.0], transformMat4);\n    vec4.transformMat4(fpNew, [...model.focalPoint, 1.0], transformMat4);\n    vec4.transformMat4(vuNew, vuOld, transformMat4);\n    vuNew[0] -= posNew[0];\n    vuNew[1] -= posNew[1];\n    vuNew[2] -= posNew[2];\n    publicAPI.setPosition(...posNew.slice(0, 3));\n    publicAPI.setFocalPoint(...fpNew.slice(0, 3));\n    publicAPI.setViewUp(...vuNew.slice(0, 3));\n  };\n  publicAPI.getThickness = () => model.clippingRange[1] - model.clippingRange[0];\n  publicAPI.setThickness = thickness => {\n    let t = thickness;\n    if (t < 1e-20) {\n      t = 1e-20;\n      vtkDebugMacro('Thickness is set to minimum.');\n    }\n    publicAPI.setClippingRange(model.clippingRange[0], model.clippingRange[0] + t);\n  };\n  publicAPI.setThicknessFromFocalPoint = thickness => {\n    let t = thickness;\n    if (t < 1e-20) {\n      t = 1e-20;\n      vtkDebugMacro('Thickness is set to minimum.');\n    }\n    publicAPI.setClippingRange(model.distance - t / 2, model.distance + t / 2);\n  };\n\n  // Unimplemented functions\n  publicAPI.setRoll = angle => {}; // dependency on GetOrientation() and a model.ViewTransform object, see https://github.com/Kitware/VTK/blob/master/Common/Transforms/vtkTransform.cxx and https://vtk.org/doc/nightly/html/classvtkTransform.html\n  publicAPI.getRoll = () => {};\n  publicAPI.setObliqueAngles = (alpha, beta) => {};\n  publicAPI.getOrientation = () => {};\n  publicAPI.getOrientationWXYZ = () => {};\n  publicAPI.getFrustumPlanes = aspect => {\n    // Return array of 24 params (4 params for each of 6 plane equations)\n  };\n  publicAPI.getCameraLightTransformMatrix = matrix => {\n    mat4.copy(matrix, model.cameraLightTransform);\n    return matrix;\n  };\n  publicAPI.computeCameraLightTransform = () => {\n    // not sure if this is the correct transformation, based on the same funciton in VTK\n    mat4.copy(tmpMatrix, publicAPI.getViewMatrix());\n    mat4.invert(tmpMatrix, tmpMatrix);\n    mat4.fromScaling(tmpMatrix2, [model.distance, model.distance, model.distance]);\n    mat4.multiply(tmpMatrix, tmpMatrix, tmpMatrix2);\n    mat4.identity(model.cameraLightTransform);\n    mat4.translate(model.cameraLightTransform, tmpMatrix, [0.0, 0.0, -1.0]);\n  };\n  publicAPI.deepCopy = sourceCamera => {};\n  publicAPI.physicalOrientationToWorldDirection = ori => {\n    // push the x axis through the orientation quat\n    const oriq = quat.fromValues(ori[0], ori[1], ori[2], ori[3]);\n    const coriq = quat.create();\n    const qdir = quat.fromValues(0.0, 0.0, 1.0, 0.0);\n    quat.conjugate(coriq, oriq);\n\n    // rotate the z axis by the quat\n    quat.multiply(qdir, oriq, qdir);\n    quat.multiply(qdir, qdir, coriq);\n\n    // return the z axis in world coords\n    return [qdir[0], qdir[1], qdir[2]];\n  };\n  publicAPI.getPhysicalToWorldMatrix = result => {\n    publicAPI.getWorldToPhysicalMatrix(result);\n    mat4.invert(result, result);\n  };\n  publicAPI.getWorldToPhysicalMatrix = result => {\n    mat4.identity(result);\n\n    // now the physical to vtk world rotation tform\n    const physVRight = [3];\n    cross(model.physicalViewNorth, model.physicalViewUp, physVRight);\n    result[0] = physVRight[0];\n    result[1] = physVRight[1];\n    result[2] = physVRight[2];\n    result[4] = model.physicalViewUp[0];\n    result[5] = model.physicalViewUp[1];\n    result[6] = model.physicalViewUp[2];\n    result[8] = -model.physicalViewNorth[0];\n    result[9] = -model.physicalViewNorth[1];\n    result[10] = -model.physicalViewNorth[2];\n    mat4.transpose(result, result);\n    vec3.set(tmpvec1, 1 / model.physicalScale, 1 / model.physicalScale, 1 / model.physicalScale);\n    mat4.scale(result, result, tmpvec1);\n    mat4.translate(result, result, model.physicalTranslation);\n  };\n  publicAPI.computeViewParametersFromViewMatrix = vmat => {\n    // invert to get view to world\n    mat4.invert(tmpMatrix, vmat);\n\n    // note with glmatrix operations happen in\n    // the reverse order\n    // mat.scale\n    // mat.translate\n    // will result in the translation then the scale\n    // mat.mult(a,b)\n    // results in perform the B transformation then A\n\n    // then extract the params position, orientation\n    // push 0,0,0 through to get a translation\n    vec3.transformMat4(tmpvec1, origin, tmpMatrix);\n    publicAPI.computeDistance();\n    const oldDist = model.distance;\n    publicAPI.setPosition(tmpvec1[0], tmpvec1[1], tmpvec1[2]);\n\n    // push basis vectors to get orientation\n    vec3.transformMat4(tmpvec2, dopbasis, tmpMatrix);\n    vec3.subtract(tmpvec2, tmpvec2, tmpvec1);\n    vec3.normalize(tmpvec2, tmpvec2);\n    publicAPI.setDirectionOfProjection(tmpvec2[0], tmpvec2[1], tmpvec2[2]);\n    vec3.transformMat4(tmpvec3, upbasis, tmpMatrix);\n    vec3.subtract(tmpvec3, tmpvec3, tmpvec1);\n    vec3.normalize(tmpvec3, tmpvec3);\n    publicAPI.setViewUp(tmpvec3[0], tmpvec3[1], tmpvec3[2]);\n    publicAPI.setDistance(oldDist);\n  };\n\n  // the provided matrix should include\n  // translation and orientation only\n  // mat is physical to view\n  publicAPI.computeViewParametersFromPhysicalMatrix = mat => {\n    // get the WorldToPhysicalMatrix\n    publicAPI.getWorldToPhysicalMatrix(tmpMatrix);\n\n    // first convert the physical -> view matrix to be\n    // world -> view\n    mat4.multiply(tmpMatrix, mat, tmpMatrix);\n    publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);\n  };\n  publicAPI.setViewMatrix = mat => {\n    model.viewMatrix = mat;\n    if (model.viewMatrix) {\n      mat4.copy(tmpMatrix, model.viewMatrix);\n      publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);\n      mat4.transpose(model.viewMatrix, model.viewMatrix);\n    }\n  };\n  publicAPI.getViewMatrix = () => {\n    if (model.viewMatrix) {\n      return model.viewMatrix;\n    }\n    mat4.lookAt(tmpMatrix, model.position,\n    // eye\n    model.focalPoint,\n    // at\n    model.viewUp // up\n    );\n\n    mat4.transpose(tmpMatrix, tmpMatrix);\n    const result = new Float64Array(16);\n    mat4.copy(result, tmpMatrix);\n    return result;\n  };\n  publicAPI.setProjectionMatrix = mat => {\n    model.projectionMatrix = mat;\n  };\n  publicAPI.getProjectionMatrix = (aspect, nearz, farz) => {\n    const result = new Float64Array(16);\n    mat4.identity(result);\n    if (model.projectionMatrix) {\n      const scale = 1 / model.physicalScale;\n      vec3.set(tmpvec1, scale, scale, scale);\n      mat4.copy(result, model.projectionMatrix);\n      mat4.scale(result, result, tmpvec1);\n      mat4.transpose(result, result);\n      return result;\n    }\n    mat4.identity(tmpMatrix);\n\n    // FIXME: Not sure what to do about adjust z buffer here\n    // adjust Z-buffer range\n    // this->ProjectionTransform->AdjustZBuffer( -1, +1, nearz, farz );\n    const cWidth = model.clippingRange[1] - model.clippingRange[0];\n    const cRange = [model.clippingRange[0] + (nearz + 1) * cWidth / 2.0, model.clippingRange[0] + (farz + 1) * cWidth / 2.0];\n    if (model.parallelProjection) {\n      // set up a rectangular parallelipiped\n      const width = model.parallelScale * aspect;\n      const height = model.parallelScale;\n      const xmin = (model.windowCenter[0] - 1.0) * width;\n      const xmax = (model.windowCenter[0] + 1.0) * width;\n      const ymin = (model.windowCenter[1] - 1.0) * height;\n      const ymax = (model.windowCenter[1] + 1.0) * height;\n      mat4.ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);\n      mat4.transpose(tmpMatrix, tmpMatrix);\n    } else if (model.useOffAxisProjection) {\n      throw new Error('Off-Axis projection is not supported at this time');\n    } else {\n      const tmp = Math.tan(radiansFromDegrees(model.viewAngle) / 2.0);\n      let width;\n      let height;\n      if (model.useHorizontalViewAngle === true) {\n        width = model.clippingRange[0] * tmp;\n        height = model.clippingRange[0] * tmp / aspect;\n      } else {\n        width = model.clippingRange[0] * tmp * aspect;\n        height = model.clippingRange[0] * tmp;\n      }\n      const xmin = (model.windowCenter[0] - 1.0) * width;\n      const xmax = (model.windowCenter[0] + 1.0) * width;\n      const ymin = (model.windowCenter[1] - 1.0) * height;\n      const ymax = (model.windowCenter[1] + 1.0) * height;\n      const znear = cRange[0];\n      const zfar = cRange[1];\n      tmpMatrix[0] = 2.0 * znear / (xmax - xmin);\n      tmpMatrix[5] = 2.0 * znear / (ymax - ymin);\n      tmpMatrix[2] = (xmin + xmax) / (xmax - xmin);\n      tmpMatrix[6] = (ymin + ymax) / (ymax - ymin);\n      tmpMatrix[10] = -(znear + zfar) / (zfar - znear);\n      tmpMatrix[14] = -1.0;\n      tmpMatrix[11] = -2.0 * znear * zfar / (zfar - znear);\n      tmpMatrix[15] = 0.0;\n    }\n    mat4.copy(result, tmpMatrix);\n    return result;\n  };\n  publicAPI.getCompositeProjectionMatrix = (aspect, nearz, farz) => {\n    const vMat = publicAPI.getViewMatrix();\n    const pMat = publicAPI.getProjectionMatrix(aspect, nearz, farz);\n    // mats are transposed so the order is A then B\n    // we reuse pMat as it is a copy so we can do what we want with it\n    mat4.multiply(pMat, vMat, pMat);\n    return pMat;\n  };\n  publicAPI.setDirectionOfProjection = (x, y, z) => {\n    if (model.directionOfProjection[0] === x && model.directionOfProjection[1] === y && model.directionOfProjection[2] === z) {\n      return;\n    }\n    model.directionOfProjection[0] = x;\n    model.directionOfProjection[1] = y;\n    model.directionOfProjection[2] = z;\n    const vec = model.directionOfProjection;\n\n    // recalculate FocalPoint\n    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    computeViewPlaneNormal();\n  };\n\n  // used to handle convert js device orientation angles\n  // when you use this method the camera will adjust to the\n  // device orientation such that the physicalViewUp you set\n  // in world coordinates looks up, and the physicalViewNorth\n  // you set in world coorindates will (maybe) point north\n  //\n  // NOTE WARNING - much of the documentation out there on how\n  // orientation works is seriously wrong. Even worse the Chrome\n  // device orientation simulator is completely wrong and should\n  // never be used. OMG it is so messed up.\n  //\n  // how it seems to work on iOS is that the device orientation\n  // is specified in extrinsic angles with a alpha, beta, gamma\n  // convention with axes of Z, X, Y (the code below substitutes\n  // the physical coordinate system for these axes to get the right\n  // modified coordinate system.\n  publicAPI.setDeviceAngles = (alpha, beta, gamma, screen) => {\n    const physVRight = [3];\n    cross(model.physicalViewNorth, model.physicalViewUp, physVRight);\n\n    // phone to physical coordinates\n    const rotmat = mat4.identity(new Float64Array(16));\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(alpha), model.physicalViewUp);\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(beta), physVRight);\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(gamma), model.physicalViewNorth);\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(-screen), model.physicalViewUp);\n    const dop = new Float64Array([-model.physicalViewUp[0], -model.physicalViewUp[1], -model.physicalViewUp[2]]);\n    const vup = new Float64Array(model.physicalViewNorth);\n    vec3.transformMat4(dop, dop, rotmat);\n    vec3.transformMat4(vup, vup, rotmat);\n    publicAPI.setDirectionOfProjection(dop[0], dop[1], dop[2]);\n    publicAPI.setViewUp(vup[0], vup[1], vup[2]);\n    publicAPI.modified();\n  };\n  publicAPI.setOrientationWXYZ = (degrees, x, y, z) => {\n    const quatMat = mat4.identity(new Float64Array(16));\n    if (degrees !== 0.0 && (x !== 0.0 || y !== 0.0 || z !== 0.0)) {\n      // convert to radians\n      const angle = radiansFromDegrees(degrees);\n      const q = quat.create();\n      quat.setAxisAngle(q, [x, y, z], angle);\n      mat4.fromQuat(quatMat, q);\n    }\n    const newdop = new Float64Array(3);\n    vec3.transformMat4(newdop, [0.0, 0.0, -1.0], quatMat);\n    const newvup = new Float64Array(3);\n    vec3.transformMat4(newvup, [0.0, 1.0, 0.0], quatMat);\n    publicAPI.setDirectionOfProjection(...newdop);\n    publicAPI.setViewUp(...newvup);\n    publicAPI.modified();\n  };\n  publicAPI.computeClippingRange = bounds => {\n    let vn = null;\n    let position = null;\n    vn = model.viewPlaneNormal;\n    position = model.position;\n    const a = -vn[0];\n    const b = -vn[1];\n    const c = -vn[2];\n    const d = -(a * position[0] + b * position[1] + c * position[2]);\n\n    // Set the max near clipping plane and the min far clipping plane\n    const range = [a * bounds[0] + b * bounds[2] + c * bounds[4] + d, 1e-18];\n\n    // Find the closest / farthest bounding box vertex\n    for (let k = 0; k < 2; k++) {\n      for (let j = 0; j < 2; j++) {\n        for (let i = 0; i < 2; i++) {\n          const dist = a * bounds[i] + b * bounds[2 + j] + c * bounds[4 + k] + d;\n          range[0] = dist < range[0] ? dist : range[0];\n          range[1] = dist > range[1] ? dist : range[1];\n        }\n      }\n    }\n    return range;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  position: [0, 0, 1],\n  focalPoint: [0, 0, 0],\n  viewUp: [0, 1, 0],\n  directionOfProjection: [0, 0, -1],\n  parallelProjection: false,\n  useHorizontalViewAngle: false,\n  viewAngle: 30,\n  parallelScale: 1,\n  clippingRange: [0.01, 1000.01],\n  windowCenter: [0, 0],\n  viewPlaneNormal: [0, 0, 1],\n  useOffAxisProjection: false,\n  screenBottomLeft: [-0.5, -0.5, -0.5],\n  screenBottomRight: [0.5, -0.5, -0.5],\n  screenTopRight: [0.5, 0.5, -0.5],\n  freezeFocalPoint: false,\n  projectionMatrix: null,\n  viewMatrix: null,\n  cameraLightTransform: mat4.create(),\n  // used for world to physical transformations\n  physicalTranslation: [0, 0, 0],\n  physicalScale: 1.0,\n  physicalViewUp: [0, 1, 0],\n  physicalViewNorth: [0, 0, -1]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['distance']);\n  macro.setGet(publicAPI, model, ['parallelProjection', 'useHorizontalViewAngle', 'viewAngle', 'parallelScale', 'useOffAxisProjection', 'freezeFocalPoint', 'physicalScale']);\n  macro.getArray(publicAPI, model, ['directionOfProjection', 'viewPlaneNormal', 'position', 'focalPoint']);\n  macro.setGetArray(publicAPI, model, ['clippingRange', 'windowCenter'], 2);\n  macro.setGetArray(publicAPI, model, ['viewUp', 'screenBottomLeft', 'screenBottomRight', 'screenTopRight', 'physicalTranslation', 'physicalViewUp', 'physicalViewNorth'], 3);\n\n  // Object methods\n  vtkCamera(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCamera');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCamera$1 = {\n  newInstance,\n  extend\n};\n\nexport { DEFAULT_VALUES, vtkCamera$1 as default, extend, newInstance };\n","import { m as macro } from '../../macros2.js';\nimport { h as hsv2rgb, i as isNan, J as floor, K as isInf, L as rgb2hsv, M as rgb2lab, N as lab2rgb } from '../../Common/Core/Math/index.js';\nimport vtkScalarsToColors from '../../Common/Core/ScalarsToColors.js';\nimport Constants from './ColorTransferFunction/Constants.js';\n\nconst {\n  ColorSpace,\n  Scale\n} = Constants;\nconst {\n  ScalarMappingTarget\n} = vtkScalarsToColors;\nconst {\n  vtkDebugMacro,\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n/* eslint-disable no-continue                                                */\n\n// Convert to and from a special polar version of CIELAB (useful for creating\n// continuous diverging color maps).\nfunction vtkColorTransferFunctionLabToMsh(lab, msh) {\n  const L = lab[0];\n  const a = lab[1];\n  const b = lab[2];\n  const M = Math.sqrt(L * L + a * a + b * b);\n  const s = M > 0.001 ? Math.acos(L / M) : 0.0;\n  const h = s > 0.001 ? Math.atan2(b, a) : 0.0;\n  msh[0] = M;\n  msh[1] = s;\n  msh[2] = h;\n}\nfunction vtkColorTransferFunctionMshToLab(msh, lab) {\n  const M = msh[0];\n  const s = msh[1];\n  const h = msh[2];\n  lab[0] = M * Math.cos(s);\n  lab[1] = M * Math.sin(s) * Math.cos(h);\n  lab[2] = M * Math.sin(s) * Math.sin(h);\n}\n\n// For the case when interpolating from a saturated color to an unsaturated\n// color, find a hue for the unsaturated color that makes sense.\nfunction vtkColorTransferFunctionAdjustHue(msh, unsatM) {\n  if (msh[0] >= unsatM - 0.1) {\n    // The best we can do is hold hue constant.\n    return msh[2];\n  }\n\n  // This equation is designed to make the perceptual change of the\n  // interpolation to be close to constant.\n  const hueSpin = msh[1] * Math.sqrt(unsatM * unsatM - msh[0] * msh[0]) / (msh[0] * Math.sin(msh[1]));\n  // Spin hue away from 0 except in purple hues.\n  if (msh[2] > -0.3 * Math.PI) {\n    return msh[2] + hueSpin;\n  }\n  return msh[2] - hueSpin;\n}\nfunction vtkColorTransferFunctionAngleDiff(a1, a2) {\n  let adiff = a1 - a2;\n  if (adiff < 0.0) {\n    adiff = -adiff;\n  }\n  while (adiff >= 2.0 * Math.PI) {\n    adiff -= 2.0 * Math.PI;\n  }\n  if (adiff > Math.PI) {\n    adiff = 2.0 * Math.PI - adiff;\n  }\n  return adiff;\n}\n\n// Interpolate a diverging color map.\nfunction vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, result) {\n  const lab1 = [];\n  const lab2 = [];\n  rgb2lab(rgb1, lab1);\n  rgb2lab(rgb2, lab2);\n  const msh1 = [];\n  const msh2 = [];\n  vtkColorTransferFunctionLabToMsh(lab1, msh1);\n  vtkColorTransferFunctionLabToMsh(lab2, msh2);\n\n  // If the endpoints are distinct saturated colors, then place white in between\n  // them.\n  let localS = s;\n  if (msh1[1] > 0.05 && msh2[1] > 0.05 && vtkColorTransferFunctionAngleDiff(msh1[2], msh2[2]) > 0.33 * Math.PI) {\n    // Insert the white midpoint by setting one end to white and adjusting the\n    // scalar value.\n    let Mmid = Math.max(msh1[0], msh2[0]);\n    Mmid = Math.max(88.0, Mmid);\n    if (s < 0.5) {\n      msh2[0] = Mmid;\n      msh2[1] = 0.0;\n      msh2[2] = 0.0;\n      localS *= 2.0;\n    } else {\n      msh1[0] = Mmid;\n      msh1[1] = 0.0;\n      msh1[2] = 0.0;\n      localS = 2.0 * localS - 1.0;\n    }\n  }\n\n  // If one color has no saturation, then its hue value is invalid.  In this\n  // case, we want to set it to something logical so that the interpolation of\n  // hue makes sense.\n  if (msh1[1] < 0.05 && msh2[1] > 0.05) {\n    msh1[2] = vtkColorTransferFunctionAdjustHue(msh2, msh1[0]);\n  } else if (msh2[1] < 0.05 && msh1[1] > 0.05) {\n    msh2[2] = vtkColorTransferFunctionAdjustHue(msh1, msh2[0]);\n  }\n  const mshTmp = [];\n  mshTmp[0] = (1 - localS) * msh1[0] + localS * msh2[0];\n  mshTmp[1] = (1 - localS) * msh1[1] + localS * msh2[1];\n  mshTmp[2] = (1 - localS) * msh1[2] + localS * msh2[2];\n\n  // Now convert back to RGB\n  const labTmp = [];\n  vtkColorTransferFunctionMshToLab(mshTmp, labTmp);\n  lab2rgb(labTmp, result);\n}\n\n// ----------------------------------------------------------------------------\n// vtkColorTransferFunction methods\n// ----------------------------------------------------------------------------\n\nfunction vtkColorTransferFunction(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkColorTransferFunction');\n\n  // Return the number of points which specify this function\n  publicAPI.getSize = () => model.nodes.length;\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n  publicAPI.addRGBPoint = (x, r, g, b) => publicAPI.addRGBPointLong(x, r, g, b, 0.5, 0.0);\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n  publicAPI.addRGBPointLong = function (x, r, g, b) {\n    let midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    let sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;\n    // Error check\n    if (midpoint < 0.0 || midpoint > 1.0) {\n      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');\n      return -1;\n    }\n    if (sharpness < 0.0 || sharpness > 1.0) {\n      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');\n      return -1;\n    }\n\n    // remove any node already at this X location\n    if (!model.allowDuplicateScalars) {\n      publicAPI.removePoint(x);\n    }\n\n    // Create the new node\n    const node = {\n      x,\n      r,\n      g,\n      b,\n      midpoint,\n      sharpness\n    };\n\n    // Add it, then sort to get everything in order\n    model.nodes.push(node);\n    publicAPI.sortAndUpdateRange();\n\n    // We need to find the index of the node we just added in order\n    // to return this value\n    let i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    // If we didn't find it, something went horribly wrong so\n    // return -1\n    if (i < model.nodes.length) {\n      return i;\n    }\n    return -1;\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n  publicAPI.addHSVPoint = (x, h, s, v) => publicAPI.addHSVPointLong(x, h, s, v, 0.5, 0.0);\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n  publicAPI.addHSVPointLong = function (x, h, s, v) {\n    let midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    let sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;\n    const rgb = [];\n    const hsv = [h, s, v];\n    hsv2rgb(hsv, rgb);\n    return publicAPI.addRGBPoint(x, rgb[0], rgb[1], rgb[2], midpoint, sharpness);\n  };\n\n  //----------------------------------------------------------------------------\n  // Set nodes directly\n  publicAPI.setNodes = nodes => {\n    if (model.nodes !== nodes) {\n      const before = JSON.stringify(model.nodes);\n      model.nodes = nodes;\n      const after = JSON.stringify(model.nodes);\n      if (publicAPI.sortAndUpdateRange() || before !== after) {\n        publicAPI.modified();\n        return true;\n      }\n    }\n    return false;\n  };\n\n  //----------------------------------------------------------------------------\n  // Sort the vector in increasing order, then fill in\n  // the Range\n  publicAPI.sortAndUpdateRange = () => {\n    const before = JSON.stringify(model.nodes);\n    model.nodes.sort((a, b) => a.x - b.x);\n    const after = JSON.stringify(model.nodes);\n    const modifiedInvoked = publicAPI.updateRange();\n    // If range is updated, Modified() has been called, don't call it again.\n    if (!modifiedInvoked && before !== after) {\n      publicAPI.modified();\n      return true;\n    }\n    return modifiedInvoked;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.updateRange = () => {\n    const oldRange = [2];\n    oldRange[0] = model.mappingRange[0];\n    oldRange[1] = model.mappingRange[1];\n    const size = model.nodes.length;\n    if (size) {\n      model.mappingRange[0] = model.nodes[0].x;\n      model.mappingRange[1] = model.nodes[size - 1].x;\n    } else {\n      model.mappingRange[0] = 0;\n      model.mappingRange[1] = 0;\n    }\n\n    // If the range is the same, then no need to call Modified()\n    if (oldRange[0] === model.mappingRange[0] && oldRange[1] === model.mappingRange[1]) {\n      return false;\n    }\n    publicAPI.modified();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  // Remove a point\n  publicAPI.removePoint = x => {\n    // First find the node since we need to know its\n    // index as our return value\n    let i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n    const retVal = i;\n\n    // If the node doesn't exist, we return -1\n    if (i >= model.nodes.length) {\n      return -1;\n    }\n\n    // If the first or last point has been removed, then we update the range\n    // No need to sort here as the order of points hasn't changed.\n    let modifiedInvoked = false;\n    model.nodes.splice(i, 1);\n    if (i === 0 || i === model.nodes.length) {\n      modifiedInvoked = publicAPI.updateRange();\n    }\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n    return retVal;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.movePoint = (oldX, newX) => {\n    if (oldX === newX) {\n      // Nothing to do.\n      return;\n    }\n    publicAPI.removePoint(newX);\n    for (let i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === oldX) {\n        model.nodes[i].x = newX;\n        publicAPI.sortAndUpdateRange();\n        break;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  // Remove all points\n  publicAPI.removeAllPoints = () => {\n    model.nodes = [];\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a line defined in RGB\n  publicAPI.addRGBSegment = (x1, r1, g1, b1, x2, r2, g2, b2) => {\n    // First, find all points in this range and remove them\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {\n        model.nodes.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n\n    // Now add the points\n    publicAPI.addRGBPointLong(x1, r1, g1, b1, 0.5, 0.0);\n    publicAPI.addRGBPointLong(x2, r2, g2, b2, 0.5, 0.0);\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a line defined in HSV\n  publicAPI.addHSVSegment = (x1, h1, s1, v1, x2, h2, s2, v2) => {\n    const hsv1 = [h1, s1, v1];\n    const hsv2 = [h2, s2, v2];\n    const rgb1 = [];\n    const rgb2 = [];\n    hsv2rgb(hsv1, rgb1);\n    hsv2rgb(hsv2, rgb2);\n    publicAPI.addRGBSegment(x1, rgb1[0], rgb1[1], rgb1[2], x2, rgb2[0], rgb2[1], rgb2[2]);\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the RGBA color evaluated at the specified location\n  publicAPI.mapValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return [Math.floor(255.0 * rgb[0] + 0.5), Math.floor(255.0 * rgb[1] + 0.5), Math.floor(255.0 * rgb[2] + 0.5), 255];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the RGB color evaluated at the specified location\n  publicAPI.getColor = (x, rgb) => {\n    if (model.indexedLookup) {\n      const numNodes = publicAPI.getSize();\n      // todo\n      const idx = publicAPI.getAnnotatedValueIndexInternal(x);\n      if (idx < 0 || numNodes === 0) {\n        const nanColor = publicAPI.getNanColorByReference();\n        rgb[0] = nanColor[0];\n        rgb[1] = nanColor[1];\n        rgb[2] = nanColor[2];\n      } else {\n        const nodeVal = [];\n        publicAPI.getNodeValue(idx % numNodes, nodeVal);\n        // nodeVal[0] is the x value. nodeVal[1...3] is rgb.\n        rgb[0] = nodeVal[1];\n        rgb[1] = nodeVal[2];\n        rgb[2] = nodeVal[3];\n      }\n      return;\n    }\n    publicAPI.getTable(x, x, 1, rgb);\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the red color evaluated at the specified location\n  publicAPI.getRedValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[0];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the green color evaluated at the specified location\n  publicAPI.getGreenValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[1];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the blue color evaluated at the specified location\n  publicAPI.getBlueValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[2];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns a table of RGB colors at regular intervals along the function\n  publicAPI.getTable = (xStart_, xEnd_, size, table) => {\n    // To handle BigInt limitation\n    const xStart = Number(xStart_);\n    const xEnd = Number(xEnd_);\n\n    // Special case: If either the start or end is a NaN, then all any\n    // interpolation done on them is also a NaN.  Therefore, fill the table with\n    // the NaN color.\n    if (isNan(xStart) || isNan(xEnd)) {\n      for (let i = 0; i < size; i++) {\n        table[i * 3 + 0] = model.nanColor[0];\n        table[i * 3 + 1] = model.nanColor[1];\n        table[i * 3 + 2] = model.nanColor[2];\n      }\n      return;\n    }\n    let idx = 0;\n    const numNodes = model.nodes.length;\n\n    // Need to keep track of the last value so that\n    // we can fill in table locations past this with\n    // this value if Clamping is On.\n    let lastR = 0.0;\n    let lastG = 0.0;\n    let lastB = 0.0;\n    if (numNodes !== 0) {\n      lastR = model.nodes[numNodes - 1].r;\n      lastG = model.nodes[numNodes - 1].g;\n      lastB = model.nodes[numNodes - 1].b;\n    }\n    let x = 0.0;\n    let x1 = 0.0;\n    let x2 = 0.0;\n    const rgb1 = [0.0, 0.0, 0.0];\n    const rgb2 = [0.0, 0.0, 0.0];\n    let midpoint = 0.0;\n    let sharpness = 0.0;\n    const tmpVec = [];\n\n    // If the scale is logarithmic, make sure the range is valid.\n    let usingLogScale = model.scale === Scale.LOG10;\n    if (usingLogScale) {\n      // Note: This requires range[0] <= range[1].\n      usingLogScale = model.mappingRange[0] > 0.0;\n    }\n    let logStart = 0.0;\n    let logEnd = 0.0;\n    let logX = 0.0;\n    if (usingLogScale) {\n      logStart = Math.log10(xStart);\n      logEnd = Math.log10(xEnd);\n    }\n\n    // For each table entry\n    for (let i = 0; i < size; i++) {\n      // Find our location in the table\n      const tidx = 3 * i;\n\n      // Find our X location. If we are taking only 1 sample, make\n      // it halfway between start and end (usually start and end will\n      // be the same in this case)\n      if (size > 1) {\n        if (usingLogScale) {\n          logX = logStart + i / (size - 1.0) * (logEnd - logStart);\n          x = 10.0 ** logX;\n        } else {\n          x = xStart + i / (size - 1.0) * (xEnd - xStart);\n        }\n      } else if (usingLogScale) {\n        logX = 0.5 * (logStart + logEnd);\n        x = 10.0 ** logX;\n      } else {\n        x = 0.5 * (xStart + xEnd);\n      }\n\n      // Linearly map x from mappingRange to [0, numberOfValues-1],\n      // discretize (round down to the closest integer),\n      // then map back to mappingRange\n      if (model.discretize) {\n        const range = model.mappingRange;\n        if (x >= range[0] && x <= range[1]) {\n          const numberOfValues = model.numberOfValues;\n          const deltaRange = range[1] - range[0];\n          if (numberOfValues <= 1) {\n            x = range[0] + deltaRange / 2.0;\n          } else {\n            // normalize x\n            const xn = (x - range[0]) / deltaRange;\n            // discretize\n            const discretizeIndex = floor(numberOfValues * xn);\n            // get discretized x\n            x = range[0] + discretizeIndex / (numberOfValues - 1) * deltaRange;\n          }\n        }\n      }\n\n      // Do we need to move to the next node?\n      while (idx < numNodes && x > model.nodes[idx].x) {\n        idx++;\n        // If we are at a valid point index, fill in\n        // the value at this node, and the one before (the\n        // two that surround our current sample location)\n        // idx cannot be 0 since we just incremented it.\n        if (idx < numNodes) {\n          x1 = model.nodes[idx - 1].x;\n          x2 = model.nodes[idx].x;\n          if (usingLogScale) {\n            x1 = Math.log10(x1);\n            x2 = Math.log10(x2);\n          }\n          rgb1[0] = model.nodes[idx - 1].r;\n          rgb2[0] = model.nodes[idx].r;\n          rgb1[1] = model.nodes[idx - 1].g;\n          rgb2[1] = model.nodes[idx].g;\n          rgb1[2] = model.nodes[idx - 1].b;\n          rgb2[2] = model.nodes[idx].b;\n\n          // We only need the previous midpoint and sharpness\n          // since these control this region\n          midpoint = model.nodes[idx - 1].midpoint;\n          sharpness = model.nodes[idx - 1].sharpness;\n\n          // Move midpoint away from extreme ends of range to avoid\n          // degenerate math\n          if (midpoint < 0.00001) {\n            midpoint = 0.00001;\n          }\n          if (midpoint > 0.99999) {\n            midpoint = 0.99999;\n          }\n        }\n      }\n\n      // Are we at or past the end? If so, just use the last value\n      if (x > model.mappingRange[1]) {\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n        if (model.clamping) {\n          if (publicAPI.getUseAboveRangeColor()) {\n            table[tidx] = model.aboveRangeColor[0];\n            table[tidx + 1] = model.aboveRangeColor[1];\n            table[tidx + 2] = model.aboveRangeColor[2];\n          } else {\n            table[tidx] = lastR;\n            table[tidx + 1] = lastG;\n            table[tidx + 2] = lastB;\n          }\n        }\n      } else if (x < model.mappingRange[0] || isInf(x) && x < 0) {\n        // we are before the first node? If so, duplicate this node's values.\n        // We have to deal with -inf here\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n        if (model.clamping) {\n          if (publicAPI.getUseBelowRangeColor()) {\n            table[tidx] = model.belowRangeColor[0];\n            table[tidx + 1] = model.belowRangeColor[1];\n            table[tidx + 2] = model.belowRangeColor[2];\n          } else if (numNodes > 0) {\n            table[tidx] = model.nodes[0].r;\n            table[tidx + 1] = model.nodes[0].g;\n            table[tidx + 2] = model.nodes[0].b;\n          }\n        }\n      } else if (idx === 0 && (Math.abs(x - xStart) < 1e-6 || model.discretize)) {\n        if (numNodes > 0) {\n          table[tidx] = model.nodes[0].r;\n          table[tidx + 1] = model.nodes[0].g;\n          table[tidx + 2] = model.nodes[0].b;\n        } else {\n          table[tidx] = 0.0;\n          table[tidx + 1] = 0.0;\n          table[tidx + 2] = 0.0;\n        }\n      } else {\n        // OK, we are between two nodes - interpolate\n        // Our first attempt at a normalized location [0,1] -\n        // we will be modifying this based on midpoint and\n        // sharpness to get the curve shape we want and to have\n        // it pass through (y1+y2)/2 at the midpoint.\n        let s = 0.0;\n        if (usingLogScale) {\n          s = (logX - x1) / (x2 - x1);\n        } else {\n          s = (x - x1) / (x2 - x1);\n        }\n\n        // Readjust based on the midpoint - linear adjustment\n        if (s < midpoint) {\n          s = 0.5 * s / midpoint;\n        } else {\n          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);\n        }\n\n        // override for sharpness > 0.99\n        // In this case we just want piecewise constant\n        if (sharpness > 0.99) {\n          // Use the first value since we are below the midpoint\n          if (s < 0.5) {\n            table[tidx] = rgb1[0];\n            table[tidx + 1] = rgb1[1];\n            table[tidx + 2] = rgb1[2];\n            continue;\n          } else {\n            // Use the second value at or above the midpoint\n            table[tidx] = rgb2[0];\n            table[tidx + 1] = rgb2[1];\n            table[tidx + 2] = rgb2[2];\n            continue;\n          }\n        }\n\n        // Override for sharpness < 0.01\n        // In this case we want piecewise linear\n        if (sharpness < 0.01) {\n          // Simple linear interpolation\n          if (model.colorSpace === ColorSpace.RGB) {\n            table[tidx] = (1 - s) * rgb1[0] + s * rgb2[0];\n            table[tidx + 1] = (1 - s) * rgb1[1] + s * rgb2[1];\n            table[tidx + 2] = (1 - s) * rgb1[2] + s * rgb2[2];\n          } else if (model.colorSpace === ColorSpace.HSV) {\n            const hsv1 = [];\n            const hsv2 = [];\n            rgb2hsv(rgb1, hsv1);\n            rgb2hsv(rgb2, hsv2);\n            if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {\n              if (hsv1[0] > hsv2[0]) {\n                hsv1[0] -= 1.0;\n              } else {\n                hsv2[0] -= 1.0;\n              }\n            }\n            const hsvTmp = [];\n            hsvTmp[0] = (1.0 - s) * hsv1[0] + s * hsv2[0];\n            if (hsvTmp[0] < 0.0) {\n              hsvTmp[0] += 1.0;\n            }\n            hsvTmp[1] = (1.0 - s) * hsv1[1] + s * hsv2[1];\n            hsvTmp[2] = (1.0 - s) * hsv1[2] + s * hsv2[2];\n\n            // Now convert this back to RGB\n            hsv2rgb(hsvTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.LAB) {\n            const lab1 = [];\n            const lab2 = [];\n            rgb2lab(rgb1, lab1);\n            rgb2lab(rgb2, lab2);\n            const labTmp = [];\n            labTmp[0] = (1 - s) * lab1[0] + s * lab2[0];\n            labTmp[1] = (1 - s) * lab1[1] + s * lab2[1];\n            labTmp[2] = (1 - s) * lab1[2] + s * lab2[2];\n\n            // Now convert back to RGB\n            lab2rgb(labTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.DIVERGING) {\n            vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else {\n            vtkErrorMacro('ColorSpace set to invalid value.', model.colorSpace);\n          }\n          continue;\n        }\n\n        // We have a sharpness between [0.01, 0.99] - we will\n        // used a modified hermite curve interpolation where we\n        // derive the slope based on the sharpness, and we compress\n        // the curve non-linearly based on the sharpness\n\n        // First, we will adjust our position based on sharpness in\n        // order to make the curve sharper (closer to piecewise constant)\n        if (s < 0.5) {\n          s = 0.5 * (s * 2.0) ** (1.0 + 10.0 * sharpness);\n        } else if (s > 0.5) {\n          s = 1.0 - 0.5 * ((1.0 - s) * 2) ** (1 + 10.0 * sharpness);\n        }\n\n        // Compute some coefficients we will need for the hermite curve\n        const ss = s * s;\n        const sss = ss * s;\n        const h1 = 2.0 * sss - 3 * ss + 1;\n        const h2 = -2 * sss + 3 * ss;\n        const h3 = sss - 2 * ss + s;\n        const h4 = sss - ss;\n        let slope;\n        let t;\n        if (model.colorSpace === ColorSpace.RGB) {\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = rgb2[j] - rgb1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            table[tidx + j] = h1 * rgb1[j] + h2 * rgb2[j] + h3 * t + h4 * t;\n          }\n        } else if (model.colorSpace === ColorSpace.HSV) {\n          const hsv1 = [];\n          const hsv2 = [];\n          rgb2hsv(rgb1, hsv1);\n          rgb2hsv(rgb2, hsv2);\n          if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {\n            if (hsv1[0] > hsv2[0]) {\n              hsv1[0] -= 1.0;\n            } else {\n              hsv2[0] -= 1.0;\n            }\n          }\n          const hsvTmp = [];\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = hsv2[j] - hsv1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            hsvTmp[j] = h1 * hsv1[j] + h2 * hsv2[j] + h3 * t + h4 * t;\n            if (j === 0 && hsvTmp[j] < 0.0) {\n              hsvTmp[j] += 1.0;\n            }\n          }\n          // Now convert this back to RGB\n          hsv2rgb(hsvTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.LAB) {\n          const lab1 = [];\n          const lab2 = [];\n          rgb2lab(rgb1, lab1);\n          rgb2lab(rgb2, lab2);\n          const labTmp = [];\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = lab2[j] - lab1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            labTmp[j] = h1 * lab1[j] + h2 * lab2[j] + h3 * t + h4 * t;\n          }\n          // Now convert this back to RGB\n          lab2rgb(labTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.DIVERGING) {\n          // I have not implemented proper interpolation by a hermite curve for\n          // the diverging color map, but I cannot think of a good use case for\n          // that anyway.\n          vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else {\n          vtkErrorMacro('ColorSpace set to invalid value.');\n        }\n\n        // Final error check to make sure we don't go outside [0,1]\n        for (let j = 0; j < 3; j++) {\n          table[tidx + j] = table[tidx + j] < 0.0 ? 0.0 : table[tidx + j];\n          table[tidx + j] = table[tidx + j] > 1.0 ? 1.0 : table[tidx + j];\n        }\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getUint8Table = function (xStart, xEnd, size) {\n    let withAlpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (publicAPI.getMTime() <= model.buildTime && model.tableSize === size && model.tableWithAlpha !== withAlpha) {\n      return model.table;\n    }\n    if (model.nodes.length === 0) {\n      vtkErrorMacro('Attempting to lookup a value with no points in the function');\n      return model.table;\n    }\n    const nbChannels = withAlpha ? 4 : 3;\n    if (model.tableSize !== size || model.tableWithAlpha !== withAlpha) {\n      model.table = new Uint8Array(size * nbChannels);\n      model.tableSize = size;\n      model.tableWithAlpha = withAlpha;\n    }\n    const tmpTable = [];\n    publicAPI.getTable(xStart, xEnd, size, tmpTable);\n    for (let i = 0; i < size; i++) {\n      model.table[i * nbChannels + 0] = Math.floor(tmpTable[i * 3 + 0] * 255.0 + 0.5);\n      model.table[i * nbChannels + 1] = Math.floor(tmpTable[i * 3 + 1] * 255.0 + 0.5);\n      model.table[i * nbChannels + 2] = Math.floor(tmpTable[i * 3 + 2] * 255.0 + 0.5);\n      if (withAlpha) {\n        model.table[i * nbChannels + 3] = 255;\n      }\n    }\n    model.buildTime.modified();\n    return model.table;\n  };\n  publicAPI.buildFunctionFromArray = array => {\n    publicAPI.removeAllPoints();\n    const numComponents = array.getNumberOfComponents();\n    for (let i = 0; i < array.getNumberOfTuples(); i++) {\n      switch (numComponents) {\n        case 3:\n          {\n            model.nodes.push({\n              x: i,\n              r: array.getComponent(i, 0),\n              g: array.getComponent(i, 1),\n              b: array.getComponent(i, 2),\n              midpoint: 0.5,\n              sharpness: 0.0\n            });\n            break;\n          }\n        case 4:\n          {\n            model.nodes.push({\n              x: array.getComponent(i, 0),\n              r: array.getComponent(i, 1),\n              g: array.getComponent(i, 2),\n              b: array.getComponent(i, 3),\n              midpoint: 0.5,\n              sharpness: 0.0\n            });\n            break;\n          }\n        case 5:\n          {\n            model.nodes.push({\n              x: i,\n              r: array.getComponent(i, 0),\n              g: array.getComponent(i, 1),\n              b: array.getComponent(i, 2),\n              midpoint: array.getComponent(i, 4),\n              sharpness: array.getComponent(i, 5)\n            });\n            break;\n          }\n        case 6:\n          {\n            model.nodes.push({\n              x: array.getComponent(i, 0),\n              r: array.getComponent(i, 1),\n              g: array.getComponent(i, 2),\n              b: array.getComponent(i, 3),\n              midpoint: array.getComponent(i, 4),\n              sharpness: array.getComponent(i, 5)\n            });\n            break;\n          }\n      }\n    }\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.buildFunctionFromTable = (xStart, xEnd, size, table) => {\n    let inc = 0.0;\n    publicAPI.removeAllPoints();\n    if (size > 1) {\n      inc = (xEnd - xStart) / (size - 1.0);\n    }\n    for (let i = 0; i < size; i++) {\n      const node = {\n        x: xStart + inc * i,\n        r: table[i * 3],\n        g: table[i * 3 + 1],\n        b: table[i * 3 + 2],\n        sharpness: 0.0,\n        midpoint: 0.5\n      };\n      model.nodes.push(node);\n    }\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n  publicAPI.getNodeValue = (index, val) => {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    val[0] = model.nodes[index].x;\n    val[1] = model.nodes[index].r;\n    val[2] = model.nodes[index].g;\n    val[3] = model.nodes[index].b;\n    val[4] = model.nodes[index].midpoint;\n    val[5] = model.nodes[index].sharpness;\n    return 1;\n  };\n\n  //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n  publicAPI.setNodeValue = (index, val) => {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    const oldX = model.nodes[index].x;\n    model.nodes[index].x = val[0];\n    model.nodes[index].r = val[1];\n    model.nodes[index].g = val[2];\n    model.nodes[index].b = val[3];\n    model.nodes[index].midpoint = val[4];\n    model.nodes[index].sharpness = val[5];\n    if (oldX !== val[0]) {\n      // The point has been moved, the order of points or the range might have\n      // been modified.\n      publicAPI.sortAndUpdateRange();\n      // No need to call Modified() here because SortAndUpdateRange() has done it\n      // already.\n    } else {\n      publicAPI.modified();\n    }\n    return 1;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getNumberOfAvailableColors = () => {\n    if (model.indexedLookup && publicAPI.getSize()) {\n      return publicAPI.getSize();\n    }\n    if (model.tableSize) {\n      // Not sure if this is correct since it is only set if\n      // \"const unsigned char *::GetTable(double xStart, double xEnd,int size)\"\n      // has been called.\n      return model.tableSize;\n    }\n    return 16777216; // 2^24\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getIndexedColor = (idx, rgba) => {\n    const n = publicAPI.getSize();\n    if (n > 0 && idx >= 0) {\n      const nodeValue = [];\n      publicAPI.getNodeValue(idx % n, nodeValue);\n      for (let j = 0; j < 3; ++j) {\n        rgba[j] = nodeValue[j + 1];\n      }\n      rgba[3] = 1.0; // NodeColor is RGB-only.\n      return;\n    }\n    const nanColor = publicAPI.getNanColorByReference();\n    rgba[0] = nanColor[0];\n    rgba[1] = nanColor[1];\n    rgba[2] = nanColor[2];\n    rgba[3] = 1.0; // NanColor is RGB-only.\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.fillFromDataPointer = (nb, ptr) => {\n    if (nb <= 0 || !ptr) {\n      return;\n    }\n    publicAPI.removeAllPoints();\n    for (let i = 0; i < nb; i++) {\n      publicAPI.addRGBPoint(ptr[i * 4], ptr[i * 4 + 1], ptr[i * 4 + 2], ptr[i * 4 + 3]);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.setMappingRange = (min, max) => {\n    const range = [min, max];\n    const originalRange = publicAPI.getRange();\n    if (originalRange[1] === range[1] && originalRange[0] === range[0]) {\n      return;\n    }\n    if (range[1] === range[0]) {\n      vtkErrorMacro('attempt to set zero width color range');\n      return;\n    }\n    const scale = (range[1] - range[0]) / (originalRange[1] - originalRange[0]);\n    const shift = range[0] - originalRange[0] * scale;\n    for (let i = 0; i < model.nodes.length; ++i) {\n      model.nodes[i].x = model.nodes[i].x * scale + shift;\n    }\n    model.mappingRange[0] = range[0];\n    model.mappingRange[1] = range[1];\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.adjustRange = range => {\n    const functionRange = publicAPI.getRange();\n\n    // Make sure we have points at each end of the range\n    const rgb = [];\n    if (functionRange[0] < range[0]) {\n      publicAPI.getColor(range[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    }\n    if (functionRange[1] > range[1]) {\n      publicAPI.getColor(range[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    }\n\n    // Remove all points out-of-range\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {\n        model.nodes.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n    return 1;\n  };\n\n  //--------------------------------------------------------------------------\n  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {\n    const d = publicAPI.findMinimumXDistance();\n    return Math.ceil((x2 - x1) / d);\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.findMinimumXDistance = () => {\n    if (model.nodes.length < 2) {\n      return -1.0;\n    }\n    let distance = Number.MAX_VALUE;\n    for (let i = 0; i < model.nodes.length - 1; i++) {\n      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;\n      if (currentDist < distance) {\n        distance = currentDist;\n      }\n    }\n    return distance;\n  };\n  publicAPI.mapScalarsThroughTable = (input, output, outFormat, inputOffset) => {\n    if (publicAPI.getSize() === 0) {\n      vtkDebugMacro('Transfer Function Has No Points!');\n      return;\n    }\n    if (model.indexedLookup) {\n      publicAPI.mapDataIndexed(input, output, outFormat, inputOffset);\n    } else {\n      publicAPI.mapData(input, output, outFormat, inputOffset);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.mapData = (input, output, outFormat, inputOffset) => {\n    if (publicAPI.getSize() === 0) {\n      vtkWarningMacro('Transfer Function Has No Points!');\n      return;\n    }\n    const alpha = Math.floor(publicAPI.getAlpha() * 255.0 + 0.5);\n    const length = input.getNumberOfTuples();\n    const inIncr = input.getNumberOfComponents();\n    const outputV = output.getData();\n    const inputV = input.getData();\n    const rgb = [];\n    if (outFormat === ScalarMappingTarget.RGBA) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 4] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[i * 4 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[i * 4 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n        outputV[i * 4 + 3] = alpha;\n      }\n    }\n    if (outFormat === ScalarMappingTarget.RGB) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 3] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[i * 3 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[i * 3 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n      }\n    }\n    if (outFormat === ScalarMappingTarget.LUMINANCE) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);\n      }\n    }\n    if (outFormat === ScalarMappingTarget.LUMINANCE_ALPHA) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 2] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);\n        outputV[i * 2 + 1] = alpha;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.applyColorMap = colorMap => {\n    const oldColorSpace = JSON.stringify(model.colorSpace);\n    if (colorMap.ColorSpace) {\n      model.colorSpace = ColorSpace[colorMap.ColorSpace.toUpperCase()];\n      if (model.colorSpace === undefined) {\n        vtkErrorMacro(`ColorSpace ${colorMap.ColorSpace} not supported, using RGB instead`);\n        model.colorSpace = ColorSpace.RGB;\n      }\n    }\n    let isModified = oldColorSpace !== JSON.stringify(model.colorSpace);\n    const oldNanColor = isModified || JSON.stringify(model.nanColor);\n    if (colorMap.NanColor) {\n      model.nanColor = [].concat(colorMap.NanColor);\n      while (model.nanColor.length < 4) {\n        model.nanColor.push(1.0);\n      }\n    }\n    isModified = isModified || oldNanColor !== JSON.stringify(model.nanColor);\n    const oldNodes = isModified || JSON.stringify(model.nodes);\n    if (colorMap.RGBPoints) {\n      const size = colorMap.RGBPoints.length;\n      model.nodes = [];\n      const midpoint = 0.5;\n      const sharpness = 0.0;\n      for (let i = 0; i < size; i += 4) {\n        model.nodes.push({\n          x: colorMap.RGBPoints[i],\n          r: colorMap.RGBPoints[i + 1],\n          g: colorMap.RGBPoints[i + 2],\n          b: colorMap.RGBPoints[i + 3],\n          midpoint,\n          sharpness\n        });\n      }\n    }\n    const modifiedInvoked = publicAPI.sortAndUpdateRange();\n    const callModified = !modifiedInvoked && (isModified || oldNodes !== JSON.stringify(model.nodes));\n    if (callModified) publicAPI.modified();\n    return modifiedInvoked || callModified;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  clamping: true,\n  colorSpace: ColorSpace.RGB,\n  hSVWrap: true,\n  scale: Scale.LINEAR,\n  nanColor: null,\n  belowRangeColor: null,\n  aboveRangeColor: null,\n  useAboveRangeColor: false,\n  useBelowRangeColor: false,\n  allowDuplicateScalars: false,\n  table: null,\n  tableSize: 0,\n  buildTime: null,\n  nodes: null,\n  discretize: false,\n  numberOfValues: 256\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkScalarsToColors.extend(publicAPI, model, initialValues);\n\n  // Internal objects initialization\n  model.table = [];\n  model.nodes = [];\n  model.nanColor = [0.5, 0.0, 0.0, 1.0];\n  model.belowRangeColor = [0.0, 0.0, 0.0, 1.0];\n  model.aboveRangeColor = [1.0, 1.0, 1.0, 1.0];\n  model.buildTime = {};\n  macro.obj(model.buildTime);\n\n  // Create get-only macros\n  macro.get(publicAPI, model, ['buildTime', 'mappingRange']);\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['useAboveRangeColor', 'useBelowRangeColor', 'colorSpace', 'discretize', 'numberOfValues']);\n  macro.setArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor'], 4);\n\n  // Create get macros for array\n  macro.getArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkColorTransferFunction(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkColorTransferFunction');\n\n// ----------------------------------------------------------------------------\n\nvar vtkColorTransferFunction$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\nexport { vtkColorTransferFunction$1 as default, extend, newInstance };\n","import { v as vtkColorMaps$1 } from './ColorMaps.json.js';\n\nconst presetMap = Object.create(null);\nvtkColorMaps$1.filter(p => p.RGBPoints).filter(p => p.ColorSpace !== 'CIELAB').forEach(p => {\n  presetMap[p.Name] = p;\n});\n\n// ----------------------------------------------------------------------------\n\nconst rgbPresetNames = Object.keys(presetMap);\nrgbPresetNames.sort();\n\n// ----------------------------------------------------------------------------\n\nfunction getPresetByName(name) {\n  return presetMap[name];\n}\n\n// ----------------------------------------------------------------------------\n\nfunction addPreset(preset) {\n  if (!preset.RGBPoints || preset.ColorSpace === 'CIELAB') {\n    return;\n  }\n  if (!presetMap[preset.Name]) {\n    rgbPresetNames.push(preset.Name);\n    rgbPresetNames.sort();\n  }\n  presetMap[preset.Name] = preset;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction removePresetByName(name) {\n  const index = rgbPresetNames.indexOf(name);\n  if (index > -1) {\n    rgbPresetNames.splice(index, 1);\n  }\n  delete presetMap[name];\n}\n\n// ----------------------------------------------------------------------------\n\nvar vtkColorMaps = {\n  addPreset,\n  removePresetByName,\n  getPresetByName,\n  rgbPresetNames\n};\n\nexport { vtkColorMaps as default };\n","import Constants from './ImageMapper/Constants.js';\nimport { m as macro } from '../../macros2.js';\nimport vtkAbstractImageMapper from './AbstractImageMapper.js';\nimport { intersectWithLineForPointPicking, intersectWithLineForCellPicking } from './AbstractImageMapper/helper.js';\nimport { C as clampValue, R as multiply3x3_vect3, F as createUninitializedBounds, S as getSparseOrthogonalMatrix } from '../../Common/Core/Math/index.js';\nimport CoincidentTopologyHelper from './Mapper/CoincidentTopologyHelper.js';\n\nconst {\n  staticOffsetAPI,\n  otherStaticMethods\n} = CoincidentTopologyHelper;\nconst {\n  SlicingMode\n} = Constants;\n\n// ----------------------------------------------------------------------------\n// vtkImageMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageMapper');\n  publicAPI.getSliceAtPosition = pos => {\n    const image = publicAPI.getCurrentImage();\n    let pos3;\n    if (pos.length === 3) {\n      pos3 = pos;\n    } else if (Number.isFinite(pos)) {\n      const bds = image.getBounds();\n      switch (model.slicingMode) {\n        case SlicingMode.X:\n          pos3 = [pos, (bds[3] + bds[2]) / 2, (bds[5] + bds[4]) / 2];\n          break;\n        case SlicingMode.Y:\n          pos3 = [(bds[1] + bds[0]) / 2, pos, (bds[5] + bds[4]) / 2];\n          break;\n        case SlicingMode.Z:\n          pos3 = [(bds[1] + bds[0]) / 2, (bds[3] + bds[2]) / 2, pos];\n          break;\n      }\n    }\n    const ijk = [0, 0, 0];\n    image.worldToIndex(pos3, ijk);\n    const ex = image.getExtent();\n    const {\n      ijkMode\n    } = publicAPI.getClosestIJKAxis();\n    let slice = 0;\n    switch (ijkMode) {\n      case SlicingMode.I:\n        slice = clampValue(ijk[0], ex[0], ex[1]);\n        break;\n      case SlicingMode.J:\n        slice = clampValue(ijk[1], ex[2], ex[3]);\n        break;\n      case SlicingMode.K:\n        slice = clampValue(ijk[2], ex[4], ex[5]);\n        break;\n      default:\n        return 0;\n    }\n    return slice;\n  };\n  publicAPI.setSliceFromCamera = cam => {\n    const fp = cam.getFocalPoint();\n    switch (model.slicingMode) {\n      case SlicingMode.I:\n      case SlicingMode.J:\n      case SlicingMode.K:\n        {\n          const slice = publicAPI.getSliceAtPosition(fp);\n          publicAPI.setSlice(slice);\n        }\n        break;\n      case SlicingMode.X:\n        publicAPI.setSlice(fp[0]);\n        break;\n      case SlicingMode.Y:\n        publicAPI.setSlice(fp[1]);\n        break;\n      case SlicingMode.Z:\n        publicAPI.setSlice(fp[2]);\n        break;\n    }\n  };\n  publicAPI.setXSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.X);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setYSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.Y);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setZSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.Z);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setISlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.I);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setJSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.J);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setKSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.K);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.getSlicingModeNormal = () => {\n    const out = [0, 0, 0];\n    const mat3 = publicAPI.getCurrentImage().getDirection();\n    switch (model.slicingMode) {\n      case SlicingMode.X:\n        out[0] = 1;\n        break;\n      case SlicingMode.Y:\n        out[1] = 1;\n        break;\n      case SlicingMode.Z:\n        out[2] = 1;\n        break;\n      case SlicingMode.I:\n        multiply3x3_vect3(mat3, [1, 0, 0], out);\n        break;\n      case SlicingMode.J:\n        multiply3x3_vect3(mat3, [0, 1, 0], out);\n        break;\n      case SlicingMode.K:\n        multiply3x3_vect3(mat3, [0, 0, 1], out);\n        break;\n    }\n    return out;\n  };\n  function computeClosestIJKAxis() {\n    let xyzMode;\n    switch (model.slicingMode) {\n      case SlicingMode.X:\n        xyzMode = 0;\n        break;\n      case SlicingMode.Y:\n        xyzMode = 1;\n        break;\n      case SlicingMode.Z:\n        xyzMode = 2;\n        break;\n      default:\n        model.closestIJKAxis = {\n          ijkMode: model.slicingMode,\n          flip: false\n        };\n        return;\n    }\n\n    // The direction matrix in vtkImageData is the indexToWorld rotation matrix\n    // with a column-major data layout since it is stored as a WebGL matrix.\n    const direction = publicAPI.getCurrentImage().getDirection();\n    const newMatrix = getSparseOrthogonalMatrix(direction);\n    // With {foo}Vector filled with 0s except at {foo}Mode position where it is 1\n    // We have xyzVector = (+/-) newMatrix * ijkVector\n    let ijkMode = 0;\n    for (; ijkMode < 3; ++ijkMode) {\n      if (newMatrix[xyzMode + 3 * ijkMode] !== 0) {\n        break;\n      }\n    }\n    const flip = newMatrix[xyzMode + 3 * ijkMode] < 0;\n    model.closestIJKAxis = {\n      ijkMode,\n      flip\n    };\n  }\n  publicAPI.setSlicingMode = mode => {\n    if (model.slicingMode === mode) {\n      return;\n    }\n    model.slicingMode = mode;\n    if (publicAPI.getCurrentImage()) {\n      computeClosestIJKAxis();\n    }\n    publicAPI.modified();\n  };\n  publicAPI.getClosestIJKAxis = () => {\n    if ((model.closestIJKAxis === undefined || model.closestIJKAxis.ijkMode === SlicingMode.NONE) && publicAPI.getCurrentImage()) {\n      computeClosestIJKAxis();\n    }\n    return model.closestIJKAxis;\n  };\n  publicAPI.getBounds = () => {\n    const image = publicAPI.getCurrentImage();\n    if (!image) {\n      return createUninitializedBounds();\n    }\n    if (!model.useCustomExtents) {\n      return image.getBounds();\n    }\n    const ex = model.customDisplayExtent.slice();\n    const {\n      ijkMode\n    } = publicAPI.getClosestIJKAxis();\n    let nSlice = model.slice;\n    if (ijkMode !== model.slicingMode) {\n      // If not IJK slicing, get the IJK slice from the XYZ position/slice\n      nSlice = publicAPI.getSliceAtPosition(model.slice);\n    }\n    switch (ijkMode) {\n      case SlicingMode.I:\n        ex[0] = nSlice;\n        ex[1] = nSlice;\n        break;\n      case SlicingMode.J:\n        ex[2] = nSlice;\n        ex[3] = nSlice;\n        break;\n      case SlicingMode.K:\n        ex[4] = nSlice;\n        ex[5] = nSlice;\n        break;\n    }\n    return image.extentToBounds(ex);\n  };\n  publicAPI.getBoundsForSlice = function () {\n    let slice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : model.slice;\n    let halfThickness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const image = publicAPI.getCurrentImage();\n    if (!image) {\n      return createUninitializedBounds();\n    }\n    const extent = image.getSpatialExtent();\n    const {\n      ijkMode\n    } = publicAPI.getClosestIJKAxis();\n    let nSlice = slice;\n    if (ijkMode !== model.slicingMode) {\n      // If not IJK slicing, get the IJK slice from the XYZ position/slice\n      nSlice = publicAPI.getSliceAtPosition(slice);\n    }\n    switch (ijkMode) {\n      case SlicingMode.I:\n        extent[0] = nSlice - halfThickness;\n        extent[1] = nSlice + halfThickness;\n        break;\n      case SlicingMode.J:\n        extent[2] = nSlice - halfThickness;\n        extent[3] = nSlice + halfThickness;\n        break;\n      case SlicingMode.K:\n        extent[4] = nSlice - halfThickness;\n        extent[5] = nSlice + halfThickness;\n        break;\n    }\n    return image.extentToBounds(extent);\n  };\n  publicAPI.intersectWithLineForPointPicking = (p1, p2) => intersectWithLineForPointPicking(p1, p2, publicAPI);\n  publicAPI.intersectWithLineForCellPicking = (p1, p2) => intersectWithLineForCellPicking(p1, p2, publicAPI);\n  publicAPI.getCurrentImage = () => publicAPI.getInputData();\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  slicingMode: SlicingMode.NONE,\n  closestIJKAxis: {\n    ijkMode: SlicingMode.NONE,\n    flip: false\n  },\n  renderToRectangle: false,\n  sliceAtFocalPoint: false,\n  preferSizeOverAccuracy: false // Whether to use halfFloat representation of float, when it is inaccurate\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  vtkAbstractImageMapper.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['slicingMode']);\n  macro.setGet(publicAPI, model, ['closestIJKAxis', 'renderToRectangle', 'sliceAtFocalPoint', 'preferSizeOverAccuracy']);\n  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);\n\n  // Object methods\n  vtkImageMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageMapper$1 = {\n  newInstance,\n  extend,\n  ...staticOffsetAPI,\n  ...otherStaticMethods,\n  ...Constants\n};\n\nexport { vtkImageMapper$1 as default, extend, newInstance };\n","import { mat4 } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport vtkProp3D from './Prop3D.js';\nimport vtkImageProperty from './ImageProperty.js';\n\nconst {\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageSlice methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageSlice(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageSlice');\n  publicAPI.getActors = () => publicAPI;\n  publicAPI.getImages = () => publicAPI;\n  publicAPI.getIsOpaque = () => {\n    if (model.forceOpaque) {\n      return true;\n    }\n    if (model.forceTranslucent) {\n      return false;\n    }\n    // make sure we have a property\n    if (!model.property) {\n      // force creation of a property\n      publicAPI.getProperty();\n    }\n    let isOpaque = model.property.getOpacity() >= 1.0;\n\n    // are we using an opaque scalar array, if any?\n    isOpaque = isOpaque && (!model.mapper || model.mapper.getIsOpaque());\n    return isOpaque;\n  };\n\n  // Always render during opaque pass, to keep the behavior\n  // predictable and because depth-peeling kills alpha-blending.\n  // In the future, the Renderer should render images in layers,\n  // i.e. where each image will have a layer number assigned to it,\n  // and the Renderer will do the images in their own pass.\n  publicAPI.hasTranslucentPolygonalGeometry = () => false;\n  publicAPI.makeProperty = vtkImageProperty.newInstance;\n  publicAPI.getProperty = () => {\n    if (model.property === null) {\n      model.property = publicAPI.makeProperty();\n    }\n    return model.property;\n  };\n  publicAPI.getBounds = () => {\n    if (model.mapper === null) {\n      return model.bounds;\n    }\n\n    // Check for the special case when the mapper's bounds are unknown\n    const bds = model.mapper.getBounds();\n    if (!bds || bds.length !== 6) {\n      return bds;\n    }\n\n    // Check for the special case when the actor is empty.\n    if (bds[0] > bds[1]) {\n      model.mapperBounds = bds.concat(); // copy the mapper's bounds\n      model.bounds = [1, -1, 1, -1, 1, -1];\n      model.boundsMTime.modified();\n      return bds;\n    }\n\n    // Check if we have cached values for these bounds - we cache the\n    // values returned by model.mapper.getBounds() and we store the time\n    // of caching. If the values returned this time are different, or\n    // the modified time of this class is newer than the cached time,\n    // then we need to rebuild.\n    const zip = rows => rows[0].map((_, c) => rows.map(row => row[c]));\n    if (!model.mapperBounds || !zip([bds, model.mapperBounds]).reduce((a, b) => a && b[0] === b[1], true) || publicAPI.getMTime() > model.boundsMTime.getMTime()) {\n      vtkDebugMacro('Recomputing bounds...');\n      model.mapperBounds = bds.map(x => x);\n      publicAPI.computeMatrix();\n      const tmp4 = new Float64Array(16);\n      mat4.transpose(tmp4, model.matrix);\n      vtkBoundingBox.transformBounds(bds, tmp4, model.bounds);\n      model.boundsMTime.modified();\n    }\n    return model.bounds;\n  };\n  publicAPI.getBoundsForSlice = (slice, thickness) => {\n    // Check for the special case when the mapper's bounds are unknown\n    const bds = model.mapper.getBoundsForSlice(slice, thickness);\n    // Check for the special case when the actor is empty.\n    if (!vtkBoundingBox.isValid(bds)) {\n      return bds;\n    }\n    publicAPI.computeMatrix();\n    const tmp4 = new Float64Array(16);\n    mat4.transpose(tmp4, model.matrix);\n    const newBounds = vtkBoundingBox.transformBounds(bds, tmp4);\n    return newBounds;\n  };\n\n  //----------------------------------------------------------------------------\n  // Get the minimum X bound\n  publicAPI.getMinXBound = () => publicAPI.getBounds()[0];\n\n  // Get the maximum X bound\n  publicAPI.getMaxXBound = () => publicAPI.getBounds()[1];\n\n  // Get the minimum Y bound\n  publicAPI.getMinYBound = () => publicAPI.getBounds()[2];\n\n  // Get the maximum Y bound\n  publicAPI.getMaxYBound = () => publicAPI.getBounds()[3];\n\n  // Get the minimum Z bound\n  publicAPI.getMinZBound = () => publicAPI.getBounds()[4];\n\n  // Get the maximum Z bound\n  publicAPI.getMaxZBound = () => publicAPI.getBounds()[5];\n  publicAPI.getMTime = () => {\n    let mt = model.mtime;\n    if (model.property !== null) {\n      const time = model.property.getMTime();\n      mt = time > mt ? time : mt;\n    }\n    return mt;\n  };\n  publicAPI.getRedrawMTime = () => {\n    let mt = model.mtime;\n    if (model.mapper !== null) {\n      let time = model.mapper.getMTime();\n      mt = time > mt ? time : mt;\n      if (model.mapper.getInput() !== null) {\n        // FIXME !!! getInputAlgorithm / getInput\n        model.mapper.getInputAlgorithm().update();\n        time = model.mapper.getInput().getMTime();\n        mt = time > mt ? time : mt;\n      }\n    }\n    if (model.property !== null) {\n      let time = model.property.getMTime();\n      mt = time > mt ? time : mt;\n      if (model.property.getRGBTransferFunction() !== null) {\n        time = model.property.getRGBTransferFunction().getMTime();\n        mt = time > mt ? time : mt;\n      }\n    }\n    return mt;\n  };\n  publicAPI.getSupportsSelection = () => model.mapper ? model.mapper.getSupportsSelection() : false;\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  mapper: null,\n  property: null,\n  bounds: [...vtkBoundingBox.INIT_BOUNDS]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkProp3D.extend(publicAPI, model, initialValues);\n\n  // vtkTimeStamp\n  model.boundsMTime = {};\n  macro.obj(model.boundsMTime);\n\n  // Build VTK API\n  macro.set(publicAPI, model, ['property']);\n  macro.setGet(publicAPI, model, ['mapper']);\n  macro.getArray(publicAPI, model, ['bounds'], 6);\n\n  // Object methods\n  vtkImageSlice(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageSlice');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageSlice$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageSlice$1 as default, extend, newInstance };\n","import { mat4, vec3 } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport vtkProp3D from './Prop3D.js';\nimport vtkVolumeProperty from './VolumeProperty.js';\n\nconst {\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkVolume methods\n// ----------------------------------------------------------------------------\n\nfunction vtkVolume(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkVolume');\n  publicAPI.getVolumes = () => publicAPI;\n  publicAPI.makeProperty = vtkVolumeProperty.newInstance;\n  publicAPI.getProperty = () => {\n    if (model.property === null) {\n      model.property = publicAPI.makeProperty();\n    }\n    return model.property;\n  };\n  publicAPI.getBounds = () => {\n    if (model.mapper === null) {\n      return model.bounds;\n    }\n\n    // Check for the special case when the mapper's bounds are unknown\n    const bds = model.mapper.getBounds();\n    if (!bds || bds.length !== 6) {\n      return bds;\n    }\n\n    // Check for the special case when the actor is empty.\n    if (bds[0] > bds[1]) {\n      model.mapperBounds = bds.concat(); // copy the mapper's bounds\n      model.bounds = [1, -1, 1, -1, 1, -1];\n      model.boundsMTime.modified();\n      return bds;\n    }\n\n    // Check if we have cached values for these bounds - we cache the\n    // values returned by model.mapper.getBounds() and we store the time\n    // of caching. If the values returned this time are different, or\n    // the modified time of this class is newer than the cached time,\n    // then we need to rebuild.\n    const zip = rows => rows[0].map((_, c) => rows.map(row => row[c]));\n    if (!model.mapperBounds || !zip([bds, model.mapperBounds]).reduce((a, b) => a && b[0] === b[1], true) || publicAPI.getMTime() > model.boundsMTime.getMTime()) {\n      vtkDebugMacro('Recomputing bounds...');\n      model.mapperBounds = bds.map(x => x);\n      const bbox = [];\n      vtkBoundingBox.getCorners(bds, bbox);\n      publicAPI.computeMatrix();\n      const tmp4 = new Float64Array(16);\n      mat4.transpose(tmp4, model.matrix);\n      bbox.forEach(pt => vec3.transformMat4(pt, pt, tmp4));\n\n      /* eslint-disable no-multi-assign */\n      model.bounds[0] = model.bounds[2] = model.bounds[4] = Number.MAX_VALUE;\n      model.bounds[1] = model.bounds[3] = model.bounds[5] = -Number.MAX_VALUE;\n      /* eslint-enable no-multi-assign */\n      model.bounds = model.bounds.map((d, i) => i % 2 === 0 ? bbox.reduce((a, b) => a > b[i / 2] ? b[i / 2] : a, d) : bbox.reduce((a, b) => a < b[(i - 1) / 2] ? b[(i - 1) / 2] : a, d));\n      model.boundsMTime.modified();\n    }\n    return model.bounds;\n  };\n  publicAPI.getMTime = () => {\n    let mt = model.mtime;\n    if (model.property !== null) {\n      const time = model.property.getMTime();\n      mt = time > mt ? time : mt;\n    }\n    return mt;\n  };\n  publicAPI.getRedrawMTime = () => {\n    let mt = model.mtime;\n    if (model.mapper !== null) {\n      let time = model.mapper.getMTime();\n      mt = time > mt ? time : mt;\n      if (model.mapper.getInput() !== null) {\n        // FIXME !!! getInputAlgorithm / getInput\n        model.mapper.getInputAlgorithm().update();\n        time = model.mapper.getInput().getMTime();\n        mt = time > mt ? time : mt;\n      }\n    }\n    return mt;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  mapper: null,\n  property: null,\n  bounds: [1, -1, 1, -1, 1, -1]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkProp3D.extend(publicAPI, model, initialValues);\n\n  // vtkTimeStamp\n  model.boundsMTime = {};\n  macro.obj(model.boundsMTime);\n\n  // Build VTK API\n  macro.set(publicAPI, model, ['property']);\n  macro.setGet(publicAPI, model, ['mapper']);\n  macro.getArray(publicAPI, model, ['bounds'], 6);\n\n  // Object methods\n  vtkVolume(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkVolume');\n\n// ----------------------------------------------------------------------------\n\nvar vtkVolume$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkVolume$1 as default, extend, newInstance };\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    return createProxy(ep, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously \\_()_/\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didnt happen.\n            if (last === \"bind\") {\n                return createProxy(ep, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        ep.addEventListener(\"message\", function l(ev) {\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\n                return;\n            }\n            ep.removeEventListener(\"message\", l);\n            resolve(ev.data);\n        });\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","import ascending from \"./ascending.js\";\nimport descending from \"./descending.js\";\n\nexport default function bisector(f) {\n  let compare1, compare2, delta;\n\n  // If an accessor is specified, promote it to a comparator. In this case we\n  // can test whether the search value is (self-) comparable. We cant do this\n  // for a comparator (except for specific, known comparators) because we cant\n  // tell if the comparator is symmetric, and an asymmetric comparator cant be\n  // used to test whether a single value is comparable.\n  if (f.length !== 2) {\n    compare1 = ascending;\n    compare2 = (d, x) => ascending(f(d), x);\n    delta = (d, x) => f(d) - x;\n  } else {\n    compare1 = f === ascending || f === descending ? f : zero;\n    compare2 = f;\n    delta = f;\n  }\n\n  function left(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function right(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) <= 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function center(a, x, lo = 0, hi = a.length) {\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {left, center, right};\n}\n\nfunction zero() {\n  return 0;\n}\n"],"names":["VideoViewport","frameRangeExtractor","constructor","props","super","canvas","element","videoWidth","videoHeight","loop","mute","isPlaying","scrollSpeed","playbackRate","frameRange","fps","videoCamera","panWorld","parallelScale","voiRange","lower","upper","getProperties","this","videoElement","muted","resetCamera","refreshRenderValues","canvasContext","fillRect","width","height","renderFrame","getNumberOfSlices","computedSlices","Math","round","duration","isNaN","numberOfFrames","getFrameOfReferenceUID","src","resize","clientWidth","clientHeight","canvasToWorld","canvasPos","destPos","pan","worldToCanvasRatio","getWorldToCanvasRatio","panOffsetCanvas","subCanvasPos","splice","worldToCanvas","worldPos","getRotation","canvasToIndex","transform","getTransform","invert","transformPoint","map","it","devicePixelRatio","indexToCanvas","indexPos","customRenderViewportToCanvas","transformationMatrix","getMatrix","ctx","resetTransform","drawImage","actor","getActors","render","triggerEvent","STACK_NEW_IMAGE","viewportId","id","viewport","renderingEngineId","time","currentTime","IMAGE_RENDERED","initialRender","frame","getFrameNumber","setFrameNumber","pause","renderWhilstPlaying","requestAnimationFrame","getContext","setAttribute","document","createElement","autoplay","crossOrigin","addEventListeners","useCustomRenderingPipeline","addEventListener","ELEMENT_DISABLED","elementDisabledHandler","removeEventListeners","removeEventListener","remove","getImageDataMetadata","image","imageId","imagePlaneModule","MetadataModules","IMAGE_PLANE","rowCosines","columnCosines","rowCosineVec","colCosineVec","rows","columns","scanAxisNormal","origin","imagePositionPatient","xSpacing","columnPixelSpacing","ySpacing","rowPixelSpacing","xVoxels","yVoxels","hasPixelSpacing","bitsAllocated","numComps","direction","dimensions","spacing","numVoxels","setDataIds","imageIds","options","setVideo","viewReference","sliceIndex","frameNumber","Array","isArray","imageUrlModule","IMAGE_URL","rendered","Error","generalSeries","GENERAL_SERIES","modality","Modality","metadata","cineRate","CINE","setVideoURL","then","setFrameRange","Promise","resolve","window","setTimeout","videoURL","preload","loadedMetadataEventHandler","getImageIds","baseImageId","replace","i","togglePlayPause","play","e","scroll","delta","newTime","seekEventListener","evt","start","paused","end","setTime","timeInSeconds","length","getFrameRange","setProperties","undefined","setPlaybackRate","setScrollSpeed","setVOI","rate","unit","FRAME","SECOND","resetProperties","getScalarData","scalarData","context","getImageData","data","getRange","imageData","getDirection","getDimensions","getSpacing","worldToIndex","point","canvasPoint","pixelCoord","indexToWorld","destPoint","calibration","preScale","scaled","Object","defineProperty","get","enumerable","hasImageURI","imageURI","framesMatch","match","testURI","substring","index","indexOf","setColorTransform","setWindowLevel","windowWidth","windowCenter","setAverageWhite","averageWhite","feFilter","white","maxWhite","max","scaleWhite","c","wlScale","wlDelta","style","filter","setCamera","camera","focalPoint","focalPointCanvas","canvasCenter","panWorldDelta","fillStyle","getCurrentImageId","getReferenceId","specifier","isReferenceViewable","viewRef","referencedImageId","colonIndex","withNavigation","currentIndex","getSliceIndex","range","split","Number","getViewReference","viewRefSpecifier","getCurrentImageIdIndex","getCamera","parallelProjection","position","viewUp","viewPlaneNormal","getPan","offsetWidth","offsetHeight","drawWidth","floor","drawHeight","xOffsetWorld","yOffsetWorld","getCanvasToWorldRatio","canvasToWorldRatio","halfCanvas","halfCanvasWorldCoordinates","scale","translate","updateCameraClippingPlanesAndRange","addImages","stackInputs","actors","forEach","stackInput","getImage","imageActor","createActorMapper","push","uid","actorUID","callback","setActors","async","renderingEngine","viewportIds","getViewport","console","warn","addStackPromises","all","volumeInputs","immediateRender","suppressEvents","addVolumePromises","addVolumes","COLOR_TRANSPARENT","getRank","array","elem","left","right","mid","midElem","makeMappingArray","N","gamma","x","y0","y1","lut","xLinSpace","a","b","n","increment","vector","linspace","pow","xLinSpaceIndexes","inputArray","values","indexes","len","sort","searchSorted","colorPercent","colorDelta","getColormap","colormapData","colormap","name","colors","segmentedData","redLut","red","greenLut","green","blueLut","blue","rgba","createLinearSegmentedColormap","numColors","getId","getColorSchemeName","setColorSchemeName","getNumberOfColors","setNumberOfColors","getColor","isValidIndex","getColorRepeating","setColor","addColor","insertColor","removeColor","clearColors","buildLookupTable","setNumberOfTableValues","setTableValue","createLookupTable","enabledElement","invalidated","stats","lastGetPixelDataTime","lastStoredPixelDataToCanvasImageDataTime","lastPutImageDataTime","lastRenderTime","lastLutGenerateTime","color","renderTimeInMs","invalid","needsRedraw","displayedArea","angle","rotation","rotate","PI","widthScale","heightScale","brhc","tlhc","y","presentationSizeMode","verticalScale","horizontalScale","min","translation","hflip","vflip","pt","shift","viewportOrientation","cosA","cos","sinA","sin","newX","newY","scaleFactor","voi","isPreScaled","pixelReplication","modalityLUT","voiLUT","imageSize","verticalRatio","horizontalRatio","isRotated","resetPan","resetZoom","forceFitToWindow","oldCanvasWidth","oldCanvasHeight","setCanvasSize","getImageSize","imageWidth","imageHeight","wasFitToWindow","getImageFitScale","fitToWindow","relWidthChange","relHeightChange","relChange","sqrt","relativeRescale","useNativeDataType","volumeId","blendMode","imageVolume","loadVolume","vtkOpenGLTexture","volumeMapper","setBlendMode","volumeActor","setMapper","getPointData","getScalars","getNumberOfComponents","getProperty","setIndependentComponents","getRGBTransferFunction","voiModifiedEventDetail","Events","VOI_MODIFIED","triggerVOIModified","REQUEST_TYPE","RequestType","Prefetch","voiLutModule","voiLut","windowLevel","getVOIFromMetadata","imageIdIndex","generalSeriesModule","modalityLutModule","numImages","bytesPerImage","byteLength","voxelsPerImage","bytePerPixel","BYTES_PER_ELEMENT","scalingParameters","rescaleSlope","rescaleIntercept","scalingParametersToUse","suvFactor","suvbw","byteOffset","targetBuffer","type","priority","requestType","enabled","referencedImageIds","loadAndCacheImage","ignoreCache","imageScalarData","getPixelData","buffer","TypedArray","volumeBufferView","set","_getImageScalarDataFromImageVolume","getMinMax","getVOIFromMinMax","scaling","PT","_isCurrentImagePTPrescaled","handlePreScaledVolume","setMappingRange","DEFAULT_VALUES","scalarTexture","extend","publicAPI","model","initialValues","assign","classHierarchy","superDelete","delete","vtkSharedVolumeMapper","newInstance","DEFAULT_SETTINGS","Symbol","RUNTIME_SETTINGS","OBJECT_SETTINGS_MAP","DICTIONARY","Settings","base","dictionary","create","seal","value","key","unset","endsWith","deleteCount","namespace","slice","deleteAll","prototype","hasOwnProperty","call","startsWith","iterate","import","root","isPlainObject","keys","dump","deepSet","assert","subject","getRuntimeSettings","getDefaultSettings","subfield","defaultSettings","settingObj","setting","runtimeSettings","getObjectSettings","from","settings","objectSettingsMap","WeakMap","extendRuntimeSettings","references","last","current","previous","isValidKey","prefix","record","failCount","has","add","field","setAll","WeakSet","getPrototypeOf","separator","subKey","subContext","subContextValue","ONE_GB","_imageCache","Map","_volumeCache","_imageCacheSize","_volumeCacheSize","_maxCacheSize","_maxInstanceSize","setMaxCacheSize","newMaxCacheSize","errorMessage","isCacheable","getBytesAvailable","getMaxCacheSize","getMaxInstanceSize","getCacheSize","_decacheImage","imageLoadObject","cancelFn","decache","_decacheVolume","cachedVolume","volumeLoadObject","volume","cancelLoading","_restoreImagesFromBuffer","purgeCache","imageIterator","done","next","removeImageLoadObject","IMAGE_CACHE_IMAGE_REMOVED","purgeVolumeCache","volumeIterator","removeVolumeLoadObject","VOLUME_CACHE_VOLUME_REMOVED","getVolumeLoadObject","timeStamp","Date","now","getGeometry","geometryId","cachedGeometry","_geometryCache","geometry","cachedImage","getVolume","getVolumes","filterVolumesByReferenceId","referencedVolumeId","incrementImageCacheSize","sizeInBytes","eventDetails","incrementVolumeCacheSize","putGeometryLoadObject","geometryLoadObject","loaded","promise","GEOMETRY_CACHE_GEOMETRY_ADDED","catch","error","decrementImageCacheSize","decrement","decrementVolumeCacheSize","decacheIfNecessaryUntilBytesAvailable","numBytes","volumeImageIds","bytesAvailable","cachedImages","cachedImageIds","im","imageIdsToPurge","includes","putImageLoadObject","sharedCacheKey","toFixed","CACHE_SIZE_EXCEEDED","IMAGE_CACHE_IMAGE_ADDED","getImageLoadObject","isLoaded","getVolumeContainingImageId","volumeIds","imageIdToUse","imageIdToURI","getImageURIIndex","getCachedImageBasedOnImageURI","imageURIToUse","foundImageId","find","putVolumeLoadObject","VOLUME_CACHE_VOLUME_ADDED","imageCacheOffsetMap","size","offset","viewPixelData","pixelData","imageFrame","bufferView","log","RENDERING_DEFAULTS","MINIMUM_SLAB_THICKNESS","MAXIMUM_RAY_DISTANCE","freeze","ViewportStatus","BlendMode","BlendModes","COMPOSITE_BLEND","MAXIMUM_INTENSITY_BLEND","MINIMUM_INTENSITY_BLEND","AVERAGE_INTENSITY_BLEND","GeometryType","DynamicOperatorType","CalibrationTypes","getEnabledElement","viewportUid","renderingEngineUid","dataset","getEnabledElementByIds","hasBeenDestroyed","FrameOfReferenceUID","getEnabledElementByViewportId","renderingEngines","getEnabledElements","enabledElements","getViewports","imageLoaders","unknownImageLoader","loadImageFromImageLoader","scheme","loader","IMAGE_LOADED","errorObject","IMAGE_LOAD_FAILED","loadImageFromCacheOrVolume","cachedVolumeInfo","loadStatus","convertToCornerstoneImage","loadImage","err","loadAndCacheImages","createAndCacheDerivedImage","preventCache","uuidv4","skipCreateBuffer","onCacheAdd","metaData","TypedArrayConstructor","getBufferConfiguration","targetBufferType","derivedImageId","genericMetadataProvider","imagePixelModule","bitsStored","highBit","samplesPerPixel","pixelRepresentation","localImage","createAndCacheLocalImage","createAndCacheDerivedImages","derivedImageIds","allPromises","newOptions","getDerivedImageId","promises","intercept","slope","minPixelValue","maxPixelValue","voiLUTFunction","getCanvas","Uint8Array","Float32Array","Uint16Array","Int16Array","cancelLoadImage","filterRequests","additionalDetails","cancelLoadImages","cancelLoadAll","requestPool","getRequestPool","requests","pop","loadObject","cancel","clearRequestStack","registerImageLoader","imageLoader","registerUnknownImageLoader","oldImageLoader","unregisterAllImageLoaders","createAndCacheDerivedSegmentationImages","createAndCacheDerivedSegmentationImage","createInternalVTKRepresentation","PhotometricInterpretation","numComponents","dataArrayAttrs","numberOfComponents","setDimensions","setSpacing","setDirection","setOrigin","isDynamicVolume","scalarDataArrays","vtkScalarArray","addArray","setActiveScalars","addScalarDataArraysToImageData","getScalarDataArrays","scalarArray","setScalars","addScalarDataToImageData","volumeLoaders","unknownVolumeLoader","loadVolumeFromVolumeLoader","setupCacheOptimizationEventListener","VOLUME_LOADED","VOLUME_LOADED_FAILED","createAndCacheVolume","createAndCacheDerivedVolume","referencedVolume","scalarLength","volumeScalarData","generateVolumeScalarData","derivedImageData","derivedVolume","createLocalVolume","validDataTypes","createAndCacheVolumeFromImages","volumeProps","generateVolumePropsFromImageIds","imagePromises","performCacheOptimizationForVolume","registerVolumeLoader","volumeLoader","getVolumeLoaderSchemes","registerUnknownVolumeLoader","oldVolumeLoader","getUnknownVolumeLoaderSchema","createAndCacheDerivedSegmentationVolume","createLocalSegmentationVolume","useNorm16Texture","rendering","use16BitTexture","isVolumeBuffer","sharedArrayBuffer","createFloat32SharedArray","createUint8SharedArray","createUint16SharedArray","imageLoadPoolManager","grabDelay","setMaxSimultaneousRequests","Interaction","Thumbnail","RequestPoolManager","numRequests","interaction","thumbnail","prefetch","compute","awake","maxNumRequests","getMaxSimultaneousRequests","destroy","timeoutHandle","clearTimeout","addRequest","requestFn","requestDetails","startGrabbing","filterFunction","sendRequests","requestsToSend","syncImageCount","getNextRequest","requestResult","finally","startAgain","interactionPriorities","getSortedPriorityGroups","hasRemainingInteractionRequests","hasRemainingThumbnailRequests","hasRemainingPrefetchRequests","hasRemainingComputeRequests","Compute","enableCacheOptimization","shouldUseSAB","addEventListenerOnce","IMAGE_VOLUME_LOADING_COMPLETED","detail","_updateImageWithScalarDataView","_processImageCacheOffsetMap","compatibleScalarData","sampleImageIdWithImage","sampleImage","samplePixelData","getImageIdIndex","_processVolumeImages","view","_colormaps","registerColormap","Name","getColormapNames","findMatchingColormap","rgbPoints","colormapsVTK","rgbPresetNames","presetName","getPresetByName","colormapsCS3D","colormapName","matchedColormap","concat","RGBPoints","presetRGBPoints","opacity","opacityPoints","getScalarOpacity","getDataPointer","createLinearRGBTransferFunction","cfun","addRGBPoint","spacingInNormalDirection","actorEntry","referenceId","sliceRange","numberOfSlices","imageIndex","getTransferFunctionNodes","transferFunction","getSize","nodeValue1","getNodeValue","setTransferFunctionNodes","nodes","removeAllPoints","node","transformWorldToIndex","el","event","CustomEvent","cancelable","dispatchEvent","workerRegistry","workerPoolManager","registerWorker","workerName","workerFn","maxWorkerInstances","overwrite","autoTerminateOnIdle","idleTimeThreshold","idleCheckIntervalId","clearInterval","workerProperties","instances","loadCounters","lastActiveTime","nativeWorkers","fill","worker","getNextWorkerAPI","workerInstances","instance","minLoadIndex","minLoadValue","currentLoadValue","api","executeTask","methodName","args","callbacks","reject","finalCallbacks","cb","processing","results","setInterval","terminateIdleWorkers","_","terminateWorkerInstance","terminate","workerInstance","BASE","iconContent","iconSize","viewBox","mousePoint","mousePointerGroupString","SEGMENTATION_CURSOR_BOUNDARIES","MINUS_RECT","PLUS_RECT","SCISSOR_ICON","RECTANGLE_ICON","CIRCLE_ICON","CursorSVG","Angle","ArrowAnnotate","Bidirectional","CobbAngle","CircleROI","EllipticalROI","FreehandROI","FreehandROISculptor","Length","Probe","RectangleROI","TextMarker","Crosshairs","Eraser","Magnify","Pan","Rotate","StackScroll","WindowLevelRegion","WindowLevel","Zoom","SegmentationFreeHandEraseInside","SegmentationFreeHandFillInside","SegmentationFreeHandEraseOutside","SegmentationFreeHandFillOutside","SegmentationRectangleEraseInside","RectangleScissor","CircleScissor","getDefinedSVGCursorDescriptor","svgCursorNames","BidirectionalTool","toolProps","defaultToolProps","supportedInteractionTypes","configuration","preventHandleOutsideImage","getTextLines","defaultGetTextLines","isPointNearTool","annotation","canvasCoords","proximity","points","handles","canvasPoint1","canvasPoint2","line","distanceToPoint","toolSelectedCallback","eventDetail","highlighted","viewportIdsToRender","getViewportIdsWithToolToRender","getToolName","editData","movingTextBox","_activateModify","hideElementCursor","preventDefault","handleSelectedCallback","handle","handleIndex","worldPosition","findIndex","p","_endCallback","newAnnotation","hasMoved","activeHandleIndex","_deactivateModify","_deactivateDraw","resetElementCursor","firstLineSegmentLength","longAxis","shortAxisPoint0","shortAxisPoint1","longAxisVector","counterClockWisePerpendicularToLongAxis","currentShortAxisVector","shortAxis","isHandleOutsideImage","removeAnnotation","annotationUID","isDrawing","_dragDrawCallback","currentPoints","world","canvasCoordPoints","shortAxisDistFromCenter","dx","dy","vectorX","vectorY","xMid","yMid","startX","startY","endX","endY","_dragModifyCallback","deltaPoints","worldPosDelta","textBox","_dragModifyHandle","movingHandleIndex","canvasCoordHandlesCurrent","firstLineSegment","secondLineSegment","proposedPoint","proposedCanvasCoord","fixedHandleCanvasCoord","fixedHandleToProposedCoordVec","fixedHandleToOldCoordVec","proposedFirstLineSegment","_movingLongAxisWouldPutItThroughShortAxis","centerOfRotation","_getSignedAngle","firstPointX","firstPointY","secondPointX","secondPointY","rotatedFirstPoint","rotatedFirstPointY","rotatedSecondPoint","rotatedSecondPointY","newFirstPoint","newSecondPoint","translateHandleIndex","canvasCoordsCurrent","longLineSegment","shortLineSegment","longLineSegmentVec","longLineSegmentVecNormalized","proposedToCurrentVec","movementLength","movementAlongLineSegmentLength","newTranslatedPoint","_activateDraw","isInteractingWithTool","MOUSE_UP","MOUSE_DRAG","MOUSE_MOVE","MOUSE_CLICK","TOUCH_TAP","TOUCH_END","TOUCH_DRAG","renderAnnotation","svgDrawingHelper","renderStatus","annotations","getAnnotations","filterInteractableAnnotationsForElement","targetId","getTargetId","getRenderingEngine","styleSpecifier","toolGroupId","toolName","canvasCoordinates","lineWidth","lineDash","shadow","getAnnotationStyle","cachedStats","_throttledCalculateCachedStats","_calculateCachedStats","activeHandleCanvasCoords","isAnnotationVisible","isAnnotationLocked","handleGroupUID","drawHandles","dataId1","dataId2","lineUID","drawLine","secondLineUID","getLinkedTextBoxStyle","visibility","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","textLines","canvasTextBoxCoords","getTextBoxCoordsCanvas","textBoxPosition","textBoxUID","boundingBox","drawLinkedTextBox","top","vectorInSecondLineDirection","extendedSecondLineSegment","worldPos1","worldPos2","worldPos3","worldPos4","targetIds","getTargetIdImage","index1","index2","index3","index4","handles1","handles2","scale1","units","units1","scale2","units2","dist1","_calculateLength","dist2","lengthUnit","widthUnit","_isInsideVolume","vector1","vector2","atan2","trailing","addNewAnnotation","getReferencedImageId","label","addAnnotation","pos1","pos2","dz","roundNumber","AnnotationTool","createAnnotation","annotationBaseData","text","baseData","createAnnotationForViewport","createAndAddAnnotation","mouseMoveCallback","filteredAnnotations","annotationsNeedToBeRedrawn","activateHandleIndex","near","_imagePointNearToolOrHandle","nearToolAndNotMarkedActive","notNearToolAndMarkedActive","statsCalculator","getHandleNearImagePoint","isCanvasAnnotation","canvasBoundingBox","annotationCanvasCoordinate","specifications","getStyle","fontFamily","fontSize","background","isSuvScaled","BaseVolumeViewport","cache","scalingModule","property","locked","lineOpacity","fillColor","fillOpacity","textbox","defaultLabelmapConfig","renderOutline","outlineWidthActive","outlineWidthInactive","activeSegmentOutlineWidthDelta","renderFill","renderFillInactive","fillAlpha","fillAlphaInactive","outlineOpacity","outlineOpacityInactive","RectangleROIThresholdTool","RectangleROITool","StackViewport","segmentationId","triggerAnnotationRenderForViewportIds","rectangleUID","drawRect","RectangleROIStartEndThresholdTool","numSlicesToPropagate","computePointsInsideVolume","startIndex","spacingInNormal","endIndex","_getEndSliceIndex","startSlice","endSlice","pointsInVolume","projectionPoints","projectionPointsImageIds","labelmapUID","_computeProjectionPoints","calculatePointsInsideVolume","_computePointsInsideVolume","firstOrLastSlice","lineDashToUse","throttle","_calculateCachedStatsTool","startIJK","endIJK","startWorld","indexToWorldVec3","endWorld","distance","newProjectionPoints","dist","newPoint","RectanglePoints","pointsInsideVolume","projectionPoint","worldPos1Index","worldProjectionPointIndex","worldPos2Index","boundsIJK","pointsInShape","pointInShapeCallback","endPos","halfSpacingInNormalDirection","dir","dot","abs","AnnotationFrameRange","imageIdToFrames","framesToString","String","framesToImageId","newRangeString","eventBase","eventTarget","ANNOTATION_MODIFIED","getClosestImageIdForStackViewport","distanceImagePairs","ImagePositionPatient","calculateDistanceToImage","EPSILON","CONSTANTS","calculateBoundingBox","isWorld","xMin","Infinity","xMax","yMin","yMax","zMin","zMax","is3D","getBoundingBoxAroundShapeIJK","getBoundingBoxAroundShapeWorld","clipBounds","calibratedPixelSpacingMetadataProvider","utilities","Enums","clip","val","low","high","addContourSegmentationAnnotation","parentAnnotationUID","segmentation","segmentIndex","getSegmentation","representationData","CONTOUR","annotationUIDsMap","annotationsUIDsSet","Set","removeContourSegmentationAnnotation","state","polyline","closed","perimeter","point1","point2","firstPoint","lastPoint","isEqual","findHandlePolylineIndex","contour","closestDistance","reduce","closestIndex","testIndex","Labelmap","SegmentationRepresentations","AnnotationToPointData","TOOL_NAMES","convert","metadataProvider","referenceImageId","validateAnnotation","toolClass","ContourSequence","getContourSequence","ReferencedROINumber","ROIDisplayColor","random","register","RectangleROIStartEndThreshold","getContourHolesDataCanvas","worldHoleContours","childAnnotationUIDs","getContourHolesDataWorld","canvasHoleContours","worldHoleContour","numPoints","canvasHoleContour","updateContourPolyline","polylineData","transforms","targetWindingDirection","decimate","epsilon","polylineWorldPoints","currentPolylineWindingDirection","parentAnnotation","currentClosedState","lastToFirstDist","windingDirection","reverse","handlePoints","func","wait","lastArgs","lastThis","maxWait","result","timerId","lastCallTime","lastInvokeTime","leading","maxing","useRAF","TypeError","invokeFunc","thisArg","apply","startTimer","pendingFunc","shouldInvoke","timeSinceLastCall","timerExpired","trailingEdge","timeSinceLastInvoke","timeWaiting","remainingWait","debounced","isInvoking","leadingEdge","Boolean","cancelAnimationFrame","cancelTimer","flush","pending","annotationCanvasPoints","corners","canvasPoints","handlesLeftToRight","_compareX","handlesTopToBottom","_compareY","bottom","_determineCorners","centerY","PIXEL_UNITS","SUPPORTED_REGION_DATA_TYPES","SUPPORTED_LENGTH_VARIANT","SUPPORTED_PROBE_VARIANT","UNIT_MAPPING","SQUARE","getCalibratedLengthUnitsAndScale","areaUnits","calibrationType","sequenceOfUltrasoundRegions","UNCALIBRATED","imageIndex1","imageIndex2","regions","region","regionLocationMinX0","regionLocationMaxX1","regionLocationMinY0","regionLocationMaxY1","regionDataType","physicalUnitsXDirection","physicalUnitsYDirection","physicalDeltaX","physicalDeltaY","ERMF","USER","ERROR","PROJECTION","getCalibratedProbeUnitsAndValue","supportedRegionsMetadata","referencePixelX0","referencePixelY0","yValue","getCalibratedAspect","aspect","getSphereBoundsInfo","circlePoints","centerWorld","radiusWorld","topLeftWorld","bottomRightWorld","viewRight","topLeftIJK","bottomRightIJK","pointsIJK","_computeBoundsIJKWithCamera","getViewportForAnnotation","viewports","intersectAABB","aabb1","aabb2","minX","maxX","minY","maxY","distanceToPointSquared","aabb","aabbWidth","aabbHeight","aabbSize","aabbCenter","translatedPoint","PointsManager","BasicStatsCalculator","sum","count","runMean","m2","create3","statsInit","noPointsCollection","statsCallback","newValue","pointLPS","newArray","idx","delta2","getStatistics","mean","stdDev","squaredDiffSum","named","singleArrayAsNumber","pointInEllipse","ellipse","inverts","precalculated","precalculatePointInEllipse","xRadius","yRadius","zRadius","invXRadiusSq","invYRadiusSq","invZRadiusSq","center","centerL","centerP","centerS","inside","getCanvasEllipseCorners","ellipseCanvasPoints","distanceToPointSquaredInfo","lineStart","lineEnd","closestPoint","distanceSquared","math","dotProduct","sign","NaN","intersectLine","line1Start","line1End","line2Start","line2End","x1","x2","y2","x3","y3","x4","y4","a1","b1","c1","r3","r4","a2","b2","c2","r1","r2","denom","num","ORIENTATION_TOLERANCE","isPointOnLineSegment","orientation","p1","p2","z1","z2","mirror","mirrorPoint","staticPoint","isClosed","numPolylinePoints","distFirstToLastPoints","containsPoint","numIntersections","holes","hole","shouldClose","maxSegmentIndex","intersects","xIntersection","containsPoints","numPoint","getArea","area","j","getSignedArea","refPoint","aX","aY","bX","getWindingDirection","getNormal3","vecArea","aZ","bY","bZ","_getAreaVector","getNormal2","areLineSegmentsIntersecting","q1","q2","line1MinX","line1MinY","line1MaxX","line1MaxY","line2MinX","line2MinY","line2MaxX","line2MaxY","orient","onSegment","q","r","orientationValue","getLineSegmentIntersectionsIndexes","intersections","maxI","PARALLEL_LINES_TOLERANCE","getLinesIntersection","diffQ1P1","diffQ2P2","denominator","line1AABB","line2AABB","numerator2","PolylinePointType","PolylinePointPosition","PolylinePointDirection","ensuresNextPointers","polylinePoints","currentPoint","getSourceAndTargetPointsList","targetPolyline","sourcePolyline","targetPolylinePoints","sourcePolylinePoints","sourceIntersectionsCache","intersectionPointDirection","Exiting","Entering","pointInside","vertexPoint","Vertex","coordinates","Inside","Outside","visited","intersectionsInfo","intersectedLineSegment","sourceLineSegmentId","intersectionCoordinate","coordinate","targetStartPointDistSquared","intersectionInfo","targetEdgePoint","Intersection","Edge","sourceEdgePoint","Unknown","cloned","sourceIntersectionPoints","lineSegmentId","intersectionPoint","lineSegStartDistSquared","getUnvisitedOutsidePoint","mergePolylines","targetNormal","sourceNormal","dotNormals","startPoint","mergedPolyline","subtractPolylines","subtractedPolylines","subtractedPolyline","getFirstLineSegmentIntersectionIndexes","initialI","intersectPolyline","sourceLen","intersectionPointIndexes","DEFAULT_EPSILON","epsilonSquared","partitionQueue","polylinePointFlags","numDecimatedPoints","endPoint","maxDistSquared","maxDistIndex","distSquared","decimatedPolyline","srcIndex","dstIndex","getLineSegmentIntersectionsCoordinates","polylineIndexes","intersection","getClosestLineSegmentIntersection","initialQ2Index","p2Index","q2Index","distances","intersectionPoints","midpoint","minDistance","segment","subPixelResolution","xDir","yDir","volumeSpacing","iVector","jVector","kVector","absViewRightDotI","absViewRightDotJ","absViewRightDotK","absViewUpDotI","absViewUpDotJ","absViewUpDotK","closeContourProximity","newCanvasPoint","commonData","lastWorldPos","newWorldPos","worldPosDiff","xDist","yDist","numPointsToAdd","lastCanvasPoint","canvasDist","canvasDir","distPerPoint","p1p","p1p2","p1p2Mag","projectionVectorMag","p1p2UnitVector","projectionVector","projectTo2D","sharedDimensionIndex","testPoints","every","points2D","firstDim","secondDim","projectedPolyline","isPointInsidePolyline3D","projectedHoles","hole2D","rect","lineSegments","rectToLineSegments","pointInSphere","sphere","radius","radius2","INSIDE","OUTSIDE","clipT","tE","tL","t","box","da","db","pointInShapeFn","iMin","iMax","jMin","jMax","kMin","kMax","getData","rowSpacing","columnSpacing","scanAxisSpacing","worldPosStart","rowStep","columnStep","scanAxisStep","xMultiple","yMultiple","zMultiple","currentPos","k","startPosJ","startPosI","pointIJK","pointToString","decimals","parseFloat","getPoint","idx3","getPolyDataPointIndexes","polyData","linesData","getLines","segmentSize","contours","findStartingPoint","entries","nextPoint","getPolyDataPoints","contoursIndexes","rawPointsData","getPoints","contourIndexes","scrollSlabs","VolumeViewport","useSlabThickness","numScrollSteps","currentStepIndex","sliceRangeInfo","newFocalPoint","newPosition","desiredStepIndex","VolumeScrollEventDetail","currentImageId","EVENTS","VOLUME_SCROLL_OUT_OF_BOUNDS","VOLUME_VIEWPORT_SCROLL","scrollVolume","debounceLoading","ChangeTypesForInterpolation","HandlesUpdated","InterpolationUpdated","InterpolationManager","toolNames","addTool","acceptAutoGenerated","annotationGroupSelector","selector","interpolationUID","autoGenerated","interpolationCompleted","handleAnnotationCompleted","originalToolName","viewportData","sliceData","getSliceData","hasInterpolationUID","filterData","parentKey","interpolationAnnotations","skipUIDs","interpolationAnnotation","handleAnnotationUpdate","changeType","isInterpolationUpdate","handleAnnotationDelete","createImageIdReferenceMap","imageIdsArray","segmentationImageIds","lpad","string","character","join","getter","seed","onFlood","onBoundary","equals","diagonals","startNode","permutations","perms","permutation","parseInt","toString","permute","perm","countNonZeroes","prunedPermutations","stack","flooded","visits","bounds","currentArgs","flood","boundaries","job","getArgs","prevArgs","previousArgs","z","iKey","markAsVisited","member","markAsFlooded","nextArgs","pushAdjacent","markAsBoundary","getHoveredContourSegmentationAnnotation","annotationUIDs","getSegmentAtLabelmapBorder","worldPoint","searchRadius","labelmapData","LABELMAP","segmentationVolume","getScalarValueFromWorld","onEdge","getNeighborIndex","deltaI","deltaJ","neighborCanvas","isSegmentOnEdge","isSegmentOnEdgeCanvas","imageIdReferenceMap","segmentationImageId","segmentationRepresentations","getSegmentationIdRepresentations","segmentationRepresentationUID","segmentationActor","getActor","getMapper","getInputData","indexIJK","voxelManager","createVolumeVoxelManager","getAtIJKPoint","deltaK","neighborIJK","getAtIJK","isSegmentOnEdgeIJK","neighborRange","neighborIndex","getSegmentAtWorldPoint","desiredRepresentation","representationType","getSegmentAtWorldForLabelmap","Contour","contourData","segmentIndices","annotationsSet","getSegmentAtWorldForContour","invalidateBrushCursor","toolGroup","getToolGroup","tool","viewportsInfo","getViewportsInfo","viewportsInfoArray","getViewportIds","getBrushToolInstances","toolInstances","_toolInstances","toolInstance","getDeltaPoints","lastPoints","curr","getMeanPoints","page","_subtractPoints2D","client","point0","getDeltaDistance","_getDistance2D","_getDistance3D","getDeltaDistanceBetweenIPoints","currentDistance","_getMeanDistanceBetweenAllIPoints","lastDistance","copyPointsList","JSON","parse","stringify","copyPoints","prev","getMeanTouchPoints","touch","identifier","radiusX","radiusY","force","rotationAngle","pairedDistance","toolGroupIds","viewportInfo","Active","Passive","Enabled","ToolModes","filterViewportsWithToolEnabled","numViewports","viewportsWithToolEnabled","vp","_toolGroupHasActiveEnabledOrPassiveTool","toolOptions","toolMode","mode","EPS","vpCamera","requireParallelNormals","viewportsWithFrameOfReferenceUID","filterViewportsWithFrameOfReferenceUID","isViewportPreScaled","targetIdTokens","jumpToWorld","jumpWorld","normal","dotProd","projectedDelta","_applyShift","clamp","Right","ColorbarRangeTextPosition","getLuminanceFromRegion","luminance","spIndex","row","column","calculateMinMaxMean","pixelLuminance","globalMin","globalMax","numPixels","spv","extractWindowLevelRegionToolData","getVolumeId","cornerstoneImageMetaData","Rows","Columns","extractImageDataVolume","getCornerstoneImage","extractImageDataStack","_scriptDir","currentScript","ICRPolySegApp","readyPromiseResolve","readyPromiseReject","Module","readBinary","moduleOverrides","arguments_","thisProgram","quit_","status","toThrow","scriptDirectory","substr","lastIndexOf","wasmBinary","out","bind","wasmMemory","noExitRuntime","WebAssembly","abort","EXITSTATUS","HEAP8","HEAPU8","HEAP16","HEAPU16","HEAP32","HEAPU32","HEAPF32","HEAPF64","ABORT","UTF8Decoder","TextDecoder","UTF8ArrayToString","heapOrArray","maxBytesToRead","endIdx","endPtr","decode","subarray","str","u0","u1","u2","fromCharCode","ch","UTF8ToString","ptr","stringToUTF8Array","heap","outIdx","maxBytesToWrite","startIdx","u","charCodeAt","lengthBytesUTF8","updateGlobalBufferAndViews","buf","Int8Array","Int32Array","Uint32Array","Float64Array","wasmTable","wasmBinaryFile","path","__ATPRERUN__","__ATINIT__","__ATMAIN__","__ATPOSTRUN__","runDependencies","runDependencyWatcher","dependenciesFulfilled","what","RuntimeError","isDataURI","filename","getBinary","file","ASM_CONSTS","$0","updateProgress","ExitStatus","message","callRuntimeCallbacks","ExceptionInfo","excPtr","set_type","get_type","set_destructor","destructor","get_destructor","set_refcount","refcount","set_caught","caught","get_caught","set_rethrown","rethrown","get_rethrown","init","set_adjusted_ptr","add_ref","release_ref","adjustedPtr","get_adjusted_ptr","get_exception_ptr","___cxa_is_pointer_type","adjusted","SYSCALLS","varargs","getStr","structRegistrations","runDestructors","destructors","del","simpleReadValueFromPointer","pointer","awaitingDependencies","registeredTypes","typeDependencies","makeLegalFunctionName","f","createNamedFunction","body","Function","extendError","baseErrorType","errorName","errorClass","InternalError","throwInternalError","whenDependentTypesAreResolved","myTypes","dependentTypes","getTypeConverters","onComplete","typeConverters","myTypeConverters","registerType","unregisteredTypes","registered","dt","getShiftFromSize","embind_charCodes","readLatin1String","ret","BindingError","throwBindingError","rawType","registeredInstance","ignoreDuplicateRegistrations","emval_free_list","emval_handle_array","__emval_decref","count_emval_handles","get_first_emval","Emval","floatReadValueFromPointer","new_","argumentList","dummy","obj","exposePublicSymbol","numArguments","overloadTable","proto","humanName","prevFunc","arguments","argCount","ensureOverloadTable","wasmTableMirror","getWasmTableEntry","funcPtr","dynCall","sig","dynCallLegacy","embind__requireFunction","signature","rawFunction","argCache","fp","UnboundTypeError","getTypeName","___getTypeName","rv","_free","integerReadValueFromPointer","signed","UTF16Decoder","UTF16ToString","maxIdx","codeUnit","stringToUTF16","outPtr","startPtr","numCharsToWrite","lengthBytesUTF16","UTF32ToString","utf32","stringToUTF32","lengthBytesUTF32","requireRegisteredType","impl","emval_symbols","getStringOrSymbol","address","symbol","emval_methodCallers","emval_get_global","globalThis","emval_registeredMethods","emval_newers","readEmAsmArgsArray","runEmAsmFunction","code","sigPtr","argbuf","readEmAsmArgs","emscripten_realloc_buffer","grow","ENV","getEnvStrings","strings","env","navigator","languages","printCharBuffers","printChar","stream","__isLeapYear","year","__MONTH_DAYS_LEAP","__MONTH_DAYS_REGULAR","_strftime","s","maxsize","format","tm","tm_zone","date","tm_sec","tm_min","tm_hour","tm_mday","tm_mon","tm_year","tm_wday","tm_yday","tm_isdst","tm_gmtoff","pattern","EXPANSION_RULES_1","rule","RegExp","WEEKDAYS","MONTHS","leadingSomething","digits","leadingNulls","compareByDay","date1","date2","sgn","compare","getFullYear","getMonth","getDate","getFirstWeekStartDate","janFourth","getDay","getWeekBasedYear","thisDate","days","newDate","getTime","leap","currentMonth","daysInCurrentMonth","setDate","setMonth","setFullYear","__addDays","janFourthThisYear","janFourthNextYear","firstWeekStartThisYear","firstWeekStartNextYear","EXPANSION_RULES_2","twelveHour","__arraySum","jan1","dec31","off","ahead","stringy","dontAddNull","u8array","numBytesWritten","bytes","writeArrayToMemory","_proc_exit","codes","embind_init_charCodes","calledRun","asmLibraryArg","fd","dirp","dirfd","flags","bufsize","structType","reg","rawConstructor","rawDestructor","fieldRecords","fields","getterReturnType","setterArgumentType","fieldTypes","fieldName","getterContext","setter","setterContext","read","write","o","destructorFunction","primitiveType","minRange","maxRange","trueValue","falseValue","wt","rawArgTypesAddr","rawInvoker","fn","argTypes","firstElement","heap32VectorToArray","types","unboundTypes","seen","visit","throwUnboundTypeError","invokerArgsArray","replacePublicSymbol","classType","cppInvokerFunc","cppTargetFunc","isClassMethodFunc","needsDestructorStack","returns","argsList","argsListWired","invokerFnBody","dtorStack","args1","args2","paramName","craftInvokerFunction","fromWireType","bitshift","isUnsignedType","dataTypeIndex","TA","decodeMemoryView","stdStringIsUTF8","payload","decodeStartPtr","currentBytePtr","stringSegment","ArrayBuffer","valueIsOfTypeString","Uint8ClampedArray","_malloc","charCode","charSize","decodeString","encodeString","getHeap","lengthBytesUTF","HEAP","constructorSignature","destructorSignature","getterSignature","setterSignature","isVoid","returnType","destructorsRef","rd","caller","emval_lookupTypes","retType","signatureName","returnId","params","functionBody","invokerFunction","newer","craftEmvalAllocator","v","arg","dest","copyWithin","requestedSize","multiple","oldSize","maxHeapSize","cutDown","overGrownHeapSize","__environ","environ_buf","bufSize","writeAsciiToMemory","penviron_count","penviron_buf_size","iov","iovcnt","pnum","offset_low","offset_high","whence","newOffset","loc","info","receiveInstance","module","exports","unshift","removeRunDependency","receiveInstantiationResult","instantiateArrayBuffer","receiver","fetch","credentials","response","binary","instantiate","reason","instantiateStreaming","createWasm","callMain","entryFunction","handleException","run","doRun","shouldRunNow","postRun","preRun","runCaller","ready","ICRPolySeg","_instance","initialize","locateFile","Dir","m","algo","requestData","inData","outData","input","output","extractContours","modified","traverseLoop","pd","startLineId","startPtId","loopPoints","lineId","lastPtId","terminated","numInserted","cellPointIds","getCellPoints","ptId","lineCell","getPointCells","loops","clear","inLines","setData","li","getNumberOfCells","outLines","insertNextCell","vtkContourLoopExtraction","polySegConverters","polySeg","polySegInitializing","polySegInitializingPromise","initializePolySeg","progressCallback","convertContourToSurface","polylines","numPointsArray","convertContourRoiToSurface","convertLabelmapToSurface","convertContourToVolumeLabelmap","annotationUIDsInSegmentMap","segmentationVoxelManager","holesPolyline","projectedHole","point2D","setAtIJKPoint","convertContourToStackLabelmap","segmentationsInfo","segmentationVoxelManagers","segmentationInfo","manager","convertSurfaceToVolumeLabelmap","convertSurfaceToLabelmap","polys","convertSurfacesToVolumeLabelmap","segmentsInfo","targetImageData","totalSize","outputVolumesInfo","extent","getExtent","volumeInfo","roundedIndex","getSurfacesAABBs","surfacesInfo","aabbs","getAABB","numDimensions","cutSurfacesIntoPlanes","planesInfo","surfacesAABB","updateCacheCallback","numberOfPlanes","cutter","plane1","setCutFunction","surfacePolyData","planeInfo","planes","polyDataResults","polyDataInfo","aabb3","minZ","maxZ","isPlaneIntersectingAABB","getPolys","setInputData","setNormal","update","getOutputData","cutterOutput","buildLinks","loopExtraction","loopOutput","lines","numberOfCells","progress","vtkErrorMacro","dataDescription","EMPTY","setGetArray","getArray","setExtent","deleted","_len","inExtent","_key","extentArray","changeDetected","some","item","dims","nCells","getNumberOfPoints","ijk","SINGLE_POINT","X_LINE","Y_LINE","Z_LINE","XY_PLANE","YZ_PLANE","XZ_PLANE","XYZ_GRID","coords","getBounds","extentToBounds","getSpatialExtent","ex","computeTransforms","ain","aout","worldToIndexVec3","indexToWorldBounds","bin","bout","worldToIndexBounds","onModified","getCenter","computeHistogram","worldBounds","voxelFunc","yStride","zStride","pixels","maximum","minimum","sumOfSquares","isum","inum","pixel","average","variance","sigma","computeIncrements","increments","incr","computeOffsetIndex","_ref","getOffsetIndexFromWorld","xyz","comp","offsetIndex","getComponent","vtkImageData","vtkImageData$1","clamping","allowDuplicateScalars","setGet","setArray","getType","prevValue","functionType","function","getFirstNonZeroValue","allZero","MAX_VALUE","sharpness","setNodeValue","oldX","sortAndUpdateRange","addPoint","addPointLong","removePoint","setNodes","updateRange","oldRange","retVal","modifiedInvoked","addSegment","getValue","table","getTable","adjustRange","functionRange","estimateMinNumberOfSamples","d","findMinimumXDistance","ceil","currentDist","xStart","xEnd","stride","numNodes","lastValue","tidx","ss","sss","h1","h2","h3","h4","vtkPiecewiseFunction","vtkPiecewiseFunction$1","PLANE_TOLERANCE","COINCIDE","DISJOINT","distanceToPlane","projectPoint","xproj","xo","projectVector","vproj","n2","generalizedProjectPoint","intersectWithLine","outObj","betweenPoints","p21","p1Origin","den","fabsden","fabstolerance","intersectWithPlane","plane1Origin","plane1Normal","plane2Origin","plane2Normal","l0","l1","cross$1","absCross","maxc","iP","d1","d2","STATIC","evaluate","evaluateFunction","evaluateGradient","planeOrigin","planeNormal","vtkPlane","vtkPlane$1","vtkDebugMacro","vtkImageMarchingSquares","getContourValues","contourValues","setContourValues","cValues","ids","pixelScalars","pixelPts","edgeLocator","getPixelScalars","scalars","kernelX","kernelY","ii","getPixelPoints","produceLines","cVal","slicingMode","CASE_MASK","pId","pixelLines","getCase","eid","edgeVerts","getEdge","mergePoints","isInsertedEdge","x0","insertEdge","getOrigin","getKernels","cv","polydata","timeEnd","directionOfProjection","useHorizontalViewAngle","viewAngle","clippingRange","useOffAxisProjection","screenBottomLeft","screenBottomRight","screenTopRight","freezeFocalPoint","projectionMatrix","viewMatrix","cameraLightTransform","physicalTranslation","physicalScale","physicalViewUp","physicalViewNorth","dopbasis","upbasis","tmpMatrix","tmpMatrix2","tmpvec1","tmpvec2","tmpvec3","rotateMatrix","trans","computeViewPlaneNormal","orthogonalizeViewUp","vt","getViewMatrix","setPosition","computeDistance","setFocalPoint","setDistance","vec","dolly","amount","roll","eye","at","up","viewUpVec4","viewDir","azimuth","yaw","elevation","axis","pitch","zoom","factor","applyTransform","transformMat4","vuOld","posNew","fpNew","vuNew","setViewUp","getThickness","setThickness","thickness","setClippingRange","setThicknessFromFocalPoint","setRoll","getRoll","setObliqueAngles","alpha","beta","getOrientation","getOrientationWXYZ","getFrustumPlanes","getCameraLightTransformMatrix","matrix","computeCameraLightTransform","deepCopy","sourceCamera","physicalOrientationToWorldDirection","ori","oriq","coriq","qdir","getPhysicalToWorldMatrix","getWorldToPhysicalMatrix","physVRight","computeViewParametersFromViewMatrix","vmat","oldDist","setDirectionOfProjection","computeViewParametersFromPhysicalMatrix","mat","setViewMatrix","setProjectionMatrix","getProjectionMatrix","nearz","farz","cWidth","cRange","xmin","xmax","ymin","ymax","tmp","tan","znear","zfar","getCompositeProjectionMatrix","vMat","pMat","setDeviceAngles","screen","rotmat","dop","vup","setOrientationWXYZ","degrees","quatMat","newdop","newvup","computeClippingRange","vn","vtkCamera","vtkCamera$1","ColorSpace","Scale","ScalarMappingTarget","vtkWarningMacro","vtkColorTransferFunctionLabToMsh","lab","msh","L","M","acos","h","vtkColorTransferFunctionAdjustHue","unsatM","hueSpin","vtkColorTransferFunctionInterpolateDiverging","rgb1","rgb2","lab1","lab2","msh1","msh2","localS","adiff","vtkColorTransferFunctionAngleDiff","Mmid","mshTmp","labTmp","vtkColorTransferFunctionMshToLab","colorSpace","RGB","hSVWrap","LINEAR","nanColor","belowRangeColor","aboveRangeColor","useAboveRangeColor","useBelowRangeColor","tableSize","buildTime","discretize","numberOfValues","g","addRGBPointLong","addHSVPoint","addHSVPointLong","rgb","hsv","before","after","mappingRange","movePoint","addRGBSegment","g1","g2","addHSVSegment","s1","v1","s2","v2","hsv1","hsv2","mapValue","indexedLookup","getAnnotatedValueIndexInternal","getNanColorByReference","nodeVal","getRedValue","getGreenValue","getBlueValue","xStart_","xEnd_","lastR","lastG","lastB","tmpVec","usingLogScale","LOG10","logStart","logEnd","logX","log10","deltaRange","xn","discretizeIndex","getUseAboveRangeColor","getUseBelowRangeColor","HSV","hsvTmp","LAB","DIVERGING","getUint8Table","withAlpha","getMTime","tableWithAlpha","nbChannels","tmpTable","buildFunctionFromArray","getNumberOfTuples","buildFunctionFromTable","inc","getNumberOfAvailableColors","getIndexedColor","nodeValue","fillFromDataPointer","nb","originalRange","mapScalarsThroughTable","outFormat","inputOffset","mapDataIndexed","mapData","getAlpha","inIncr","outputV","inputV","RGBA","LUMINANCE","LUMINANCE_ALPHA","applyColorMap","colorMap","oldColorSpace","toUpperCase","isModified","oldNanColor","NanColor","oldNodes","callModified","vtkColorTransferFunction","vtkColorTransferFunction$1","presetMap","vtkColorMaps","addPreset","preset","removePresetByName","staticOffsetAPI","otherStaticMethods","SlicingMode","NONE","closestIJKAxis","ijkMode","flip","renderToRectangle","sliceAtFocalPoint","preferSizeOverAccuracy","implementCoincidentTopologyMethods","computeClosestIJKAxis","xyzMode","X","Y","Z","getCurrentImage","newMatrix","getSliceAtPosition","pos","pos3","isFinite","bds","getClosestIJKAxis","I","J","K","setSliceFromCamera","cam","getFocalPoint","setSlice","setXSlice","setSlicingMode","setYSlice","setZSlice","setISlice","setJSlice","setKSlice","getSlicingModeNormal","mat3","useCustomExtents","customDisplayExtent","nSlice","getBoundsForSlice","halfThickness","intersectWithLineForPointPicking","intersectWithLineForCellPicking","vtkImageMapper","vtkImageMapper$1","mapper","INIT_BOUNDS","boundsMTime","getImages","getIsOpaque","forceOpaque","forceTranslucent","isOpaque","getOpacity","hasTranslucentPolygonalGeometry","makeProperty","mapperBounds","computeMatrix","tmp4","getMinXBound","getMaxXBound","getMinYBound","getMaxYBound","getMinZBound","getMaxZBound","mt","mtime","getRedrawMTime","getInput","getInputAlgorithm","getSupportsSelection","vtkImageSlice","vtkImageSlice$1","bbox","vtkVolume","vtkVolume$1","proxyMarker","createEndpoint","releaseProxy","finalizer","throwMarker","isObject","transferHandlers","canHandle","serialize","port1","port2","MessageChannel","expose","deserialize","port","wrap","serialized","isError","ep","allowedOrigins","ev","allowedOrigin","test","isAllowedOrigin","fromWireValue","returnValue","parent","prop","rawValue","proxy","transfers","transferCache","transfer","wireValue","transferables","toWireValue","postMessage","closeEndPoint","endpoint","isMessagePort","close","target","createProxy","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","proxyFinalizers","FinalizationRegistry","newCount","isProxyReleased","Proxy","_target","unregister","unregisterProxy","_thisArg","rawArgumentList","processArguments","construct","registerProxy","processed","arr","handler","serializedValue","msg","MAX_SAFE_INTEGER","l","bisector","compare1","compare2","lo","hi","zero"],"sourceRoot":""}