{"version":3,"file":"993.bundle.df94e8125504991d12ea.js","mappings":"qGAGA,MAkQA,EAlQ8B,CAC5B,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,C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","sources":["webpack:///../../../node_modules/@cornerstonejs/tools/src/constants/COLOR_LUT.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/SVGCursorDescriptor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/elementCursor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/MouseCursor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/ImageMouseCursor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/SVGMouseCursor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/setCursorForElement.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/_getHash.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/setAttributesIfNecessary.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/setNewAttributesIfValid.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawCircle.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawEllipseByCoordinates.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawEllipse.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawHandle.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawHandles.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawLine.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawPolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawPath.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawTextBox.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawLink.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawLinkedTextBox.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawRectByCoordinates.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawRect.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawArrow.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawRedactionRect.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/ChangeTypes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/Events.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/SegmentationRepresentations.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/StrategyCallbacks.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/Touch.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/ToolBindings.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/AnnotationStyleStates.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/WorkerTypes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/imageRenderedEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/mouseToolEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/keyboardToolEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/cameraModifiedEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/imageSpacingCalibratedEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/touchToolEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/annotationInterpolationEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/cameraResetEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/annotations/contourSegmentation/contourSegmentationCompleted.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/mouse/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/touch/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/wheel/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/segmentation/segmentationRepresentationModifiedEventListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/segmentation/labelmap/onLabelmapSegmentationDataModified.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/segmentation/segmentationDataModifiedEventListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/segmentation/segmentationRepresentationRemovedEventListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/segmentation/segmentationModifiedEventListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/segmentation/imageChangeEventListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/annotations/annotationCompletedListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/annotations/annotationSelectionListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/annotations/annotationModifiedListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/annotations/annotationRemovedListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/annotations/contourSegmentation/contourSegmentationRemoved.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/annotations/annotationVisibilityListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/init.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/AnnotationGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/FrameOfReferenceSpecificAnnotationManager.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/annotationLocking.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/annotationSelection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/annotationState.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/annotationVisibility.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/config/ToolStyle.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/config/getFont.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/config/getState.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/config/helpers.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/helpers/state.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/activeSegmentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/config/segmentationVisibility.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/helpers/clipAndCacheSurfacesForViewport.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/removeSegmentationsFromToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/helpers/validateSegmentationInput.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/addSegmentations.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/config/segmentationConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/helpers/getRepresentationSpecificConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/addSegmentationRepresentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/addSegmentationRepresentations.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/addRepresentationData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/convertStackToVolumeSegmentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/convertVolumeToStackSegmentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/segmentLocking.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/config/segmentationColor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/computeAndAddRepresentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Surface/convertContourToSurface.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Surface/createAndCacheSurfacesFromRaw.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Surface/convertLabelmapToSurface.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Surface/surfaceComputationStrategies.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Surface/computeAndAddSurfaceRepresentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Surface/updateSurfaceData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Labelmap/convertContourToLabelmap.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Labelmap/convertSurfaceToLabelmap.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Labelmap/labelmapComputationStrategies.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Labelmap/computeAndAddLabelmapRepresentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Contour/utils/extractContourData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Contour/utils/createAndAddContourSegmentationsFromClippedSurfaces.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Contour/contourComputationStrategies.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Contour/computeAndAddContourRepresentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/canComputeRequestedRepresentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/registerPolySegWorker.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/segmentIndex.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/SegmentationStateManager.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/helpers/normalizeSegmentationInput.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/segmentationState.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/triggerSegmentationEvents.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/SynchronizerManager/Synchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/SynchronizerManager/getSynchronizersForViewport.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/SynchronizerManager/createSynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/SynchronizerManager/destroy.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/SynchronizerManager/getSynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/SynchronizerManager/getAllSynchronizers.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/SynchronizerManager/destroySynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/getToolGroupForViewport.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/addTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/addEnabledElement.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/removeEnabledElement.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/cancelActiveManipulations.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/state.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/svgNodeCache.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/callbacks/cameraSyncCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/synchronizers/createCameraPositionSynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/callbacks/presentationViewSyncCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/synchronizers/createPresentationViewSynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/callbacks/voiSyncCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/synchronizers/createVOISynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/callbacks/zoomPanSyncCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/synchronizers/createZoomPanSynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/callbacks/imageSliceSyncCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/callbacks/areViewportsCoplanar .ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/synchronizers/createImageSliceSynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/callbacks/slabThicknessSyncCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/synchronizers/createSlabThicknessSynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/AdvancedMagnifyTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/AnnotationEraserTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/CrosshairsTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/MIPJumpToClickTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/MagnifyTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/OrientationMarkerTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/OverlayGridTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/PanTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/PlanarRotateTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/ReferenceCursors.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/ReferenceLinesTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/ScaleOverlayTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/SculptorTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/SegmentationIntersectionTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/StackScrollTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/StackScrollToolMouseWheelTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/TrackballRotateTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/VolumeRotateMouseWheelTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/WindowLevelRegionTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/WindowLevelTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/ZoomTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/AngleTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/ArrowAnnotateTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/BidirectionalTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/CircleROITool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/CobbAngleTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/DragProbeTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/EllipticalROITool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/KeyImageTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/LengthTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/LivewireContourSegmentationTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/LivewireContourTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/PlanarFreehandContourSegmentationTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/ProbeTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/RectangleROITool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/SplineContourSegmentationTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/SplineROITool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/UltrasoundDirectionalTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/VideoRedactionTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/base/AnnotationDisplayTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/base/BaseTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/displayTools/Labelmap/labelmapDisplay.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/RectangleROIThresholdTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/RectangleROIStartEndThresholdTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/BrushTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/CircleROIStartEndThresholdTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/CircleScissorsTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/PaintFillTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/RectangleScissorsTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/SegmentSelectTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/SphereScissorsTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/UndoTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/types/ContourAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getViewportsForAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/vec2/findClosestPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getUniqueSegmentIndices.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/triggerSegmentationRender.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/triggerAnnotationRender.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/triggerAnnotationRenderForViewportIds.ts"],"sourcesContent":["/**\r\n * Cornerstone Color LUT used for Segmentations\r\n */\r\nconst CORNERSTONE_COLOR_LUT = [\r\n  [0, 0, 0, 0],\r\n  [221, 84, 84, 255],\r\n  [77, 228, 121, 255],\r\n  [166, 70, 235, 255],\r\n  [189, 180, 116, 255],\r\n  [109, 182, 196, 255],\r\n  [204, 101, 157, 255],\r\n  [123, 211, 94, 255],\r\n  [93, 87, 218, 255],\r\n  [225, 128, 80, 255],\r\n  [73, 232, 172, 255],\r\n  [181, 119, 186, 255],\r\n  [176, 193, 112, 255],\r\n  [105, 153, 200, 255],\r\n  [208, 97, 120, 255],\r\n  [90, 215, 101, 255],\r\n  [135, 83, 222, 255],\r\n  [229, 178, 76, 255],\r\n  [122, 183, 181, 255],\r\n  [190, 115, 171, 255],\r\n  [149, 197, 108, 255],\r\n  [100, 118, 205, 255],\r\n  [212, 108, 93, 255],\r\n  [86, 219, 141, 255],\r\n  [183, 79, 226, 255],\r\n  [233, 233, 72, 255],\r\n  [118, 167, 187, 255],\r\n  [194, 111, 146, 255],\r\n  [116, 201, 104, 255],\r\n  [115, 96, 209, 255],\r\n  [216, 147, 89, 255],\r\n  [82, 223, 188, 255],\r\n  [230, 75, 224, 255],\r\n  [163, 184, 121, 255],\r\n  [114, 143, 191, 255],\r\n  [198, 107, 114, 255],\r\n  [99, 206, 122, 255],\r\n  [153, 92, 213, 255],\r\n  [220, 192, 85, 255],\r\n  [78, 215, 227, 255],\r\n  [234, 71, 173, 255],\r\n  [141, 188, 117, 255],\r\n  [110, 113, 195, 255],\r\n  [202, 128, 103, 255],\r\n  [95, 210, 157, 255],\r\n  [195, 88, 217, 255],\r\n  [206, 224, 81, 255],\r\n  [74, 166, 231, 255],\r\n  [185, 120, 139, 255],\r\n  [113, 192, 113, 255],\r\n  [133, 106, 199, 255],\r\n  [207, 162, 98, 255],\r\n  [91, 214, 198, 255],\r\n  [221, 84, 198, 255],\r\n  [159, 228, 77, 255],\r\n  [70, 111, 235, 255],\r\n  [189, 119, 116, 255],\r\n  [109, 196, 138, 255],\r\n  [165, 101, 204, 255],\r\n  [211, 201, 94, 255],\r\n  [87, 191, 218, 255],\r\n  [225, 80, 153, 255],\r\n  [106, 232, 73, 255],\r\n  [124, 119, 186, 255],\r\n  [193, 142, 112, 255],\r\n  [105, 200, 168, 255],\r\n  [203, 97, 208, 255],\r\n  [184, 215, 90, 255],\r\n  [83, 147, 222, 255],\r\n  [229, 76, 101, 255],\r\n  [122, 183, 130, 255],\r\n  [146, 115, 190, 255],\r\n  [197, 171, 108, 255],\r\n  [100, 205, 205, 255],\r\n  [212, 93, 177, 255],\r\n  [141, 219, 86, 255],\r\n  [79, 97, 226, 255],\r\n  [233, 99, 72, 255],\r\n  [118, 187, 150, 255],\r\n  [173, 111, 194, 255],\r\n  [197, 201, 104, 255],\r\n  [96, 171, 209, 255],\r\n  [216, 89, 137, 255],\r\n  [94, 223, 82, 255],\r\n  [107, 75, 230, 255],\r\n  [184, 153, 121, 255],\r\n  [114, 191, 175, 255],\r\n  [198, 107, 191, 255],\r\n  [166, 206, 99, 255],\r\n  [92, 132, 213, 255],\r\n  [220, 85, 91, 255],\r\n  [78, 227, 115, 255],\r\n  [159, 71, 234, 255],\r\n  [188, 176, 117, 255],\r\n  [110, 185, 195, 255],\r\n  [202, 103, 161, 255],\r\n  [129, 210, 95, 255],\r\n  [88, 88, 217, 255],\r\n  [224, 123, 81, 255],\r\n  [74, 231, 166, 255],\r\n  [177, 120, 185, 255],\r\n  [179, 192, 113, 255],\r\n  [106, 156, 199, 255],\r\n  [207, 98, 125, 255],\r\n  [91, 214, 96, 255],\r\n  [130, 84, 221, 255],\r\n  [228, 171, 77, 255],\r\n  [70, 235, 221, 255],\r\n  [189, 116, 174, 255],\r\n  [153, 196, 109, 255],\r\n  [101, 123, 204, 255],\r\n  [211, 104, 94, 255],\r\n  [87, 218, 136, 255],\r\n  [177, 80, 225, 255],\r\n  [232, 225, 73, 255],\r\n  [119, 169, 186, 255],\r\n  [193, 112, 149, 255],\r\n  [121, 200, 105, 255],\r\n  [111, 97, 208, 255],\r\n  [215, 142, 90, 255],\r\n  [83, 222, 181, 255],\r\n  [229, 76, 229, 255],\r\n  [165, 183, 122, 255],\r\n  [115, 146, 190, 255],\r\n  [197, 108, 119, 255],\r\n  [100, 205, 118, 255],\r\n  [148, 93, 212, 255],\r\n  [219, 186, 86, 255],\r\n  [79, 220, 226, 255],\r\n  [233, 72, 179, 255],\r\n  [144, 187, 118, 255],\r\n  [111, 118, 194, 255],\r\n  [201, 124, 104, 255],\r\n  [96, 209, 153, 255],\r\n  [189, 89, 216, 255],\r\n  [211, 223, 82, 255],\r\n  [75, 172, 230, 255],\r\n  [184, 121, 142, 255],\r\n  [117, 191, 114, 255],\r\n  [130, 107, 198, 255],\r\n  [206, 157, 99, 255],\r\n  [92, 213, 193, 255],\r\n  [220, 85, 203, 255],\r\n  [165, 227, 78, 255],\r\n  [71, 118, 234, 255],\r\n  [188, 117, 117, 255],\r\n  [110, 195, 135, 255],\r\n  [161, 103, 202, 255],\r\n  [210, 195, 95, 255],\r\n  [88, 195, 217, 255],\r\n  [224, 81, 158, 255],\r\n  [113, 231, 74, 255],\r\n  [123, 120, 185, 255],\r\n  [192, 139, 113, 255],\r\n  [106, 199, 164, 255],\r\n  [198, 98, 207, 255],\r\n  [188, 214, 91, 255],\r\n  [84, 153, 221, 255],\r\n  [228, 77, 108, 255],\r\n  [70, 235, 84, 255],\r\n  [143, 116, 189, 255],\r\n  [196, 167, 109, 255],\r\n  [101, 204, 199, 255],\r\n  [211, 94, 182, 255],\r\n  [147, 218, 87, 255],\r\n  [80, 104, 225, 255],\r\n  [232, 93, 73, 255],\r\n  [119, 186, 147, 255],\r\n  [170, 112, 193, 255],\r\n  [200, 200, 105, 255],\r\n  [97, 175, 208, 255],\r\n  [215, 90, 142, 255],\r\n  [100, 222, 83, 255],\r\n  [101, 76, 229, 255],\r\n  [183, 150, 122, 255],\r\n  [115, 190, 171, 255],\r\n  [197, 108, 194, 255],\r\n  [170, 205, 100, 255],\r\n  [93, 138, 212, 255],\r\n  [219, 86, 97, 255],\r\n  [79, 226, 110, 255],\r\n  [153, 72, 233, 255],\r\n  [187, 173, 118, 255],\r\n  [111, 187, 194, 255],\r\n  [201, 104, 165, 255],\r\n  [134, 209, 96, 255],\r\n  [89, 95, 216, 255],\r\n  [223, 117, 82, 255],\r\n  [75, 230, 159, 255],\r\n  [174, 121, 184, 255],\r\n  [182, 191, 114, 255],\r\n  [107, 160, 198, 255],\r\n  [206, 99, 130, 255],\r\n  [92, 213, 92, 255],\r\n  [124, 85, 220, 255],\r\n  [227, 165, 78, 255],\r\n  [71, 234, 214, 255],\r\n  [188, 117, 176, 255],\r\n  [156, 195, 110, 255],\r\n  [103, 128, 202, 255],\r\n  [210, 100, 95, 255],\r\n  [88, 217, 131, 255],\r\n  [170, 81, 224, 255],\r\n  [231, 218, 74, 255],\r\n  [120, 172, 185, 255],\r\n  [192, 113, 153, 255],\r\n  [125, 199, 106, 255],\r\n  [107, 98, 207, 255],\r\n  [214, 137, 91, 255],\r\n  [84, 221, 175, 255],\r\n  [222, 77, 228, 255],\r\n  [194, 235, 70, 255],\r\n  [116, 149, 189, 255],\r\n  [196, 109, 123, 255],\r\n  [101, 204, 114, 255],\r\n  [143, 94, 211, 255],\r\n  [218, 180, 87, 255],\r\n  [80, 225, 225, 255],\r\n  [232, 73, 186, 255],\r\n  [147, 186, 119, 255],\r\n  [112, 122, 193, 255],\r\n  [200, 121, 105, 255],\r\n  [97, 208, 148, 255],\r\n  [184, 90, 215, 255],\r\n  [216, 222, 83, 255],\r\n  [76, 178, 229, 255],\r\n  [183, 122, 145, 255],\r\n  [121, 190, 115, 255],\r\n  [126, 108, 197, 255],\r\n  [205, 153, 100, 255],\r\n  [93, 212, 187, 255],\r\n  [219, 86, 208, 255],\r\n  [171, 226, 79, 255],\r\n  [72, 126, 233, 255],\r\n  [187, 118, 121, 255],\r\n  [111, 194, 132, 255],\r\n  [157, 104, 201, 255],\r\n  [209, 190, 96, 255],\r\n  [89, 200, 216, 255],\r\n  [223, 82, 164, 255],\r\n  [120, 230, 75, 255],\r\n  [121, 121, 184, 255],\r\n  [191, 136, 114, 255],\r\n  [107, 198, 160, 255],\r\n  [192, 99, 206, 255],\r\n  [193, 213, 92, 255],\r\n  [85, 158, 220, 255],\r\n  [227, 78, 115, 255],\r\n  [71, 234, 78, 255],\r\n  [141, 117, 188, 255],\r\n  [195, 163, 110, 255],\r\n  [103, 202, 194, 255],\r\n  [210, 95, 186, 255],\r\n  [153, 217, 88, 255],\r\n  [81, 111, 224, 255],\r\n];\r\n\r\nexport default CORNERSTONE_COLOR_LUT;\r\n","import { SVGCursorDescriptor } from '../types';\r\n\r\n/*\r\n * Definitions\r\n */\r\n\r\nconst BASE: SVGCursorDescriptor = {\r\n  iconContent: '',\r\n  iconSize: 16,\r\n  viewBox: {\r\n    x: 16,\r\n    y: 16,\r\n  },\r\n  mousePoint: {\r\n    x: 8,\r\n    y: 8,\r\n  },\r\n  mousePointerGroupString: `\r\n    <path stroke=\"{{color}}\" d=\"M8 16L8 0\"></path>\r\n    <path stroke=\"{{color}}\" d=\"M16 8L0 8\"></path>\r\n  `,\r\n};\r\n\r\nconst SEGMENTATION_CURSOR_BOUNDARIES = {\r\n  x: 127,\r\n  y: 60,\r\n};\r\n\r\nconst MINUS_RECT = `\r\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\r\n`;\r\n\r\nconst PLUS_RECT = `\r\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\r\n<rect fill=\"{{color}}\" x=\"95.84\" y=\"9.38\" width=\"15.85\" height=\"47.14\"/>\r\n`;\r\n\r\nconst SCISSOR_ICON = `<path fill=\"{{color}}\" d=\"M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z\" transform=\"translate(-1.17 -0.96)\"/>`;\r\nconst RECTANGLE_ICON = `<path fill=\"{{color}}\" d=\"M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z\" transform=\"translate(-8.86 -2.25)\"/>`;\r\nconst CIRCLE_ICON = `<path fill=\"{{color}}\" d=\"M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z\" transform=\"translate(-8.86 -2.25)\"/>`;\r\n\r\nconst CursorSVG: Record<string, SVGCursorDescriptor> = {\r\n  Angle: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50\r\n    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23\r\n    10l50 50q10 10 10 23z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  ArrowAnnotate: extend(BASE, {\r\n    iconContent: `<g id=\"arrowAnnotate-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <path id=\"arrowAnnotate-arrow\" d=\"M23,7 l-15,15 M7,17 l0,6 6,0\" stroke-width=\"2\" />\r\n  </g>`,\r\n    viewBox: {\r\n      x: 24,\r\n      y: 24,\r\n    },\r\n  }),\r\n  Bidirectional: extend(BASE, {\r\n    iconContent: `<g fill=\"{{color}}\" stroke-width=\"3\" stroke=\"{{color}}\">\r\n    <path d=\"M27.63 3.21L3.12 28.81\"></path>\r\n    <path d=\"M27.63 15.75L15.27 4.43\"></path>\r\n    <path d=\"M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z\" ></path>\r\n    <path d=\"M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z\"></path>\r\n    <path d=\"M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z\"></path>\r\n    <path d=\"M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z\"></path>\r\n  </g>`,\r\n    viewBox: {\r\n      x: 48,\r\n      y: 48,\r\n    },\r\n  }),\r\n  CobbAngle: extend(BASE, {\r\n    iconContent: `<g stroke=\"{{color}}\" stroke-width=\"3\">\r\n    <path d=\"M28.59 2.34L3.82 12.32\"></path>\r\n    <path d=\"M28.59 29.66L3.82 19.68\"></path>\r\n    <path stroke-dasharray=\"2\" fill-opacity=\"0\" d=\"M12.37\r\n      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15\r\n      9.33C13.11 9.24 13.02 9 12.88 8.63\">\r\n    </path>\r\n  </g>`,\r\n    viewBox: {\r\n      x: 32,\r\n      y: 32,\r\n    },\r\n  }),\r\n  CircleROI: extend(BASE, {\r\n    iconContent: `<circle stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" cx=\"16\" cy=\"16\" r=\"14\" />`,\r\n    viewBox: {\r\n      x: 32,\r\n      y: 32,\r\n    },\r\n  }),\r\n  EllipticalROI: extend(BASE, {\r\n    iconContent: `<path stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" d=\"M30.74 15.76C30.74 20.99 24.14 25.23 16\r\n    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14\r\n    6.3 30.74 10.54 30.74 15.76Z\" />`,\r\n    viewBox: {\r\n      x: 32,\r\n      y: 32,\r\n    },\r\n  }),\r\n  FreehandROI: extend(BASE, {\r\n    iconContent: `<g fill=\"{{color}}\" stroke=\"{{color}}\" stroke-width=\"2\">\r\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_3\" cy=\"4.240343\" cx=\"14.306499\"/>\r\n    <line id=\"svg_4\" y2=\"3.58462\" x2=\"12.242186\" y1=\"3.997482\" x1=\"13.432202\"/>\r\n    <line id=\"svg_5\" y2=\"3.268901\" x2=\"10.857882\" y1=\"3.608906\" x1=\"12.387902\"/>\r\n    <line id=\"svg_6\" y2=\"3.147471\" x2=\"9.740724\" y1=\"3.293187\" x1=\"10.955026\"/>\r\n    <line id=\"svg_7\" y2=\"3.147471\" x2=\"8.089274\" y1=\"3.196043\" x1=\"9.983585\"/>\r\n    <line id=\"svg_8\" y2=\"3.268901\" x2=\"6.874972\" y1=\"3.123185\" x1=\"8.307848\"/>\r\n    <line id=\"svg_9\" y2=\"3.657478\" x2=\"5.587812\" y1=\"3.220329\" x1=\"7.020688\"/>\r\n    <line id=\"svg_10\" y2=\"4.046054\" x2=\"4.737801\" y1=\"3.560334\" x1=\"5.854959\"/>\r\n    <line id=\"svg_11\" y2=\"4.337487\" x2=\"4.300652\" y1=\"3.997482\" x1=\"4.834945\"/>\r\n    <line id=\"svg_12\" y2=\"4.726063\" x2=\"3.88779\" y1=\"4.191771\" x1=\"4.470655\"/>\r\n    <line id=\"svg_15\" y2=\"5.3575\" x2=\"3.377783\" y1=\"4.604633\" x1=\"3.960648\"/>\r\n    <line id=\"svg_16\" y2=\"6.183226\" x2=\"2.916348\" y1=\"5.138926\" x1=\"3.547785\"/>\r\n    <line id=\"svg_17\" y2=\"6.960379\" x2=\"2.770632\" y1=\"5.867507\" x1=\"3.037779\"/>\r\n    <line id=\"svg_18\" y2=\"7.713246\" x2=\"2.673488\" y1=\"6.741804\" x1=\"2.819204\"/>\r\n    <line id=\"svg_19\" y2=\"8.684687\" x2=\"2.697774\" y1=\"7.616102\" x1=\"2.673488\"/>\r\n    <line id=\"svg_20\" y2=\"9.753273\" x2=\"2.892062\" y1=\"8.611829\" x1=\"2.697774\"/>\r\n    <line id=\"svg_21\" y2=\"10.724714\" x2=\"3.134923\" y1=\"9.534698\" x1=\"2.84349\"/>\r\n    <line id=\"svg_23\" y2=\"11.647583\" x2=\"3.596357\" y1=\"10.578998\" x1=\"3.086351\"/>\r\n    <line id=\"svg_25\" y2=\"12.521881\" x2=\"4.276366\" y1=\"11.501867\" x1=\"3.499213\"/>\r\n    <line id=\"svg_26\" y2=\"13.930471\" x2=\"5.830673\" y1=\"12.376165\" x1=\"4.13065\"/>\r\n    <line id=\"svg_28\" y2=\"14.707624\" x2=\"7.263549\" y1=\"13.881899\" x1=\"5.733528\"/>\r\n    <line id=\"svg_29\" y2=\"15.339061\" x2=\"8.963571\" y1=\"14.61048\" x1=\"7.06926\"/>\r\n    <line id=\"svg_30\" y2=\"15.581921\" x2=\"10.882168\" y1=\"15.314775\" x1=\"8.817855\"/>\r\n    <line id=\"svg_31\" y2=\"15.460491\" x2=\"12.023612\" y1=\"15.581921\" x1=\"10.785024\"/>\r\n    <line id=\"svg_33\" y2=\"15.120487\" x2=\"13.092197\" y1=\"15.484777\" x1=\"11.877895\"/>\r\n    <line id=\"svg_34\" y2=\"14.586194\" x2=\"13.86935\" y1=\"15.217631\" x1=\"12.897909\"/>\r\n    <line id=\"svg_35\" y2=\"13.833327\" x2=\"14.597931\" y1=\"14.756196\" x1=\"13.699348\"/>\r\n    <line id=\"svg_37\" y2=\"12.716169\" x2=\"15.180796\" y1=\"13.881899\" x1=\"14.549359\"/>\r\n    <line id=\"svg_39\" y2=\"11.429009\" x2=\"15.520801\" y1=\"12.813313\" x1=\"15.15651\"/>\r\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_40\" cy=\"10.967574\" cx=\"15.520801\"/>\r\n  </g>`,\r\n    viewBox: {\r\n      x: 18,\r\n      y: 18,\r\n    },\r\n  }),\r\n  FreehandROISculptor: extend(BASE, {\r\n    iconContent: `<g id=\"icon-freehand-sculpt\" fill=\"none\" stroke-width=\"1.5\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <line id=\"svg_1\" y2=\"2.559367\" x2=\"10.184807\" y1=\"4.467781\" x1=\"8.81711\"/>\r\n    <line id=\"svg_4\" y2=\"1.493836\" x2=\"11.727442\" y1=\"2.766112\" x1=\"10.089386\"/>\r\n    <line id=\"svg_7\" y2=\"1.080346\" x2=\"13.047428\" y1=\"1.748291\" x1=\"11.345759\"/>\r\n    <line id=\"svg_8\" y2=\"1.000829\" x2=\"14.351511\" y1=\"1.112153\" x1=\"12.77707\"/>\r\n    <line id=\"svg_9\" y2=\"1.350705\" x2=\"15.242104\" y1=\"0.905408\" x1=\"13.969828\"/>\r\n    <line id=\"svg_10\" y2=\"2.098167\" x2=\"15.862339\" y1=\"1.14396\" x1=\"14.955842\"/>\r\n    <line id=\"svg_11\" y2=\"3.195505\" x2=\"16.41896\" y1=\"1.939133\" x1=\"15.766918\"/>\r\n    <line id=\"svg_12\" y2=\"4.292843\" x2=\"16.530284\" y1=\"2.925147\" x1=\"16.387153\"/>\r\n    <line id=\"svg_16\" y2=\"5.644637\" x2=\"16.196311\" y1=\"3.831643\" x1=\"16.593898\"/>\r\n    <line id=\"svg_18\" y2=\"7.266789\" x2=\"15.623787\" y1=\"5.19934\" x1=\"16.275829\"/>\r\n    <line id=\"svg_19\" y2=\"10.813258\" x2=\"14.526449\" y1=\"6.726071\" x1=\"15.766918\"/>\r\n    <line id=\"svg_20\" y2=\"5.056209\" x2=\"8.085552\" y1=\"4.181519\" x1=\"8.976145\"/>\r\n    <line id=\"svg_23\" y2=\"5.326568\" x2=\"7.481221\" y1=\"4.78585\" x1=\"8.403621\"/>\r\n    <line id=\"svg_24\" y2=\"5.565119\" x2=\"6.749662\" y1=\"5.294761\" x1=\"7.624352\"/>\r\n    <line id=\"svg_25\" y2=\"5.994512\" x2=\"5.429675\" y1=\"5.533312\" x1=\"6.956407\"/>\r\n    <line id=\"svg_27\" y2=\"6.551133\" x2=\"4.284627\" y1=\"5.962706\" x1=\"5.572807\"/>\r\n    <line id=\"svg_28\" y2=\"7.584858\" x2=\"3.044158\" y1=\"6.392099\" x1=\"4.427758\"/>\r\n    <line id=\"svg_29\" y2=\"8.84123\" x2=\"2.185372\" y1=\"7.489437\" x1=\"3.219096\"/>\r\n    <line id=\"svg_31\" y2=\"10.606513\" x2=\"1.644654\" y1=\"8.602678\" x1=\"2.280792\"/>\r\n    <line id=\"svg_32\" y2=\"13.214679\" x2=\"1.48562\" y1=\"10.352058\" x1=\"1.724171\"/>\r\n    <line id=\"svg_33\" y2=\"14.375631\" x2=\"1.676461\" y1=\"12.992031\" x1=\"1.453813\"/>\r\n    <line id=\"svg_34\" y2=\"15.298031\" x2=\"2.264889\" y1=\"14.152983\" x1=\"1.517427\"/>\r\n    <line id=\"svg_35\" y2=\"16.172721\" x2=\"3.521261\" y1=\"14.948155\" x1=\"1.915013\"/>\r\n    <line id=\"svg_36\" y2=\"16.824762\" x2=\"5.207027\" y1=\"15.997783\" x1=\"3.28271\"/>\r\n    <line id=\"svg_38\" y2=\"17.063314\" x2=\"7.035924\" y1=\"16.745245\" x1=\"4.968475\"/>\r\n    <line id=\"svg_39\" y2=\"16.888376\" x2=\"9.278311\" y1=\"17.047411\" x1=\"6.733758\"/>\r\n    <line id=\"svg_40\" y2=\"16.284045\" x2=\"10.661911\" y1=\"16.983797\" x1=\"8.992048\"/>\r\n    <line id=\"svg_41\" y2=\"15.313934\" x2=\"11.647925\" y1=\"16.395369\" x1=\"10.455166\"/>\r\n    <line id=\"svg_44\" y2=\"13.898527\" x2=\"12.82478\" y1=\"15.425259\" x1=\"11.504794\"/>\r\n    <line id=\"svg_45\" y2=\"12.037824\" x2=\"14.144766\" y1=\"14.312017\" x1=\"12.522614\"/>\r\n    <line id=\"svg_47\" y2=\"10.59061\" x2=\"14.605966\" y1=\"12.228665\" x1=\"13.953925\"/>\r\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_48\" cy=\"3.982726\" cx=\"13.460918\"/>\r\n  </g>`,\r\n    viewBox: {\r\n      x: 18,\r\n      y: 18,\r\n    },\r\n  }),\r\n  Length: extend(BASE, {\r\n    iconContent: `<g id=\"length-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <path id=\"length-dashes\" d=\"m22.5,6 -16.5,16.5\" stroke-width=\"3\" stroke-dasharray=\"0.6666,5\" />\r\n  </g>`,\r\n    viewBox: {\r\n      x: 24,\r\n      y: 24,\r\n    },\r\n  }),\r\n  Probe: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75\r\n    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73\r\n    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5\r\n    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5\r\n    385.5-103 385.5 103 279.5 279.5 103 385.5z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  RectangleROI: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47\r\n    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0\r\n    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119\r\n    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  TextMarker: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M789 559l-170 450q33 0 136.5 2t160.5 2q19 0\r\n    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29\r\n    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15\r\n    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5\r\n    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0\r\n    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11\r\n    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0\r\n    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58\r\n    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  Crosshairs: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26\r\n    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45\r\n    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26\r\n    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5\r\n    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32\r\n    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5\r\n    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26\r\n    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26\r\n    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161\r\n    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161\r\n    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  Eraser: extend(BASE, {\r\n    iconContent: `<path transform=\"translate(0,1792) scale(1,-1)\" fill=\"{{color}}\" d=\"M960 1408l336-384h-768l-336 384h768zm1013-1077q15\r\n    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38\r\n    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38\r\n    0 69.5 20.5t47.5 54.5z\" />`,\r\n    viewBox: {\r\n      x: 2048,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  Magnify: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\r\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\r\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\r\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\r\n    32s176 78.7 176 176-78.7 176-176 176z\" />`,\r\n    viewBox: {\r\n      x: 512,\r\n      y: 512,\r\n    },\r\n  }),\r\n  Pan: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17\r\n    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355\r\n    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59\r\n    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12\r\n    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144\r\n    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19\r\n    45v448q0 42-39 59-13 5-25 5-26 0-45-19z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  Rotate: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39\r\n    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5\r\n    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0\r\n    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109\r\n    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298\r\n    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14\r\n    39 17 39 59z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  StackScroll: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547\r\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0\r\n    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547\r\n    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547\r\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z\" />`,\r\n    viewBox: {\r\n      x: 24,\r\n      y: 28,\r\n    },\r\n  }),\r\n  WindowLevelRegion: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119\r\n    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5\r\n    84.5t84.5 203.5z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  WindowLevel: extend(BASE, {\r\n    iconContent: `\r\n    <path fill=\"{{color}}\" d=\"M14.5,3.5 a1 1 0 0 1 -11,11 Z\" stroke=\"none\" opacity=\"0.8\" />\r\n    <circle cx=\"9\" cy=\"9\" r=\"8\" fill=\"none\" stroke-width=\"2\" stroke=\"{{color}}\" />`,\r\n    viewBox: {\r\n      x: 18,\r\n      y: 18,\r\n    },\r\n  }),\r\n  Zoom: extend(BASE, {\r\n    iconContent: `\r\n  <path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\r\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\r\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\r\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\r\n    32s176 78.7 176 176-78.7 176-176 176z\" />\r\n  <path fill=\"{{color}}\" transform=\"scale(0.22,0.22) translate(1400,0)\" d=\"M1216\r\n    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19\r\n    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26\r\n    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z\" />`,\r\n    viewBox: {\r\n      x: 640,\r\n      y: 512,\r\n    },\r\n  }),\r\n\r\n  /*\r\n   * Segmentation Cursors\r\n   */\r\n\r\n  SegmentationFreeHandEraseInside: extend(BASE, {\r\n    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  SegmentationFreeHandFillInside: extend(BASE, {\r\n    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  SegmentationFreeHandEraseOutside: extend(BASE, {\r\n    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  SegmentationFreeHandFillOutside: extend(BASE, {\r\n    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  SegmentationRectangleEraseInside: extend(BASE, {\r\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  // Default Rectangle Scissors\r\n  RectangleScissor: extend(BASE, {\r\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  'RectangleScissor.FILL_INSIDE': extend(BASE, {\r\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  'RectangleScissor.FILL_OUTSIDE': extend(BASE, {\r\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  'RectangleScissor.ERASE_OUTSIDE': extend(BASE, {\r\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  'RectangleScissor.ERASE_INSIDE': extend(BASE, {\r\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  CircleScissor: extend(BASE, {\r\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  'CircleScissor.FILL_INSIDE': extend(BASE, {\r\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  'CircleScissor.ERASE_OUTSIDE': extend(BASE, {\r\n    iconContent: `${CIRCLE_ICON} ${MINUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  'CircleScissor.FILL_OUTSIDE': extend(BASE, {\r\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n};\r\n\r\n/*\r\n * Utils\r\n */\r\n\r\nfunction extend(\r\n  base: SVGCursorDescriptor,\r\n  values: Record<string, unknown>\r\n): SVGCursorDescriptor {\r\n  return Object.assign(Object.create(base), values);\r\n}\r\n\r\n/**\r\n * Registers a cursor to the list, so that it will be used for the given `toolName`.\r\n * Overwrites the given cursor if it is already set.\r\n *\r\n * @param toolName - The name of the tool to assign a cursor to.\r\n * @param iconContent - The SVG icon content of the cursor.\r\n * @param viewBox - The viewBox of the cursor object.\r\n */\r\nfunction registerCursor(\r\n  toolName: string,\r\n  iconContent: string,\r\n  viewBox: { x: number; y: number }\r\n) {\r\n  CursorSVG[toolName] = extend(BASE, {\r\n    iconContent,\r\n    viewBox,\r\n  });\r\n}\r\n\r\nfunction getDefinedSVGCursorDescriptor(\r\n  name: string\r\n): SVGCursorDescriptor | undefined {\r\n  return CursorSVG[name];\r\n}\r\n\r\n/*\r\n * Exports\r\n */\r\nconst svgCursorNames = Object.keys(CursorSVG);\r\n\r\nexport {\r\n  getDefinedSVGCursorDescriptor,\r\n  registerCursor,\r\n  svgCursorNames,\r\n  CursorSVG,\r\n};\r\n","import { MouseCursor } from '.';\r\n\r\nconst ELEMENT_CURSORS_MAP = Symbol('ElementCursorsMap');\r\n\r\n/*\r\n * Public Methods\r\n */\r\n\r\nfunction initElementCursor(\r\n  element: HTMLDivElement,\r\n  cursor: MouseCursor | null\r\n): void {\r\n  _getElementCursors(element)[0] = cursor;\r\n  _setElementCursor(element, cursor);\r\n}\r\n\r\nfunction _setElementCursor(\r\n  element: HTMLDivElement,\r\n  cursor: MouseCursor | null\r\n): void {\r\n  const cursors = _getElementCursors(element);\r\n  cursors[1] = cursors[0];\r\n  cursors[0] = cursor;\r\n  element.style.cursor = (\r\n    cursor instanceof MouseCursor\r\n      ? cursor\r\n      : MouseCursor.getDefinedCursor('auto')\r\n  ).getStyleProperty();\r\n}\r\n\r\nfunction resetElementCursor(element: HTMLDivElement): void {\r\n  _setElementCursor(element, _getElementCursors(element)[1]);\r\n}\r\n\r\nfunction hideElementCursor(element: HTMLDivElement): void {\r\n  _setElementCursor(element, MouseCursor.getDefinedCursor('none'));\r\n}\r\n\r\n/*\r\n * Helpers\r\n */\r\n\r\nfunction _getElementCursors(\r\n  element: HTMLDivElement\r\n): [MouseCursor | null, MouseCursor | null] {\r\n  let map = _getElementCursors[ELEMENT_CURSORS_MAP];\r\n  if (!(map instanceof WeakMap)) {\r\n    map = new WeakMap();\r\n    Object.defineProperty(_getElementCursors, ELEMENT_CURSORS_MAP, {\r\n      value: map,\r\n    });\r\n  }\r\n  let cursors = map.get(element);\r\n  if (!cursors) {\r\n    cursors = [null, null];\r\n    map.set(element, cursors);\r\n  }\r\n  return cursors;\r\n}\r\n\r\n/*\r\n * Exports\r\n */\r\nexport {\r\n  initElementCursor,\r\n  resetElementCursor,\r\n  hideElementCursor,\r\n  _setElementCursor as setElementCursor,\r\n};\r\n","const DEFINED_CURSORS = Symbol('DefinedCursors');\r\nconst STANDARD_CURSORS = new Set([\r\n  'alias',\r\n  'all-scroll',\r\n  'auto',\r\n  'cell',\r\n  'col-resize',\r\n  'context-menu',\r\n  'copy',\r\n  'crosshair',\r\n  'default',\r\n  'e-resize',\r\n  'ew-resize',\r\n  'grab',\r\n  'grabbing',\r\n  'help',\r\n  'move',\r\n  'ne-resize',\r\n  'nesw-resize',\r\n  'no-drop',\r\n  'none',\r\n  'not-allowed',\r\n  'n-resize',\r\n  'ns-resize',\r\n  'nw-resize',\r\n  'nwse-resize',\r\n  'pointer',\r\n  'progress',\r\n  'row-resize',\r\n  'se-resize',\r\n  's-resize',\r\n  'sw-resize',\r\n  'text',\r\n  'vertical-text',\r\n  'wait',\r\n  'w-resize',\r\n  'zoom-in',\r\n  'zoom-out',\r\n]);\r\n\r\nexport default class MouseCursor {\r\n  private name: string;\r\n  private fallback: MouseCursor | undefined;\r\n\r\n  constructor(name: string, fallback?: MouseCursor | undefined) {\r\n    this.name = name + '';\r\n    this.fallback = fallback;\r\n  }\r\n\r\n  getName(): string {\r\n    return this.name + '';\r\n  }\r\n\r\n  addFallbackStyleProperty(style: string): string {\r\n    const { fallback } = this;\r\n    if (fallback instanceof MouseCursor) {\r\n      return `${style}, ${fallback.getStyleProperty()}`;\r\n    }\r\n    return style + '';\r\n  }\r\n\r\n  getStyleProperty(): string {\r\n    return this.addFallbackStyleProperty(this.name) + '';\r\n  }\r\n\r\n  static getDefinedCursor(name: string): MouseCursor | undefined {\r\n    const definedCursors = getDefinedCursors(\r\n      // @ts-ignore\r\n      MouseCursor as Record<symbol, Map<string, MouseCursor>>,\r\n      DEFINED_CURSORS\r\n    );\r\n    let mouseCursor = definedCursors.get(name);\r\n    if (mouseCursor instanceof MouseCursor) {\r\n      return mouseCursor;\r\n    }\r\n    if (STANDARD_CURSORS.has(name)) {\r\n      mouseCursor = new MouseCursor(name);\r\n      definedCursors.set(name, mouseCursor);\r\n      return mouseCursor;\r\n    }\r\n  }\r\n\r\n  static setDefinedCursor(name: string, cursor: MouseCursor): boolean {\r\n    if (cursor instanceof MouseCursor) {\r\n      const definedCursors = getDefinedCursors(\r\n        // @ts-ignore\r\n        MouseCursor as Record<symbol, Map<string, MouseCursor>>,\r\n        DEFINED_CURSORS\r\n      );\r\n      definedCursors.set(name, cursor);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\n/*\r\n * Helpers\r\n */\r\n\r\nfunction getDefinedCursors(\r\n  context: Record<symbol, Map<string, MouseCursor>>,\r\n  symbol: symbol\r\n): Map<string, MouseCursor> {\r\n  let definedCursors = context[symbol];\r\n  if (!(definedCursors instanceof Map)) {\r\n    definedCursors = new Map();\r\n    Object.defineProperty(context, symbol, { value: definedCursors });\r\n  }\r\n  return definedCursors;\r\n}\r\n\r\nconst standardCursorNames = STANDARD_CURSORS.values();\r\nexport { standardCursorNames };\r\n","import { utilities } from '@cornerstonejs/core';\r\nimport MouseCursor from './MouseCursor';\r\n\r\nconst DEFAULT_NAME = 'image-cursor';\r\n\r\nexport default class ImageMouseCursor extends MouseCursor {\r\n  private url: string;\r\n  private x: number;\r\n  private y: number;\r\n\r\n  constructor(\r\n    url: string,\r\n    x?: number,\r\n    y?: number,\r\n    name?: string | undefined,\r\n    fallback?: MouseCursor | undefined\r\n  ) {\r\n    super(\r\n      name || ImageMouseCursor.getUniqueInstanceName(DEFAULT_NAME),\r\n      fallback\r\n    );\r\n    this.url = url;\r\n    this.x = Number(x) || 0;\r\n    this.y = Number(y) || 0;\r\n  }\r\n\r\n  getStyleProperty(): string {\r\n    const { url, x, y } = this;\r\n    let style = `url('${url}')`;\r\n    if (x >= 0 && y >= 0 && (x > 0 || y > 0)) {\r\n      style += ` ${x} ${y}`;\r\n    }\r\n    return this.addFallbackStyleProperty(style);\r\n  }\r\n\r\n  static getUniqueInstanceName(prefix: string): string {\r\n    return `${prefix}-${utilities.getRuntimeId(ImageMouseCursor)}`;\r\n  }\r\n}\r\n","import { ToolModes, AnnotationStyleStates } from '../enums';\r\nimport MouseCursor from './MouseCursor';\r\nimport ImageMouseCursor from './ImageMouseCursor';\r\nimport { getDefinedSVGCursorDescriptor } from './SVGCursorDescriptor';\r\nimport { getStyleProperty } from '../stateManagement/annotation/config/helpers';\r\n\r\nimport type { StyleSpecifier } from '../types/AnnotationStyle';\r\nimport type { SVGCursorDescriptor } from '../types';\r\n\r\nconst PROPERTY = 'color';\r\nconst STATE = AnnotationStyleStates.Highlighted;\r\nconst MODE = ToolModes.Active;\r\n\r\nexport default class SVGMouseCursor extends ImageMouseCursor {\r\n  constructor(\r\n    url: string,\r\n    x?: number,\r\n    y?: number,\r\n    name?: string | undefined,\r\n    fallback?: MouseCursor | undefined\r\n  ) {\r\n    super(url, x, y, name, fallback);\r\n  }\r\n\r\n  /**\r\n   * Get a shared instance of the SVGMouseCursor class satisfying the given parameters.\r\n   *\r\n   * @param name - The name of the cursor (defined in SVGCursorDescriptor.ts);\r\n   * @param pointer - Should be true to use the version of the cursor containing\r\n   * a mouse pointer. Defaults to false (which does not add a pointer to the cursor);\r\n   * @param color - The color of the cursor. Defaults to tool.style.colorHighlightedActive;\r\n   * @returns a SVGMouseCursor instance or\r\n   * undefined if no SVG cursor descriptor was found with the given name;\r\n   */\r\n  static getDefinedCursor(\r\n    name: string,\r\n    pointer = false,\r\n    color?: string\r\n  ): MouseCursor {\r\n    if (!color) {\r\n      color = getStyleProperty(PROPERTY, {} as StyleSpecifier, STATE, MODE);\r\n    }\r\n    const urn = getCursorURN(name, pointer, color);\r\n    let cursor = super.getDefinedCursor(urn);\r\n    if (!cursor) {\r\n      const descriptor = getDefinedSVGCursorDescriptor(name);\r\n      if (descriptor) {\r\n        cursor = createSVGMouseCursor(\r\n          descriptor,\r\n          urn,\r\n          pointer,\r\n          color,\r\n          super.getDefinedCursor('default')\r\n        );\r\n        super.setDefinedCursor(urn, cursor);\r\n      }\r\n    }\r\n    return cursor;\r\n  }\r\n}\r\n\r\n/*\r\n * Helpers\r\n */\r\n\r\nfunction format(template: string, dictionary: Record<string, unknown>): string {\r\n  const dict = Object(dictionary);\r\n  const defined = Object.prototype.hasOwnProperty.bind(dict);\r\n  return (template + '').replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) => {\r\n    return defined(key) ? dict[key] + '' : '';\r\n  });\r\n}\r\n\r\nfunction getCursorURN(name: string, pointer: boolean, color: string) {\r\n  const type = pointer ? 'pointer' : 'cursor';\r\n  return `${type}:${name}/${color}`;\r\n}\r\n\r\nfunction createSVGMouseCursor(\r\n  descriptor: SVGCursorDescriptor,\r\n  name: string,\r\n  pointer: boolean,\r\n  color: string,\r\n  fallback: MouseCursor\r\n): SVGMouseCursor {\r\n  const { x, y } = descriptor.mousePoint;\r\n  return new SVGMouseCursor(\r\n    createSVGIconUrl(descriptor, pointer, { color }),\r\n    x,\r\n    y,\r\n    name,\r\n    fallback\r\n  );\r\n}\r\n\r\nfunction createSVGIconUrl(\r\n  descriptor: SVGCursorDescriptor,\r\n  pointer: boolean,\r\n  options: Record<string, unknown>\r\n): string {\r\n  return URL.createObjectURL(createSVGIconBlob(descriptor, pointer, options));\r\n}\r\n\r\nfunction createSVGIconBlob(\r\n  descriptor: SVGCursorDescriptor,\r\n  pointer: boolean,\r\n  options: Record<string, unknown>\r\n): Blob {\r\n  const svgString = (pointer ? createSVGIconWithPointer : createSVGIcon)(\r\n    descriptor,\r\n    options\r\n  );\r\n  return new Blob([svgString], { type: 'image/svg+xml' });\r\n}\r\n\r\nfunction createSVGIcon(\r\n  descriptor: SVGCursorDescriptor,\r\n  options: Record<string, unknown>\r\n): string {\r\n  const { iconContent, iconSize, viewBox } = descriptor;\r\n  const svgString = `\r\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\r\n      width=\"${iconSize}\" height=\"${iconSize}\" viewBox=\"0 0\r\n      ${viewBox.x} ${viewBox.y}\">\r\n      ${iconContent}\r\n    </svg>`;\r\n  return format(svgString, options);\r\n}\r\n\r\nfunction createSVGIconWithPointer(\r\n  descriptor: SVGCursorDescriptor,\r\n  options: Record<string, unknown>\r\n) {\r\n  const { iconContent, iconSize, viewBox, mousePointerGroupString } =\r\n    descriptor;\r\n  const scale = iconSize / Math.max(viewBox.x, viewBox.y, 1);\r\n  const svgSize = 16 + iconSize;\r\n  const svgString = `\r\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\r\n      width=\"${svgSize}\" height=\"${svgSize}\" viewBox=\"0 0 ${svgSize} ${svgSize}\">\r\n      <g>${mousePointerGroupString}</g>\r\n      <g transform=\"translate(16, 16) scale(${scale})\">${iconContent}</g>\r\n    </svg>`;\r\n  return format(svgString, options);\r\n}\r\n","import { setElementCursor } from './elementCursor';\r\nimport MouseCursor from './MouseCursor';\r\nimport SVGMouseCursor from './SVGMouseCursor';\r\n\r\n/**\r\n * Set the cursor for an HTML element. cursorNames can be either\r\n * cornerstone3DTools cursors or standard cursors.\r\n *\r\n * @param element - The element to set the cursor on.\r\n * @param cursorName - The name of the cursor to set. This can be\r\n * any cursor name either Cornerstone-specific cursor names or the standard\r\n * CSS cursor names.\r\n */\r\nfunction setCursorForElement(\r\n  element: HTMLDivElement,\r\n  cursorName: string\r\n): void {\r\n  let cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\r\n  if (!cursor) {\r\n    cursor = MouseCursor.getDefinedCursor(cursorName);\r\n  }\r\n\r\n  if (!cursor) {\r\n    console.log(\r\n      `Cursor ${cursorName} is not defined either as SVG or as a standard cursor.`\r\n    );\r\n    cursor = MouseCursor.getDefinedCursor(cursorName);\r\n  }\r\n\r\n  setElementCursor(element, cursor);\r\n}\r\n\r\nexport default setCursorForElement;\r\n","import MouseCursor, { standardCursorNames } from './MouseCursor';\r\nimport ImageMouseCursor from './ImageMouseCursor';\r\nimport SVGMouseCursor from './SVGMouseCursor';\r\nimport * as elementCursor from './elementCursor';\r\nimport setCursorForElement from './setCursorForElement';\r\nimport {\r\n  registerCursor,\r\n  svgCursorNames,\r\n  CursorSVG,\r\n} from './SVGCursorDescriptor';\r\n\r\n// Todo: this should be enum\r\nconst CursorNames = [...svgCursorNames, ...standardCursorNames];\r\n\r\nexport {\r\n  MouseCursor,\r\n  ImageMouseCursor,\r\n  SVGMouseCursor,\r\n  elementCursor,\r\n  registerCursor,\r\n  CursorNames,\r\n  CursorSVG,\r\n  setCursorForElement,\r\n};\r\n","function _getHash(\r\n  annotationUID: string,\r\n  drawingElementType: string,\r\n  nodeUID: string\r\n): string {\r\n  return `${annotationUID}::${drawingElementType}::${nodeUID}`;\r\n}\r\n\r\nexport default _getHash;\r\n","export function setAttributesIfNecessary(attributes, svgNode) {\r\n  Object.keys(attributes).forEach((key) => {\r\n    const currentValue = svgNode.getAttribute(key);\r\n    const newValue = attributes[key];\r\n    if (newValue === undefined || newValue === '') {\r\n      svgNode.removeAttribute(key);\r\n    } else if (currentValue !== newValue) {\r\n      svgNode.setAttribute(key, newValue);\r\n    }\r\n  });\r\n}\r\n\r\nexport default setAttributesIfNecessary;\r\n","export function setNewAttributesIfValid(attributes, svgNode) {\r\n  Object.keys(attributes).forEach((key) => {\r\n    const newValue = attributes[key];\r\n    if (newValue !== undefined && newValue !== '') {\r\n      svgNode.setAttribute(key, newValue);\r\n    }\r\n  });\r\n}\r\n\r\nexport default setNewAttributesIfValid;\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport { SVGDrawingHelper } from '../types';\r\n\r\nimport _getHash from './_getHash';\r\n\r\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\r\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\r\n\r\nfunction drawCircle(\r\n  svgDrawingHelper: SVGDrawingHelper,\r\n  annotationUID: string,\r\n  circleUID: string,\r\n  center: Types.Point2,\r\n  radius: number,\r\n  options = {},\r\n  dataId = ''\r\n): void {\r\n  const {\r\n    color,\r\n    fill,\r\n    width,\r\n    lineWidth,\r\n    lineDash,\r\n    fillOpacity,\r\n    strokeOpacity,\r\n  } = Object.assign(\r\n    {\r\n      color: 'rgb(0, 255, 0)',\r\n      fill: 'transparent',\r\n      width: '2',\r\n      lineDash: undefined,\r\n      lineWidth: undefined,\r\n      strokeOpacity: 1,\r\n      fillOpacity: 1,\r\n    },\r\n    options\r\n  );\r\n\r\n  // for supporting both lineWidth and width options\r\n  const strokeWidth = lineWidth || width;\r\n\r\n  // variable for the namespace\r\n  const svgns = 'http://www.w3.org/2000/svg';\r\n  const svgNodeHash = _getHash(annotationUID, 'circle', circleUID);\r\n  const existingCircleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\r\n\r\n  const attributes = {\r\n    cx: `${center[0]}`,\r\n    cy: `${center[1]}`,\r\n    r: `${radius}`,\r\n    stroke: color,\r\n    fill,\r\n    'stroke-width': strokeWidth,\r\n    'stroke-dasharray': lineDash,\r\n    'fill-opacity': fillOpacity, // setting fill opacity\r\n    'stroke-opacity': strokeOpacity, // setting stroke opacity\r\n  };\r\n\r\n  if (existingCircleElement) {\r\n    setAttributesIfNecessary(attributes, existingCircleElement);\r\n\r\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\r\n  } else {\r\n    const newCircleElement = document.createElementNS(svgns, 'circle');\r\n\r\n    if (dataId !== '') {\r\n      newCircleElement.setAttribute('data-id', dataId);\r\n    }\r\n\r\n    setNewAttributesIfValid(attributes, newCircleElement);\r\n\r\n    svgDrawingHelper.appendNode(newCircleElement, svgNodeHash);\r\n  }\r\n}\r\n\r\nexport default drawCircle;\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport { SVGDrawingHelper } from '../types';\r\n\r\nimport _getHash from './_getHash';\r\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\r\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\r\n\r\nfunction drawEllipseByCoordinates(\r\n  svgDrawingHelper: SVGDrawingHelper,\r\n  annotationUID: string,\r\n  ellipseUID: string,\r\n  canvasCoordinates: [Types.Point2, Types.Point2, Types.Point2, Types.Point2],\r\n  options = {},\r\n  dataId = ''\r\n): void {\r\n  const { color, width, lineWidth, lineDash } = Object.assign(\r\n    {\r\n      color: 'rgb(0, 255, 0)',\r\n      width: '2',\r\n      lineWidth: undefined,\r\n      lineDash: undefined,\r\n    },\r\n    options\r\n  );\r\n\r\n  // for supporting both lineWidth and width options\r\n  const strokeWidth = lineWidth || width;\r\n\r\n  const svgns = 'http://www.w3.org/2000/svg';\r\n  const svgNodeHash = _getHash(annotationUID, 'ellipse', ellipseUID);\r\n  const existingEllipse = svgDrawingHelper.getSvgNode(svgNodeHash);\r\n\r\n  const [bottom, top, left, right] = canvasCoordinates;\r\n\r\n  const w = Math.hypot(left[0] - right[0], left[1] - right[1]);\r\n  const h = Math.hypot(top[0] - bottom[0], top[1] - bottom[1]);\r\n  const angle =\r\n    (Math.atan2(left[1] - right[1], left[0] - right[0]) * 180) / Math.PI;\r\n\r\n  const center = [(left[0] + right[0]) / 2, (top[1] + bottom[1]) / 2];\r\n  const radiusX = w / 2;\r\n  const radiusY = h / 2;\r\n\r\n  const attributes = {\r\n    cx: `${center[0]}`,\r\n    cy: `${center[1]}`,\r\n    rx: `${radiusX}`,\r\n    ry: `${radiusY}`,\r\n    stroke: color,\r\n    fill: 'transparent',\r\n    transform: `rotate(${angle} ${center[0]} ${center[1]})`,\r\n    'stroke-width': strokeWidth,\r\n    'stroke-dasharray': lineDash,\r\n  };\r\n\r\n  if (existingEllipse) {\r\n    setAttributesIfNecessary(attributes, existingEllipse);\r\n\r\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\r\n  } else {\r\n    const svgEllipseElement = document.createElementNS(svgns, 'ellipse');\r\n\r\n    if (dataId !== '') {\r\n      svgEllipseElement.setAttribute('data-id', dataId);\r\n    }\r\n\r\n    setNewAttributesIfValid(attributes, svgEllipseElement);\r\n\r\n    svgDrawingHelper.appendNode(svgEllipseElement, svgNodeHash);\r\n  }\r\n}\r\n\r\nexport default drawEllipseByCoordinates;\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport { SVGDrawingHelper } from '../types';\r\n\r\nimport _getHash from './_getHash';\r\nimport drawEllipseByCoordinates from './drawEllipseByCoordinates';\r\n\r\nfunction drawEllipse(\r\n  svgDrawingHelper: SVGDrawingHelper,\r\n  annotationUID: string,\r\n  ellipseUID: string,\r\n  corner1: Types.Point2,\r\n  corner2: Types.Point2,\r\n  options = {},\r\n  dataId = ''\r\n) {\r\n  const top: Types.Point2 = [(corner1[0] + corner2[0]) / 2, corner1[1]];\r\n  const bottom: Types.Point2 = [(corner1[0] + corner2[0]) / 2, corner2[1]];\r\n  const left: Types.Point2 = [corner1[0], (corner1[1] + corner2[1]) / 2];\r\n  const right: Types.Point2 = [corner2[0], (corner1[1] + corner2[1]) / 2];\r\n\r\n  drawEllipseByCoordinates(\r\n    svgDrawingHelper,\r\n    annotationUID,\r\n    ellipseUID,\r\n    [bottom, top, left, right],\r\n    (options = {}),\r\n    (dataId = '')\r\n  );\r\n}\r\n\r\nexport default drawEllipse;\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\nimport _getHash from './_getHash';\r\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\r\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\r\nimport { SVGDrawingHelper } from '../types';\r\n\r\nfunction drawHandle(\r\n  svgDrawingHelper: SVGDrawingHelper,\r\n  annotationUID: string,\r\n  handleGroupUID: string,\r\n  handle: Types.Point2,\r\n  options = {},\r\n  uniqueIndex\r\n): void {\r\n  const { color, handleRadius, width, lineWidth, fill, type, opacity } =\r\n    Object.assign(\r\n      {\r\n        color: 'rgb(0, 255, 0)',\r\n        handleRadius: '6',\r\n        width: '2',\r\n        lineWidth: undefined,\r\n        fill: 'transparent',\r\n        type: 'circle',\r\n        opacity: 1,\r\n      },\r\n      options\r\n    );\r\n\r\n  // for supporting both lineWidth and width options\r\n  const strokeWidth = lineWidth || width;\r\n\r\n  // variable for the namespace\r\n  const svgns = 'http://www.w3.org/2000/svg';\r\n  const svgNodeHash = _getHash(\r\n    annotationUID,\r\n    'handle',\r\n    `hg-${handleGroupUID}-index-${uniqueIndex}`\r\n  );\r\n\r\n  let attributes;\r\n  if (type === 'circle') {\r\n    attributes = {\r\n      cx: `${handle[0]}`,\r\n      cy: `${handle[1]}`,\r\n      r: handleRadius,\r\n      stroke: color,\r\n      fill,\r\n      'stroke-width': strokeWidth,\r\n      opacity: opacity,\r\n    };\r\n  } else if (type === 'rect') {\r\n    const handleRadiusFloat = parseFloat(handleRadius);\r\n    const side = handleRadiusFloat * 1.5;\r\n    const x = handle[0] - side * 0.5;\r\n    const y = handle[1] - side * 0.5;\r\n\r\n    attributes = {\r\n      x: `${x}`,\r\n      y: `${y}`,\r\n      width: `${side}`,\r\n      height: `${side}`,\r\n      stroke: color,\r\n      fill,\r\n      'stroke-width': strokeWidth,\r\n      rx: `${side * 0.1}`,\r\n      opacity: opacity,\r\n    };\r\n  } else {\r\n    throw new Error(`Unsupported handle type: ${type}`);\r\n  }\r\n\r\n  const existingHandleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\r\n\r\n  if (existingHandleElement) {\r\n    setAttributesIfNecessary(attributes, existingHandleElement);\r\n\r\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\r\n  } else {\r\n    const newHandleElement = document.createElementNS(svgns, type);\r\n\r\n    setNewAttributesIfValid(attributes, newHandleElement);\r\n\r\n    svgDrawingHelper.appendNode(newHandleElement, svgNodeHash);\r\n  }\r\n}\r\n\r\nexport default drawHandle;\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\nimport { SVGDrawingHelper } from '../types';\r\nimport drawHandle from './drawHandle';\r\n\r\nfunction drawHandles(\r\n  svgDrawingHelper: SVGDrawingHelper,\r\n  annotationUID: string,\r\n  handleGroupUID: string,\r\n  handlePoints: Array<Types.Point2>,\r\n  options = {}\r\n): void {\r\n  handlePoints.forEach((handle, i) => {\r\n    drawHandle(\r\n      svgDrawingHelper,\r\n      annotationUID,\r\n      handleGroupUID,\r\n      handle,\r\n      options,\r\n      i\r\n    );\r\n  });\r\n}\r\n\r\nexport default drawHandles;\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\nimport _getHash from './_getHash';\r\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\r\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\r\nimport { SVGDrawingHelper } from '../types';\r\n\r\nexport default function drawLine(\r\n  svgDrawingHelper: SVGDrawingHelper,\r\n  annotationUID: string,\r\n  lineUID: string,\r\n  start: Types.Point2,\r\n  end: Types.Point2,\r\n  options = {},\r\n  dataId = ''\r\n): void {\r\n  // if length is NaN return\r\n  if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\r\n    return;\r\n  }\r\n\r\n  const { color, width, lineWidth, lineDash, shadow } = Object.assign(\r\n    {\r\n      color: 'rgb(0, 255, 0)',\r\n      width: '2',\r\n      lineWidth: undefined,\r\n      lineDash: undefined,\r\n      shadow: undefined,\r\n    },\r\n    options\r\n  );\r\n\r\n  // for supporting both lineWidth and width options\r\n  const strokeWidth = lineWidth || width;\r\n\r\n  const svgns = 'http://www.w3.org/2000/svg';\r\n  const svgNodeHash = _getHash(annotationUID, 'line', lineUID);\r\n  const existingLine = svgDrawingHelper.getSvgNode(svgNodeHash);\r\n  const dropShadowStyle = shadow\r\n    ? `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`\r\n    : '';\r\n\r\n  const attributes = {\r\n    x1: `${start[0]}`,\r\n    y1: `${start[1]}`,\r\n    x2: `${end[0]}`,\r\n    y2: `${end[1]}`,\r\n    stroke: color,\r\n    style: dropShadowStyle,\r\n    'stroke-width': strokeWidth,\r\n    'stroke-dasharray': lineDash,\r\n  };\r\n\r\n  if (existingLine) {\r\n    // This is run to avoid re-rendering annotations that actually haven't changed\r\n    setAttributesIfNecessary(attributes, existingLine);\r\n\r\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\r\n  } else {\r\n    const newLine = document.createElementNS(svgns, 'line');\r\n\r\n    if (dataId !== '') {\r\n      newLine.setAttribute('data-id', dataId);\r\n    }\r\n\r\n    setNewAttributesIfValid(attributes, newLine);\r\n\r\n    svgDrawingHelper.appendNode(newLine, svgNodeHash);\r\n  }\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport _getHash from './_getHash';\r\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\r\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\r\nimport { SVGDrawingHelper } from '../types';\r\n\r\n/**\r\n * Draws an SVG polyline with the given points.\r\n *\r\n * The `closePath` option, if true, draws a closed polyline, with the\r\n * last point connected to the first.\r\n */\r\nexport default function drawPolyline(\r\n  svgDrawingHelper: SVGDrawingHelper,\r\n  annotationUID: string,\r\n  polylineUID: string,\r\n  points: Types.Point2[],\r\n  options: {\r\n    color?: string;\r\n    fillColor?: string;\r\n    fillOpacity?: number;\r\n    width?: number;\r\n    lineWidth?: number;\r\n    lineDash?: string;\r\n    closePath?: boolean;\r\n  }\r\n): void {\r\n  if (points.length < 2) {\r\n    return;\r\n  }\r\n\r\n  const {\r\n    color = 'rgb(0, 255, 0)',\r\n    width = 10,\r\n    fillColor = 'none',\r\n    fillOpacity = 0,\r\n    lineWidth,\r\n    lineDash,\r\n    closePath = false,\r\n  } = options;\r\n\r\n  // for supporting both lineWidth and width options\r\n  const strokeWidth = lineWidth || width;\r\n\r\n  const svgns = 'http://www.w3.org/2000/svg';\r\n  const svgNodeHash = _getHash(annotationUID, 'polyline', polylineUID);\r\n  const existingPolyLine = svgDrawingHelper.getSvgNode(svgNodeHash);\r\n\r\n  let pointsAttribute = '';\r\n\r\n  for (const point of points) {\r\n    pointsAttribute += `${point[0].toFixed(1)}, ${point[1].toFixed(1)} `;\r\n  }\r\n\r\n  if (closePath) {\r\n    const firstPoint = points[0];\r\n\r\n    pointsAttribute += `${firstPoint[0]}, ${firstPoint[1]}`;\r\n  }\r\n\r\n  const attributes = {\r\n    points: pointsAttribute,\r\n    stroke: color,\r\n    fill: fillColor,\r\n    'fill-opacity': fillOpacity,\r\n    'stroke-width': strokeWidth,\r\n    'stroke-dasharray': lineDash,\r\n  };\r\n\r\n  if (existingPolyLine) {\r\n    // This is run to avoid re-rendering annotations that actually haven't changed\r\n    setAttributesIfNecessary(attributes, existingPolyLine);\r\n\r\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\r\n  } else {\r\n    const newPolyLine = document.createElementNS(svgns, 'polyline');\r\n\r\n    setNewAttributesIfValid(attributes, newPolyLine);\r\n\r\n    svgDrawingHelper.appendNode(newPolyLine, svgNodeHash);\r\n  }\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport _getHash from './_getHash';\r\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\r\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\r\nimport { SVGDrawingHelper } from '../types';\r\n\r\n/**\r\n * Draws an SVG path with the given points.\r\n *\r\n * The `closePath` option, if true, draws a closed path (last point\r\n * connected to the first).\r\n */\r\nexport default function drawPath(\r\n  svgDrawingHelper: SVGDrawingHelper,\r\n  annotationUID: string,\r\n  pathUID: string,\r\n  points: Types.Point2[] | Types.Point2[][],\r\n  options: {\r\n    color?: string;\r\n    fillColor?: string;\r\n    fillOpacity?: number;\r\n    width?: number;\r\n    lineWidth?: number;\r\n    lineDash?: string;\r\n    closePath?: boolean;\r\n  }\r\n): void {\r\n  // It may be a polyline with holes that will be an array with multiple\r\n  // 'points' arrays\r\n  const hasSubArrays =\r\n    points.length && points[0].length && Array.isArray(points[0][0]);\r\n\r\n  const pointsArrays = hasSubArrays ? points : [points];\r\n  const {\r\n    color = 'rgb(0, 255, 0)',\r\n    width = 10,\r\n    fillColor = 'none',\r\n    fillOpacity = 0,\r\n    lineWidth,\r\n    lineDash,\r\n    closePath = false,\r\n  } = options;\r\n\r\n  // for supporting both lineWidth and width options\r\n  const strokeWidth = lineWidth || width;\r\n\r\n  const svgns = 'http://www.w3.org/2000/svg';\r\n  const svgNodeHash = _getHash(annotationUID, 'path', pathUID);\r\n  const existingNode = svgDrawingHelper.getSvgNode(svgNodeHash);\r\n  let pointsAttribute = '';\r\n\r\n  for (let i = 0, numArrays = pointsArrays.length; i < numArrays; i++) {\r\n    const points = pointsArrays[i];\r\n    const numPoints = points.length;\r\n\r\n    if (numPoints < 2) {\r\n      continue;\r\n    }\r\n\r\n    for (let j = 0; j < numPoints; j++) {\r\n      const point = points[j];\r\n      const cmd = j ? 'L' : 'M';\r\n\r\n      pointsAttribute += `${cmd} ${point[0].toFixed(1)}, ${point[1].toFixed(\r\n        1\r\n      )} `;\r\n    }\r\n\r\n    if (closePath) {\r\n      pointsAttribute += 'Z ';\r\n    }\r\n  }\r\n\r\n  if (!pointsAttribute) {\r\n    return;\r\n  }\r\n\r\n  const attributes = {\r\n    d: pointsAttribute,\r\n    stroke: color,\r\n    fill: fillColor,\r\n    'fill-opacity': fillOpacity,\r\n    'stroke-width': strokeWidth,\r\n    'stroke-dasharray': lineDash,\r\n  };\r\n\r\n  if (existingNode) {\r\n    // This is run to avoid re-rendering annotations that actually haven't changed\r\n    setAttributesIfNecessary(attributes, existingNode);\r\n\r\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\r\n  } else {\r\n    const newNode = document.createElementNS(svgns, 'path');\r\n\r\n    setNewAttributesIfValid(attributes, newNode);\r\n    svgDrawingHelper.appendNode(newNode, svgNodeHash);\r\n  }\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport { SVGDrawingHelper } from '../types';\r\n\r\nimport _getHash from './_getHash';\r\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\r\n\r\n/**\r\n * Draws a textBox.\r\n *\r\n * @param textLines - The text to display.\r\n * @param position - The x/y position of the textbox\r\n * @param options - Options for the textBox.\r\n * @returns Bounding box; can be used for isPointNearTool\r\n */\r\nfunction drawTextBox(\r\n  svgDrawingHelper: SVGDrawingHelper,\r\n  annotationUID: string,\r\n  textUID: string,\r\n  textLines: Array<string>,\r\n  position: Types.Point2,\r\n  options = {}\r\n): SVGRect {\r\n  const mergedOptions = Object.assign(\r\n    {\r\n      fontFamily: 'Helvetica, Arial, sans-serif',\r\n      fontSize: '14px',\r\n      color: 'rgb(255, 255, 0)',\r\n      background: '',\r\n      padding: 25,\r\n      centerX: false,\r\n      centerY: true,\r\n    },\r\n    options\r\n  );\r\n\r\n  // Draw each of the text lines on top of the background box\r\n  const textGroupBoundingBox = _drawTextGroup(\r\n    svgDrawingHelper,\r\n    annotationUID,\r\n    textUID,\r\n    textLines,\r\n    position,\r\n    mergedOptions\r\n  );\r\n\r\n  return textGroupBoundingBox;\r\n}\r\n\r\nfunction _drawTextGroup(\r\n  svgDrawingHelper: SVGDrawingHelper,\r\n  annotationUID: string,\r\n  textUID: string,\r\n  textLines: Array<string> = [''],\r\n  position: Types.Point2,\r\n  options: any\r\n): SVGRect {\r\n  const { padding, color, fontFamily, fontSize, background } = options;\r\n\r\n  let textGroupBoundingBox;\r\n  const [x, y] = [position[0] + padding, position[1] + padding];\r\n  const svgns = 'http://www.w3.org/2000/svg';\r\n  const svgNodeHash = _getHash(annotationUID, 'text', textUID);\r\n  const existingTextGroup = svgDrawingHelper.getSvgNode(svgNodeHash);\r\n\r\n  // Todo: right now textBox gets a re-render even if the textBox has not changed\r\n  // and evenIf the attributes are not set again since they are the same.\r\n  if (existingTextGroup) {\r\n    // TODO: Iterate each node and update color? font-size?\r\n    const textElement = existingTextGroup.querySelector('text');\r\n    const textSpans = Array.from(textElement.children) as Array<SVGElement>;\r\n\r\n    for (let i = 0; i < textSpans.length; i++) {\r\n      const textSpanElement = textSpans[i];\r\n      const text = textLines[i] || '';\r\n\r\n      textSpanElement.textContent = text;\r\n    }\r\n\r\n    // if the textLines have changed size, we need to create textSpans for them\r\n    if (textLines.length > textSpans.length) {\r\n      for (let i = 0; i < textLines.length - textSpans.length; i++) {\r\n        const textLine = textLines[i + textSpans.length];\r\n        const textSpan = _createTextSpan(textLine);\r\n\r\n        textElement.appendChild(textSpan);\r\n      }\r\n\r\n      existingTextGroup.appendChild(textElement);\r\n      svgDrawingHelper.appendNode(existingTextGroup, svgNodeHash);\r\n    }\r\n\r\n    const textAttributes = {\r\n      fill: color,\r\n      'font-size': fontSize,\r\n      'font-family': fontFamily,\r\n    };\r\n\r\n    const textGroupAttributes = {\r\n      transform: `translate(${x} ${y})`,\r\n    };\r\n\r\n    // Todo: for some reason this does not work to not re-render the textBox\r\n    setAttributesIfNecessary(textAttributes, textElement);\r\n    setAttributesIfNecessary(textGroupAttributes, existingTextGroup);\r\n\r\n    textGroupBoundingBox = _drawTextBackground(existingTextGroup, background);\r\n\r\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\r\n  } else {\r\n    const textGroup = document.createElementNS(svgns, 'g');\r\n\r\n    textGroup.setAttribute('transform', `translate(${x} ${y})`);\r\n\r\n    //\r\n    const textElement = _createTextElement(svgDrawingHelper, options);\r\n    for (let i = 0; i < textLines.length; i++) {\r\n      const textLine = textLines[i];\r\n      const textSpan = _createTextSpan(textLine);\r\n\r\n      textElement.appendChild(textSpan);\r\n    }\r\n\r\n    textGroup.appendChild(textElement);\r\n    svgDrawingHelper.appendNode(textGroup, svgNodeHash);\r\n    textGroupBoundingBox = _drawTextBackground(textGroup, background);\r\n  }\r\n\r\n  // We translate the group using `position`\r\n  // which means we also need to pluck those values when returning\r\n  // the bounding box\r\n  return Object.assign({}, textGroupBoundingBox, {\r\n    x,\r\n    y,\r\n    height: textGroupBoundingBox.height + padding,\r\n    width: textGroupBoundingBox.width + padding,\r\n  });\r\n}\r\n\r\nfunction _createTextElement(\r\n  svgDrawingHelper: SVGDrawingHelper,\r\n  options: any\r\n): SVGElement {\r\n  const { color, fontFamily, fontSize } = options;\r\n  const svgns = 'http://www.w3.org/2000/svg';\r\n  const textElement = document.createElementNS(svgns, 'text');\r\n  const noSelectStyle =\r\n    'user-select: none; pointer-events: none; -webkit-tap-highlight-color:  rgba(255, 255, 255, 0);';\r\n  const dropShadowStyle = `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`;\r\n  const combinedStyle = `${noSelectStyle}${dropShadowStyle}`;\r\n\r\n  // font-size=\"100\"\r\n  textElement.setAttribute('x', '0');\r\n  textElement.setAttribute('y', '0');\r\n  textElement.setAttribute('fill', color);\r\n  textElement.setAttribute('font-family', fontFamily);\r\n  textElement.setAttribute('font-size', fontSize);\r\n  textElement.setAttribute('style', combinedStyle);\r\n\r\n  return textElement;\r\n}\r\n\r\nfunction _createTextSpan(text): SVGElement {\r\n  const svgns = 'http://www.w3.org/2000/svg';\r\n  const textSpanElement = document.createElementNS(svgns, 'tspan');\r\n\r\n  // TODO: centerX\r\n  // (parent width / 2) - my width\r\n  // TODO: centerY\r\n\r\n  textSpanElement.setAttribute('x', '0');\r\n  textSpanElement.setAttribute('dy', '1.2em');\r\n  textSpanElement.textContent = text;\r\n\r\n  return textSpanElement;\r\n}\r\n\r\nfunction _drawTextBackground(group: SVGGElement, color: string) {\r\n  let element = group.querySelector('rect.background');\r\n\r\n  // If we have no background color, remove any element that exists and return\r\n  // the bounding box of the text\r\n  if (!color) {\r\n    if (element) {\r\n      group.removeChild(element);\r\n    }\r\n\r\n    return group.getBBox();\r\n  }\r\n\r\n  // Otherwise, check if we have a <rect> element. If not, create one\r\n  if (!element) {\r\n    element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\r\n    element.setAttribute('class', 'background');\r\n    group.insertBefore(element, group.firstChild);\r\n  }\r\n\r\n  // Get the text groups's bounding box and use it to draw the background rectangle\r\n  const bBox = group.getBBox();\r\n\r\n  const attributes = {\r\n    x: `${bBox.x}`,\r\n    y: `${bBox.y}`,\r\n    width: `${bBox.width}`,\r\n    height: `${bBox.height}`,\r\n    fill: color,\r\n  };\r\n\r\n  setAttributesIfNecessary(attributes, element);\r\n\r\n  return bBox;\r\n}\r\n\r\nexport default drawTextBox;\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\nimport drawLine from './drawLine';\r\nimport findClosestPoint from '../utilities/math/vec2/findClosestPoint';\r\nimport { PlanarBoundingBox, SVGDrawingHelper } from '../types';\r\n\r\n/**\r\n * Draw a link between an annotation to a box.\r\n */\r\nfunction drawLink(\r\n  svgDrawingHelper: SVGDrawingHelper,\r\n  annotationUID: string,\r\n  linkUID: string,\r\n  // Find closest point to approx. bounding box\r\n  annotationAnchorPoints: Array<Types.Point2>,\r\n  refPoint: Types.Point2,\r\n  // Find bounding box point that's closest to our identified\r\n  // start point\r\n  boundingBox: PlanarBoundingBox,\r\n  options = {}\r\n): void {\r\n  // The closest anchor point (for the annotation) to the\r\n  // text box / bounding box\r\n  const start =\r\n    annotationAnchorPoints.length > 0\r\n      ? findClosestPoint(annotationAnchorPoints, refPoint)\r\n      : refPoint;\r\n\r\n  // Calculate the midpoints of the bounding box\r\n  const boundingBoxPoints = _boundingBoxPoints(boundingBox);\r\n  // Find the closest textBox midpoint to the annotation's anchor/start point\r\n  const end = findClosestPoint(boundingBoxPoints, start);\r\n\r\n  // Finally we draw the dashed linking line\r\n  const mergedOptions = Object.assign(\r\n    {\r\n      color: 'rgb(255, 255, 0)',\r\n      lineWidth: '1',\r\n      lineDash: '2,3',\r\n    },\r\n    options\r\n  );\r\n\r\n  drawLine(\r\n    svgDrawingHelper,\r\n    annotationUID,\r\n    `link-${linkUID}`,\r\n    start,\r\n    end,\r\n    mergedOptions\r\n  );\r\n}\r\n\r\n/**\r\n * Find potential anchor points for a given bounding box. For example, it may\r\n * look nicer to draw a line from the \"middle left\" of a bounding box to an\r\n * annotation (instead of from a corner). This function calculates those points\r\n *\r\n * @param boundingBox\r\n */\r\nfunction _boundingBoxPoints(\r\n  boundingBox: PlanarBoundingBox\r\n): Array<Types.Point2> {\r\n  const { x: left, y: top, height, width } = boundingBox;\r\n  const halfWidth = width / 2;\r\n  const halfHeight = height / 2;\r\n\r\n  const topMiddle = [left + halfWidth, top] as Types.Point2;\r\n  const leftMiddle = [left, top + halfHeight] as Types.Point2;\r\n  const bottomMiddle = [left + halfWidth, top + height] as Types.Point2;\r\n  const rightMiddle = [left + width, top + halfHeight] as Types.Point2;\r\n\r\n  return [topMiddle, leftMiddle, bottomMiddle, rightMiddle];\r\n}\r\n\r\nexport default drawLink;\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\nimport drawTextBox from './drawTextBox';\r\nimport drawLink from './drawLink';\r\nimport { SVGDrawingHelper } from '../types';\r\n\r\nfunction drawLinkedTextBox(\r\n  svgDrawingHelper: SVGDrawingHelper,\r\n  annotationUID: string,\r\n  textBoxUID: string,\r\n  //\r\n  textLines: Array<string>,\r\n  textBoxPosition: Types.Point2,\r\n  annotationAnchorPoints: Array<Types.Point2>,\r\n  textBox: unknown,\r\n  options = {}\r\n  // TODO: yCenter as an option\r\n): SVGRect {\r\n  const mergedOptions = Object.assign(\r\n    {\r\n      handleRadius: '6',\r\n      centering: {\r\n        x: false,\r\n        y: true, // yCenter,\r\n      },\r\n    },\r\n    options\r\n  );\r\n\r\n  // Draw the text box\r\n  const canvasBoundingBox = drawTextBox(\r\n    svgDrawingHelper,\r\n    annotationUID,\r\n    textBoxUID,\r\n    textLines,\r\n    textBoxPosition,\r\n    mergedOptions\r\n  );\r\n  // if (textBox.hasMoved) {\r\n  //   // Draw dashed link line between tool and text\r\n  drawLink(\r\n    svgDrawingHelper,\r\n    annotationUID,\r\n    textBoxUID,\r\n    annotationAnchorPoints, // annotationAnchorPoints\r\n    textBoxPosition, // refPoint (text)\r\n    canvasBoundingBox, // textBoxBoundingBox\r\n    mergedOptions\r\n  );\r\n  // }\r\n\r\n  // const { top, left, width, height } = canvasBoundingBox\r\n\r\n  // textBox.worldBoundingBox = {\r\n  //   topLeft: canvasToWorld([left, top]),\r\n  //   topRight: canvasToWorld([left + width, top]),\r\n  //   bottomLeft: canvasToWorld([left, top + height]),\r\n  //   bottomRight: canvasToWorld([left + width, top + height]),\r\n  // }\r\n\r\n  return canvasBoundingBox;\r\n}\r\n\r\nexport default drawLinkedTextBox;\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\nimport _getHash from './_getHash';\r\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\r\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\r\nimport { SVGDrawingHelper } from '../types';\r\n\r\nexport default function drawRectByCoordinates(\r\n  svgDrawingHelper: SVGDrawingHelper,\r\n  annotationUID: string,\r\n  rectangleUID: string,\r\n  canvasCoordinates: Types.Point2[],\r\n  options = {},\r\n  dataId = ''\r\n): void {\r\n  const {\r\n    color,\r\n    width: _width,\r\n    lineWidth,\r\n    lineDash,\r\n  } = Object.assign(\r\n    {\r\n      color: 'rgb(0, 255, 0)',\r\n      width: '2',\r\n      lineWidth: undefined,\r\n      lineDash: undefined,\r\n    },\r\n    options\r\n  );\r\n\r\n  // for supporting both lineWidth and width options\r\n\r\n  const strokeWidth = lineWidth || _width;\r\n\r\n  const svgns = 'http://www.w3.org/2000/svg';\r\n  const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\r\n  const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\r\n\r\n  const [topLeft, topRight, bottomLeft, bottomRight] = canvasCoordinates;\r\n\r\n  const width = Math.hypot(topLeft[0] - topRight[0], topLeft[1] - topRight[1]);\r\n  const height = Math.hypot(\r\n    topLeft[0] - bottomLeft[0],\r\n    topLeft[1] - bottomLeft[1]\r\n  );\r\n\r\n  const center = [\r\n    (bottomRight[0] + topLeft[0]) / 2,\r\n    (bottomRight[1] + topLeft[1]) / 2,\r\n  ];\r\n  const leftEdgeCenter = [\r\n    (bottomLeft[0] + topLeft[0]) / 2,\r\n    (bottomLeft[1] + topLeft[1]) / 2,\r\n  ];\r\n  const angle =\r\n    (Math.atan2(center[1] - leftEdgeCenter[1], center[0] - leftEdgeCenter[0]) *\r\n      180) /\r\n    Math.PI;\r\n\r\n  const attributes = {\r\n    x: `${center[0] - width / 2}`,\r\n    y: `${center[1] - height / 2}`,\r\n    width: `${width}`,\r\n    height: `${height}`,\r\n    stroke: color,\r\n    fill: 'transparent',\r\n    transform: `rotate(${angle} ${center[0]} ${center[1]})`,\r\n    'stroke-width': strokeWidth,\r\n    'stroke-dasharray': lineDash,\r\n  };\r\n\r\n  if (existingRect) {\r\n    setAttributesIfNecessary(attributes, existingRect);\r\n\r\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\r\n  } else {\r\n    const svgRectElement = document.createElementNS(svgns, 'rect');\r\n\r\n    if (dataId !== '') {\r\n      svgRectElement.setAttribute('data-id', dataId);\r\n    }\r\n\r\n    setNewAttributesIfValid(attributes, svgRectElement);\r\n\r\n    svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\r\n  }\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\nimport _getHash from './_getHash';\r\nimport { SVGDrawingHelper } from '../types';\r\nimport drawRectByCoordinates from './drawRectByCoordinates';\r\n\r\n// This method is obsolete due to not supporting rotation tool. Please use drawRectByCoordinates instead.\r\n// <rect x=\"120\" y=\"100\" width=\"100\" height=\"100\" />\r\nexport default function drawRect(\r\n  svgDrawingHelper: SVGDrawingHelper,\r\n  annotationUID: string,\r\n  rectangleUID: string,\r\n  start: Types.Point2,\r\n  end: Types.Point2,\r\n  options = {},\r\n  dataId = ''\r\n): void {\r\n    // console.log('DRAW RECT SVG', options, annotationUID, rectangleUID, dataId)\r\n\r\n  const topLeft: Types.Point2 = [start[0], start[1]];\r\n  const topRight: Types.Point2 = [end[0], start[1]];\r\n  const bottomLeft: Types.Point2 = [start[0], end[1]];\r\n  const bottomRight: Types.Point2 = [end[0], end[1]];\r\n\r\n  drawRectByCoordinates(\r\n    svgDrawingHelper,\r\n    annotationUID,\r\n    rectangleUID,\r\n    [topLeft, topRight, bottomLeft, bottomRight],\r\n    options,\r\n    dataId\r\n  );\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport { SVGDrawingHelper } from '../types';\r\nimport drawLine from './drawLine';\r\n\r\nexport default function drawArrow(\r\n  svgDrawingHelper: SVGDrawingHelper,\r\n  annotationUID: string,\r\n  arrowUID: string,\r\n  start: Types.Point2,\r\n  end: Types.Point2,\r\n  options = {}\r\n): void {\r\n  // if length is NaN return\r\n  if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\r\n    return;\r\n  }\r\n\r\n  const { color, width, lineWidth, lineDash } = Object.assign(\r\n    {\r\n      color: 'rgb(0, 255, 0)',\r\n      width: '2',\r\n      lineWidth: undefined,\r\n      lineDash: undefined,\r\n    },\r\n    options\r\n  );\r\n\r\n  // The line itself\r\n  drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, {\r\n    color,\r\n    width,\r\n    lineWidth,\r\n    lineDash,\r\n  });\r\n\r\n  // Drawing the head arrow with two lines\r\n  // Variables to be used when creating the arrow\r\n  const headLength = 10;\r\n  const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);\r\n\r\n  const firstLine = {\r\n    start: [\r\n      end[0] - headLength * Math.cos(angle - Math.PI / 7),\r\n      end[1] - headLength * Math.sin(angle - Math.PI / 7),\r\n    ] as Types.Point2,\r\n    end: end,\r\n  };\r\n\r\n  const secondLine = {\r\n    start: [\r\n      end[0] - headLength * Math.cos(angle + Math.PI / 7),\r\n      end[1] - headLength * Math.sin(angle + Math.PI / 7),\r\n    ] as Types.Point2,\r\n    end: end,\r\n  };\r\n\r\n  drawLine(\r\n    svgDrawingHelper,\r\n    annotationUID,\r\n    `${parseInt(arrowUID) + 1}`,\r\n    firstLine.start,\r\n    firstLine.end,\r\n    {\r\n      color,\r\n      width,\r\n      lineWidth,\r\n    }\r\n  );\r\n\r\n  drawLine(\r\n    svgDrawingHelper,\r\n    annotationUID,\r\n      `${parseInt(arrowUID) + 2}`,\r\n    secondLine.start,\r\n    secondLine.end,\r\n    {\r\n      color,\r\n      width,\r\n      lineWidth,\r\n    }\r\n  );\r\n}\r\n","import _getHash from './_getHash';\r\nimport _setAttributesIfNecessary from './setAttributesIfNecessary';\r\nimport _setNewAttributesIfValid from './setNewAttributesIfValid';\r\n\r\n// <rect x=\"120\" y=\"100\" width=\"100\" height=\"100\" />\r\nexport default function drawRedactionRect(\r\n  svgDrawingHelper: any,\r\n  annotationUID: string,\r\n  rectangleUID: string,\r\n  start: any,\r\n  end: any,\r\n  options = {}\r\n): void {\r\n  const {\r\n    color,\r\n    width: _width,\r\n    lineWidth,\r\n    lineDash,\r\n  } = Object.assign(\r\n    {\r\n      color: 'rgb(0, 255, 0)',\r\n      width: '2',\r\n      lineWidth: undefined,\r\n      lineDash: undefined,\r\n    },\r\n    options\r\n  );\r\n\r\n  // for supporting both lineWidth and width options\r\n  const strokeWidth = lineWidth || _width;\r\n\r\n  const svgns = 'http://www.w3.org/2000/svg';\r\n  const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\r\n  const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\r\n\r\n  const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];\r\n  const width = Math.abs(start[0] - end[0]);\r\n  const height = Math.abs(start[1] - end[1]);\r\n\r\n  const attributes = {\r\n    x: `${tlhc[0]}`,\r\n    y: `${tlhc[1]}`,\r\n    width: `${width}`,\r\n    height: `${height}`,\r\n    stroke: color,\r\n    fill: 'black',\r\n    'stroke-width': strokeWidth,\r\n    'stroke-dasharray': lineDash,\r\n  };\r\n\r\n  if (existingRect) {\r\n    _setAttributesIfNecessary(attributes, existingRect);\r\n\r\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\r\n  } else {\r\n    const svgRectElement = document.createElementNS(svgns, 'rect');\r\n\r\n    _setNewAttributesIfValid(attributes, svgRectElement);\r\n\r\n    svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\r\n  }\r\n}\r\n","/**\r\n * ChangeTypes defines the types of changes occurring on annotation and\r\n * segmentation data.\r\n */\r\nenum ChangeTypes {\r\n  /**\r\n   * Interaction events are done when the user is actively interacting with\r\n   * an annotation, and probably means the event shouldn't be handled/used.\r\n   */\r\n  Interaction = 'Interaction',\r\n  /**\r\n   * HandlesUpdated occurs when the handle data is added or removed, or moved around\r\n   */\r\n  HandlesUpdated = 'HandlesUpdated',\r\n  /**\r\n   * StatsUpdated occurs when the stats are updated/calculated.  This can be used\r\n   * to ignore stats calculations changes occurring on initial load, while still\r\n   * rendering other updates.\r\n   */\r\n  StatsUpdated = 'StatsUpdated',\r\n  /**\r\n   * InitialSetup occurs when an annotation has been created initially and\r\n   * has the first render/data calculation being applied.\r\n   */\r\n  InitialSetup = 'InitialSetup',\r\n  /**\r\n   * Completed occurs only for the annotation completed event, just to identify it\r\n   */\r\n  Completed = 'Completed',\r\n  /**\r\n   * Occurs when an interpolation result is updated with more tool specific data.\r\n   */\r\n  InterpolationUpdated = 'InterpolationUpdated',\r\n}\r\n\r\nexport default ChangeTypes;\r\n","/**\r\n *  The events for cornerstoneTools3D Tools. Native Mouse and Keyboard events are\r\n *  captured, normalized, and re-triggered with a `CORNERSTONE_TOOLS` prefix. This\r\n *  allows us to handle events consistently across different browsers.\r\n *\r\n */\r\nenum Events {\r\n  ///////////////////////////////////////\r\n  //            Tools\r\n  ///////////////////////////////////////\r\n\r\n  /**\r\n   * Triggers on the eventTarget when a new tools is activated.\r\n   *\r\n   * Make use of {@link EventTypes.ToolActivatedEventType | Tool Activated Event Type  }\r\n   * for typing your event listeners for this tool activated event, and see what event\r\n   * detail is included in {@link EventTypes.ToolActivatedEventDetail | Tool Activated Event Detail}.\r\n   */\r\n  TOOL_ACTIVATED = 'CORNERSTONE_TOOLS_TOOL_ACTIVATED',\r\n\r\n  // fired when a viewport is added to the toolGroup\r\n  TOOLGROUP_VIEWPORT_ADDED = 'CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_ADDED',\r\n\r\n  // fired when a viewport is removed from the toolGroup\r\n  TOOLGROUP_VIEWPORT_REMOVED = 'CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_REMOVED',\r\n\r\n  /**\r\n   * Triggers on the eventTarget when a mode of a tool is changed (active, passive, enabled and disabled).\r\n   *\r\n   * Make use of {@link EventTypes.ToolModeChangedEventType | Tool Mode Changed Event Type  }\r\n   * for typing your event listeners for this tool activated event, and see what event\r\n   * detail is included in {@link EventTypes.ToolModeChangedEventDetail | Tool Mode Changed Event Detail}.\r\n   */\r\n  TOOL_MODE_CHANGED = 'CORNERSTONE_TOOLS_TOOL_MODE_CHANGED',\r\n\r\n  ///////////////////////////////////////\r\n  //            Annotations\r\n  ///////////////////////////////////////\r\n\r\n  /**\r\n   * Triggers on the eventTarget when a new annotation is added to the state.\r\n   *\r\n   * Make use of {@link EventTypes.AnnotationAddedEventType | Annotation Added Event Type  }\r\n   * for typing your event listeners for this annotation added event, and see what event\r\n   * detail is included in {@link EventTypes.AnnotationAddedEventDetail | Annotation Added Event Detail}.\r\n   */\r\n  ANNOTATION_ADDED = 'CORNERSTONE_TOOLS_ANNOTATION_ADDED',\r\n\r\n  /**\r\n   * Triggers on the eventTarget when a new annotation is completed its drawing\r\n   * Make use of {@link EventTypes.AnnotationCompletedEventType | Annotation Completed Event Type }\r\n   * for typing your event listeners for this annotation completed event, and see what event\r\n   * detail is included in {@link EventTypes.AnnotationCompletedEventDetail | Annotation Completed Event Detail}.\r\n   */\r\n  ANNOTATION_COMPLETED = 'CORNERSTONE_TOOLS_ANNOTATION_COMPLETED',\r\n\r\n  /**\r\n   * Triggers on the eventTarget when an annotation is modified (e.g. a handle is modified).\r\n   * Make use of {@link EventTypes.AnnotationModifiedEventType | Annotation Modified Event Type}\r\n   * for typing your event listeners for this annotation modified event, and see what\r\n   * event detail is included in {@link EventTypes.AnnotationModifiedEventDetail | Annotation Modified Event Detail}.\r\n   */\r\n  ANNOTATION_MODIFIED = 'CORNERSTONE_TOOLS_ANNOTATION_MODIFIED',\r\n\r\n  /**\r\n   * Triggers on the eventTarget when an annotation is removed from the annotations manager.\r\n   * Make use of {@link EventTypes.AnnotationRemovedEventType | Annotation Removed Event Type}\r\n   * for typing your event listeners for this annotation removed event, and see what\r\n   * event detail is included in {@link EventTypes.AnnotationRemovedEventDetail | Annotation Removed Event Detail}.\r\n   */\r\n  ANNOTATION_REMOVED = 'CORNERSTONE_TOOLS_ANNOTATION_REMOVED',\r\n\r\n  /**\r\n   * Triggers on the eventTarget when an annotation selection status is changed.\r\n   * Make use of {@link EventTypes.AnnotationSelectionChangeEventType | Annotation Selection Change Event Type}\r\n   * for typing your event listeners for this annotation selection change event, and see what\r\n   * event detail is included in {@link EventTypes.AnnotationSelectionChangeEventDetail | Annotation Selection Change Event Detail}.\r\n   */\r\n  ANNOTATION_SELECTION_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE',\r\n\r\n  /**\r\n   * Triggers on the eventTarget when an annotation locked status is changed.\r\n   * Make use of {@link EventTypes.AnnotationLockChangeEventType | Annotation Lock Change Event Type}\r\n   * for typing your event listeners for this annotation lock change event, and see what\r\n   * event detail is included in {@link EventTypes.AnnotationLockChangeEventDetail | Annotation Lock Change Event Detail}.\r\n   */\r\n  ANNOTATION_LOCK_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE',\r\n\r\n  /**\r\n   * Triggers on the eventTarget when an annotation visible status is changed.\r\n   * Make use of {@link EventTypes.AnnotationVisibilityChangeEventType | Annotation Visible Change Event Type}\r\n   * for typing your event listeners for this annotation Hide change event, and see what\r\n   * event detail is included in {@link EventTypes.AnnotationVisibilityChangeEventDetail | Annotation Visible Change Event Detail}.\r\n   */\r\n  ANNOTATION_VISIBILITY_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE',\r\n\r\n  /**\r\n   * Triggers on the eventTarget when an annotation is rendered.\r\n   * Make use of {@link EventTypes.AnnotationRenderedEventType | Annotation Rendered Event Type}\r\n   * for typing your event listeners for this annotation rendered event, and see what\r\n   * event detail is included in {@link EventTypes.AnnotationRenderedEventDetail | Annotation Rendered Event Detail}.\r\n   */\r\n  ANNOTATION_RENDERED = 'CORNERSTONE_TOOLS_ANNOTATION_RENDERED',\r\n\r\n  /**\r\n   * Triggers on the eventTarget when an annotation interpolation process completed.\r\n   * Make use of {@link EventTypes.AnnotationInterpolationCompletedEventType | Annotation Interpolation process Completed Event Type}\r\n   * for typing your event listeners for this annotation interpolation complete event, and see what\r\n   * event detail is included in {@link EventTypes.AnnotationInterpolationCompletedEventDetail | Annotation interpolation process Event Detail}.\r\n   */\r\n  ANNOTATION_INTERPOLATION_PROCESS_COMPLETED = 'CORNERSTONE_TOOLS_ANNOTATION_INTERPOLATION_PROCESS_COMPLETED',\r\n\r\n  /**\r\n   * Triggers on the eventTarget when interpolated annotations are removed.\r\n   * Make use of {@link EventTypes.AnnotationInterpolationRemovedEventType | Annotation Interpolation Removed Event Type}\r\n   * for typing your event listeners for this interpolated annotation removed event, and see what\r\n   * event detail is included in {@link EventTypes.AnnotationInterpolationRemovedEventDetail | Annotation interpolation removed Event Detail}.\r\n   */\r\n  INTERPOLATED_ANNOTATIONS_REMOVED = 'CORNERSTONE_TOOLS_INTERPOLATED_ANNOTATIONS_REMOVED',\r\n\r\n  ///////////////////////////////////////\r\n  //        Segmentations Events\r\n  ///////////////////////////////////////\r\n\r\n  /**\r\n   * Triggers on the eventTarget when a Segmentation is updated in the state manager.\r\n   * Make use of {@link EventTypes.SegmentationModifiedEventType | Segmentation Modified Event Type}\r\n   * for typing your event listeners for this segmentation modified event, and see what\r\n   * event detail is included in {@link EventTypes.SegmentationModifiedEventDetail | Segmentation Modified Event Detail}.\r\n   */\r\n  SEGMENTATION_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED',\r\n\r\n  /**\r\n   * Triggers on the eventTarget when a Segmentation is rendered by the Segmentation Rendering Engine.\r\n   * Make use of {@link EventTypes.SegmentationRenderedEventType | Segmentation Rendered Event Type}\r\n   * for typing your event listeners for this segmentation rendered event, and see what\r\n   * event detail is included in {@link EventTypes.SegmentationRenderedEventDetail | Segmentation Rendered Event Detail}.\r\n   */\r\n  SEGMENTATION_RENDERED = 'CORNERSTONE_TOOLS_SEGMENTATION_RENDERED',\r\n\r\n  /**\r\n   * Triggers on the eventTarget when a Segmentation representation of a toolGroup is modified in the state manager.\r\n   * Make use of {@link EventTypes.SegmentationRepresentationModifiedEventType | Segmentation Representation Modified Event Type}\r\n   * for typing your event listeners for this segmentation representation modified event, and see what\r\n   * event detail is included in {@link EventTypes.SegmentationRepresentationModifiedEventDetail | Segmentation Representation Modified Event Detail}.\r\n   */\r\n  SEGMENTATION_REPRESENTATION_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED',\r\n\r\n  /**\r\n   * Triggers on the eventTarget when a Segmentation is removed from the state manager.\r\n   * Make use of {@link EventTypes.SegmentationRemovedEventType | Segmentation Removed Event Type}\r\n   * for typing your event listeners for this segmentation removed event, and see what\r\n   * event detail is included in {@link EventTypes.SegmentationRemovedEventDetail | Segmentation Removed Event Detail}.\r\n   */\r\n  SEGMENTATION_REMOVED = 'CORNERSTONE_TOOLS_SEGMENTATION_REMOVED',\r\n\r\n  /**\r\n   * Triggers on the eventTarget when a Segmentation representation of a toolGroup is removed in the state manager.\r\n   * Make use of {@link EventTypes.SegmentationRepresentationRemovedEventType | Segmentation Representation Removed Event Type}\r\n   * for typing your event listeners for this segmentation representation removed event, and see what\r\n   * event detail is included in {@link EventTypes.SegmentationRepresentationRemovedEventDetail | Segmentation Representation Removed Event Detail}.\r\n   */\r\n  SEGMENTATION_REPRESENTATION_REMOVED = 'CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED',\r\n\r\n  /**\r\n   * Triggers on the eventTarget when a Segmentation data is modified (e.g., by brush tool).\r\n   * Make use of {@link EventTypes.SegmentationDataModifiedEventType | Segmentation Data Modified Event Type}\r\n   * for typing your event listeners for this segmentation data modified event, and see what\r\n   * event detail is included in {@link EventTypes.SegmentationDataModifiedEventDetail | Segmentation Data Modified Event Detail}.\r\n   */\r\n  SEGMENTATION_DATA_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED',\r\n\r\n  ///////////////////////////////////////\r\n  //         Keyboard Events\r\n  ///////////////////////////////////////\r\n\r\n  /**\r\n   * Triggers on the eventTarget when a key on the keyboard is pressed.\r\n   * Make use of {@link EventTypes.KeyDownEventType | Key Down Event Type}\r\n   * for typing your event listeners for this key down event, and see what\r\n   * event detail is included in {@link EventTypes.KeyDownEventDetail | Key Down Event Detail}.\r\n   */\r\n  KEY_DOWN = 'CORNERSTONE_TOOLS_KEY_DOWN',\r\n\r\n  /**\r\n   * Triggers on the eventTarget when a key on the keyboard is released.\r\n   * Make use of {@link EventTypes.KeyUpEventType | Key Up Event Type}\r\n   * for typing your event listeners for this key up event, and see what\r\n   * event detail is included in {@link EventTypes.KeyUpEventDetail | Key Up Event Detail}.\r\n   */\r\n  KEY_UP = 'CORNERSTONE_TOOLS_KEY_UP',\r\n\r\n  ///////////////////////////////////////\r\n  //      Mouse Events\r\n  ///////////////////////////////////////\r\n\r\n  /**\r\n   * Triggers on the eventTarget when the mouse is pressed down, it is CornerstoneTools normalized event.\r\n   * Make use of {@link EventTypes.MouseDownEventType | Mouse Down Event Type}\r\n   * for typing your event listeners for this mouse down event, and see what\r\n   * event detail is included in {@link EventTypes.MouseDownEventDetail | Mouse Down Event Detail}.\r\n   */\r\n  MOUSE_DOWN = 'CORNERSTONE_TOOLS_MOUSE_DOWN',\r\n\r\n  /**\r\n   * Triggers on the eventTarget when the mouse is released, it is CornerstoneTools normalized event.\r\n   * Make use of {@link EventTypes.MouseUpEventType | Mouse Up Event Type}\r\n   * for typing your event listeners for this mouse up event, and see what\r\n   * event detail is included in {@link EventTypes.MouseUpEventDetail | Mouse Up Event Detail}.\r\n   */\r\n  MOUSE_UP = 'CORNERSTONE_TOOLS_MOUSE_UP',\r\n\r\n  /**\r\n   * Triggers on the eventTarget when a handled `MOUSE_DOWN` event does not `stopPropagation`. The hook\r\n   * we use to create new annotation for mouse events.\r\n   * Make use of {@link EventTypes.MouseDownActivateEventType | Mouse Down Activate Event Type}\r\n   * for typing your event listeners for this mouse down activate event, and see what\r\n   * event detail is included in {@link EventTypes.MouseDownActivateEventDetail | Mouse Down Activate Event Detail}.\r\n   */\r\n  MOUSE_DOWN_ACTIVATE = 'CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE',\r\n\r\n  /**\r\n   * Triggers on the event target when mouse is dragging an annotation or textBox.\r\n   * Make use of {@link EventTypes.MouseDragEventType | Mouse Drag Event Type}\r\n   * for typing your event listeners for this mouse drag event, and see what\r\n   * event detail is included in {@link EventTypes.MouseDragEventDetail | Mouse Drag Event Detail}.\r\n   */\r\n  MOUSE_DRAG = 'CORNERSTONE_TOOLS_MOUSE_DRAG',\r\n\r\n  /**\r\n   * Triggers on the eventTarget, when the mouse is moved, it is CornerstoneTools normalized event.\r\n   * It can be just a mouse move or when double click is performed and annotation\r\n   * drawing can be performed with just mouse move.\r\n   * Make use of {@link EventTypes.MouseMoveEventType | Mouse Move Event Type}\r\n   * for typing your event listeners for this mouse move event, and see what\r\n   * event detail is included in {@link EventTypes.MouseMoveEventDetail | Mouse Move Event Detail}.\r\n   */\r\n  MOUSE_MOVE = 'CORNERSTONE_TOOLS_MOUSE_MOVE',\r\n\r\n  /**\r\n   * Triggers on the eventTarget when a mouse click is detected. It is CornerstoneTools normalized event.\r\n   * Make use of {@link EventTypes.MouseClickEventType | Mouse Click Event Type}\r\n   * for typing your event listeners for this mouse click event, and see what\r\n   * event detail is included in {@link EventTypes.MouseClickEventDetail | Mouse Click Event Detail}.\r\n   */\r\n  MOUSE_CLICK = 'CORNERSTONE_TOOLS_MOUSE_CLICK',\r\n\r\n  /**\r\n   * Triggers on the eventTarget when a mouse double click is detected. It is CornerstoneTools normalized event.\r\n   * Make use of {@link EventTypes.MouseDoubleClickEventType | Mouse Double Click Event Type}\r\n   * for typing your event listeners for this mouse double click event, and see what\r\n   * event detail is included in {@link EventTypes.MouseDoubleClickEventDetail | Mouse Double Click Event Detail}.\r\n   */\r\n  MOUSE_DOUBLE_CLICK = 'CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK',\r\n\r\n  /**\r\n   * Triggers on the eventTarget when a mouse wheel event is detected. It is CornerstoneTools normalized event.\r\n   * Make use of {@link EventTypes.MouseWheelEventType | Mouse Wheel Event Type}\r\n   * for typing your event listeners for this mouse wheel event, and see what\r\n   * event detail is included in {@link EventTypes.MouseWheelEventDetail | Mouse Wheel Event Detail}.\r\n   */\r\n  MOUSE_WHEEL = 'CORNERSTONE_TOOLS_MOUSE_WHEEL',\r\n\r\n  // Todo: not being fired as of now\r\n  // ANNOTATION_COMPLETED = 'CORNERSTONE_TOOLS_ANNOTATION_COMPLETED',\r\n  // Todo: not implemented yet\r\n  // KEY_PRESS = 'CORNERSTONE_TOOLS_KEY_PRESS',\r\n\r\n  //////////////////////\r\n  //   Touch Events   //\r\n  //////////////////////\r\n  // The event flow looks like the following\r\n  // Touch Start -> (optional) Touch Press -> Touch Drag -> (optional) Touch Swipe -> Touch End\r\n  // Touch Tap\r\n  // mousedown\r\n  // mousedown, Touch Start, and Tap are mutually exclusive events\r\n  TOUCH_START = 'CORNERSTONE_TOOLS_TOUCH_START',\r\n  TOUCH_START_ACTIVATE = 'CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE',\r\n  TOUCH_PRESS = 'CORNERSTONE_TOOLS_TOUCH_PRESS',\r\n  TOUCH_DRAG = 'CORNERSTONE_TOOLS_TOUCH_DRAG',\r\n  TOUCH_END = 'CORNERSTONE_TOOLS_TOUCH_END',\r\n  TOUCH_TAP = 'CORNERSTONE_TOOLS_TAP',\r\n  TOUCH_SWIPE = 'CORNERSTONE_TOOLS_SWIPE',\r\n}\r\n\r\nexport default Events;\r\n","/**\r\n * Segmentations on viewports can be visualized in different ways. This enum\r\n * defines the different ways of visualizing segmentations. Currently, only\r\n * labelmap is supported.\r\n */\r\nenum SegmentationRepresentations {\r\n  Labelmap = 'LABELMAP',\r\n  Contour = 'CONTOUR',\r\n  Surface = 'SURFACE',\r\n}\r\n\r\nexport default SegmentationRepresentations;\r\n","/**\r\n * Defines the names of the strategy callbacks used for performing enhanced\r\n * strategy operations.\r\n */\r\nenum StrategyCallbacks {\r\n  /**\r\n   * startStrategy is called at the start of a strategy, typically on mouse down\r\n   * Note this is separate from preview and the endings for preview, which could\r\n   * be called alternatively, but this may be nested within a preview.\r\n   */\r\n  OnInteractionStart = 'onInteractionStart',\r\n  /**\r\n   * finishStrategy is called at the end of a strategy being applied, usually on\r\n   * mouse up.\r\n   */\r\n  OnInteractionEnd = 'onInteractionEnd',\r\n  /**\r\n   * The preview can be used for tools to show what would happen on accepting\r\n   * before the change is actually done.  For example, a spline tool might\r\n   * show a preview state, and allow that to be accepted or rejected.\r\n   */\r\n  Preview = 'preview',\r\n  RejectPreview = 'rejectPreview',\r\n  AcceptPreview = 'acceptPreview',\r\n\r\n  /**\r\n   * Fills the given reygion\r\n   */\r\n  Fill = 'fill',\r\n\r\n  /**\r\n   * The default strategy function, often synonymous with fill\r\n   */\r\n  StrategyFunction = 'strategyFunction',\r\n\r\n  /**\r\n   * For threshold functions, this creates the thresold test.  Mostly an internal\r\n   * detail, but might be useful to share between strategies.\r\n   */\r\n  CreateIsInThreshold = 'createIsInThreshold',\r\n\r\n  /**\r\n   * For replace functions, this creates the target segment test.  Mostly an internal\r\n   * detail, but might be useful to share between strategies.\r\n   */\r\n  CreateIsTargetSegment = 'createIsTargetSegment',\r\n\r\n  /**\r\n   *  Some strategy functions need to initialize some data before being runnable.\r\n   * This is mostly an internal detail, just useful to have an enum here for this.\r\n   */\r\n  Initialize = 'initialize',\r\n\r\n  // Internal Details\r\n  INTERNAL_setValue = 'setValue',\r\n\r\n  /** inner circle size  */\r\n  ComputeInnerCircleRadius = 'computeInnerCircleRadius',\r\n}\r\n\r\nexport default StrategyCallbacks;\r\n","enum Swipe {\r\n  UP = 'UP',\r\n  DOWN = 'DOWN',\r\n  LEFT = 'LEFT',\r\n  RIGHT = 'RIGHT',\r\n}\r\n\r\nexport { Swipe };\r\n","/**\r\n * Mouse This enum enumerates the different buttons returned by `.buttons` on the mouse event.\r\n * These values are used when setting a tool active in a tool group.\r\n *\r\n * See also: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\r\n */\r\nenum MouseBindings {\r\n  /** usually the left button */\r\n  Primary = 1,\r\n  /** usually the right button */\r\n  Secondary = 2,\r\n  Primary_And_Secondary = 3,\r\n  /** usually mouse wheel button */\r\n  Auxiliary = 4,\r\n  Primary_And_Auxiliary = 5,\r\n  Secondary_And_Auxiliary = 6,\r\n  Primary_And_Secondary_And_Auxiliary = 7,\r\n  /** usually \"Browser Back\" button */\r\n  Fourth_Button = 8,\r\n  /** usually \"Browser Forward\" button */\r\n  Fifth_Button = 16,\r\n}\r\n\r\nenum KeyboardBindings {\r\n  Shift = 16,\r\n  Ctrl = 17,\r\n  Alt = 18,\r\n  Meta = 91,\r\n  ShiftCtrl = 1617,\r\n  ShiftAlt = 1618,\r\n  ShiftMeta = 1691,\r\n  CtrlAlt = 1718,\r\n  CtrlMeta = 1791,\r\n  AltMeta = 1891,\r\n}\r\n\r\nexport { MouseBindings, KeyboardBindings };\r\n","/**\r\n * AnnotationStyleStates - This enum defines the 4 possible states available for\r\n *  a Annotation instance.\r\n *\r\n * Default:\r\n *   The default state for the annotation instance\r\n * Highlighted:\r\n *   The annotation should be rendered in \"highlighted\" mode in response to\r\n *   direct user interaction;\r\n * Selected:\r\n *   The annotation has been selected by the user;\r\n * Locked:\r\n *   The annotation has been locked;\r\n * AutoGenerated:\r\n *   The annotation has been auto generated;\r\n */\r\nenum AnnotationStyleStates {\r\n  Default = '',\r\n  Highlighted = 'Highlighted',\r\n  Selected = 'Selected',\r\n  Locked = 'Locked',\r\n  AutoGenerated = 'AutoGenerated',\r\n}\r\n\r\nexport default AnnotationStyleStates;\r\n","/**\r\n * Worker Types are used to define the types the worker that is getting performed\r\n */\r\nenum ChangeTypes {\r\n  POLYSEG_CONTOUR_TO_LABELMAP = 'polySeg/convertContourToVolumeLabelmap',\r\n\r\n  POLYSEG_SURFACE_TO_LABELMAP = 'polySeg/convertSurfacesToVolumeLabelmap',\r\n\r\n  POLYSEG_CONTOUR_TO_SURFACE = 'polySeg/convertContourToSurface',\r\n\r\n  POLYSEG_LABELMAP_TO_SURFACE = 'polySeg/convertLabelmapToSurface',\r\n\r\n  SURFACE_CLIPPING = 'surfaceClipping',\r\n}\r\n\r\nexport default ChangeTypes;\r\n","import { Enums, Types } from '@cornerstonejs/core';\r\nimport triggerAnnotationRender from '../utilities/triggerAnnotationRender';\r\n\r\n/**\r\n *  When the image is rendered, check what tools can be rendered for this element.\r\n *\r\n * - First we get all tools which are active, passive or enabled on the element.\r\n * - If any of these tools have a `renderAnnotation` method, then we render them.\r\n * - Note that these tools don't necessarily have to be instances of  `AnnotationTool`,\r\n *   Any tool may register a `renderAnnotation` method (e.g. a tool that displays an overlay).\r\n *\r\n * @param evt - The normalized IMAGE_RENDERED event.\r\n */\r\nconst onImageRendered = function (evt: Types.EventTypes.ImageRenderedEvent) {\r\n  // TODO: should we do this on camera modified instead of image rendered?\r\n  // e.g. no need to re-render annotations if only the VOI has changed\r\n  triggerAnnotationRender(evt.detail.element);\r\n};\r\n\r\nconst enable = function (element: HTMLDivElement): void {\r\n  element.addEventListener(\r\n    Enums.Events.IMAGE_RENDERED,\r\n    onImageRendered as EventListener\r\n  );\r\n};\r\n\r\nconst disable = function (element: HTMLDivElement): void {\r\n  element.removeEventListener(\r\n    Enums.Events.IMAGE_RENDERED,\r\n    onImageRendered as EventListener\r\n  );\r\n};\r\n\r\nexport default {\r\n  enable,\r\n  disable,\r\n};\r\n","import Events from '../enums/Events';\r\n\r\nimport {\r\n  mouseClick,\r\n  mouseDown,\r\n  mouseDownActivate,\r\n  mouseDoubleClick,\r\n  mouseDrag,\r\n  mouseMove,\r\n  mouseUp,\r\n  mouseWheel,\r\n} from './mouseEventHandlers';\r\n\r\n/**\r\n * Enable these listeners are emitted in order, and can be cancelled/prevented from bubbling\r\n * by any previous event.\r\n *\r\n * @param element - The element to add the event listeners to.\r\n */\r\nconst enable = function (element: HTMLDivElement): void {\r\n  element.addEventListener(Events.MOUSE_CLICK, mouseClick as EventListener);\r\n  element.addEventListener(Events.MOUSE_DOWN, mouseDown as EventListener);\r\n  element.addEventListener(\r\n    Events.MOUSE_DOWN_ACTIVATE,\r\n    mouseDownActivate as EventListener\r\n  );\r\n  element.addEventListener(\r\n    Events.MOUSE_DOUBLE_CLICK,\r\n    mouseDoubleClick as EventListener\r\n  );\r\n  element.addEventListener(Events.MOUSE_DRAG, mouseDrag as EventListener);\r\n  element.addEventListener(Events.MOUSE_MOVE, mouseMove as EventListener);\r\n  element.addEventListener(Events.MOUSE_UP, mouseUp as EventListener);\r\n  element.addEventListener(Events.MOUSE_WHEEL, mouseWheel as EventListener);\r\n};\r\n\r\n/**\r\n * Disable and Remove the MouseToolEventDispatcher handlers from the element.\r\n *\r\n * @param element - HTMLDivElement\r\n */\r\nconst disable = function (element: HTMLDivElement) {\r\n  element.removeEventListener(Events.MOUSE_CLICK, mouseClick as EventListener);\r\n  element.removeEventListener(Events.MOUSE_DOWN, mouseDown as EventListener);\r\n  element.removeEventListener(\r\n    Events.MOUSE_DOWN_ACTIVATE,\r\n    mouseDownActivate as EventListener\r\n  );\r\n  element.removeEventListener(\r\n    Events.MOUSE_DOUBLE_CLICK,\r\n    mouseDoubleClick as EventListener\r\n  );\r\n  element.removeEventListener(Events.MOUSE_DRAG, mouseDrag as EventListener);\r\n  element.removeEventListener(Events.MOUSE_MOVE, mouseMove as EventListener);\r\n  element.removeEventListener(Events.MOUSE_UP, mouseUp as EventListener);\r\n  element.removeEventListener(Events.MOUSE_WHEEL, mouseWheel as EventListener);\r\n};\r\n\r\nconst mouseToolEventDispatcher = {\r\n  enable,\r\n  disable,\r\n};\r\n\r\nexport default mouseToolEventDispatcher;\r\n","import Events from '../enums/Events';\r\nimport { keyDown, keyUp } from './keyboardEventHandlers';\r\n\r\n/**\r\n * Enable Key down and key up listeners\r\n *\r\n * @param element - The HTML element to attach the event listeners to.\r\n */\r\nconst enable = function (element: HTMLDivElement) {\r\n  element.addEventListener(Events.KEY_DOWN, keyDown as EventListener);\r\n  element.addEventListener(Events.KEY_UP, keyUp as EventListener);\r\n};\r\n\r\n/**\r\n * Disable Key down and key up listeners\r\n * @param element - The HTML element to attach the event listeners to.\r\n */\r\nconst disable = function (element: HTMLDivElement) {\r\n  element.removeEventListener(Events.KEY_DOWN, keyDown as EventListener);\r\n  element.removeEventListener(Events.KEY_UP, keyUp as EventListener);\r\n};\r\n\r\nconst keyboardToolEventDispatcher = {\r\n  enable,\r\n  disable,\r\n};\r\n\r\nexport default keyboardToolEventDispatcher;\r\n","import { Enums, Types } from '@cornerstonejs/core';\r\nimport { ToolModes } from '../enums';\r\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\r\n\r\nconst { Active, Passive, Enabled } = ToolModes;\r\n\r\n/**\r\n * When the camera is modified, check what tools need to react to this.\r\n *\r\n * - First we get all tools which are active, passive or enabled on the element.\r\n * - If any of these tools have a `onCameraModified` method, we call it.\r\n *\r\n * @param evt - The normalized camera modified event.\r\n */\r\nconst onCameraModified = function (evt: Types.EventTypes.CameraModifiedEvent) {\r\n  // @ts-ignore\r\n  const enabledTools = getToolsWithModesForMouseEvent(evt, [\r\n    Active,\r\n    Passive,\r\n    Enabled,\r\n  ]);\r\n\r\n  enabledTools.forEach((tool) => {\r\n    if (tool.onCameraModified) {\r\n      tool.onCameraModified(evt);\r\n    }\r\n  });\r\n};\r\n\r\nconst enable = function (element) {\r\n  element.addEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\r\n};\r\n\r\nconst disable = function (element) {\r\n  element.removeEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\r\n};\r\n\r\nexport default {\r\n  enable,\r\n  disable,\r\n};\r\n","import { Enums, Types } from '@cornerstonejs/core';\r\nimport { ToolModes } from '../enums';\r\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\r\n\r\nconst { Active, Passive, Enabled } = ToolModes;\r\n\r\n/**\r\n * When image spacing is calibrated modify the annotations for all of its tools\r\n * to consider the new calibration info.\r\n *\r\n * - First we get all tools which are active, passive or enabled on the element.\r\n * - If any of these tools have a `onImageSpacingCalibrated` method, we call it.\r\n *\r\n * @param evt - The normalized image calibration event.\r\n */\r\nconst onImageSpacingCalibrated = function (\r\n  evt: Types.EventTypes.ImageSpacingCalibratedEvent\r\n) {\r\n  // @ts-ignore\r\n  const enabledTools = getToolsWithModesForMouseEvent(evt, [\r\n    Active,\r\n    Passive,\r\n    Enabled,\r\n  ]);\r\n\r\n  enabledTools.forEach((tool) => {\r\n    if (tool.onImageSpacingCalibrated) {\r\n      tool.onImageSpacingCalibrated(evt);\r\n    }\r\n  });\r\n};\r\n\r\nconst enable = function (element: HTMLDivElement) {\r\n  element.addEventListener(\r\n    Enums.Events.IMAGE_SPACING_CALIBRATED,\r\n    onImageSpacingCalibrated as EventListener\r\n  );\r\n};\r\n\r\nconst disable = function (element: HTMLDivElement) {\r\n  element.removeEventListener(\r\n    Enums.Events.IMAGE_SPACING_CALIBRATED,\r\n    onImageSpacingCalibrated as EventListener\r\n  );\r\n};\r\n\r\nexport default {\r\n  enable,\r\n  disable,\r\n};\r\n","import Events from '../enums/Events';\r\n\r\nimport {\r\n  touchStart,\r\n  touchStartActivate,\r\n  touchDrag,\r\n  touchEnd,\r\n  touchTap,\r\n  touchPress,\r\n} from './touchEventHandlers';\r\n\r\n/**\r\n * Enable these listeners are emitted in order, and can be cancelled/prevented from bubbling\r\n * by any previous event.\r\n *\r\n * @param element - The element to add the event listeners to.\r\n */\r\nconst enable = function (element: HTMLDivElement): void {\r\n  element.addEventListener(Events.TOUCH_START, touchStart as EventListener);\r\n  element.addEventListener(\r\n    Events.TOUCH_START_ACTIVATE,\r\n    touchStartActivate as EventListener\r\n  );\r\n  element.addEventListener(Events.TOUCH_DRAG, touchDrag as EventListener);\r\n  element.addEventListener(Events.TOUCH_END, touchEnd as EventListener);\r\n  element.addEventListener(Events.TOUCH_TAP, touchTap as EventListener);\r\n  element.addEventListener(Events.TOUCH_PRESS, touchPress as EventListener);\r\n};\r\n\r\n/**\r\n * Disable and Remove the MouseToolEventDispatcher handlers from the element.\r\n *\r\n * @param element - HTMLDivElement\r\n */\r\nconst disable = function (element: HTMLDivElement) {\r\n  element.removeEventListener(Events.TOUCH_START, touchStart as EventListener);\r\n  element.removeEventListener(\r\n    Events.TOUCH_START_ACTIVATE,\r\n    touchStartActivate as EventListener\r\n  );\r\n  element.removeEventListener(Events.TOUCH_DRAG, touchDrag as EventListener);\r\n  element.removeEventListener(Events.TOUCH_END, touchEnd as EventListener);\r\n  element.removeEventListener(Events.TOUCH_PRESS, touchPress as EventListener);\r\n};\r\n\r\nconst touchToolEventDispatcher = {\r\n  enable,\r\n  disable,\r\n};\r\n\r\nexport default touchToolEventDispatcher;\r\n","import { eventTarget } from '@cornerstonejs/core';\r\nimport Events from '../enums/Events';\r\nimport InterpolationManager from '../utilities/segmentation/InterpolationManager/InterpolationManager';\r\n\r\n/**\r\n * The enable and disable add/remove the event listeners that dispatch the\r\n * required events to the interpolation manager.\r\n */\r\nconst enable = function () {\r\n  eventTarget.addEventListener(\r\n    Events.ANNOTATION_COMPLETED,\r\n    InterpolationManager.handleAnnotationCompleted as EventListener\r\n  );\r\n  eventTarget.addEventListener(\r\n    Events.ANNOTATION_MODIFIED,\r\n    InterpolationManager.handleAnnotationUpdate as EventListener\r\n  );\r\n  eventTarget.addEventListener(\r\n    Events.ANNOTATION_REMOVED,\r\n    InterpolationManager.handleAnnotationDelete as EventListener\r\n  );\r\n};\r\n\r\nconst disable = function () {\r\n  eventTarget.removeEventListener(\r\n    Events.ANNOTATION_COMPLETED,\r\n    InterpolationManager.handleAnnotationCompleted as EventListener\r\n  );\r\n  eventTarget.removeEventListener(\r\n    Events.ANNOTATION_MODIFIED,\r\n    InterpolationManager.handleAnnotationUpdate as EventListener\r\n  );\r\n  eventTarget.removeEventListener(\r\n    Events.ANNOTATION_REMOVED,\r\n    InterpolationManager.handleAnnotationDelete as EventListener\r\n  );\r\n};\r\n\r\nexport default {\r\n  enable,\r\n  disable,\r\n};\r\n","import { Enums, Types } from '@cornerstonejs/core';\r\nimport { ToolModes } from '../enums';\r\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\r\n\r\nconst { Active, Passive, Enabled } = ToolModes;\r\n\r\n/**\r\n * When the camera is reset, check what tools need to react to this.\r\n *\r\n * - First we get all tools which are active, passive or enabled on the element.\r\n * - If any of these tools have a `onCameraReset` method, we call it.\r\n *\r\n * @param evt - The normalized camera reset event.\r\n */\r\nconst onCameraReset = function (evt: Types.EventTypes.CameraResetEvent) {\r\n  // @ts-ignore\r\n  const enabledTools = getToolsWithModesForMouseEvent(evt, [\r\n    Active,\r\n    Passive,\r\n    Enabled,\r\n  ]);\r\n\r\n  enabledTools.forEach((tool) => {\r\n    if (tool.onResetCamera) {\r\n      tool.onResetCamera(evt);\r\n    }\r\n  });\r\n};\r\n\r\nconst enable = function (element) {\r\n  element.addEventListener(Enums.Events.CAMERA_RESET, onCameraReset);\r\n};\r\n\r\nconst disable = function (element) {\r\n  element.removeEventListener(Enums.Events.CAMERA_RESET, onCameraReset);\r\n};\r\n\r\nexport default {\r\n  enable,\r\n  disable,\r\n};\r\n","import {\r\n  getEnabledElement,\r\n  utilities as csUtils,\r\n  Types,\r\n} from '@cornerstonejs/core';\r\nimport { ContourSegmentationAnnotation } from '../../../types/ContourSegmentationAnnotation';\r\nimport getViewportsForAnnotation from '../../../utilities/getViewportsForAnnotation';\r\nimport {\r\n  math,\r\n  triggerAnnotationRenderForViewportIds,\r\n} from '../../../utilities';\r\nimport { getViewportIdsWithToolToRender } from '../../../utilities/viewportFilters';\r\nimport {\r\n  addAnnotation,\r\n  removeAnnotation,\r\n  getAllAnnotations,\r\n  getChildAnnotations,\r\n  addChildAnnotation,\r\n  clearParentAnnotation,\r\n} from '../../../stateManagement/annotation/annotationState';\r\nimport {\r\n  AnnotationCompletedEventType,\r\n  ContourAnnotationCompletedEventDetail,\r\n} from '../../../types/EventTypes';\r\nimport * as contourUtils from '../../../utilities/contours';\r\nimport * as contourSegUtils from '../../../utilities/contourSegmentation';\r\nimport { ToolGroupManager, hasTool as cstHasTool } from '../../../store';\r\nimport { PlanarFreehandContourSegmentationTool } from '../../../tools';\r\nimport type { Annotation } from '../../../types';\r\nimport type { ContourAnnotation } from '../../../types/ContourAnnotation';\r\nimport { ContourWindingDirection } from '../../../types/ContourAnnotation';\r\nimport { triggerAnnotationModified } from '../../../stateManagement/annotation/helpers/state';\r\n\r\nconst DEFAULT_CONTOUR_SEG_TOOLNAME = 'PlanarFreehandContourSegmentationTool';\r\n\r\nexport default async function contourSegmentationCompletedListener(\r\n  evt: AnnotationCompletedEventType\r\n) {\r\n  const sourceAnnotation = evt.detail\r\n    .annotation as ContourSegmentationAnnotation;\r\n\r\n  if (!contourSegUtils.isContourSegmentationAnnotation(sourceAnnotation)) {\r\n    return;\r\n  }\r\n\r\n  const viewport = getViewport(sourceAnnotation);\r\n  const contourSegmentationAnnotations = getValidContourSegmentationAnnotations(\r\n    viewport,\r\n    sourceAnnotation\r\n  );\r\n\r\n  if (!contourSegmentationAnnotations.length) {\r\n    return;\r\n  }\r\n\r\n  const sourcePolyline = convertContourPolylineToCanvasSpace(\r\n    sourceAnnotation.data.contour.polyline,\r\n    viewport\r\n  );\r\n\r\n  const targetAnnotationInfo = findIntersectingContour(\r\n    viewport,\r\n    sourcePolyline,\r\n    contourSegmentationAnnotations\r\n  );\r\n\r\n  if (!targetAnnotationInfo) {\r\n    return;\r\n  }\r\n\r\n  const { targetAnnotation, targetPolyline, isContourHole } =\r\n    targetAnnotationInfo;\r\n\r\n  if (isContourHole) {\r\n    const { contourHoleProcessingEnabled = false } =\r\n      evt.detail as ContourAnnotationCompletedEventDetail;\r\n\r\n    // Do not create holes when contourHoleProcessingEnabled is `false`\r\n    if (!contourHoleProcessingEnabled) {\r\n      return;\r\n    }\r\n\r\n    createPolylineHole(viewport, targetAnnotation, sourceAnnotation);\r\n  } else {\r\n    combinePolylines(\r\n      viewport,\r\n      targetAnnotation,\r\n      targetPolyline,\r\n      sourceAnnotation,\r\n      sourcePolyline\r\n    );\r\n  }\r\n}\r\n\r\nfunction isFreehandContourSegToolRegisteredForViewport(\r\n  viewport: Types.IViewport,\r\n  silent = false\r\n) {\r\n  const { toolName } = PlanarFreehandContourSegmentationTool;\r\n\r\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\r\n    viewport.id,\r\n    viewport.renderingEngineId\r\n  );\r\n\r\n  let errorMessage;\r\n\r\n  if (!toolGroup.hasTool(toolName)) {\r\n    errorMessage = `Tool ${toolName} not added to ${toolGroup.id} toolGroup`;\r\n  } else if (!toolGroup.getToolOptions(toolName)) {\r\n    errorMessage = `Tool ${toolName} must be in active/passive state`;\r\n  }\r\n\r\n  if (errorMessage && !silent) {\r\n    console.warn(errorMessage);\r\n  }\r\n\r\n  return !errorMessage;\r\n}\r\n\r\nfunction getViewport(annotation: Annotation) {\r\n  const viewports = getViewportsForAnnotation(annotation);\r\n  const viewportWithToolRegistered = viewports.find((viewport) =>\r\n    isFreehandContourSegToolRegisteredForViewport(viewport, true)\r\n  );\r\n\r\n  // Returns the first viewport even if freehand contour segmentation is not\r\n  // registered because it can be used to project the polyline to create holes.\r\n  // Another verification is done before appending/removing contours which is\r\n  // possible only when the tool is registered.\r\n  return viewportWithToolRegistered ?? viewports[0];\r\n}\r\n\r\nfunction convertContourPolylineToCanvasSpace(\r\n  polyline: Types.Point3[],\r\n  viewport: Types.IViewport\r\n): Types.Point2[] {\r\n  const numPoints = polyline.length;\r\n  const projectedPolyline = new Array(numPoints);\r\n\r\n  for (let i = 0; i < numPoints; i++) {\r\n    projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\r\n  }\r\n\r\n  return projectedPolyline;\r\n}\r\n\r\nfunction getValidContourSegmentationAnnotations(\r\n  viewport: Types.IViewport,\r\n  sourceAnnotation: ContourSegmentationAnnotation\r\n): ContourSegmentationAnnotation[] {\r\n  const { annotationUID: sourceAnnotationUID } = sourceAnnotation;\r\n\r\n  // Get all annotations and filter all contour segmentations locally\r\n  const allAnnotations = getAllAnnotations();\r\n  return allAnnotations.filter(\r\n    (targetAnnotation) =>\r\n      targetAnnotation.annotationUID &&\r\n      targetAnnotation.annotationUID !== sourceAnnotationUID &&\r\n      contourSegUtils.isContourSegmentationAnnotation(targetAnnotation) &&\r\n      contourSegUtils.areSameSegment(targetAnnotation, sourceAnnotation) &&\r\n      viewport.isReferenceViewable(targetAnnotation.metadata)\r\n  ) as ContourSegmentationAnnotation[];\r\n}\r\n\r\n/**\r\n * Finds other contours on the same slice which intersect the source polyline,\r\n * represented as canvas points.\r\n */\r\nfunction findIntersectingContour(\r\n  viewport: Types.IViewport,\r\n  sourcePolyline: Types.Point2[],\r\n  contourSegmentationAnnotations: ContourSegmentationAnnotation[]\r\n): {\r\n  targetAnnotation: ContourSegmentationAnnotation;\r\n  targetPolyline: Types.Point2[];\r\n  isContourHole: boolean;\r\n} {\r\n  const sourceAABB = math.polyline.getAABB(sourcePolyline);\r\n\r\n  for (let i = 0; i < contourSegmentationAnnotations.length; i++) {\r\n    const targetAnnotation = contourSegmentationAnnotations[i];\r\n    const targetPolyline = convertContourPolylineToCanvasSpace(\r\n      targetAnnotation.data.contour.polyline,\r\n      viewport\r\n    );\r\n\r\n    const targetAABB = math.polyline.getAABB(targetPolyline);\r\n    const aabbIntersect = math.aabb.intersectAABB(sourceAABB, targetAABB);\r\n    const lineSegmentsIntersect =\r\n      aabbIntersect &&\r\n      math.polyline.intersectPolyline(sourcePolyline, targetPolyline);\r\n    const isContourHole =\r\n      aabbIntersect &&\r\n      !lineSegmentsIntersect &&\r\n      math.polyline.containsPoints(targetPolyline, sourcePolyline);\r\n\r\n    if (lineSegmentsIntersect || isContourHole) {\r\n      return { targetAnnotation, targetPolyline, isContourHole };\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Modifies the holeAnnotation to work as a contour hole in the targetAnnotation,\r\n * displayed on the given viewport.\r\n\r\n */\r\nexport function createPolylineHole(\r\n  viewport: Types.IViewport,\r\n  targetAnnotation: ContourSegmentationAnnotation,\r\n  holeAnnotation: ContourSegmentationAnnotation\r\n) {\r\n  const { windingDirection: targetWindingDirection } =\r\n    targetAnnotation.data.contour;\r\n  const { windingDirection: holeWindingDirection } =\r\n    holeAnnotation.data.contour;\r\n\r\n  addChildAnnotation(targetAnnotation, holeAnnotation);\r\n  contourSegUtils.removeContourSegmentationAnnotation(holeAnnotation);\r\n\r\n  const { contour: holeContour } = holeAnnotation.data;\r\n  const holePolyline = convertContourPolylineToCanvasSpace(\r\n    holeContour.polyline,\r\n    viewport\r\n  );\r\n\r\n  // Calling `updateContourPolyline` method instead of reversing the polyline\r\n  // locally because it is also responsible for checking/fixing the winding direction.\r\n  contourUtils.updateContourPolyline(\r\n    holeAnnotation,\r\n    {\r\n      points: holePolyline,\r\n      closed: holeContour.closed,\r\n    },\r\n    viewport\r\n  );\r\n\r\n  const { element } = viewport;\r\n  const enabledElement = getEnabledElement(element);\r\n  const { renderingEngine } = enabledElement;\r\n\r\n  // Updating a Spline contours, for example, should also update freehand contours\r\n  const updatedToolNames = new Set([\r\n    DEFAULT_CONTOUR_SEG_TOOLNAME,\r\n    targetAnnotation.metadata.toolName,\r\n    holeAnnotation.metadata.toolName,\r\n  ]);\r\n\r\n  for (const toolName of updatedToolNames.values()) {\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      toolName\r\n    );\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  }\r\n}\r\n\r\nfunction getContourHolesData(\r\n  viewport: Types.IViewport,\r\n  annotation: ContourAnnotation\r\n) {\r\n  return getChildAnnotations(annotation).map((holeAnnotation) => {\r\n    const polyline = convertContourPolylineToCanvasSpace(\r\n      holeAnnotation.data.contour.polyline,\r\n      viewport\r\n    );\r\n\r\n    return { annotation: holeAnnotation, polyline };\r\n  });\r\n}\r\n\r\nfunction combinePolylines(\r\n  viewport: Types.IViewport,\r\n  targetAnnotation: ContourSegmentationAnnotation,\r\n  targetPolyline: Types.Point2[],\r\n  sourceAnnotation: ContourSegmentationAnnotation,\r\n  sourcePolyline: Types.Point2[]\r\n) {\r\n  if (!cstHasTool(PlanarFreehandContourSegmentationTool)) {\r\n    console.warn(\r\n      `${PlanarFreehandContourSegmentationTool.toolName} is not registered in cornerstone`\r\n    );\r\n    return;\r\n  }\r\n\r\n  // Cannot append/remove an annotation if it will not be available on any viewport\r\n  if (!isFreehandContourSegToolRegisteredForViewport(viewport)) {\r\n    return;\r\n  }\r\n\r\n  const sourceStartPoint = sourcePolyline[0];\r\n  const mergePolylines = math.polyline.containsPoint(\r\n    targetPolyline,\r\n    sourceStartPoint\r\n  );\r\n\r\n  const contourHolesData = getContourHolesData(viewport, targetAnnotation);\r\n  const unassignedContourHolesSet = new Set(contourHolesData);\r\n  const reassignedContourHolesMap = new Map();\r\n  const assignHoleToPolyline = (parentPolyline, holeData) => {\r\n    let holes = reassignedContourHolesMap.get(parentPolyline);\r\n\r\n    if (!holes) {\r\n      holes = [];\r\n      reassignedContourHolesMap.set(parentPolyline, holes);\r\n    }\r\n\r\n    holes.push(holeData);\r\n    unassignedContourHolesSet.delete(holeData);\r\n  };\r\n  const newPolylines = [];\r\n\r\n  if (mergePolylines) {\r\n    const mergedPolyline = math.polyline.mergePolylines(\r\n      targetPolyline,\r\n      sourcePolyline\r\n    );\r\n\r\n    newPolylines.push(mergedPolyline);\r\n\r\n    // Keep all holes because the contour can only grow when merging and there\r\n    // is no chance for any hole to be removed\r\n    Array.from(unassignedContourHolesSet.keys()).forEach((holeData) =>\r\n      assignHoleToPolyline(mergedPolyline, holeData)\r\n    );\r\n  } else {\r\n    const subtractedPolylines = math.polyline.subtractPolylines(\r\n      targetPolyline,\r\n      sourcePolyline\r\n    );\r\n\r\n    subtractedPolylines.forEach((newPolyline) => {\r\n      newPolylines.push(newPolyline);\r\n\r\n      Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => {\r\n        const containsHole = math.polyline.containsPoints(\r\n          newPolyline,\r\n          holeData.polyline\r\n        );\r\n\r\n        if (containsHole) {\r\n          assignHoleToPolyline(newPolyline, holeData);\r\n          unassignedContourHolesSet.delete(holeData);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  // Make sure the holes that will be added to the new annotation are not\r\n  // associated to the target annotation that will be deleted\r\n  Array.from(reassignedContourHolesMap.values()).forEach(\r\n    (contourHolesDataArray) =>\r\n      contourHolesDataArray.forEach((contourHoleData) =>\r\n        clearParentAnnotation(contourHoleData.annotation)\r\n      )\r\n  );\r\n\r\n  const { element } = viewport;\r\n  const enabledElement = getEnabledElement(element);\r\n  const { metadata, data } = targetAnnotation;\r\n  const { handles, segmentation } = data;\r\n  const { textBox } = handles;\r\n\r\n  removeAnnotation(sourceAnnotation.annotationUID);\r\n  removeAnnotation(targetAnnotation.annotationUID);\r\n\r\n  for (let i = 0; i < newPolylines.length; i++) {\r\n    const polyline = newPolylines[i];\r\n    const startPoint = viewport.canvasToWorld(polyline[0]);\r\n    const endPoint = viewport.canvasToWorld(polyline[polyline.length - 1]);\r\n    const newAnnotation: ContourSegmentationAnnotation = {\r\n      metadata: {\r\n        ...metadata,\r\n        toolName: DEFAULT_CONTOUR_SEG_TOOLNAME,\r\n        originalToolName: metadata.originalToolName || metadata.toolName,\r\n      },\r\n      data: {\r\n        cachedStats: {},\r\n        handles: {\r\n          points: [startPoint, endPoint],\r\n          textBox: textBox ? { ...textBox } : undefined,\r\n        },\r\n        contour: {\r\n          polyline: [],\r\n          closed: true,\r\n        },\r\n        spline: targetAnnotation.data.spline,\r\n        segmentation: {\r\n          ...segmentation,\r\n        },\r\n      },\r\n      annotationUID: csUtils.uuidv4() as string,\r\n      highlighted: true,\r\n      invalidated: true,\r\n      isLocked: false,\r\n      isVisible: undefined,\r\n      // Allow this object to be interpolated against the original interpolation\r\n      // data.\r\n      interpolationUID: targetAnnotation.interpolationUID,\r\n      interpolationCompleted: targetAnnotation.interpolationCompleted,\r\n    };\r\n\r\n    // Calling `updateContourPolyline` method instead of setting it locally\r\n    // because it is also responsible for checking/fixing the winding direction.\r\n    contourUtils.updateContourPolyline(\r\n      newAnnotation,\r\n      {\r\n        points: polyline,\r\n        closed: true,\r\n        targetWindingDirection: ContourWindingDirection.Clockwise,\r\n      },\r\n      viewport\r\n    );\r\n\r\n    addAnnotation(newAnnotation, element);\r\n    contourSegUtils.addContourSegmentationAnnotation(newAnnotation);\r\n    triggerAnnotationModified(newAnnotation, viewport.element);\r\n\r\n    reassignedContourHolesMap\r\n      .get(polyline)\r\n      ?.forEach((holeData) =>\r\n        addChildAnnotation(newAnnotation, holeData.annotation)\r\n      );\r\n  }\r\n\r\n  updateViewports(enabledElement, targetAnnotation, sourceAnnotation);\r\n}\r\n\r\nfunction updateViewports(enabledElement, targetAnnotation, sourceAnnotation) {\r\n  const { viewport } = enabledElement;\r\n  const { element } = viewport;\r\n  const { renderingEngine } = enabledElement;\r\n\r\n  const updatedTtoolNames = new Set([\r\n    DEFAULT_CONTOUR_SEG_TOOLNAME,\r\n    targetAnnotation.metadata.toolName,\r\n    sourceAnnotation.metadata.toolName,\r\n  ]);\r\n\r\n  for (const toolName of updatedTtoolNames.values()) {\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      toolName\r\n    );\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  }\r\n\r\n  return new Promise((resolve) => window.requestAnimationFrame(resolve));\r\n}\r\n","import mouseDoubleClickListener from './mouseDoubleClickListener';\r\nimport mouseDownListener, {\r\n  mouseDoubleClickIgnoreListener,\r\n} from './mouseDownListener';\r\nimport mouseMoveListener from './mouseMoveListener';\r\n\r\n/**\r\n * Removes mouse event listeners for native mouse event. Enables\r\n * vtk.js tools flavored events that build on top of existing events to\r\n * provide more helpful information.\r\n *\r\n * @private\r\n * @param element - The DOM element to remove event listeners from.\r\n */\r\nfunction disable(element: HTMLDivElement): void {\r\n  element.removeEventListener('dblclick', mouseDoubleClickListener);\r\n  element.removeEventListener('mousedown', mouseDownListener);\r\n  element.removeEventListener('mousemove', mouseMoveListener);\r\n  // The mouseDoubleClickIgnoreListener prevents those browser 'dblclick'\r\n  // events that cornerstone has determined are single clicks from propagating\r\n  // to other (3rd party) listeners. A capture phase listener is used so that\r\n  // the 'dblclick' event can be ignored and not propagated ASAP.\r\n  element.removeEventListener('dblclick', mouseDoubleClickIgnoreListener, {\r\n    capture: true,\r\n  });\r\n}\r\n\r\n/**\r\n * Registers mouse event listeners for native mouse event. Enables\r\n * vtk.js tools flavored events that build on top of existing events to\r\n * provide more helpful information.\r\n *\r\n * @private\r\n * @param element - The DOM element to register event listeners on.\r\n */\r\nfunction enable(element: HTMLDivElement): void {\r\n  // Prevent handlers from being attached multiple times\r\n  disable(element);\r\n\r\n  element.addEventListener('dblclick', mouseDoubleClickListener);\r\n  element.addEventListener('mousedown', mouseDownListener);\r\n  element.addEventListener('mousemove', mouseMoveListener);\r\n  // The mouseDoubleClickIgnoreListener prevents those browser 'dblclick'\r\n  // events that cornerstone has determined are single clicks from propagating\r\n  // to other (3rd party) listeners. A capture phase listener is used so that\r\n  // the 'dblclick' event can be ignored and not propagated ASAP.\r\n  element.addEventListener('dblclick', mouseDoubleClickIgnoreListener, {\r\n    capture: true,\r\n  });\r\n}\r\n\r\nexport default {\r\n  enable,\r\n  disable,\r\n};\r\n","import preventGhostClick from './preventGhostClick';\r\nimport touchStartListener from './touchStartListener';\r\n\r\n/**\r\n * Removes touch event listeners for native touch event. Enables\r\n * vtk.js tools flavored events that build on top of existing events to\r\n * provide more helpful information.\r\n *\r\n * @private\r\n * @param element - The DOM element to remove event listeners from.\r\n */\r\nfunction disable(element: HTMLDivElement): void {\r\n  preventGhostClick.disable(element);\r\n  element.removeEventListener('touchstart', touchStartListener);\r\n}\r\n\r\n/**\r\n * Registers touch event listeners for native touch event. Enables\r\n * vtk.js tools flavored events that build on top of existing events to\r\n * provide more helpful information.\r\n *\r\n * @private\r\n * @param element - The DOM element to register event listeners on.\r\n */\r\nfunction enable(element: HTMLDivElement): void {\r\n  // Prevent handlers from being attached multiple times\r\n  disable(element);\r\n  preventGhostClick.enable(element);\r\n  element.addEventListener('touchstart', touchStartListener, {\r\n    passive: false,\r\n  });\r\n}\r\n\r\nexport default {\r\n  enable,\r\n  disable,\r\n};\r\n","import wheelListener from './wheelListener';\r\n\r\n/**\r\n * Listens for the wheel event, and handles it. Handled event\r\n * will be \"normalized\" and re-emitted as `Events.MOUSE_WHEEL`\r\n *\r\n * @param element - The HTML element\r\n */\r\nfunction enable(element: HTMLDivElement) {\r\n  disable(element);\r\n  element.addEventListener('wheel', wheelListener, { passive: false });\r\n}\r\n\r\n/**\r\n * Removes listener and handler for wheel event. `Events.MOUSE_WHEEL`\r\n * will no longer be emitted.\r\n *\r\n * @param element - THe HTML element\r\n */\r\nfunction disable(element: HTMLDivElement) {\r\n  element.removeEventListener('wheel', wheelListener);\r\n}\r\n\r\nexport default {\r\n  enable,\r\n  disable,\r\n};\r\n","import triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\r\nimport { SegmentationRepresentationModifiedEventType } from '../../types/EventTypes';\r\n\r\n/** A function that listens to the `segmentationStateModified` event and triggers\r\n * the `triggerSegmentationRender` function. This function is called when the\r\n * segmentation state or config is modified.\r\n */\r\nconst segmentationRepresentationModifiedListener = function (\r\n  evt: SegmentationRepresentationModifiedEventType\r\n): void {\r\n  const { toolGroupId } = evt.detail;\r\n  triggerSegmentationRender(toolGroupId);\r\n};\r\n\r\nexport default segmentationRepresentationModifiedListener;\r\n","import {\r\n  cache,\r\n  getEnabledElementByIds,\r\n  utilities as csUtils,\r\n  VolumeViewport,\r\n} from '@cornerstonejs/core';\r\n\r\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\r\nimport { SegmentationDataModifiedEventType } from '../../../types/EventTypes';\r\nimport {\r\n  LabelmapSegmentationDataStack,\r\n  LabelmapSegmentationDataVolume,\r\n} from '../../../types/LabelmapTypes';\r\nimport { getToolGroup } from '../../../store/ToolGroupManager';\r\n\r\n/** A callback function that is called when the segmentation data is modified which\r\n *  often is as a result of tool interactions e.g., scissors, eraser, etc.\r\n */\r\nconst onLabelmapSegmentationDataModified = function (\r\n  evt: SegmentationDataModifiedEventType\r\n): void {\r\n  const { segmentationId, modifiedSlicesToUse } = evt.detail;\r\n\r\n  const { representationData, type } =\r\n    SegmentationState.getSegmentation(segmentationId);\r\n\r\n  const toolGroupIds =\r\n    SegmentationState.getToolGroupIdsWithSegmentation(segmentationId);\r\n\r\n  const labelmapRepresentationData = representationData[type];\r\n\r\n  if ('volumeId' in labelmapRepresentationData) {\r\n    // get the volume from cache, we need the openGLTexture to be updated to GPU\r\n    performVolumeLabelmapUpdate({\r\n      modifiedSlicesToUse,\r\n      representationData,\r\n      type,\r\n    });\r\n  }\r\n\r\n  if ('imageIdReferenceMap' in labelmapRepresentationData) {\r\n    // get the stack from cache, we need the imageData to be updated to GPU\r\n    performStackLabelmapUpdate({\r\n      toolGroupIds,\r\n      segmentationId,\r\n      representationData,\r\n      type,\r\n    });\r\n  }\r\n};\r\n\r\nfunction performVolumeLabelmapUpdate({\r\n  modifiedSlicesToUse,\r\n  representationData,\r\n  type,\r\n}) {\r\n  const segmentationVolume = cache.getVolume(\r\n    (representationData[type] as LabelmapSegmentationDataVolume).volumeId\r\n  );\r\n\r\n  if (!segmentationVolume) {\r\n    console.warn('segmentation not found in cache');\r\n    return;\r\n  }\r\n\r\n  const { imageData, vtkOpenGLTexture } = segmentationVolume;\r\n\r\n  // Update the texture for the volume in the GPU\r\n  let slicesToUpdate;\r\n  if (modifiedSlicesToUse && Array.isArray(modifiedSlicesToUse)) {\r\n    slicesToUpdate = modifiedSlicesToUse;\r\n  } else {\r\n    const numSlices = imageData.getDimensions()[2];\r\n    slicesToUpdate = [...Array(numSlices).keys()];\r\n  }\r\n\r\n  slicesToUpdate.forEach((i) => {\r\n    vtkOpenGLTexture.setUpdatedFrame(i);\r\n  });\r\n\r\n  // Trigger modified on the imageData to update the image\r\n  imageData.modified();\r\n}\r\n\r\nfunction performStackLabelmapUpdate({\r\n  toolGroupIds,\r\n  segmentationId,\r\n  representationData,\r\n  type,\r\n}) {\r\n  toolGroupIds.forEach((toolGroupId) => {\r\n    const toolGroupSegmentationRepresentations =\r\n      SegmentationState.getSegmentationRepresentations(toolGroupId);\r\n\r\n    const toolGroup = getToolGroup(toolGroupId);\r\n    const viewportsInfo = toolGroup.getViewportsInfo();\r\n\r\n    toolGroupSegmentationRepresentations.forEach((representation) => {\r\n      if (representation.segmentationId !== segmentationId) {\r\n        return;\r\n      }\r\n\r\n      viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\r\n        const viewport = getEnabledElementByIds(\r\n          viewportId,\r\n          renderingEngineId\r\n        ).viewport;\r\n\r\n        if (viewport instanceof VolumeViewport) {\r\n          return;\r\n        }\r\n\r\n        const actorEntry = viewport.getActor(\r\n          representation.segmentationRepresentationUID\r\n        );\r\n\r\n        if (!actorEntry) {\r\n          return;\r\n        }\r\n\r\n        const currentImageId = viewport.getCurrentImageId();\r\n\r\n        const segImageData = actorEntry.actor.getMapper().getInputData();\r\n\r\n        const { imageIdReferenceMap } = representationData[\r\n          type\r\n        ] as LabelmapSegmentationDataStack;\r\n\r\n        const currentSegmentationImageId =\r\n          imageIdReferenceMap.get(currentImageId);\r\n\r\n        const segmentationImage = cache.getImage(currentSegmentationImageId);\r\n        segImageData.modified();\r\n\r\n        // update the cache with the new image data\r\n        csUtils.updateVTKImageDataWithCornerstoneImage(\r\n          segImageData,\r\n          segmentationImage\r\n        );\r\n      });\r\n    });\r\n  });\r\n}\r\n\r\nexport default onLabelmapSegmentationDataModified;\r\n","import triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\r\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\r\nimport * as SegmentationState from '../../stateManagement/segmentation/segmentationState';\r\nimport { SegmentationDataModifiedEventType } from '../../types/EventTypes';\r\nimport onLabelmapSegmentationDataModified from './labelmap/onLabelmapSegmentationDataModified';\r\n\r\n/** A callback function that is called when the segmentation data is modified which\r\n *  often is as a result of tool interactions e.g., scissors, eraser, etc.\r\n */\r\nconst onSegmentationDataModified = function (\r\n  evt: SegmentationDataModifiedEventType\r\n): void {\r\n  const { segmentationId } = evt.detail;\r\n  const { type } = SegmentationState.getSegmentation(segmentationId);\r\n\r\n  const toolGroupIds =\r\n    SegmentationState.getToolGroupIdsWithSegmentation(segmentationId);\r\n\r\n  if (type === SegmentationRepresentations.Labelmap) {\r\n    onLabelmapSegmentationDataModified(evt);\r\n  }\r\n\r\n  toolGroupIds.forEach((toolGroupId) => {\r\n    triggerSegmentationRender(toolGroupId);\r\n  });\r\n};\r\n\r\nexport default onSegmentationDataModified;\r\n","import triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\r\nimport { SegmentationRepresentationRemovedEventType } from '../../types/EventTypes';\r\n\r\n/** A function that listens to the `segmentationRepresentationRemoved` event and triggers\r\n * the `triggerSegmentationRender` function. This function is called when the\r\n * segmentation state or config is modified.\r\n */\r\nconst segmentationRepresentationRemovedEventListener = function (\r\n  evt: SegmentationRepresentationRemovedEventType\r\n): void {\r\n  const { toolGroupId, segmentationRepresentationUID } = evt.detail;\r\n\r\n  triggerSegmentationRender(toolGroupId);\r\n};\r\n\r\nexport default segmentationRepresentationRemovedEventListener;\r\n","import { SegmentationModifiedEventType } from '../../types/EventTypes';\r\nimport {\r\n  getToolGroupIdsWithSegmentation,\r\n  getSegmentationRepresentations,\r\n} from '../../stateManagement/segmentation/segmentationState';\r\nimport { triggerSegmentationRepresentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\r\n\r\n/** A function that listens to the `segmentationModified` event and triggers\r\n * the triggerSegmentationRepresentationModified on each toolGroup that\r\n * has a representation of the given segmentationId.\r\n */\r\nconst segmentationModifiedListener = function (\r\n  evt: SegmentationModifiedEventType\r\n): void {\r\n  const { segmentationId } = evt.detail;\r\n\r\n  const toolGroupIds = getToolGroupIdsWithSegmentation(segmentationId);\r\n\r\n  toolGroupIds.forEach((toolGroupId) => {\r\n    const segRepresentations = getSegmentationRepresentations(toolGroupId);\r\n    segRepresentations.forEach((representation) => {\r\n      if (representation.segmentationId === segmentationId) {\r\n        triggerSegmentationRepresentationModified(\r\n          toolGroupId,\r\n          representation.segmentationRepresentationUID\r\n        );\r\n      }\r\n    });\r\n  });\r\n};\r\n\r\nexport default segmentationModifiedListener;\r\n","import vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\r\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\r\nimport {\r\n  BaseVolumeViewport,\r\n  getEnabledElement,\r\n  Enums,\r\n  getEnabledElementByIds,\r\n  cache,\r\n  utilities,\r\n  Types,\r\n} from '@cornerstonejs/core';\r\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\r\nimport Representations from '../../enums/SegmentationRepresentations';\r\nimport * as SegmentationState from '../../stateManagement/segmentation/segmentationState';\r\nimport { LabelmapSegmentationDataStack } from '../../types/LabelmapTypes';\r\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\r\nimport triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\r\n\r\nconst enable = function (element: HTMLDivElement): void {\r\n  const { viewport } = getEnabledElement(element);\r\n\r\n  if (viewport instanceof BaseVolumeViewport) {\r\n    return;\r\n  }\r\n\r\n  element.addEventListener(\r\n    Enums.Events.STACK_NEW_IMAGE,\r\n    _imageChangeEventListener as EventListener\r\n  );\r\n  // this listener handles the segmentation modifications\r\n  element.addEventListener(\r\n    Enums.Events.IMAGE_RENDERED,\r\n    _imageChangeEventListener as EventListener\r\n  );\r\n};\r\n\r\nconst disable = function (element: HTMLDivElement): void {\r\n  element.removeEventListener(\r\n    Enums.Events.STACK_NEW_IMAGE,\r\n    _imageChangeEventListener as EventListener\r\n  );\r\n  element.removeEventListener(\r\n    Enums.Events.IMAGE_RENDERED,\r\n    _imageChangeEventListener as EventListener\r\n  );\r\n};\r\n\r\nconst perToolGroupManualTriggers = new Map();\r\n\r\n/**\r\n *  When the image is rendered, check what tools can be rendered for this element.\r\n *\r\n * - First we get all tools which are active, passive or enabled on the element.\r\n * - If any of these tools have a `renderAnnotation` method, then we render them.\r\n * - Note that these tools don't necessarily have to be instances of  `AnnotationTool`,\r\n *   Any tool may register a `renderAnnotation` method (e.g. a tool that displays an overlay).\r\n *\r\n * @param evt - The normalized IMAGE_RENDERED event.\r\n */\r\nfunction _imageChangeEventListener(evt) {\r\n  const eventData = evt.detail;\r\n  const { viewportId, renderingEngineId } = eventData;\r\n  const { viewport } = getEnabledElementByIds(\r\n    viewportId,\r\n    renderingEngineId\r\n  ) as { viewport: Types.IStackViewport };\r\n\r\n  const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\r\n\r\n  if (!toolGroup) {\r\n    return;\r\n  }\r\n\r\n  let toolGroupSegmentationRepresentations =\r\n    SegmentationState.getSegmentationRepresentations(toolGroup.id) || [];\r\n\r\n  toolGroupSegmentationRepresentations =\r\n    toolGroupSegmentationRepresentations.filter(\r\n      (representation) => representation.type === Representations.Labelmap\r\n    );\r\n\r\n  if (!toolGroupSegmentationRepresentations?.length) {\r\n    return;\r\n  }\r\n\r\n  const segmentationRepresentations = {};\r\n  toolGroupSegmentationRepresentations.forEach((representation) => {\r\n    const segmentation = SegmentationState.getSegmentation(\r\n      representation.segmentationId\r\n    );\r\n\r\n    if (!segmentation || !segmentation.representationData?.LABELMAP) {\r\n      return;\r\n    }\r\n\r\n    const labelmapData = segmentation.representationData.LABELMAP;\r\n\r\n    if (isVolumeSegmentation(labelmapData, viewport)) {\r\n      return;\r\n    }\r\n\r\n    const { imageIdReferenceMap } =\r\n      labelmapData as LabelmapSegmentationDataStack;\r\n\r\n    segmentationRepresentations[representation.segmentationRepresentationUID] =\r\n      {\r\n        imageIdReferenceMap,\r\n      };\r\n  });\r\n\r\n  const representationList = Object.keys(segmentationRepresentations);\r\n  const currentImageId = viewport.getCurrentImageId();\r\n  const actors = viewport.getActors();\r\n\r\n  const segmentationFound = actors.find((actor) => {\r\n    if (!representationList.includes(actor.uid)) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  });\r\n\r\n  if (!segmentationFound) {\r\n    // If the segmentation is not found, it could be because of some special cases\r\n    // where we are in the process of updating the volume conversion to a stack while\r\n    // the data is still coming in. In such situations, we should trigger the render\r\n    // to ensure that the segmentation actors are created, even if the data arrives late.\r\n\r\n    if (!perToolGroupManualTriggers.has(toolGroup.id)) {\r\n      perToolGroupManualTriggers.set(toolGroup.id, true);\r\n      triggerSegmentationRender(toolGroup.id);\r\n    }\r\n\r\n    // we should return here, since there is no segmentation actor to update\r\n    // we will hit this function later on after the actor is created\r\n    return;\r\n  }\r\n\r\n  actors.forEach((actor) => {\r\n    if (!representationList.includes(actor.uid)) {\r\n      return;\r\n    }\r\n    const segmentationActor = actor.actor;\r\n\r\n    const { imageIdReferenceMap } = segmentationRepresentations[actor.uid];\r\n\r\n    const derivedImageId = imageIdReferenceMap.get(currentImageId);\r\n\r\n    const segmentationImageData = segmentationActor.getMapper().getInputData();\r\n\r\n    if (!derivedImageId) {\r\n      // this means that this slice doesn't have a segmentation for this representation\r\n      // this can be a case where the segmentation was added to certain slices only\r\n      // so we can keep the actor but empty out the imageData\r\n      if (segmentationImageData.setDerivedImage) {\r\n        // If the image data has a set derived image, then it should be called\r\n        // to update any vtk or actor data associated with it.  In this case, null\r\n        // is used to clear the data.  THis allows intercepting/alternative\r\n        // to vtk calls.  Eventually the vtk version should also use this.\r\n        segmentationImageData.setDerivedImage(null);\r\n        return;\r\n      }\r\n      // This is the vtk version of the clearing out the image data, and fails\r\n      // to work for non scalar image data.\r\n      const scalarArray = vtkDataArray.newInstance({\r\n        name: 'Pixels',\r\n        numberOfComponents: 1,\r\n        values: new Uint8Array(segmentationImageData.getNumberOfPoints()),\r\n      });\r\n\r\n      const imageData = vtkImageData.newInstance();\r\n      imageData.getPointData().setScalars(scalarArray);\r\n      segmentationActor.getMapper().setInputData(imageData);\r\n      return;\r\n    }\r\n\r\n    const derivedImage = cache.getImage(derivedImageId);\r\n\r\n    const { dimensions, spacing, direction } =\r\n      viewport.getImageDataMetadata(derivedImage);\r\n\r\n    const currentImage =\r\n      cache.getImage(currentImageId) ||\r\n      ({\r\n        imageId: currentImageId,\r\n      } as Types.IImage);\r\n    const { origin: currentOrigin } =\r\n      viewport.getImageDataMetadata(currentImage);\r\n\r\n    // IMPORTANT: We need to make sure that the origin of the segmentation\r\n    // is the same as the current image origin. This is because due to some\r\n    // floating point precision issues, when coming from volume to stack\r\n    // the origin of the segmentation can be slightly different from the\r\n    // current image origin. This can cause the segmentation to be rendered\r\n    // in the wrong location.\r\n    // Todo: This will not work for segmentations that are not in the same frame\r\n    // of reference or derived from the same image. This can happen when we have\r\n    // a segmentation that happens to exist in the same space as the image but is\r\n    // not derived from it. We need to find a way to handle this case, but don't think\r\n    // it makes sense to do it for the stack viewport, as the volume viewport is designed to handle this case.\r\n    const originToUse = currentOrigin;\r\n\r\n    segmentationImageData.setOrigin(originToUse);\r\n    segmentationImageData.modified();\r\n\r\n    if (\r\n      segmentationImageData.getDimensions()[0] !== dimensions[0] ||\r\n      segmentationImageData.getDimensions()[1] !== dimensions[1]\r\n    ) {\r\n      // IMPORTANT: Not sure why we can't just update the dimensions\r\n      // and the orientation of the image data and then call modified\r\n      // I tried calling modified on everything, but seems like we should remove\r\n      // and add the actor again below\r\n      viewport.removeActors([actor.uid]);\r\n      viewport.addImages([\r\n        {\r\n          imageId: derivedImageId,\r\n          actorUID: actor.uid,\r\n          callback: ({ imageActor }) => {\r\n            const scalarArray = vtkDataArray.newInstance({\r\n              name: 'Pixels',\r\n              numberOfComponents: 1,\r\n              values: [...derivedImage.getPixelData()],\r\n            });\r\n\r\n            const imageData = vtkImageData.newInstance();\r\n\r\n            imageData.setDimensions(dimensions[0], dimensions[1], 1);\r\n            imageData.setSpacing(spacing);\r\n            imageData.setDirection(direction);\r\n            imageData.setOrigin(originToUse);\r\n            imageData.getPointData().setScalars(scalarArray);\r\n\r\n            imageActor.getMapper().setInputData(imageData);\r\n          },\r\n        },\r\n      ]);\r\n\r\n      triggerSegmentationRender(toolGroup.id);\r\n      return;\r\n    }\r\n\r\n    if (segmentationImageData.setDerivedImage) {\r\n      // Update the derived image data, whether vtk or other as appropriate\r\n      // to the actor(s) displaying the data.\r\n      segmentationImageData.setDerivedImage(derivedImage);\r\n    } else {\r\n      // TODO - use setDerivedImage for this functionality\r\n      utilities.updateVTKImageDataWithCornerstoneImage(\r\n        segmentationImageData,\r\n        derivedImage\r\n      );\r\n    }\r\n    viewport.render();\r\n\r\n    // This is put here to make sure that the segmentation is rendered\r\n    // for the initial image as well after that we don't need it since\r\n    // stack new image is called when changing slices\r\n    if (evt.type === Enums.Events.IMAGE_RENDERED) {\r\n      // unsubscribe after the initial render\r\n      viewport.element.removeEventListener(\r\n        Enums.Events.IMAGE_RENDERED,\r\n        _imageChangeEventListener as EventListener\r\n      );\r\n    }\r\n  });\r\n}\r\n\r\nexport default {\r\n  enable,\r\n  disable,\r\n};\r\n","import { AnnotationCompletedEventType } from '../../types/EventTypes';\r\nimport * as contourSegUtils from '../../utilities/contourSegmentation';\r\nimport { contourSegmentationCompleted } from './contourSegmentation';\r\n\r\nexport default function annotationCompletedListener(\r\n  evt: AnnotationCompletedEventType\r\n) {\r\n  const annotation = evt.detail.annotation;\r\n\r\n  if (contourSegUtils.isContourSegmentationAnnotation(annotation)) {\r\n    contourSegmentationCompleted(evt);\r\n  }\r\n}\r\n","import { getRenderingEngines } from '@cornerstonejs/core';\r\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities';\r\n\r\n/**\r\n * When an annotation is deselected, trigger an annotation render for all viewports.\r\n * The reason for this is that, drawing an annotation in a different viewport\r\n * should deselect all other annotations in other viewports. In order to achieve\r\n * this, we need to trigger an annotation render for all viewports.\r\n * Todo: Although this is inefficient, but since annotations are only rendered if necessary,\r\n * it's probably not going to have a noticeable impact on performance.\r\n * @param evt - The event object.\r\n */\r\nfunction annotationSelectionListener(evt): void {\r\n  const deselectedAnnotation = evt.detail.removed;\r\n\r\n  if (!deselectedAnnotation.length) {\r\n    return;\r\n  }\r\n\r\n  const renderingEngines = getRenderingEngines();\r\n\r\n  renderingEngines.forEach((renderingEngine) => {\r\n    const viewports = renderingEngine.getViewports();\r\n    const viewportIds = viewports.map((vp) => vp.id);\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\r\n  });\r\n}\r\n\r\nexport default annotationSelectionListener;\r\n","import { getRenderingEngine } from '@cornerstonejs/core';\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\n\r\n/**\r\n * This is a callback function that is called when an annotation is modified.\r\n * Since we are throttling the cachedStats calculation for annotation tools,\r\n * we need to trigger a final render for the annotation. so that the annotation\r\n * textBox is updated.\r\n * Todo: This will trigger all the annotation tools to re-render, although DOM\r\n * will update those that have changed, but more efficient would be to only\r\n * update the changed annotation.\r\n * Todo: A better way is to extract the textBox render logic from the renderAnnotation\r\n * of all tools and just trigger a render for that (instead of the entire annotation., even if\r\n * no svg update happens since the attributes for handles are the same)\r\n */\r\nfunction annotationModifiedListener(evt): void {\r\n  const { viewportId, renderingEngineId } = evt.detail;\r\n  const renderingEngine = getRenderingEngine(renderingEngineId);\r\n  triggerAnnotationRenderForViewportIds(renderingEngine, [viewportId]);\r\n}\r\n\r\nexport default annotationModifiedListener;\r\n","import { AnnotationRemovedEventType } from '../../types/EventTypes';\r\nimport * as contourSegUtils from '../../utilities/contourSegmentation';\r\nimport { contourSegmentationRemoved } from './contourSegmentation';\r\n\r\nexport default function annotationRemovedListener(\r\n  evt: AnnotationRemovedEventType\r\n) {\r\n  const annotation = evt.detail.annotation;\r\n\r\n  if (contourSegUtils.isContourSegmentationAnnotation(annotation)) {\r\n    contourSegmentationRemoved(evt);\r\n  }\r\n}\r\n","import type { AnnotationRemovedEventType } from '../../../types/EventTypes';\r\nimport type { ContourSegmentationAnnotation } from '../../../types/ContourSegmentationAnnotation';\r\nimport { removeContourSegmentationAnnotation } from '../../../utilities/contourSegmentation';\r\n\r\nexport default function contourSegmentationRemovedListener(\r\n  evt: AnnotationRemovedEventType\r\n) {\r\n  const annotation = evt.detail.annotation as ContourSegmentationAnnotation;\r\n\r\n  removeContourSegmentationAnnotation(annotation);\r\n}\r\n","import { AnnotationVisibilityChangeEventType } from '../../types/EventTypes';\r\nimport { getRenderingEngines } from '@cornerstonejs/core';\r\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities';\r\n\r\nexport default function annotationVisibilityListener(\r\n  evt: AnnotationVisibilityChangeEventType\r\n) {\r\n  const annotationUIDs = [].concat(evt.detail.lastHidden, evt.detail.lastVisible);\r\n  if (!annotationUIDs) {\r\n    return;\r\n  }\r\n\r\n  const renderingEngines = getRenderingEngines();\r\n\r\n  renderingEngines.forEach((renderingEngine) => {\r\n    const viewports = renderingEngine.getViewports();\r\n    const viewportIds = viewports.map((vp) => vp.id);\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\r\n  });\r\n}\r\n","import { eventTarget, Enums } from '@cornerstonejs/core';\r\nimport { getAnnotationManager } from './stateManagement/annotation/annotationState';\r\nimport { getDefaultSegmentationStateManager } from './stateManagement/segmentation/segmentationState';\r\nimport { Events as TOOLS_EVENTS } from './enums';\r\nimport { addEnabledElement, removeEnabledElement } from './store';\r\nimport { resetCornerstoneToolsState } from './store/state';\r\nimport {\r\n  annotationCompletedListener,\r\n  annotationRemovedListener,\r\n  annotationSelectionListener,\r\n  annotationModifiedListener,\r\n  annotationVisibilityListener,\r\n  segmentationDataModifiedEventListener,\r\n  segmentationRepresentationModifiedEventListener,\r\n  segmentationRepresentationRemovedEventListener,\r\n  segmentationModifiedListener,\r\n} from './eventListeners';\r\nimport { annotationInterpolationEventDispatcher } from './eventDispatchers';\r\n\r\nimport * as ToolGroupManager from './store/ToolGroupManager';\r\n\r\nlet csToolsInitialized = false;\r\n\r\n/**\r\n * Initialize the cornerstoneTools package. It will add event listeners for mouse\r\n * and keyboard events.\r\n * @param defaultConfiguration - A configuration object that will be used to\r\n * initialize the tool.\r\n */\r\nexport function init(defaultConfiguration = {}): void {\r\n  if (csToolsInitialized) {\r\n    return;\r\n  }\r\n\r\n  _addCornerstoneEventListeners();\r\n  _addCornerstoneToolsEventListeners();\r\n\r\n  csToolsInitialized = true;\r\n}\r\n\r\n/**\r\n * It destroys and cleanup state for cornerstone3DTools. It removes all the tools\r\n * that were added to the tool groups and restore states. It also removes all\r\n * event listeners.\r\n */\r\nexport function destroy(): void {\r\n  _removeCornerstoneEventListeners();\r\n  _removeCornerstoneToolsEventListeners();\r\n\r\n  // Important: destroy ToolGroups first, in order for cleanup to work correctly for the\r\n  // added tools.\r\n  ToolGroupManager.destroy();\r\n\r\n  // Remove all tools\r\n  resetCornerstoneToolsState();\r\n\r\n  // remove all annotation.\r\n  const annotationManager = getAnnotationManager();\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n\r\n  annotationManager.restoreAnnotations({});\r\n  segmentationStateManager.resetState();\r\n  csToolsInitialized = false;\r\n}\r\n\r\n/**\r\n * Wires up event listeners for the Cornerstone#ElementDisabled and\r\n * Cornerstone#ElementEnabled events.\r\n *\r\n * @internal\r\n */\r\nfunction _addCornerstoneEventListeners(): void {\r\n  // Clear any listeners that may already be set\r\n  _removeCornerstoneEventListeners();\r\n\r\n  const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\r\n  const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\r\n\r\n  eventTarget.addEventListener(elementEnabledEvent, addEnabledElement);\r\n  eventTarget.addEventListener(elementDisabledEvent, removeEnabledElement);\r\n  annotationInterpolationEventDispatcher.enable();\r\n}\r\n\r\n/**\r\n * Removes event listeners for the Cornerstone#ElementDisabled and\r\n * Cornerstone#ElementEnabled events.\r\n *\r\n */\r\nfunction _removeCornerstoneEventListeners(): void {\r\n  const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\r\n  const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\r\n\r\n  eventTarget.removeEventListener(elementEnabledEvent, addEnabledElement);\r\n  eventTarget.removeEventListener(elementDisabledEvent, removeEnabledElement);\r\n  annotationInterpolationEventDispatcher.disable();\r\n}\r\n\r\n/**\r\n * It adds an event listener to the event target (the cornerstoneTools object) for\r\n * the annotation selected and annotation modified events.\r\n */\r\nfunction _addCornerstoneToolsEventListeners() {\r\n  // Clear any listeners that may already be set\r\n  _removeCornerstoneToolsEventListeners();\r\n\r\n  /**\r\n   * Annotation\r\n   */\r\n  eventTarget.addEventListener(\r\n    TOOLS_EVENTS.ANNOTATION_COMPLETED,\r\n    annotationCompletedListener\r\n  );\r\n\r\n  eventTarget.addEventListener(\r\n    TOOLS_EVENTS.ANNOTATION_MODIFIED,\r\n    annotationModifiedListener\r\n  );\r\n\r\n  eventTarget.addEventListener(\r\n    TOOLS_EVENTS.ANNOTATION_VISIBILITY_CHANGE,\r\n    annotationVisibilityListener\r\n  );\r\n\r\n  eventTarget.addEventListener(\r\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\r\n    annotationSelectionListener\r\n  );\r\n\r\n  eventTarget.addEventListener(\r\n    TOOLS_EVENTS.ANNOTATION_REMOVED,\r\n    annotationRemovedListener\r\n  );\r\n\r\n  /**\r\n   * Segmentation\r\n   */\r\n  eventTarget.addEventListener(\r\n    TOOLS_EVENTS.SEGMENTATION_MODIFIED,\r\n    segmentationModifiedListener\r\n  );\r\n\r\n  eventTarget.addEventListener(\r\n    TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED,\r\n    segmentationDataModifiedEventListener\r\n  );\r\n  eventTarget.addEventListener(\r\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED,\r\n    segmentationRepresentationModifiedEventListener\r\n  );\r\n\r\n  eventTarget.addEventListener(\r\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_REMOVED,\r\n    segmentationRepresentationRemovedEventListener\r\n  );\r\n}\r\n\r\n/**\r\n * Remove the event listener for the the annotation selected and annotation modified events.\r\n */\r\nfunction _removeCornerstoneToolsEventListeners() {\r\n  /**\r\n   * Annotation\r\n   */\r\n  eventTarget.removeEventListener(\r\n    TOOLS_EVENTS.ANNOTATION_COMPLETED,\r\n    annotationCompletedListener\r\n  );\r\n\r\n  eventTarget.removeEventListener(\r\n    TOOLS_EVENTS.ANNOTATION_MODIFIED,\r\n    annotationModifiedListener\r\n  );\r\n\r\n  eventTarget.removeEventListener(\r\n    TOOLS_EVENTS.ANNOTATION_VISIBILITY_CHANGE,\r\n    annotationVisibilityListener\r\n  );\r\n\r\n  eventTarget.removeEventListener(\r\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\r\n    annotationSelectionListener\r\n  );\r\n\r\n  /**\r\n   * Segmentation\r\n   */\r\n\r\n  eventTarget.removeEventListener(\r\n    TOOLS_EVENTS.SEGMENTATION_MODIFIED,\r\n    segmentationModifiedListener\r\n  );\r\n\r\n  eventTarget.removeEventListener(\r\n    TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED,\r\n    segmentationDataModifiedEventListener\r\n  );\r\n  eventTarget.removeEventListener(\r\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED,\r\n    segmentationRepresentationModifiedEventListener\r\n  );\r\n\r\n  eventTarget.removeEventListener(\r\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_REMOVED,\r\n    segmentationRepresentationRemovedEventListener\r\n  );\r\n}\r\n\r\nexport default init;\r\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\r\nimport Events from '../../enums/Events';\r\nimport { getAnnotation } from './annotationState';\r\n\r\nexport type BaseEventDetail = {\r\n  viewportId: string;\r\n  renderingEngineId: string;\r\n};\r\n\r\n/**\r\n * An annotation group\r\n */\r\n\r\nexport default class AnnotationGroup {\r\n  private annotationUIDs = new Set<string>();\r\n  private _isVisible = true;\r\n\r\n  public visibleFilter: (uid: string) => boolean;\r\n\r\n  constructor() {\r\n    this.visibleFilter = this.unboundVisibleFilter.bind(this);\r\n  }\r\n\r\n  /**\r\n   * Returns true if other groups are free to hide this annotation.\r\n   * That is, if the annotation is not a member or is hidden.\r\n   */\r\n  protected unboundVisibleFilter(uid: string): boolean {\r\n    return !this._isVisible || !this.annotationUIDs.has(uid);\r\n  }\r\n\r\n  public has(uid: string): boolean {\r\n    return this.annotationUIDs.has(uid);\r\n  }\r\n  /**\r\n   * Sets whether annotations belonging to this group are visible or not.\r\n   * If there are multiple groups, then the set visible false should be called\r\n   * before before re-enabling the other groups with setVisible true.\r\n   */\r\n  public setVisible(\r\n    isVisible = true,\r\n    baseEvent: BaseEventDetail,\r\n    filter?: (annotationUID: string) => boolean\r\n  ) {\r\n    if (this._isVisible === isVisible) {\r\n      return;\r\n    }\r\n    this._isVisible = isVisible;\r\n    this.annotationUIDs.forEach((uid) => {\r\n      const annotation = getAnnotation(uid);\r\n      if (!annotation) {\r\n        this.annotationUIDs.delete(uid);\r\n        return;\r\n      }\r\n      if (annotation.isVisible === isVisible) {\r\n        return;\r\n      }\r\n      if (!isVisible && filter?.(uid) === false) {\r\n        return;\r\n      }\r\n      annotation.isVisible = isVisible;\r\n      const eventDetail = {\r\n        ...baseEvent,\r\n        annotation,\r\n      };\r\n      triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);\r\n    });\r\n  }\r\n\r\n  public get isVisible() {\r\n    return this._isVisible;\r\n  }\r\n\r\n  /** Finds the nearby/next annotation in the given direction */\r\n  public findNearby(uid: string, direction: 1) {\r\n    const uids = [...this.annotationUIDs];\r\n    if (uids.length === 0) {\r\n      return null;\r\n    }\r\n    if (!uid) {\r\n      return uids[direction === 1 ? 0 : uids.length - 1];\r\n    }\r\n    const index = uids.indexOf(uid);\r\n    if (\r\n      index === -1 ||\r\n      index + direction < 0 ||\r\n      index + direction >= uids.length\r\n    ) {\r\n      return null;\r\n    }\r\n    return uids[index + direction];\r\n  }\r\n\r\n  /**\r\n   * Adds the annotation to the group\r\n   * Does NOT change the visibility status of the annotation.\r\n   */\r\n  public add(...annotationUIDs: string[]) {\r\n    annotationUIDs.forEach((annotationUID) =>\r\n      this.annotationUIDs.add(annotationUID)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Removes the annotation from the group.\r\n   * Does not affect the visibility status of the annotation.\r\n   */\r\n  public remove(...annotationUIDs: string[]) {\r\n    annotationUIDs.forEach((annotationUID) =>\r\n      this.annotationUIDs.delete(annotationUID)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Removes everything from the group.\r\n   */\r\n  public clear() {\r\n    this.annotationUIDs.clear();\r\n  }\r\n}\r\n","import cloneDeep from 'lodash.clonedeep';\r\nimport {\r\n  Annotation,\r\n  Annotations,\r\n  AnnotationState,\r\n  GroupSpecificAnnotations,\r\n} from '../../types/AnnotationTypes';\r\n\r\nimport { AnnotationGroupSelector, IAnnotationManager } from '../../types';\r\n\r\nimport {\r\n  Enums,\r\n  eventTarget,\r\n  getEnabledElement,\r\n  Types,\r\n  utilities,\r\n} from '@cornerstonejs/core';\r\n\r\nimport { checkAndDefineIsLockedProperty } from './annotationLocking';\r\nimport { checkAndDefineIsVisibleProperty } from './annotationVisibility';\r\n\r\nimport {\r\n  checkAndDefineTextBoxProperty,\r\n  checkAndDefineCachedStatsProperty,\r\n} from './utilities/defineProperties';\r\n\r\n/**\r\n * This is the default annotation manager. It stores annotations by default\r\n * based on the FrameOfReferenceUID. However, it is possible to override the\r\n * getAnnotationStateKey function to store annotations based on any other\r\n * property of the element. When you write your custom annotation manager, you\r\n * can use the setAnnotationManager function to set your custom annotation.\r\n *\r\n * Note that this class is a singleton and should not be instantiated directly.\r\n * To get the stored annotations information you can use ToolState helpers.\r\n */\r\nclass FrameOfReferenceSpecificAnnotationManager implements IAnnotationManager {\r\n  private annotations: AnnotationState;\r\n  public readonly uid: string;\r\n\r\n  /**\r\n   * @param uid - The uid of the state manager. If omitted it is autogenerated.\r\n   */\r\n  constructor(uid?: string) {\r\n    if (!uid) {\r\n      uid = utilities.uuidv4();\r\n    }\r\n    this.annotations = {};\r\n    this.uid = uid;\r\n\r\n    // Listen to the IMAGE_VOLUME_MODIFIED event to invalidate data.\r\n    eventTarget.addEventListener(\r\n      Enums.Events.IMAGE_VOLUME_MODIFIED,\r\n      this._imageVolumeModifiedHandler\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Default annotation manager works with FrameOfReferenceUID as the key. The\r\n   * manager adds them under the FrameOfReferenceUID for the element being\r\n   * annotated.\r\n   *\r\n   * @param annotationGroupSelector - element or a string that is provided\r\n   * to the annotation manager to get the key.\r\n   * @returns - The annotation state key for the element.\r\n   */\r\n  getGroupKey = (annotationGroupSelector: AnnotationGroupSelector): string => {\r\n    if (typeof annotationGroupSelector === 'string') {\r\n      return annotationGroupSelector;\r\n    }\r\n\r\n    const element = annotationGroupSelector;\r\n    const enabledElement = getEnabledElement(element);\r\n\r\n    if (!enabledElement) {\r\n      throw new Error(\r\n        'Element not enabled, you must have an enabled element if you are not providing a FrameOfReferenceUID'\r\n      );\r\n    }\r\n\r\n    return enabledElement.FrameOfReferenceUID;\r\n  };\r\n\r\n  /**\r\n   * When a volume is modified we invalidate all of the `annotations` on the\r\n   * volume's `FrameOfReferenceUID`. This is mainly to update statistics calculations\r\n   * when an annotation is drawn whilst data is still loading.\r\n   *\r\n   * @param evt - The IMAGE_VOLUME_MODIFIED rendering event.\r\n   */\r\n  _imageVolumeModifiedHandler = (\r\n    evt: Types.EventTypes.ImageVolumeModifiedEvent\r\n  ) => {\r\n    const eventDetail = evt.detail;\r\n    const { FrameOfReferenceUID } = eventDetail;\r\n\r\n    const annotations = this.annotations;\r\n    const frameOfReferenceSpecificAnnotations =\r\n      annotations[FrameOfReferenceUID];\r\n\r\n    if (!frameOfReferenceSpecificAnnotations) {\r\n      return;\r\n    }\r\n\r\n    Object.keys(frameOfReferenceSpecificAnnotations).forEach((toolName) => {\r\n      const toolSpecificAnnotations =\r\n        frameOfReferenceSpecificAnnotations[toolName];\r\n\r\n      toolSpecificAnnotations.forEach((annotation) => {\r\n        const invalidated = annotation.invalidated;\r\n\r\n        if (invalidated !== undefined) {\r\n          annotation.invalidated = true;\r\n        }\r\n      });\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Returns all the available frameOfReferences inside the state manager\r\n   * @returns - All the added frames of references inside the manager\r\n   */\r\n  getFramesOfReference = (): Array<string> => {\r\n    return Object.keys(this.annotations);\r\n  };\r\n\r\n  /**\r\n   * Returns the annotations associated with the specified frameOfReference and tool, or\r\n   * all annotations for the group if the tool name is not provided.\r\n   *\r\n   * @param groupKey - The annotation group key to retrieve annotations for (in default manager it is FrameOfReferenceUID).\r\n   * @param toolName - Optional. The name of the tool to retrieve annotations for.\r\n   * @returns The annotations associated with the specified group (default FrameOfReferenceUID) and tool,\r\n   * or all annotations for the group (FrameOfReferenceUID) if the tool name is not provided.\r\n   * WARNING: The list returned here is internal tool data, not a copy, so do NOT modify it.\r\n   */\r\n  getAnnotations = (\r\n    groupKey: string,\r\n    toolName?: string\r\n  ): GroupSpecificAnnotations | Annotations => {\r\n    const annotations = this.annotations;\r\n\r\n    if (!annotations[groupKey]) {\r\n      return [];\r\n    }\r\n\r\n    if (toolName) {\r\n      return annotations[groupKey][toolName]\r\n        ? annotations[groupKey][toolName]\r\n        : [];\r\n    }\r\n\r\n    return annotations[groupKey];\r\n  };\r\n\r\n  /**\r\n   * Given the unique identified for the some `annotation`, returns the `annotation`\r\n   * from the `annotations`. Each `annotation` has a unique identifier.\r\n   *\r\n   * @param annotationUID - The unique identifier of the `annotation`.\r\n   * @returns The retrieved `annotation`.\r\n   */\r\n  getAnnotation = (annotationUID: string): Annotation | undefined => {\r\n    const annotations = this.annotations;\r\n\r\n    for (const frameOfReferenceUID in annotations) {\r\n      const frameOfReferenceAnnotations = annotations[frameOfReferenceUID];\r\n\r\n      for (const toolName in frameOfReferenceAnnotations) {\r\n        const toolSpecificAnnotations = frameOfReferenceAnnotations[toolName];\r\n\r\n        for (const annotation of toolSpecificAnnotations) {\r\n          if (annotationUID === annotation.annotationUID) {\r\n            return annotation;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * A function that returns the number of annotations for a given tool in the\r\n   * specific group (default FrameOfReferenceUID) IF no groupKey (FrameOfReferenceUID) is provided,\r\n   * it will return the number of annotations for the tool in all groups (FrameOfReferenceUIDs)\r\n   *\r\n   * @param groupKey - The annotation group key to retrieve annotations for (in default manager it is FrameOfReferenceUID).\r\n   * @param toolName - The name of the tool to retrieve data for.\r\n   *\r\n   * @returns The number of annotations for a given tool in the state\r\n   */\r\n  getNumberOfAnnotations = (groupKey: string, toolName?: string): number => {\r\n    const annotations = this.getAnnotations(groupKey, toolName);\r\n\r\n    if (!annotations.length) {\r\n      return 0;\r\n    }\r\n\r\n    if (toolName) {\r\n      return (annotations as Annotations).length;\r\n    }\r\n\r\n    let total = 0;\r\n\r\n    for (const toolName in annotations) {\r\n      total += annotations[toolName].length;\r\n    }\r\n\r\n    return total;\r\n  };\r\n\r\n  /**\r\n   * Adds an instance of `Annotation` to the `annotations`.\r\n   *\r\n   * @param annotation - The annotation to add.\r\n   * @param groupKey - The annotation group key to add the annotation to (in default manager it is FrameOfReferenceUID).\r\n   */\r\n  addAnnotation = (annotation: Annotation, groupKey?: string): void => {\r\n    const { metadata } = annotation;\r\n    const { FrameOfReferenceUID, toolName } = metadata;\r\n\r\n    groupKey = groupKey || FrameOfReferenceUID;\r\n\r\n    const annotations = this.annotations;\r\n\r\n    let frameOfReferenceSpecificAnnotations = annotations[groupKey];\r\n\r\n    if (!frameOfReferenceSpecificAnnotations) {\r\n      annotations[groupKey] = {};\r\n\r\n      frameOfReferenceSpecificAnnotations = annotations[groupKey];\r\n    }\r\n\r\n    let toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\r\n\r\n    if (!toolSpecificAnnotations) {\r\n      frameOfReferenceSpecificAnnotations[toolName] = [];\r\n\r\n      toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\r\n    }\r\n\r\n    toolSpecificAnnotations.push(annotation);\r\n    checkAndDefineIsLockedProperty(annotation);\r\n    checkAndDefineIsVisibleProperty(annotation);\r\n    checkAndDefineTextBoxProperty(annotation);\r\n    checkAndDefineCachedStatsProperty(annotation);\r\n  };\r\n\r\n  /**\r\n   * Given the unique identified for the some `annotation`, removes the `annotation`\r\n   * from the `annotations`.\r\n   *\r\n   * @param annotationUID - The unique identifier of the `annotation` to remove.\r\n   */\r\n  removeAnnotation = (annotationUID: string): void => {\r\n    const { annotations } = this;\r\n\r\n    for (const groupKey in annotations) {\r\n      const groupAnnotations = annotations[groupKey];\r\n\r\n      for (const toolName in groupAnnotations) {\r\n        const toolAnnotations = groupAnnotations[toolName];\r\n\r\n        const index = toolAnnotations.findIndex(\r\n          (annotation) => annotation.annotationUID === annotationUID\r\n        );\r\n\r\n        if (index !== -1) {\r\n          toolAnnotations.splice(index, 1);\r\n\r\n          if (toolAnnotations.length === 0) {\r\n            delete groupAnnotations[toolName];\r\n          }\r\n        }\r\n      }\r\n\r\n      if (Object.keys(groupAnnotations).length === 0) {\r\n        delete annotations[groupKey];\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Removes all annotations associated with the specified group (FrameOfReferenceUID) and tool, or\r\n   * all annotations for the group (FrameOfReferenceUID) if the tool name is not provided.\r\n   *\r\n   * @param groupKey - The group key to remove annotations for (in default manager it is FrameOfReferenceUID).\r\n   * @param toolName - Optional. The name of the tool to remove annotations for.\r\n   *\r\n   * @returns The removed annotations\r\n   */\r\n  removeAnnotations = (groupKey: string, toolName?: string): Annotations => {\r\n    const annotations = this.annotations;\r\n    const removedAnnotations = [];\r\n\r\n    if (!annotations[groupKey]) {\r\n      return removedAnnotations;\r\n    }\r\n\r\n    if (toolName) {\r\n      const annotationsForTool = annotations[groupKey][toolName];\r\n      for (const annotation of annotationsForTool) {\r\n        this.removeAnnotation(annotation.annotationUID);\r\n        removedAnnotations.push(annotation);\r\n      }\r\n    } else {\r\n      for (const toolName in annotations[groupKey]) {\r\n        const annotationsForTool = annotations[groupKey][toolName];\r\n        for (const annotation of annotationsForTool) {\r\n          this.removeAnnotation(annotation.annotationUID);\r\n          removedAnnotations.push(annotation);\r\n        }\r\n      }\r\n    }\r\n\r\n    return removedAnnotations;\r\n  };\r\n\r\n  /**\r\n   * Returns a section of the annotations. Useful for serialization.\r\n   * If both groupKey (default manager is FrameOfReferenceUID) and toolName are provided, returns the corresponding Annotations instance\r\n   * for that groupKey (FrameOfReferenceUID) and toolName.\r\n   * If only groupKey is provided, returns the corresponding FrameOfReferenceSpecificAnnotations instance\r\n   * for that groupKey.\r\n   * If neither groupKey nor toolName is provided, returns the entire AnnotationState object.\r\n   * @param groupKey - Optional. The group key (e.g. FrameOfReferenceUID) to retrieve annotations for.\r\n   * @param toolName - Optional. The name of the tool to retrieve annotations for.\r\n   * @returns A section of the annotations.\r\n   */\r\n  saveAnnotations = (\r\n    groupKey?: string,\r\n    toolName?: string\r\n  ): AnnotationState | GroupSpecificAnnotations | Annotations => {\r\n    const annotations = this.annotations;\r\n\r\n    if (groupKey && toolName) {\r\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\r\n\r\n      if (!frameOfReferenceSpecificAnnotations) {\r\n        return;\r\n      }\r\n\r\n      const toolSpecificAnnotations =\r\n        frameOfReferenceSpecificAnnotations[toolName];\r\n\r\n      return cloneDeep(toolSpecificAnnotations);\r\n    } else if (groupKey) {\r\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\r\n\r\n      return cloneDeep(frameOfReferenceSpecificAnnotations);\r\n    }\r\n\r\n    return cloneDeep(annotations);\r\n  };\r\n\r\n  /**\r\n   * Restores a section of the `annotations`. Useful for loading in serialized data.\r\n   *\r\n   * - If no arguments are given, the entire `AnnotationState` instance is restored.\r\n   * - If the `FrameOfReferenceUID` is given, the corresponding\r\n   * `FrameOfReferenceSpecificAnnotations` instance is restored.\r\n   * - If both the `FrameOfReferenceUID` and the `toolName` are are given, the\r\n   * corresponding `Annotations` instance is restored.\r\n   *\r\n   * @param groupKey - A filter string for restoring only the `annotations` of a specific frame of reference.\r\n   * @param toolName - A filter string for restoring `annotation` for a specific tool on a specific frame of reference.\r\n   */\r\n  restoreAnnotations = (\r\n    state: AnnotationState | GroupSpecificAnnotations | Annotations,\r\n    groupKey?: string,\r\n    toolName?: string\r\n  ): void => {\r\n    const annotations = this.annotations;\r\n\r\n    if (groupKey && toolName) {\r\n      // Set Annotations for FrameOfReferenceUID and toolName.\r\n\r\n      let frameOfReferenceSpecificAnnotations = annotations[groupKey];\r\n\r\n      if (!frameOfReferenceSpecificAnnotations) {\r\n        annotations[groupKey] = {};\r\n\r\n        frameOfReferenceSpecificAnnotations = annotations[groupKey];\r\n      }\r\n\r\n      frameOfReferenceSpecificAnnotations[toolName] = <Annotations>state;\r\n    } else if (groupKey) {\r\n      // Set FrameOfReferenceSpecificAnnotations for FrameOfReferenceUID.\r\n\r\n      annotations[groupKey] = <GroupSpecificAnnotations>state;\r\n    } else {\r\n      // Set entire annotations\r\n      this.annotations = <AnnotationState>cloneDeep(state);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * return all annotations as a single array\r\n   */\r\n  getAllAnnotations = (): Annotations => {\r\n    return Object.values(this.annotations)\r\n      .map((frameOfReferenceSpecificAnnotations) =>\r\n        Object.values(frameOfReferenceSpecificAnnotations)\r\n      )\r\n      .flat(2);\r\n  };\r\n\r\n  /**\r\n   * A function that returns the number of all annotations in the annotation state\r\n   *\r\n   * @returns The number of all annotations in the state\r\n   */\r\n  getNumberOfAllAnnotations = (): number => {\r\n    let count = 0;\r\n    const annotations = this.annotations;\r\n    for (const groupKey in annotations) {\r\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\r\n      for (const toolName in frameOfReferenceSpecificAnnotations) {\r\n        const toolSpecificAnnotations =\r\n          frameOfReferenceSpecificAnnotations[toolName];\r\n        count += toolSpecificAnnotations.length;\r\n      }\r\n    }\r\n    return count;\r\n  };\r\n\r\n  /**\r\n   * Removes all annotations in the annotation state.\r\n   *\r\n   * @returns The removed annotations\r\n   */\r\n  removeAllAnnotations = (): Annotations => {\r\n    const removedAnnotations = [];\r\n\r\n    for (const annotation of this.getAllAnnotations()) {\r\n      this.removeAnnotation(annotation.annotationUID);\r\n      removedAnnotations.push(annotation);\r\n    }\r\n\r\n    return removedAnnotations;\r\n  };\r\n}\r\n\r\nconst defaultFrameOfReferenceSpecificAnnotationManager =\r\n  new FrameOfReferenceSpecificAnnotationManager('DEFAULT');\r\n\r\nexport { defaultFrameOfReferenceSpecificAnnotationManager };\r\nexport default FrameOfReferenceSpecificAnnotationManager;\r\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\r\nimport { Events } from '../../enums';\r\nimport { Annotation } from '../../types';\r\nimport { AnnotationLockChangeEventDetail } from '../../types/EventTypes';\r\n\r\n/*\r\n * Constants\r\n */\r\nconst globalLockedAnnotationsSet: Set<Annotation> = new Set();\r\n\r\n/*\r\n * Interface (Public API)\r\n */\r\n\r\n/**\r\n * Set the \"Locked\" state of a given annotation instance.\r\n *\r\n * @triggers ANNOTATION_LOCK_CHANGE\r\n *\r\n * @param annotation - The annotation instance which will have\r\n * its locked state changed. An event will only be triggered if the locked state\r\n * of the given annotation instance changed.\r\n * @param locked - A boolean value indicating if the instance should\r\n * be locked (true) or not (false)\r\n */\r\nfunction setAnnotationLocked(annotation: Annotation, locked = true): void {\r\n  const detail = makeEventDetail();\r\n  if (annotation) {\r\n    if (locked) {\r\n      lock(annotation, globalLockedAnnotationsSet, detail);\r\n    } else {\r\n      unlock(annotation, globalLockedAnnotationsSet, detail);\r\n    }\r\n  }\r\n  publish(detail, globalLockedAnnotationsSet);\r\n}\r\n\r\n/**\r\n * Clears all the locked annotation\r\n *\r\n */\r\nfunction unlockAllAnnotations(): void {\r\n  const detail = makeEventDetail();\r\n  clearLockedAnnotationsSet(globalLockedAnnotationsSet, detail);\r\n  publish(detail, globalLockedAnnotationsSet);\r\n}\r\n\r\n/**\r\n * Returns an array of all the annotation that is currently locked\r\n * @returns An array of tool specific annotation objects.\r\n *\r\n */\r\nfunction getAnnotationsLocked(): Array<Annotation> {\r\n  return Array.from(globalLockedAnnotationsSet);\r\n}\r\n\r\n/**\r\n * Given a Annotation object, return true if it is locked.\r\n * @param annotation - Annotation\r\n * @returns A boolean value.\r\n */\r\nfunction isAnnotationLocked(annotation: Annotation): boolean {\r\n  return globalLockedAnnotationsSet.has(annotation);\r\n}\r\n\r\n/**\r\n * Get the number of locked annotation objects in the global set of locked annotation\r\n * objects.\r\n * @returns The number of locked annotation objects.\r\n *\r\n */\r\nfunction getAnnotationsLockedCount(): number {\r\n  return globalLockedAnnotationsSet.size;\r\n}\r\n\r\n/**\r\n * Properly initialize the isLocked on annotation, and set it as locked if\r\n * isLocked is true.\r\n * @param annotation - The annotation object to be checked.\r\n */\r\nfunction checkAndDefineIsLockedProperty(annotation: Annotation): void {\r\n  if (annotation) {\r\n    const isLocked = !!annotation.isLocked;\r\n    if (shouldDefineIsLockedProperty(annotation)) {\r\n      Object.defineProperty(annotation, 'isLocked', {\r\n        configurable: false,\r\n        enumerable: true,\r\n        set: setIsLocked,\r\n        get: getIsLocked,\r\n      });\r\n    }\r\n    setAnnotationLocked(annotation, isLocked);\r\n  }\r\n}\r\n\r\n/*\r\n * Private Helpers\r\n */\r\n\r\nfunction makeEventDetail(): AnnotationLockChangeEventDetail {\r\n  return Object.freeze({\r\n    added: [],\r\n    removed: [],\r\n    locked: [],\r\n  });\r\n}\r\n\r\nfunction lock(\r\n  annotation: Annotation,\r\n  lockedAnnotationsSet: Set<Annotation>,\r\n  detail: AnnotationLockChangeEventDetail\r\n): void {\r\n  if (!lockedAnnotationsSet.has(annotation)) {\r\n    lockedAnnotationsSet.add(annotation);\r\n    detail.added.push(annotation);\r\n  }\r\n}\r\n\r\nfunction unlock(\r\n  annotation: Annotation,\r\n  lockedAnnotationsSet: Set<Annotation>,\r\n  detail: AnnotationLockChangeEventDetail\r\n): void {\r\n  if (lockedAnnotationsSet.delete(annotation)) {\r\n    detail.removed.push(annotation);\r\n  }\r\n}\r\n\r\nfunction clearLockedAnnotationsSet(\r\n  lockedAnnotationsSet: Set<Annotation>,\r\n  detail: AnnotationLockChangeEventDetail\r\n): void {\r\n  lockedAnnotationsSet.forEach((annotation) => {\r\n    unlock(annotation, lockedAnnotationsSet, detail);\r\n  });\r\n}\r\n\r\nfunction publish(\r\n  detail: AnnotationLockChangeEventDetail,\r\n  lockedAnnotationsSet: Set<Annotation>\r\n) {\r\n  if (detail.added.length > 0 || detail.removed.length > 0) {\r\n    lockedAnnotationsSet.forEach((item) => void detail.locked.push(item));\r\n    triggerEvent(eventTarget, Events.ANNOTATION_LOCK_CHANGE, detail);\r\n  }\r\n}\r\n\r\nfunction shouldDefineIsLockedProperty(annotation: Annotation): boolean {\r\n  const descriptor = Object.getOwnPropertyDescriptor(annotation, 'isLocked');\r\n  if (descriptor) {\r\n    return (\r\n      descriptor.configurable &&\r\n      (descriptor.set !== setIsLocked || descriptor.get !== getIsLocked)\r\n    );\r\n  }\r\n  return Object.isExtensible(annotation);\r\n}\r\n\r\nfunction setIsLocked(locked: boolean) {\r\n  setAnnotationLocked(this as Annotation, locked);\r\n}\r\n\r\nfunction getIsLocked() {\r\n  return isAnnotationLocked(this as Annotation);\r\n}\r\n\r\n/*\r\n * Exports\r\n */\r\n\r\nexport {\r\n  setAnnotationLocked,\r\n  getAnnotationsLocked,\r\n  getAnnotationsLockedCount,\r\n  unlockAllAnnotations,\r\n  isAnnotationLocked,\r\n  checkAndDefineIsLockedProperty,\r\n};\r\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\r\nimport { Events } from '../../enums';\r\nimport { AnnotationSelectionChangeEventDetail } from '../../types/EventTypes';\r\nimport { getAnnotation } from './annotationState';\r\n\r\n/*\r\n * Constants\r\n */\r\n\r\nconst selectedAnnotationUIDs: Set<string> = new Set();\r\n\r\n/*\r\n * Interface (Public API)\r\n */\r\n\r\n/**\r\n * Set a given annotationUID as selected or deselected based on the provided\r\n * selected value.\r\n *\r\n * @param annotationUID - The annotation UID to be selected\r\n * @param selected - When true, the annotation is selected. When false, the annotation is deselected.\r\n * @param preserveSelected - When true, preserves existing\r\n *  selections (i.e., the given annotation is appended to the selection set).\r\n *  When false (the default behavior) the currently selected items are discarded\r\n *  (i.e., the given annotation instance replaces the currently selected ones).\r\n */\r\nfunction setAnnotationSelected(\r\n  annotationUID: string,\r\n  selected = true,\r\n  preserveSelected = false\r\n): void {\r\n  if (selected) {\r\n    selectAnnotation(annotationUID, preserveSelected);\r\n  } else {\r\n    deselectAnnotation(annotationUID);\r\n  }\r\n}\r\n\r\n/**\r\n * Set a given annotation as selected.\r\n *\r\n * @param annotationUID - The annotation UID to be selected\r\n * @param preserveSelected - When true, preserves existing\r\n *  selections (i.e., the given annotation is appended to the selection set).\r\n *  When false (the default behavior) the currently selected items are discarded\r\n *  (i.e., the given annotation instance replaces the currently selected ones).\r\n */\r\nfunction selectAnnotation(\r\n  annotationUID: string,\r\n  preserveSelected = false\r\n): void {\r\n  const detail = makeEventDetail();\r\n  if (!preserveSelected) {\r\n    clearSelectionSet(selectedAnnotationUIDs, detail);\r\n  }\r\n  if (annotationUID && !selectedAnnotationUIDs.has(annotationUID)) {\r\n    selectedAnnotationUIDs.add(annotationUID);\r\n    detail.added.push(annotationUID);\r\n  }\r\n  publish(detail, selectedAnnotationUIDs);\r\n}\r\n\r\n/**\r\n * Deselect one or all annotations.\r\n *\r\n * @param annotationUID - If an annotation is provided that instance will be removed from\r\n * the internal selection set. If none is given, ALL selections will be cleared.\r\n */\r\nfunction deselectAnnotation(annotationUID?: string): void {\r\n  const detail = makeEventDetail();\r\n  if (annotationUID) {\r\n    if (selectedAnnotationUIDs.delete(annotationUID)) {\r\n      detail.removed.push(annotationUID);\r\n    }\r\n  } else {\r\n    clearSelectionSet(selectedAnnotationUIDs, detail);\r\n  }\r\n  publish(detail, selectedAnnotationUIDs);\r\n}\r\n\r\n/**\r\n * Return an array of ALL the selected annotationUIDs\r\n * @returns An array of Annotation UIDs\r\n */\r\nfunction getAnnotationsSelected(): Array<string> {\r\n  return Array.from(selectedAnnotationUIDs);\r\n}\r\n\r\n/**\r\n * Given a tool name, return ALL the annotationUIDs for that tool that are selected\r\n * @param toolName - The name of the tool you want to get the selected annotation for\r\n * @returns An array of annotationUIDs\r\n */\r\nfunction getAnnotationsSelectedByToolName(toolName: string): Array<string> {\r\n  return getAnnotationsSelected().filter((annotationUID) => {\r\n    const annotation = getAnnotation(annotationUID);\r\n    return annotation?.metadata?.toolName === toolName;\r\n  });\r\n}\r\n\r\n/**\r\n * Given an annotationUID, return true if it is selected, false\r\n * otherwise.\r\n * @param annotationUID - Annotation UID\r\n * @returns A boolean value.\r\n */\r\nfunction isAnnotationSelected(annotationUID: string): boolean {\r\n  return selectedAnnotationUIDs.has(annotationUID);\r\n}\r\n\r\n/**\r\n * Return the number of the selected annotation\r\n * @returns The size of the selected annotation set\r\n */\r\nfunction getAnnotationsSelectedCount(): number {\r\n  return selectedAnnotationUIDs.size;\r\n}\r\n\r\n/*\r\n * Private Helpers\r\n */\r\n\r\nfunction makeEventDetail(): AnnotationSelectionChangeEventDetail {\r\n  return Object.freeze({\r\n    added: [],\r\n    removed: [],\r\n    selection: [],\r\n  });\r\n}\r\n\r\nfunction clearSelectionSet(\r\n  selectionSet: Set<string>,\r\n  detail: AnnotationSelectionChangeEventDetail\r\n): void {\r\n  selectionSet.forEach((value) => {\r\n    if (selectionSet.delete(value)) {\r\n      detail.removed.push(value);\r\n    }\r\n  });\r\n}\r\n\r\nfunction publish(\r\n  detail: AnnotationSelectionChangeEventDetail,\r\n  selectionSet: Set<string>\r\n) {\r\n  if (detail.added.length > 0 || detail.removed.length > 0) {\r\n    selectionSet.forEach((item) => void detail.selection.push(item));\r\n    triggerEvent(eventTarget, Events.ANNOTATION_SELECTION_CHANGE, detail);\r\n  }\r\n}\r\n\r\n/*\r\n * Exports\r\n */\r\n\r\nexport {\r\n  setAnnotationSelected,\r\n  getAnnotationsSelected,\r\n  getAnnotationsSelectedByToolName,\r\n  getAnnotationsSelectedCount,\r\n  deselectAnnotation,\r\n  isAnnotationSelected,\r\n};\r\n","import { utilities as csUtils } from '@cornerstonejs/core';\r\nimport { defaultFrameOfReferenceSpecificAnnotationManager } from './FrameOfReferenceSpecificAnnotationManager';\r\nimport { Annotations, Annotation } from '../../types/AnnotationTypes';\r\nimport { AnnotationGroupSelector } from '../../types';\r\n\r\nimport {\r\n  triggerAnnotationAddedForElement,\r\n  triggerAnnotationAddedForFOR,\r\n  triggerAnnotationRemoved,\r\n} from './helpers/state';\r\n\r\n// our default annotation manager\r\nlet defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\r\n\r\n/**\r\n * It returns the default annotations manager.\r\n * @returns the singleton default annotations manager.\r\n */\r\nfunction getAnnotationManager() {\r\n  return defaultManager;\r\n}\r\n\r\n/**\r\n * Set the annotation manager to be used for rendering, adding, removing, etc.\r\n * @param annotationManager - The annotation manager to be used\r\n */\r\nfunction setAnnotationManager(annotationManager) {\r\n  defaultManager = annotationManager;\r\n}\r\n\r\n// set back to default frameOfReferenceSpecificAnnotationManager\r\nfunction resetAnnotationManager() {\r\n  defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\r\n}\r\n\r\n/**\r\n * Returns the annotations for a given tool with the provided options that is\r\n * used to filter annotations based on the annotation manager.\r\n *\r\n * In our default implementation, the options are the element and/or the FrameOfReferenceUID.\r\n * Hence, the getAnnotations function will return the annotations for the given tool\r\n * that are associated with the FrameOfReferenceUID.\r\n *\r\n * @param toolName - The name of the tool.\r\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\r\n * to group annotations in the annotation manager.\r\n * @returns The annotations corresponding to the Frame of Reference and the toolName.\r\n */\r\nfunction getAnnotations(\r\n  toolName: string,\r\n  annotationGroupSelector: AnnotationGroupSelector\r\n): Annotations {\r\n  const manager = getAnnotationManager();\r\n  const groupKey = manager.getGroupKey(annotationGroupSelector);\r\n  return manager.getAnnotations(groupKey, toolName) as Annotations;\r\n}\r\n\r\nfunction getAllAnnotations(): Annotations {\r\n  const manager = getAnnotationManager();\r\n  return manager.getAllAnnotations();\r\n}\r\n\r\n/**\r\n * Removes the association between the annotation passed as parameter and its\r\n * parent in case it has one (eg: contour holes).\r\n * @param annotation - Annotation\r\n */\r\nfunction clearParentAnnotation(annotation: Annotation): void {\r\n  const { annotationUID: childUID, parentAnnotationUID } = annotation;\r\n\r\n  if (!parentAnnotationUID) {\r\n    return;\r\n  }\r\n\r\n  const parentAnnotation = getAnnotation(parentAnnotationUID);\r\n  const childUIDIndex = parentAnnotation.childAnnotationUIDs.indexOf(childUID);\r\n\r\n  parentAnnotation.childAnnotationUIDs.splice(childUIDIndex, 1);\r\n  annotation.parentAnnotationUID = undefined;\r\n}\r\n\r\n/**\r\n * Creates a parent/child association between annotations.\r\n * A annotation may have only one parent and multiple children (eg: a contour\r\n * may have multiple holes in it).\r\n * @param parentAnnotation - Parent annotation\r\n * @param childAnnotation - Child annotation\r\n */\r\nfunction addChildAnnotation(\r\n  parentAnnotation: Annotation,\r\n  childAnnotation: Annotation\r\n): void {\r\n  const { annotationUID: parentUID } = parentAnnotation;\r\n  const { annotationUID: childUID } = childAnnotation;\r\n\r\n  // Make sure it is not associated with any other tool\r\n  clearParentAnnotation(childAnnotation);\r\n\r\n  if (!parentAnnotation.childAnnotationUIDs) {\r\n    parentAnnotation.childAnnotationUIDs = [];\r\n  }\r\n\r\n  // Check if it is already a child\r\n  if (parentAnnotation.childAnnotationUIDs.includes(childUID)) {\r\n    return;\r\n  }\r\n\r\n  parentAnnotation.childAnnotationUIDs.push(childUID);\r\n  childAnnotation.parentAnnotationUID = parentUID;\r\n}\r\n\r\n/**\r\n * Returns the parent annotation of a given one since annotations can be\r\n * associated in a parent/child way (eg: polyline holes)\r\n * @param annotation - Annotation\r\n * @returns Parent annotation\r\n */\r\nfunction getParentAnnotation(annotation: Annotation) {\r\n  return annotation.parentAnnotationUID\r\n    ? getAnnotation(annotation.parentAnnotationUID)\r\n    : undefined;\r\n}\r\n\r\n/**\r\n * Returns all children annotation of a given one since annotations can be\r\n * associated in a parent/child way (eg: polyline holes)\r\n * @param annotation - Annotation\r\n * @returns Child annotations\r\n */\r\nfunction getChildAnnotations(annotation: Annotation) {\r\n  return (\r\n    annotation.childAnnotationUIDs?.map((childAnnotationUID) =>\r\n      getAnnotation(childAnnotationUID)\r\n    ) ?? []\r\n  );\r\n}\r\n\r\n/**\r\n * Add the annotation to the annotation manager along with the options that is\r\n * used to filter the annotation manager and the annotation group that\r\n * the annotation belongs to.\r\n *\r\n * As a result, our default implementation will add the annotation to the\r\n * default manager using the FrameOfReferenceUID as the group key.\r\n *\r\n * @param annotation - The annotation that is being added to the annotations manager.\r\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\r\n * to group annotations in the annotation manager.\r\n */\r\nfunction addAnnotation(\r\n  annotation: Annotation,\r\n  annotationGroupSelector: AnnotationGroupSelector\r\n): string {\r\n  if (!annotation.annotationUID) {\r\n    annotation.annotationUID = csUtils.uuidv4() as string;\r\n  }\r\n\r\n  const manager = getAnnotationManager();\r\n\r\n  // if the annotation manager selector is an element, trigger the\r\n  // annotation added event for that element.\r\n  if (annotationGroupSelector instanceof HTMLDivElement) {\r\n    const groupKey = manager.getGroupKey(annotationGroupSelector);\r\n    manager.addAnnotation(annotation, groupKey);\r\n    triggerAnnotationAddedForElement(annotation, annotationGroupSelector);\r\n  } else {\r\n    // if no element is provided, render all viewports that have the\r\n    // same frame of reference.\r\n    // Todo: we should do something else here for other types of annotation managers.\r\n    manager.addAnnotation(annotation);\r\n    triggerAnnotationAddedForFOR(annotation);\r\n  }\r\n\r\n  return annotation.annotationUID;\r\n}\r\n\r\n/**\r\n * Get the number of annotations for a given tool with the provided options that is\r\n * used to filter annotations based on the annotation manager.\r\n *\r\n * In our default implementation, the options are the element and/or the FrameOfReferenceUID.\r\n * Hence, the getNumberOfAnnotations function will return the number of annotations for the given tool\r\n * that are associated with the FrameOfReferenceUID.\r\n *\r\n * @param toolName - The name of the tool\r\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\r\n * to group annotations in the annotation manager.\r\n *\r\n */\r\nfunction getNumberOfAnnotations(\r\n  toolName: string,\r\n  annotationGroupSelector: AnnotationGroupSelector\r\n): number {\r\n  const manager = getAnnotationManager();\r\n  const groupKey = manager.getGroupKey(annotationGroupSelector);\r\n\r\n  return manager.getNumberOfAnnotations(groupKey, toolName);\r\n}\r\n\r\n/**\r\n * Remove the annotation by UID of the annotation.\r\n * @param annotationUID - The unique identifier for the annotation.\r\n */\r\nfunction removeAnnotation(annotationUID: string): void {\r\n  if (!annotationUID) {\r\n    return;\r\n  }\r\n  const manager = getAnnotationManager();\r\n  const annotation = manager.getAnnotation(annotationUID);\r\n\r\n  // no need to continue in case there is no annotation.\r\n  if (!annotation) {\r\n    return;\r\n  }\r\n\r\n  // Remove all child annotations first\r\n  annotation.childAnnotationUIDs?.forEach((childAnnotationUID) =>\r\n    removeAnnotation(childAnnotationUID)\r\n  );\r\n\r\n  manager.removeAnnotation(annotationUID);\r\n\r\n  triggerAnnotationRemoved({ annotation, annotationManagerUID: manager.uid });\r\n}\r\n\r\n/**\r\n * Get the Annotation object by its UID\r\n * @param annotationUID - The unique identifier of the annotation.\r\n */\r\nfunction getAnnotation(annotationUID: string): Annotation {\r\n  const manager = getAnnotationManager();\r\n  const annotation = manager.getAnnotation(annotationUID);\r\n\r\n  return annotation;\r\n}\r\n\r\n/**\r\n * It removes all annotations from the default annotation manager\r\n */\r\nfunction removeAllAnnotations(): void {\r\n  const manager = getAnnotationManager();\r\n  const removedAnnotations = manager.removeAllAnnotations();\r\n\r\n  for (const annotation of removedAnnotations) {\r\n    triggerAnnotationRemoved({\r\n      annotation,\r\n      annotationManagerUID: manager.uid,\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Removes all annotations associated with the specified group (FrameOfReferenceUID) and tool, or\r\n * all annotations for the group (FrameOfReferenceUID) if the tool name is not provided.\r\n * @param toolName - Optional. The name of the tool to remove annotations for.\r\n * @param annotationGroupSelector - The group (FrameOfReferenceUID) to remove annotations for.\r\n */\r\nfunction removeAnnotations(\r\n  toolName: string,\r\n  annotationGroupSelector: AnnotationGroupSelector\r\n): void {\r\n  const manager = getAnnotationManager();\r\n  const groupKey = manager.getGroupKey(annotationGroupSelector);\r\n  const removedAnnotations = manager.removeAnnotations(groupKey, toolName);\r\n\r\n  for (const annotation of removedAnnotations) {\r\n    triggerAnnotationRemoved({\r\n      annotation,\r\n      annotationManagerUID: manager.uid,\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Invalidate current and all parent annotations (eg: contour holes)\r\n * @param annotation - Annotation\r\n */\r\nfunction invalidateAnnotation(annotation: Annotation): void {\r\n  let currAnnotation = annotation;\r\n\r\n  while (currAnnotation) {\r\n    currAnnotation.invalidated = true;\r\n\r\n    currAnnotation = currAnnotation.parentAnnotationUID\r\n      ? getAnnotation(currAnnotation.parentAnnotationUID)\r\n      : undefined;\r\n  }\r\n}\r\n\r\nexport {\r\n  getAllAnnotations,\r\n  getAnnotations,\r\n  getParentAnnotation,\r\n  getChildAnnotations,\r\n  clearParentAnnotation,\r\n  addChildAnnotation,\r\n  getNumberOfAnnotations,\r\n  addAnnotation,\r\n  getAnnotation,\r\n  removeAnnotation,\r\n  removeAnnotations,\r\n  removeAllAnnotations,\r\n  // annotation manager\r\n  setAnnotationManager,\r\n  getAnnotationManager,\r\n  resetAnnotationManager,\r\n  invalidateAnnotation,\r\n};\r\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\r\nimport { getAnnotation } from './annotationState';\r\nimport { Events } from '../../enums';\r\nimport { Annotation } from '../../types';\r\nimport { AnnotationVisibilityChangeEventDetail } from '../../types/EventTypes';\r\nimport {\r\n  isAnnotationSelected,\r\n  deselectAnnotation,\r\n} from './annotationSelection';\r\nimport { BaseEventDetail } from './AnnotationGroup'\r\n\r\n/*\r\n * It stores all hidden annotation uids.\r\n */\r\nconst globalHiddenAnnotationUIDsSet: Set<string> = new Set();\r\n\r\n/*\r\n * Interface (Public API)\r\n */\r\n\r\n/**\r\n * Set the \"visible\" state of a given annotation instance.\r\n *\r\n * @event ANNOTATION_VISIBILITY_CHANGE\r\n *\r\n * @param annotationUID - The annotation uid which will have\r\n * its visible state changed. An event will only be triggered if the visible state\r\n * of the given annotation instance changed.\r\n * @param visible - A boolean value indicating if the instance should\r\n * be visible (true) or not (false)\r\n */\r\nfunction setAnnotationVisibility(annotationUID: string, visible = true): void {\r\n  const detail = makeEventDetail();\r\n  if (annotationUID) {\r\n    if (visible) {\r\n      show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\r\n    } else {\r\n      hide(annotationUID, globalHiddenAnnotationUIDsSet, detail);\r\n    }\r\n  }\r\n  publish(detail);\r\n}\r\n\r\n/**\r\n * Clears all the hidden annotations.\r\n *\r\n */\r\nfunction showAllAnnotations(): void {\r\n  const detail = makeEventDetail();\r\n  globalHiddenAnnotationUIDsSet.forEach((annotationUID) => {\r\n    show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\r\n  });\r\n  publish(detail);\r\n}\r\n\r\n/**\r\n * Given an annotation UID, return true if it is visible, false if hidden and undefined if does not exist.\r\n * @param annotationUID - The annotation uid to tell if is visible or not.\r\n * @returns A boolean value or value if does not exist.\r\n */\r\nfunction isAnnotationVisible(annotationUID: string): boolean | undefined {\r\n  const annotation = getAnnotation(annotationUID);\r\n\r\n  if (annotation) {\r\n    return !globalHiddenAnnotationUIDsSet.has(annotationUID);\r\n  }\r\n}\r\n/**\r\n * It decorates given annotation with isVisible property.\r\n * It properly initializes the isVisible on annotation(the property will be create if does not exist yet)\r\n *\r\n * @param annotation - The annotation object to be checked.\r\n */\r\nfunction checkAndDefineIsVisibleProperty(annotation: Annotation): void {\r\n  if (annotation) {\r\n    const isVisible = annotation.isVisible ?? true;\r\n    if (shouldDefineIsVisibleProperty(annotation)) {\r\n      Object.defineProperty(annotation, 'isVisible', {\r\n        configurable: false,\r\n        enumerable: true,\r\n        set: setIsVisible,\r\n        get: getIsVisible,\r\n      });\r\n    }\r\n    setAnnotationVisibility(annotation.annotationUID, isVisible);\r\n  }\r\n}\r\n\r\n/*\r\n * Private Helpers\r\n */\r\nfunction makeEventDetail(): AnnotationVisibilityChangeEventDetail {\r\n  return Object.freeze({\r\n    lastVisible: [],\r\n    lastHidden: [],\r\n    hidden: [],\r\n  });\r\n}\r\n\r\nfunction show(\r\n  annotationUID: string,\r\n  annotationUIDsSet: Set<string>,\r\n  detail: AnnotationVisibilityChangeEventDetail\r\n): void {\r\n  if (annotationUIDsSet.delete(annotationUID)) {\r\n    detail.lastVisible.push(annotationUID);\r\n  }\r\n}\r\n\r\nfunction hide(\r\n  annotationUID: string,\r\n  annotationUIDsSet: Set<string>,\r\n  detail: AnnotationVisibilityChangeEventDetail\r\n): void {\r\n  if (!annotationUIDsSet.has(annotationUID)) {\r\n    annotationUIDsSet.add(annotationUID);\r\n    if (isAnnotationSelected(annotationUID)) {\r\n      deselectAnnotation(annotationUID);\r\n    }\r\n    detail.lastHidden.push(annotationUID);\r\n  }\r\n}\r\n\r\nfunction publish(detail: AnnotationVisibilityChangeEventDetail) {\r\n  if (detail.lastHidden.length > 0 || detail.lastVisible.length > 0) {\r\n    globalHiddenAnnotationUIDsSet.forEach(\r\n      (item) => void detail.hidden.push(item)\r\n    );\r\n    triggerEvent(eventTarget, Events.ANNOTATION_VISIBILITY_CHANGE, detail);\r\n  }\r\n}\r\n\r\nfunction shouldDefineIsVisibleProperty(annotation: Annotation): boolean {\r\n  const descriptor = Object.getOwnPropertyDescriptor(annotation, 'isVisible');\r\n  if (descriptor) {\r\n    return (\r\n      descriptor.configurable &&\r\n      (descriptor.set !== setIsVisible || descriptor.get !== getIsVisible)\r\n    );\r\n  }\r\n  return Object.isExtensible(annotation);\r\n}\r\n\r\nfunction setIsVisible(hidden: boolean) {\r\n  setAnnotationVisibility((this as Annotation).annotationUID, hidden);\r\n}\r\n\r\nfunction getIsVisible() {\r\n  return isAnnotationVisible((this as Annotation).annotationUID);\r\n}\r\n\r\nexport {\r\n  setAnnotationVisibility,\r\n  showAllAnnotations,\r\n  isAnnotationVisible,\r\n  checkAndDefineIsVisibleProperty,\r\n};\r\n","import {\r\n  StyleConfig,\r\n  ToolStyleConfig,\r\n  StyleSpecifier,\r\n  AnnotationStyle,\r\n} from '../../../types/AnnotationStyle';\r\n\r\n/**\r\n * This class handles the configuration of the tool style. You can use it to set\r\n * the style of a tool at various levels (annotation, viewport, toolGroup, global).\r\n *\r\n * The hierarchy of the configuration is as follows (each level falls back to the\r\n * next level if not specified):\r\n *\r\n * 1) Annotation-level styles (with annotationUID)\r\n *     2) Viewport-level tool styles\r\n *         - Per-tool: Length on the viewport with viewportId\r\n *         - Global: All tools on the viewport with viewportId\r\n *             3) ToolGroup tool styles\r\n *                 - Per-tool: Angle on toolGroupId in all viewports of the toolGroup\r\n *                 - Global: All tools in the toolGroupId for all viewports\r\n *                     4) Default level:\r\n *                         - Per-tool: Length styles\r\n *                         - Global: Opinionated styles by CornerstoneJS\r\n */\r\nclass ToolStyle {\r\n  config: StyleConfig;\r\n\r\n  constructor() {\r\n    const defaultConfig = {\r\n      color: 'rgb(255, 255, 0)',\r\n      colorHighlighted: 'rgb(0, 255, 0)',\r\n      colorSelected: 'rgb(0, 220, 0)',\r\n      colorLocked: 'rgb(255, 255, 0)',\r\n      lineWidth: '1',\r\n      lineDash: '',\r\n      shadow: true,\r\n      textBoxVisibility: true,\r\n      textBoxFontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\r\n      textBoxFontSize: '14px',\r\n      textBoxColor: 'rgb(255, 255, 0)',\r\n      textBoxColorHighlighted: 'rgb(0, 255, 0)',\r\n      textBoxColorSelected: 'rgb(0, 255, 0)',\r\n      textBoxColorLocked: 'rgb(255, 255, 0)',\r\n      textBoxBackground: '',\r\n      textBoxLinkLineWidth: '1',\r\n      textBoxLinkLineDash: '2,3',\r\n      textBoxShadow: true,\r\n    };\r\n\r\n    this._initializeConfig(defaultConfig);\r\n  }\r\n\r\n  /**\r\n   * It returns the annotation-specific tool styles for the annotation with the given UID\r\n   * @param annotationUID - The unique identifier of the annotation.\r\n   * @returns The annotation tool styles for the annotation with the given UID.\r\n   */\r\n  getAnnotationToolStyles(annotationUID: string): AnnotationStyle {\r\n    return this.config.annotations && this.config.annotations[annotationUID];\r\n  }\r\n\r\n  /**\r\n   * It returns the styles for a given viewport. It includes tool-specific and\r\n   * global styles (all tools in the viewport)\r\n   * @param viewportId - The id of the viewport\r\n   * @returns The viewport tool styles for the given viewport id.\r\n   */\r\n  getViewportToolStyles(viewportId: string): ToolStyleConfig {\r\n    return this.config.viewports && this.config.viewports[viewportId];\r\n  }\r\n\r\n  /**\r\n   * It returns the tool style for the given toolGroup. It includes tool-specific and\r\n   * global styles (all tools in the toolGroup)\r\n   * @param toolGroupId - The id of the toolGroup.\r\n   * @returns The tool styles for the tool group with the given id.\r\n   */\r\n  getToolGroupToolStyles(toolGroupId: string): ToolStyleConfig {\r\n    return this.config.toolGroups && this.config.toolGroups[toolGroupId];\r\n  }\r\n\r\n  /**\r\n   * It returns the default tool styles from the config file. It includes tool-specific and\r\n   * global styles (all tools in all tooLGroups)\r\n   * @returns The default tool styles.\r\n   */\r\n  getDefaultToolStyles(): ToolStyleConfig {\r\n    return this.config.default;\r\n  }\r\n\r\n  /**\r\n   * It takes an annotationUID and a style object and sets the styles at\r\n   * the annotationLevel (highest priority in the hierarchy). The styles is an\r\n   * object with key value pairs.\r\n   * @param annotationUID - string - The unique identifier for the annotation.\r\n   * @param styles - ToolStyles\r\n   */\r\n  setAnnotationStyles(annotationUID: string, styles: AnnotationStyle) {\r\n    let annotationSpecificStyles = this.config.annotations;\r\n\r\n    if (!annotationSpecificStyles) {\r\n      this.config = {\r\n        ...this.config,\r\n        annotations: {},\r\n      };\r\n\r\n      annotationSpecificStyles = this.config.annotations;\r\n    }\r\n\r\n    annotationSpecificStyles[annotationUID] = styles;\r\n  }\r\n\r\n  /**\r\n   * It takes a viewportId and a ToolStyles object, and adds the ToolStyles object\r\n   * at the viewport level (second highest priority in the hierarchy after the annotation level).\r\n   * @param viewportId - The id of the viewport\r\n   * @param styles - style object including tool-specific and/or global styles (All tools in the viewport)\r\n   */\r\n  setViewportToolStyles(viewportId: string, styles: ToolStyleConfig) {\r\n    let viewportSpecificStyles = this.config.viewports;\r\n\r\n    if (!viewportSpecificStyles) {\r\n      this.config = {\r\n        ...this.config,\r\n        viewports: {},\r\n      };\r\n\r\n      viewportSpecificStyles = this.config.viewports;\r\n    }\r\n\r\n    viewportSpecificStyles[viewportId] = styles;\r\n  }\r\n\r\n  /**\r\n   * It takes a toolGroupId and a ToolStyles object, and it adds the ToolStyles object\r\n   * at the toolGroup level (third highest priority in the hierarchy after the viewport level).\r\n   * @param toolGroupId - The id of the toolGroup\r\n   * @param styles - style object including tool-specific (in all viewports of the toolGroup) and/or\r\n   * global styles (All tools in the toolGroup for all viewports)\r\n   */\r\n  setToolGroupToolStyles(toolGroupId: string, styles: ToolStyleConfig) {\r\n    let toolGroupSpecificStyles = this.config.toolGroups;\r\n\r\n    if (!toolGroupSpecificStyles) {\r\n      this.config = {\r\n        ...this.config,\r\n        toolGroups: {},\r\n      };\r\n\r\n      toolGroupSpecificStyles = this.config.toolGroups;\r\n    }\r\n\r\n    toolGroupSpecificStyles[toolGroupId] = styles;\r\n  }\r\n\r\n  /**\r\n   * Sets the default tool styles for the editor. It overrides the default styles for all tools.\r\n   * @param styles - style object including tool-specific (a tool in all toolGroups) and/or\r\n   * global styles (All tools in all tooLGroups)\r\n   */\r\n  setDefaultToolStyles(styles: ToolStyleConfig) {\r\n    this.config.default = styles;\r\n  }\r\n\r\n  /**\r\n   * It returns the value for a given style key, based on the provided specifications.\r\n   * It starts by looking at the annotation-specific styles, then at the viewport-specific styles,\r\n   * then at the toolGroup-specific styles, and finally at the default styles.\r\n   * @param styleKey - The key of the style.\r\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\r\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\r\n   * met\r\n   * @returns The value for the given style key.\r\n   */\r\n  getStyleProperty(toolStyle: string, specifications: StyleSpecifier) {\r\n    const { annotationUID, viewportId, toolGroupId, toolName } = specifications;\r\n\r\n    return this._getToolStyle(\r\n      toolStyle,\r\n      annotationUID,\r\n      viewportId,\r\n      toolGroupId,\r\n      toolName\r\n    );\r\n  }\r\n\r\n  private _getToolStyle(\r\n    property: string,\r\n    annotationUID: string,\r\n    viewportId: string,\r\n    toolGroupId: string,\r\n    toolName: string\r\n  ) {\r\n    if (annotationUID) {\r\n      const annotationToolStyles = this.getAnnotationToolStyles(annotationUID);\r\n\r\n      if (annotationToolStyles) {\r\n        // check first in the toolSpecific styles\r\n        if (annotationToolStyles[property] !== undefined) {\r\n          return annotationToolStyles[property];\r\n        }\r\n      }\r\n    }\r\n\r\n    if (viewportId) {\r\n      const viewportToolStyles = this.getViewportToolStyles(viewportId);\r\n\r\n      if (viewportToolStyles) {\r\n        // check if we have the viewportId specific style\r\n        // check first in the toolSpecific styles\r\n        if (\r\n          viewportToolStyles[toolName] &&\r\n          viewportToolStyles[toolName][property] !== undefined\r\n        ) {\r\n          return viewportToolStyles[toolName][property];\r\n        }\r\n\r\n        // check if we have the style in the viewport specific global viewportSpecificStyles\r\n        if (\r\n          viewportToolStyles.global &&\r\n          viewportToolStyles.global[property] !== undefined\r\n        ) {\r\n          return viewportToolStyles.global[property];\r\n        }\r\n      }\r\n    }\r\n\r\n    if (toolGroupId) {\r\n      const toolGroupToolStyles = this.getToolGroupToolStyles(toolGroupId);\r\n\r\n      if (toolGroupToolStyles) {\r\n        // check first in the toolSpecific styles\r\n        if (\r\n          toolGroupToolStyles[toolName] &&\r\n          toolGroupToolStyles[toolName][property] !== undefined\r\n        ) {\r\n          return toolGroupToolStyles[toolName][property];\r\n        }\r\n\r\n        // check if we have the style in the toolGroup specific global styles\r\n        if (\r\n          toolGroupToolStyles.global &&\r\n          toolGroupToolStyles.global[property] !== undefined\r\n        ) {\r\n          return toolGroupToolStyles.global[property];\r\n        }\r\n      }\r\n    }\r\n\r\n    const globalStyles = this.getDefaultToolStyles();\r\n\r\n    if (\r\n      globalStyles[toolName] &&\r\n      globalStyles[toolName][property] !== undefined\r\n    ) {\r\n      return globalStyles[toolName][property];\r\n    }\r\n\r\n    if (globalStyles.global && globalStyles.global[property] !== undefined) {\r\n      return globalStyles.global[property];\r\n    }\r\n  }\r\n\r\n  private _initializeConfig(config) {\r\n    const toolStyles = {};\r\n    for (const name in config) {\r\n      toolStyles[name] = config[name];\r\n    }\r\n\r\n    this.config = {\r\n      default: {\r\n        global: toolStyles as AnnotationStyle,\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\nconst toolStyle = new ToolStyle();\r\n\r\nexport default toolStyle;\r\n","import { ToolModes, AnnotationStyleStates } from '../../../enums';\r\nimport { getStyleProperty } from './helpers';\r\nimport { StyleSpecifier } from '../../../types/AnnotationStyle';\r\n\r\n/**\r\n * getFont - Returns a font string of the form \"{fontSize}px fontName\" used by `canvas`.\r\n * @param styleSpecifier - An object containing the specifications such as viewportId,\r\n * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\r\n * met (hierarchy is checked from most specific to least specific which is\r\n * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\r\n * @param state - An optional state to determine the final property name\r\n * @param mode - An optional mode to determine the final property name\r\n * @returns The font string.\r\n */\r\nfunction getFont(\r\n  styleSpecifier: StyleSpecifier,\r\n  state?: AnnotationStyleStates,\r\n  mode?: ToolModes\r\n): string {\r\n  const fontSize = getStyleProperty(\r\n    'textBoxFontSize',\r\n    styleSpecifier,\r\n    state,\r\n    mode\r\n  );\r\n  const fontFamily = getStyleProperty(\r\n    'textBoxFontFamily',\r\n    styleSpecifier,\r\n    state,\r\n    mode\r\n  );\r\n\r\n  return `${fontSize}px ${fontFamily}`;\r\n}\r\n\r\nexport default getFont;\r\n","import { Annotation } from '../../../types';\r\nimport { isAnnotationLocked } from '../annotationLocking';\r\nimport { isAnnotationSelected } from '../annotationSelection';\r\nimport { AnnotationStyleStates } from '../../../enums';\r\n\r\n/**\r\n * Given a Annotation object, return the annotationStyle State that it\r\n * should be in based on its data.\r\n * The ordering of states is:\r\n *   * Highlighted\r\n *   * Selected\r\n *   * Locked\r\n *   * Autogenerated\r\n *   * Default\r\n * So the first one that applies will be returned.\r\n * For the autogenerated state, it depends on the autoGenerated flag on the\r\n * annotation, so once that is gone/false, the annotation will go to default.\r\n *\r\n * @param annotation - The annotation that we want to style.\r\n * @returns The state of the annotation whether it is Default, Highlighted, Locked, Selected, or AutoGenerated.\r\n */\r\nfunction getState(annotation?: Annotation): AnnotationStyleStates {\r\n  if (annotation) {\r\n    if (annotation.data && annotation.highlighted) {\r\n      return AnnotationStyleStates.Highlighted;\r\n    }\r\n    if (isAnnotationSelected(annotation.annotationUID)) {\r\n      return AnnotationStyleStates.Selected;\r\n    }\r\n\r\n    // Todo: make annotation lock api not to rely on the annotation itself\r\n    if (isAnnotationLocked(annotation)) {\r\n      return AnnotationStyleStates.Locked;\r\n    }\r\n\r\n    if (annotation.data && annotation.autoGenerated) {\r\n      return AnnotationStyleStates.AutoGenerated;\r\n    }\r\n  }\r\n\r\n  return AnnotationStyleStates.Default;\r\n}\r\n\r\nexport default getState;\r\n","import { StyleSpecifier } from '../../../types/AnnotationStyle';\r\nimport { ToolModes, AnnotationStyleStates } from '../../../enums';\r\nimport toolStyle from './ToolStyle';\r\n\r\n/**\r\n * Build a list of hierarchal property names in ascending order of priority\r\n * @param property - The base property name -- e.g., 'color'\r\n * @param state - An optional state to determine the final property name\r\n * @param mode - An optional mode to determine the final property name\r\n * @returns A list of property names\r\n */\r\nfunction getHierarchalPropertyStyles(\r\n  property: string,\r\n  state?: AnnotationStyleStates,\r\n  mode?: ToolModes\r\n): string[] {\r\n  const list = [`${property}`];\r\n  if (state) {\r\n    list.push(`${list[0]}${state}`);\r\n  }\r\n  if (mode) {\r\n    list.push(`${list[list.length - 1]}${mode}`);\r\n  }\r\n  return list;\r\n}\r\n\r\n/**\r\n * Get the value of a style property from the ToolStyle config\r\n * @param property - The name of the property to get.\r\n * @param styleSpecifier - An object containing the specifications such as viewportId,\r\n * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\r\n * met (hierarchy is checked from most specific to least specific which is\r\n * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\r\n * @param state - The state of the tool (Default, Locked etc.)\r\n * @param mode - The current tool mode. (Active, Passive etc.)\r\n * @returns The value of the property.\r\n */\r\nfunction getStyleProperty(\r\n  property: string,\r\n  styleSpecifier: StyleSpecifier,\r\n  state?: AnnotationStyleStates,\r\n  mode?: ToolModes\r\n): string {\r\n  // Hierarchal property styles is a list of property names with priority in ascending\r\n  // order like: ['color', 'colorSelected', 'colorSelectedActive'], if in the toolStyle\r\n  // config, the `colorSelectedActive` property is defined, it will be used, otherwise\r\n  // the `colorSelected` property will be used, and if that is not defined, the `color`\r\n  // property will be used. This is done to ensure that the most specific property is used.\r\n  // Thus, we attempt resolving property names in reverse order\r\n  const alternatives = getHierarchalPropertyStyles(property, state, mode);\r\n  for (let i = alternatives.length - 1; i >= 0; --i) {\r\n    const style = toolStyle.getStyleProperty(alternatives[i], styleSpecifier);\r\n    if (style !== undefined) {\r\n      return style;\r\n    }\r\n  }\r\n}\r\n\r\nexport { getStyleProperty };\r\n","import {\r\n  getEnabledElement,\r\n  triggerEvent,\r\n  eventTarget,\r\n  getEnabledElementByIds,\r\n} from '@cornerstonejs/core';\r\nimport { Events, ChangeTypes } from '../../../enums';\r\nimport { Annotation } from '../../../types/AnnotationTypes';\r\nimport { getToolGroupsWithToolName } from '../../../store/ToolGroupManager';\r\nimport {\r\n  AnnotationAddedEventDetail,\r\n  AnnotationModifiedEventDetail,\r\n  AnnotationCompletedEventDetail,\r\n  ContourAnnotationCompletedEventDetail,\r\n  AnnotationRemovedEventDetail,\r\n} from '../../../types/EventTypes';\r\n\r\n/**\r\n * It triggers an event for the element when an annotation is added\r\n * @param annotation - Annotation - The annotation that was added.\r\n * @param element - The element that the annotation was added to.\r\n */\r\nfunction triggerAnnotationAddedForElement(\r\n  annotation: Annotation,\r\n  element: HTMLDivElement\r\n) {\r\n  const enabledElement = getEnabledElement(element);\r\n  const { renderingEngine, viewportId } = enabledElement;\r\n\r\n  const eventType = Events.ANNOTATION_ADDED;\r\n\r\n  const eventDetail: AnnotationAddedEventDetail = {\r\n    annotation,\r\n    viewportId,\r\n    renderingEngineId: renderingEngine.id,\r\n  };\r\n\r\n  triggerEvent(eventTarget, eventType, eventDetail);\r\n}\r\n\r\n/**\r\n * If the annotation has a FrameOfReferenceUID, it triggers the ANNOTATION_ADDED\r\n * event for all the viewports that has the same FrameOfReferenceUID.\r\n * @param annotation -  Annotation - The annotation that was added\r\n */\r\nfunction triggerAnnotationAddedForFOR(annotation: Annotation) {\r\n  const { toolName } = annotation.metadata;\r\n\r\n  const toolGroups = getToolGroupsWithToolName(toolName);\r\n  if (!toolGroups.length) {\r\n    return;\r\n  }\r\n\r\n  // Find the viewports in the toolGroups who has the same FrameOfReferenceUID\r\n  const viewportsToRender = [];\r\n  toolGroups.forEach((toolGroup) => {\r\n    toolGroup.viewportsInfo.forEach((viewportInfo) => {\r\n      const { renderingEngineId, viewportId } = viewportInfo;\r\n      const { FrameOfReferenceUID } = getEnabledElementByIds(\r\n        viewportId,\r\n        renderingEngineId\r\n      );\r\n\r\n      if (annotation.metadata.FrameOfReferenceUID === FrameOfReferenceUID) {\r\n        viewportsToRender.push(viewportInfo);\r\n      }\r\n    });\r\n  });\r\n\r\n  const eventType = Events.ANNOTATION_ADDED;\r\n  const eventDetail: AnnotationAddedEventDetail = { annotation };\r\n\r\n  if (!viewportsToRender.length) {\r\n    triggerEvent(eventTarget, eventType, eventDetail);\r\n    return;\r\n  }\r\n\r\n  viewportsToRender.forEach(({ renderingEngineId, viewportId }) => {\r\n    eventDetail.viewportId = viewportId;\r\n    eventDetail.renderingEngineId = renderingEngineId;\r\n    triggerEvent(eventTarget, eventType, eventDetail);\r\n  });\r\n}\r\n\r\n/**\r\n * Triggers an annotation removed event.\r\n * @param eventDetail - Event detail\r\n */\r\nfunction triggerAnnotationRemoved(\r\n  eventDetail: AnnotationRemovedEventDetail\r\n): void {\r\n  const eventType = Events.ANNOTATION_REMOVED;\r\n  triggerEvent(eventTarget, eventType, eventDetail);\r\n}\r\n\r\n/**\r\n * Triggers an annotation modified event.\r\n */\r\nfunction triggerAnnotationModified(\r\n  annotation: Annotation,\r\n  element: HTMLDivElement,\r\n  changeType = ChangeTypes.HandlesUpdated\r\n): void {\r\n  const enabledElement = getEnabledElement(element);\r\n  const { viewportId, renderingEngineId } = enabledElement;\r\n  const eventType = Events.ANNOTATION_MODIFIED;\r\n  const eventDetail: AnnotationModifiedEventDetail = {\r\n    annotation,\r\n    viewportId,\r\n    renderingEngineId,\r\n    changeType,\r\n  };\r\n\r\n  triggerEvent(eventTarget, eventType, eventDetail);\r\n}\r\n\r\n/**\r\n * Triggers an annotation completed event.\r\n */\r\nfunction triggerAnnotationCompleted(annotation: Annotation): void {\r\n  const eventDetail: AnnotationCompletedEventDetail = {\r\n    annotation,\r\n  };\r\n\r\n  _triggerAnnotationCompleted(eventDetail);\r\n}\r\n\r\n/**\r\n * Triggers an annotation completed event for contours (same annotation completed\r\n * event but with more specific details).\r\n */\r\nfunction triggerContourAnnotationCompleted(\r\n  annotation: Annotation,\r\n  contourHoleProcessingEnabled = false\r\n): void {\r\n  const eventDetail: ContourAnnotationCompletedEventDetail = {\r\n    annotation,\r\n    contourHoleProcessingEnabled,\r\n  };\r\n\r\n  _triggerAnnotationCompleted(eventDetail);\r\n}\r\n\r\n/**\r\n * Triggers an annotation completed event for the `detail` provided\r\n * @param eventDetail - Event detail\r\n */\r\nfunction _triggerAnnotationCompleted(\r\n  eventDetail: AnnotationCompletedEventDetail\r\n) {\r\n  const eventType = Events.ANNOTATION_COMPLETED;\r\n  triggerEvent(eventTarget, eventType, eventDetail);\r\n}\r\n\r\nexport {\r\n  triggerAnnotationAddedForElement,\r\n  triggerAnnotationAddedForFOR,\r\n  triggerAnnotationRemoved,\r\n  triggerAnnotationModified,\r\n  triggerAnnotationCompleted,\r\n  triggerContourAnnotationCompleted,\r\n};\r\n","import { ToolGroupSpecificRepresentation } from '../../types/SegmentationStateTypes';\r\nimport {\r\n  getDefaultSegmentationStateManager,\r\n  getSegmentation,\r\n} from './segmentationState';\r\nimport { triggerSegmentationRepresentationModified } from './triggerSegmentationEvents';\r\n\r\n/**\r\n * Get the active segmentation representation for the tool group with\r\n * the given toolGroupId.\r\n * @param toolGroupId - The Id of the tool group\r\n * @returns The active segmentation representation for the tool group.\r\n */\r\nfunction getActiveSegmentationRepresentation(\r\n  toolGroupId: string\r\n): ToolGroupSpecificRepresentation {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n\r\n  const toolGroupSegmentationRepresentations =\r\n    segmentationStateManager.getSegmentationRepresentations(toolGroupId);\r\n\r\n  if (!toolGroupSegmentationRepresentations) {\r\n    return;\r\n  }\r\n\r\n  const activeRepresentation = toolGroupSegmentationRepresentations.find(\r\n    (representation) => representation.active\r\n  );\r\n\r\n  return activeRepresentation;\r\n}\r\n\r\n/**\r\n * Retrieves the active segmentation for a given tool group.\r\n * @param toolGroupId - The ID of the tool group.\r\n * @returns The active segmentation Id, or undefined if no active segmentation is found.\r\n */\r\nfunction getActiveSegmentation(toolGroupId: string) {\r\n  const activeRepresentation = getActiveSegmentationRepresentation(toolGroupId);\r\n\r\n  if (!activeRepresentation) {\r\n    return;\r\n  }\r\n\r\n  const activeSegmentation = getSegmentation(\r\n    activeRepresentation.segmentationId\r\n  );\r\n\r\n  return activeSegmentation;\r\n}\r\n\r\n/**\r\n * Set the active segmentation for the given tool group for all its viewports\r\n *\r\n * @param toolGroupId - The Id of the tool group to set the active\r\n * segmentation for.\r\n * @param segmentationRepresentationUID - The id of the segmentation representation to set as\r\n * active.\r\n */\r\nfunction setActiveSegmentationRepresentation(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string\r\n): void {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n\r\n  segmentationStateManager.setActiveSegmentationRepresentation(\r\n    toolGroupId,\r\n    segmentationRepresentationUID\r\n  );\r\n\r\n  triggerSegmentationRepresentationModified(\r\n    toolGroupId,\r\n    segmentationRepresentationUID\r\n  );\r\n}\r\n\r\nexport {\r\n  // get\r\n  getActiveSegmentationRepresentation,\r\n  getActiveSegmentation,\r\n  // set\r\n  setActiveSegmentationRepresentation,\r\n};\r\n","import * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\r\nimport { getSegmentationRepresentations } from '../../../stateManagement/segmentation/segmentationState';\r\nimport { ToolGroupSpecificRepresentation } from '../../../types/SegmentationStateTypes';\r\nimport { getUniqueSegmentIndices } from '../../../utilities/segmentation';\r\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\r\n\r\n/**\r\n * Set the visibility of a segmentation representation for a given tool group. It fires\r\n * a SEGMENTATION_REPRESENTATION_MODIFIED event. Visibility true will show all segments\r\n * and visibility false will hide all segments\"\r\n *\r\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\r\n * @param toolGroupId - The Id of the tool group that contains the segmentation.\r\n * @param segmentationRepresentationUID - The id of the segmentation representation to modify its visibility.\r\n * @param visibility - boolean\r\n */\r\nfunction setSegmentationVisibility(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string,\r\n  visibility: boolean\r\n): void {\r\n  const toolGroupSegmentationRepresentations =\r\n    getSegmentationRepresentations(toolGroupId);\r\n\r\n  if (!toolGroupSegmentationRepresentations) {\r\n    return;\r\n  }\r\n\r\n  const representation = toolGroupSegmentationRepresentations.find(\r\n    (representation: ToolGroupSpecificRepresentation) =>\r\n      representation.segmentationRepresentationUID ===\r\n      segmentationRepresentationUID\r\n  );\r\n\r\n  if (!representation) {\r\n    return;\r\n  }\r\n\r\n  const { segmentsHidden, segmentationId } = representation;\r\n\r\n  const indices = getUniqueSegmentIndices(segmentationId);\r\n\r\n  // if visibility is set to be true, we need to remove all the segments\r\n  // from the segmentsHidden set, otherwise we need to add all the segments\r\n  // to the segmentsHidden set\r\n  if (visibility) {\r\n    segmentsHidden.clear();\r\n  } else {\r\n    indices.forEach((index) => {\r\n      segmentsHidden.add(index);\r\n    });\r\n  }\r\n\r\n  triggerSegmentationRepresentationModified(\r\n    toolGroupId,\r\n    representation.segmentationRepresentationUID\r\n  );\r\n}\r\n\r\n/**\r\n * Get the visibility of a segmentation data for a given tool group.\r\n *\r\n * @param toolGroupId - The Id of the tool group that the segmentation\r\n * data belongs to.\r\n * @param segmentationRepresentationUID - The id of the segmentation data to get\r\n * @returns A boolean value that indicates whether the segmentation data is visible or\r\n * not on the toolGroup\r\n */\r\nfunction getSegmentationVisibility(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string\r\n): boolean | undefined {\r\n  const toolGroupSegmentationRepresentations =\r\n    getSegmentationRepresentations(toolGroupId);\r\n\r\n  const representation = toolGroupSegmentationRepresentations.find(\r\n    (representation: ToolGroupSpecificRepresentation) =>\r\n      representation.segmentationRepresentationUID ===\r\n      segmentationRepresentationUID\r\n  );\r\n\r\n  if (!representation) {\r\n    return;\r\n  }\r\n\r\n  const { segmentsHidden, segmentationId } = representation;\r\n  const indices = getUniqueSegmentIndices(segmentationId);\r\n\r\n  // Create a set that contains all segments indices\r\n  const indicesSet = new Set(indices);\r\n\r\n  // Remove a indices that are hidden\r\n  segmentsHidden.forEach((segmentIndex) => indicesSet.delete(segmentIndex));\r\n\r\n  // Check if there is at least one segment visible\r\n  return !!indicesSet.size;\r\n}\r\n\r\n/**\r\n * Set the visibility of the given segment indices to the given visibility. This\r\n * is a helper to set the visibility of multiple segments at once and reduces\r\n * the number of events fired.\r\n *\r\n * @param toolGroupId -  The tool group id of the segmentation representation.\r\n * @param segmentationRepresentationUID -  The UID of the segmentation\r\n * representation.\r\n * @param segmentIndices -  The indices of the segments to be hidden/shown.\r\n * @param visibility -  The visibility to set the segments to.\r\n *\r\n */\r\nfunction setSegmentsVisibility(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string,\r\n  segmentIndices: number[],\r\n  visibility: boolean\r\n): void {\r\n  const segRepresentation =\r\n    SegmentationState.getSegmentationRepresentationByUID(\r\n      toolGroupId,\r\n      segmentationRepresentationUID\r\n    );\r\n\r\n  if (!segRepresentation) {\r\n    return;\r\n  }\r\n\r\n  segmentIndices.forEach((segmentIndex) => {\r\n    visibility\r\n      ? segRepresentation.segmentsHidden.delete(segmentIndex)\r\n      : segRepresentation.segmentsHidden.add(segmentIndex);\r\n  });\r\n\r\n  triggerSegmentationRepresentationModified(\r\n    toolGroupId,\r\n    segmentationRepresentationUID\r\n  );\r\n}\r\n\r\n/**\r\n * @param toolGroupId - The Id of the tool group that contains the segmentation\r\n * @param segmentationRepresentationUID - The id of the segmentation representation that contains the segment\r\n * @param segmentIndex - Index of the segment that will be updated\r\n * @param visibility - True to show the segment or false to hide it\r\n * @returns True if the segment is visible or false otherwise\r\n */\r\nfunction setSegmentVisibility(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string,\r\n  segmentIndex: number,\r\n  visibility: boolean\r\n): void {\r\n  const segRepresentation =\r\n    SegmentationState.getSegmentationRepresentationByUID(\r\n      toolGroupId,\r\n      segmentationRepresentationUID\r\n    );\r\n\r\n  if (!segRepresentation) {\r\n    return;\r\n  }\r\n\r\n  visibility\r\n    ? segRepresentation.segmentsHidden.delete(segmentIndex)\r\n    : segRepresentation.segmentsHidden.add(segmentIndex);\r\n\r\n  triggerSegmentationRepresentationModified(\r\n    toolGroupId,\r\n    segmentationRepresentationUID\r\n  );\r\n}\r\n\r\n/**\r\n * @param toolGroupId - The Id of the tool group that contains the segmentation.\r\n * @param segmentationRepresentationUID - The id of the segmentation representation to modify its visibility.\r\n * @param segmentIndex - Index of the segment\r\n * @returns True if the segment is visible or false otherwise\r\n */\r\nfunction getSegmentVisibility(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string,\r\n  segmentIndex: number\r\n): boolean {\r\n  const segRepresentation =\r\n    SegmentationState.getSegmentationRepresentationByUID(\r\n      toolGroupId,\r\n      segmentationRepresentationUID\r\n    );\r\n\r\n  if (!segRepresentation) {\r\n    return false;\r\n  }\r\n\r\n  return !segRepresentation.segmentsHidden.has(segmentIndex);\r\n}\r\n\r\nexport {\r\n  setSegmentationVisibility,\r\n  getSegmentationVisibility,\r\n  setSegmentVisibility,\r\n  setSegmentsVisibility,\r\n  getSegmentVisibility,\r\n};\r\n","import {\r\n  Types,\r\n  Enums,\r\n  getWebWorkerManager,\r\n  eventTarget,\r\n  triggerEvent,\r\n} from '@cornerstonejs/core';\r\n\r\nimport { WorkerTypes } from '../../../enums';\r\nimport { pointToString } from '../../../utilities';\r\nimport { registerPolySegWorker } from '../polySeg/registerPolySegWorker';\r\nconst workerManager = getWebWorkerManager();\r\n\r\n/**\r\n * Surfaces info for clipping\r\n */\r\nexport type SurfacesInfo = {\r\n  id: string;\r\n  points: number[];\r\n  polys: number[];\r\n  segmentIndex: number;\r\n};\r\n\r\n/**\r\n * The result of the surface clipping\r\n */\r\nexport type SurfaceClipResult = {\r\n  points: number[];\r\n  lines: number[];\r\n  numberOfCells: number;\r\n};\r\n\r\nexport type PolyDataClipCacheType = Map<string, Map<string, SurfaceClipResult>>;\r\n\r\n/**\r\n * a cache from actorUID to cacheId to SurfaceClipResult\r\n * Map<actorUID, Map<cacheId, SurfaceClipResult>>\r\n * cacheId is slice specific (viewPlaneNormal, sliceIndex)\r\n */\r\nconst polyDataCache = new Map() as PolyDataClipCacheType;\r\nconst surfacesAABBCache = new Map();\r\n\r\nconst triggerWorkerProgress = (eventTarget, progress) => {\r\n  triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\r\n    progress,\r\n    type: WorkerTypes.SURFACE_CLIPPING,\r\n  });\r\n};\r\n\r\n/**\r\n * Clips and caches surfaces for a specific viewport.\r\n *\r\n * @param surfacesInfo - An array of surfaces information.\r\n * @param viewport - The volume viewport.\r\n * @param segmentationRepresentationUID - The UID of the segmentation representation.\r\n * @returns The cached polydata.\r\n */\r\nexport async function clipAndCacheSurfacesForViewport(\r\n  surfacesInfo: SurfacesInfo[],\r\n  viewport: Types.IVolumeViewport,\r\n  segmentationRepresentationUID: string\r\n) {\r\n  registerPolySegWorker();\r\n  // All planes is an array of planes pairs for each slice, so we should loop over them and\r\n  // add the planes to the clipping filter and cache the results for that slice\r\n\r\n  // Fix these ts ignores\r\n  // @ts-ignore\r\n  const planesInfo = viewport.getSlicesClippingPlanes?.();\r\n\r\n  if (!planesInfo) {\r\n    // this means it is probably the stack viewport not being ready\r\n    // in terms of planes which we should wait for the first render to\r\n    // get the planes\r\n    return;\r\n  }\r\n\r\n  // @ts-ignore\r\n  const currentSliceIndex = viewport.getSliceIndex();\r\n\r\n  // Reorder planesInfo based on proximity to currentSliceIndex\r\n  planesInfo.sort((a, b) => {\r\n    const diffA = Math.abs(a.sliceIndex - currentSliceIndex);\r\n    const diffB = Math.abs(b.sliceIndex - currentSliceIndex);\r\n    return diffA - diffB;\r\n  });\r\n\r\n  triggerWorkerProgress(eventTarget, 0);\r\n\r\n  // check which surfaces don't have a cached AABB\r\n  // make a list of the surfaces that don't have a cached AABB\r\n  await updateSurfacesAABBCache(surfacesInfo);\r\n\r\n  const surfacesAABB = new Map();\r\n  surfacesInfo.forEach((surface) => {\r\n    surfacesAABB.set(surface.id, surfacesAABBCache.get(surface.id));\r\n  });\r\n\r\n  const camera = viewport.getCamera();\r\n\r\n  await workerManager\r\n    .executeTask(\r\n      'polySeg',\r\n      'cutSurfacesIntoPlanes',\r\n      {\r\n        surfacesInfo,\r\n        planesInfo,\r\n        surfacesAABB,\r\n      },\r\n      {\r\n        callbacks: [\r\n          // progress callback\r\n          ({ progress }) => {\r\n            triggerWorkerProgress(eventTarget, progress);\r\n          },\r\n          // update cache callback\r\n          ({ sliceIndex, polyDataResults }) => {\r\n            polyDataResults.forEach((polyDataResult, surfaceId) => {\r\n              const actorUID = `${segmentationRepresentationUID}_${surfaceId}`;\r\n              const cacheId = generateCacheId(\r\n                viewport,\r\n                camera.viewPlaneNormal,\r\n                sliceIndex\r\n              );\r\n              updatePolyDataCache(actorUID, cacheId, polyDataResult);\r\n            });\r\n          },\r\n        ],\r\n      }\r\n    )\r\n    .catch((error) => {\r\n      console.error(error);\r\n    });\r\n\r\n  triggerWorkerProgress(eventTarget, 1);\r\n\r\n  return polyDataCache;\r\n}\r\n\r\n/**\r\n * Updates the surfaces AABB cache with the AABB information for the given surfaces.\r\n * If the AABB information for a surface already exists in the cache, it will not be updated.\r\n * @param surfacesInfo - An array of surfaces information.\r\n * @returns A Promise that resolves when the surfaces AABB cache has been updated.\r\n */\r\nasync function updateSurfacesAABBCache(surfacesInfo: SurfacesInfo[]) {\r\n  const surfacesWithoutAABB = surfacesInfo.filter(\r\n    (surface) => !surfacesAABBCache.has(surface.id)\r\n  );\r\n\r\n  if (!surfacesWithoutAABB.length) {\r\n    return;\r\n  }\r\n\r\n  const surfacesAABB = await workerManager.executeTask(\r\n    'polySeg',\r\n    'getSurfacesAABBs',\r\n    {\r\n      surfacesInfo: surfacesWithoutAABB,\r\n    },\r\n    {\r\n      callbacks: [\r\n        // progress callback\r\n        ({ progress }) => {\r\n          triggerWorkerProgress(eventTarget, progress);\r\n        },\r\n      ],\r\n    }\r\n  );\r\n\r\n  // update the surfacesAABBCache with the new surfacesAABB\r\n  surfacesAABB.forEach((aabb, id) => {\r\n    surfacesAABBCache.set(id, aabb);\r\n  });\r\n}\r\n\r\nexport function getSurfaceActorUID(\r\n  segmentationRepresentationUID: string,\r\n  surfaceId: string\r\n) {\r\n  return `${segmentationRepresentationUID}_${surfaceId}`;\r\n}\r\n\r\n// Helper function to generate a cache ID\r\nexport function generateCacheId(viewport, viewPlaneNormal, sliceIndex) {\r\n  return `${viewport.id}-${pointToString(viewPlaneNormal)}-${sliceIndex}`;\r\n}\r\n\r\n// Helper function to update PolyData cache\r\nexport function updatePolyDataCache(\r\n  actorUID: string,\r\n  cacheId: string,\r\n  polyDataResult: SurfaceClipResult\r\n) {\r\n  const { points, lines, numberOfCells } = polyDataResult;\r\n\r\n  let actorCache = polyDataCache.get(actorUID);\r\n  if (!actorCache) {\r\n    actorCache = new Map<string, SurfaceClipResult>();\r\n    polyDataCache.set(actorUID, actorCache);\r\n  }\r\n  actorCache.set(cacheId, { points, lines, numberOfCells });\r\n}\r\n","import SegmentationRepresentations from '../../enums/SegmentationRepresentations';\r\nimport { labelmapDisplay } from '../../tools/displayTools/Labelmap';\r\nimport { contourDisplay } from '../../tools/displayTools/Contour';\r\n\r\nimport {\r\n  getSegmentationRepresentations,\r\n  getSegmentationRepresentationByUID,\r\n} from './segmentationState';\r\n\r\n/**\r\n * Remove the segmentation representation (representation) from the viewports of the toolGroup.\r\n * @param toolGroupId - The Id of the toolGroup to remove the segmentation from.\r\n * @param segmentationRepresentationUIDs - The UIDs of the segmentation representations to remove.\r\n * @param immediate - if True the viewport will be re-rendered immediately.\r\n */\r\nfunction removeSegmentationsFromToolGroup(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUIDs?: string[] | undefined,\r\n  immediate?: boolean\r\n): void {\r\n  const toolGroupSegRepresentations =\r\n    getSegmentationRepresentations(toolGroupId);\r\n\r\n  if (\r\n    !toolGroupSegRepresentations ||\r\n    toolGroupSegRepresentations.length === 0\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  const toolGroupSegRepresentationUIDs = toolGroupSegRepresentations.map(\r\n    (representation) => representation.segmentationRepresentationUID\r\n  );\r\n\r\n  let segRepresentationUIDsToRemove = segmentationRepresentationUIDs;\r\n  if (segRepresentationUIDsToRemove) {\r\n    // make sure the segmentationDataUIDs that are going to be removed belong\r\n    // to the toolGroup\r\n    const invalidSegRepresentationUIDs = segmentationRepresentationUIDs.filter(\r\n      (segRepresentationUID) =>\r\n        !toolGroupSegRepresentationUIDs.includes(segRepresentationUID)\r\n    );\r\n\r\n    if (invalidSegRepresentationUIDs.length > 0) {\r\n      throw new Error(\r\n        `The following segmentationRepresentationUIDs are not part of the toolGroup: ${JSON.stringify(\r\n          invalidSegRepresentationUIDs\r\n        )}`\r\n      );\r\n    }\r\n  } else {\r\n    // remove all segmentation representations\r\n    segRepresentationUIDsToRemove = toolGroupSegRepresentationUIDs;\r\n  }\r\n\r\n  segRepresentationUIDsToRemove.forEach((segmentationDataUID) => {\r\n    _removeSegmentation(toolGroupId, segmentationDataUID, immediate);\r\n  });\r\n}\r\n\r\nfunction _removeSegmentation(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string,\r\n  immediate?: boolean\r\n): void {\r\n  const segmentationRepresentation = getSegmentationRepresentationByUID(\r\n    toolGroupId,\r\n    segmentationRepresentationUID\r\n  );\r\n\r\n  const { type } = segmentationRepresentation;\r\n\r\n  if (type === SegmentationRepresentations.Labelmap) {\r\n    labelmapDisplay.removeSegmentationRepresentation(\r\n      toolGroupId,\r\n      segmentationRepresentationUID,\r\n      immediate\r\n    );\r\n  } else if (type === SegmentationRepresentations.Contour) {\r\n    contourDisplay.removeSegmentationRepresentation(\r\n      toolGroupId,\r\n      segmentationRepresentationUID,\r\n      immediate\r\n    );\r\n  } else {\r\n    throw new Error(`The representation ${type} is not supported yet`);\r\n  }\r\n}\r\n\r\nexport default removeSegmentationsFromToolGroup;\r\n","import * as Enums from '../../../enums';\r\nimport { SegmentationPublicInput } from '../../../types/SegmentationStateTypes';\r\nimport { validatePublic as validatePublicLabelmap } from '../../../tools/displayTools/Labelmap/validateLabelmap';\r\n\r\n/**\r\n * Validates the given segmentationInputArray to ensure it contains\r\n * appropriate representationProps for the representation type being used.\r\n *\r\n * @param segmentationInputArray - Array of segmentation inputs\r\n * @throws If the segmentationInputArray is undefined or empty\r\n * @throws If the segmentationInput.segmentationId is undefined\r\n * @throws If the segmentationInput.representation is undefined\r\n * @internal\r\n */\r\nfunction validateSegmentationInput(\r\n  segmentationInputArray: SegmentationPublicInput[]\r\n): void {\r\n  if (!segmentationInputArray || segmentationInputArray.length === 0) {\r\n    throw new Error(\r\n      'The segmentationInputArray is undefined or an empty array'\r\n    );\r\n  }\r\n\r\n  segmentationInputArray.forEach((segmentationInput) => {\r\n    if (segmentationInput.segmentationId === undefined) {\r\n      throw new Error(\r\n        'Undefined segmentationInput.segmentationId. Please provide a valid segmentationId'\r\n      );\r\n    }\r\n\r\n    if (segmentationInput.representation === undefined) {\r\n      throw new Error(\r\n        'Undefined segmentationInput.representation. Please provide a valid representation'\r\n      );\r\n    }\r\n\r\n    if (\r\n      segmentationInput.representation.type ===\r\n      Enums.SegmentationRepresentations.Labelmap\r\n    ) {\r\n      validatePublicLabelmap(segmentationInput);\r\n    }\r\n  });\r\n}\r\n\r\nexport default validateSegmentationInput;\r\n","import cloneDeep from 'lodash.clonedeep';\r\nimport { SegmentationPublicInput } from '../../types/SegmentationStateTypes';\r\nimport { validateSegmentationInput } from './helpers';\r\nimport { addSegmentation as addSegmentationToState } from './segmentationState';\r\n/**\r\n * Adds the segmentation to the cornerstone3D segmentation state. It should be\r\n * noted that segmentations are not added to any toolGroup's viewports. In order to\r\n * do so, you should add a \"representation\" of the segmentation to the toolGroup\r\n * using addSegmentationRepresentations helper. The reason for this is that there\r\n * can be multiple representations of the same segmentation (e.g. Labelmap and\r\n * Contour, etc. - Currently only Labelmap representations is supported).\r\n * @param segmentationInputArray - The array of segmentation input, each of which\r\n * defining the segmentationId and the main representation data for the segmentation.\r\n */\r\nfunction addSegmentations(\r\n  segmentationInputArray: SegmentationPublicInput[]\r\n): void {\r\n  validateSegmentationInput(segmentationInputArray);\r\n\r\n  segmentationInputArray.map((segInput) => {\r\n    const segmentationInput = cloneDeep(segInput);\r\n\r\n    addSegmentationToState(segmentationInput);\r\n  });\r\n}\r\n\r\nexport default addSegmentations;\r\n","import SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\r\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\r\n\r\nimport {\r\n  RepresentationConfig,\r\n  SegmentationRepresentationConfig,\r\n  SegmentSpecificRepresentationConfig,\r\n} from '../../../types/SegmentationStateTypes';\r\n\r\n/**\r\n * It returns the global segmentation config.\r\n * @returns The global segmentation config containing the representations\r\n * config for each representation type and renderInactiveSegmentations flag.\r\n */\r\nfunction getGlobalConfig(): SegmentationRepresentationConfig {\r\n  return SegmentationState.getGlobalConfig();\r\n}\r\n\r\n/**\r\n * Set the global segmentation config\r\n * @param segmentationConfig - SegmentationConfig\r\n */\r\nfunction setGlobalConfig(\r\n  segmentationConfig: SegmentationRepresentationConfig\r\n): void {\r\n  SegmentationState.setGlobalConfig(segmentationConfig);\r\n}\r\n\r\n/**\r\n * Given a representation type, return the corresponding global representation config\r\n * @param representationType - The type of representation to query\r\n * @returns A representation configuration object.\r\n */\r\nfunction getGlobalRepresentationConfig(\r\n  representationType: SegmentationRepresentations\r\n): RepresentationConfig['LABELMAP'] {\r\n  const globalConfig = getGlobalConfig();\r\n  return globalConfig.representations[representationType];\r\n}\r\n\r\n/**\r\n * Set the global configuration for a given representation type. It fires\r\n * a SEGMENTATION_MODIFIED event.\r\n *\r\n * @triggers SEGMENTATION_MODIFIED\r\n * @param representationType - The type of representation to set config for\r\n * @param config - The configuration for the representation.\r\n */\r\nfunction setGlobalRepresentationConfig(\r\n  representationType: SegmentationRepresentations,\r\n  config: RepresentationConfig['LABELMAP']\r\n): void {\r\n  const globalConfig = getGlobalConfig();\r\n\r\n  setGlobalConfig({\r\n    ...globalConfig,\r\n    representations: {\r\n      ...globalConfig.representations,\r\n      [representationType]: {\r\n        ...globalConfig.representations[representationType],\r\n        ...config,\r\n      },\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Get the toolGroup specific segmentation config\r\n * @param toolGroupId - The Id of the tool group\r\n * @returns A SegmentationConfig object.\r\n */\r\nfunction getToolGroupSpecificConfig(\r\n  toolGroupId: string\r\n): SegmentationRepresentationConfig {\r\n  return SegmentationState.getToolGroupSpecificConfig(toolGroupId);\r\n}\r\n\r\n/**\r\n * Sets the tool group specific configuration for the segmentation\r\n * representation. This will apply to all segmentation representations.\r\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\r\n * @param segmentationRepresentationConfig - This is the configuration object that you will use to set the default values for\r\n * the segmentation representation.\r\n */\r\nfunction setToolGroupSpecificConfig(\r\n  toolGroupId: string,\r\n  segmentationRepresentationConfig: SegmentationRepresentationConfig\r\n): void {\r\n  SegmentationState.setToolGroupSpecificConfig(\r\n    toolGroupId,\r\n    segmentationRepresentationConfig\r\n  );\r\n}\r\n\r\n/**\r\n * Give the segmentation representation UID, return the corresponding config\r\n * which is shared by all segments in the segmentation representation. This is\r\n * an optional level of configuration that can be set by the user, by default\r\n * it will fallback to the toolGroup specific config, if not set, it will fallback\r\n * to the global config.\r\n *\r\n * @param segmentationRepresentationUID - The uid of the segmentation representation\r\n * @param config - The configuration for the representation. This is an object\r\n * only containing the representation type as key and the config as value.\r\n * @returns - The configuration for the representation.\r\n */\r\nfunction getSegmentationRepresentationSpecificConfig(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string\r\n): RepresentationConfig {\r\n  return SegmentationState.getSegmentationRepresentationSpecificConfig(\r\n    toolGroupId,\r\n    segmentationRepresentationUID\r\n  );\r\n}\r\n\r\n/**\r\n * Set the segmentation representation specific configuration for the\r\n * segmentation representation. This will apply to all segments in the\r\n * segmentation representation and has higher priority than the toolGroup\r\n * specific config.\r\n *\r\n * @param segmentationRepresentationUID - The uid of the segmentation representation\r\n * @param config - The configuration for the representation. This is an object\r\n * only containing the representation type as key and the config as value.\r\n */\r\nfunction setSegmentationRepresentationSpecificConfig(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string,\r\n  config: RepresentationConfig\r\n): void {\r\n  SegmentationState.setSegmentationRepresentationSpecificConfig(\r\n    toolGroupId,\r\n    segmentationRepresentationUID,\r\n    config\r\n  );\r\n}\r\n\r\n/**\r\n * Get the segment specific configuration for the segmentation representation.\r\n *\r\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\r\n * @param segmentationRepresentationUID  - The uid of the segmentation representation\r\n * @param segmentIndex - The index of the segment\r\n * @returns - The configuration for the segment index in the segmentation representation that is shown in the toolGroup's viewport\r\n */\r\nfunction getSegmentSpecificConfig(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string,\r\n  segmentIndex: number\r\n): RepresentationConfig {\r\n  return SegmentationState.getSegmentSpecificRepresentationConfig(\r\n    toolGroupId,\r\n    segmentationRepresentationUID,\r\n    segmentIndex\r\n  );\r\n}\r\n\r\n/**\r\n * Set the segment specific configuration for the segmentation representation.\r\n * This configuration, if specified, has higher priority than the segmentation representation specific config,\r\n * and the toolGroup specific config. The order of priority is: segment specific config > segmentation representation specific config > toolGroup specific config > global config\r\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\r\n * @param segmentationRepresentationUID - The uid of the segmentation representation\r\n * @param segmentIndex - The index of the segment\r\n * @param config - The configuration for the representation. This is an object\r\n */\r\nfunction setSegmentSpecificConfig(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string,\r\n  config: SegmentSpecificRepresentationConfig\r\n): void {\r\n  SegmentationState.setSegmentSpecificRepresentationConfig(\r\n    toolGroupId,\r\n    segmentationRepresentationUID,\r\n    config\r\n  );\r\n}\r\n\r\nexport {\r\n  // Global\r\n  getGlobalConfig,\r\n  setGlobalConfig,\r\n  getGlobalRepresentationConfig,\r\n  setGlobalRepresentationConfig,\r\n  // ToolGroup Specific\r\n  getToolGroupSpecificConfig,\r\n  setToolGroupSpecificConfig,\r\n  // segmentation representation specific config\r\n  getSegmentationRepresentationSpecificConfig,\r\n  setSegmentationRepresentationSpecificConfig,\r\n  // segment specific config\r\n  getSegmentSpecificConfig,\r\n  setSegmentSpecificConfig,\r\n};\r\n","import SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\r\nimport { RepresentationPublicInput } from '../../../types';\r\nimport { getRepresentationRenderingConfig as getLabelmapRenderingConfig } from '../../../tools/displayTools/Labelmap/labelmapDisplay';\r\n\r\nexport function getRepresentationSpecificConfig(\r\n  representationInput: RepresentationPublicInput\r\n) {\r\n  const { type } = representationInput;\r\n\r\n  if (type === SegmentationRepresentations.Labelmap) {\r\n    return getLabelmapRenderingConfig();\r\n  } else {\r\n    return {};\r\n  }\r\n}\r\n","import { getRenderingEngine, utilities } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport {\r\n  SegmentationRepresentationConfig,\r\n  RepresentationPublicInput,\r\n  ToolGroupSpecificRepresentation,\r\n  RepresentationPublicInputOptions,\r\n} from '../../types/SegmentationStateTypes';\r\nimport * as SegmentationConfig from './config/segmentationConfig';\r\nimport {\r\n  addSegmentationRepresentation as addSegmentationRepresentationToState,\r\n  getNextColorLUTIndex,\r\n  addColorLUT,\r\n} from './segmentationState';\r\nimport { getRepresentationSpecificConfig } from './helpers/getRepresentationSpecificConfig';\r\nimport CORNERSTONE_COLOR_LUT from '../../constants/COLOR_LUT';\r\nimport { getToolGroup } from '../../store/ToolGroupManager';\r\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities';\r\nimport { SegmentationRepresentations } from '../../enums';\r\n\r\nasync function addSegmentationRepresentation(\r\n  toolGroupId: string,\r\n  representationInput: RepresentationPublicInput,\r\n  toolGroupSpecificConfig?: SegmentationRepresentationConfig\r\n): Promise<string> {\r\n  const { segmentationId, options = {} as RepresentationPublicInputOptions } =\r\n    representationInput;\r\n\r\n  const segmentationRepresentationUID =\r\n    representationInput.options?.segmentationRepresentationUID ||\r\n    utilities.uuidv4();\r\n\r\n  // Todo: make segmentsHidden also an option that can get passed by\r\n  // the user\r\n  const segmentsHidden = new Set() as Set<number>;\r\n\r\n  const colorLUTIndexToUse = getColorLUTIndex(options);\r\n\r\n  const toolGroupSpecificRepresentation: ToolGroupSpecificRepresentation = {\r\n    segmentationId,\r\n    segmentationRepresentationUID,\r\n    type: representationInput.type,\r\n    segmentsHidden,\r\n    colorLUTIndex: colorLUTIndexToUse,\r\n    active: true,\r\n    segmentationRepresentationSpecificConfig: {},\r\n    segmentSpecificConfig: {},\r\n    config: getRepresentationSpecificConfig(representationInput),\r\n    polySeg: options.polySeg,\r\n  };\r\n\r\n  // Update the toolGroup specific configuration\r\n  if (toolGroupSpecificConfig) {\r\n    // Since setting configuration on toolGroup will trigger a segmentationRepresentation\r\n    // update event, we don't want to trigger the event twice, so we suppress\r\n    // the first one\r\n    const currentToolGroupConfig =\r\n      SegmentationConfig.getToolGroupSpecificConfig(toolGroupId);\r\n\r\n    const mergedConfig = utilities.deepMerge(\r\n      currentToolGroupConfig,\r\n      toolGroupSpecificConfig\r\n    );\r\n\r\n    SegmentationConfig.setToolGroupSpecificConfig(toolGroupId, {\r\n      renderInactiveSegmentations:\r\n        mergedConfig.renderInactiveSegmentations || true,\r\n      representations: {\r\n        ...mergedConfig.representations,\r\n      },\r\n    });\r\n  }\r\n\r\n  addSegmentationRepresentationToState(\r\n    toolGroupId,\r\n    toolGroupSpecificRepresentation\r\n  );\r\n\r\n  if (representationInput.type === SegmentationRepresentations.Contour) {\r\n    getToolGroup(toolGroupId)\r\n      .getViewportsInfo()\r\n      .forEach(({ viewportId, renderingEngineId }) => {\r\n        const renderingEngine = getRenderingEngine(renderingEngineId);\r\n        triggerAnnotationRenderForViewportIds(renderingEngine, [viewportId]);\r\n      });\r\n  }\r\n\r\n  return segmentationRepresentationUID;\r\n}\r\n\r\nfunction getColorLUTIndex(options = {} as RepresentationPublicInputOptions) {\r\n  const colorLUTOrIndexInput = options.colorLUTOrIndex;\r\n  let colorLUTIndexToUse;\r\n\r\n  if (typeof colorLUTOrIndexInput === 'number') {\r\n    colorLUTIndexToUse = colorLUTOrIndexInput;\r\n  } else {\r\n    const nextIndex = getNextColorLUTIndex();\r\n    const colorLUTToAdd = Array.isArray(colorLUTOrIndexInput)\r\n      ? colorLUTOrIndexInput\r\n      : CORNERSTONE_COLOR_LUT;\r\n    addColorLUT(colorLUTToAdd as Types.ColorLUT, nextIndex);\r\n    colorLUTIndexToUse = nextIndex;\r\n  }\r\n  return colorLUTIndexToUse;\r\n}\r\n\r\nexport { addSegmentationRepresentation };\r\n","import {\r\n  SegmentationRepresentationConfig,\r\n  RepresentationPublicInput,\r\n} from '../../types/SegmentationStateTypes';\r\nimport { getToolGroup } from '../../store/ToolGroupManager';\r\n\r\nimport { addSegmentationRepresentation } from './addSegmentationRepresentation';\r\n\r\n/**\r\n * Set the specified segmentation representations on the viewports of the specified\r\n * toolGroup. It accepts a second argument which is a toolGroup specific representation\r\n * configuration.\r\n *\r\n * @param toolGroupId - The Id of the toolGroup to add the segmentation representations to\r\n * @param representationInputArray - An array of segmentation representations to add to the toolGroup\r\n * @param toolGroupSpecificRepresentationConfig - The toolGroup specific configuration\r\n * for the segmentation representations\r\n */\r\nasync function addSegmentationRepresentations(\r\n  toolGroupId: string,\r\n  representationInputArray: RepresentationPublicInput[],\r\n  toolGroupSpecificRepresentationConfig?: SegmentationRepresentationConfig\r\n): Promise<string[]> {\r\n  // Check if there exists a toolGroup with the toolGroupId\r\n  const toolGroup = getToolGroup(toolGroupId);\r\n\r\n  if (!toolGroup) {\r\n    throw new Error(`No tool group found for toolGroupId: ${toolGroupId}`);\r\n  }\r\n\r\n  const promises = representationInputArray.map((representationInput) => {\r\n    return addSegmentationRepresentation(\r\n      toolGroupId,\r\n      representationInput,\r\n      toolGroupSpecificRepresentationConfig\r\n    );\r\n  });\r\n\r\n  const segmentationRepresentationUIDs = await Promise.all(promises);\r\n\r\n  return segmentationRepresentationUIDs;\r\n}\r\n\r\nexport default addSegmentationRepresentations;\r\n","import { LabelmapSegmentationData } from '../../types/LabelmapTypes';\r\nimport { ContourSegmentationData } from '../../types/ContourTypes';\r\nimport { SurfaceSegmentationData } from '../../types/SurfaceTypes';\r\nimport { getSegmentation } from './segmentationState';\r\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\r\n\r\ntype SegmentationData =\r\n  | LabelmapSegmentationData\r\n  | ContourSegmentationData\r\n  | SurfaceSegmentationData;\r\n\r\ntype AddRepresentationData = {\r\n  segmentationId: string;\r\n  type: SegmentationRepresentations;\r\n  data: SegmentationData;\r\n};\r\n\r\n/**\r\n * This will add representation data to the segmentation, for rendering.\r\n * Each segmentation can have multiple representation data, for example\r\n * labelmap, contour and surface representation data. For each representation\r\n * the relevant data should be provided, for instance for the labelmap\r\n * representation the volumeId should be provided, for contour the contour data\r\n * which includes geometryIds of the contour sets, and for surface the surface\r\n * data which includes geometryId of the points and cells.\r\n *\r\n * Note: if the representation data already exists for the segmentation, it will\r\n * be overwritten.\r\n *\r\n * @param segmentationId - id of the segmentation\r\n * @param representationData - representation data to add, it can be either\r\n * labelmap, contour or surface representation data.\r\n */\r\nfunction addRepresentationData({\r\n  segmentationId,\r\n  type,\r\n  data,\r\n}: AddRepresentationData) {\r\n  const segmentation = getSegmentation(segmentationId);\r\n\r\n  if (segmentation.representationData[type]) {\r\n    console.warn(\r\n      `Representation data of type ${type} already exists for segmentation ${segmentationId}, overwriting it.`\r\n    );\r\n\r\n    // update the representation data class\r\n  }\r\n\r\n  switch (type) {\r\n    case SegmentationRepresentations.Labelmap:\r\n      if (data) {\r\n        segmentation.representationData[type] =\r\n          data as LabelmapSegmentationData;\r\n      }\r\n      break;\r\n    case SegmentationRepresentations.Contour:\r\n      if (data) {\r\n        segmentation.representationData[type] = data as ContourSegmentationData;\r\n      }\r\n      break;\r\n    case SegmentationRepresentations.Surface:\r\n      if (data) {\r\n        segmentation.representationData[type] = data as SurfaceSegmentationData;\r\n      }\r\n      break;\r\n    default:\r\n      throw new Error(`Invalid representation type ${type}`);\r\n  }\r\n}\r\n\r\nexport default addRepresentationData;\r\n","import {\r\n  volumeLoader,\r\n  utilities as csUtils,\r\n  eventTarget,\r\n  cache,\r\n} from '@cornerstonejs/core';\r\nimport { Events, SegmentationRepresentations } from '../../enums';\r\nimport addSegmentationRepresentations from './addSegmentationRepresentations';\r\nimport { triggerSegmentationRender } from '../../utilities/segmentation';\r\nimport { getSegmentation } from './segmentationState';\r\nimport { LabelmapSegmentationDataStack } from '../../types/LabelmapTypes';\r\nimport { triggerSegmentationDataModified } from './triggerSegmentationEvents';\r\n\r\nasync function computeVolumeSegmentationFromStack({\r\n  imageIdReferenceMap,\r\n  options,\r\n}: {\r\n  imageIdReferenceMap: Map<string, string>;\r\n  options?: {\r\n    volumeId?: string;\r\n  };\r\n}): Promise<{ volumeId: string }> {\r\n  const segmentationImageIds = Array.from(imageIdReferenceMap.values());\r\n\r\n  const additionalDetails = {\r\n    imageIdReferenceMap,\r\n  };\r\n\r\n  const volumeId = options?.volumeId ?? csUtils.uuidv4();\r\n\r\n  await volumeLoader.createAndCacheVolumeFromImages(\r\n    volumeId,\r\n    segmentationImageIds,\r\n    {\r\n      additionalDetails,\r\n    }\r\n  );\r\n\r\n  return { volumeId };\r\n}\r\n\r\n/**\r\n * Converts a stack-based segmentation to a volume-based segmentation.\r\n *\r\n * @param params - The parameters for the conversion.\r\n * @param params.segmentationId - The segmentationId to convert.\r\n * @param [params.options] - The conversion options.\r\n * @param params.options.toolGroupId - The new toolGroupId to use for the segmentation.\r\n * @param [params.options.volumeId] - the new volumeId to use for the segmentation. If not provided, a new ID will be generated.\r\n * @param [params.options.newSegmentationId] - the new segmentationId to use for the segmentation. If not provided, a new ID will be generated.\r\n * @param [params.options.removeOriginal] - Whether or not to remove the original segmentation. Defaults to true.\r\n *\r\n * @returns A promise that resolves when the conversion is complete.\r\n */\r\nasync function convertStackToVolumeSegmentation({\r\n  segmentationId,\r\n  options,\r\n}: {\r\n  segmentationId: string;\r\n  options?: {\r\n    toolGroupId: string;\r\n    volumeId?: string;\r\n    removeOriginal?: boolean;\r\n  };\r\n}): Promise<void> {\r\n  const segmentation = getSegmentation(segmentationId);\r\n\r\n  const data = segmentation.representationData\r\n    .LABELMAP as LabelmapSegmentationDataStack;\r\n\r\n  const { volumeId } = await computeVolumeSegmentationFromStack({\r\n    imageIdReferenceMap: data.imageIdReferenceMap,\r\n    options,\r\n  });\r\n\r\n  await updateSegmentationState({\r\n    segmentationId,\r\n    toolGroupId: options.toolGroupId,\r\n    options,\r\n    volumeId,\r\n  });\r\n}\r\n\r\n// This function is responsible for updating the segmentation state\r\nasync function updateSegmentationState({\r\n  segmentationId,\r\n  toolGroupId,\r\n  volumeId,\r\n  options,\r\n}: {\r\n  segmentationId: string;\r\n  toolGroupId: string;\r\n  volumeId: string;\r\n  options?: {\r\n    removeOriginal?: boolean;\r\n  };\r\n}): Promise<void> {\r\n  const segmentation = getSegmentation(segmentationId);\r\n\r\n  if (options?.removeOriginal) {\r\n    const data = segmentation.representationData\r\n      .LABELMAP as LabelmapSegmentationDataStack;\r\n\r\n    const imageIdReferenceMap = data.imageIdReferenceMap;\r\n\r\n    Array.from(imageIdReferenceMap.values()).forEach((imageId) => {\r\n      cache.removeImageLoadObject(imageId);\r\n    });\r\n\r\n    segmentation.representationData.LABELMAP = {\r\n      volumeId,\r\n    };\r\n  } else {\r\n    segmentation.representationData.LABELMAP = {\r\n      ...segmentation.representationData.LABELMAP,\r\n      volumeId,\r\n    };\r\n  }\r\n\r\n  await addSegmentationRepresentations(toolGroupId, [\r\n    {\r\n      segmentationId,\r\n      type: SegmentationRepresentations.Labelmap,\r\n    },\r\n  ]);\r\n\r\n  triggerSegmentationRender(toolGroupId);\r\n  // Note: It is crucial to trigger the data modified event. This ensures that the\r\n  // old texture is updated to the GPU, especially in scenarios where it may not be getting updated.\r\n  eventTarget.addEventListenerOnce(Events.SEGMENTATION_RENDERED, () =>\r\n    triggerSegmentationDataModified(segmentationId)\r\n  );\r\n}\r\n\r\nexport { convertStackToVolumeSegmentation, computeVolumeSegmentationFromStack };\r\n","import {\r\n  Types,\r\n  cache,\r\n  eventTarget,\r\n  getRenderingEngines,\r\n} from '@cornerstonejs/core';\r\nimport { Events, SegmentationRepresentations } from '../../enums';\r\nimport addSegmentationRepresentations from './addSegmentationRepresentations';\r\nimport {\r\n  triggerSegmentationRender,\r\n  createImageIdReferenceMap,\r\n} from '../../utilities/segmentation';\r\nimport { getSegmentation } from './segmentationState';\r\nimport { LabelmapSegmentationDataVolume } from '../../types/LabelmapTypes';\r\nimport { triggerSegmentationDataModified } from './triggerSegmentationEvents';\r\n\r\n// This function is responsible for the conversion calculations\r\nexport async function computeStackSegmentationFromVolume({\r\n  volumeId,\r\n}: {\r\n  volumeId: string;\r\n}): Promise<{ imageIdReferenceMap: Map<string, string> }> {\r\n  const segmentationVolume = cache.getVolume(volumeId) as Types.IImageVolume;\r\n\r\n  // we need to decache the segmentation Volume so that we use it\r\n  // for the conversion\r\n\r\n  // So here we have two scenarios that we need to handle:\r\n  // 1. the volume was derived from a stack and we need to decache it, this is easy\r\n  // since we just need purge the volume from the cache and those images will get\r\n  // their copy of the image back\r\n  // 2. It was actually a native volume and we need to decache it, this is a bit more\r\n  // complicated since then we need to decide on the imageIds for it to get\r\n  // decached to\r\n  const hasCachedImages = segmentationVolume.imageCacheOffsetMap.size > 0;\r\n  // Initialize the variable to hold the final result\r\n  let isAllImagesCached = false;\r\n\r\n  if (hasCachedImages) {\r\n    // Check if every imageId in the volume is in the _imageCache\r\n    isAllImagesCached = segmentationVolume.imageIds.every((imageId) =>\r\n      cache.getImage(imageId)\r\n    );\r\n  }\r\n\r\n  //Todo: This is a hack to get the rendering engine\r\n  const renderingEngine = getRenderingEngines()[0];\r\n  const volumeUsedInOtherViewports = renderingEngine\r\n    .getVolumeViewports()\r\n    .find((vp) => vp.hasVolumeId(volumeId));\r\n\r\n  segmentationVolume.decache(!volumeUsedInOtherViewports && isAllImagesCached);\r\n\r\n  const imageIdReferenceMap =\r\n    _getImageIdReferenceMapForStackSegmentation(segmentationVolume);\r\n\r\n  // check if the imageIds have been cache, if not we should actually copy\r\n\r\n  return { imageIdReferenceMap };\r\n}\r\n\r\n// Updated original function to call the new separate functions\r\nexport async function convertVolumeToStackSegmentation({\r\n  segmentationId,\r\n  options,\r\n}: {\r\n  segmentationId: string;\r\n  options?: {\r\n    toolGroupId: string;\r\n    newSegmentationId?: string;\r\n    removeOriginal?: boolean;\r\n  };\r\n}): Promise<void> {\r\n  const segmentation = getSegmentation(segmentationId);\r\n\r\n  const data = segmentation.representationData\r\n    .LABELMAP as LabelmapSegmentationDataVolume;\r\n  const { imageIdReferenceMap } = await computeStackSegmentationFromVolume({\r\n    volumeId: data.volumeId,\r\n  });\r\n\r\n  await updateStackSegmentationState({\r\n    segmentationId,\r\n    toolGroupId: options.toolGroupId,\r\n    imageIdReferenceMap,\r\n    options,\r\n  });\r\n}\r\n\r\n/**\r\n * Converts a volume segmentation to a stack segmentation.\r\n *\r\n * @param params - The parameters for the conversion.\r\n * @param params.segmentationId - The segmentationId to convert.\r\n * @param [params.options] - The conversion options.\r\n * @param params.options.toolGroupId - The new toolGroupId that the new segmentation will belong to.\r\n * @param [params.options.newSegmentationId] -  The new segmentationId to use for the segmentation. If not provided, a new ID will be generated.\r\n * @param [params.options.removeOriginal] - Whether or not to remove the original segmentation. Defaults to true.\r\n *\r\n * @returns A promise that resolves when the conversion is complete.\r\n */\r\nexport async function updateStackSegmentationState({\r\n  segmentationId,\r\n  toolGroupId,\r\n  imageIdReferenceMap,\r\n  options,\r\n}: {\r\n  segmentationId: string;\r\n  toolGroupId: string;\r\n  imageIdReferenceMap: Map<any, any>;\r\n  options?: {\r\n    removeOriginal?: boolean;\r\n  };\r\n}): Promise<void> {\r\n  const segmentation = getSegmentation(segmentationId);\r\n\r\n  if (options?.removeOriginal) {\r\n    const data = segmentation.representationData\r\n      .LABELMAP as LabelmapSegmentationDataVolume;\r\n\r\n    if (cache.getVolume(data.volumeId)) {\r\n      cache.removeVolumeLoadObject(data.volumeId);\r\n    }\r\n\r\n    segmentation.representationData.LABELMAP = {\r\n      imageIdReferenceMap,\r\n    };\r\n  } else {\r\n    segmentation.representationData.LABELMAP = {\r\n      ...segmentation.representationData.LABELMAP,\r\n      imageIdReferenceMap,\r\n    };\r\n  }\r\n\r\n  await addSegmentationRepresentations(toolGroupId, [\r\n    {\r\n      segmentationId,\r\n      type: SegmentationRepresentations.Labelmap,\r\n    },\r\n  ]);\r\n\r\n  triggerSegmentationRender(toolGroupId);\r\n  eventTarget.addEventListenerOnce(Events.SEGMENTATION_RENDERED, () =>\r\n    triggerSegmentationDataModified(segmentationId)\r\n  );\r\n}\r\n\r\nfunction _getImageIdReferenceMapForStackSegmentation(\r\n  segmentationVolume: Types.IImageVolume\r\n) {\r\n  // There might be or might not be segmentationImageIds, if it is a volume\r\n  // segmentation converted from stack segmentation, there will be segmentationImageIds\r\n  // otherwise, if it is empty volume segmentation derived from\r\n  // a volume that is not a stack, there will be no segmentationImageIds\r\n\r\n  if (segmentationVolume.additionalDetails?.imageIdReferenceMap) {\r\n    // this means the segmentation volume is derived from a stack segmentation\r\n    // and we can use the imageIdReferenceMap from the additionalDetails\r\n    return segmentationVolume.additionalDetails.imageIdReferenceMap;\r\n  } else if (\r\n    segmentationVolume.referencedImageIds?.length &&\r\n    !segmentationVolume.referencedImageIds[0].startsWith('derived')\r\n  ) {\r\n    // this means the segmentation volume is derived from a stack segmentation\r\n    // and we can use the referencedImageIds from the segmentationVolume\r\n    const referencedImageIds = segmentationVolume.referencedImageIds;\r\n    const segmentationImageIds = segmentationVolume.imageIds;\r\n\r\n    return createImageIdReferenceMap(\r\n      referencedImageIds,\r\n      [...segmentationImageIds].reverse()\r\n    );\r\n  } else {\r\n    // check if the segmentation volume is derived from another volume and\r\n    // whether if that volume has imageIds\r\n    const referencedVolumeId = segmentationVolume.referencedVolumeId;\r\n    const referencedVolume = cache.getVolume(referencedVolumeId);\r\n\r\n    if (!referencedVolume) {\r\n      throw new Error(\r\n        'Cannot convert volumetric segmentation without referenced volume to stack segmentation yet'\r\n      );\r\n    }\r\n\r\n    if (!referencedVolume?.imageIds?.length) {\r\n      throw new Error(\r\n        'Cannot convert volumetric segmentation without imageIds to stack segmentation yet'\r\n      );\r\n    }\r\n\r\n    if (referencedVolume.imageIds?.[0].startsWith('derived')) {\r\n      throw new Error(\r\n        `Cannot convert volume segmentation that is derived from another segmentation\r\n         to stack segmentation yet, include the additionalDetails.imageIdReferenceMap\r\n         in the volume segmentation in case you need it for the conversion`\r\n      );\r\n    }\r\n\r\n    // if the referenced volume has imageIds, and itself is not derived from\r\n    // another segmentation then we can use the imageIds from the referenced volume\r\n    const referencedImageIds = referencedVolume.imageIds;\r\n\r\n    let segmentationImageIdsToUse = segmentationVolume.imageIds;\r\n    if (!segmentationImageIdsToUse?.length) {\r\n      // If segmentation Ids don't exist it means that the segmentation is literally\r\n      // just a volume so we need to assume imageIds and decache it to the _imageCache\r\n      // so that it can be used for the conversion\r\n      segmentationImageIdsToUse =\r\n        segmentationVolume.convertToImageSlicesAndCache();\r\n    }\r\n\r\n    return createImageIdReferenceMap(\r\n      referencedImageIds,\r\n      [...segmentationImageIdsToUse].reverse()\r\n    );\r\n  }\r\n}\r\n","import { getActiveSegmentationRepresentation } from './activeSegmentation';\r\n\r\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\r\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\r\n\r\n/**\r\n * Get the locked status for a segment index in a segmentation\r\n * @param segmentationId - The id of the segmentation that the segment\r\n * belongs to.\r\n * @param segmentIndex - The index of the segment\r\n * @returns A boolean value indicating whether the segment is locked or not.\r\n */\r\nfunction isSegmentIndexLocked(\r\n  segmentationId: string,\r\n  segmentIndex: number\r\n): boolean {\r\n  const segmentation = getSegmentation(segmentationId);\r\n\r\n  if (!segmentation) {\r\n    throw new Error(`No segmentation state found for ${segmentationId}`);\r\n  }\r\n\r\n  const { segmentsLocked } = segmentation;\r\n  return segmentsLocked.has(segmentIndex);\r\n}\r\n\r\n/**\r\n * Set the locked status of a segment index in a segmentation\r\n * @param segmentationId - The id of the segmentation whose segment\r\n * index is being modified.\r\n * @param segmentIndex - The index of the segment to lock/unlock.\r\n */\r\nfunction setSegmentIndexLocked(\r\n  segmentationId: string,\r\n  segmentIndex: number,\r\n  locked = true\r\n): void {\r\n  const segmentation = getSegmentation(segmentationId);\r\n\r\n  if (!segmentation) {\r\n    throw new Error(`No segmentation state found for ${segmentationId}`);\r\n  }\r\n\r\n  const { segmentsLocked } = segmentation;\r\n\r\n  if (locked) {\r\n    segmentsLocked.add(segmentIndex);\r\n  } else {\r\n    segmentsLocked.delete(segmentIndex);\r\n  }\r\n\r\n  triggerSegmentationModified(segmentationId);\r\n}\r\n\r\n/**\r\n * Get the locked segments for a segmentation\r\n * @param segmentationId - The id of the segmentation to get locked\r\n * segments for.\r\n * @returns An array of locked segment indices.\r\n */\r\nfunction getLockedSegments(segmentationId: string): number[] | [] {\r\n  const segmentation = getSegmentation(segmentationId);\r\n\r\n  if (!segmentation) {\r\n    throw new Error(`No segmentation state found for ${segmentationId}`);\r\n  }\r\n\r\n  const { segmentsLocked } = segmentation;\r\n  return Array.from(segmentsLocked);\r\n}\r\n\r\nexport { isSegmentIndexLocked, setSegmentIndexLocked, getLockedSegments };\r\n","import { utilities } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\r\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\r\n\r\n/**\r\n * addColorLUT - Adds a new color LUT to the state at the given colorLUTIndex.\r\n * If no colorLUT is provided, a new color LUT is generated.\r\n *\r\n * @param colorLUTIndex - the index of the colorLUT in the state\r\n * @param colorLUT - An array of The colorLUT to set.\r\n * @returns\r\n */\r\nfunction addColorLUT(colorLUT: Types.ColorLUT, colorLUTIndex: number): void {\r\n  if (!colorLUT) {\r\n    throw new Error('addColorLUT: colorLUT is required');\r\n  }\r\n\r\n  // Append the \"zero\" (no label) color to the front of the LUT, if necessary.\r\n  if (!utilities.isEqual(colorLUT[0], [0, 0, 0, 0])) {\r\n    console.warn(\r\n      'addColorLUT: [0, 0, 0, 0] color is not provided for the background color (segmentIndex =0), automatically adding it'\r\n    );\r\n    colorLUT.unshift([0, 0, 0, 0]);\r\n  }\r\n\r\n  SegmentationState.addColorLUT(colorLUT, colorLUTIndex);\r\n}\r\n\r\n/**\r\n * It sets the toolGroup's segmentationRepresentation to use the provided\r\n * colorLUT at the given colorLUTIndex.\r\n * @param toolGroupId - the id of the toolGroup that renders the representation\r\n * @param segmentationRepresentationUID - the representationUID for the segmentation\r\n * @param colorLUTIndex - the index of the colorLUT to use\r\n */\r\nfunction setColorLUT(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string,\r\n  colorLUTIndex: number\r\n): void {\r\n  const segRepresentation =\r\n    SegmentationState.getSegmentationRepresentationByUID(\r\n      toolGroupId,\r\n      segmentationRepresentationUID\r\n    );\r\n\r\n  if (!segRepresentation) {\r\n    throw new Error(\r\n      `setColorLUT: could not find segmentation representation with UID ${segmentationRepresentationUID}`\r\n    );\r\n  }\r\n\r\n  if (!SegmentationState.getColorLUT(colorLUTIndex)) {\r\n    throw new Error(\r\n      `setColorLUT: could not find colorLUT with index ${colorLUTIndex}`\r\n    );\r\n  }\r\n\r\n  segRepresentation.colorLUTIndex = colorLUTIndex;\r\n\r\n  triggerSegmentationRepresentationModified(\r\n    toolGroupId,\r\n    segmentationRepresentationUID\r\n  );\r\n}\r\n\r\n/**\r\n * Given a tool group UID, a segmentation representationUID, and a segment index, return the\r\n * color for that segment. It can be used for segmentation tools that need to\r\n * display the color of their annotation.\r\n *\r\n * @param toolGroupId - The Id of the tool group that owns the segmentation representation.\r\n * @param segmentationRepresentationUID - The uid of the segmentation representation\r\n * @param segmentIndex - The index of the segment in the segmentation\r\n * @returns A color.\r\n */\r\nfunction getColorForSegmentIndex(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string,\r\n  segmentIndex: number\r\n): Types.Color {\r\n  const segmentationRepresentation =\r\n    SegmentationState.getSegmentationRepresentationByUID(\r\n      toolGroupId,\r\n      segmentationRepresentationUID\r\n    );\r\n\r\n  if (!segmentationRepresentation) {\r\n    throw new Error(\r\n      `segmentation representation with UID ${segmentationRepresentationUID} does not exist for tool group ${toolGroupId}`\r\n    );\r\n  }\r\n\r\n  const { colorLUTIndex } = segmentationRepresentation;\r\n\r\n  // get colorLUT\r\n  const colorLUT = SegmentationState.getColorLUT(colorLUTIndex);\r\n  let colorValue = colorLUT[segmentIndex];\r\n  if (!colorValue) {\r\n    if (typeof segmentIndex !== 'number') {\r\n      throw new Error(`Can't create colour for LUT index ${segmentIndex}`);\r\n    }\r\n    colorValue = colorLUT[segmentIndex] = [0, 0, 0, 0];\r\n  }\r\n  return colorValue;\r\n}\r\n\r\nfunction setColorForSegmentIndex(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string,\r\n  segmentIndex: number,\r\n  color: Types.Color\r\n): void {\r\n  // Get the reference to the color in the colorLUT.\r\n  const colorReference = getColorForSegmentIndex(\r\n    toolGroupId,\r\n    segmentationRepresentationUID,\r\n    segmentIndex\r\n  );\r\n\r\n  // Modify the values by reference\r\n  for (let i = 0; i < color.length; i++) {\r\n    colorReference[i] = color[i];\r\n  }\r\n\r\n  triggerSegmentationRepresentationModified(\r\n    toolGroupId,\r\n    segmentationRepresentationUID\r\n  );\r\n}\r\n\r\nexport {\r\n  getColorForSegmentIndex,\r\n  addColorLUT,\r\n  setColorLUT,\r\n  setColorForSegmentIndex,\r\n};\r\n","import { eventTarget } from '@cornerstonejs/core';\r\nimport { Events, SegmentationRepresentations } from '../../../enums';\r\nimport addRepresentationData from '../addRepresentationData';\r\nimport { triggerSegmentationModified } from '../triggerSegmentationEvents';\r\nimport { debounce } from '../../../utilities';\r\nimport { registerPolySegWorker } from './registerPolySegWorker';\r\n\r\nconst computedRepresentations = new Map<\r\n  string,\r\n  SegmentationRepresentations[]\r\n>();\r\n\r\n/**\r\n * Computes a representation using the provided computation function, adds the computed data,\r\n * subscribes to segmentation changes, and triggers segmentation modification.\r\n *\r\n * @param segmentationId - The ID of the segmentation.\r\n * @param representationType - The type of the segmentation representation.\r\n * @param computeFunction - The function that computes the representation data.\r\n * @param options - Additional options for computing the representation.\r\n * @returns - A promise that resolves with the computed representation data.\r\n */\r\nasync function computeAndAddRepresentation<T>(\r\n  segmentationId: string,\r\n  representationType: SegmentationRepresentations,\r\n  computeFunction: () => Promise<T>,\r\n  updateFunction?: () => void\r\n): Promise<T> {\r\n  // register the worker if it hasn't been registered yet\r\n  registerPolySegWorker();\r\n\r\n  // Compute the specific representation data\r\n  const data = await computeFunction();\r\n\r\n  // Add the computed data to the system\r\n  addRepresentationData({\r\n    segmentationId,\r\n    type: representationType,\r\n    data,\r\n  });\r\n\r\n  // Update internal structures and possibly UI components\r\n  if (!computedRepresentations.has(segmentationId)) {\r\n    computedRepresentations.set(segmentationId, []);\r\n  }\r\n\r\n  const representations = computedRepresentations.get(segmentationId);\r\n  if (!representations.includes(representationType)) {\r\n    representations.push(representationType);\r\n  }\r\n\r\n  // Subscribe to any changes in the segmentation data for real-time updates\r\n  subscribeToSegmentationChanges(updateFunction);\r\n\r\n  // Notify other system parts that segmentation data has been modified\r\n  triggerSegmentationModified(segmentationId);\r\n\r\n  return data;\r\n}\r\n\r\n/**\r\n * Subscribes to segmentation changes by adding an event listener for the SEGMENTATION_DATA_MODIFIED event.\r\n * If there is an existing listener, it will be unsubscribed before adding the new listener.\r\n */\r\nfunction subscribeToSegmentationChanges(updateFunction) {\r\n  const debouncedUpdateFunction = (event) => {\r\n    _debouncedSegmentationModified(event, updateFunction);\r\n  };\r\n\r\n  updateFunction._debouncedUpdateFunction = debouncedUpdateFunction;\r\n\r\n  eventTarget.removeEventListener(\r\n    Events.SEGMENTATION_DATA_MODIFIED,\r\n    updateFunction._debouncedUpdateFunction\r\n  );\r\n\r\n  eventTarget.addEventListener(\r\n    Events.SEGMENTATION_DATA_MODIFIED,\r\n    updateFunction._debouncedUpdateFunction\r\n  );\r\n}\r\n\r\nconst _debouncedSegmentationModified = debounce((event, updateFunction) => {\r\n  const segmentationId = event.detail.segmentationId;\r\n  const representations = computedRepresentations.get(segmentationId);\r\n  if (!representations || !representations.length) {\r\n    return;\r\n  }\r\n\r\n  updateFunction(segmentationId);\r\n\r\n  if (representations.length) {\r\n    triggerSegmentationModified(segmentationId);\r\n  }\r\n}, 300);\r\n\r\nexport { computeAndAddRepresentation };\r\n","import { Enums, Types, eventTarget, triggerEvent } from '@cornerstonejs/core';\r\nimport { getWebWorkerManager } from '@cornerstonejs/core';\r\nimport { ContourSegmentationData } from '../../../../types';\r\nimport { getAnnotation } from '../../../annotation/annotationState';\r\nimport { WorkerTypes } from '../../../../enums';\r\n\r\nconst workerManager = getWebWorkerManager();\r\n\r\nconst triggerWorkerProgress = (eventTarget, progress) => {\r\n  triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\r\n    progress,\r\n    type: WorkerTypes.POLYSEG_CONTOUR_TO_SURFACE,\r\n  });\r\n};\r\n\r\n/**\r\n * Converts a contour representation to a surface representation.\r\n *\r\n * @param contourRepresentationData - The contour segmentation data.\r\n * @param segmentIndex - The index of the segment to convert.\r\n * @returns A promise that resolves to the surface data.\r\n */\r\nexport async function convertContourToSurface(\r\n  contourRepresentationData: ContourSegmentationData,\r\n  segmentIndex: number\r\n): Promise<Types.SurfaceData> {\r\n  const { annotationUIDsMap } = contourRepresentationData;\r\n\r\n  // loop over all annotations in the segment and flatten their polylines\r\n  const polylines = [];\r\n  const numPointsArray = [];\r\n  const annotationUIDs = annotationUIDsMap.get(segmentIndex);\r\n\r\n  for (const annotationUID of annotationUIDs) {\r\n    const annotation = getAnnotation(annotationUID);\r\n    const { polyline } = annotation.data.contour;\r\n    numPointsArray.push(polyline.length);\r\n    polyline.forEach((polyline) => polylines.push(...polyline));\r\n  }\r\n\r\n  triggerWorkerProgress(eventTarget, 0);\r\n\r\n  const results = await workerManager.executeTask(\r\n    'polySeg',\r\n    'convertContourToSurface',\r\n    {\r\n      polylines,\r\n      numPointsArray,\r\n    },\r\n    {\r\n      callbacks: [\r\n        (progress) => {\r\n          triggerWorkerProgress(eventTarget, progress);\r\n        },\r\n      ],\r\n    }\r\n  );\r\n\r\n  triggerWorkerProgress(eventTarget, 1);\r\n\r\n  return results;\r\n}\r\n","import { Enums, Types, geometryLoader } from '@cornerstonejs/core';\r\nimport { getColorForSegmentIndex } from '../../config/segmentationColor';\r\nimport {\r\n  findSegmentationRepresentationByUID,\r\n  getSegmentation,\r\n} from '../../segmentationState';\r\nimport { RawSurfacesData } from './surfaceComputationStrategies';\r\nimport { PolySegConversionOptions } from '../../../../types';\r\n\r\n/**\r\n * Creates and caches surfaces from raw surface data.\r\n *\r\n * @param segmentationId - The ID of the segmentation.\r\n * @param rawSurfacesData - The raw surface data.\r\n * @param options - Additional options for creating and caching surfaces.\r\n * @param options.segmentIndices - An array of segment indices.\r\n * @param options.segmentationRepresentationUID - The UID of the segmentation representation.\r\n * @returns An object containing the IDs of the created surfaces.\r\n */\r\nexport async function createAndCacheSurfacesFromRaw(\r\n  segmentationId: string,\r\n  rawSurfacesData: RawSurfacesData,\r\n  options: PolySegConversionOptions = {}\r\n) {\r\n  // Initialize segmentationRepresentation and toolGroupId if a representation UID is provided\r\n  let segmentationRepresentation: any, toolGroupId: any;\r\n  if (options.segmentationRepresentationUID) {\r\n    ({ segmentationRepresentation, toolGroupId } =\r\n      findSegmentationRepresentationByUID(\r\n        options.segmentationRepresentationUID\r\n      ));\r\n  }\r\n\r\n  const segmentation = getSegmentation(segmentationId);\r\n\r\n  const geometryIds = new Map<number, string>();\r\n\r\n  // Loop through raw surfaces data and create surfaces\r\n  const promises = Object.keys(rawSurfacesData).map(async (index: string) => {\r\n    const rawSurfaceData = rawSurfacesData[index];\r\n    const segmentIndex = rawSurfaceData.segmentIndex;\r\n\r\n    // Get the color either from the segmentation representation or randomly generated\r\n    const color = segmentationRepresentation;\r\n    getColorForSegmentIndex(\r\n      toolGroupId,\r\n      segmentationRepresentation.segmentationRepresentationUID,\r\n      segmentIndex\r\n    ).slice(0, 3);\r\n\r\n    if (!color) {\r\n      throw new Error(\r\n        'No color found for segment index, unable to create surface'\r\n      );\r\n    }\r\n\r\n    const closedSurface = {\r\n      id: `segmentation_${segmentation.segmentationId}_surface_${segmentIndex}`,\r\n      color,\r\n      frameOfReferenceUID: 'test-frameOfReferenceUID',\r\n      data: {\r\n        points: rawSurfaceData.data.points,\r\n        polys: rawSurfaceData.data.polys,\r\n      },\r\n    };\r\n\r\n    const geometryId = closedSurface.id;\r\n    geometryIds.set(segmentIndex, geometryId);\r\n\r\n    return geometryLoader.createAndCacheGeometry(geometryId, {\r\n      type: Enums.GeometryType.SURFACE,\r\n      geometryData: closedSurface as Types.PublicSurfaceData,\r\n    });\r\n  });\r\n\r\n  await Promise.all(promises);\r\n\r\n  return {\r\n    geometryIds,\r\n  };\r\n}\r\n","import {\r\n  Types,\r\n  cache,\r\n  eventTarget,\r\n  triggerEvent,\r\n  Enums,\r\n} from '@cornerstonejs/core';\r\nimport { getWebWorkerManager } from '@cornerstonejs/core';\r\nimport {\r\n  LabelmapSegmentationData,\r\n  LabelmapSegmentationDataStack,\r\n  LabelmapSegmentationDataVolume,\r\n} from '../../../../types/LabelmapTypes';\r\nimport { computeVolumeSegmentationFromStack } from '../../convertStackToVolumeSegmentation';\r\nimport { WorkerTypes } from '../../../../enums';\r\n\r\nconst workerManager = getWebWorkerManager();\r\n\r\nconst triggerWorkerProgress = (eventTarget, progress) => {\r\n  triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\r\n    progress,\r\n    type: WorkerTypes.POLYSEG_LABELMAP_TO_SURFACE,\r\n  });\r\n};\r\n\r\n/**\r\n * Converts a labelmap representation to a surface representation.\r\n *\r\n * @param labelmapRepresentationData - The labelmap segmentation data.\r\n * @param segmentIndex - The index of the segment to convert.\r\n * @param isVolume - Optional flag indicating whether the labelmap is a volume or a stack. Default is true.\r\n * @returns A promise that resolves to the surface data.\r\n */\r\nexport async function convertLabelmapToSurface(\r\n  labelmapRepresentationData: LabelmapSegmentationData,\r\n  segmentIndex: number,\r\n  isVolume = true\r\n): Promise<Types.SurfaceData> {\r\n  let volumeId;\r\n  if (isVolume) {\r\n    volumeId = (labelmapRepresentationData as LabelmapSegmentationDataVolume)\r\n      .volumeId;\r\n  } else {\r\n    const { imageIdReferenceMap } =\r\n      labelmapRepresentationData as LabelmapSegmentationDataStack;\r\n    ({ volumeId } = await computeVolumeSegmentationFromStack({\r\n      imageIdReferenceMap,\r\n    }));\r\n  }\r\n\r\n  const volume = cache.getVolume(volumeId);\r\n\r\n  const scalarData = volume.getScalarData();\r\n  const { dimensions, spacing, origin, direction } = volume;\r\n\r\n  triggerWorkerProgress(eventTarget, 0);\r\n\r\n  const results = await workerManager.executeTask(\r\n    'polySeg',\r\n    'convertLabelmapToSurface',\r\n    {\r\n      scalarData,\r\n      dimensions,\r\n      spacing,\r\n      origin,\r\n      direction,\r\n      segmentIndex,\r\n    },\r\n    {\r\n      callbacks: [\r\n        (progress) => {\r\n          triggerWorkerProgress(eventTarget, progress);\r\n        },\r\n      ],\r\n    }\r\n  );\r\n\r\n  triggerWorkerProgress(eventTarget, 1);\r\n\r\n  return results;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport {\r\n  ContourSegmentationData,\r\n  PolySegConversionOptions,\r\n} from '../../../../types';\r\nimport { getUniqueSegmentIndices } from '../../../../utilities/segmentation';\r\nimport { getSegmentation } from '../../segmentationState';\r\nimport { convertContourToSurface } from './convertContourToSurface';\r\nimport { createAndCacheSurfacesFromRaw } from './createAndCacheSurfacesFromRaw';\r\nimport {\r\n  LabelmapSegmentationData,\r\n  LabelmapSegmentationDataStack,\r\n  LabelmapSegmentationDataVolume,\r\n} from '../../../../types/LabelmapTypes';\r\nimport { isVolumeSegmentation } from '../../../../tools/segmentation/strategies/utils/stackVolumeCheck';\r\nimport { convertLabelmapToSurface } from './convertLabelmapToSurface';\r\n\r\nexport type RawSurfacesData = {\r\n  segmentIndex: number;\r\n  data: Types.SurfaceData;\r\n}[];\r\n\r\n/**\r\n * Computes surface data for a given segmentation.\r\n * @param segmentationId - The ID of the segmentation.\r\n * @param options - Additional options for surface computation.\r\n * @returns A promise that resolves to the computed surface data.\r\n * @throws An error if there is no surface data available for the segmentation.\r\n */\r\nexport async function computeSurfaceData(\r\n  segmentationId: string,\r\n  options: PolySegConversionOptions = {}\r\n) {\r\n  const segmentIndices = options.segmentIndices?.length\r\n    ? options.segmentIndices\r\n    : getUniqueSegmentIndices(segmentationId);\r\n\r\n  let rawSurfacesData: RawSurfacesData;\r\n  const segmentation = getSegmentation(segmentationId);\r\n  const representationData = segmentation.representationData;\r\n\r\n  try {\r\n    if (representationData.CONTOUR) {\r\n      rawSurfacesData = await computeSurfaceFromContourSegmentation(\r\n        segmentationId,\r\n        {\r\n          segmentIndices,\r\n          ...options,\r\n        }\r\n      );\r\n    } else if (representationData.LABELMAP as LabelmapSegmentationData) {\r\n      // convert volume labelmap to surface\r\n      rawSurfacesData = await computeSurfaceFromLabelmapSegmentation(\r\n        segmentation.segmentationId,\r\n        {\r\n          segmentIndices,\r\n          ...options,\r\n        }\r\n      );\r\n    }\r\n  } catch (error) {\r\n    console.error(error);\r\n    throw error;\r\n  }\r\n\r\n  if (!rawSurfacesData) {\r\n    throw new Error(\r\n      'Not enough data to convert to surface, currently only support converting volume labelmap to surface if available'\r\n    );\r\n  }\r\n\r\n  const surfacesData = await createAndCacheSurfacesFromRaw(\r\n    segmentationId,\r\n    rawSurfacesData,\r\n    options\r\n  );\r\n\r\n  return surfacesData;\r\n}\r\n\r\nasync function computeSurfaceFromLabelmapSegmentation(\r\n  segmentationId,\r\n  options: PolySegConversionOptions = {}\r\n): Promise<RawSurfacesData> {\r\n  // Todo: validate valid labelmap representation\r\n  const segmentation = getSegmentation(segmentationId);\r\n\r\n  if (!segmentation?.representationData?.LABELMAP) {\r\n    console.warn('Only support surface update from labelmaps');\r\n    return;\r\n  }\r\n\r\n  const isVolume = isVolumeSegmentation(\r\n    segmentation.representationData.LABELMAP\r\n  );\r\n\r\n  const labelmapRepresentationData = segmentation.representationData.LABELMAP;\r\n\r\n  const segmentIndices =\r\n    options.segmentIndices || getUniqueSegmentIndices(segmentationId);\r\n\r\n  const promises = segmentIndices.map((index) => {\r\n    const surface = convertLabelmapToSurface(\r\n      labelmapRepresentationData as\r\n        | LabelmapSegmentationDataVolume\r\n        | LabelmapSegmentationDataStack,\r\n      index,\r\n      isVolume\r\n    );\r\n\r\n    return surface;\r\n  });\r\n\r\n  const surfaces = await Promise.allSettled(promises);\r\n  const errors = surfaces.filter((p) => p.status === 'rejected');\r\n\r\n  if (errors.length > 0) {\r\n    console.error(errors);\r\n    throw new Error('Failed to convert labelmap to surface');\r\n  }\r\n\r\n  const rawSurfacesData = surfaces\r\n    .map((surface, index) => {\r\n      if (surface.status === 'fulfilled') {\r\n        return { segmentIndex: segmentIndices[index], data: surface.value };\r\n      }\r\n    })\r\n    .filter(Boolean);\r\n\r\n  return rawSurfacesData;\r\n}\r\n\r\n/**\r\n * Computes the surface from contour segmentation.\r\n * @param segmentationId - The ID of the segmentation.\r\n * @param options - The options for surface computation.\r\n * @returns A promise that resolves to the raw surfaces data.\r\n */\r\nasync function computeSurfaceFromContourSegmentation(\r\n  segmentationId: string,\r\n  options: PolySegConversionOptions = {}\r\n): Promise<RawSurfacesData> {\r\n  const segmentation = getSegmentation(segmentationId);\r\n\r\n  const contourRepresentationData = segmentation.representationData.CONTOUR;\r\n\r\n  const segmentIndices =\r\n    options.segmentIndices || getUniqueSegmentIndices(segmentationId);\r\n\r\n  const promises = segmentIndices.map(async (index) => {\r\n    const surface = await convertContourToSurface(\r\n      contourRepresentationData as ContourSegmentationData,\r\n      index\r\n    );\r\n\r\n    return { segmentIndex: index, data: surface };\r\n  });\r\n\r\n  const surfaces = await Promise.all(promises);\r\n\r\n  return surfaces;\r\n}\r\n\r\nexport {\r\n  computeSurfaceFromContourSegmentation,\r\n  computeSurfaceFromLabelmapSegmentation,\r\n};\r\n","import { SegmentationRepresentations } from '../../../../enums';\r\nimport { PolySegConversionOptions } from '../../../../types';\r\nimport { computeAndAddRepresentation } from '../computeAndAddRepresentation';\r\nimport { computeSurfaceData } from './surfaceComputationStrategies';\r\nimport { updateSurfaceData } from './updateSurfaceData';\r\n\r\n/**\r\n * Computes and adds a surface representation for a given segmentation.\r\n * @param segmentationId - The ID of the segmentation.\r\n * @param options - Additional options for computing the surface representation.\r\n * @param options.segmentIndices - The indices of the segments to compute the surface for.\r\n * @param options.segmentationRepresentationUID - The UID of the segmentation representation to compute the surface for.\r\n *\r\n * @returns A promise that resolves when the surface representation is computed and added.\r\n */\r\nexport function computeAndAddSurfaceRepresentation(\r\n  segmentationId: string,\r\n  options: PolySegConversionOptions = {}\r\n) {\r\n  return computeAndAddRepresentation(\r\n    segmentationId,\r\n    SegmentationRepresentations.Surface,\r\n    () => computeSurfaceData(segmentationId, options),\r\n    () => updateSurfaceData(segmentationId)\r\n  );\r\n}\r\n","import { Types, cache } from '@cornerstonejs/core';\r\nimport { getUniqueSegmentIndices } from '../../../../utilities/segmentation';\r\nimport {\r\n  getSegmentation,\r\n  getSegmentationRepresentations,\r\n  getToolGroupIdsWithSegmentation,\r\n} from '../../segmentationState';\r\nimport { triggerSegmentationModified } from '../../triggerSegmentationEvents';\r\nimport { ToolGroupSpecificRepresentations } from '../../../../types/SegmentationStateTypes';\r\nimport { SegmentationRepresentations } from '../../../../enums';\r\nimport { computeSurfaceFromLabelmapSegmentation } from './surfaceComputationStrategies';\r\nimport { createAndCacheSurfacesFromRaw } from './createAndCacheSurfacesFromRaw';\r\n\r\nexport async function updateSurfaceData(segmentationId) {\r\n  const surfacesObj = await computeSurfaceFromLabelmapSegmentation(\r\n    segmentationId\r\n  );\r\n\r\n  if (!surfacesObj) {\r\n    return;\r\n  }\r\n\r\n  const segmentation = getSegmentation(segmentationId);\r\n  const indices = getUniqueSegmentIndices(segmentationId);\r\n\r\n  if (!indices.length) {\r\n    // means all segments were removed so we need to empty out\r\n    // the geometry data\r\n    const geometryIds = segmentation.representationData.SURFACE.geometryIds;\r\n    geometryIds.forEach((geometryId) => {\r\n      const geometry = cache.getGeometry(geometryId);\r\n      const surface = geometry.data as Types.ISurface;\r\n      surface.setPoints([]);\r\n      surface.setPolys([]);\r\n    });\r\n\r\n    triggerSegmentationModified(segmentationId);\r\n\r\n    return;\r\n  }\r\n\r\n  const promises = surfacesObj.map(({ data, segmentIndex }) => {\r\n    const geometryId = `segmentation_${segmentationId}_surface_${segmentIndex}`;\r\n\r\n    const geometry = cache.getGeometry(geometryId);\r\n\r\n    if (!geometry) {\r\n      // means it is a new segment getting added while we were\r\n      // listening to the segmentation data modified event\r\n      const toolGroupIds = getToolGroupIdsWithSegmentation(segmentationId);\r\n\r\n      return toolGroupIds.map((toolGroupId) => {\r\n        const segmentationRepresentations = getSegmentationRepresentations(\r\n          toolGroupId\r\n        ) as ToolGroupSpecificRepresentations;\r\n\r\n        return segmentationRepresentations.map((segmentationRepresentation) => {\r\n          if (\r\n            segmentationRepresentation.type !==\r\n            SegmentationRepresentations.Surface\r\n          ) {\r\n            return;\r\n          }\r\n          segmentation.representationData.SURFACE.geometryIds.set(\r\n            segmentIndex,\r\n            geometryId\r\n          );\r\n\r\n          return createAndCacheSurfacesFromRaw(\r\n            segmentationId,\r\n            [{ segmentIndex, data }],\r\n            {\r\n              segmentationRepresentationUID:\r\n                segmentationRepresentation.segmentationRepresentationUID,\r\n            }\r\n          );\r\n        });\r\n      });\r\n    } else if (indices.includes(segmentIndex)) {\r\n      // if the geometry already exists and the segmentIndex is\r\n      // still present, update the geometry data\r\n      const surface = geometry.data as Types.ISurface;\r\n      surface.setPoints(data.points);\r\n      surface.setPolys(data.polys);\r\n    } else {\r\n      const surface = geometry.data as Types.ISurface;\r\n      surface.setPoints([]);\r\n      surface.setPolys([]);\r\n    }\r\n  });\r\n\r\n  await Promise.all(promises);\r\n\r\n  triggerSegmentationModified(segmentationId);\r\n}\r\n","import { vec3 } from 'gl-matrix';\r\nimport {\r\n  Types,\r\n  cache,\r\n  utilities,\r\n  getWebWorkerManager,\r\n  volumeLoader,\r\n  imageLoader,\r\n  metaData,\r\n  Enums,\r\n  triggerEvent,\r\n  eventTarget,\r\n} from '@cornerstonejs/core';\r\nimport {\r\n  Annotation,\r\n  ContourAnnotation,\r\n  ContourSegmentationData,\r\n  PolySegConversionOptions,\r\n} from '../../../../types';\r\nimport { getAnnotation } from '../../..';\r\nimport { WorkerTypes } from '../../../../enums';\r\n\r\nconst workerManager = getWebWorkerManager();\r\n\r\nconst triggerWorkerProgress = (eventTarget, progress) => {\r\n  triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\r\n    progress,\r\n    type: WorkerTypes.POLYSEG_CONTOUR_TO_LABELMAP,\r\n  });\r\n};\r\n\r\nexport async function convertContourToVolumeLabelmap(\r\n  contourRepresentationData: ContourSegmentationData,\r\n  options: PolySegConversionOptions = {}\r\n) {\r\n  const { viewport } = options;\r\n\r\n  const imageIds = utilities.getViewportImageIds(viewport);\r\n\r\n  if (!imageIds) {\r\n    throw new Error(\r\n      'No imageIds found, labelmap computation from contour requires viewports with imageIds'\r\n    );\r\n  }\r\n\r\n  const segmentationVolumeId = utilities.uuidv4();\r\n\r\n  const volumeProps = utilities.generateVolumePropsFromImageIds(\r\n    imageIds,\r\n    segmentationVolumeId\r\n  );\r\n\r\n  const { metadata, dimensions, origin, direction, spacing, scalarData } =\r\n    volumeProps;\r\n\r\n  const segmentationVolume = await volumeLoader.createLocalSegmentationVolume(\r\n    {\r\n      dimensions,\r\n      origin,\r\n      direction,\r\n      spacing,\r\n      metadata,\r\n      imageIds: imageIds.map((imageId) => `generated://${imageId}`),\r\n      referencedImageIds: imageIds,\r\n    },\r\n    segmentationVolumeId\r\n  );\r\n\r\n  const { segmentIndices, annotationUIDsInSegmentMap } =\r\n    _getAnnotationMapFromSegmentation(contourRepresentationData, options);\r\n\r\n  triggerWorkerProgress(eventTarget, 0);\r\n\r\n  const newScalarData = await workerManager.executeTask(\r\n    'polySeg',\r\n    'convertContourToVolumeLabelmap',\r\n    {\r\n      segmentIndices,\r\n      dimensions,\r\n      scalarData,\r\n      origin,\r\n      direction,\r\n      spacing,\r\n      annotationUIDsInSegmentMap,\r\n    },\r\n    {\r\n      callbacks: [\r\n        (progress) => {\r\n          triggerWorkerProgress(eventTarget, progress);\r\n        },\r\n      ],\r\n    }\r\n  );\r\n\r\n  triggerWorkerProgress(eventTarget, 1);\r\n\r\n  segmentationVolume.imageData\r\n    .getPointData()\r\n    .getScalars()\r\n    .setData(newScalarData);\r\n  segmentationVolume.imageData.modified();\r\n\r\n  // update the scalarData in the volume as well\r\n  segmentationVolume.modified();\r\n\r\n  return {\r\n    volumeId: segmentationVolume.volumeId,\r\n  };\r\n}\r\n\r\nexport async function convertContourToStackLabelmap(\r\n  contourRepresentationData: ContourSegmentationData,\r\n  options: PolySegConversionOptions = {}\r\n) {\r\n  if (!options.viewport) {\r\n    throw new Error(\r\n      'No viewport provided, labelmap computation from contour requires viewports'\r\n    );\r\n  }\r\n\r\n  const viewport = options.viewport as Types.IStackViewport;\r\n\r\n  const imageIds = viewport.getImageIds();\r\n\r\n  if (!imageIds) {\r\n    throw new Error(\r\n      'No imageIds found, labelmap computation from contour requires viewports with imageIds'\r\n    );\r\n  }\r\n\r\n  // check if the imageIds are already cached\r\n  imageIds.forEach((imageId) => {\r\n    if (!cache.getImageLoadObject(imageId)) {\r\n      throw new Error(\r\n        'ImageIds must be cached before converting contour to labelmap'\r\n      );\r\n    }\r\n  });\r\n\r\n  // create\r\n  const { imageIds: segmentationImageIds } =\r\n    await imageLoader.createAndCacheDerivedSegmentationImages(imageIds);\r\n\r\n  const { segmentIndices, annotationUIDsInSegmentMap } =\r\n    _getAnnotationMapFromSegmentation(contourRepresentationData, options);\r\n\r\n  // information for the referenced to the segmentation image\r\n  // Define constant to hold segmentation information\r\n  const segmentationsInfo = new Map();\r\n\r\n  // Loop through each segmentation image ID\r\n  segmentationImageIds.forEach((segImageId, index) => {\r\n    // Fetch the image from cache\r\n    const segImage = cache.getImage(segImageId);\r\n\r\n    // Fetch metadata for the image\r\n    const imagePlaneModule = metaData.get(\r\n      Enums.MetadataModules.IMAGE_PLANE,\r\n      segImageId\r\n    );\r\n\r\n    // Extract properties from image metadata\r\n    let {\r\n      columnCosines,\r\n      rowCosines,\r\n      rowPixelSpacing,\r\n      columnPixelSpacing,\r\n      imagePositionPatient,\r\n    } = imagePlaneModule;\r\n\r\n    // Set defaults if necessary\r\n    columnCosines = columnCosines ?? [0, 1, 0];\r\n    rowCosines = rowCosines ?? [1, 0, 0];\r\n    rowPixelSpacing = rowPixelSpacing ?? 1;\r\n    columnPixelSpacing = columnPixelSpacing ?? 1;\r\n    imagePositionPatient = imagePositionPatient ?? [0, 0, 0];\r\n\r\n    // Create vector from row and column cosines\r\n    const rowCosineVec = vec3.fromValues(\r\n      rowCosines[0],\r\n      rowCosines[1],\r\n      rowCosines[2]\r\n    );\r\n    const colCosineVec = vec3.fromValues(\r\n      columnCosines[0],\r\n      columnCosines[1],\r\n      columnCosines[2]\r\n    );\r\n\r\n    // Calculate scan axis normal\r\n    const scanAxisNormal = vec3.create();\r\n    vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);\r\n\r\n    // Define direction and spacing\r\n    const direction = [...rowCosineVec, ...colCosineVec, ...scanAxisNormal];\r\n    const spacing = [rowPixelSpacing, columnPixelSpacing, 1];\r\n\r\n    // Set origin\r\n    const origin = imagePositionPatient;\r\n\r\n    // Store segmentation information\r\n    segmentationsInfo.set(imageIds[index], {\r\n      direction,\r\n      spacing,\r\n      origin,\r\n      scalarData: segImage.getPixelData(),\r\n      imageId: segImageId,\r\n      dimensions: [segImage.width, segImage.height, 1],\r\n    });\r\n  });\r\n\r\n  triggerWorkerProgress(eventTarget, 0);\r\n\r\n  const newSegmentationsScalarData = await workerManager.executeTask(\r\n    'polySeg',\r\n    'convertContourToStackLabelmap',\r\n    {\r\n      segmentationsInfo,\r\n      annotationUIDsInSegmentMap,\r\n      segmentIndices,\r\n    },\r\n    {\r\n      callbacks: [\r\n        (progress) => {\r\n          triggerWorkerProgress(eventTarget, progress);\r\n        },\r\n      ],\r\n    }\r\n  );\r\n\r\n  triggerWorkerProgress(eventTarget, 1);\r\n\r\n  const imageIdReferenceMap = new Map();\r\n  newSegmentationsScalarData.forEach(({ scalarData }, referencedImageId) => {\r\n    const segmentationInfo = segmentationsInfo.get(referencedImageId);\r\n    const { imageId: segImageId } = segmentationInfo;\r\n\r\n    const segImage = cache.getImage(segImageId);\r\n    segImage.getPixelData().set(scalarData);\r\n    segImage.imageFrame?.pixelData?.set(scalarData);\r\n\r\n    imageIdReferenceMap.set(referencedImageId, segImageId);\r\n  });\r\n\r\n  return {\r\n    imageIdReferenceMap,\r\n  };\r\n}\r\n\r\nfunction _getAnnotationMapFromSegmentation(\r\n  contourRepresentationData: ContourSegmentationData,\r\n  options: PolySegConversionOptions = {}\r\n) {\r\n  const annotationMap = contourRepresentationData.annotationUIDsMap;\r\n\r\n  const segmentIndices = options.segmentIndices?.length\r\n    ? options.segmentIndices\r\n    : Array.from(annotationMap.keys());\r\n\r\n  const annotationUIDsInSegmentMap = new Map<number, any>();\r\n  segmentIndices.forEach((index) => {\r\n    const annotationUIDsInSegment = annotationMap.get(index);\r\n\r\n    // Todo: there is a bug right now where the annotationUIDsInSegment has both\r\n    // children and parent annotations, so we need to filter out the parent\r\n    // annotations only\r\n\r\n    let uids = Array.from(annotationUIDsInSegment);\r\n\r\n    uids = uids.filter(\r\n      (uid) => !(getAnnotation(uid) as Annotation).parentAnnotationUID\r\n    );\r\n\r\n    const annotations = uids.map((uid) => {\r\n      const annotation = getAnnotation(uid) as ContourAnnotation;\r\n      const hasChildAnnotations = annotation.childAnnotationUIDs?.length;\r\n\r\n      return {\r\n        polyline: annotation.data.contour.polyline,\r\n        referencedImageId: annotation.metadata.referencedImageId,\r\n        holesPolyline:\r\n          hasChildAnnotations &&\r\n          annotation.childAnnotationUIDs.map((childUID) => {\r\n            const childAnnotation = getAnnotation(\r\n              childUID\r\n            ) as ContourAnnotation;\r\n            return childAnnotation.data.contour.polyline;\r\n          }),\r\n      };\r\n    });\r\n\r\n    annotationUIDsInSegmentMap.set(index, annotations);\r\n  });\r\n\r\n  return { segmentIndices, annotationUIDsInSegmentMap };\r\n}\r\n","import {\r\n  Enums,\r\n  Types,\r\n  cache,\r\n  eventTarget,\r\n  getWebWorkerManager,\r\n  triggerEvent,\r\n} from '@cornerstonejs/core';\r\nimport { SurfaceSegmentationData } from '../../../../types/SurfaceTypes';\r\nimport { WorkerTypes } from '../../../../enums';\r\n\r\nconst workerManager = getWebWorkerManager();\r\n\r\nconst triggerWorkerProgress = (eventTarget, progress) => {\r\n  triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\r\n    progress,\r\n    type: WorkerTypes.POLYSEG_SURFACE_TO_LABELMAP,\r\n  });\r\n};\r\n\r\nexport async function convertSurfaceToVolumeLabelmap(\r\n  surfaceRepresentationData: SurfaceSegmentationData,\r\n  segmentationVolume: Types.IImageVolume\r\n) {\r\n  const { geometryIds } = surfaceRepresentationData;\r\n  if (!geometryIds?.size) {\r\n    throw new Error('No geometry IDs found for surface representation');\r\n  }\r\n\r\n  const segmentsInfo = new Map() as Map<\r\n    number,\r\n    {\r\n      points: number[];\r\n      polys: number[];\r\n    }\r\n  >;\r\n\r\n  geometryIds.forEach((geometryId, segmentIndex) => {\r\n    const geometry = cache.getGeometry(geometryId);\r\n    const geometryData = geometry.data as Types.ISurface;\r\n    const points = geometryData.getPoints();\r\n    const polys = geometryData.getPolys();\r\n\r\n    segmentsInfo.set(segmentIndex, {\r\n      points,\r\n      polys,\r\n    });\r\n  });\r\n\r\n  const { dimensions, direction, origin, spacing } = segmentationVolume;\r\n\r\n  triggerWorkerProgress(eventTarget, 0);\r\n\r\n  const newScalarData = await workerManager.executeTask(\r\n    'polySeg',\r\n    'convertSurfacesToVolumeLabelmap',\r\n    {\r\n      segmentsInfo,\r\n      dimensions,\r\n      spacing,\r\n      direction,\r\n      origin,\r\n    },\r\n    {\r\n      callbacks: [\r\n        (progress) => {\r\n          triggerWorkerProgress(eventTarget, progress);\r\n        },\r\n      ],\r\n    }\r\n  );\r\n\r\n  triggerWorkerProgress(eventTarget, 1);\r\n\r\n  segmentationVolume.imageData\r\n    .getPointData()\r\n    .getScalars()\r\n    .setData(newScalarData);\r\n  segmentationVolume.imageData.modified();\r\n\r\n  // update the scalarData in the volume as well\r\n  segmentationVolume.modified();\r\n\r\n  return {\r\n    volumeId: segmentationVolume.volumeId,\r\n  };\r\n}\r\n\r\nexport async function convertSurfaceToStackLabelmap() {\r\n  // TODO\r\n}\r\n","import { VolumeViewport, volumeLoader, utilities } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport { getUniqueSegmentIndices } from '../../../../utilities/segmentation';\r\nimport { getSegmentation } from '../../segmentationState';\r\nimport {\r\n  LabelmapSegmentationDataStack,\r\n  LabelmapSegmentationDataVolume,\r\n} from '../../../../types/LabelmapTypes';\r\nimport {\r\n  convertContourToStackLabelmap,\r\n  convertContourToVolumeLabelmap,\r\n} from './convertContourToLabelmap';\r\nimport { convertSurfaceToVolumeLabelmap } from './convertSurfaceToLabelmap';\r\nimport { computeStackSegmentationFromVolume } from '../../convertVolumeToStackSegmentation';\r\nimport { PolySegConversionOptions } from '../../../../types';\r\n\r\nexport type RawLabelmapData =\r\n  | LabelmapSegmentationDataVolume\r\n  | LabelmapSegmentationDataStack;\r\n\r\nexport async function computeLabelmapData(\r\n  segmentationId: string,\r\n  options: PolySegConversionOptions = {}\r\n) {\r\n  const segmentIndices = options.segmentIndices?.length\r\n    ? options.segmentIndices\r\n    : getUniqueSegmentIndices(segmentationId);\r\n\r\n  let rawLabelmapData: RawLabelmapData;\r\n  const segmentation = getSegmentation(segmentationId);\r\n  const representationData = segmentation.representationData;\r\n\r\n  try {\r\n    if (representationData.CONTOUR) {\r\n      rawLabelmapData = await computeLabelmapFromContourSegmentation(\r\n        segmentationId,\r\n        {\r\n          segmentIndices,\r\n          ...options,\r\n        }\r\n      );\r\n    } else if (representationData.SURFACE) {\r\n      rawLabelmapData = await computeLabelmapFromSurfaceSegmentation(\r\n        segmentation.segmentationId,\r\n        {\r\n          segmentIndices,\r\n          ...options,\r\n        }\r\n      );\r\n    }\r\n  } catch (error) {\r\n    console.error(error);\r\n    throw error;\r\n  }\r\n\r\n  if (!rawLabelmapData) {\r\n    throw new Error(\r\n      'Not enough data to convert to surface, currently only support converting volume labelmap to surface if available'\r\n    );\r\n  }\r\n\r\n  return rawLabelmapData;\r\n}\r\n\r\nasync function computeLabelmapFromContourSegmentation(\r\n  segmentationId,\r\n  options: PolySegConversionOptions = {}\r\n): Promise<LabelmapSegmentationDataVolume | LabelmapSegmentationDataStack> {\r\n  const isVolume = options.viewport instanceof VolumeViewport ?? true;\r\n\r\n  if (isVolume && !options.viewport) {\r\n    // Todo: we don't have support for volume viewport without providing the\r\n    // viewport, since we need to get the referenced volumeId from the viewport\r\n    // but we can alternatively provide the volumeId directly, or even better\r\n    // the target metadata for the volume (spacing, origin, dimensions, etc.)\r\n    // and then we can create the volume from that\r\n    throw new Error(\r\n      'Cannot compute labelmap from contour segmentation without providing the viewport'\r\n    );\r\n  }\r\n\r\n  const segmentIndices = options.segmentIndices?.length\r\n    ? options.segmentIndices\r\n    : getUniqueSegmentIndices(segmentationId);\r\n\r\n  const segmentation = getSegmentation(segmentationId);\r\n  const representationData = segmentation.representationData.CONTOUR;\r\n\r\n  const convertFunction = isVolume\r\n    ? convertContourToVolumeLabelmap\r\n    : convertContourToStackLabelmap;\r\n\r\n  const result = await convertFunction(representationData, {\r\n    segmentIndices,\r\n    segmentationRepresentationUID: options.segmentationRepresentationUID,\r\n    viewport: options.viewport,\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\nasync function computeLabelmapFromSurfaceSegmentation(\r\n  segmentationId,\r\n  options: PolySegConversionOptions = {}\r\n): Promise<LabelmapSegmentationDataVolume | LabelmapSegmentationDataStack> {\r\n  const isVolume = options.viewport instanceof VolumeViewport ?? true;\r\n\r\n  const segmentIndices = options.segmentIndices?.length\r\n    ? options.segmentIndices\r\n    : getUniqueSegmentIndices(segmentationId);\r\n\r\n  const segmentation = getSegmentation(segmentationId);\r\n\r\n  const segmentsGeometryIds = new Map() as Map<number, string>;\r\n  const representationData = segmentation.representationData.SURFACE;\r\n  representationData.geometryIds.forEach((geometryId, segmentIndex) => {\r\n    if (segmentIndices.includes(segmentIndex)) {\r\n      segmentsGeometryIds.set(segmentIndex, geometryId);\r\n    }\r\n  });\r\n\r\n  if (isVolume && !options.viewport) {\r\n    // Todo: we don't have support for volume viewport without providing the\r\n    // viewport, since we need to get the referenced volumeId from the viewport\r\n    // but we can alternatively provide the volumeId directly, or even better\r\n    // the target metadata for the volume (spacing, origin, dimensions, etc.)\r\n    // and then we can create the volume from that\r\n    throw new Error(\r\n      'Cannot compute labelmap from surface segmentation without providing the viewport'\r\n    );\r\n  }\r\n\r\n  let segmentationVolume;\r\n  if (isVolume) {\r\n    const defaultActor = options.viewport.getDefaultActor();\r\n    const { uid: volumeId } = defaultActor;\r\n    segmentationVolume =\r\n      await volumeLoader.createAndCacheDerivedSegmentationVolume(volumeId);\r\n  } else {\r\n    // for stack we basically need to create a volume from the stack\r\n    // imageIds and then create a segmentation volume from that and finally\r\n    // convert the surface to a labelmap and later on convert the labelmap\r\n    // to a stack labelmap\r\n    const imageIds = (options.viewport as Types.IStackViewport).getImageIds();\r\n    const volumeId = 'generatedSegmentationVolumeId';\r\n    const volumeProps = utilities.generateVolumePropsFromImageIds(\r\n      imageIds,\r\n      volumeId\r\n    );\r\n\r\n    // we don't need the imageIds for the viewport (e.g., CT), but rather\r\n    // want to use the imageIds as a reference\r\n    delete volumeProps.imageIds;\r\n\r\n    segmentationVolume = await volumeLoader.createLocalSegmentationVolume(\r\n      {\r\n        ...volumeProps,\r\n        scalarData: volumeProps.scalarData as Types.PixelDataTypedArray,\r\n        referencedImageIds: imageIds,\r\n      },\r\n      volumeId\r\n    );\r\n  }\r\n\r\n  const result = await convertSurfaceToVolumeLabelmap(\r\n    { geometryIds: segmentsGeometryIds },\r\n    segmentationVolume\r\n  );\r\n\r\n  if (isVolume) {\r\n    return result;\r\n  }\r\n\r\n  // we need to convert the volume labelmap to a stack labelmap\r\n  const stackData = (await computeStackSegmentationFromVolume({\r\n    volumeId: segmentationVolume.volumeId,\r\n  })) as LabelmapSegmentationDataStack;\r\n\r\n  return stackData;\r\n}\r\n\r\nexport { computeLabelmapFromContourSegmentation };\r\n","import { SegmentationRepresentations } from '../../../../enums';\r\nimport { computeAndAddRepresentation } from '../computeAndAddRepresentation';\r\nimport { computeLabelmapData } from './labelmapComputationStrategies';\r\nimport { PolySegConversionOptions } from '../../../../types';\r\n\r\n/**\r\n * Computes and adds the labelmap representation for a given segmentation.\r\n *\r\n * @param segmentationId - The ID of the segmentation.\r\n * @param options - Optional parameters for computing the labelmap representation.\r\n * @param options.segmentIndices - An array of segment indices to include in the labelmap representation.\r\n * @param options.segmentationRepresentationUID - The UID of the segmentation representation.\r\n * @returns A promise that resolves when the labelmap representation is computed and added.\r\n */\r\nexport function computeAndAddLabelmapRepresentation(\r\n  segmentationId: string,\r\n  options: PolySegConversionOptions = {}\r\n) {\r\n  return computeAndAddRepresentation(\r\n    segmentationId,\r\n    SegmentationRepresentations.Labelmap,\r\n    () => computeLabelmapData(segmentationId, options),\r\n    () => undefined\r\n  );\r\n}\r\n","import { PolyDataClipCacheType } from '../../../helpers/clipAndCacheSurfacesForViewport';\r\nimport { RawContourData } from '../contourComputationStrategies';\r\n\r\n/**\r\n * Extracts contour data from the given polyDataCache.\r\n * @param polyDataCache - The polyData cache containing intersection information.\r\n * @param segmentIndexMap - Optional map for mapping surface IDs to segment indices.\r\n * @returns A map of segment indices to an array of contour results.\r\n */\r\nexport function extractContourData(\r\n  polyDataCache: PolyDataClipCacheType,\r\n  segmentIndexMap?: Map<string, number>\r\n) {\r\n  const rawResults = new Map() as RawContourData;\r\n\r\n  for (const [cacheId, intersectionInfo] of polyDataCache) {\r\n    // Todo; fix this\r\n    const surfaceId = cacheId.split('_')[1];\r\n\r\n    for (const [_, result] of intersectionInfo) {\r\n      if (!result) {\r\n        continue;\r\n      }\r\n      const segmentIndex = Number(surfaceId) || segmentIndexMap?.get(surfaceId);\r\n\r\n      if (!segmentIndex) {\r\n        continue;\r\n      }\r\n\r\n      if (!rawResults.has(segmentIndex)) {\r\n        rawResults.set(segmentIndex, []);\r\n      }\r\n\r\n      rawResults.get(segmentIndex).push(result);\r\n    }\r\n  }\r\n  return rawResults;\r\n}\r\n","import { PlanarFreehandContourSegmentationTool } from '../../../../../tools';\r\nimport { addAnnotation } from '../../../../annotation/annotationState';\r\nimport { RawContourData } from '../contourComputationStrategies';\r\nimport { utilities, type Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Creates and adds contour segmentations from a clipped surface.\r\n *\r\n * @param rawContourData - The raw contour data.\r\n * @param viewport - The viewport.\r\n * @param segmentationId - The segmentation ID.\r\n */\r\nexport function createAndAddContourSegmentationsFromClippedSurfaces(\r\n  rawContourData: RawContourData,\r\n  viewport: Types.IViewport,\r\n  segmentationId: string\r\n) {\r\n  const annotationUIDsMap = new Map<number, Set<string>>();\r\n\r\n  for (const [segmentIndex, contoursData] of rawContourData) {\r\n    for (const contourData of contoursData) {\r\n      const { points } = contourData;\r\n\r\n      const { lineSegments, linesNumberOfPoints } =\r\n        _extractLineSegments(contourData);\r\n\r\n      // There may be a few lines as the surface might not be closed and could have holes in it.\r\n      // Currently, we simply render the generated contour as empty fill to indicate\r\n      // the presence of holes. However, filling the proper area with\r\n      //  fillAlpha requires further work.\r\n      for (let i = 0; i < lineSegments.length; i++) {\r\n        const line = lineSegments[i];\r\n        const polyline = [];\r\n\r\n        for (let j = 0; j < linesNumberOfPoints[i]; j++) {\r\n          const pointIndex = line[j];\r\n          polyline.push([\r\n            points[3 * pointIndex],\r\n            points[3 * pointIndex + 1],\r\n            points[3 * pointIndex + 2],\r\n          ]);\r\n        }\r\n\r\n        if (polyline.length < 3) {\r\n          continue;\r\n        }\r\n\r\n        const contourSegmentationAnnotation = {\r\n          annotationUID: utilities.uuidv4(),\r\n          data: {\r\n            contour: {\r\n              closed: true,\r\n              polyline,\r\n            },\r\n            segmentation: {\r\n              segmentationId,\r\n              segmentIndex,\r\n            },\r\n            handles: {},\r\n          },\r\n          handles: {},\r\n          highlighted: false,\r\n          autoGenerated: false,\r\n          invalidated: false,\r\n          isLocked: false,\r\n          isVisible: true,\r\n          metadata: {\r\n            toolName: PlanarFreehandContourSegmentationTool.toolName,\r\n            ...viewport.getViewReference(),\r\n          },\r\n        };\r\n\r\n        addAnnotation(contourSegmentationAnnotation, viewport.element);\r\n\r\n        const currentSet = annotationUIDsMap.get(segmentIndex) || new Set();\r\n        currentSet.add(contourSegmentationAnnotation.annotationUID);\r\n        annotationUIDsMap.set(segmentIndex, currentSet);\r\n      }\r\n    }\r\n  }\r\n\r\n  return annotationUIDsMap;\r\n}\r\n\r\nconst _extractLineSegments = (contourData) => {\r\n  const { numberOfCells, lines } = contourData;\r\n\r\n  const lineSegments = [];\r\n  const linesNumberOfPoints = [];\r\n\r\n  for (let i = 0; i < lines.length; ) {\r\n    const pointsInLine = lines[i];\r\n    linesNumberOfPoints.push(pointsInLine);\r\n    lineSegments.push(lines.slice(i + 1, i + pointsInLine + 1));\r\n    i += pointsInLine + 1;\r\n\r\n    if (lineSegments.length === numberOfCells) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  return { lineSegments, linesNumberOfPoints };\r\n};\r\n","import { cache } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport { getUniqueSegmentIndices } from '../../../../utilities/segmentation';\r\nimport {\r\n  getSegmentation,\r\n  setSegmentationRepresentationSpecificConfig,\r\n} from '../../segmentationState';\r\nimport { PolySegConversionOptions } from '../../../../types';\r\nimport { computeSurfaceFromLabelmapSegmentation } from '../Surface/surfaceComputationStrategies';\r\nimport {\r\n  SurfaceClipResult,\r\n  clipAndCacheSurfacesForViewport,\r\n} from '../../helpers/clipAndCacheSurfacesForViewport';\r\nimport { extractContourData } from './utils/extractContourData';\r\nimport { createAndAddContourSegmentationsFromClippedSurfaces } from './utils/createAndAddContourSegmentationsFromClippedSurfaces';\r\nimport { getToolGroupForViewport } from '../../../../store/ToolGroupManager';\r\n\r\n// the map between segment index and the intersection points and lines\r\nexport type RawContourData = Map<number, SurfaceClipResult[]>;\r\n\r\n/**\r\n * Computes contour data for a given segmentation.\r\n * @param segmentationId - The ID of the segmentation.\r\n * @param options - Optional parameters for the computation.\r\n * @returns An object containing the annotation UIDs map.\r\n * @throws Error if there is not enough data to convert to contour.\r\n */\r\nexport async function computeContourData(\r\n  segmentationId: string,\r\n  options: PolySegConversionOptions = {}\r\n) {\r\n  const segmentIndices = options.segmentIndices?.length\r\n    ? options.segmentIndices\r\n    : getUniqueSegmentIndices(segmentationId);\r\n\r\n  let rawContourData: RawContourData;\r\n  const segmentation = getSegmentation(segmentationId);\r\n  const representationData = segmentation.representationData;\r\n\r\n  try {\r\n    if (representationData.SURFACE) {\r\n      rawContourData = await computeContourFromSurfaceSegmentation(\r\n        segmentationId,\r\n        {\r\n          segmentIndices,\r\n          ...options,\r\n        }\r\n      );\r\n    } else if (representationData.LABELMAP) {\r\n      rawContourData = await computeContourFromLabelmapSegmentation(\r\n        segmentationId,\r\n        {\r\n          segmentIndices,\r\n          ...options,\r\n        }\r\n      );\r\n    }\r\n  } catch (error) {\r\n    console.error(error);\r\n    throw error;\r\n  }\r\n\r\n  if (!rawContourData) {\r\n    throw new Error(\r\n      'Not enough data to convert to contour, currently only support converting volume labelmap to contour if available'\r\n    );\r\n  }\r\n\r\n  const { viewport, segmentationRepresentationUID } = options;\r\n\r\n  // create the new annotations and add them to the segmentation state representation\r\n  // data for the contour representation\r\n  const annotationUIDsMap = createAndAddContourSegmentationsFromClippedSurfaces(\r\n    rawContourData,\r\n    viewport,\r\n    segmentationId\r\n  );\r\n\r\n  // make the segmentation configuration fillAlpha 0 since\r\n  // we don't have proper hole support right now\r\n  // Todo: add hole support\r\n  const toolGroupId = getToolGroupForViewport(viewport.id)?.id;\r\n\r\n  setSegmentationRepresentationSpecificConfig(\r\n    toolGroupId,\r\n    segmentationRepresentationUID,\r\n    {\r\n      CONTOUR: {\r\n        fillAlpha: 0,\r\n      },\r\n    }\r\n  );\r\n\r\n  return {\r\n    annotationUIDsMap,\r\n  };\r\n}\r\n\r\n/**\r\n * Computes the contour from a labelmap segmentation.\r\n * @param segmentationId - The ID of the segmentation.\r\n * @param options - The options for the contour computation.\r\n * @returns The raw contour data.\r\n */\r\nasync function computeContourFromLabelmapSegmentation(\r\n  segmentationId,\r\n  options: PolySegConversionOptions = {}\r\n) {\r\n  if (!options.viewport) {\r\n    throw new Error('Viewport is required to compute contour from labelmap');\r\n  }\r\n\r\n  const results = await computeSurfaceFromLabelmapSegmentation(\r\n    segmentationId,\r\n    options\r\n  );\r\n\r\n  if (!results?.length) {\r\n    console.error('Failed to convert labelmap to surface or labelmap is empty');\r\n    return;\r\n  }\r\n\r\n  const { viewport, segmentationRepresentationUID } = options;\r\n\r\n  const pointsAndPolys = results.map((surface) => {\r\n    return {\r\n      id: surface.segmentIndex.toString(),\r\n      points: surface.data.points,\r\n      polys: surface.data.polys,\r\n      segmentIndex: surface.segmentIndex,\r\n    };\r\n  });\r\n\r\n  const polyDataCache = await clipAndCacheSurfacesForViewport(\r\n    pointsAndPolys,\r\n    viewport as Types.IVolumeViewport,\r\n    segmentationRepresentationUID\r\n  );\r\n\r\n  const rawResults = extractContourData(polyDataCache);\r\n\r\n  return rawResults;\r\n}\r\n\r\n/**\r\n * Computes the contour from a surface segmentation.\r\n * @param segmentationId - The ID of the segmentation.\r\n * @param options - The options for the contour computation.\r\n * @returns A promise that resolves to the raw contour data.\r\n * @throws An error if the viewport is not provided.\r\n */\r\nasync function computeContourFromSurfaceSegmentation(\r\n  segmentationId,\r\n  options: PolySegConversionOptions = {}\r\n): Promise<RawContourData> {\r\n  if (!options.viewport) {\r\n    throw new Error('Viewport is required to compute contour from surface');\r\n  }\r\n  const { viewport, segmentationRepresentationUID } = options;\r\n\r\n  const segmentIndices = options.segmentIndices?.length\r\n    ? options.segmentIndices\r\n    : getUniqueSegmentIndices(segmentationId);\r\n\r\n  const segmentIndexToSurfaceId = new Map() as Map<number, string>;\r\n  const surfaceIdToSegmentIndex = new Map() as Map<string, number>;\r\n\r\n  const segmentation = getSegmentation(segmentationId);\r\n  const representationData = segmentation.representationData.SURFACE;\r\n\r\n  const surfacesInfo = [];\r\n  representationData.geometryIds.forEach((geometryId, segmentIndex) => {\r\n    if (segmentIndices.includes(segmentIndex)) {\r\n      segmentIndexToSurfaceId.set(segmentIndex, geometryId);\r\n      const surface = cache.getGeometry(geometryId)?.data as Types.ISurface;\r\n      if (surface) {\r\n        surfacesInfo.push({\r\n          id: geometryId,\r\n          points: surface.getPoints(),\r\n          polys: surface.getPolys(),\r\n        });\r\n      }\r\n    }\r\n  });\r\n\r\n  segmentIndexToSurfaceId.forEach((surfaceId, segmentIndex) => {\r\n    surfaceIdToSegmentIndex.set(surfaceId, segmentIndex);\r\n  });\r\n\r\n  const polyDataCache = await clipAndCacheSurfacesForViewport(\r\n    surfacesInfo,\r\n    viewport as Types.IVolumeViewport,\r\n    segmentationRepresentationUID\r\n  );\r\n\r\n  const rawResults = extractContourData(polyDataCache, surfaceIdToSegmentIndex);\r\n\r\n  return rawResults;\r\n}\r\n\r\nexport { computeContourFromLabelmapSegmentation };\r\n","import { SegmentationRepresentations } from '../../../../enums';\r\nimport { PolySegConversionOptions } from '../../../../types';\r\nimport { computeAndAddRepresentation } from '../computeAndAddRepresentation';\r\nimport { computeContourData } from './contourComputationStrategies';\r\n/**\r\n * Computes and adds the contour representation for a given segmentation.\r\n *\r\n * @param segmentationId - The ID of the segmentation.\r\n * @param options - Optional parameters for computing the labelmap representation.\r\n * @param options.segmentIndices - An array of segment indices to include in the labelmap representation.\r\n * @param options.segmentationRepresentationUID - The UID of the segmentation representation.\r\n * @returns A promise that resolves when the labelmap representation is computed and added.\r\n */\r\nexport function computeAndAddContourRepresentation(\r\n  segmentationId: string,\r\n  options: PolySegConversionOptions = {}\r\n) {\r\n  return computeAndAddRepresentation(\r\n    segmentationId,\r\n    SegmentationRepresentations.Contour,\r\n    () => computeContourData(segmentationId, options),\r\n    () => undefined\r\n  );\r\n}\r\n","import { SegmentationRepresentations } from '../../../enums';\r\nimport { validateLabelmap } from '../../../tools/displayTools/Labelmap';\r\nimport { SegmentationRepresentationData } from '../../../types';\r\nimport {\r\n  findSegmentationRepresentationByUID,\r\n  getSegmentation,\r\n} from '../segmentationState';\r\n\r\n// Map of conversion paths between source and target representations\r\n// You should read it as \"source\" -> \"targets\"\r\nconst conversionPaths = new Map<\r\n  SegmentationRepresentations,\r\n  Set<SegmentationRepresentations>\r\n>([\r\n  [\r\n    SegmentationRepresentations.Labelmap,\r\n    new Set([\r\n      SegmentationRepresentations.Surface,\r\n      SegmentationRepresentations.Contour,\r\n    ]),\r\n  ],\r\n  [\r\n    SegmentationRepresentations.Contour,\r\n    new Set([\r\n      SegmentationRepresentations.Labelmap,\r\n      SegmentationRepresentations.Surface,\r\n    ]),\r\n  ],\r\n  [\r\n    SegmentationRepresentations.Surface,\r\n    new Set([SegmentationRepresentations.Labelmap]),\r\n  ],\r\n]);\r\n\r\n/**\r\n * Determines whether the requested representation can be computed, based on\r\n * the existing representation types and available conversion paths.\r\n * This is used in the labelmapDisplay and surfaceDisplay logic if the\r\n * requested representation is not available whether we can use the existing\r\n * representation to compute the requested representation. You can checkout the polySeg\r\n * examples to see how this is used polyDataActorManipulationTools and others\r\n *\r\n * @param segmentationRepresentationUID - The UID of the desired segmentation representation.\r\n * @returns true if the requested representation can be computed, otherwise false.\r\n */\r\nfunction canComputeRequestedRepresentation(\r\n  segmentationRepresentationUID: string\r\n): boolean {\r\n  const representationInfo = findSegmentationRepresentationByUID(\r\n    segmentationRepresentationUID\r\n  );\r\n\r\n  if (!representationInfo?.segmentationRepresentation) {\r\n    return false;\r\n  }\r\n\r\n  const { segmentationRepresentation } = representationInfo;\r\n  const { type: representationType, polySeg } = segmentationRepresentation;\r\n\r\n  if (!polySeg || !polySeg.enabled) {\r\n    return false;\r\n  }\r\n\r\n  const { representationData } = getSegmentation(\r\n    segmentationRepresentation.segmentationId\r\n  );\r\n\r\n  const existingRepresentationTypes =\r\n    getExistingRepresentationTypes(representationData);\r\n\r\n  return existingRepresentationTypes.some((existingRepresentationType) =>\r\n    canConvertFromTo(existingRepresentationType, representationType)\r\n  );\r\n}\r\n\r\n/**\r\n * Retrieves the existing representation types for the given representationData\r\n * by verifying the validity of each representation type.\r\n *\r\n * @param representationData - The representation data\r\n * @returns supportedTypes - An array of valid representation types\r\n */\r\nfunction getExistingRepresentationTypes(\r\n  representationData: SegmentationRepresentationData\r\n): string[] {\r\n  const supportedTypes: string[] = [];\r\n\r\n  Object.keys(representationData).forEach((representationType) => {\r\n    const representationTypeData = representationData[representationType];\r\n\r\n    let validateFn;\r\n    switch (representationType) {\r\n      case SegmentationRepresentations.Labelmap:\r\n        validateFn = validateLabelmap;\r\n        break;\r\n      // Todo: add validation for other representation types\r\n    }\r\n\r\n    if (validateFn) {\r\n      try {\r\n        validateFn(representationTypeData);\r\n        supportedTypes.push(representationType);\r\n      } catch (error) {\r\n        console.warn(\r\n          `Validation failed for labelmap of type ${representationType}`\r\n        );\r\n      }\r\n    } else {\r\n      supportedTypes.push(representationType);\r\n    }\r\n  });\r\n\r\n  return supportedTypes;\r\n}\r\n\r\nasync function canConvertFromTo(fromRepresentationType, toRepresentationType) {\r\n  return (\r\n    conversionPaths.get(fromRepresentationType)?.has(toRepresentationType) ||\r\n    false\r\n  );\r\n}\r\n\r\nexport { canComputeRequestedRepresentation };\r\n","import { getWebWorkerManager } from '@cornerstonejs/core';\r\n\r\nlet registered = false;\r\n\r\nexport function registerPolySegWorker() {\r\n  if (registered) {\r\n    return;\r\n  }\r\n\r\n  registered = true;\r\n\r\n  const workerFn = () => {\r\n    // @ts-ignore\r\n    return new Worker(\r\n      // @ts-ignore\r\n      new URL('../../../workers/polySegConverters', import.meta.url),\r\n      {\r\n        name: 'polySeg',\r\n      }\r\n    );\r\n  };\r\n\r\n  const workerManager = getWebWorkerManager();\r\n\r\n  const options = {\r\n    maxWorkerInstances: 1, // Todo, make this configurable\r\n    autoTerminateOnIdle: {\r\n      enabled: true,\r\n      idleTimeThreshold: 2000,\r\n    },\r\n  };\r\n\r\n  workerManager.registerWorker('polySeg', workerFn, options);\r\n}\r\n","import { invalidateBrushCursor } from '../../utilities/segmentation/';\r\nimport {\r\n  getSegmentation,\r\n  getToolGroupIdsWithSegmentation,\r\n} from './segmentationState';\r\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\r\n\r\n/**\r\n * Set the active segment index for a segmentation Id. It fires a global state\r\n * modified event. Also it invalidates the brush cursor for all toolGroups that\r\n * has the segmentationId as active segment (since the brush cursor color\r\n * should change as well)\r\n *\r\n * @triggers SEGMENTATION_MODIFIED\r\n * @param segmentationId - The id of the segmentation that the segment belongs to.\r\n * @param segmentIndex - The index of the segment to be activated.\r\n */\r\nfunction setActiveSegmentIndex(\r\n  segmentationId: string,\r\n  segmentIndex: number\r\n): void {\r\n  const segmentation = getSegmentation(segmentationId);\r\n\r\n  if (typeof segmentIndex === 'string') {\r\n    console.warn('segmentIndex is a string, converting to number');\r\n    segmentIndex = Number(segmentIndex);\r\n  }\r\n\r\n  if (segmentation?.activeSegmentIndex !== segmentIndex) {\r\n    segmentation.activeSegmentIndex = segmentIndex;\r\n\r\n    triggerSegmentationModified(segmentationId);\r\n  }\r\n\r\n  // get all toolGroups that has the segmentationId as active\r\n  // segment and call invalidateBrushCursor on them\r\n  const toolGroups = getToolGroupIdsWithSegmentation(segmentationId);\r\n  toolGroups.forEach((toolGroupId) => {\r\n    invalidateBrushCursor(toolGroupId);\r\n  });\r\n}\r\n\r\n/**\r\n * Get the active segment index for a segmentation in the global state\r\n * @param segmentationId - The id of the segmentation to get the active segment index from.\r\n * @returns The active segment index for the given segmentation.\r\n */\r\nfunction getActiveSegmentIndex(segmentationId: string): number | undefined {\r\n  const segmentation = getSegmentation(segmentationId);\r\n\r\n  if (segmentation) {\r\n    return segmentation.activeSegmentIndex;\r\n  }\r\n}\r\n\r\nexport { getActiveSegmentIndex, setActiveSegmentIndex };\r\n","import cloneDeep from 'lodash.clonedeep';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport { utilities as csUtils } from '@cornerstonejs/core';\r\n\r\nimport { SegmentationRepresentations } from '../../enums';\r\nimport getDefaultContourConfig from '../../tools/displayTools/Contour/contourConfig';\r\nimport getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\r\nimport getDefaultSurfaceConfig from '../../tools/displayTools/Surface/surfaceConfig';\r\nimport type {\r\n  RepresentationConfig,\r\n  Segmentation,\r\n  SegmentationRepresentationConfig,\r\n  SegmentationState,\r\n  SegmentSpecificRepresentationConfig,\r\n  ToolGroupSpecificRepresentation,\r\n  ToolGroupSpecificRepresentations,\r\n} from '../../types/SegmentationStateTypes';\r\n\r\n// Initialize the default configuration\r\n// Note: when we get other representations, we should set their default representations too.\r\nconst defaultLabelmapConfig = getDefaultLabelmapConfig();\r\nconst defaultContourConfig = getDefaultContourConfig();\r\nconst defaultSurfaceConfig = getDefaultSurfaceConfig();\r\n\r\nconst newGlobalConfig: SegmentationRepresentationConfig = {\r\n  renderInactiveSegmentations: true,\r\n  representations: {\r\n    [SegmentationRepresentations.Labelmap]: defaultLabelmapConfig,\r\n    [SegmentationRepresentations.Contour]: defaultContourConfig,\r\n    [SegmentationRepresentations.Surface]: defaultSurfaceConfig,\r\n  },\r\n};\r\n\r\n/* A default initial state for the segmentation manager. */\r\nconst initialDefaultState: SegmentationState = {\r\n  colorLUT: [],\r\n  segmentations: [],\r\n  globalConfig: newGlobalConfig,\r\n  toolGroups: {},\r\n};\r\n\r\n/**\r\n * The SegmentationStateManager Class is responsible for managing the state of the\r\n * segmentations. It stores the segmentations and toolGroup specific representations\r\n * of the segmentation. It also stores a global config and a toolGroup specific\r\n * config. Note that this is a singleton state manager.\r\n */\r\nexport default class SegmentationStateManager {\r\n  private state: SegmentationState;\r\n  public readonly uid: string;\r\n\r\n  constructor(uid?: string) {\r\n    if (!uid) {\r\n      uid = csUtils.uuidv4();\r\n    }\r\n    this.state = cloneDeep(initialDefaultState);\r\n    this.uid = uid;\r\n  }\r\n\r\n  /**\r\n   * It returns a copy of the current state of the segmentation\r\n   * @returns A deep copy of the state.\r\n   */\r\n  getState(): SegmentationState {\r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * It returns an array of toolGroupIds currently in the segmentation state.\r\n   * @returns An array of strings.\r\n   */\r\n  getToolGroups(): string[] {\r\n    return Object.keys(this.state.toolGroups);\r\n  }\r\n\r\n  /**\r\n   * It returns the colorLUT at the specified index.\r\n   * @param lutIndex - The index of the color LUT to retrieve.\r\n   * @returns A ColorLUT object.\r\n   */\r\n  getColorLUT(lutIndex: number): Types.ColorLUT | undefined {\r\n    return this.state.colorLUT[lutIndex];\r\n  }\r\n\r\n  getNextColorLUTIndex(): number {\r\n    return this.state.colorLUT.length;\r\n  }\r\n\r\n  /**\r\n   * Reset the state to the default state\r\n   */\r\n  resetState(): void {\r\n    this.state = cloneDeep(initialDefaultState);\r\n  }\r\n\r\n  /**\r\n   * Given a segmentation Id, return the segmentation state\r\n   * @param segmentationId - The id of the segmentation to get the data for.\r\n   * @returns - The segmentation data\r\n   */\r\n  getSegmentation(segmentationId: string): Segmentation | undefined {\r\n    return this.state.segmentations.find(\r\n      (segmentation) => segmentation.segmentationId === segmentationId\r\n    );\r\n  }\r\n\r\n  /**\r\n   * It adds a segmentation to the segmentations array.\r\n   * @param segmentation - Segmentation\r\n   */\r\n  addSegmentation(segmentation: Segmentation): void {\r\n    // Check if the segmentation already exists with the segmentationId\r\n    if (this.getSegmentation(segmentation.segmentationId)) {\r\n      throw new Error(\r\n        `Segmentation with id ${segmentation.segmentationId} already exists`\r\n      );\r\n    }\r\n\r\n    this.state.segmentations.push(segmentation);\r\n  }\r\n\r\n  /**\r\n   * Get the segmentation representations for a tool group\r\n   * @param toolGroupId - string\r\n   * @returns A list of segmentation representations.\r\n   */\r\n  getSegmentationRepresentations(\r\n    toolGroupId: string\r\n  ): ToolGroupSpecificRepresentations | undefined {\r\n    const toolGroupSegRepresentationsWithConfig =\r\n      this.state.toolGroups[toolGroupId];\r\n\r\n    if (!toolGroupSegRepresentationsWithConfig) {\r\n      return;\r\n    }\r\n\r\n    return toolGroupSegRepresentationsWithConfig.segmentationRepresentations;\r\n  }\r\n\r\n  /**\r\n   * Returns an array of all segmentation representations for all tool groups.\r\n   * @returns An array of ToolGroupSpecificRepresentations.\r\n   */\r\n  getAllSegmentationRepresentations(): Record<\r\n    string,\r\n    ToolGroupSpecificRepresentation[]\r\n  > {\r\n    const toolGroupSegReps: Record<string, ToolGroupSpecificRepresentation[]> =\r\n      {};\r\n    Object.entries(this.state.toolGroups).forEach(\r\n      ([toolGroupId, toolGroupSegRepresentationsWithConfig]) => {\r\n        toolGroupSegReps[toolGroupId] =\r\n          toolGroupSegRepresentationsWithConfig.segmentationRepresentations;\r\n      }\r\n    );\r\n    return toolGroupSegReps;\r\n  }\r\n\r\n  /**\r\n   * Add a new segmentation representation to the toolGroup's segmentation representations.\r\n   * @param toolGroupId - The Id of the tool group .\r\n   * @param segmentationRepresentation - The segmentation representation to add.\r\n   */\r\n  addSegmentationRepresentation(\r\n    toolGroupId: string,\r\n    segmentationRepresentation: ToolGroupSpecificRepresentation\r\n  ): void {\r\n    // Initialize the default toolGroup state if not created yet\r\n    if (!this.state.toolGroups[toolGroupId]) {\r\n      this.state.toolGroups[toolGroupId] = {\r\n        segmentationRepresentations: [],\r\n        config: {} as SegmentationRepresentationConfig,\r\n      };\r\n    }\r\n\r\n    // local toolGroupSpecificSegmentationState\r\n    this.state.toolGroups[toolGroupId].segmentationRepresentations.push(\r\n      segmentationRepresentation\r\n    );\r\n\r\n    this._handleActiveSegmentation(toolGroupId, segmentationRepresentation);\r\n  }\r\n\r\n  /**\r\n   * Get the global config containing both representation config\r\n   * and render inactive segmentations config\r\n   * @returns The global config object.\r\n   */\r\n  getGlobalConfig(): SegmentationRepresentationConfig {\r\n    return this.state.globalConfig;\r\n  }\r\n\r\n  /**\r\n   * It sets the global segmentation config including both representation config\r\n   * and render inactive segmentations config\r\n   * @param config - The global configuration for the segmentations.\r\n   */\r\n  setGlobalConfig(config: SegmentationRepresentationConfig): void {\r\n    this.state.globalConfig = config;\r\n  }\r\n\r\n  /**\r\n   * Given a toolGroupId and a segmentationRepresentationUID, return the segmentation\r\n   * representation for that tool group.\r\n   * @param toolGroupId - The Id of the tool group\r\n   * @param segmentationRepresentationUID - string\r\n   * @returns The segmentation representation.\r\n   */\r\n  getSegmentationRepresentationByUID(\r\n    toolGroupId: string,\r\n    segmentationRepresentationUID: string\r\n  ): ToolGroupSpecificRepresentation | undefined {\r\n    const toolGroupSegRepresentations =\r\n      this.getSegmentationRepresentations(toolGroupId);\r\n\r\n    const segmentationData = toolGroupSegRepresentations?.find(\r\n      (representation) =>\r\n        representation.segmentationRepresentationUID ===\r\n        segmentationRepresentationUID\r\n    );\r\n\r\n    return segmentationData;\r\n  }\r\n\r\n  /**\r\n   * It removes the segmentation from the segmentation state.\r\n   * @param segmentationId - The id of the segmentation to remove.\r\n   */\r\n  removeSegmentation(segmentationId: string): void {\r\n    this.state.segmentations = this.state.segmentations.filter(\r\n      (segmentation) => segmentation.segmentationId !== segmentationId\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Remove a segmentation representation from the toolGroup\r\n   * @param toolGroupId - The Id of the tool group\r\n   * @param segmentationRepresentationUID - the uid of the segmentation representation to remove\r\n   * @param immediate - If true, the viewport will be updated immediately.\r\n   */\r\n  removeSegmentationRepresentation(\r\n    toolGroupId: string,\r\n    segmentationRepresentationUID: string\r\n  ): void {\r\n    const toolGroupSegmentationRepresentations =\r\n      this.getSegmentationRepresentations(toolGroupId);\r\n\r\n    if (\r\n      !toolGroupSegmentationRepresentations ||\r\n      !toolGroupSegmentationRepresentations.length\r\n    ) {\r\n      throw new Error(\r\n        `No viewport specific segmentation state found for viewport ${toolGroupId}`\r\n      );\r\n    }\r\n\r\n    const state =\r\n      toolGroupSegmentationRepresentations as ToolGroupSpecificRepresentations;\r\n    const index = state.findIndex(\r\n      (segData) =>\r\n        segData.segmentationRepresentationUID === segmentationRepresentationUID\r\n    );\r\n\r\n    if (index === -1) {\r\n      console.warn(\r\n        `No viewport specific segmentation state data found for viewport ${toolGroupId} and segmentation data UID ${segmentationRepresentationUID}`\r\n      );\r\n    }\r\n\r\n    const removedSegmentationRepresentation =\r\n      toolGroupSegmentationRepresentations[index];\r\n\r\n    toolGroupSegmentationRepresentations.splice(index, 1);\r\n\r\n    this._handleActiveSegmentation(\r\n      toolGroupId,\r\n      removedSegmentationRepresentation\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Set the active segmentation data for a tool group\r\n   * @param toolGroupId - The Id of the tool group that owns the\r\n   * segmentation data.\r\n   * @param segmentationRepresentationUID - string\r\n   */\r\n  setActiveSegmentationRepresentation(\r\n    toolGroupId: string,\r\n    segmentationRepresentationUID: string\r\n  ): void {\r\n    const toolGroupSegmentations =\r\n      this.getSegmentationRepresentations(toolGroupId);\r\n\r\n    if (!toolGroupSegmentations || !toolGroupSegmentations.length) {\r\n      throw new Error(\r\n        `No segmentation data found for toolGroupId: ${toolGroupId}`\r\n      );\r\n    }\r\n\r\n    const segmentationData = toolGroupSegmentations.find(\r\n      (segmentationData) =>\r\n        segmentationData.segmentationRepresentationUID ===\r\n        segmentationRepresentationUID\r\n    );\r\n\r\n    if (!segmentationData) {\r\n      throw new Error(\r\n        `No segmentation data found for segmentation data UID ${segmentationRepresentationUID}`\r\n      );\r\n    }\r\n\r\n    segmentationData.active = true;\r\n    this._handleActiveSegmentation(toolGroupId, segmentationData);\r\n  }\r\n\r\n  /**\r\n   * Given a tool group Id it returns the tool group specific representation config\r\n   *\r\n   * @param toolGroupId - The Id of the tool group\r\n   * @returns A SegmentationConfig object.\r\n   */\r\n  getToolGroupSpecificConfig(\r\n    toolGroupId: string\r\n  ): SegmentationRepresentationConfig | undefined {\r\n    const toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\r\n\r\n    if (!toolGroupStateWithConfig) {\r\n      return;\r\n    }\r\n\r\n    return toolGroupStateWithConfig.config;\r\n  }\r\n\r\n  getSegmentationRepresentationSpecificConfig(\r\n    toolGroupId: string,\r\n    segmentationRepresentationUID: string\r\n  ): RepresentationConfig {\r\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\r\n      toolGroupId,\r\n      segmentationRepresentationUID\r\n    );\r\n\r\n    if (!segmentationRepresentation) {\r\n      return;\r\n    }\r\n\r\n    return segmentationRepresentation.segmentationRepresentationSpecificConfig;\r\n  }\r\n\r\n  setSegmentationRepresentationSpecificConfig(\r\n    toolGroupId: string,\r\n    segmentationRepresentationUID: string,\r\n    config: RepresentationConfig\r\n  ): void {\r\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\r\n      toolGroupId,\r\n      segmentationRepresentationUID\r\n    );\r\n\r\n    if (!segmentationRepresentation) {\r\n      return;\r\n    }\r\n\r\n    segmentationRepresentation.segmentationRepresentationSpecificConfig =\r\n      config;\r\n  }\r\n\r\n  getSegmentSpecificConfig(\r\n    toolGroupId: string,\r\n    segmentationRepresentationUID: string,\r\n    segmentIndex: number\r\n  ): RepresentationConfig {\r\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\r\n      toolGroupId,\r\n      segmentationRepresentationUID\r\n    );\r\n\r\n    if (!segmentationRepresentation) {\r\n      return;\r\n    }\r\n\r\n    return segmentationRepresentation.segmentSpecificConfig[segmentIndex];\r\n  }\r\n\r\n  setSegmentSpecificConfig(\r\n    toolGroupId: string,\r\n    segmentationRepresentationUID: string,\r\n    config: SegmentSpecificRepresentationConfig,\r\n    options?: {\r\n      clear: false;\r\n    }\r\n  ): void {\r\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\r\n      toolGroupId,\r\n      segmentationRepresentationUID\r\n    );\r\n\r\n    if (!segmentationRepresentation) {\r\n      return;\r\n    }\r\n\r\n    if (!segmentationRepresentation.segmentSpecificConfig || options?.clear) {\r\n      segmentationRepresentation.segmentSpecificConfig = {};\r\n    }\r\n\r\n    Object.keys(config).forEach((key) => {\r\n      segmentationRepresentation.segmentSpecificConfig[key] = config[key];\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set the segmentation representations config for a given tool group. It will create a new\r\n   * tool group specific config if one does not exist.\r\n   *\r\n   * @param toolGroupId - The Id of the tool group that the segmentation\r\n   * belongs to.\r\n   * @param config - SegmentationConfig\r\n   */\r\n  setSegmentationRepresentationConfig(\r\n    toolGroupId: string,\r\n    config: SegmentationRepresentationConfig\r\n  ): void {\r\n    let toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\r\n\r\n    if (!toolGroupStateWithConfig) {\r\n      this.state.toolGroups[toolGroupId] = {\r\n        segmentationRepresentations: [],\r\n        config: {\r\n          renderInactiveSegmentations: true,\r\n          representations: {},\r\n        },\r\n      };\r\n\r\n      toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\r\n    }\r\n\r\n    toolGroupStateWithConfig.config = {\r\n      ...toolGroupStateWithConfig.config,\r\n      ...config,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * It adds a color LUT to the state.\r\n   * @param colorLUT - ColorLUT\r\n   * @param lutIndex - The index of the color LUT table to add.\r\n   */\r\n  addColorLUT(colorLUT: Types.ColorLUT, lutIndex: number): void {\r\n    if (this.state.colorLUT[lutIndex]) {\r\n      console.warn('Color LUT table already exists, overwriting');\r\n    }\r\n\r\n    this.state.colorLUT[lutIndex] = cloneDeep(colorLUT);\r\n  }\r\n\r\n  /**\r\n   * Removes a color LUT to the state.\r\n   * @param colorLUTIndex - The index of the color LUT table to remove.\r\n   */\r\n  removeColorLUT(colorLUTIndex: number): void {\r\n    delete this.state.colorLUT[colorLUTIndex];\r\n  }\r\n\r\n  /**\r\n   * It handles the active segmentation representation based on the active status of the\r\n   * segmentation representation that was added or removed.\r\n   *\r\n   * @param toolGroupId - The Id of the tool group that the segmentation representation belongs to.\r\n   * @param recentlyAddedOrRemovedSegmentationRepresentation - ToolGroupSpecificSegmentationData\r\n   */\r\n  _handleActiveSegmentation(\r\n    toolGroupId: string,\r\n    recentlyAddedOrRemovedSegmentationRepresentation: ToolGroupSpecificRepresentation\r\n  ): void {\r\n    const segmentationRepresentations =\r\n      this.getSegmentationRepresentations(toolGroupId);\r\n\r\n    // 1. If there is no segmentation representations, return early\r\n    if (segmentationRepresentations.length === 0) {\r\n      return;\r\n    }\r\n\r\n    // 2. If there is only one segmentation representation, make that one active\r\n    if (segmentationRepresentations.length === 1) {\r\n      segmentationRepresentations[0].active = true;\r\n      return;\r\n    }\r\n\r\n    // 3. If removed Segmentation representation was active, make the first one active\r\n    const activeSegmentationRepresentations =\r\n      segmentationRepresentations.filter(\r\n        (representation) => representation.active\r\n      );\r\n\r\n    if (activeSegmentationRepresentations.length === 0) {\r\n      segmentationRepresentations[0].active = true;\r\n      return;\r\n    }\r\n\r\n    // 4. If the added segmentation representation is active, make other segmentation\r\n    // representations inactive\r\n    if (recentlyAddedOrRemovedSegmentationRepresentation.active) {\r\n      segmentationRepresentations.forEach((representation) => {\r\n        if (\r\n          representation.segmentationRepresentationUID !==\r\n          recentlyAddedOrRemovedSegmentationRepresentation.segmentationRepresentationUID\r\n        ) {\r\n          representation.active = false;\r\n        }\r\n      });\r\n    }\r\n\r\n    // 5. if added/removed segmentation is is inactive, do nothing\r\n  }\r\n}\r\n\r\nconst defaultSegmentationStateManager = new SegmentationStateManager('DEFAULT');\r\nexport { defaultSegmentationStateManager };\r\n","import { SegmentationRepresentations } from '../../../enums';\r\nimport {\r\n  SegmentationPublicInput,\r\n  Segmentation,\r\n} from '../../../types/SegmentationStateTypes';\r\nimport type { ContourSegmentationData } from '../../../types/ContourTypes';\r\n\r\n/**\r\n * It takes in a segmentation input and returns a segmentation with default values\r\n * @param segmentationInput - The input to the segmentation.\r\n * @returns A Segmentation object.\r\n * @internal\r\n */\r\nfunction normalizeSegmentationInput(\r\n  segmentationInput: SegmentationPublicInput\r\n): Segmentation {\r\n  const { segmentationId, representation } = segmentationInput;\r\n  const isContourRepresentation =\r\n    representation.type === SegmentationRepresentations.Contour;\r\n  let data = representation.data ? { ...representation.data } : null;\r\n\r\n  // Contour representation data is defined internally\r\n  data = !data && isContourRepresentation ? {} : data;\r\n\r\n  // Data cannot be undefined for labelmap and surface\r\n  if (!data) {\r\n    throw new Error('Segmentation representation data may not be undefined');\r\n  }\r\n\r\n  if (isContourRepresentation) {\r\n    const contourData = <ContourSegmentationData>data;\r\n\r\n    // geometryIds will be removed in a near future. It still exist in the\r\n    // code for compatibility only but it is optional from now on.\r\n    contourData.geometryIds = contourData.geometryIds ?? [];\r\n\r\n    // Make sure annotationUIDsMap is defined because an empty contour is\r\n    // created before adding contour annotations to the map. Also it prevents\r\n    // breaking legacy code after moving from geometryIds to annotationUIDsMap.\r\n    contourData.annotationUIDsMap = contourData.annotationUIDsMap ?? new Map();\r\n  }\r\n\r\n  // Todo: we should be able to let the user pass in non-default values for\r\n  // cachedStats, label, activeSegmentIndex, etc.\r\n  return {\r\n    segmentationId,\r\n    cachedStats: {},\r\n    segmentLabels: {},\r\n    label: null,\r\n    segmentsLocked: new Set(),\r\n    type: representation.type,\r\n    activeSegmentIndex: 1,\r\n    representationData: {\r\n      [representation.type]: {\r\n        ...data,\r\n      },\r\n    },\r\n  };\r\n}\r\n\r\nexport default normalizeSegmentationInput;\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport type {\r\n  RepresentationConfig,\r\n  Segmentation,\r\n  SegmentationPublicInput,\r\n  SegmentationRepresentationConfig,\r\n  SegmentSpecificRepresentationConfig,\r\n  ToolGroupSpecificRepresentation,\r\n  ToolGroupSpecificRepresentations,\r\n} from '../../types/SegmentationStateTypes';\r\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\r\nimport {\r\n  triggerSegmentationModified,\r\n  triggerSegmentationRemoved,\r\n  triggerSegmentationRepresentationModified,\r\n  triggerSegmentationRepresentationRemoved,\r\n} from './triggerSegmentationEvents';\r\n\r\nimport normalizeSegmentationInput from './helpers/normalizeSegmentationInput';\r\n\r\n/**\r\n * It returns the defaultSegmentationStateManager.\r\n */\r\nfunction getDefaultSegmentationStateManager() {\r\n  return defaultSegmentationStateManager;\r\n}\r\n\r\n/*************************\r\n *\r\n * Segmentation State\r\n *\r\n **************************/\r\n\r\n/**\r\n * Get the segmentation for the given segmentationId\r\n * @param segmentationId - The Id of the segmentation\r\n * @returns A GlobalSegmentationData object\r\n */\r\nfunction getSegmentation(segmentationId: string): Segmentation | undefined {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n  return segmentationStateManager.getSegmentation(segmentationId);\r\n}\r\n\r\n/**\r\n * Get the segmentations inside the state\r\n * @returns Segmentation array\r\n */\r\nfunction getSegmentations(): Segmentation[] | [] {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n  const state = segmentationStateManager.getState();\r\n\r\n  return state.segmentations;\r\n}\r\n\r\n/**\r\n * It takes a segmentation input and adds it to the segmentation state manager\r\n * @param segmentationInput - The segmentation to add.\r\n * @param suppressEvents - If true, the event will not be triggered.\r\n */\r\nfunction addSegmentation(\r\n  segmentationInput: SegmentationPublicInput,\r\n  suppressEvents?: boolean\r\n): void {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n\r\n  const segmentation = normalizeSegmentationInput(segmentationInput);\r\n\r\n  segmentationStateManager.addSegmentation(segmentation);\r\n\r\n  if (!suppressEvents) {\r\n    triggerSegmentationModified(segmentation.segmentationId);\r\n  }\r\n}\r\n\r\n/**\r\n * Get the segmentation state for a tool group. It will return an array of\r\n * segmentation representation objects.\r\n * @param toolGroupId - The unique identifier of the tool group.\r\n * @returns An array of segmentation representation objects.\r\n */\r\nfunction getSegmentationRepresentations(\r\n  toolGroupId: string\r\n): ToolGroupSpecificRepresentations | [] {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n  return segmentationStateManager.getSegmentationRepresentations(toolGroupId);\r\n}\r\n\r\n/**\r\n * Get all segmentation representations in the state\r\n * @returns An array of segmentation representation objects.\r\n */\r\nfunction getAllSegmentationRepresentations(): Record<\r\n  string,\r\n  ToolGroupSpecificRepresentation[]\r\n> {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n  return segmentationStateManager.getAllSegmentationRepresentations();\r\n}\r\n\r\n/**\r\n * Finds all segmentation representations with the given segmentationId.\r\n * @param segmentationId - The ID of the segmentation.\r\n * @returns An array of found segmentation representations.\r\n */\r\nfunction getSegmentationIdRepresentations(segmentationId) {\r\n  const allRepresentations = getAllSegmentationRepresentations() || {};\r\n  const foundRepresentations = [];\r\n\r\n  for (const toolGroupId in allRepresentations) {\r\n    const toolGroupRepresentations = allRepresentations[toolGroupId];\r\n\r\n    const foundRepresentation = toolGroupRepresentations.find(\r\n      (representation) => representation.segmentationId === segmentationId\r\n    );\r\n\r\n    if (foundRepresentation) {\r\n      foundRepresentations.push(foundRepresentation);\r\n    }\r\n  }\r\n\r\n  return foundRepresentations;\r\n}\r\n\r\n/**\r\n * Finds a segmentation representation by its UID.\r\n *\r\n * @param segmentationRepresentationUID - The UID of the segmentation representation to find.\r\n * @returns The found segmentation representation, or undefined if not found.\r\n */\r\nfunction findSegmentationRepresentationByUID(\r\n  segmentationRepresentationUID: string\r\n): {\r\n  toolGroupId: string;\r\n  segmentationRepresentation: ToolGroupSpecificRepresentation;\r\n} {\r\n  const allToolGroupRepresentations = getAllSegmentationRepresentations() || [];\r\n\r\n  const toolGroupIds = Object.keys(allToolGroupRepresentations);\r\n\r\n  for (const toolGroupId of toolGroupIds) {\r\n    const toolGroupRepresentations =\r\n      getAllSegmentationRepresentations()[toolGroupId];\r\n\r\n    const foundRepresentation = toolGroupRepresentations.find(\r\n      (representation) =>\r\n        representation.segmentationRepresentationUID ===\r\n        segmentationRepresentationUID\r\n    );\r\n\r\n    if (foundRepresentation) {\r\n      return {\r\n        segmentationRepresentation: foundRepresentation,\r\n        toolGroupId,\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get the tool group IDs that have a segmentation representation with the given\r\n * segmentationId\r\n * @param segmentationId - The id of the segmentation\r\n * @returns An array of tool group IDs.\r\n */\r\nfunction getToolGroupIdsWithSegmentation(segmentationId: string): string[] {\r\n  if (!segmentationId) {\r\n    throw new Error('getToolGroupIdsWithSegmentation: segmentationId is empty');\r\n  }\r\n\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n  const state = segmentationStateManager.getState();\r\n  const toolGroupIds = Object.keys(state.toolGroups);\r\n\r\n  const foundToolGroupIds = [];\r\n  toolGroupIds.forEach((toolGroupId) => {\r\n    const toolGroupSegmentationRepresentations =\r\n      segmentationStateManager.getSegmentationRepresentations(toolGroupId);\r\n\r\n    toolGroupSegmentationRepresentations.forEach((representation) => {\r\n      if (representation.segmentationId === segmentationId) {\r\n        foundToolGroupIds.push(toolGroupId);\r\n      }\r\n    });\r\n  });\r\n\r\n  return foundToolGroupIds;\r\n}\r\n\r\n/**\r\n * Get the segmentation representations config for a given tool group\r\n * @param toolGroupId - The Id of the tool group that the segmentation\r\n * config belongs to.\r\n * @returns A SegmentationConfig object.\r\n */\r\nfunction getToolGroupSpecificConfig(\r\n  toolGroupId: string\r\n): SegmentationRepresentationConfig {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n  return segmentationStateManager.getToolGroupSpecificConfig(toolGroupId);\r\n}\r\n\r\n/**\r\n * Set the segmentation representation config for the provided toolGroup. ToolGroup specific\r\n * configuration overwrites the global configuration for each representation.\r\n * It fires SEGMENTATION_REPRESENTATION_MODIFIED event if not suppressed.\r\n *\r\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\r\n * @param toolGroupId - The Id of the tool group that the segmentation\r\n * config is being set for.\r\n * @param config - The new configuration for the tool group.\r\n * @param suppressEvents - If true, the event will not be triggered.\r\n */\r\nfunction setToolGroupSpecificConfig(\r\n  toolGroupId: string,\r\n  config: SegmentationRepresentationConfig,\r\n  suppressEvents?: boolean\r\n): void {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n  segmentationStateManager.setSegmentationRepresentationConfig(\r\n    toolGroupId,\r\n    config\r\n  );\r\n\r\n  if (!suppressEvents) {\r\n    triggerSegmentationRepresentationModified(toolGroupId);\r\n  }\r\n}\r\n\r\n/**\r\n * It sets the segmentation representation specific config for all the segments\r\n * inside the segmentation.\r\n * @param segmentationRepresentationUID - The unique identifier of the segmentation representation.\r\n * @param config  - The new configuration for the segmentation representation it is an object with keys of\r\n * different representation types, and values of the configuration for each representation type.\r\n */\r\nfunction setSegmentationRepresentationSpecificConfig(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string,\r\n  config: RepresentationConfig,\r\n  suppressEvents = false\r\n): void {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n  segmentationStateManager.setSegmentationRepresentationSpecificConfig(\r\n    toolGroupId,\r\n    segmentationRepresentationUID,\r\n    config\r\n  );\r\n\r\n  if (!suppressEvents) {\r\n    triggerSegmentationRepresentationModified(\r\n      toolGroupId,\r\n      segmentationRepresentationUID\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * It returns the segmentation representation specific config which is the same for all the segments\r\n * @param segmentationRepresentationUID - The unique identifier of the segmentation representation.\r\n * @returns - The segmentation representation specific config.\r\n */\r\nfunction getSegmentationRepresentationSpecificConfig(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string\r\n): RepresentationConfig {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n  return segmentationStateManager.getSegmentationRepresentationSpecificConfig(\r\n    toolGroupId,\r\n    segmentationRepresentationUID\r\n  );\r\n}\r\n\r\nfunction getSegmentSpecificRepresentationConfig(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string,\r\n  segmentIndex: number\r\n): RepresentationConfig {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n  return segmentationStateManager.getSegmentSpecificConfig(\r\n    toolGroupId,\r\n    segmentationRepresentationUID,\r\n    segmentIndex\r\n  );\r\n}\r\n\r\nfunction setSegmentSpecificRepresentationConfig(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string,\r\n  config: SegmentSpecificRepresentationConfig,\r\n  suppressEvents = false\r\n): void {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n  segmentationStateManager.setSegmentSpecificConfig(\r\n    toolGroupId,\r\n    segmentationRepresentationUID,\r\n    config\r\n  );\r\n\r\n  // Todo: this can be even more performant if we create a new event for\r\n  // triggering a specific segment config change.\r\n  if (!suppressEvents) {\r\n    triggerSegmentationRepresentationModified(\r\n      toolGroupId,\r\n      segmentationRepresentationUID\r\n    );\r\n  }\r\n}\r\n\r\nfunction getToolGroupIdFromSegmentationRepresentationUID(\r\n  segmentationRepresentationUID: string\r\n): string {\r\n  const allToolGroupRepresentations = getAllSegmentationRepresentations() || [];\r\n\r\n  const toolGroupIds = Object.keys(allToolGroupRepresentations);\r\n\r\n  for (const toolGroupId of toolGroupIds) {\r\n    const toolGroupRepresentations =\r\n      getAllSegmentationRepresentations()[toolGroupId];\r\n\r\n    const foundRepresentation = toolGroupRepresentations.find(\r\n      (representation) =>\r\n        representation.segmentationRepresentationUID ===\r\n        segmentationRepresentationUID\r\n    );\r\n\r\n    if (foundRepresentation) {\r\n      return toolGroupId;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Add the given segmentation representation data to the given tool group state. It fires\r\n * SEGMENTATION_REPRESENTATION_MODIFIED event if not suppressed.\r\n *\r\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\r\n *\r\n * @param toolGroupId - The Id of the tool group that the segmentation representation is for.\r\n * @param segmentationData - The data to add to the segmentation state.\r\n * @param suppressEvents - boolean\r\n */\r\nfunction addSegmentationRepresentation(\r\n  toolGroupId: string,\r\n  segmentationRepresentation: ToolGroupSpecificRepresentation,\r\n  suppressEvents?: boolean\r\n): void {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n  segmentationStateManager.addSegmentationRepresentation(\r\n    toolGroupId,\r\n    segmentationRepresentation\r\n  );\r\n\r\n  if (!suppressEvents) {\r\n    triggerSegmentationRepresentationModified(\r\n      toolGroupId,\r\n      segmentationRepresentation.segmentationRepresentationUID\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * It returns the global segmentation config. Note that the toolGroup-specific\r\n * configuration has higher priority than the global configuration and overwrites\r\n * the global configuration for each representation.\r\n * @returns The global segmentation configuration for all segmentations.\r\n */\r\nfunction getGlobalConfig(): SegmentationRepresentationConfig {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n  return segmentationStateManager.getGlobalConfig();\r\n}\r\n\r\n/**\r\n * Set the global segmentation configuration. It fires SEGMENTATION_MODIFIED\r\n * event if not suppressed.\r\n *\r\n * @triggers SEGMENTATION_MODIFIED\r\n * @param config - The new global segmentation config.\r\n * @param suppressEvents - If true, the `segmentationGlobalStateModified` event will not be triggered.\r\n */\r\nfunction setGlobalConfig(\r\n  config: SegmentationRepresentationConfig,\r\n  suppressEvents?: boolean\r\n): void {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n  segmentationStateManager.setGlobalConfig(config);\r\n\r\n  if (!suppressEvents) {\r\n    triggerSegmentationModified();\r\n  }\r\n}\r\n\r\n/**\r\n * Get the segmentation data object for a given tool group and\r\n * segmentation data UID. It searches all the toolGroup specific segmentation\r\n * data objects and returns the first one that matches the UID.\r\n * @param toolGroupId - The Id of the tool group that the segmentation\r\n * data belongs to.\r\n * @param segmentationRepresentationUID - The uid of the segmentation representation\r\n * @returns Segmentation Data object.\r\n */\r\nfunction getSegmentationRepresentationByUID(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string\r\n): ToolGroupSpecificRepresentation | undefined {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n  return segmentationStateManager.getSegmentationRepresentationByUID(\r\n    toolGroupId,\r\n    segmentationRepresentationUID\r\n  );\r\n}\r\n\r\n/**\r\n * It removes the segmentation from the segmentation state manager\r\n *\r\n * @triggers SEGMENTATION_REMOVED\r\n *\r\n * @param segmentationId - The id of the segmentation\r\n */\r\nfunction removeSegmentation(segmentationId: string): void {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n  segmentationStateManager.removeSegmentation(segmentationId);\r\n  triggerSegmentationRemoved(segmentationId);\r\n}\r\n\r\n/**\r\n * Remove a segmentation representation from the segmentation state manager for a toolGroup.\r\n * It fires SEGMENTATION_REPRESENTATION_MODIFIED event.\r\n *\r\n * @triggers SEGMENTATION_REPRESENTATION_REMOVED\r\n *\r\n * @param toolGroupId - The Id of the tool group that the segmentation\r\n * data belongs to.\r\n * @param segmentationRepresentationUID - The uid of the segmentation representation to remove.\r\n * remove.\r\n * @param - immediate - If true, the viewports will be updated immediately.\r\n */\r\nfunction removeSegmentationRepresentation(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string\r\n): void {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n  segmentationStateManager.removeSegmentationRepresentation(\r\n    toolGroupId,\r\n    segmentationRepresentationUID\r\n  );\r\n\r\n  triggerSegmentationRepresentationRemoved(\r\n    toolGroupId,\r\n    segmentationRepresentationUID\r\n  );\r\n}\r\n\r\n/**\r\n * Removes all segmentation representations associated with a tool group.\r\n * @param toolGroupId - The ID of the tool group.\r\n */\r\nfunction removeSegmentationRepresentations(toolGroupId: string): void {\r\n  const segmentationRepresentations =\r\n    getSegmentationRepresentations(toolGroupId) || [];\r\n\r\n  segmentationRepresentations.forEach((representation) => {\r\n    removeSegmentationRepresentation(\r\n      toolGroupId,\r\n      representation.segmentationRepresentationUID\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n * Add a color LUT to the segmentation state manager\r\n * @param colorLUT - The color LUT array to add.\r\n * @param index - The index of the color LUT to add.\r\n */\r\nfunction removeColorLUT(colorLUTIndex: number): void {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n  segmentationStateManager.removeColorLUT(colorLUTIndex);\r\n}\r\n\r\n/**\r\n * Get the color lut for a given index\r\n * @param index - The index of the color lut to retrieve.\r\n * @returns A ColorLUT array.\r\n */\r\nfunction getColorLUT(index: number): Types.ColorLUT | undefined {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n  return segmentationStateManager.getColorLUT(index);\r\n}\r\n\r\nfunction getNextColorLUTIndex(): number {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n  return segmentationStateManager.getNextColorLUTIndex();\r\n}\r\n\r\n/**\r\n * Add a color LUT to the segmentation state manager\r\n * @param colorLUT - The color LUT array to add.\r\n * @param index - The index of the color LUT to add.\r\n */\r\nfunction addColorLUT(colorLUT: Types.ColorLUT, index: number): void {\r\n  const segmentationStateManager = getDefaultSegmentationStateManager();\r\n  segmentationStateManager.addColorLUT(colorLUT, index);\r\n  // Todo: trigger event color LUT added\r\n}\r\n\r\nexport {\r\n  getDefaultSegmentationStateManager,\r\n  // Segmentation\r\n  getSegmentation,\r\n  getSegmentations,\r\n  addSegmentation,\r\n  removeSegmentation,\r\n  // ToolGroup specific Segmentation Representation\r\n  getSegmentationRepresentations,\r\n  addSegmentationRepresentation,\r\n  removeSegmentationRepresentation,\r\n  removeSegmentationRepresentations,\r\n  // config\r\n  getToolGroupSpecificConfig,\r\n  setToolGroupSpecificConfig,\r\n  getGlobalConfig,\r\n  setGlobalConfig,\r\n  getSegmentationRepresentationSpecificConfig,\r\n  setSegmentationRepresentationSpecificConfig,\r\n  getSegmentSpecificRepresentationConfig,\r\n  setSegmentSpecificRepresentationConfig,\r\n  // helpers s\r\n  getToolGroupIdsWithSegmentation,\r\n  getAllSegmentationRepresentations,\r\n  getSegmentationRepresentationByUID,\r\n  getSegmentationIdRepresentations,\r\n  // color\r\n  addColorLUT,\r\n  getColorLUT,\r\n  getNextColorLUTIndex,\r\n  removeColorLUT,\r\n  //\r\n  findSegmentationRepresentationByUID,\r\n  getToolGroupIdFromSegmentationRepresentationUID,\r\n};\r\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\r\n\r\nimport { Events } from '../../enums';\r\nimport {\r\n  getSegmentationRepresentations,\r\n  getSegmentations,\r\n} from '../../stateManagement/segmentation/segmentationState';\r\nimport {\r\n  SegmentationRepresentationModifiedEventDetail,\r\n  SegmentationDataModifiedEventDetail,\r\n  SegmentationModifiedEventDetail,\r\n  SegmentationRepresentationRemovedEventDetail,\r\n  SegmentationRemovedEventDetail,\r\n} from '../../types/EventTypes';\r\nimport { setSegmentationDirty } from '../../utilities/segmentation/getUniqueSegmentIndices';\r\n\r\n/**\r\n * Trigger an event that a segmentation is removed\r\n * @param segmentationId - The Id of segmentation\r\n */\r\nfunction triggerSegmentationRemoved(segmentationId: string): void {\r\n  const eventDetail: SegmentationRemovedEventDetail = {\r\n    segmentationId,\r\n  };\r\n\r\n  triggerEvent(eventTarget, Events.SEGMENTATION_REMOVED, eventDetail);\r\n}\r\n\r\n/**\r\n * Trigger an event that a segmentation representation was removed\r\n * @param toolGroupId - The id of the tool group that the segmentation\r\n * representation was removed from.\r\n * @param segmentationRepresentationUID - The UID of the segmentation\r\n * representation that was removed.\r\n */\r\nfunction triggerSegmentationRepresentationRemoved(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string\r\n): void {\r\n  const eventDetail: SegmentationRepresentationRemovedEventDetail = {\r\n    toolGroupId,\r\n    segmentationRepresentationUID,\r\n  };\r\n\r\n  triggerEvent(\r\n    eventTarget,\r\n    Events.SEGMENTATION_REPRESENTATION_REMOVED,\r\n    eventDetail\r\n  );\r\n}\r\n\r\n/**\r\n * Trigger an event on the eventTarget that the segmentation representation for\r\n * toolGroupId has been updated\r\n * @param toolGroupId - The Id of the toolGroup\r\n */\r\nfunction triggerSegmentationRepresentationModified(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID?: string\r\n): void {\r\n  const eventDetail: SegmentationRepresentationModifiedEventDetail = {\r\n    toolGroupId,\r\n    segmentationRepresentationUID,\r\n  };\r\n\r\n  if (segmentationRepresentationUID) {\r\n    triggerEvent(\r\n      eventTarget,\r\n      Events.SEGMENTATION_REPRESENTATION_MODIFIED,\r\n      eventDetail\r\n    );\r\n    return;\r\n  }\r\n\r\n  // If no segmentationRepresentationUID is provided, then we need to trigger\r\n  // the event for all segmentation representations in the toolGroup\r\n\r\n  // Get all segmentation representations in the toolGroup\r\n  const segmentationRepresentations =\r\n    getSegmentationRepresentations(toolGroupId) || [];\r\n\r\n  segmentationRepresentations.forEach((segmentationRepresentation) => {\r\n    const { segmentationRepresentationUID } = segmentationRepresentation;\r\n    const eventDetail: SegmentationRepresentationModifiedEventDetail = {\r\n      toolGroupId,\r\n      segmentationRepresentationUID,\r\n    };\r\n\r\n    triggerEvent(\r\n      eventTarget,\r\n      Events.SEGMENTATION_REPRESENTATION_MODIFIED,\r\n      eventDetail\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n * Triggers segmentation global state updated event, notifying all toolGroups\r\n * that the global state has been updated, If a segmentationId is provided\r\n * the event will only be triggered for that segmentation, otherwise it will\r\n * be triggered for all segmentations.\r\n *\r\n * @param segmentationId - The id of the segmentation that has been updated\r\n */\r\nfunction triggerSegmentationModified(segmentationId?: string): void {\r\n  let segmentationIds;\r\n\r\n  if (segmentationId) {\r\n    segmentationIds = [segmentationId];\r\n  } else {\r\n    // get all toolGroups\r\n    segmentationIds = getSegmentations().map(\r\n      ({ segmentationId }) => segmentationId\r\n    );\r\n  }\r\n\r\n  // 1. Trigger an event notifying all listeners about the segmentationId\r\n  // that has been updated.\r\n  segmentationIds.forEach((segmentationId) => {\r\n    const eventDetail: SegmentationModifiedEventDetail = {\r\n      segmentationId,\r\n    };\r\n    triggerEvent(eventTarget, Events.SEGMENTATION_MODIFIED, eventDetail);\r\n  });\r\n\r\n  // Todo: I don't think we need the following lines of code\r\n  // // 2. Notify all viewports that render the segmentationId in order to update the\r\n  // // rendering based on the new global state.\r\n  // toolGroupIds.forEach((toolGroupId) => {\r\n  //   triggerSegmentationRepresentationModified(toolGroupId)\r\n  // })\r\n}\r\n\r\n/**\r\n * Trigger an event that a segmentation data has been modified\r\n * @param segmentationId - The Id of segmentation\r\n */\r\nfunction triggerSegmentationDataModified(\r\n  segmentationId: string,\r\n  modifiedSlicesToUse?: number[]\r\n): void {\r\n  const eventDetail: SegmentationDataModifiedEventDetail = {\r\n    segmentationId,\r\n    modifiedSlicesToUse,\r\n  };\r\n\r\n  // set it to dirty to force the next call to getUniqueSegmentIndices to\r\n  // recalculate the segment indices\r\n  setSegmentationDirty(segmentationId);\r\n\r\n  triggerEvent(eventTarget, Events.SEGMENTATION_DATA_MODIFIED, eventDetail);\r\n}\r\n\r\nexport {\r\n  // ToolGroup Specific\r\n  triggerSegmentationRepresentationModified,\r\n  triggerSegmentationRepresentationRemoved,\r\n  // Global\r\n  triggerSegmentationDataModified,\r\n  triggerSegmentationModified,\r\n  triggerSegmentationRemoved,\r\n};\r\n","import {\r\n  getRenderingEngine,\r\n  getEnabledElement,\r\n  Enums,\r\n  Types,\r\n} from '@cornerstonejs/core';\r\n\r\nimport { ISynchronizerEventHandler } from '../../types';\r\n\r\n/**\r\n * Synchronizer is a class that listens to a specific event on a specific source\r\n * targets and fires a specific event on a specific target elements. Use cases\r\n * include: synchronizing a camera between two viewports, synchronizing a\r\n * windowLevel between various viewports.\r\n */\r\nclass Synchronizer {\r\n  //\r\n  private _enabled: boolean;\r\n  private _eventName: string;\r\n  private _auxiliaryEventNames: string[];\r\n  private _eventHandler: ISynchronizerEventHandler;\r\n  private _ignoreFiredEvents: boolean;\r\n  private _sourceViewports: Array<Types.IViewportId>;\r\n  private _targetViewports: Array<Types.IViewportId>;\r\n  private _viewportOptions: Record<string, Record<string, unknown>> = {};\r\n  private _options: any;\r\n  public id: string;\r\n\r\n  constructor(\r\n    synchronizerId: string,\r\n    eventName: string,\r\n    eventHandler: ISynchronizerEventHandler,\r\n    options?: any\r\n  ) {\r\n    this._enabled = true;\r\n    this._eventName = eventName;\r\n    this._eventHandler = eventHandler;\r\n    this._ignoreFiredEvents = false;\r\n    this._sourceViewports = [];\r\n    this._targetViewports = [];\r\n    this._options = options || {};\r\n    this._auxiliaryEventNames = this._options.auxiliaryEventNames || [];\r\n\r\n    //\r\n    this.id = synchronizerId;\r\n  }\r\n\r\n  /**\r\n   * \"Returns true if the synchronizer is disabled.\"\r\n   * @returns A boolean value.\r\n   */\r\n  public isDisabled(): boolean {\r\n    return !this._enabled || !this._hasSourceElements();\r\n  }\r\n\r\n  /**\r\n   * Sets the options for the viewport id.  This can be used to\r\n   * provide configuration on a viewport basis for things like offsets\r\n   * to the general synchronization, or turn on/off synchronization of certain\r\n   * attributes.\r\n   */\r\n  public setOptions(\r\n    viewportId: string,\r\n    options: Record<string, unknown> = {}\r\n  ): void {\r\n    this._viewportOptions[viewportId] = options;\r\n  }\r\n\r\n  /**\r\n   * Sets a synchronizer enabled\r\n   */\r\n  public setEnabled(enabled: boolean) {\r\n    this._enabled = enabled;\r\n  }\r\n\r\n  /** Gets the options for the given viewport id */\r\n  public getOptions(viewportId: string): Record<string, unknown> | undefined {\r\n    return this._viewportOptions[viewportId];\r\n  }\r\n\r\n  /**\r\n   * Add a viewport to the list of targets and sources both.\r\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\r\n   */\r\n  public add(viewportInfo: Types.IViewportId): void {\r\n    this.addTarget(viewportInfo);\r\n    this.addSource(viewportInfo);\r\n  }\r\n\r\n  /**\r\n   * Add a viewport to the list of sources (source ONLY)\r\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\r\n   */\r\n  public addSource(viewportInfo: Types.IViewportId): void {\r\n    if (_containsViewport(this._sourceViewports, viewportInfo)) {\r\n      return;\r\n    }\r\n\r\n    const { renderingEngineId, viewportId } = viewportInfo;\r\n\r\n    const viewport =\r\n      getRenderingEngine(renderingEngineId).getViewport(viewportId);\r\n\r\n    if (!viewport) {\r\n      console.warn(\r\n        `Synchronizer.addSource: No viewport for ${renderingEngineId} ${viewportId}`\r\n      );\r\n      return;\r\n    }\r\n\r\n    const element = viewport.element;\r\n\r\n    element.addEventListener(this._eventName, this._onEvent.bind(this));\r\n\r\n    if (this._auxiliaryEventNames.length) {\r\n      this._auxiliaryEventNames.forEach((eventName) => {\r\n        element.addEventListener(eventName, this._onEvent.bind(this));\r\n      });\r\n    }\r\n\r\n    this._updateDisableHandlers();\r\n\r\n    this._sourceViewports.push(viewportInfo);\r\n  }\r\n\r\n  /**\r\n   * Add a viewport to the list of viewports that will get the eventHandler\r\n   * executed when the event is fired on the source viewport.\r\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\r\n   */\r\n  public addTarget(viewportInfo: Types.IViewportId): void {\r\n    if (_containsViewport(this._targetViewports, viewportInfo)) {\r\n      return;\r\n    }\r\n\r\n    this._targetViewports.push(viewportInfo);\r\n    this._updateDisableHandlers();\r\n  }\r\n\r\n  /**\r\n   * Get the list of source viewports (as {viewportId, renderingEngineId} objects)\r\n   * @returns An array of {viewportId, renderingEngineId} objects.\r\n   */\r\n  public getSourceViewports(): Array<Types.IViewportId> {\r\n    return this._sourceViewports;\r\n  }\r\n\r\n  /**\r\n   * Get the list of target viewports (as {viewportId, renderingEngineId} objects)\r\n   * @returns An array of {viewportId, renderingEngineId} objects.\r\n   */\r\n  public getTargetViewports(): Array<Types.IViewportId> {\r\n    return this._targetViewports;\r\n  }\r\n\r\n  public destroy(): void {\r\n    this._sourceViewports.forEach((s) => this.removeSource(s));\r\n    this._targetViewports.forEach((t) => this.removeTarget(t));\r\n  }\r\n\r\n  /**\r\n   * Remove the viewport from the list of targets and sources\r\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\r\n   */\r\n  public remove(viewportInfo: Types.IViewportId): void {\r\n    this.removeTarget(viewportInfo);\r\n    this.removeSource(viewportInfo);\r\n  }\r\n\r\n  /**\r\n   * Remove the viewport from the list of source viewports\r\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\r\n   */\r\n  public removeSource(viewportInfo: Types.IViewportId): void {\r\n    const index = _getViewportIndex(this._sourceViewports, viewportInfo);\r\n\r\n    if (index === -1) {\r\n      return;\r\n    }\r\n\r\n    const element = _getViewportElement(viewportInfo);\r\n\r\n    this._sourceViewports.splice(index, 1);\r\n\r\n    //@ts-ignore\r\n    element.removeEventListener(this._eventName, this._eventHandler);\r\n\r\n    if (this._auxiliaryEventNames) {\r\n      this._auxiliaryEventNames.forEach((eventName) => {\r\n        //@ts-ignore\r\n        element.removeEventListener(eventName, this._eventHandler);\r\n      });\r\n    }\r\n    this._updateDisableHandlers();\r\n  }\r\n\r\n  /**\r\n   * Remove the viewport from the list of viewports that are currently targeted by\r\n   * this handler\r\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\r\n   *\r\n   */\r\n  public removeTarget(viewportInfo: Types.IViewportId): void {\r\n    const index = _getViewportIndex(this._targetViewports, viewportInfo);\r\n\r\n    if (index === -1) {\r\n      return;\r\n    }\r\n\r\n    this._targetViewports.splice(index, 1);\r\n    this._updateDisableHandlers();\r\n  }\r\n\r\n  public hasSourceViewport(\r\n    renderingEngineId: string,\r\n    viewportId: string\r\n  ): boolean {\r\n    return _containsViewport(this._sourceViewports, {\r\n      renderingEngineId,\r\n      viewportId,\r\n    });\r\n  }\r\n\r\n  public hasTargetViewport(\r\n    renderingEngineId: string,\r\n    viewportId: string\r\n  ): boolean {\r\n    return _containsViewport(this._targetViewports, {\r\n      renderingEngineId,\r\n      viewportId,\r\n    });\r\n  }\r\n\r\n  private fireEvent(sourceViewport: Types.IViewportId, sourceEvent: any): void {\r\n    if (this.isDisabled() || this._ignoreFiredEvents) {\r\n      return;\r\n    }\r\n\r\n    this._ignoreFiredEvents = true;\r\n    const promises = [];\r\n    try {\r\n      for (let i = 0; i < this._targetViewports.length; i++) {\r\n        const targetViewport = this._targetViewports[i];\r\n        const targetIsSource =\r\n          sourceViewport.viewportId === targetViewport.viewportId;\r\n\r\n        if (targetIsSource) {\r\n          continue;\r\n        }\r\n        const result = this._eventHandler(\r\n          this,\r\n          sourceViewport,\r\n          targetViewport,\r\n          sourceEvent,\r\n          this._options\r\n        );\r\n\r\n        // if the result is a promise, then add it to the list of promises\r\n        // to wait for before setting _ignoreFiredEvents to false\r\n        if (result instanceof Promise) {\r\n          promises.push(result);\r\n        }\r\n      }\r\n    } catch (ex) {\r\n      console.warn(`Synchronizer, for: ${this._eventName}`, ex);\r\n    } finally {\r\n      if (promises.length) {\r\n        Promise.allSettled(promises).then(() => {\r\n          this._ignoreFiredEvents = false;\r\n        });\r\n      } else {\r\n        this._ignoreFiredEvents = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  private _onEvent = (evt: any): void => {\r\n    if (this._ignoreFiredEvents === true) {\r\n      return;\r\n    }\r\n\r\n    // If no target viewports, then return immediately, this is useful\r\n    // when switching between layouts, when previous layout has disabled\r\n    // its viewports, and the new layout has not yet enabled them.\r\n    // Right now we don't \"delete\" the synchronizer if all source and targets\r\n    // are removed, but we may want to do that in the future.\r\n    if (!this._targetViewports.length) {\r\n      return;\r\n    }\r\n\r\n    const enabledElement = getEnabledElement(evt.currentTarget);\r\n\r\n    if (!enabledElement) {\r\n      return;\r\n    }\r\n\r\n    const { renderingEngineId, viewportId } = enabledElement;\r\n\r\n    // If the viewport has been removed from the synchronizer before the event is\r\n    // fired, then return immediately.\r\n    if (!this._sourceViewports.find((s) => s.viewportId === viewportId)) {\r\n      return;\r\n    }\r\n\r\n    this.fireEvent(\r\n      {\r\n        renderingEngineId,\r\n        viewportId,\r\n      },\r\n      evt\r\n    );\r\n  };\r\n\r\n  private _hasSourceElements(): boolean {\r\n    return this._sourceViewports.length !== 0;\r\n  }\r\n\r\n  private _updateDisableHandlers(): void {\r\n    const viewports = _getUniqueViewports(\r\n      this._sourceViewports,\r\n      this._targetViewports\r\n    );\r\n    const _remove = this.remove;\r\n    const disableHandler = (elementDisabledEvent) => {\r\n      _remove(elementDisabledEvent.detail.element);\r\n    };\r\n\r\n    viewports.forEach(function (vUid) {\r\n      const renderingEngine = getRenderingEngine(vUid.renderingEngineId);\r\n\r\n      if (!renderingEngine) {\r\n        return;\r\n      }\r\n\r\n      const viewport = renderingEngine.getViewport(vUid.viewportId);\r\n\r\n      if (!viewport) {\r\n        return;\r\n      }\r\n\r\n      const { element } = viewport;\r\n\r\n      element.removeEventListener(\r\n        Enums.Events.ELEMENT_DISABLED,\r\n        disableHandler\r\n      );\r\n      element.addEventListener(Enums.Events.ELEMENT_DISABLED, disableHandler);\r\n    });\r\n  }\r\n}\r\n\r\nfunction _getUniqueViewports(\r\n  vp1: Array<Types.IViewportId>,\r\n  vp2: Array<Types.IViewportId>\r\n): Array<Types.IViewportId> {\r\n  const unique = [];\r\n\r\n  const vps = vp1.concat(vp2);\r\n\r\n  for (let i = 0; i < vps.length; i++) {\r\n    const vp = vps[i];\r\n    if (\r\n      !unique.some(\r\n        (u) =>\r\n          vp.renderingEngineId === u.renderingEngineId &&\r\n          vp.viewportId === u.viewportId\r\n      )\r\n    ) {\r\n      unique.push(vp);\r\n    }\r\n  }\r\n\r\n  return unique;\r\n}\r\n\r\nfunction _getViewportIndex(\r\n  arr: Array<Types.IViewportId>,\r\n  vp: Types.IViewportId\r\n): number {\r\n  return arr.findIndex(\r\n    (ar) =>\r\n      vp.renderingEngineId === ar.renderingEngineId &&\r\n      vp.viewportId === ar.viewportId\r\n  );\r\n}\r\n\r\nfunction _containsViewport(\r\n  arr: Array<Types.IViewportId>,\r\n  vp: Types.IViewportId\r\n) {\r\n  return arr.some(\r\n    (ar) =>\r\n      ar.renderingEngineId === vp.renderingEngineId &&\r\n      ar.viewportId === vp.viewportId\r\n  );\r\n}\r\n\r\nfunction _getViewportElement(vp: Types.IViewportId): HTMLDivElement {\r\n  const renderingEngine = getRenderingEngine(vp.renderingEngineId);\r\n  if (!renderingEngine) {\r\n    throw new Error(`No RenderingEngine for Id: ${vp.renderingEngineId}`);\r\n  }\r\n\r\n  return renderingEngine.getViewport(vp.viewportId).element;\r\n}\r\n\r\nexport default Synchronizer;\r\n","import { state } from '../index';\r\nimport Synchronizer from './Synchronizer';\r\n\r\n/**\r\n * It returns all synchronizers that are not disabled and have a source viewport\r\n * with the given rendering engine Id and viewport Id\r\n * @param renderingEngineId - The Id of the rendering engine\r\n * @param viewportId - The Id of the viewport\r\n * @returns An array of synchronizers\r\n */\r\nfunction getSynchronizersForViewport(\r\n  viewportId: string,\r\n  renderingEngineId: string\r\n): Array<Synchronizer> {\r\n  const synchronizersFilteredByIds = [];\r\n\r\n  if (!renderingEngineId && !viewportId) {\r\n    throw new Error(\r\n      'At least one of renderingEngineId or viewportId should be given'\r\n    );\r\n  }\r\n\r\n  for (let i = 0; i < state.synchronizers.length; i++) {\r\n    const synchronizer = state.synchronizers[i];\r\n    const notDisabled = !synchronizer.isDisabled();\r\n    const hasSourceViewport = synchronizer.hasSourceViewport(\r\n      renderingEngineId,\r\n      viewportId\r\n    );\r\n\r\n    const hasTargetViewport = synchronizer.hasTargetViewport(\r\n      renderingEngineId,\r\n      viewportId\r\n    );\r\n\r\n    if (notDisabled && (hasSourceViewport || hasTargetViewport)) {\r\n      synchronizersFilteredByIds.push(synchronizer);\r\n    }\r\n  }\r\n\r\n  return synchronizersFilteredByIds;\r\n}\r\n\r\nexport default getSynchronizersForViewport;\r\n","import { state } from '../index';\r\nimport Synchronizer from './Synchronizer';\r\nimport { ISynchronizerEventHandler } from '../../types';\r\n\r\n/**\r\n * Create a new synchronizer instance from Synchronizer class\r\n * @param synchronizerId - The id of the synchronizer.\r\n * @param eventName - The name of the event that will be emitted by the\r\n * synchronizer.\r\n * @param eventHandler - The event handler that will be\r\n * called when the event is emitted.\r\n * @param options - Options for the synchronizer.\r\n * @returns A reference to the synchronizer.\r\n */\r\nfunction createSynchronizer(\r\n  synchronizerId: string,\r\n  eventName: string,\r\n  eventHandler: ISynchronizerEventHandler,\r\n  options?: any\r\n): Synchronizer {\r\n  const synchronizerWithSameIdExists = state.synchronizers.some(\r\n    (sync) => sync.id === synchronizerId\r\n  );\r\n\r\n  if (synchronizerWithSameIdExists) {\r\n    throw new Error(`Synchronizer with id '${synchronizerId}' already exists.`);\r\n  }\r\n\r\n  // Create\r\n  const synchronizer = new Synchronizer(\r\n    synchronizerId,\r\n    eventName,\r\n    eventHandler,\r\n    options\r\n  );\r\n\r\n  // Update state\r\n  state.synchronizers.push(synchronizer);\r\n\r\n  // Return reference\r\n  return synchronizer;\r\n}\r\n\r\nexport default createSynchronizer;\r\n","import { state } from '../index';\r\n\r\n/**\r\n * \"Destroy all synchronizers.\"\r\n */\r\nfunction destroy(): void {\r\n  while (state.synchronizers.length > 0) {\r\n    const synchronizer = state.synchronizers.pop();\r\n\r\n    synchronizer.destroy();\r\n  }\r\n}\r\n\r\nexport default destroy;\r\n","import { state } from '../index';\r\nimport Synchronizer from './Synchronizer';\r\n\r\n/**\r\n * Get the synchronizer with the given id from the state.\r\n * @param synchronizerId - The id of the synchronizer to be retrieved.\r\n * @returns A synchronizer object.\r\n */\r\nfunction getSynchronizer(synchronizerId: string): Synchronizer | void {\r\n  return state.synchronizers.find((s) => s.id === synchronizerId);\r\n}\r\n\r\nexport default getSynchronizer;\r\n","import { state } from '../index';\r\nimport Synchronizer from './Synchronizer';\r\n\r\n/**\r\n * Return the array of synchronizers\r\n * @returns An array of synchronizers.\r\n */\r\nfunction getAllSynchronizers(): Array<Synchronizer> {\r\n  return state.synchronizers;\r\n}\r\n\r\nexport default getAllSynchronizers;\r\n","import { state } from '../index';\r\n\r\n// Synchronizers are a bit more tenacious. We need to make sure we remove\r\n// any attached events\r\n// We should probably just have a destroySynchronizer call\r\n// then use getByX to allow versatility in how we can call destroy\r\n\r\n/**\r\n * Destroy a synchronizer by its ID.\r\n * @param synchronizerId - The id of the synchronizer to destroy.\r\n */\r\nfunction destroySynchronizer(synchronizerId: string): void {\r\n  const synchronizerIndex = state.synchronizers.findIndex(\r\n    (sync) => sync.id === synchronizerId\r\n  );\r\n\r\n  if (synchronizerIndex > -1) {\r\n    const synchronizer = state.synchronizers[synchronizerIndex];\r\n\r\n    synchronizer.destroy();\r\n    state.synchronizers.splice(synchronizerIndex, 1);\r\n  }\r\n}\r\n\r\nexport default destroySynchronizer;\r\n","import { getRenderingEngines } from '@cornerstonejs/core';\r\nimport { state } from '../index';\r\nimport { IToolGroup } from '../../types';\r\n\r\n/**\r\n * Given a rendering engine Id and a viewport Id, return the tool group that\r\n * contains that rendering engine and viewport. Note: A viewport can only be\r\n * associated with a single tool group. You cannot have a viewport that belongs\r\n * to multiple tool groups. To achieve so, create a new viewport and a new toolGroup\r\n * for it. This will not impact memory usage much as the volume textures are\r\n * shared across all viewports rendering the same image.\r\n *\r\n * @param viewportId - The Id of the viewport that the tool is being\r\n * added to.\r\n * @param renderingEngineId - The Id of the rendering engine that the\r\n * tool group is associated with.\r\n * @returns A tool group.\r\n */\r\nfunction getToolGroupForViewport(\r\n  viewportId: string,\r\n  renderingEngineId?: string\r\n): IToolGroup | undefined {\r\n  if (!renderingEngineId) {\r\n    renderingEngineId = getRenderingEngines().find((re) =>\r\n      re.getViewports().find((vp) => vp.id === viewportId)\r\n    )?.id;\r\n  }\r\n\r\n  const toolGroupFilteredByIds = state.toolGroups.filter((tg) =>\r\n    tg.viewportsInfo.some(\r\n      (vp) =>\r\n        vp.renderingEngineId === renderingEngineId &&\r\n        (!vp.viewportId || vp.viewportId === viewportId)\r\n    )\r\n  );\r\n\r\n  if (!toolGroupFilteredByIds.length) {\r\n    return;\r\n  }\r\n\r\n  if (toolGroupFilteredByIds.length > 1) {\r\n    throw new Error(\r\n      `Multiple tool groups found for renderingEngineId: ${renderingEngineId} and viewportId: ${viewportId}. You should only\r\n      have one tool group per viewport in a renderingEngine.`\r\n    );\r\n  }\r\n\r\n  return toolGroupFilteredByIds[0];\r\n}\r\n\r\nexport default getToolGroupForViewport;\r\n","import { state } from './state';\r\n\r\n/**\r\n * Adds the tool class to the cornerstoneTools to be used later. This function\r\n * should be called before creating the toolGroups and adding tools and setting their mode.\r\n * The flow is:\r\n * - addTool(ToolClass) // where ToolClass is the tool constructor imported from CornerstoneTools or created by a 3rd party\r\n * - createToolGroup(toolGroupId)\r\n * - toolGroup.addTool(${toolName}) // NOT THE TOOL CLASS\r\n * - toolGroup.setToolActive(${toolName})\r\n *\r\n * @param ToolClass - A tool calls to instantiate.\r\n * @param toolOptions - The tool-specific configuration options for the tool.\r\n * @returns\r\n */\r\nexport function addTool(ToolClass): void {\r\n  // Check if tool exists and name is not undefined\r\n  const toolName = ToolClass.toolName;\r\n  const toolAlreadyAdded = state.tools[toolName] !== undefined;\r\n\r\n  if (!toolName) {\r\n    throw new Error(`No Tool Found for the ToolClass ${ToolClass.name}`);\r\n  }\r\n\r\n  if (toolAlreadyAdded) {\r\n    throw new Error(`${toolName} has already been added globally`);\r\n  }\r\n\r\n  // Stores the toolNames and ToolClass to be instantiated in the toolGroup on toolGroup.addTool\r\n  state.tools[toolName] = {\r\n    toolClass: ToolClass,\r\n  };\r\n}\r\n\r\n/**\r\n * Check if a given tool is already registered\r\n * @param ToolClass - A tool class to check\r\n * @returns True if the tool is alredy registered or false otherwise\r\n */\r\nexport function hasTool(ToolClass): boolean {\r\n  const toolName = ToolClass.toolName;\r\n\r\n  return !!(toolName && state.tools[toolName]);\r\n}\r\n\r\n/**\r\n * Removes the tool class from the cornerstoneTools.\r\n *\r\n * @param ToolClass - A tool calls to instantiate.\r\n */\r\nexport function removeTool(ToolClass): void {\r\n  const toolName = ToolClass.toolName;\r\n\r\n  if (!toolName) {\r\n    throw new Error(`No tool found for: ${ToolClass.name}`);\r\n  }\r\n\r\n  if (!state.tools[toolName] !== undefined) {\r\n    delete state.tools[toolName];\r\n  } else {\r\n    throw new Error(\r\n      `${toolName} cannot be removed because it has not been added`\r\n    );\r\n  }\r\n}\r\n\r\nexport default addTool;\r\n","import { Types } from '@cornerstonejs/core';\r\nimport {\r\n  mouseEventListeners,\r\n  wheelEventListener,\r\n  touchEventListeners,\r\n  keyEventListener,\r\n  imageChangeEventListener,\r\n} from '../eventListeners';\r\nimport {\r\n  imageRenderedEventDispatcher,\r\n  cameraModifiedEventDispatcher,\r\n  mouseToolEventDispatcher,\r\n  touchToolEventDispatcher,\r\n  keyboardToolEventDispatcher,\r\n  imageSpacingCalibratedEventDispatcher,\r\n  cameraResetEventDispatcher,\r\n} from '../eventDispatchers';\r\nimport { state } from './state';\r\n\r\nimport { annotationRenderingEngine } from '../utilities/triggerAnnotationRender';\r\n\r\n/**\r\n * When an element is \"enabled\", add event listeners and dispatchers to it\r\n * so we can use interactions to affect tool behaviors\r\n *\r\n * @param evt - The ELEMENT_ENABLED event\r\n */\r\nexport default function addEnabledElement(\r\n  evt: Types.EventTypes.ElementEnabledEvent\r\n): void {\r\n  const { element, viewportId } = evt.detail;\r\n  const svgLayer = _createSvgAnnotationLayer(viewportId);\r\n\r\n  // Reset/Create svgNodeCache for element\r\n  _setSvgNodeCache(element);\r\n  _appendChild(svgLayer, element);\r\n\r\n  // Add this element to the annotation rendering engine\r\n  annotationRenderingEngine.addViewportElement(viewportId, element);\r\n\r\n  // Listeners\r\n  mouseEventListeners.enable(element);\r\n  wheelEventListener.enable(element);\r\n  touchEventListeners.enable(element);\r\n  keyEventListener.enable(element);\r\n  imageChangeEventListener.enable(element);\r\n\r\n  // Dispatchers: renderer\r\n  imageRenderedEventDispatcher.enable(element);\r\n  cameraModifiedEventDispatcher.enable(element);\r\n  imageSpacingCalibratedEventDispatcher.enable(element);\r\n  cameraResetEventDispatcher.enable(element);\r\n  // Dispatchers: interaction\r\n  mouseToolEventDispatcher.enable(element);\r\n  keyboardToolEventDispatcher.enable(element);\r\n  touchToolEventDispatcher.enable(element);\r\n\r\n  // labelmap\r\n  // State\r\n  state.enabledElements.push(element);\r\n}\r\n\r\n/**\r\n *\r\n */\r\nfunction _createSvgAnnotationLayer(viewportId: string): SVGElement {\r\n  const svgns = 'http://www.w3.org/2000/svg';\r\n  const svgLayer = document.createElementNS(svgns, 'svg');\r\n\r\n  const svgLayerId = `svg-layer-${viewportId}`;\r\n  svgLayer.classList.add('svg-layer');\r\n  svgLayer.setAttribute('id', svgLayerId);\r\n  svgLayer.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\r\n  svgLayer.style.width = '100%';\r\n  svgLayer.style.height = '100%';\r\n  svgLayer.style.pointerEvents = 'none';\r\n  svgLayer.style.position = 'absolute';\r\n  // TODO: we should test this on high-res monitors\r\n  //svgLayer.style.textRendering = 'optimizeSpeed'\r\n\r\n  // Single dropshadow config for now\r\n  const defs = document.createElementNS(svgns, 'defs');\r\n  const filter = document.createElementNS(svgns, 'filter');\r\n  const feOffset = document.createElementNS(svgns, 'feOffset');\r\n  const feColorMatrix = document.createElementNS(svgns, 'feColorMatrix');\r\n  const feBlend = document.createElementNS(svgns, 'feBlend');\r\n\r\n  //\r\n  filter.setAttribute('id', `shadow-${svgLayerId}`);\r\n  filter.setAttribute('filterUnits', 'userSpaceOnUse');\r\n\r\n  //\r\n  feOffset.setAttribute('result', 'offOut');\r\n  feOffset.setAttribute('in', 'SourceGraphic');\r\n  feOffset.setAttribute('dx', '0.5');\r\n  feOffset.setAttribute('dy', '0.5');\r\n\r\n  //\r\n  feColorMatrix.setAttribute('result', 'matrixOut');\r\n  feColorMatrix.setAttribute('in', 'offOut');\r\n  feColorMatrix.setAttribute('in2', 'matrix');\r\n  feColorMatrix.setAttribute(\r\n    'values',\r\n    '0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0'\r\n  );\r\n\r\n  //\r\n  feBlend.setAttribute('in', 'SourceGraphic');\r\n  feBlend.setAttribute('in2', 'matrixOut');\r\n  feBlend.setAttribute('mode', 'normal');\r\n\r\n  filter.appendChild(feOffset);\r\n  filter.appendChild(feColorMatrix);\r\n  filter.appendChild(feBlend);\r\n  defs.appendChild(filter);\r\n  svgLayer.appendChild(defs);\r\n\r\n  return svgLayer;\r\n}\r\n\r\nfunction _setSvgNodeCache(element) {\r\n  const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } =\r\n    element.dataset;\r\n  const elementHash = `${viewportId}:${renderingEngineId}`;\r\n\r\n  // Create or reset\r\n  // TODO: If... Reset, we should blow out any nodes in DOM\r\n  state.svgNodeCache[elementHash] = {};\r\n}\r\n\r\n/**\r\n *\r\n * @param newNode\r\n * @param referenceNode\r\n */\r\nfunction _appendChild(\r\n  newNode: SVGElement,\r\n  referenceNode: HTMLDivElement\r\n): void {\r\n  referenceNode.querySelector('div.viewport-element').appendChild(newNode);\r\n}\r\n","import { getEnabledElement, Types } from '@cornerstonejs/core';\r\nimport {\r\n  mouseEventListeners,\r\n  wheelEventListener,\r\n  touchEventListeners,\r\n  keyEventListener,\r\n  imageChangeEventListener,\r\n} from '../eventListeners';\r\nimport {\r\n  imageRenderedEventDispatcher,\r\n  cameraModifiedEventDispatcher,\r\n  mouseToolEventDispatcher,\r\n  keyboardToolEventDispatcher,\r\n  imageSpacingCalibratedEventDispatcher,\r\n  touchToolEventDispatcher,\r\n  cameraResetEventDispatcher,\r\n} from '../eventDispatchers';\r\n// ~~\r\n\r\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\r\nimport { state } from './state';\r\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\r\nimport { ToolModes } from '../enums';\r\nimport { removeAnnotation } from '../stateManagement';\r\nimport getSynchronizersForViewport from './SynchronizerManager/getSynchronizersForViewport';\r\nimport getToolGroupForViewport from './ToolGroupManager/getToolGroupForViewport';\r\nimport { annotationRenderingEngine } from '../utilities/triggerAnnotationRender';\r\n\r\nconst VIEWPORT_ELEMENT = 'viewport-element';\r\n\r\nfunction removeEnabledElement(\r\n  elementDisabledEvt: Types.EventTypes.ElementDisabledEvent\r\n): void {\r\n  // Is DOM element\r\n  const { element, viewportId } = elementDisabledEvt.detail;\r\n\r\n  _resetSvgNodeCache(element);\r\n  _removeSvgNode(element);\r\n\r\n  // Remove this element from the annotation rendering engine\r\n  annotationRenderingEngine.removeViewportElement(viewportId, element);\r\n\r\n  // Listeners\r\n  mouseEventListeners.disable(element);\r\n  wheelEventListener.disable(element);\r\n  touchEventListeners.disable(element);\r\n  keyEventListener.disable(element);\r\n\r\n  // labelmap\r\n  imageChangeEventListener.disable(element);\r\n\r\n  // Dispatchers: renderer\r\n  imageRenderedEventDispatcher.disable(element);\r\n  cameraModifiedEventDispatcher.disable(element);\r\n  imageSpacingCalibratedEventDispatcher.disable(element);\r\n  cameraResetEventDispatcher.disable(element);\r\n\r\n  // Dispatchers: interaction\r\n  mouseToolEventDispatcher.disable(element);\r\n  keyboardToolEventDispatcher.disable(element);\r\n  touchToolEventDispatcher.disable(element);\r\n\r\n  // State\r\n  // @TODO: We used to \"disable\" the tool before removal. Should we preserve the hook that would call on tools?\r\n  _removeViewportFromSynchronizers(element);\r\n  _removeViewportFromToolGroup(element);\r\n\r\n  // _removeAllToolsForElement(canvas)\r\n  _removeEnabledElement(element);\r\n}\r\n\r\nconst _removeViewportFromSynchronizers = (element: HTMLDivElement) => {\r\n  const enabledElement = getEnabledElement(element);\r\n\r\n  const synchronizers = getSynchronizersForViewport(\r\n    enabledElement.viewportId,\r\n    enabledElement.renderingEngineId\r\n  );\r\n  synchronizers.forEach((sync) => {\r\n    sync.remove(enabledElement);\r\n  });\r\n};\r\n\r\nconst _removeViewportFromToolGroup = (element: HTMLDivElement) => {\r\n  const { renderingEngineId, viewportId } = getEnabledElement(element);\r\n\r\n  const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\r\n\r\n  if (toolGroup) {\r\n    toolGroup.removeViewports(renderingEngineId, viewportId);\r\n  }\r\n};\r\n\r\nconst _removeAllToolsForElement = function (element) {\r\n  const tools = getToolsWithModesForElement(element, [\r\n    ToolModes.Active,\r\n    ToolModes.Passive,\r\n  ]);\r\n\r\n  const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\r\n  toolsWithData.forEach(({ annotations }) => {\r\n    annotations.forEach((annotation) => {\r\n      removeAnnotation(annotation.annotationUID);\r\n    });\r\n  });\r\n};\r\n\r\nfunction _resetSvgNodeCache(element: HTMLDivElement) {\r\n  const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } =\r\n    element.dataset;\r\n  const elementHash = `${viewportId}:${renderingEngineId}`;\r\n\r\n  delete state.svgNodeCache[elementHash];\r\n}\r\n\r\nfunction _removeSvgNode(element: HTMLDivElement) {\r\n  const internalViewportNode = element.querySelector(`div.${VIEWPORT_ELEMENT}`);\r\n  const svgLayer = internalViewportNode.querySelector('svg');\r\n  if (svgLayer) {\r\n    internalViewportNode.removeChild(svgLayer);\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * @param enabledElement\r\n */\r\nconst _removeEnabledElement = function (element: HTMLDivElement) {\r\n  const foundElementIndex = state.enabledElements.findIndex(\r\n    (el) => el === element\r\n  );\r\n\r\n  if (foundElementIndex > -1) {\r\n    state.enabledElements.splice(foundElementIndex, 1);\r\n  }\r\n};\r\n\r\nexport default removeEnabledElement;\r\n","import { ToolModes } from '../enums';\r\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\r\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\r\n\r\n/**\r\n * Cancel the current active manipulation that is being performed on the provided\r\n * element. It filters all the active and passive tools for the enabledElement\r\n * and calls cancel() method for all of them, and returns the tool that has executed its\r\n * cancellation (returned its annotationUID), since tools that are not being manipulated will\r\n * short circuit early. Note: not all tools currently implement a cancel method.\r\n *\r\n * @param element - canvas element\r\n * @returns annotationUID that is cancelled\r\n */\r\nexport default function cancelActiveManipulations(\r\n  element: HTMLDivElement\r\n): string | undefined {\r\n  const tools = getToolsWithModesForElement(element, [\r\n    ToolModes.Active,\r\n    ToolModes.Passive,\r\n  ]);\r\n\r\n  const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\r\n  for (const { tool } of toolsWithData) {\r\n    const annotationUID = tool.cancel(element);\r\n    if (annotationUID) {\r\n      return annotationUID;\r\n    }\r\n  }\r\n}\r\n","import { IToolGroup, IToolClassReference } from '../types';\r\nimport Synchronizer from './SynchronizerManager/Synchronizer';\r\nimport svgNodeCache, { resetSvgNodeCache } from './svgNodeCache';\r\nimport cloneDeep from 'lodash.clonedeep';\r\n\r\ninterface ICornerstoneTools3dState {\r\n  isInteractingWithTool: boolean;\r\n  isMultiPartToolActive: boolean;\r\n  tools: Record<\r\n    string,\r\n    {\r\n      toolClass: IToolClassReference;\r\n    }\r\n  >;\r\n  toolGroups: Array<IToolGroup>;\r\n  synchronizers: Array<Synchronizer>;\r\n  svgNodeCache: Record<string, unknown>;\r\n  enabledElements: Array<unknown>;\r\n  handleRadius: number;\r\n}\r\n\r\nconst defaultState: ICornerstoneTools3dState = {\r\n  isInteractingWithTool: false,\r\n  isMultiPartToolActive: false,\r\n  tools: {},\r\n  toolGroups: [],\r\n  synchronizers: [],\r\n  svgNodeCache: svgNodeCache,\r\n  // Should this be named... canvases?\r\n  enabledElements: [], // switch to Uids?\r\n  handleRadius: 6,\r\n};\r\n\r\nlet state: ICornerstoneTools3dState = {\r\n  isInteractingWithTool: false,\r\n  isMultiPartToolActive: false,\r\n  tools: {},\r\n  toolGroups: [],\r\n  synchronizers: [],\r\n  svgNodeCache: svgNodeCache,\r\n  // Should this be named... canvases?\r\n  enabledElements: [], // switch to Uids?\r\n  handleRadius: 6,\r\n};\r\n\r\nfunction resetCornerstoneToolsState(): void {\r\n  resetSvgNodeCache();\r\n  state = {\r\n    ...cloneDeep({\r\n      ...defaultState,\r\n      svgNodeCache: {},\r\n    }),\r\n    svgNodeCache: {\r\n      ...defaultState.svgNodeCache,\r\n    },\r\n  };\r\n}\r\n\r\nexport {\r\n  ICornerstoneTools3dState,\r\n  resetCornerstoneToolsState,\r\n  state,\r\n  state as default,\r\n};\r\n","let svgNodeCache = {};\r\n\r\nexport function resetSvgNodeCache(): void {\r\n  svgNodeCache = {};\r\n}\r\n\r\nexport default svgNodeCache;\r\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\r\nimport { Synchronizer } from '../../store';\r\n\r\n/**\r\n * Synchronizer callback to synchronize the camera by updating all camera\r\n * values.  See also zoomPanSyncCallback\r\n *\r\n * @param synchronizerInstance - The Instance of the Synchronizer\r\n * @param sourceViewport - The list of IDs defining the source viewport.\r\n * @param targetViewport - The list of IDs defining the target viewport, never\r\n *   the same as sourceViewport.\r\n * @param cameraModifiedEvent - The CAMERA_MODIFIED event.\r\n */\r\nexport default function cameraSyncCallback(\r\n  synchronizerInstance: Synchronizer,\r\n  sourceViewport: Types.IViewportId,\r\n  targetViewport: Types.IViewportId,\r\n  cameraModifiedEvent: CustomEvent\r\n): void {\r\n  const { camera } = cameraModifiedEvent.detail;\r\n\r\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\r\n  if (!renderingEngine) {\r\n    throw new Error(\r\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\r\n    );\r\n  }\r\n\r\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\r\n\r\n  tViewport.setCamera(camera);\r\n  tViewport.render();\r\n}\r\n","import { createSynchronizer } from '../../store/SynchronizerManager';\r\nimport { Enums } from '@cornerstonejs/core';\r\nimport cameraSyncCallback from '../callbacks/cameraSyncCallback';\r\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\r\n\r\nconst { CAMERA_MODIFIED } = Enums.Events;\r\n\r\n/**\r\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\r\n * rendering event and calls the `cameraSyncCallback`.\r\n *\r\n * @param synchronizerName - The name of the synchronizer.\r\n * @returns A new `Synchronizer` instance.\r\n */\r\nexport default function createCameraPositionSynchronizer(\r\n  synchronizerName: string\r\n): Synchronizer {\r\n  const cameraPositionSynchronizer = createSynchronizer(\r\n    synchronizerName,\r\n    CAMERA_MODIFIED,\r\n    cameraSyncCallback\r\n  );\r\n\r\n  return cameraPositionSynchronizer;\r\n}\r\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Synchronizer callback to synchronize the camera. Synchronization\r\n *\r\n * targetViewport.options.syncZoom set to false to not sync the zoom\r\n * targetViewport.options.syncPan set to false to not sync the pan\r\n\r\n * @param synchronizerInstance - The Instance of the Synchronizer\r\n * @param sourceViewport - The list of IDs defining the source viewport.\r\n * @param targetViewport - The list of IDs defining the target viewport, different\r\n *   from sourceViewport\r\n */\r\nexport default function presentationViewSyncCallback(\r\n  _synchronizerInstance,\r\n  sourceViewport: Types.IViewportId,\r\n  targetViewport: Types.IViewportId,\r\n  _sourceEvent,\r\n  options?: Types.ViewPresentationSelector\r\n): void {\r\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\r\n  if (!renderingEngine) {\r\n    throw new Error(\r\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\r\n    );\r\n  }\r\n\r\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\r\n  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\r\n\r\n  const presentationView = sViewport.getViewPresentation(options);\r\n\r\n  tViewport.setViewPresentation(presentationView);\r\n\r\n  tViewport.render();\r\n}\r\n","import { Enums } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport { createSynchronizer } from '../../store/SynchronizerManager';\r\nimport presentationViewSyncCallback from '../callbacks/presentationViewSyncCallback';\r\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\r\n\r\nconst { CAMERA_MODIFIED } = Enums.Events;\r\n\r\n/**\r\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\r\n * rendering event and calls the `cameraSyncCallback` based on presentation view\r\n * values and not based on absolute camera positions.\r\n *\r\n * @param synchronizerName - The name of the synchronizer.\r\n * @returns A new `Synchronizer` instance.\r\n */\r\nexport default function createPresentationViewSynchronizer(\r\n  synchronizerName: string,\r\n  options?: Types.ViewPresentation\r\n): Synchronizer {\r\n  const presentationView = createSynchronizer(\r\n    synchronizerName,\r\n    CAMERA_MODIFIED,\r\n    presentationViewSyncCallback,\r\n    options\r\n  );\r\n\r\n  return presentationView;\r\n}\r\n","import {\r\n  BaseVolumeViewport,\r\n  getRenderingEngine,\r\n  StackViewport,\r\n  Types,\r\n} from '@cornerstonejs/core';\r\n\r\n/**\r\n * Synchronizer callback to synchronize the voi of volumeActors of identical volumes\r\n * in different viewports.\r\n *\r\n * @param synchronizerInstance - The Instance of the Synchronizer\r\n * @param sourceViewport - The list of IDs defining the source viewport.\r\n * @param targetViewport - The list of IDs defining the target viewport.\r\n * @param modifiedEvent - The COLORMAP_MODIFIED or VOI_MODIFIED event.\r\n * @param options - Options for the synchronizer.\r\n */\r\nexport default function voiSyncCallback(\r\n  synchronizerInstance,\r\n  sourceViewport: Types.IViewportId,\r\n  targetViewport: Types.IViewportId,\r\n  modifiedEvent: any,\r\n  options?: any\r\n): void {\r\n  const eventDetail = modifiedEvent.detail;\r\n  const { volumeId, range, invertStateChanged, invert, colormap } = eventDetail;\r\n\r\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\r\n  if (!renderingEngine) {\r\n    throw new Error(\r\n      `Rendering Engine does not exist: ${targetViewport.renderingEngineId}`\r\n    );\r\n  }\r\n\r\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\r\n  const tProperties:\r\n    | Types.VolumeViewportProperties\r\n    | Types.StackViewportProperties = {\r\n    voiRange: range,\r\n  };\r\n\r\n  if (options?.syncInvertState && invertStateChanged) {\r\n    tProperties.invert = invert;\r\n  }\r\n  if (options?.syncColormap && colormap) {\r\n    tProperties.colormap = colormap;\r\n  }\r\n\r\n  if (tViewport instanceof BaseVolumeViewport) {\r\n    const isFusion = tViewport._actors && tViewport._actors.size > 1;\r\n    if (isFusion) {\r\n      tViewport.setProperties(tProperties, volumeId);\r\n    } else {\r\n      tViewport.setProperties(tProperties);\r\n    }\r\n  } else if (tViewport instanceof StackViewport) {\r\n    tViewport.setProperties(tProperties);\r\n  } else {\r\n    throw new Error('Viewport type not supported.');\r\n  }\r\n\r\n  tViewport.render();\r\n}\r\n","import { createSynchronizer } from '../../store/SynchronizerManager';\r\nimport { Enums } from '@cornerstonejs/core';\r\nimport voiSyncCallback from '../callbacks/voiSyncCallback';\r\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\r\n\r\ntype VOISynchronizerOptions = {\r\n  syncInvertState: boolean;\r\n  syncColormap: boolean;\r\n};\r\n\r\n/**\r\n * A helper that creates a new `Synchronizer`\r\n * which listens to the `VOI_MODIFIED` rendering event and calls the `voiSyncCallback`.\r\n *\r\n * @param synchronizerName - The name of the synchronizer.\r\n * @param options - The options for the synchronizer. By default the voi\r\n * synchronizer will also sync the invert state of the volume, but this can be\r\n * disabled by setting `syncInvertState` to false.\r\n *\r\n * @returns A new `Synchronizer` instance.\r\n */\r\nexport default function createVOISynchronizer(\r\n  synchronizerName: string,\r\n  options: VOISynchronizerOptions\r\n): Synchronizer {\r\n  //  = { syncInvertState: true } if options is not provided or undefined or {}\r\n  options = Object.assign(\r\n    { syncInvertState: true, syncColormap: true },\r\n    options\r\n  );\r\n\r\n  const VOISynchronizer = createSynchronizer(\r\n    synchronizerName,\r\n    Enums.Events.VOI_MODIFIED,\r\n    voiSyncCallback,\r\n    {\r\n      auxiliaryEventNames: [Enums.Events.COLORMAP_MODIFIED],\r\n      ...options,\r\n    }\r\n  );\r\n\r\n  return VOISynchronizer;\r\n}\r\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\r\nimport { Synchronizer } from '../../store';\r\n\r\n/**\r\n * Synchronizer callback to synchronize the camera. Synchronization\r\n *\r\n * targetViewport.options.syncZoom set to false to not sync the zoom\r\n * targetViewport.options.syncPan set to false to not sync the pan\r\n\r\n * @param synchronizerInstance - The Instance of the Synchronizer\r\n * @param sourceViewport - The list of IDs defining the source viewport.\r\n * @param targetViewport - The list of IDs defining the target viewport, different\r\n *   from sourceViewport\r\n */\r\nexport default function zoomPanSyncCallback(\r\n  synchronizerInstance: Synchronizer,\r\n  sourceViewport: Types.IViewportId,\r\n  targetViewport: Types.IViewportId\r\n): void {\r\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\r\n  if (!renderingEngine) {\r\n    throw new Error(\r\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\r\n    );\r\n  }\r\n\r\n  const options = synchronizerInstance.getOptions(targetViewport.viewportId);\r\n\r\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\r\n  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\r\n\r\n  if (options?.syncZoom !== false) {\r\n    const srcZoom = sViewport.getZoom();\r\n    // Do the zoom first, as the pan is relative to the zoom level\r\n    tViewport.setZoom(srcZoom);\r\n  }\r\n  if (options?.syncPan !== false) {\r\n    const srcPan = sViewport.getPan();\r\n    tViewport.setPan(srcPan);\r\n  }\r\n\r\n  tViewport.render();\r\n}\r\n","import { createSynchronizer } from '../../store/SynchronizerManager';\r\nimport { Enums } from '@cornerstonejs/core';\r\nimport zoomPanSyncCallback from '../callbacks/zoomPanSyncCallback';\r\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\r\n\r\nconst { CAMERA_MODIFIED } = Enums.Events;\r\n\r\n/**\r\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\r\n * rendering event and calls the `cameraSyncCallback`.\r\n *\r\n * @param synchronizerName - The name of the synchronizer.\r\n * @returns A new `Synchronizer` instance.\r\n */\r\nexport default function createZoomPanSynchronizer(\r\n  synchronizerName: string\r\n): Synchronizer {\r\n  const zoomPanSynchronizer = createSynchronizer(\r\n    synchronizerName,\r\n    CAMERA_MODIFIED,\r\n    zoomPanSyncCallback\r\n  );\r\n\r\n  return zoomPanSynchronizer;\r\n}\r\n","import { vec3, mat4 } from 'gl-matrix';\r\nimport {\r\n  getRenderingEngine,\r\n  Types,\r\n  metaData,\r\n  utilities,\r\n  VolumeViewport,\r\n} from '@cornerstonejs/core';\r\nimport { Synchronizer } from '../../store';\r\nimport { jumpToSlice } from '../../utilities';\r\nimport areViewportsCoplanar from './areViewportsCoplanar ';\r\n\r\nconst getSpatialRegistration = (targetId, sourceId) =>\r\n  utilities.spatialRegistrationMetadataProvider.get(\r\n    'spatialRegistrationModule',\r\n    targetId,\r\n    sourceId\r\n  );\r\n\r\n/**\r\n * Synchronizer callback to synchronize the source viewport image to the\r\n * target viewports closest image in its stack.\r\n *\r\n * This synchronizer does a setup (which can already be predefined as required)\r\n * to register the target and soruce viewports.  The registration will default\r\n * to the identity registration if the same FOR is present in both viewports,\r\n * unless the option `useInitialPosition` is set in the target viewport.\r\n *\r\n * The consuming apps using Cornerstone3D (OHIF, etc) MAY provide such data in\r\n * the registrationMetadataProvider to override the data here. This can be done\r\n * by various methods 1) Using spatialRegistrationModule inside dicom 2) assuming\r\n * the user has actually manually scrolled the target viewport to the correct\r\n * slice before initiating the synchronization 3) using some other method\r\n *\r\n * @param synchronizerInstance - The Instance of the Synchronizer\r\n * @param sourceViewport - The list of IDs defining the source viewport.\r\n * @param targetViewport - The list of IDs defining the target viewport, never\r\n *   the same as sourceViewport.\r\n * @param cameraModifiedEvent - The CAMERA_MODIFIED event.\r\n */\r\nexport default async function imageSliceSyncCallback(\r\n  synchronizerInstance: Synchronizer,\r\n  sourceViewport: Types.IViewportId,\r\n  targetViewport: Types.IViewportId\r\n): Promise<void> {\r\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\r\n  if (!renderingEngine) {\r\n    throw new Error(\r\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\r\n    );\r\n  }\r\n\r\n  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId) as\r\n    | Types.IVolumeViewport\r\n    | Types.IStackViewport;\r\n\r\n  const options = synchronizerInstance.getOptions(targetViewport.viewportId);\r\n\r\n  if (options?.disabled) {\r\n    return;\r\n  }\r\n\r\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId) as\r\n    | Types.IVolumeViewport\r\n    | Types.IStackViewport;\r\n\r\n  const imageId1 = sViewport.getCurrentImageId();\r\n  const imagePlaneModule1 = metaData.get('imagePlaneModule', imageId1);\r\n  const sourceImagePositionPatient = imagePlaneModule1.imagePositionPatient;\r\n\r\n  const targetImageIds = tViewport.getImageIds();\r\n\r\n  if (!areViewportsCoplanar(sViewport, tViewport)) {\r\n    return;\r\n  }\r\n\r\n  // if the frame of reference is different we need to use the registrationMetadataProvider\r\n  // and add that to the imagePositionPatient of the source viewport to get the\r\n  // imagePositionPatient of the target viewport's closest image in its stack\r\n  let registrationMatrixMat4 = getSpatialRegistration(\r\n    targetViewport.viewportId,\r\n    sourceViewport.viewportId\r\n  );\r\n\r\n  if (!registrationMatrixMat4) {\r\n    const frameOfReferenceUID1 = sViewport.getFrameOfReferenceUID();\r\n    const frameOfReferenceUID2 = tViewport.getFrameOfReferenceUID();\r\n    if (\r\n      frameOfReferenceUID1 === frameOfReferenceUID2 &&\r\n      options?.useInitialPosition !== false\r\n    ) {\r\n      registrationMatrixMat4 = mat4.identity(mat4.create());\r\n    } else {\r\n      utilities.calculateViewportsSpatialRegistration(sViewport, tViewport);\r\n      registrationMatrixMat4 = getSpatialRegistration(\r\n        targetViewport.viewportId,\r\n        sourceViewport.viewportId\r\n      );\r\n    }\r\n    if (!registrationMatrixMat4) {\r\n      return;\r\n    }\r\n  }\r\n\r\n  // apply the registration matrix to the source viewport's imagePositionPatient\r\n  // to get the target viewport's imagePositionPatient\r\n  const targetImagePositionPatientWithRegistrationMatrix = vec3.transformMat4(\r\n    vec3.create(),\r\n    sourceImagePositionPatient,\r\n    registrationMatrixMat4\r\n  );\r\n\r\n  // find the closest image in the target viewport's stack to the\r\n  // targetImagePositionPatientWithRegistrationMatrix\r\n  const closestImageIdIndex2 = _getClosestImageIdIndex(\r\n    targetImagePositionPatientWithRegistrationMatrix,\r\n    targetImageIds\r\n  );\r\n\r\n  let imageIndexToSet = closestImageIdIndex2.index;\r\n  if (tViewport instanceof VolumeViewport) {\r\n    // since in case of volume viewport our stack is reversed, we should\r\n    // reverse the index as well\r\n    imageIndexToSet = targetImageIds.length - closestImageIdIndex2.index - 1;\r\n  }\r\n\r\n  if (\r\n    closestImageIdIndex2.index !== -1 &&\r\n    tViewport.getCurrentImageIdIndex() !== closestImageIdIndex2.index\r\n  ) {\r\n    await jumpToSlice(tViewport.element, {\r\n      imageIndex: imageIndexToSet,\r\n    });\r\n  }\r\n}\r\n\r\nfunction _getClosestImageIdIndex(targetPoint, imageIds) {\r\n  // todo: this does not assume orientation yet, but that can be added later\r\n  // todo: handle multiframe images\r\n  return imageIds.reduce(\r\n    (closestImageIdIndex, imageId, index) => {\r\n      const { imagePositionPatient } = metaData.get(\r\n        'imagePlaneModule',\r\n        imageId\r\n      );\r\n      const distance = vec3.distance(imagePositionPatient, targetPoint);\r\n\r\n      if (distance < closestImageIdIndex.distance) {\r\n        return {\r\n          distance,\r\n          index,\r\n        };\r\n      }\r\n      return closestImageIdIndex;\r\n    },\r\n    {\r\n      distance: Infinity,\r\n      index: -1,\r\n    }\r\n  );\r\n}\r\n","import { vec3 } from 'gl-matrix';\r\nimport { Types } from '@cornerstonejs/core';\r\n\r\nexport default function areViewportsCoplanar(\r\n  viewport1: Types.IStackViewport | Types.IVolumeViewport,\r\n  viewport2: Types.IStackViewport | Types.IVolumeViewport\r\n): boolean {\r\n  const { viewPlaneNormal: viewPlaneNormal1 } = viewport1.getCamera();\r\n  const { viewPlaneNormal: viewPlaneNormal2 } = viewport2.getCamera();\r\n  const dotProducts = vec3.dot(viewPlaneNormal1, viewPlaneNormal2);\r\n  return Math.abs(dotProducts) > 0.9;\r\n}\r\n","import { createSynchronizer } from '../../store/SynchronizerManager';\r\nimport { Enums } from '@cornerstonejs/core';\r\nimport imageSliceSyncCallback from '../callbacks/imageSliceSyncCallback';\r\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\r\n\r\nconst { STACK_NEW_IMAGE, VOLUME_NEW_IMAGE } = Enums.Events;\r\n\r\n/**\r\n * A helper that creates a new `Synchronizer` which listens to the `STACK_NEW_IMAGE`\r\n * rendering event and calls the `ImageSliceSyncCallback`.\r\n *\r\n * @param synchronizerName - The name of the synchronizer.\r\n * @returns A new `Synchronizer` instance.\r\n */\r\nexport default function createImageSliceSynchronizer(\r\n  synchronizerName: string\r\n): Synchronizer {\r\n  const stackImageSynchronizer = createSynchronizer(\r\n    synchronizerName,\r\n    STACK_NEW_IMAGE,\r\n    imageSliceSyncCallback,\r\n    {\r\n      auxiliaryEventNames: [VOLUME_NEW_IMAGE],\r\n    }\r\n  );\r\n\r\n  return stackImageSynchronizer;\r\n}\r\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Synchronizer callback to synchronize the slab thickness.\r\n */\r\nexport default function slabThicknessSyncCallback(\r\n  _synchronizerInstance,\r\n  sourceViewport: Types.IViewportId,\r\n  targetViewport: Types.IViewportId\r\n): void {\r\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\r\n  if (!renderingEngine) {\r\n    throw new Error(\r\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\r\n    );\r\n  }\r\n\r\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\r\n  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\r\n\r\n  const slabThickness = (\r\n    sViewport as Types.IVolumeViewport\r\n  ).getSlabThickness?.();\r\n  if (!slabThickness) {\r\n    return;\r\n  }\r\n  (tViewport as Types.IVolumeViewport).setSlabThickness?.(slabThickness);\r\n  tViewport.render();\r\n}\r\n","import { Enums } from '@cornerstonejs/core';\r\nimport { createSynchronizer } from '../../store/SynchronizerManager';\r\nimport slabThicknessSyncCallback from '../callbacks/slabThicknessSyncCallback';\r\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\r\n\r\nconst { CAMERA_MODIFIED } = Enums.Events;\r\n\r\n/**\r\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\r\n * rendering event and calls the `cameraSyncCallback` based on presentation view\r\n * values and not based on absolute camera positions.\r\n *\r\n * @param synchronizerName - The name of the synchronizer.\r\n * @returns A new `Synchronizer` instance.\r\n */\r\nexport default function createPresentationViewSynchronizer(\r\n  synchronizerName: string\r\n): Synchronizer {\r\n  const presentationView = createSynchronizer(\r\n    synchronizerName,\r\n    CAMERA_MODIFIED,\r\n    slabThicknessSyncCallback\r\n  );\r\n\r\n  return presentationView;\r\n}\r\n","import createCameraPositionSynchronizer from './synchronizers/createCameraPositionSynchronizer';\r\nimport createPresentationViewSynchronizer from './synchronizers/createPresentationViewSynchronizer';\r\nimport createVOISynchronizer from './synchronizers/createVOISynchronizer';\r\nimport createZoomPanSynchronizer from './synchronizers/createZoomPanSynchronizer';\r\nimport createImageSliceSynchronizer from './synchronizers/createImageSliceSynchronizer';\r\nimport createSlabThicknessSynchronizer from './synchronizers/createSlabThicknessSynchronizer';\r\n\r\n// for backward compatibility\r\nconst createStackImageSynchronizer = createImageSliceSynchronizer;\r\n\r\nexport {\r\n  createCameraPositionSynchronizer,\r\n  createPresentationViewSynchronizer,\r\n  createVOISynchronizer,\r\n  createZoomPanSynchronizer,\r\n  createImageSliceSynchronizer,\r\n  createStackImageSynchronizer,\r\n  createSlabThicknessSynchronizer,\r\n};\r\n","import { AnnotationTool } from './base';\r\n\r\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport {\r\n  addAnnotation,\r\n  getAllAnnotations,\r\n  getAnnotations,\r\n  removeAnnotation,\r\n} from '../stateManagement/annotation/annotationState';\r\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\r\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\r\nimport { triggerAnnotationCompleted } from '../stateManagement/annotation/helpers/state';\r\nimport {\r\n  drawCircle as drawCircleSvg,\r\n  drawHandles as drawHandlesSvg,\r\n} from '../drawingSvg';\r\nimport { state } from '../store';\r\nimport { Events, MouseBindings, KeyboardBindings } from '../enums';\r\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\r\nimport {\r\n  resetElementCursor,\r\n  hideElementCursor,\r\n} from '../cursors/elementCursor';\r\nimport {\r\n  EventTypes,\r\n  ToolHandle,\r\n  PublicToolProps,\r\n  ToolProps,\r\n  SVGDrawingHelper,\r\n} from '../types';\r\nimport { AdvancedMagnifyAnnotation } from '../types/ToolSpecificAnnotationTypes';\r\n\r\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\r\nimport { StyleSpecifier } from '../types/AnnotationStyle';\r\nimport { getCanvasCircleRadius } from '../utilities/math/circle';\r\nimport AdvancedMagnifyViewportManager from './AdvancedMagnifyViewportManager';\r\nimport type { AutoPanCallbackData } from './AdvancedMagnifyViewport';\r\n\r\nenum AdvancedMagnifyToolActions {\r\n  ShowZoomFactorsList = 'showZoomFactorsList',\r\n}\r\n\r\nclass AdvancedMagnifyTool extends AnnotationTool {\r\n  static toolName;\r\n  static Actions = AdvancedMagnifyToolActions;\r\n\r\n  magnifyViewportManager: AdvancedMagnifyViewportManager;\r\n  touchDragCallback: any;\r\n  mouseDragCallback: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: Array<string>;\r\n    handleIndex?: number;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        shadow: true,\r\n        magnifyingGlass: {\r\n          radius: 125, // px\r\n          zoomFactor: 3,\r\n          zoomFactorList: [1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5],\r\n          autoPan: {\r\n            enabled: true,\r\n            padding: 10, // px\r\n          },\r\n        },\r\n        actions: {\r\n          showZoomFactorsList: {\r\n            method: 'showZoomFactorsList',\r\n            bindings: [\r\n              {\r\n                mouseButton: MouseBindings.Secondary,\r\n                modifierKey: KeyboardBindings.Shift,\r\n              },\r\n            ],\r\n          },\r\n        },\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n    this.magnifyViewportManager = AdvancedMagnifyViewportManager.getInstance();\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the current imageId to create\r\n   * a CircleROI Annotation and stores it in the annotationManager\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation = (\r\n    evt: EventTypes.InteractionEventType\r\n  ): AdvancedMagnifyAnnotation => {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n    const worldPos = currentPoints.world;\r\n    const canvasPos = currentPoints.canvas;\r\n    const { magnifyingGlass: config } = this.configuration;\r\n    const { radius, zoomFactor, autoPan } = config;\r\n\r\n    const canvasHandlePoints = this._getCanvasHandlePoints(\r\n      canvasPos,\r\n      radius\r\n    ) as [Types.Point3, Types.Point3, Types.Point3, Types.Point3];\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    const referencedImageId = this.getReferencedImageId(\r\n      viewport,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      viewUp\r\n    );\r\n\r\n    const annotationUID = csUtils.uuidv4();\r\n    const magnifyViewportId = csUtils.uuidv4();\r\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n\r\n    const annotation: AdvancedMagnifyAnnotation = {\r\n      annotationUID,\r\n      highlighted: true,\r\n      invalidated: true,\r\n      metadata: {\r\n        toolName: this.getToolName(),\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID,\r\n        referencedImageId,\r\n      },\r\n      data: {\r\n        sourceViewportId: viewport.id,\r\n        magnifyViewportId,\r\n        zoomFactor,\r\n        // this means that the last coordinate for the points\r\n        // is 0 and should not be used for calculations\r\n        isCanvasAnnotation: true,\r\n        handles: {\r\n          points: canvasHandlePoints,\r\n          activeHandleIndex: null,\r\n        },\r\n      },\r\n    };\r\n\r\n    this.magnifyViewportManager.createViewport(annotation, {\r\n      magnifyViewportId,\r\n      sourceEnabledElement: enabledElement,\r\n      position: canvasPos,\r\n      radius,\r\n      zoomFactor,\r\n      autoPan: {\r\n        enabled: autoPan.enabled,\r\n        padding: autoPan.padding,\r\n        callback: (data: AutoPanCallbackData) => {\r\n          const annotationPoints = annotation.data.handles.points;\r\n          const { canvas: canvasDelta } = data.delta;\r\n\r\n          for (let i = 0, len = annotationPoints.length; i < len; i++) {\r\n            const point = annotationPoints[i];\r\n            point[0] += canvasDelta[0];\r\n            point[1] += canvasDelta[1];\r\n            annotation.invalidated = true;\r\n          }\r\n        },\r\n      },\r\n    });\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    evt.preventDefault();\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  };\r\n\r\n  onSetToolDisabled = () => {\r\n    // reset\r\n    this.magnifyViewportManager.dispose();\r\n    // remove the annotations from the state for that toolGroup\r\n    const annotations = getAllAnnotations();\r\n    annotations.forEach((annotation) => {\r\n      if (annotation.metadata.toolName === this.getToolName()) {\r\n        removeAnnotation(annotation.annotationUID);\r\n      }\r\n    });\r\n  };\r\n\r\n  /**\r\n   * It returns if the canvas point is near the provided annotation in the provided\r\n   * element or not. A proximity is passed to the function to determine the\r\n   * proximity of the point to the annotation in number of pixels.\r\n   *\r\n   * @param element - HTML Element\r\n   * @param annotation - Annotation\r\n   * @param canvasCoords - Canvas coordinates\r\n   * @param proximity - Proximity to tool to consider\r\n   * @returns Boolean, whether the canvas point is near tool\r\n   */\r\n  public isPointNearTool = (\r\n    element: HTMLDivElement,\r\n    annotation: AdvancedMagnifyAnnotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): boolean => {\r\n    const { data } = annotation;\r\n    const { points } = data.handles;\r\n\r\n    // For some reason Typescript doesn't understand this, so we need to be\r\n    // more specific about the type\r\n    const canvasCoordinates = points;\r\n\r\n    const canvasTop = canvasCoordinates[0];\r\n    const canvasBottom = canvasCoordinates[2];\r\n    const canvasLeft = canvasCoordinates[3];\r\n    const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\r\n    const center = [\r\n      canvasLeft[0] + radius,\r\n      canvasTop[1] + radius,\r\n    ] as Types.Point2;\r\n    const radiusPoint = getCanvasCircleRadius([center, canvasCoords]);\r\n\r\n    if (Math.abs(radiusPoint - radius) < proximity * 2) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  toolSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: AdvancedMagnifyAnnotation\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n    };\r\n\r\n    hideElementCursor(element);\r\n\r\n    this._activateModify(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  handleSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: AdvancedMagnifyAnnotation,\r\n    handle: ToolHandle\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const { data } = annotation;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    const { points } = data.handles;\r\n    const handleIndex = points.findIndex((p) => p === handle);\r\n\r\n    // Find viewports to render on drag.\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex,\r\n    };\r\n    this._activateModify(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\r\n    const { data } = annotation;\r\n\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateModify(element);\r\n\r\n    resetElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    if (newAnnotation) {\r\n      triggerAnnotationCompleted(annotation);\r\n    }\r\n  };\r\n\r\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    this.isDrawing = true;\r\n    const eventDetail = evt.detail;\r\n    const { element, deltaPoints } = eventDetail;\r\n    const canvasDelta = deltaPoints?.canvas ?? [0, 0, 0];\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    const { annotation, viewportIdsToRender } = this.editData;\r\n    const { points } = annotation.data.handles;\r\n\r\n    points.forEach((point) => {\r\n      point[0] += canvasDelta[0];\r\n      point[1] += canvasDelta[1];\r\n    });\r\n\r\n    annotation.invalidated = true;\r\n    this.editData.hasMoved = true;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    this.isDrawing = true;\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (handleIndex === undefined) {\r\n      // Moving tool\r\n      const { deltaPoints } = eventDetail;\r\n      const canvasDelta = deltaPoints.canvas;\r\n\r\n      const points = data.handles.points;\r\n\r\n      points.forEach((point) => {\r\n        point[0] += canvasDelta[0];\r\n        point[1] += canvasDelta[1];\r\n      });\r\n      annotation.invalidated = true;\r\n    } else {\r\n      this._dragHandle(evt);\r\n      annotation.invalidated = true;\r\n    }\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n\r\n    const { annotation } = this.editData;\r\n    const { data } = annotation;\r\n    const { points } = data.handles;\r\n\r\n    const canvasCoordinates = points;\r\n    const canvasTop = canvasCoordinates[0];\r\n    const canvasBottom = canvasCoordinates[2];\r\n    const canvasLeft = canvasCoordinates[3];\r\n    const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\r\n    const canvasCenter: Types.Point2 = [\r\n      canvasLeft[0] + radius,\r\n      canvasTop[1] + radius,\r\n    ];\r\n\r\n    const { currentPoints } = eventDetail;\r\n    const currentCanvasPoints = currentPoints.canvas;\r\n\r\n    const newRadius = getCanvasCircleRadius([\r\n      canvasCenter,\r\n      currentCanvasPoints,\r\n    ]);\r\n    const newCanvasHandlePoints = this._getCanvasHandlePoints(\r\n      canvasCenter,\r\n      newRadius\r\n    );\r\n\r\n    points[0] = newCanvasHandlePoints[0];\r\n    points[1] = newCanvasHandlePoints[1];\r\n    points[2] = newCanvasHandlePoints[2];\r\n    points[3] = newCanvasHandlePoints[3];\r\n  };\r\n\r\n  cancel = (element: HTMLDivElement) => {\r\n    // If it is mid-draw or mid-modify\r\n    if (!this.isDrawing) {\r\n      return;\r\n    }\r\n\r\n    this.isDrawing = false;\r\n    this._deactivateModify(element);\r\n    resetElementCursor(element);\r\n\r\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\r\n    const { data } = annotation;\r\n\r\n    annotation.highlighted = false;\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    if (newAnnotation) {\r\n      triggerAnnotationCompleted(annotation);\r\n    }\r\n\r\n    this.editData = null;\r\n    return annotation.annotationUID;\r\n  };\r\n\r\n  _activateModify = (element) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\r\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  _deactivateModify = (element) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\r\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the circleROI annotation in each\r\n   * request animation frame. It calculates the updated cached statistics if\r\n   * data is invalidated and cache it.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n\r\n    let annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    annotations = annotations?.filter(\r\n      (annotation) =>\r\n        (<AdvancedMagnifyAnnotation>annotation).data.sourceViewportId ===\r\n        viewport.id\r\n    );\r\n\r\n    const filteredAnnotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    );\r\n\r\n    if (!filteredAnnotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    for (let i = 0; i < filteredAnnotations.length; i++) {\r\n      const annotation = filteredAnnotations[i] as AdvancedMagnifyAnnotation;\r\n      const { annotationUID, data } = annotation;\r\n      const { magnifyViewportId, zoomFactor, handles } = data;\r\n      const { points, activeHandleIndex } = handles;\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\r\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\r\n      const color = this.getStyle('color', styleSpecifier, annotation);\r\n\r\n      const canvasCoordinates = points;\r\n      const canvasTop = canvasCoordinates[0];\r\n      const canvasBottom = canvasCoordinates[2];\r\n      const canvasLeft = canvasCoordinates[3];\r\n      const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\r\n      const center = [\r\n        canvasLeft[0] + radius,\r\n        canvasTop[1] + radius,\r\n      ] as Types.Point2;\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n\r\n      let activeHandleCanvasCoords;\r\n\r\n      if (!isAnnotationVisible(annotationUID)) {\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        !isAnnotationLocked(annotation) &&\r\n        !this.editData &&\r\n        activeHandleIndex !== null\r\n      ) {\r\n        // Not locked or creating and hovering over handle, so render handle.\r\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\r\n      }\r\n\r\n      if (activeHandleCanvasCoords) {\r\n        const handleGroupUID = '0';\r\n        drawHandlesSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          handleGroupUID,\r\n          activeHandleCanvasCoords,\r\n          {\r\n            color,\r\n          }\r\n        );\r\n      }\r\n\r\n      const dataId = `${annotationUID}-advancedMagnify`;\r\n      const circleUID = '0';\r\n      drawCircleSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        circleUID,\r\n        center,\r\n        radius,\r\n        {\r\n          color,\r\n          lineWidth: 5,\r\n        },\r\n        dataId\r\n      );\r\n\r\n      const magnifyViewport =\r\n        this.magnifyViewportManager.getViewport(magnifyViewportId);\r\n\r\n      magnifyViewport.position = center;\r\n      magnifyViewport.radius = radius;\r\n      magnifyViewport.zoomFactor = zoomFactor;\r\n      magnifyViewport.update();\r\n\r\n      renderStatus = true;\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  // Basic dropdown component that allows the user to select a different zoom factor.\r\n  // configurations.actions may be changed to use a customized dropdown.\r\n  public showZoomFactorsList(\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: AdvancedMagnifyAnnotation\r\n  ) {\r\n    const { element, currentPoints } = evt.detail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const { canvas: canvasPoint } = currentPoints;\r\n    const viewportElement = element.querySelector(':scope .viewport-element');\r\n    const currentZoomFactor = annotation.data.zoomFactor;\r\n    const remove = () => dropdown.parentElement.removeChild(dropdown);\r\n\r\n    const dropdown = this._getZoomFactorsListDropdown(\r\n      currentZoomFactor,\r\n      (newZoomFactor) => {\r\n        if (newZoomFactor !== undefined) {\r\n          annotation.data.zoomFactor = Number.parseFloat(newZoomFactor);\r\n          annotation.invalidated = true;\r\n        }\r\n\r\n        remove();\r\n        viewport.render();\r\n      }\r\n    );\r\n\r\n    Object.assign(dropdown.style, {\r\n      left: `${canvasPoint[0]}px`,\r\n      top: `${canvasPoint[1]}px`,\r\n    });\r\n\r\n    viewportElement.appendChild(dropdown);\r\n    dropdown.focus();\r\n  }\r\n\r\n  private _getZoomFactorsListDropdown(currentZoomFactor, onChangeCallback) {\r\n    const { zoomFactorList } = this.configuration.magnifyingGlass;\r\n    const dropdown = document.createElement('select');\r\n\r\n    dropdown.size = 5;\r\n    Object.assign(dropdown.style, {\r\n      width: '50px',\r\n      position: 'absolute',\r\n    });\r\n\r\n    ['mousedown', 'mouseup', 'mousemove', 'click'].forEach((eventName) => {\r\n      dropdown.addEventListener(eventName, (evt) => evt.stopPropagation());\r\n    });\r\n\r\n    dropdown.addEventListener('change', (evt) => {\r\n      evt.stopPropagation();\r\n      onChangeCallback(dropdown.value);\r\n    });\r\n\r\n    dropdown.addEventListener('keydown', (evt) => {\r\n      const shouldCancel =\r\n        (evt.keyCode ?? evt.which === 27) ||\r\n        evt.key?.toLowerCase() === 'escape';\r\n\r\n      if (shouldCancel) {\r\n        evt.stopPropagation();\r\n        onChangeCallback();\r\n      }\r\n    });\r\n\r\n    zoomFactorList.forEach((zoomFactor) => {\r\n      const option = document.createElement('option');\r\n\r\n      option.label = zoomFactor;\r\n      option.title = `Zoom factor ${zoomFactor.toFixed(1)}`;\r\n      option.value = zoomFactor;\r\n      option.defaultSelected = zoomFactor === currentZoomFactor;\r\n\r\n      dropdown.add(option);\r\n    });\r\n\r\n    return dropdown;\r\n  }\r\n\r\n  private _getCanvasHandlePoints = (canvasCenterPos, canvasRadius) => {\r\n    return [\r\n      [canvasCenterPos[0], canvasCenterPos[1] - canvasRadius, 0], // top\r\n      [canvasCenterPos[0] + canvasRadius, canvasCenterPos[1], 0], // right\r\n      [canvasCenterPos[0], canvasCenterPos[1] + canvasRadius, 0], // bottom\r\n      [canvasCenterPos[0] - canvasRadius, canvasCenterPos[1], 0], // left\r\n    ];\r\n  };\r\n}\r\n\r\nAdvancedMagnifyTool.toolName = 'AdvancedMagnify';\r\n\r\nexport { AdvancedMagnifyTool as default };\r\n","import { BaseTool } from './base';\r\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\r\nimport { ToolGroupManager } from '../store';\r\nimport {\r\n  getAnnotations,\r\n  removeAnnotation,\r\n} from '../stateManagement/annotation/annotationState';\r\nimport { setAnnotationSelected } from '../stateManagement/annotation/annotationSelection';\r\n\r\nclass AnnotationEraserTool extends BaseTool {\r\n  static toolName;\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\r\n    return this._deleteNearbyAnnotations(evt, 'mouse');\r\n  };\r\n  preTouchStartCallback = (evt: EventTypes.InteractionEventType): boolean => {\r\n    return this._deleteNearbyAnnotations(evt, 'touch');\r\n  };\r\n\r\n  _deleteNearbyAnnotations(\r\n    evt: EventTypes.InteractionEventType,\r\n    interactionType: string\r\n  ): boolean {\r\n    const { renderingEngineId, viewportId, element, currentPoints } =\r\n      evt.detail;\r\n\r\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\r\n      viewportId,\r\n      renderingEngineId\r\n    );\r\n\r\n    if (!toolGroup) {\r\n      return false;\r\n    }\r\n\r\n    const tools = toolGroup._toolInstances;\r\n    const annotationsToRemove = [];\r\n\r\n    for (const toolName in tools) {\r\n      const toolInstance = tools[toolName];\r\n\r\n      if (\r\n        typeof toolInstance.isPointNearTool !== 'function' ||\r\n        typeof toolInstance.filterInteractableAnnotationsForElement !==\r\n          'function'\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      const annotations = getAnnotations(toolName, element);\r\n\r\n      if (!annotations.length) {\r\n        continue;\r\n      }\r\n\r\n      const interactableAnnotations =\r\n        toolInstance.filterInteractableAnnotationsForElement(\r\n          element,\r\n          annotations\r\n        ) || [];\r\n\r\n      for (const annotation of interactableAnnotations) {\r\n        if (\r\n          toolInstance.isPointNearTool(\r\n            element,\r\n            annotation,\r\n            currentPoints.canvas,\r\n            10,\r\n            interactionType\r\n          )\r\n        ) {\r\n          annotationsToRemove.push(annotation.annotationUID);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (const annotationUID of annotationsToRemove) {\r\n      setAnnotationSelected(annotationUID);\r\n      removeAnnotation(annotationUID);\r\n    }\r\n\r\n    evt.preventDefault();\r\n\r\n    return true;\r\n  }\r\n}\r\n\r\nAnnotationEraserTool.toolName = 'Eraser';\r\nexport default AnnotationEraserTool;\r\n","import { vec2, vec3 } from 'gl-matrix';\r\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\r\nimport vtkMatrixBuilder from '@kitware/vtk.js/Common/Core/MatrixBuilder';\r\n\r\nimport { AnnotationTool } from './base';\r\n\r\nimport {\r\n  getEnabledElementByIds,\r\n  getEnabledElement,\r\n  utilities as csUtils,\r\n  Enums,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport {\r\n  getToolGroup,\r\n  getToolGroupForViewport,\r\n} from '../store/ToolGroupManager';\r\n\r\nimport {\r\n  addAnnotation,\r\n  getAnnotations,\r\n  removeAnnotation,\r\n} from '../stateManagement/annotation/annotationState';\r\n\r\nimport {\r\n  drawCircle as drawCircleSvg,\r\n  drawHandles as drawHandlesSvg,\r\n  drawLine as drawLineSvg,\r\n} from '../drawingSvg';\r\nimport { state } from '../store';\r\nimport { Events } from '../enums';\r\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\r\nimport {\r\n  resetElementCursor,\r\n  hideElementCursor,\r\n} from '../cursors/elementCursor';\r\nimport liangBarksyClip from '../utilities/math/vec2/liangBarksyClip';\r\n\r\nimport * as lineSegment from '../utilities/math/line';\r\nimport {\r\n  Annotation,\r\n  Annotations,\r\n  EventTypes,\r\n  ToolHandle,\r\n  PublicToolProps,\r\n  ToolProps,\r\n  InteractionTypes,\r\n  SVGDrawingHelper,\r\n} from '../types';\r\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\r\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\r\nimport { CONSTANTS } from '@cornerstonejs/core';\r\n\r\nconst { RENDERING_DEFAULTS } = CONSTANTS;\r\n\r\ninterface CrosshairsAnnotation extends Annotation {\r\n  data: {\r\n    handles: {\r\n      rotationPoints: any[]; // rotation handles, used for rotation interactions\r\n      slabThicknessPoints: any[]; // slab thickness handles, used for setting the slab thickness\r\n      activeOperation: number | null; // 0 translation, 1 rotation handles, 2 slab thickness handles\r\n      toolCenter: Types.Point3;\r\n    };\r\n    activeViewportIds: string[]; // a list of the viewport ids connected to the reference lines being translated\r\n    viewportId: string;\r\n  };\r\n}\r\n\r\nfunction defaultReferenceLineColor() {\r\n  return 'rgb(0, 200, 0)';\r\n}\r\n\r\nfunction defaultReferenceLineControllable() {\r\n  return true;\r\n}\r\n\r\nfunction defaultReferenceLineDraggableRotatable() {\r\n  return true;\r\n}\r\n\r\nfunction defaultReferenceLineSlabThicknessControlsOn() {\r\n  return true;\r\n}\r\n\r\nconst OPERATION = {\r\n  DRAG: 1,\r\n  ROTATE: 2,\r\n  SLAB: 3,\r\n};\r\n\r\nconst EPSILON = 1e-3;\r\n\r\n/**\r\n * CrosshairsTool is a tool that provides reference lines between different viewports\r\n * of a toolGroup. Using crosshairs, you can jump to a specific location in one\r\n * viewport and the rest of the viewports in the toolGroup will be aligned to that location.\r\n * Crosshairs have grababble handles that can be used to rotate and translate the\r\n * reference lines. They can also be used to set the slab thickness of the viewports\r\n * by modifying the slab thickness handles.\r\n *\r\n */\r\nclass CrosshairsTool extends AnnotationTool {\r\n  static toolName;\r\n\r\n  toolCenter: Types.Point3 = [0, 0, 0]; // NOTE: it is assumed that all the active/linked viewports share the same crosshair center.\r\n  // This because the rotation operation rotates also all the other active/intersecting reference lines of the same angle\r\n  _getReferenceLineColor?: (viewportId: string) => string;\r\n  _getReferenceLineControllable?: (viewportId: string) => boolean;\r\n  _getReferenceLineDraggableRotatable?: (viewportId: string) => boolean;\r\n  _getReferenceLineSlabThicknessControlsOn?: (viewportId: string) => boolean;\r\n  editData: {\r\n    annotation: any;\r\n  } | null;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse'],\r\n      configuration: {\r\n        shadow: true,\r\n        // renders a colored circle on top right of the viewports whose color\r\n        // matches the color of the reference line\r\n        viewportIndicators: false,\r\n\r\n        viewportIndicatorsConfig: {\r\n          radius: 5,\r\n          x: null,\r\n          y: null,\r\n        },\r\n        // Auto pan is a configuration which will update pan\r\n        // other viewports in the toolGroup if the center of the crosshairs\r\n        // is outside of the viewport. This might be useful for the case\r\n        // when the user is scrolling through an image (usually in the zoomed view)\r\n        // and the crosshairs will eventually get outside of the viewport for\r\n        // the other viewports.\r\n        autoPan: {\r\n          enabled: false,\r\n          panSize: 10,\r\n        },\r\n        // radius of the area around the intersection of the planes, in which\r\n        // the reference lines will not be rendered. This is only used when\r\n        // having 3 viewports in the toolGroup.\r\n        referenceLinesCenterGapRadius: 20,\r\n        // actorUIDs for slabThickness application, if not defined, the slab thickness\r\n        // will be applied to all actors of the viewport\r\n        filterActorUIDsToSetSlabThickness: [],\r\n        // blend mode for slabThickness modifications\r\n        slabThicknessBlendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\r\n        mobile: {\r\n          enabled: false,\r\n          opacity: 0.8,\r\n          handleRadius: 9,\r\n        },\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n\r\n    this._getReferenceLineColor =\r\n      toolProps.configuration?.getReferenceLineColor ||\r\n      defaultReferenceLineColor;\r\n    this._getReferenceLineControllable =\r\n      toolProps.configuration?.getReferenceLineControllable ||\r\n      defaultReferenceLineControllable;\r\n    this._getReferenceLineDraggableRotatable =\r\n      toolProps.configuration?.getReferenceLineDraggableRotatable ||\r\n      defaultReferenceLineDraggableRotatable;\r\n    this._getReferenceLineSlabThicknessControlsOn =\r\n      toolProps.configuration?.getReferenceLineSlabThicknessControlsOn ||\r\n      defaultReferenceLineSlabThicknessControlsOn;\r\n  }\r\n\r\n  /**\r\n   * Gets the camera from the viewport, and adds crosshairs annotation for the viewport\r\n   * to the annotationManager. If any annotation is found in the annotationManager, it\r\n   * overwrites it.\r\n   * @param viewportInfo - The viewportInfo for the viewport to add the crosshairs\r\n   * @returns viewPlaneNormal and center of viewport canvas in world space\r\n   */\r\n  initializeViewport = ({\r\n    renderingEngineId,\r\n    viewportId,\r\n  }: Types.IViewportId): {\r\n    normal: Types.Point3;\r\n    point: Types.Point3;\r\n  } => {\r\n    const enabledElement = getEnabledElementByIds(\r\n      viewportId,\r\n      renderingEngineId\r\n    );\r\n    const { FrameOfReferenceUID, viewport } = enabledElement;\r\n    const { element } = viewport;\r\n    const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();\r\n\r\n    // Check if there is already annotation for this viewport\r\n    let annotations = this._getAnnotations(enabledElement);\r\n    annotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    );\r\n\r\n    if (annotations.length) {\r\n      // If found, it will override it by removing the annotation and adding it later\r\n      removeAnnotation(annotations[0].annotationUID);\r\n    }\r\n\r\n    const annotation = {\r\n      highlighted: false,\r\n      metadata: {\r\n        cameraPosition: <Types.Point3>[...position],\r\n        cameraFocalPoint: <Types.Point3>[...focalPoint],\r\n        FrameOfReferenceUID,\r\n        toolName: this.getToolName(),\r\n      },\r\n      data: {\r\n        handles: {\r\n          rotationPoints: [], // rotation handles, used for rotation interactions\r\n          slabThicknessPoints: [], // slab thickness handles, used for setting the slab thickness\r\n          toolCenter: this.toolCenter,\r\n        },\r\n        activeOperation: null, // 0 translation, 1 rotation handles, 2 slab thickness handles\r\n        activeViewportIds: [], // a list of the viewport ids connected to the reference lines being translated\r\n        viewportId,\r\n      },\r\n    };\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    return {\r\n      normal: viewPlaneNormal,\r\n      point: viewport.canvasToWorld([\r\n        viewport.canvas.clientWidth / 2,\r\n        viewport.canvas.clientHeight / 2,\r\n      ]),\r\n    };\r\n  };\r\n\r\n  _getViewportsInfo = () => {\r\n    const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\r\n\r\n    return viewports;\r\n  };\r\n\r\n  onSetToolActive() {\r\n    const viewportsInfo = this._getViewportsInfo();\r\n\r\n    // Upon new setVolumes on viewports we need to update the crosshairs\r\n    // reference points in the new space, so we subscribe to the event\r\n    // and update the reference points accordingly.\r\n    this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\r\n    this._subscribeToViewportNewVolumeSet(viewportsInfo);\r\n\r\n    this.computeToolCenter(viewportsInfo);\r\n  }\r\n\r\n  onSetToolPassive() {\r\n    const viewportsInfo = this._getViewportsInfo();\r\n\r\n    this.computeToolCenter(viewportsInfo);\r\n  }\r\n\r\n  onSetToolEnabled() {\r\n    const viewportsInfo = this._getViewportsInfo();\r\n\r\n    this.computeToolCenter(viewportsInfo);\r\n  }\r\n\r\n  onSetToolDisabled() {\r\n    const viewportsInfo = this._getViewportsInfo();\r\n\r\n    this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\r\n\r\n    // Crosshairs annotations in the state\r\n    // has no value when the tool is disabled\r\n    // since viewports can change (zoom, pan, scroll)\r\n    // between disabled and enabled/active states.\r\n    // so we just remove the annotations from the state\r\n    viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\r\n      const enabledElement = getEnabledElementByIds(\r\n        viewportId,\r\n        renderingEngineId\r\n      );\r\n\r\n      if (!enabledElement) {\r\n        return;\r\n      }\r\n\r\n      const annotations = this._getAnnotations(enabledElement);\r\n\r\n      if (annotations?.length) {\r\n        annotations.forEach((annotation) => {\r\n          removeAnnotation(annotation.annotationUID);\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  resetCrosshairs = () => {\r\n    const viewportsInfo = this._getViewportsInfo();\r\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\r\n      const enabledElement = getEnabledElementByIds(\r\n        viewportId,\r\n        renderingEngineId\r\n      );\r\n      const { viewport } = enabledElement;\r\n      const resetPan = true;\r\n      const resetZoom = true;\r\n      const resetToCenter = true;\r\n      const resetRotation = true;\r\n      const supressEvents = true;\r\n      viewport.resetCamera(\r\n        resetPan,\r\n        resetZoom,\r\n        resetToCenter,\r\n        resetRotation,\r\n        supressEvents\r\n      );\r\n      (viewport as Types.IVolumeViewport).resetSlabThickness();\r\n      const { element } = viewport;\r\n      let annotations = this._getAnnotations(enabledElement);\r\n      annotations = this.filterInteractableAnnotationsForElement(\r\n        element,\r\n        annotations\r\n      );\r\n      if (annotations.length) {\r\n        removeAnnotation(annotations[0].annotationUID);\r\n      }\r\n      viewport.render();\r\n    });\r\n\r\n    this.computeToolCenter(viewportsInfo);\r\n  };\r\n\r\n  /**\r\n   * When activated, it initializes the crosshairs. It begins by computing\r\n   * the intersection of viewports associated with the crosshairs instance.\r\n   * When all three views are accessible, the intersection (e.g., crosshairs tool centre)\r\n   * will be an exact point in space; however, with two viewports, because the\r\n   * intersection of two planes is a line, it assumes the last view is between the centre\r\n   * of the two rendering viewports.\r\n   * @param viewportsInfo Array of viewportInputs which each item containing {viewportId, renderingEngineId}\r\n   */\r\n  computeToolCenter = (viewportsInfo): void => {\r\n    if (!viewportsInfo.length || viewportsInfo.length === 1) {\r\n      console.warn(\r\n        'For crosshairs to operate, at least two viewports must be given.'\r\n      );\r\n      return;\r\n    }\r\n\r\n    // Todo: handle two same view viewport, or more than 3 viewports\r\n    const [firstViewport, secondViewport, thirdViewport] = viewportsInfo;\r\n\r\n    // Initialize first viewport\r\n    const { normal: normal1, point: point1 } =\r\n      this.initializeViewport(firstViewport);\r\n\r\n    // Initialize second viewport\r\n    const { normal: normal2, point: point2 } =\r\n      this.initializeViewport(secondViewport);\r\n\r\n    let normal3 = <Types.Point3>[0, 0, 0];\r\n    let point3 = vec3.create();\r\n\r\n    // If there are three viewports\r\n    if (thirdViewport) {\r\n      ({ normal: normal3, point: point3 } =\r\n        this.initializeViewport(thirdViewport));\r\n    } else {\r\n      // If there are only two views (viewport) associated with the crosshairs:\r\n      // In this situation, we don't have a third information to find the\r\n      // exact intersection, and we \"assume\" the third view is looking at\r\n      // a location in between the first and second view centers\r\n      vec3.add(point3, point1, point2);\r\n      vec3.scale(point3, point3, 0.5);\r\n      vec3.cross(normal3, normal1, normal2);\r\n    }\r\n\r\n    // Planes of each viewport\r\n    const firstPlane = csUtils.planar.planeEquation(normal1, point1);\r\n    const secondPlane = csUtils.planar.planeEquation(normal2, point2);\r\n    const thirdPlane = csUtils.planar.planeEquation(normal3, point3);\r\n\r\n    // Calculating the intersection of 3 planes\r\n    // prettier-ignore\r\n    this.toolCenter = csUtils.planar.threePlaneIntersection(firstPlane, secondPlane, thirdPlane)\r\n\r\n    // assuming all viewports are in the same rendering engine\r\n    const { renderingEngine } = getEnabledElementByIds(\r\n      viewportsInfo[0].viewportId,\r\n      viewportsInfo[0].renderingEngineId\r\n    );\r\n\r\n    triggerAnnotationRenderForViewportIds(\r\n      renderingEngine,\r\n      viewportsInfo.map(({ viewportId }) => viewportId)\r\n    );\r\n  };\r\n\r\n  /**\r\n   * addNewAnnotation acts as jump for the crosshairs tool. It is called when\r\n   * the user clicks on the image. It does not store the annotation in the stateManager though.\r\n   *\r\n   * @param evt - The mouse event\r\n   * @param interactionType - The type of interaction (e.g., mouse, touch, etc.)\r\n   * @returns Crosshairs annotation\r\n   */\r\n  addNewAnnotation = (\r\n    evt: EventTypes.InteractionEventType\r\n  ): CrosshairsAnnotation => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { currentPoints } = eventDetail;\r\n    const jumpWorld = currentPoints.world;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    this._jump(enabledElement, jumpWorld);\r\n\r\n    const annotations = this._getAnnotations(enabledElement);\r\n    const filteredAnnotations = this.filterInteractableAnnotationsForElement(\r\n      viewport.element,\r\n      annotations\r\n    );\r\n\r\n    // viewport Annotation\r\n    const { data } = filteredAnnotations[0];\r\n\r\n    const { rotationPoints } = data.handles;\r\n    const viewportIdArray = [];\r\n    // put all the draggable reference lines in the viewportIdArray\r\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\r\n      const otherViewport = rotationPoints[i][1];\r\n      const viewportControllable = this._getReferenceLineControllable(\r\n        otherViewport.id\r\n      );\r\n      const viewportDraggableRotatable =\r\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\r\n      if (!viewportControllable || !viewportDraggableRotatable) {\r\n        continue;\r\n      }\r\n      viewportIdArray.push(otherViewport.id);\r\n      // rotation handles are two per viewport\r\n      i++;\r\n    }\r\n\r\n    data.activeViewportIds = [...viewportIdArray];\r\n    // set translation operation\r\n    data.handles.activeOperation = OPERATION.DRAG;\r\n\r\n    evt.preventDefault();\r\n\r\n    hideElementCursor(element);\r\n\r\n    this._activateModify(element);\r\n    return filteredAnnotations[0];\r\n  };\r\n\r\n  cancel = () => {\r\n    console.log('Not implemented yet');\r\n  };\r\n\r\n  /**\r\n   * It checks if the mouse click is near crosshairs handles, if yes\r\n   * it returns the handle location. If the mouse click is not near any\r\n   * of the handles, it does not return anything.\r\n   *\r\n   * @param element - The element that the tool is attached to.\r\n   * @param annotation - The annotation object associated with the annotation\r\n   * @param canvasCoords - The coordinates of the mouse click on canvas\r\n   * @param proximity - The distance from the mouse cursor to the point\r\n   * that is considered \"near\".\r\n   * @returns The handle that is closest to the cursor, or null if the cursor\r\n   * is not near any of the handles.\r\n   */\r\n  getHandleNearImagePoint(\r\n    element: HTMLDivElement,\r\n    annotation: Annotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): ToolHandle | undefined {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    let point = this._getRotationHandleNearImagePoint(\r\n      viewport,\r\n      annotation,\r\n      canvasCoords,\r\n      proximity\r\n    );\r\n\r\n    if (point !== null) {\r\n      return point;\r\n    }\r\n\r\n    point = this._getSlabThicknessHandleNearImagePoint(\r\n      viewport,\r\n      annotation,\r\n      canvasCoords,\r\n      proximity\r\n    );\r\n\r\n    if (point !== null) {\r\n      return point;\r\n    }\r\n  }\r\n\r\n  handleSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: Annotation\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    annotation.highlighted = true;\r\n\r\n    // NOTE: handle index or coordinates are not used when dragging.\r\n    // This because the handle points are actually generated in the renderTool and they are a derivative\r\n    // from the camera variables of the viewports and of the slab thickness variable.\r\n    // Remember that the translation and rotation operations operate on the camera\r\n    // variables and not really on the handles. Similar for the slab thickness.\r\n    this._activateModify(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  /**\r\n   * It returns if the canvas point is near the provided crosshairs annotation in the\r\n   * provided element or not. A proximity is passed to the function to determine the\r\n   * proximity of the point to the annotation in number of pixels.\r\n   *\r\n   * @param element - HTML Element\r\n   * @param annotation - Annotation\r\n   * @param canvasCoords - Canvas coordinates\r\n   * @param proximity - Proximity to tool to consider\r\n   * @returns Boolean, whether the canvas point is near tool\r\n   */\r\n  isPointNearTool = (\r\n    element: HTMLDivElement,\r\n    annotation: CrosshairsAnnotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): boolean => {\r\n    if (this._pointNearTool(element, annotation, canvasCoords, 6)) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  toolSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: Annotation,\r\n    interactionType: InteractionTypes\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    annotation.highlighted = true;\r\n    this._activateModify(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  onCameraModified = (evt) => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n    const viewport = enabledElement.viewport as Types.IVolumeViewport;\r\n\r\n    const annotations = this._getAnnotations(enabledElement);\r\n    const filteredToolAnnotations =\r\n      this.filterInteractableAnnotationsForElement(element, annotations);\r\n\r\n    // viewport that the camera modified is originating from\r\n    const viewportAnnotation =\r\n      filteredToolAnnotations[0] as CrosshairsAnnotation;\r\n\r\n    if (!viewportAnnotation) {\r\n      return;\r\n    }\r\n\r\n    // -- Update the camera of other linked viewports containing the same volumeId that\r\n    //    have the same camera in case of translation\r\n    // -- Update the crosshair center in world coordinates in annotation.\r\n    // This is necessary because other tools can modify the position of the slices,\r\n    // e.g. stackScroll tool at wheel scroll. So we update the coordinates of the center always here.\r\n    // NOTE: rotation and slab thickness handles are created/updated in renderTool.\r\n    const currentCamera = viewport.getCamera();\r\n    const oldCameraPosition = viewportAnnotation.metadata.cameraPosition;\r\n    const deltaCameraPosition: Types.Point3 = [0, 0, 0];\r\n    vtkMath.subtract(\r\n      currentCamera.position,\r\n      oldCameraPosition,\r\n      deltaCameraPosition\r\n    );\r\n\r\n    const oldCameraFocalPoint = viewportAnnotation.metadata.cameraFocalPoint;\r\n    const deltaCameraFocalPoint: Types.Point3 = [0, 0, 0];\r\n    vtkMath.subtract(\r\n      currentCamera.focalPoint,\r\n      oldCameraFocalPoint,\r\n      deltaCameraFocalPoint\r\n    );\r\n\r\n    // updated cached \"previous\" camera position and focal point\r\n    viewportAnnotation.metadata.cameraPosition = [...currentCamera.position];\r\n    viewportAnnotation.metadata.cameraFocalPoint = [\r\n      ...currentCamera.focalPoint,\r\n    ];\r\n\r\n    const viewportControllable = this._getReferenceLineControllable(\r\n      viewport.id\r\n    );\r\n    const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(\r\n      viewport.id\r\n    );\r\n    if (\r\n      !csUtils.isEqual(currentCamera.position, oldCameraPosition, 1e-3) &&\r\n      viewportControllable &&\r\n      viewportDraggableRotatable\r\n    ) {\r\n      // Is camera Modified a TRANSLATION or ROTATION?\r\n      let isRotation = false;\r\n\r\n      // This is guaranteed to be the same diff for both position and focal point\r\n      // if the camera is modified by pan, zoom, or scroll BUT for rotation of\r\n      // crosshairs handles it will be different.\r\n      const cameraModifiedSameForPosAndFocalPoint = csUtils.isEqual(\r\n        deltaCameraPosition,\r\n        deltaCameraFocalPoint,\r\n        1e-3\r\n      );\r\n\r\n      // NOTE: it is a translation if the the focal point and camera position shifts are the same\r\n      if (!cameraModifiedSameForPosAndFocalPoint) {\r\n        isRotation = true;\r\n      }\r\n\r\n      const cameraModifiedInPlane =\r\n        Math.abs(\r\n          vtkMath.dot(deltaCameraPosition, currentCamera.viewPlaneNormal)\r\n        ) < 1e-2;\r\n\r\n      // TRANSLATION\r\n      // NOTE1: if the camera modified is a result of a pan or zoom don't update the crosshair center\r\n      // NOTE2: rotation handles are updates in renderTool\r\n      if (!isRotation && !cameraModifiedInPlane) {\r\n        this.toolCenter[0] += deltaCameraPosition[0];\r\n        this.toolCenter[1] += deltaCameraPosition[1];\r\n        this.toolCenter[2] += deltaCameraPosition[2];\r\n      }\r\n    }\r\n\r\n    // AutoPan modification\r\n    if (this.configuration.autoPan?.enabled) {\r\n      const toolGroup = getToolGroupForViewport(\r\n        viewport.id,\r\n        renderingEngine.id\r\n      );\r\n\r\n      const otherViewportIds = toolGroup\r\n        .getViewportIds()\r\n        .filter((id) => id !== viewport.id);\r\n\r\n      otherViewportIds.forEach((viewportId) => {\r\n        this._autoPanViewportIfNecessary(viewportId, renderingEngine);\r\n      });\r\n    }\r\n\r\n    const requireSameOrientation = false;\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName(),\r\n      requireSameOrientation\r\n    );\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  onResetCamera = (evt) => {\r\n    this.resetCrosshairs();\r\n  };\r\n\r\n  mouseMoveCallback = (\r\n    evt: EventTypes.MouseMoveEventType,\r\n    filteredToolAnnotations: Annotations\r\n  ): boolean => {\r\n    const { element, currentPoints } = evt.detail;\r\n    const canvasCoords = currentPoints.canvas;\r\n    let imageNeedsUpdate = false;\r\n\r\n    for (let i = 0; i < filteredToolAnnotations.length; i++) {\r\n      const annotation = filteredToolAnnotations[i] as CrosshairsAnnotation;\r\n\r\n      if (isAnnotationLocked(annotation)) {\r\n        continue;\r\n      }\r\n\r\n      const { data, highlighted } = annotation;\r\n      if (!data.handles) {\r\n        continue;\r\n      }\r\n\r\n      const previousActiveOperation = data.handles.activeOperation;\r\n      const previousActiveViewportIds =\r\n        data.activeViewportIds && data.activeViewportIds.length > 0\r\n          ? [...data.activeViewportIds]\r\n          : [];\r\n\r\n      // This init are necessary, because when we move the mouse they are not cleaned by _endCallback\r\n      data.activeViewportIds = [];\r\n      data.handles.activeOperation = null;\r\n\r\n      const handleNearImagePoint = this.getHandleNearImagePoint(\r\n        element,\r\n        annotation,\r\n        canvasCoords,\r\n        6\r\n      );\r\n\r\n      let near = false;\r\n      if (handleNearImagePoint) {\r\n        near = true;\r\n      } else {\r\n        near = this._pointNearTool(element, annotation, canvasCoords, 6);\r\n      }\r\n\r\n      const nearToolAndNotMarkedActive = near && !highlighted;\r\n      const notNearToolAndMarkedActive = !near && highlighted;\r\n      if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\r\n        annotation.highlighted = !highlighted;\r\n        imageNeedsUpdate = true;\r\n      } else if (\r\n        data.handles.activeOperation !== previousActiveOperation ||\r\n        !this._areViewportIdArraysEqual(\r\n          data.activeViewportIds,\r\n          previousActiveViewportIds\r\n        )\r\n      ) {\r\n        imageNeedsUpdate = true;\r\n      }\r\n    }\r\n\r\n    return imageNeedsUpdate;\r\n  };\r\n\r\n  filterInteractableAnnotationsForElement = (element, annotations) => {\r\n    if (!annotations || !annotations.length) {\r\n      return [];\r\n    }\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewportId } = enabledElement;\r\n\r\n    const viewportUIDSpecificCrosshairs = annotations.filter(\r\n      (annotation) => annotation.data.viewportId === viewportId\r\n    );\r\n\r\n    return viewportUIDSpecificCrosshairs;\r\n  };\r\n\r\n  /**\r\n   * renders the crosshairs lines and handles in the requestAnimationFrame callback\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n    const { viewport, renderingEngine } = enabledElement;\r\n    const { element } = viewport;\r\n    const annotations = this._getAnnotations(enabledElement);\r\n    const camera = viewport.getCamera();\r\n    const filteredToolAnnotations =\r\n      this.filterInteractableAnnotationsForElement(element, annotations);\r\n\r\n    // viewport Annotation\r\n    const viewportAnnotation = filteredToolAnnotations[0];\r\n    if (!annotations?.length || !viewportAnnotation?.data) {\r\n      // No annotations yet, and didn't just create it as we likely don't have a FrameOfReference/any data loaded yet.\r\n      return renderStatus;\r\n    }\r\n\r\n    const annotationUID = viewportAnnotation.annotationUID;\r\n\r\n    // Get cameras/canvases for each of these.\r\n    // -- Get two world positions for this canvas in this line (e.g. the diagonal)\r\n    // -- Convert these world positions to this canvas.\r\n    // -- Extend/confine this line to fit in this canvas.\r\n    // -- Render this line.\r\n    const { clientWidth, clientHeight } = viewport.canvas;\r\n    const canvasDiagonalLength = Math.sqrt(\r\n      clientWidth * clientWidth + clientHeight * clientHeight\r\n    );\r\n    const canvasMinDimensionLength = Math.min(clientWidth, clientHeight);\r\n\r\n    const data = viewportAnnotation.data;\r\n    const crosshairCenterCanvas = viewport.worldToCanvas(this.toolCenter);\r\n\r\n    const otherViewportAnnotations =\r\n      this._filterAnnotationsByUniqueViewportOrientations(\r\n        enabledElement,\r\n        annotations\r\n      );\r\n\r\n    const referenceLines = [];\r\n\r\n    // get canvas information for points and lines (canvas box, canvas horizontal distances)\r\n    const canvasBox = [0, 0, clientWidth, clientHeight];\r\n\r\n    otherViewportAnnotations.forEach((annotation) => {\r\n      const { data } = annotation;\r\n\r\n      data.handles.toolCenter = this.toolCenter;\r\n\r\n      const otherViewport = renderingEngine.getViewport(\r\n        data.viewportId\r\n      ) as Types.IVolumeViewport;\r\n\r\n      const otherCamera = otherViewport.getCamera();\r\n\r\n      const otherViewportControllable = this._getReferenceLineControllable(\r\n        otherViewport.id\r\n      );\r\n      const otherViewportDraggableRotatable =\r\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\r\n      const otherViewportSlabThicknessControlsOn =\r\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\r\n\r\n      // get coordinates for the reference line\r\n      const { clientWidth, clientHeight } = otherViewport.canvas;\r\n      const otherCanvasDiagonalLength = Math.sqrt(\r\n        clientWidth * clientWidth + clientHeight * clientHeight\r\n      );\r\n      const otherCanvasCenter: Types.Point2 = [\r\n        clientWidth * 0.5,\r\n        clientHeight * 0.5,\r\n      ];\r\n      const otherViewportCenterWorld =\r\n        otherViewport.canvasToWorld(otherCanvasCenter);\r\n\r\n      const direction: Types.Point3 = [0, 0, 0];\r\n      vtkMath.cross(\r\n        camera.viewPlaneNormal,\r\n        otherCamera.viewPlaneNormal,\r\n        direction\r\n      );\r\n      vtkMath.normalize(direction);\r\n      vtkMath.multiplyScalar(\r\n        <Types.Point3>direction,\r\n        otherCanvasDiagonalLength\r\n      );\r\n\r\n      const pointWorld0: Types.Point3 = [0, 0, 0];\r\n      vtkMath.add(otherViewportCenterWorld, direction, pointWorld0);\r\n\r\n      const pointWorld1: Types.Point3 = [0, 0, 0];\r\n      vtkMath.subtract(otherViewportCenterWorld, direction, pointWorld1);\r\n\r\n      const pointCanvas0 = viewport.worldToCanvas(pointWorld0);\r\n\r\n      const otherViewportCenterCanvas = viewport.worldToCanvas(\r\n        otherViewportCenterWorld\r\n      );\r\n\r\n      const canvasUnitVectorFromCenter = vec2.create();\r\n      vec2.subtract(\r\n        canvasUnitVectorFromCenter,\r\n        pointCanvas0,\r\n        otherViewportCenterCanvas\r\n      );\r\n      vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\r\n\r\n      // Graphic:\r\n      // Mid -> SlabThickness handle\r\n      // Short -> Rotation handle\r\n      //                           Long\r\n      //                            |\r\n      //                            |\r\n      //                            |\r\n      //                           Mid\r\n      //                            |\r\n      //                            |\r\n      //                            |\r\n      //                          Short\r\n      //                            |\r\n      //                            |\r\n      //                            |\r\n      // Long --- Mid--- Short--- Center --- Short --- Mid --- Long\r\n      //                            |\r\n      //                            |\r\n      //                            |\r\n      //                          Short\r\n      //                            |\r\n      //                            |\r\n      //                            |\r\n      //                           Mid\r\n      //                            |\r\n      //                            |\r\n      //                            |\r\n      //                           Long\r\n      const canvasVectorFromCenterLong = vec2.create();\r\n\r\n      vec2.scale(\r\n        canvasVectorFromCenterLong,\r\n        canvasUnitVectorFromCenter,\r\n        canvasDiagonalLength * 100\r\n      );\r\n      const canvasVectorFromCenterMid = vec2.create();\r\n      vec2.scale(\r\n        canvasVectorFromCenterMid,\r\n        canvasUnitVectorFromCenter,\r\n        // to maximize the visibility of the controls, they need to be\r\n        // placed at most at half the length of the shortest side of the canvas.\r\n        // Chosen 0.4 to have some margin to the edge.\r\n        canvasMinDimensionLength * 0.4\r\n      );\r\n      const canvasVectorFromCenterShort = vec2.create();\r\n      vec2.scale(\r\n        canvasVectorFromCenterShort,\r\n        canvasUnitVectorFromCenter,\r\n        // Chosen 0.2 because is half of 0.4.\r\n        canvasMinDimensionLength * 0.2\r\n      );\r\n      const canvasVectorFromCenterStart = vec2.create();\r\n      const centerGap = this.configuration.referenceLinesCenterGapRadius;\r\n      vec2.scale(\r\n        canvasVectorFromCenterStart,\r\n        canvasUnitVectorFromCenter,\r\n        // Don't put a gap if the the third view is missing\r\n        otherViewportAnnotations.length === 2 ? centerGap : 0\r\n      );\r\n\r\n      // Computing Reference start and end (4 lines per viewport in case of 3 view MPR)\r\n      const refLinePointOne = vec2.create();\r\n      const refLinePointTwo = vec2.create();\r\n      const refLinePointThree = vec2.create();\r\n      const refLinePointFour = vec2.create();\r\n\r\n      let refLinesCenter = vec2.clone(crosshairCenterCanvas);\r\n      if (!otherViewportDraggableRotatable || !otherViewportControllable) {\r\n        refLinesCenter = vec2.clone(otherViewportCenterCanvas);\r\n      }\r\n\r\n      vec2.add(refLinePointOne, refLinesCenter, canvasVectorFromCenterStart);\r\n      vec2.add(refLinePointTwo, refLinesCenter, canvasVectorFromCenterLong);\r\n      vec2.subtract(\r\n        refLinePointThree,\r\n        refLinesCenter,\r\n        canvasVectorFromCenterStart\r\n      );\r\n      vec2.subtract(\r\n        refLinePointFour,\r\n        refLinesCenter,\r\n        canvasVectorFromCenterLong\r\n      );\r\n\r\n      // Clipping lines to be only included in a box (canvas), we don't want\r\n      // the lines goes beyond canvas\r\n      liangBarksyClip(refLinePointOne, refLinePointTwo, canvasBox);\r\n      liangBarksyClip(refLinePointThree, refLinePointFour, canvasBox);\r\n\r\n      // Computing rotation handle positions\r\n      const rotHandleOne = vec2.create();\r\n      vec2.subtract(\r\n        rotHandleOne,\r\n        crosshairCenterCanvas,\r\n        canvasVectorFromCenterMid\r\n      );\r\n\r\n      const rotHandleTwo = vec2.create();\r\n      vec2.add(rotHandleTwo, crosshairCenterCanvas, canvasVectorFromCenterMid);\r\n\r\n      // Computing SlabThickness (st below) position\r\n\r\n      // SlabThickness center in canvas\r\n      let stHandlesCenterCanvas = vec2.clone(crosshairCenterCanvas);\r\n      if (\r\n        !otherViewportDraggableRotatable &&\r\n        otherViewportSlabThicknessControlsOn\r\n      ) {\r\n        stHandlesCenterCanvas = vec2.clone(otherViewportCenterCanvas);\r\n      }\r\n\r\n      // SlabThickness center in world\r\n      let stHandlesCenterWorld: Types.Point3 = [...this.toolCenter];\r\n      if (\r\n        !otherViewportDraggableRotatable &&\r\n        otherViewportSlabThicknessControlsOn\r\n      ) {\r\n        stHandlesCenterWorld = [...otherViewportCenterWorld];\r\n      }\r\n\r\n      const worldUnitVectorFromCenter: Types.Point3 = [0, 0, 0];\r\n      vtkMath.subtract(pointWorld0, pointWorld1, worldUnitVectorFromCenter);\r\n      vtkMath.normalize(worldUnitVectorFromCenter);\r\n\r\n      const { viewPlaneNormal } = camera;\r\n      // @ts-ignore // Todo: fix after vtk pr merged\r\n      const { matrix } = vtkMatrixBuilder\r\n        .buildFromDegree()\r\n        // @ts-ignore fix after vtk pr merged\r\n        .rotate(90, viewPlaneNormal);\r\n\r\n      const worldUnitOrthoVectorFromCenter: Types.Point3 = [0, 0, 0];\r\n      vec3.transformMat4(\r\n        worldUnitOrthoVectorFromCenter,\r\n        worldUnitVectorFromCenter,\r\n        matrix\r\n      );\r\n\r\n      const slabThicknessValue = otherViewport.getSlabThickness();\r\n      const worldOrthoVectorFromCenter: Types.Point3 = [\r\n        ...worldUnitOrthoVectorFromCenter,\r\n      ];\r\n      vtkMath.multiplyScalar(worldOrthoVectorFromCenter, slabThicknessValue);\r\n\r\n      const worldVerticalRefPoint: Types.Point3 = [0, 0, 0];\r\n      vtkMath.add(\r\n        stHandlesCenterWorld,\r\n        worldOrthoVectorFromCenter,\r\n        worldVerticalRefPoint\r\n      );\r\n\r\n      // convert vertical world distances in canvas coordinates\r\n      const canvasVerticalRefPoint = viewport.worldToCanvas(\r\n        worldVerticalRefPoint\r\n      );\r\n\r\n      // points for slab thickness lines\r\n      const canvasOrthoVectorFromCenter = vec2.create();\r\n      vec2.subtract(\r\n        canvasOrthoVectorFromCenter,\r\n        stHandlesCenterCanvas,\r\n        canvasVerticalRefPoint\r\n      );\r\n\r\n      const stLinePointOne = vec2.create();\r\n      vec2.subtract(\r\n        stLinePointOne,\r\n        stHandlesCenterCanvas,\r\n        canvasVectorFromCenterLong\r\n      );\r\n      vec2.add(stLinePointOne, stLinePointOne, canvasOrthoVectorFromCenter);\r\n\r\n      const stLinePointTwo = vec2.create();\r\n      vec2.add(\r\n        stLinePointTwo,\r\n        stHandlesCenterCanvas,\r\n        canvasVectorFromCenterLong\r\n      );\r\n      vec2.add(stLinePointTwo, stLinePointTwo, canvasOrthoVectorFromCenter);\r\n\r\n      liangBarksyClip(stLinePointOne, stLinePointTwo, canvasBox);\r\n\r\n      const stLinePointThree = vec2.create();\r\n      vec2.add(\r\n        stLinePointThree,\r\n        stHandlesCenterCanvas,\r\n        canvasVectorFromCenterLong\r\n      );\r\n      vec2.subtract(\r\n        stLinePointThree,\r\n        stLinePointThree,\r\n        canvasOrthoVectorFromCenter\r\n      );\r\n\r\n      const stLinePointFour = vec2.create();\r\n      vec2.subtract(\r\n        stLinePointFour,\r\n        stHandlesCenterCanvas,\r\n        canvasVectorFromCenterLong\r\n      );\r\n      vec2.subtract(\r\n        stLinePointFour,\r\n        stLinePointFour,\r\n        canvasOrthoVectorFromCenter\r\n      );\r\n\r\n      liangBarksyClip(stLinePointThree, stLinePointFour, canvasBox);\r\n\r\n      // points for slab thickness handles\r\n      const stHandleOne = vec2.create();\r\n      const stHandleTwo = vec2.create();\r\n      const stHandleThree = vec2.create();\r\n      const stHandleFour = vec2.create();\r\n\r\n      vec2.subtract(\r\n        stHandleOne,\r\n        stHandlesCenterCanvas,\r\n        canvasVectorFromCenterShort\r\n      );\r\n      vec2.add(stHandleOne, stHandleOne, canvasOrthoVectorFromCenter);\r\n      vec2.add(stHandleTwo, stHandlesCenterCanvas, canvasVectorFromCenterShort);\r\n      vec2.add(stHandleTwo, stHandleTwo, canvasOrthoVectorFromCenter);\r\n      vec2.subtract(\r\n        stHandleThree,\r\n        stHandlesCenterCanvas,\r\n        canvasVectorFromCenterShort\r\n      );\r\n      vec2.subtract(stHandleThree, stHandleThree, canvasOrthoVectorFromCenter);\r\n      vec2.add(\r\n        stHandleFour,\r\n        stHandlesCenterCanvas,\r\n        canvasVectorFromCenterShort\r\n      );\r\n      vec2.subtract(stHandleFour, stHandleFour, canvasOrthoVectorFromCenter);\r\n\r\n      referenceLines.push([\r\n        otherViewport,\r\n        refLinePointOne,\r\n        refLinePointTwo,\r\n        refLinePointThree,\r\n        refLinePointFour,\r\n        stLinePointOne,\r\n        stLinePointTwo,\r\n        stLinePointThree,\r\n        stLinePointFour,\r\n        rotHandleOne,\r\n        rotHandleTwo,\r\n        stHandleOne,\r\n        stHandleTwo,\r\n        stHandleThree,\r\n        stHandleFour,\r\n      ]);\r\n    });\r\n\r\n    const newRtpoints = [];\r\n    const newStpoints = [];\r\n    const viewportColor = this._getReferenceLineColor(viewport.id);\r\n    const color =\r\n      viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\r\n\r\n    referenceLines.forEach((line, lineIndex) => {\r\n      // get color for the reference line\r\n      const otherViewport = line[0];\r\n      const viewportColor = this._getReferenceLineColor(otherViewport.id);\r\n      const viewportControllable = this._getReferenceLineControllable(\r\n        otherViewport.id\r\n      );\r\n      const viewportDraggableRotatable =\r\n        this._getReferenceLineDraggableRotatable(otherViewport.id) ||\r\n        this.configuration.mobile?.enabled;\r\n      const viewportSlabThicknessControlsOn =\r\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id) ||\r\n        this.configuration.mobile?.enabled;\r\n      const selectedViewportId = data.activeViewportIds.find(\r\n        (id) => id === otherViewport.id\r\n      );\r\n\r\n      let color =\r\n        viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\r\n\r\n      let lineWidth = 1;\r\n\r\n      const lineActive =\r\n        data.handles.activeOperation !== null &&\r\n        data.handles.activeOperation === OPERATION.DRAG &&\r\n        selectedViewportId;\r\n\r\n      if (lineActive) {\r\n        lineWidth = 2.5;\r\n      }\r\n\r\n      let lineUID = `${lineIndex}`;\r\n      if (viewportControllable && viewportDraggableRotatable) {\r\n        lineUID = `${lineIndex}One`;\r\n        drawLineSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          lineUID,\r\n          line[1],\r\n          line[2],\r\n          {\r\n            color,\r\n            lineWidth,\r\n          }\r\n        );\r\n\r\n        lineUID = `${lineIndex}Two`;\r\n        drawLineSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          lineUID,\r\n          line[3],\r\n          line[4],\r\n          {\r\n            color,\r\n            lineWidth,\r\n          }\r\n        );\r\n      } else {\r\n        drawLineSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          lineUID,\r\n          line[2],\r\n          line[4],\r\n          {\r\n            color,\r\n            lineWidth,\r\n          }\r\n        );\r\n      }\r\n\r\n      if (viewportControllable) {\r\n        color =\r\n          viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\r\n\r\n        const rotHandlesActive =\r\n          data.handles.activeOperation === OPERATION.ROTATE;\r\n        const rotationHandles = [line[9], line[10]];\r\n\r\n        const rotHandleWorldOne = [\r\n          viewport.canvasToWorld(line[9]),\r\n          otherViewport,\r\n          line[1],\r\n          line[2],\r\n        ];\r\n        const rotHandleWorldTwo = [\r\n          viewport.canvasToWorld(line[10]),\r\n          otherViewport,\r\n          line[3],\r\n          line[4],\r\n        ];\r\n        newRtpoints.push(rotHandleWorldOne, rotHandleWorldTwo);\r\n\r\n        const slabThicknessHandlesActive =\r\n          data.handles.activeOperation === OPERATION.SLAB;\r\n        const slabThicknessHandles = [line[11], line[12], line[13], line[14]];\r\n\r\n        const slabThicknessHandleWorldOne = [\r\n          viewport.canvasToWorld(line[11]),\r\n          otherViewport,\r\n          line[5],\r\n          line[6],\r\n        ];\r\n        const slabThicknessHandleWorldTwo = [\r\n          viewport.canvasToWorld(line[12]),\r\n          otherViewport,\r\n          line[5],\r\n          line[6],\r\n        ];\r\n        const slabThicknessHandleWorldThree = [\r\n          viewport.canvasToWorld(line[13]),\r\n          otherViewport,\r\n          line[7],\r\n          line[8],\r\n        ];\r\n        const slabThicknessHandleWorldFour = [\r\n          viewport.canvasToWorld(line[14]),\r\n          otherViewport,\r\n          line[7],\r\n          line[8],\r\n        ];\r\n        newStpoints.push(\r\n          slabThicknessHandleWorldOne,\r\n          slabThicknessHandleWorldTwo,\r\n          slabThicknessHandleWorldThree,\r\n          slabThicknessHandleWorldFour\r\n        );\r\n\r\n        if (\r\n          (lineActive || this.configuration.mobile?.enabled) &&\r\n          !rotHandlesActive &&\r\n          !slabThicknessHandlesActive &&\r\n          viewportDraggableRotatable &&\r\n          viewportSlabThicknessControlsOn\r\n        ) {\r\n          // draw all handles inactive (rotation and slab thickness)\r\n          let handleUID = `${lineIndex}One`;\r\n          drawHandlesSvg(\r\n            svgDrawingHelper,\r\n            annotationUID,\r\n            handleUID,\r\n            rotationHandles,\r\n            {\r\n              color,\r\n              handleRadius: this.configuration.mobile?.enabled\r\n                ? this.configuration.mobile?.handleRadius\r\n                : 3,\r\n              opacity: this.configuration.mobile?.enabled\r\n                ? this.configuration.mobile?.opacity\r\n                : 1,\r\n              type: 'circle',\r\n            }\r\n          );\r\n          handleUID = `${lineIndex}Two`;\r\n          drawHandlesSvg(\r\n            svgDrawingHelper,\r\n            annotationUID,\r\n            handleUID,\r\n            slabThicknessHandles,\r\n            {\r\n              color,\r\n              handleRadius: this.configuration.mobile?.enabled\r\n                ? this.configuration.mobile?.handleRadius\r\n                : 3,\r\n              opacity: this.configuration.mobile?.enabled\r\n                ? this.configuration.mobile?.opacity\r\n                : 1,\r\n              type: 'rect',\r\n            }\r\n          );\r\n        } else if (\r\n          lineActive &&\r\n          !rotHandlesActive &&\r\n          !slabThicknessHandlesActive &&\r\n          viewportDraggableRotatable\r\n        ) {\r\n          const handleUID = `${lineIndex}`;\r\n          // draw rotation handles inactive\r\n          drawHandlesSvg(\r\n            svgDrawingHelper,\r\n            annotationUID,\r\n            handleUID,\r\n            rotationHandles,\r\n            {\r\n              color,\r\n              handleRadius: this.configuration.mobile?.enabled\r\n                ? this.configuration.mobile?.handleRadius\r\n                : 3,\r\n              opacity: this.configuration.mobile?.enabled\r\n                ? this.configuration.mobile?.opacity\r\n                : 1,\r\n              type: 'circle',\r\n            }\r\n          );\r\n        } else if (\r\n          selectedViewportId &&\r\n          !rotHandlesActive &&\r\n          !slabThicknessHandlesActive &&\r\n          viewportSlabThicknessControlsOn\r\n        ) {\r\n          const handleUID = `${lineIndex}`;\r\n          // draw slab thickness handles inactive\r\n          drawHandlesSvg(\r\n            svgDrawingHelper,\r\n            annotationUID,\r\n            handleUID,\r\n            slabThicknessHandles,\r\n            {\r\n              color,\r\n              handleRadius: this.configuration.mobile?.enabled\r\n                ? this.configuration.mobile?.handleRadius\r\n                : 3,\r\n              opacity: this.configuration.mobile?.enabled\r\n                ? this.configuration.mobile?.opacity\r\n                : 1,\r\n              type: 'rect',\r\n            }\r\n          );\r\n        } else if (rotHandlesActive && viewportDraggableRotatable) {\r\n          const handleUID = `${lineIndex}`;\r\n          // draw all rotation handles as active\r\n          drawHandlesSvg(\r\n            svgDrawingHelper,\r\n            annotationUID,\r\n            handleUID,\r\n            rotationHandles,\r\n            {\r\n              color,\r\n              handleRadius: 2,\r\n              fill: color,\r\n              type: 'circle',\r\n            }\r\n          );\r\n        } else if (\r\n          slabThicknessHandlesActive &&\r\n          selectedViewportId &&\r\n          viewportSlabThicknessControlsOn\r\n        ) {\r\n          // draw only the slab thickness handles for the active viewport as active\r\n          drawHandlesSvg(\r\n            svgDrawingHelper,\r\n            annotationUID,\r\n            lineUID,\r\n            slabThicknessHandles,\r\n            {\r\n              color,\r\n              handleRadius: 2,\r\n              fill: color,\r\n              type: 'rect',\r\n            }\r\n          );\r\n        }\r\n        const slabThicknessValue = otherViewport.getSlabThickness();\r\n        if (slabThicknessValue > 0.5 && viewportSlabThicknessControlsOn) {\r\n          // draw slab thickness reference lines\r\n          lineUID = `${lineIndex}STOne`;\r\n          drawLineSvg(\r\n            svgDrawingHelper,\r\n            annotationUID,\r\n            lineUID,\r\n            line[5],\r\n            line[6],\r\n            {\r\n              color,\r\n              width: 1,\r\n              lineDash: [2, 3],\r\n            }\r\n          );\r\n\r\n          lineUID = `${lineIndex}STTwo`;\r\n          drawLineSvg(\r\n            svgDrawingHelper,\r\n            annotationUID,\r\n            lineUID,\r\n            line[7],\r\n            line[8],\r\n            {\r\n              color,\r\n              width: line,\r\n              lineDash: [2, 3],\r\n            }\r\n          );\r\n        }\r\n      }\r\n    });\r\n\r\n    renderStatus = true;\r\n\r\n    // Save new handles points in annotation\r\n    data.handles.rotationPoints = newRtpoints;\r\n    data.handles.slabThicknessPoints = newStpoints;\r\n\r\n    debugger;\r\n    if (this.configuration.viewportIndicators) {\r\n      const { viewportIndicatorsConfig } = this.configuration;\r\n\r\n      const xOffset = viewportIndicatorsConfig?.xOffset || 0.95;\r\n      const yOffset = viewportIndicatorsConfig?.yOffset || 0.05;\r\n      const referenceColorCoordinates = [\r\n        clientWidth * xOffset,\r\n        clientHeight * yOffset,\r\n      ];\r\n\r\n      const circleRadius =\r\n        viewportIndicatorsConfig?.circleRadius || canvasDiagonalLength * 0.01;\r\n\r\n      const circleUID = '0';\r\n      drawCircleSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        circleUID,\r\n        referenceColorCoordinates as Types.Point2,\r\n        circleRadius,\r\n        { color, fill: color }\r\n      );\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  _getAnnotations = (enabledElement: Types.IEnabledElement) => {\r\n    const { viewport } = enabledElement;\r\n    const annotations =\r\n      getAnnotations(this.getToolName(), viewport.element) || [];\r\n    const viewportIds = this._getViewportsInfo().map(\r\n      ({ viewportId }) => viewportId\r\n    );\r\n\r\n    // filter the annotations to only keep that are for this toolGroup\r\n    const toolGroupAnnotations = annotations.filter((annotation) => {\r\n      const { data } = annotation;\r\n      return viewportIds.includes(data.viewportId);\r\n    });\r\n\r\n    return toolGroupAnnotations;\r\n  };\r\n\r\n  _onNewVolume = (e: any) => {\r\n    const viewportsInfo = this._getViewportsInfo();\r\n    this.computeToolCenter(viewportsInfo);\r\n  };\r\n\r\n  _unsubscribeToViewportNewVolumeSet(viewportsInfo) {\r\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\r\n      const { viewport } = getEnabledElementByIds(\r\n        viewportId,\r\n        renderingEngineId\r\n      );\r\n      const { element } = viewport;\r\n\r\n      element.removeEventListener(\r\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\r\n        this._onNewVolume\r\n      );\r\n    });\r\n  }\r\n\r\n  _subscribeToViewportNewVolumeSet(viewports) {\r\n    viewports.forEach(({ viewportId, renderingEngineId }) => {\r\n      const { viewport } = getEnabledElementByIds(\r\n        viewportId,\r\n        renderingEngineId\r\n      );\r\n      const { element } = viewport;\r\n\r\n      element.addEventListener(\r\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\r\n        this._onNewVolume\r\n      );\r\n    });\r\n  }\r\n\r\n  _autoPanViewportIfNecessary(\r\n    viewportId: string,\r\n    renderingEngine: Types.IRenderingEngine\r\n  ): void {\r\n    // 1. Check if the toolCenter is outside the viewport\r\n    // 2. If it is outside, pan the viewport to fit in the toolCenter\r\n\r\n    const viewport = renderingEngine.getViewport(viewportId);\r\n    const { clientWidth, clientHeight } = viewport.canvas;\r\n\r\n    const toolCenterCanvas = viewport.worldToCanvas(this.toolCenter);\r\n\r\n    // pan the viewport to fit the toolCenter in the direction\r\n    // that is out of bounds\r\n    const pan = this.configuration.autoPan.panSize;\r\n\r\n    const visiblePointCanvas = <Types.Point2>[\r\n      toolCenterCanvas[0],\r\n      toolCenterCanvas[1],\r\n    ];\r\n\r\n    if (toolCenterCanvas[0] < 0) {\r\n      visiblePointCanvas[0] = pan;\r\n    } else if (toolCenterCanvas[0] > clientWidth) {\r\n      visiblePointCanvas[0] = clientWidth - pan;\r\n    }\r\n\r\n    if (toolCenterCanvas[1] < 0) {\r\n      visiblePointCanvas[1] = pan;\r\n    } else if (toolCenterCanvas[1] > clientHeight) {\r\n      visiblePointCanvas[1] = clientHeight - pan;\r\n    }\r\n\r\n    if (\r\n      visiblePointCanvas[0] === toolCenterCanvas[0] &&\r\n      visiblePointCanvas[1] === toolCenterCanvas[1]\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    const visiblePointWorld = viewport.canvasToWorld(visiblePointCanvas);\r\n\r\n    const deltaPointsWorld = [\r\n      visiblePointWorld[0] - this.toolCenter[0],\r\n      visiblePointWorld[1] - this.toolCenter[1],\r\n      visiblePointWorld[2] - this.toolCenter[2],\r\n    ];\r\n\r\n    const camera = viewport.getCamera();\r\n    const { focalPoint, position } = camera;\r\n\r\n    const updatedPosition = <Types.Point3>[\r\n      position[0] - deltaPointsWorld[0],\r\n      position[1] - deltaPointsWorld[1],\r\n      position[2] - deltaPointsWorld[2],\r\n    ];\r\n\r\n    const updatedFocalPoint = <Types.Point3>[\r\n      focalPoint[0] - deltaPointsWorld[0],\r\n      focalPoint[1] - deltaPointsWorld[1],\r\n      focalPoint[2] - deltaPointsWorld[2],\r\n    ];\r\n\r\n    viewport.setCamera({\r\n      focalPoint: updatedFocalPoint,\r\n      position: updatedPosition,\r\n    });\r\n\r\n    viewport.render();\r\n  }\r\n\r\n  _areViewportIdArraysEqual = (viewportIdArrayOne, viewportIdArrayTwo) => {\r\n    if (viewportIdArrayOne.length !== viewportIdArrayTwo.length) {\r\n      return false;\r\n    }\r\n\r\n    viewportIdArrayOne.forEach((id) => {\r\n      let itemFound = false;\r\n      for (let i = 0; i < viewportIdArrayTwo.length; ++i) {\r\n        if (id === viewportIdArrayTwo[i]) {\r\n          itemFound = true;\r\n          break;\r\n        }\r\n      }\r\n      if (itemFound === false) {\r\n        return false;\r\n      }\r\n    });\r\n\r\n    return true;\r\n  };\r\n\r\n  // It filters the viewports with crosshairs and only return viewports\r\n  // that have different camera.\r\n  _getAnnotationsForViewportsWithDifferentCameras = (\r\n    enabledElement,\r\n    annotations\r\n  ) => {\r\n    const { viewportId, renderingEngine, viewport } = enabledElement;\r\n\r\n    const otherViewportAnnotations = annotations.filter(\r\n      (annotation) => annotation.data.viewportId !== viewportId\r\n    );\r\n\r\n    if (!otherViewportAnnotations || !otherViewportAnnotations.length) {\r\n      return [];\r\n    }\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, position } = camera;\r\n\r\n    const viewportsWithDifferentCameras = otherViewportAnnotations.filter(\r\n      (annotation) => {\r\n        const { viewportId } = annotation.data;\r\n        const targetViewport = renderingEngine.getViewport(viewportId);\r\n        const cameraOfTarget = targetViewport.getCamera();\r\n\r\n        return !(\r\n          csUtils.isEqual(\r\n            cameraOfTarget.viewPlaneNormal,\r\n            viewPlaneNormal,\r\n            1e-2\r\n          ) && csUtils.isEqual(cameraOfTarget.position, position, 1)\r\n        );\r\n      }\r\n    );\r\n\r\n    return viewportsWithDifferentCameras;\r\n  };\r\n\r\n  _filterViewportWithSameOrientation = (\r\n    enabledElement,\r\n    referenceAnnotation,\r\n    annotations\r\n  ) => {\r\n    const { renderingEngine } = enabledElement;\r\n    const { data } = referenceAnnotation;\r\n    const viewport = renderingEngine.getViewport(data.viewportId);\r\n\r\n    const linkedViewportAnnotations = annotations.filter((annotation) => {\r\n      const { data } = annotation;\r\n      const otherViewport = renderingEngine.getViewport(data.viewportId);\r\n      const otherViewportControllable = this._getReferenceLineControllable(\r\n        otherViewport.id\r\n      );\r\n\r\n      return otherViewportControllable === true;\r\n    });\r\n\r\n    if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {\r\n      return [];\r\n    }\r\n\r\n    const camera = viewport.getCamera();\r\n    const viewPlaneNormal = camera.viewPlaneNormal;\r\n    vtkMath.normalize(viewPlaneNormal);\r\n\r\n    const otherViewportsAnnotationsWithSameCameraDirection =\r\n      linkedViewportAnnotations.filter((annotation) => {\r\n        const { viewportId } = annotation.data;\r\n        const otherViewport = renderingEngine.getViewport(viewportId);\r\n        const otherCamera = otherViewport.getCamera();\r\n        const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\r\n        vtkMath.normalize(otherViewPlaneNormal);\r\n\r\n        return (\r\n          csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&\r\n          csUtils.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2)\r\n        );\r\n      });\r\n\r\n    return otherViewportsAnnotationsWithSameCameraDirection;\r\n  };\r\n\r\n  _filterAnnotationsByUniqueViewportOrientations = (\r\n    enabledElement,\r\n    annotations\r\n  ) => {\r\n    const { renderingEngine, viewport } = enabledElement;\r\n    const camera = viewport.getCamera();\r\n    const viewPlaneNormal = camera.viewPlaneNormal;\r\n    vtkMath.normalize(viewPlaneNormal);\r\n\r\n    const otherLinkedViewportAnnotationsFromSameScene = annotations.filter(\r\n      (annotation) => {\r\n        const { data } = annotation;\r\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\r\n        const otherViewportControllable = this._getReferenceLineControllable(\r\n          otherViewport.id\r\n        );\r\n\r\n        return (\r\n          viewport !== otherViewport &&\r\n          // scene === otherScene &&\r\n          otherViewportControllable === true\r\n        );\r\n      }\r\n    );\r\n\r\n    const otherViewportsAnnotationsWithUniqueCameras = [];\r\n    // Iterate first on other viewport from the same scene linked\r\n    for (\r\n      let i = 0;\r\n      i < otherLinkedViewportAnnotationsFromSameScene.length;\r\n      ++i\r\n    ) {\r\n      const annotation = otherLinkedViewportAnnotationsFromSameScene[i];\r\n      const { viewportId } = annotation.data;\r\n      const otherViewport = renderingEngine.getViewport(viewportId);\r\n      const otherCamera = otherViewport.getCamera();\r\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\r\n      vtkMath.normalize(otherViewPlaneNormal);\r\n\r\n      if (\r\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\r\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      let cameraFound = false;\r\n      for (\r\n        let jj = 0;\r\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\r\n        ++jj\r\n      ) {\r\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\r\n        const { viewportId } = annotation.data;\r\n        const stockedViewport = renderingEngine.getViewport(viewportId);\r\n        const cameraOfStocked = stockedViewport.getCamera();\r\n\r\n        if (\r\n          csUtils.isEqual(\r\n            cameraOfStocked.viewPlaneNormal,\r\n            otherCamera.viewPlaneNormal,\r\n            1e-2\r\n          ) &&\r\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\r\n        ) {\r\n          cameraFound = true;\r\n        }\r\n      }\r\n\r\n      if (!cameraFound) {\r\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\r\n      }\r\n    }\r\n\r\n    const otherNonLinkedViewportAnnotationsFromSameScene = annotations.filter(\r\n      (annotation) => {\r\n        const { data } = annotation;\r\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\r\n        const otherViewportControllable = this._getReferenceLineControllable(\r\n          otherViewport.id\r\n        );\r\n\r\n        return (\r\n          viewport !== otherViewport &&\r\n          // scene === otherScene &&\r\n          otherViewportControllable !== true\r\n        );\r\n      }\r\n    );\r\n\r\n    // Iterate second on other viewport from the same scene non linked\r\n    for (\r\n      let i = 0;\r\n      i < otherNonLinkedViewportAnnotationsFromSameScene.length;\r\n      ++i\r\n    ) {\r\n      const annotation = otherNonLinkedViewportAnnotationsFromSameScene[i];\r\n      const { viewportId } = annotation.data;\r\n      const otherViewport = renderingEngine.getViewport(viewportId);\r\n\r\n      const otherCamera = otherViewport.getCamera();\r\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\r\n      vtkMath.normalize(otherViewPlaneNormal);\r\n\r\n      if (\r\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\r\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      let cameraFound = false;\r\n      for (\r\n        let jj = 0;\r\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\r\n        ++jj\r\n      ) {\r\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\r\n        const { viewportId } = annotation.data;\r\n        const stockedViewport = renderingEngine.getViewport(viewportId);\r\n        const cameraOfStocked = stockedViewport.getCamera();\r\n\r\n        if (\r\n          csUtils.isEqual(\r\n            cameraOfStocked.viewPlaneNormal,\r\n            otherCamera.viewPlaneNormal,\r\n            1e-2\r\n          ) &&\r\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\r\n        ) {\r\n          cameraFound = true;\r\n        }\r\n      }\r\n\r\n      if (!cameraFound) {\r\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\r\n      }\r\n    }\r\n\r\n    // Iterate on all the viewport\r\n    const otherViewportAnnotations =\r\n      this._getAnnotationsForViewportsWithDifferentCameras(\r\n        enabledElement,\r\n        annotations\r\n      );\r\n\r\n    for (let i = 0; i < otherViewportAnnotations.length; ++i) {\r\n      const annotation = otherViewportAnnotations[i];\r\n      if (\r\n        otherViewportsAnnotationsWithUniqueCameras.some(\r\n          (element) => element === annotation\r\n        )\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      const { viewportId } = annotation.data;\r\n      const otherViewport = renderingEngine.getViewport(viewportId);\r\n      const otherCamera = otherViewport.getCamera();\r\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\r\n      vtkMath.normalize(otherViewPlaneNormal);\r\n\r\n      if (\r\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\r\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      let cameraFound = false;\r\n      for (\r\n        let jj = 0;\r\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\r\n        ++jj\r\n      ) {\r\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\r\n        const { viewportId } = annotation.data;\r\n        const stockedViewport = renderingEngine.getViewport(viewportId);\r\n        const cameraOfStocked = stockedViewport.getCamera();\r\n\r\n        if (\r\n          csUtils.isEqual(\r\n            cameraOfStocked.viewPlaneNormal,\r\n            otherCamera.viewPlaneNormal,\r\n            1e-2\r\n          ) &&\r\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\r\n        ) {\r\n          cameraFound = true;\r\n        }\r\n      }\r\n\r\n      if (!cameraFound) {\r\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\r\n      }\r\n    }\r\n\r\n    return otherViewportsAnnotationsWithUniqueCameras;\r\n  };\r\n\r\n  _checkIfViewportsRenderingSameScene = (viewport, otherViewport) => {\r\n    const actors = viewport.getActors();\r\n    const otherViewportActors = otherViewport.getActors();\r\n\r\n    let sameScene = true;\r\n\r\n    actors.forEach((actor) => {\r\n      if (\r\n        actors.length !== otherViewportActors.length ||\r\n        otherViewportActors.find(({ uid }) => uid === actor.uid) === undefined\r\n      ) {\r\n        sameScene = false;\r\n      }\r\n    });\r\n\r\n    return sameScene;\r\n  };\r\n\r\n  _jump = (enabledElement, jumpWorld) => {\r\n    state.isInteractingWithTool = true;\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    const annotations = this._getAnnotations(enabledElement);\r\n\r\n    const delta: Types.Point3 = [0, 0, 0];\r\n    vtkMath.subtract(jumpWorld, this.toolCenter, delta);\r\n\r\n    // TRANSLATION\r\n    // get the annotation of the other viewport which are parallel to the delta shift and are of the same scene\r\n    const otherViewportAnnotations =\r\n      this._getAnnotationsForViewportsWithDifferentCameras(\r\n        enabledElement,\r\n        annotations\r\n      );\r\n\r\n    const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\r\n      (annotation) => {\r\n        const { data } = annotation;\r\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\r\n\r\n        const sameScene = this._checkIfViewportsRenderingSameScene(\r\n          viewport,\r\n          otherViewport\r\n        );\r\n\r\n        return (\r\n          this._getReferenceLineControllable(otherViewport.id) &&\r\n          this._getReferenceLineDraggableRotatable(otherViewport.id) &&\r\n          sameScene\r\n        );\r\n      }\r\n    );\r\n\r\n    if (viewportsAnnotationsToUpdate.length === 0) {\r\n      state.isInteractingWithTool = false;\r\n      return false;\r\n    }\r\n\r\n    this._applyDeltaShiftToSelectedViewportCameras(\r\n      renderingEngine,\r\n      viewportsAnnotationsToUpdate,\r\n      delta\r\n    );\r\n\r\n    state.isInteractingWithTool = false;\r\n\r\n    return true;\r\n  };\r\n\r\n  _activateModify = (element) => {\r\n    // mobile sometimes has lingering interaction even when touchEnd triggers\r\n    // this check allows for multiple handles to be active which doesn't affect\r\n    // tool usage.\r\n    state.isInteractingWithTool = !this.configuration.mobile?.enabled;\r\n\r\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\r\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  _deactivateModify = (element) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\r\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    this.editData.annotation.data.handles.activeOperation = null;\r\n    this.editData.annotation.data.activeViewportIds = [];\r\n\r\n    this._deactivateModify(element);\r\n\r\n    resetElementCursor(element);\r\n\r\n    this.editData = null;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    const requireSameOrientation = false;\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName(),\r\n      requireSameOrientation\r\n    );\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\r\n    const eventDetail = evt.detail;\r\n    const delta = eventDetail.deltaPoints.world;\r\n\r\n    if (\r\n      Math.abs(delta[0]) < 1e-3 &&\r\n      Math.abs(delta[1]) < 1e-3 &&\r\n      Math.abs(delta[2]) < 1e-3\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    const { element } = eventDetail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine, viewport } = enabledElement;\r\n    const annotations = this._getAnnotations(\r\n      enabledElement\r\n    ) as CrosshairsAnnotation[];\r\n    const filteredToolAnnotations =\r\n      this.filterInteractableAnnotationsForElement(element, annotations);\r\n\r\n    // viewport Annotation\r\n    const viewportAnnotation = filteredToolAnnotations[0];\r\n    if (!viewportAnnotation) {\r\n      return;\r\n    }\r\n\r\n    const { handles } = viewportAnnotation.data;\r\n    const { currentPoints } = evt.detail;\r\n    const canvasCoords = currentPoints.canvas;\r\n\r\n    if (handles.activeOperation === OPERATION.DRAG) {\r\n      // TRANSLATION\r\n      // get the annotation of the other viewport which are parallel to the delta shift and are of the same scene\r\n      const otherViewportAnnotations =\r\n        this._getAnnotationsForViewportsWithDifferentCameras(\r\n          enabledElement,\r\n          annotations\r\n        );\r\n\r\n      const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\r\n        (annotation) => {\r\n          const { data } = annotation;\r\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\r\n          const otherViewportControllable = this._getReferenceLineControllable(\r\n            otherViewport.id\r\n          );\r\n          const otherViewportDraggableRotatable =\r\n            this._getReferenceLineDraggableRotatable(otherViewport.id);\r\n\r\n          return (\r\n            otherViewportControllable === true &&\r\n            otherViewportDraggableRotatable === true &&\r\n            viewportAnnotation.data.activeViewportIds.find(\r\n              (id) => id === otherViewport.id\r\n            )\r\n          );\r\n        }\r\n      );\r\n\r\n      this._applyDeltaShiftToSelectedViewportCameras(\r\n        renderingEngine,\r\n        viewportsAnnotationsToUpdate,\r\n        delta\r\n      );\r\n    } else if (handles.activeOperation === OPERATION.ROTATE) {\r\n      // ROTATION\r\n      const otherViewportAnnotations =\r\n        this._getAnnotationsForViewportsWithDifferentCameras(\r\n          enabledElement,\r\n          annotations\r\n        );\r\n\r\n      const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\r\n        (annotation) => {\r\n          const { data } = annotation;\r\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\r\n          const otherViewportControllable = this._getReferenceLineControllable(\r\n            otherViewport.id\r\n          );\r\n          const otherViewportDraggableRotatable =\r\n            this._getReferenceLineDraggableRotatable(otherViewport.id);\r\n\r\n          return (\r\n            otherViewportControllable === true &&\r\n            otherViewportDraggableRotatable === true\r\n          );\r\n        }\r\n      );\r\n\r\n      const dir1 = vec2.create();\r\n      const dir2 = vec2.create();\r\n\r\n      const center: Types.Point3 = [\r\n        this.toolCenter[0],\r\n        this.toolCenter[1],\r\n        this.toolCenter[2],\r\n      ];\r\n\r\n      const centerCanvas = viewport.worldToCanvas(center);\r\n\r\n      const finalPointCanvas = eventDetail.currentPoints.canvas;\r\n      const originalPointCanvas = vec2.create();\r\n      vec2.sub(\r\n        originalPointCanvas,\r\n        finalPointCanvas,\r\n        eventDetail.deltaPoints.canvas\r\n      );\r\n      vec2.sub(dir1, originalPointCanvas, <vec2>centerCanvas);\r\n      vec2.sub(dir2, finalPointCanvas, <vec2>centerCanvas);\r\n\r\n      let angle = vec2.angle(dir1, dir2);\r\n\r\n      if (\r\n        this._isClockWise(centerCanvas, originalPointCanvas, finalPointCanvas)\r\n      ) {\r\n        angle *= -1;\r\n      }\r\n\r\n      // Rounding the angle to allow rotated handles to be undone\r\n      // If we don't round and rotate handles clockwise by 0.0131233 radians,\r\n      // there's no assurance that the counter-clockwise rotation occurs at\r\n      // precisely -0.0131233, resulting in the drawn annotations being lost.\r\n      angle = Math.round(angle * 100) / 100;\r\n\r\n      const rotationAxis = viewport.getCamera().viewPlaneNormal;\r\n      // @ts-ignore : vtkjs incorrect typing\r\n      const { matrix } = vtkMatrixBuilder\r\n        .buildFromRadian()\r\n        .translate(center[0], center[1], center[2])\r\n        // @ts-ignore\r\n        .rotate(angle, rotationAxis) //todo: why we are passing\r\n        .translate(-center[0], -center[1], -center[2]);\r\n\r\n      const otherViewportsIds = [];\r\n      // update camera for the other viewports.\r\n      // NOTE: The lines then are rendered by the onCameraModified\r\n      viewportsAnnotationsToUpdate.forEach((annotation) => {\r\n        const { data } = annotation;\r\n        data.handles.toolCenter = center;\r\n\r\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\r\n        const camera = otherViewport.getCamera();\r\n        const { viewUp, position, focalPoint } = camera;\r\n\r\n        viewUp[0] += position[0];\r\n        viewUp[1] += position[1];\r\n        viewUp[2] += position[2];\r\n\r\n        vec3.transformMat4(focalPoint, focalPoint, matrix);\r\n        vec3.transformMat4(position, position, matrix);\r\n        vec3.transformMat4(viewUp, viewUp, matrix);\r\n\r\n        viewUp[0] -= position[0];\r\n        viewUp[1] -= position[1];\r\n        viewUp[2] -= position[2];\r\n\r\n        otherViewport.setCamera({\r\n          position,\r\n          viewUp,\r\n          focalPoint,\r\n        });\r\n        otherViewportsIds.push(otherViewport.id);\r\n      });\r\n      renderingEngine.renderViewports(otherViewportsIds);\r\n    } else if (handles.activeOperation === OPERATION.SLAB) {\r\n      // SLAB THICKNESS\r\n      // this should be just the active one under the mouse,\r\n      const otherViewportAnnotations =\r\n        this._getAnnotationsForViewportsWithDifferentCameras(\r\n          enabledElement,\r\n          annotations\r\n        );\r\n\r\n      const referenceAnnotations = otherViewportAnnotations.filter(\r\n        (annotation) => {\r\n          const { data } = annotation;\r\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\r\n          const otherViewportControllable = this._getReferenceLineControllable(\r\n            otherViewport.id\r\n          );\r\n          const otherViewportSlabThicknessControlsOn =\r\n            this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\r\n\r\n          return (\r\n            otherViewportControllable === true &&\r\n            otherViewportSlabThicknessControlsOn === true &&\r\n            viewportAnnotation.data.activeViewportIds.find(\r\n              (id) => id === otherViewport.id\r\n            )\r\n          );\r\n        }\r\n      );\r\n\r\n      if (referenceAnnotations.length === 0) {\r\n        return;\r\n      }\r\n      const viewportsAnnotationsToUpdate =\r\n        this._filterViewportWithSameOrientation(\r\n          enabledElement,\r\n          referenceAnnotations[0],\r\n          annotations\r\n        );\r\n\r\n      const viewportsIds = [];\r\n      viewportsIds.push(viewport.id);\r\n      viewportsAnnotationsToUpdate.forEach(\r\n        (annotation: CrosshairsAnnotation) => {\r\n          const { data } = annotation;\r\n\r\n          const otherViewport = renderingEngine.getViewport(\r\n            data.viewportId\r\n          ) as Types.IVolumeViewport;\r\n          const camera = otherViewport.getCamera();\r\n          const normal = camera.viewPlaneNormal;\r\n\r\n          const dotProd = vtkMath.dot(delta, normal);\r\n          const projectedDelta: Types.Point3 = [...normal];\r\n          vtkMath.multiplyScalar(projectedDelta, dotProd);\r\n\r\n          if (\r\n            Math.abs(projectedDelta[0]) > 1e-3 ||\r\n            Math.abs(projectedDelta[1]) > 1e-3 ||\r\n            Math.abs(projectedDelta[2]) > 1e-3\r\n          ) {\r\n            const mod = Math.sqrt(\r\n              projectedDelta[0] * projectedDelta[0] +\r\n                projectedDelta[1] * projectedDelta[1] +\r\n                projectedDelta[2] * projectedDelta[2]\r\n            );\r\n\r\n            const currentPoint = eventDetail.lastPoints.world;\r\n            const direction: Types.Point3 = [0, 0, 0];\r\n\r\n            const currentCenter: Types.Point3 = [\r\n              this.toolCenter[0],\r\n              this.toolCenter[1],\r\n              this.toolCenter[2],\r\n            ];\r\n\r\n            // use this.toolCenter only if viewportDraggableRotatable\r\n            const viewportDraggableRotatable =\r\n              this._getReferenceLineDraggableRotatable(otherViewport.id);\r\n            if (!viewportDraggableRotatable) {\r\n              const { rotationPoints } = this.editData.annotation.data.handles;\r\n              // Todo: what is a point uid?\r\n              const otherViewportRotationPoints = rotationPoints.filter(\r\n                (point) => point[1].uid === otherViewport.id\r\n              );\r\n              if (otherViewportRotationPoints.length === 2) {\r\n                const point1 = viewport.canvasToWorld(\r\n                  otherViewportRotationPoints[0][3]\r\n                );\r\n                const point2 = viewport.canvasToWorld(\r\n                  otherViewportRotationPoints[1][3]\r\n                );\r\n                vtkMath.add(point1, point2, currentCenter);\r\n                vtkMath.multiplyScalar(<Types.Point3>currentCenter, 0.5);\r\n              }\r\n            }\r\n\r\n            vtkMath.subtract(currentPoint, currentCenter, direction);\r\n            const dotProdDirection = vtkMath.dot(direction, normal);\r\n            const projectedDirection: Types.Point3 = [...normal];\r\n            vtkMath.multiplyScalar(projectedDirection, dotProdDirection);\r\n            const normalizedProjectedDirection: Types.Point3 = [\r\n              projectedDirection[0],\r\n              projectedDirection[1],\r\n              projectedDirection[2],\r\n            ];\r\n            vec3.normalize(\r\n              normalizedProjectedDirection,\r\n              normalizedProjectedDirection\r\n            );\r\n            const normalizedProjectedDelta: Types.Point3 = [\r\n              projectedDelta[0],\r\n              projectedDelta[1],\r\n              projectedDelta[2],\r\n            ];\r\n            vec3.normalize(normalizedProjectedDelta, normalizedProjectedDelta);\r\n\r\n            let slabThicknessValue = otherViewport.getSlabThickness();\r\n            if (\r\n              csUtils.isOpposite(\r\n                normalizedProjectedDirection,\r\n                normalizedProjectedDelta,\r\n                1e-3\r\n              )\r\n            ) {\r\n              slabThicknessValue -= mod;\r\n            } else {\r\n              slabThicknessValue += mod;\r\n            }\r\n\r\n            slabThicknessValue = Math.abs(slabThicknessValue);\r\n            slabThicknessValue = Math.max(\r\n              RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS,\r\n              slabThicknessValue\r\n            );\r\n\r\n            const near = this._pointNearReferenceLine(\r\n              viewportAnnotation,\r\n              canvasCoords,\r\n              6,\r\n              otherViewport\r\n            );\r\n\r\n            if (near) {\r\n              slabThicknessValue = RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;\r\n            }\r\n\r\n            // We want to set the slabThickness for the viewport's actors but\r\n            // since the crosshairs tool instance has configuration regarding which\r\n            // actorUIDs (in case of volume -> actorUID = volumeIds) to set the\r\n            // slabThickness for, we need to delegate the slabThickness setting\r\n            // to the crosshairs tool instance of the toolGroup since configurations\r\n            // exist on the toolInstance and each toolGroup has its own crosshairs\r\n            // tool instance (Otherwise, we would need to set this filterActorUIDsToSetSlabThickness at\r\n            // the viewport level which makes tool and viewport state convoluted).\r\n            const toolGroup = getToolGroupForViewport(\r\n              otherViewport.id,\r\n              renderingEngine.id\r\n            );\r\n            const crosshairsInstance = toolGroup.getToolInstance(\r\n              this.getToolName()\r\n            );\r\n            crosshairsInstance.setSlabThickness(\r\n              otherViewport,\r\n              slabThicknessValue\r\n            );\r\n\r\n            viewportsIds.push(otherViewport.id);\r\n          }\r\n        }\r\n      );\r\n      renderingEngine.renderViewports(viewportsIds);\r\n    }\r\n  };\r\n\r\n  setSlabThickness(viewport, slabThickness) {\r\n    let actorUIDs;\r\n    const { filterActorUIDsToSetSlabThickness } = this.configuration;\r\n    if (\r\n      filterActorUIDsToSetSlabThickness &&\r\n      filterActorUIDsToSetSlabThickness.length > 0\r\n    ) {\r\n      actorUIDs = filterActorUIDsToSetSlabThickness;\r\n    }\r\n\r\n    let blendModeToUse = this.configuration.slabThicknessBlendMode;\r\n    if (slabThickness === RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS) {\r\n      blendModeToUse = Enums.BlendModes.COMPOSITE;\r\n    }\r\n\r\n    const immediate = false;\r\n    viewport.setBlendMode(blendModeToUse, actorUIDs, immediate);\r\n    viewport.setSlabThickness(slabThickness, actorUIDs);\r\n  }\r\n\r\n  _isClockWise(a, b, c) {\r\n    // return true if the rotation is clockwise\r\n    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;\r\n  }\r\n\r\n  _applyDeltaShiftToSelectedViewportCameras(\r\n    renderingEngine,\r\n    viewportsAnnotationsToUpdate,\r\n    delta\r\n  ) {\r\n    // update camera for the other viewports.\r\n    // NOTE1: The lines then are rendered by the onCameraModified\r\n    // NOTE2: crosshair center are automatically updated in the onCameraModified event\r\n    viewportsAnnotationsToUpdate.forEach((annotation) => {\r\n      this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);\r\n    });\r\n  }\r\n\r\n  _applyDeltaShiftToViewportCamera(\r\n    renderingEngine: Types.IRenderingEngine,\r\n    annotation,\r\n    delta\r\n  ) {\r\n    // update camera for the other viewports.\r\n    // NOTE1: The lines then are rendered by the onCameraModified\r\n    // NOTE2: crosshair center are automatically updated in the onCameraModified event\r\n    const { data } = annotation;\r\n\r\n    const viewport = renderingEngine.getViewport(data.viewportId);\r\n    const camera = viewport.getCamera();\r\n    const normal = camera.viewPlaneNormal;\r\n\r\n    // Project delta over camera normal\r\n    // (we don't need to pan, we need only to scroll the camera as in the wheel stack scroll tool)\r\n    const dotProd = vtkMath.dot(delta, normal);\r\n    const projectedDelta: Types.Point3 = [...normal];\r\n    vtkMath.multiplyScalar(projectedDelta, dotProd);\r\n\r\n    if (\r\n      Math.abs(projectedDelta[0]) > 1e-3 ||\r\n      Math.abs(projectedDelta[1]) > 1e-3 ||\r\n      Math.abs(projectedDelta[2]) > 1e-3\r\n    ) {\r\n      const newFocalPoint: Types.Point3 = [0, 0, 0];\r\n      const newPosition: Types.Point3 = [0, 0, 0];\r\n\r\n      vtkMath.add(camera.focalPoint, projectedDelta, newFocalPoint);\r\n      vtkMath.add(camera.position, projectedDelta, newPosition);\r\n\r\n      viewport.setCamera({\r\n        focalPoint: newFocalPoint,\r\n        position: newPosition,\r\n      });\r\n      viewport.render();\r\n    }\r\n  }\r\n\r\n  _pointNearReferenceLine = (\r\n    annotation,\r\n    canvasCoords,\r\n    proximity,\r\n    lineViewport\r\n  ) => {\r\n    const { data } = annotation;\r\n    const { rotationPoints } = data.handles;\r\n\r\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\r\n      const otherViewport = rotationPoints[i][1];\r\n      if (otherViewport.id !== lineViewport.id) {\r\n        continue;\r\n      }\r\n\r\n      const viewportControllable = this._getReferenceLineControllable(\r\n        otherViewport.id\r\n      );\r\n      if (!viewportControllable) {\r\n        continue;\r\n      }\r\n\r\n      const lineSegment1 = {\r\n        start: {\r\n          x: rotationPoints[i][2][0],\r\n          y: rotationPoints[i][2][1],\r\n        },\r\n        end: {\r\n          x: rotationPoints[i][3][0],\r\n          y: rotationPoints[i][3][1],\r\n        },\r\n      };\r\n\r\n      const distanceToPoint1 = lineSegment.distanceToPoint(\r\n        [lineSegment1.start.x, lineSegment1.start.y],\r\n        [lineSegment1.end.x, lineSegment1.end.y],\r\n        [canvasCoords[0], canvasCoords[1]]\r\n      );\r\n\r\n      const lineSegment2 = {\r\n        start: {\r\n          x: rotationPoints[i + 1][2][0],\r\n          y: rotationPoints[i + 1][2][1],\r\n        },\r\n        end: {\r\n          x: rotationPoints[i + 1][3][0],\r\n          y: rotationPoints[i + 1][3][1],\r\n        },\r\n      };\r\n\r\n      const distanceToPoint2 = lineSegment.distanceToPoint(\r\n        [lineSegment2.start.x, lineSegment2.start.y],\r\n        [lineSegment2.end.x, lineSegment2.end.y],\r\n        [canvasCoords[0], canvasCoords[1]]\r\n      );\r\n\r\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\r\n        return true;\r\n      }\r\n\r\n      // rotation handles are two for viewport\r\n      i++;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  _getRotationHandleNearImagePoint(\r\n    viewport,\r\n    annotation,\r\n    canvasCoords,\r\n    proximity\r\n  ) {\r\n    const { data } = annotation;\r\n    const { rotationPoints } = data.handles;\r\n\r\n    for (let i = 0; i < rotationPoints.length; i++) {\r\n      const point = rotationPoints[i][0];\r\n      const otherViewport = rotationPoints[i][1];\r\n      const viewportControllable = this._getReferenceLineControllable(\r\n        otherViewport.id\r\n      );\r\n      if (!viewportControllable) {\r\n        continue;\r\n      }\r\n\r\n      const viewportDraggableRotatable =\r\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\r\n      if (!viewportDraggableRotatable) {\r\n        continue;\r\n      }\r\n\r\n      const annotationCanvasCoordinate = viewport.worldToCanvas(point);\r\n      if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\r\n        data.handles.activeOperation = OPERATION.ROTATE;\r\n\r\n        this.editData = {\r\n          annotation,\r\n        };\r\n\r\n        return point;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  _getSlabThicknessHandleNearImagePoint(\r\n    viewport,\r\n    annotation,\r\n    canvasCoords,\r\n    proximity\r\n  ) {\r\n    const { data } = annotation;\r\n    const { slabThicknessPoints } = data.handles;\r\n\r\n    for (let i = 0; i < slabThicknessPoints.length; i++) {\r\n      const point = slabThicknessPoints[i][0];\r\n      const otherViewport = slabThicknessPoints[i][1];\r\n      const viewportControllable = this._getReferenceLineControllable(\r\n        otherViewport.id\r\n      );\r\n      if (!viewportControllable) {\r\n        continue;\r\n      }\r\n\r\n      const viewportSlabThicknessControlsOn =\r\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\r\n      if (!viewportSlabThicknessControlsOn) {\r\n        continue;\r\n      }\r\n\r\n      const annotationCanvasCoordinate = viewport.worldToCanvas(point);\r\n      if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\r\n        data.handles.activeOperation = OPERATION.SLAB;\r\n\r\n        data.activeViewportIds = [otherViewport.id];\r\n\r\n        this.editData = {\r\n          annotation,\r\n        };\r\n\r\n        return point;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  _pointNearTool(element, annotation, canvasCoords, proximity) {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const { clientWidth, clientHeight } = viewport.canvas;\r\n    const canvasDiagonalLength = Math.sqrt(\r\n      clientWidth * clientWidth + clientHeight * clientHeight\r\n    );\r\n    const { data } = annotation;\r\n\r\n    const { rotationPoints } = data.handles;\r\n    const { slabThicknessPoints } = data.handles;\r\n    const viewportIdArray = [];\r\n\r\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\r\n      const otherViewport = rotationPoints[i][1];\r\n      const viewportControllable = this._getReferenceLineControllable(\r\n        otherViewport.id\r\n      );\r\n      const viewportDraggableRotatable =\r\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\r\n\r\n      if (!viewportControllable || !viewportDraggableRotatable) {\r\n        continue;\r\n      }\r\n\r\n      const lineSegment1 = {\r\n        start: {\r\n          x: rotationPoints[i][2][0],\r\n          y: rotationPoints[i][2][1],\r\n        },\r\n        end: {\r\n          x: rotationPoints[i][3][0],\r\n          y: rotationPoints[i][3][1],\r\n        },\r\n      };\r\n\r\n      const distanceToPoint1 = lineSegment.distanceToPoint(\r\n        [lineSegment1.start.x, lineSegment1.start.y],\r\n        [lineSegment1.end.x, lineSegment1.end.y],\r\n        [canvasCoords[0], canvasCoords[1]]\r\n      );\r\n\r\n      const lineSegment2 = {\r\n        start: {\r\n          x: rotationPoints[i + 1][2][0],\r\n          y: rotationPoints[i + 1][2][1],\r\n        },\r\n        end: {\r\n          x: rotationPoints[i + 1][3][0],\r\n          y: rotationPoints[i + 1][3][1],\r\n        },\r\n      };\r\n\r\n      const distanceToPoint2 = lineSegment.distanceToPoint(\r\n        [lineSegment2.start.x, lineSegment2.start.y],\r\n        [lineSegment2.end.x, lineSegment2.end.y],\r\n        [canvasCoords[0], canvasCoords[1]]\r\n      );\r\n\r\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\r\n        viewportIdArray.push(otherViewport.id);\r\n        data.handles.activeOperation = OPERATION.DRAG;\r\n      }\r\n\r\n      // rotation handles are two for viewport\r\n      i++;\r\n    }\r\n\r\n    for (let i = 0; i < slabThicknessPoints.length - 1; ++i) {\r\n      const otherViewport = slabThicknessPoints[i][1];\r\n      if (viewportIdArray.find((id) => id === otherViewport.id)) {\r\n        continue;\r\n      }\r\n\r\n      const viewportControllable = this._getReferenceLineControllable(\r\n        otherViewport.id\r\n      );\r\n      const viewportSlabThicknessControlsOn =\r\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\r\n\r\n      if (!viewportControllable || !viewportSlabThicknessControlsOn) {\r\n        continue;\r\n      }\r\n\r\n      const stPointLineCanvas1 = slabThicknessPoints[i][2];\r\n      const stPointLineCanvas2 = slabThicknessPoints[i][3];\r\n\r\n      const centerCanvas = vec2.create();\r\n      vec2.add(centerCanvas, stPointLineCanvas1, stPointLineCanvas2);\r\n      vec2.scale(centerCanvas, centerCanvas, 0.5);\r\n\r\n      const canvasUnitVectorFromCenter = vec2.create();\r\n      vec2.subtract(\r\n        canvasUnitVectorFromCenter,\r\n        stPointLineCanvas1,\r\n        centerCanvas\r\n      );\r\n      vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\r\n\r\n      const canvasVectorFromCenterStart = vec2.create();\r\n      vec2.scale(\r\n        canvasVectorFromCenterStart,\r\n        canvasUnitVectorFromCenter,\r\n        canvasDiagonalLength * 0.05\r\n      );\r\n\r\n      const stPointLineCanvas1Start = vec2.create();\r\n      const stPointLineCanvas2Start = vec2.create();\r\n      vec2.add(\r\n        stPointLineCanvas1Start,\r\n        centerCanvas,\r\n        canvasVectorFromCenterStart\r\n      );\r\n      vec2.subtract(\r\n        stPointLineCanvas2Start,\r\n        centerCanvas,\r\n        canvasVectorFromCenterStart\r\n      );\r\n\r\n      const lineSegment1 = {\r\n        start: {\r\n          x: stPointLineCanvas1Start[0],\r\n          y: stPointLineCanvas1Start[1],\r\n        },\r\n        end: {\r\n          x: stPointLineCanvas1[0],\r\n          y: stPointLineCanvas1[1],\r\n        },\r\n      };\r\n\r\n      const distanceToPoint1 = lineSegment.distanceToPoint(\r\n        [lineSegment1.start.x, lineSegment1.start.y],\r\n        [lineSegment1.end.x, lineSegment1.end.y],\r\n        [canvasCoords[0], canvasCoords[1]]\r\n      );\r\n\r\n      const lineSegment2 = {\r\n        start: {\r\n          x: stPointLineCanvas2Start[0],\r\n          y: stPointLineCanvas2Start[1],\r\n        },\r\n        end: {\r\n          x: stPointLineCanvas2[0],\r\n          y: stPointLineCanvas2[1],\r\n        },\r\n      };\r\n\r\n      const distanceToPoint2 = lineSegment.distanceToPoint(\r\n        [lineSegment2.start.x, lineSegment2.start.y],\r\n        [lineSegment2.end.x, lineSegment2.end.y],\r\n        [canvasCoords[0], canvasCoords[1]]\r\n      );\r\n\r\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\r\n        viewportIdArray.push(otherViewport.id); // we still need this to draw inactive slab thickness handles\r\n        data.handles.activeOperation = null; // no operation\r\n      }\r\n\r\n      // slab thickness handles are in couples\r\n      i++;\r\n    }\r\n\r\n    data.activeViewportIds = [...viewportIdArray];\r\n\r\n    this.editData = {\r\n      annotation,\r\n    };\r\n\r\n    return data.handles.activeOperation === OPERATION.DRAG ? true : false;\r\n  }\r\n}\r\n\r\nCrosshairsTool.toolName = 'Crosshairs';\r\nexport default CrosshairsTool;\r\n","import { BaseTool } from './base';\r\nimport { getEnabledElement, VolumeViewport } from '@cornerstonejs/core';\r\nimport { type Types, utilities } from '@cornerstonejs/core';\r\nimport { getPointInLineOfSightWithCriteria } from '../utilities/planar';\r\nimport jumpToWorld from '../utilities/viewport/jumpToWorld';\r\nimport { PublicToolProps, ToolProps } from '../types';\r\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\r\n\r\n/**\r\n * On a Maximum Intensity Projection (MIP) viewport, MIPJumpToClickTool allows the\r\n * user to click on a point in the MIP and the targetViewportIdS (provided in the\r\n * tool configuration) will be scrolled (jumped) to the location of the point with\r\n * the highest intensity value in the MIP.\r\n */\r\nclass MIPJumpToClickTool extends BaseTool {\r\n  static toolName;\r\n\r\n  _bounds: any;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        targetViewportIds: [],\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  /**\r\n   * Handles the click event, and move the camera's focal point the brightest\r\n   * point that is in the line of sight of camera. This function 1) search for the\r\n   * brightest point in the line of sight, 2) move the camera to that point,\r\n   * this triggers a cameraModified event which then 4) moves all other synced\r\n   * viewports and their crosshairs.\r\n   *\r\n   * @param evt - click event\r\n   */\r\n  mouseClickCallback(evt): void {\r\n    const { element, currentPoints } = evt.detail;\r\n\r\n    // 1. Getting the enabled element\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    // 2. Getting the target volume that is clicked on\r\n    const targetId = this.getTargetId(viewport as Types.IVolumeViewport);\r\n\r\n    if (!targetId.startsWith('volumeId')) {\r\n      throw new Error(\r\n        `MIPJumpToClickTool: targetId is not a volumeId, you should only use MIPJumpToClickTool with a volumeId as the targetId`\r\n      );\r\n    }\r\n\r\n    const volumeId = utilities.getVolumeId(targetId);\r\n\r\n    // 3. Criteria function to search for the point (maximum intensity)\r\n    let maxIntensity = -Infinity;\r\n    const maxFn = (intensity, point) => {\r\n      if (intensity > maxIntensity) {\r\n        maxIntensity = intensity;\r\n        return point;\r\n      }\r\n    };\r\n\r\n    // 4. Search for the brightest point location in the line of sight\r\n    const brightestPoint = getPointInLineOfSightWithCriteria(\r\n      viewport as Types.IVolumeViewport,\r\n      currentPoints.world,\r\n      volumeId,\r\n      maxFn\r\n    );\r\n\r\n    if (!brightestPoint || !brightestPoint.length) {\r\n      return;\r\n    }\r\n\r\n    const { targetViewportIds, toolGroupId } = this.configuration;\r\n    // TODO - consider making this a utility\r\n    const viewports = renderingEngine.getViewports().filter((vp) => {\r\n      if (targetViewportIds?.indexOf(vp.id) >= 0) {\r\n        return true;\r\n      }\r\n      const foundToolGroup = getToolGroupForViewport(vp.id, renderingEngine.id);\r\n      if (toolGroupId && toolGroupId === foundToolGroup?.id) {\r\n        return true;\r\n      }\r\n      return false;\r\n    });\r\n\r\n    // 6. Update all the targetedViewports to jump\r\n    viewports.forEach((viewport) => {\r\n      // Todo: current limitation is that we cannot jump in viewports\r\n      // that don't belong to the renderingEngine of the source clicked viewport\r\n      if (viewport instanceof VolumeViewport) {\r\n        jumpToWorld(viewport, brightestPoint);\r\n      } else {\r\n        console.warn(\r\n          'Cannot jump to specified world coordinates for a viewport that is not a VolumeViewport'\r\n        );\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nMIPJumpToClickTool.toolName = 'MIPJumpToClickTool';\r\nexport default MIPJumpToClickTool;\r\n","import { BaseTool } from './base';\r\nimport { Events } from '../enums';\r\n\r\nimport { getEnabledElement, StackViewport } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\r\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\r\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\r\nimport { state } from '../store';\r\nimport { Enums } from '@cornerstonejs/core';\r\n\r\nimport {\r\n  hideElementCursor,\r\n  resetElementCursor,\r\n} from '../cursors/elementCursor';\r\nimport { IPoints } from '../types';\r\n\r\nconst MAGNIFY_VIEWPORT_ID = 'magnify-viewport';\r\n\r\nclass MagnifyTool extends BaseTool {\r\n  static toolName;\r\n  _bounds: any;\r\n  editData: {\r\n    referencedImageId: string;\r\n    viewportIdsToRender: string[];\r\n    enabledElement: Types.IEnabledElement;\r\n    renderingEngine: Types.IRenderingEngine;\r\n    currentPoints: IPoints;\r\n  } | null;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        magnifySize: 10, // parallel scale , higher more zoom\r\n        magnifyWidth: 250, //px\r\n        magnifyHeight: 250, //px\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  private _hasBeenRemoved = false;\r\n\r\n  _getReferencedImageId(\r\n    viewport: Types.IStackViewport | Types.IVolumeViewport\r\n  ): string {\r\n    const targetId = this.getTargetId(viewport);\r\n\r\n    let referencedImageId;\r\n\r\n    if (viewport instanceof StackViewport) {\r\n      referencedImageId = targetId.split('imageId:')[1];\r\n    }\r\n\r\n    return referencedImageId;\r\n  }\r\n\r\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType) => {\r\n    const eventDetail = evt.detail;\r\n    const { element, currentPoints } = eventDetail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    if (!(viewport instanceof StackViewport)) {\r\n      throw new Error('MagnifyTool only works on StackViewports');\r\n    }\r\n\r\n    const referencedImageId = this._getReferencedImageId(viewport);\r\n\r\n    if (!referencedImageId) {\r\n      throw new Error(\r\n        'MagnifyTool: No referenced image id found, reconstructed planes not supported yet'\r\n      );\r\n    }\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      referencedImageId,\r\n      viewportIdsToRender,\r\n      enabledElement,\r\n      renderingEngine,\r\n      currentPoints,\r\n    };\r\n\r\n    this._createMagnificationViewport();\r\n    this._activateDraw(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return true;\r\n  };\r\n\r\n  preTouchStartCallback = (evt: EventTypes.InteractionEventType) => {\r\n    this.preMouseDownCallback(evt);\r\n  };\r\n\r\n  _createMagnificationViewport = () => {\r\n    const {\r\n      enabledElement,\r\n      referencedImageId,\r\n      viewportIdsToRender,\r\n      renderingEngine,\r\n      currentPoints,\r\n    } = this.editData;\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n    const viewportProperties = viewport.getProperties();\r\n\r\n    const { canvas: canvasPos, world: worldPos } = currentPoints;\r\n\r\n    let magnifyToolElement: HTMLDivElement;\r\n\r\n    magnifyToolElement = element.querySelector('.magnifyTool');\r\n    if (magnifyToolElement === null) {\r\n      const magnifyElement = document.createElement('div');\r\n\r\n      magnifyElement.classList.add('magnifyTool');\r\n\r\n      magnifyElement.style.display = 'block';\r\n      magnifyElement.style.width = `${this.configuration.magnifyWidth}px`;\r\n      magnifyElement.style.height = `${this.configuration.magnifyHeight}px`;\r\n      magnifyElement.style.position = 'absolute';\r\n\r\n      magnifyToolElement = magnifyElement;\r\n\r\n      const viewportElement = element.querySelector('.viewport-element');\r\n      viewportElement.appendChild(magnifyElement);\r\n\r\n      const viewportInput = {\r\n        viewportId: MAGNIFY_VIEWPORT_ID,\r\n        type: Enums.ViewportType.STACK,\r\n        element: magnifyToolElement as HTMLDivElement,\r\n      };\r\n\r\n      renderingEngine.enableElement(viewportInput);\r\n    }\r\n\r\n    // Todo: use CSS transform instead of setting top and left for better performance\r\n    magnifyToolElement.style.top = `${\r\n      canvasPos[1] - this.configuration.magnifyHeight / 2\r\n    }px`;\r\n    magnifyToolElement.style.left = `${\r\n      canvasPos[0] - this.configuration.magnifyWidth / 2\r\n    }px`;\r\n\r\n    const magnifyViewport = renderingEngine.getViewport(\r\n      MAGNIFY_VIEWPORT_ID\r\n    ) as Types.IStackViewport;\r\n    magnifyViewport.setStack([referencedImageId]).then(() => {\r\n      if (this._hasBeenRemoved) {\r\n        return;\r\n      }\r\n      // match the original viewport voi range\r\n      magnifyViewport.setProperties(viewportProperties);\r\n\r\n      // Use the original viewport for the base for parallelScale\r\n      const { parallelScale } = viewport.getCamera();\r\n\r\n      const { focalPoint, position, viewPlaneNormal } =\r\n        magnifyViewport.getCamera();\r\n\r\n      const distance = Math.sqrt(\r\n        Math.pow(focalPoint[0] - position[0], 2) +\r\n          Math.pow(focalPoint[1] - position[1], 2) +\r\n          Math.pow(focalPoint[2] - position[2], 2)\r\n      );\r\n\r\n      const updatedFocalPoint = <Types.Point3>[\r\n        worldPos[0],\r\n        worldPos[1],\r\n        worldPos[2],\r\n      ];\r\n\r\n      const updatedPosition = <Types.Point3>[\r\n        updatedFocalPoint[0] + distance * viewPlaneNormal[0],\r\n        updatedFocalPoint[1] + distance * viewPlaneNormal[1],\r\n        updatedFocalPoint[2] + distance * viewPlaneNormal[2],\r\n      ];\r\n\r\n      magnifyViewport.setCamera({\r\n        parallelScale: parallelScale * (1 / this.configuration.magnifySize),\r\n        focalPoint: updatedFocalPoint,\r\n        position: updatedPosition,\r\n      });\r\n      magnifyViewport.render();\r\n    });\r\n\r\n    magnifyToolElement.style.display = 'block';\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\r\n    const eventDetail = evt.detail;\r\n\r\n    const { deltaPoints, element, currentPoints } = eventDetail;\r\n    const deltaPointsWorld = deltaPoints.world;\r\n    const canvasPos = currentPoints.canvas;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);\r\n\r\n    const magnifyElement = element.querySelector(\r\n      '.magnifyTool'\r\n    ) as HTMLDivElement;\r\n\r\n    if (!magnifyElement) {\r\n      return;\r\n    }\r\n\r\n    magnifyElement.style.top = `${\r\n      canvasPos[1] - this.configuration.magnifyHeight / 2\r\n    }px`;\r\n    magnifyElement.style.left = `${\r\n      canvasPos[0] - this.configuration.magnifyWidth / 2\r\n    }px`;\r\n\r\n    const { focalPoint, position } = magnifyViewport.getCamera();\r\n\r\n    const updatedPosition = <Types.Point3>[\r\n      position[0] + deltaPointsWorld[0],\r\n      position[1] + deltaPointsWorld[1],\r\n      position[2] + deltaPointsWorld[2],\r\n    ];\r\n\r\n    const updatedFocalPoint = <Types.Point3>[\r\n      focalPoint[0] + deltaPointsWorld[0],\r\n      focalPoint[1] + deltaPointsWorld[1],\r\n      focalPoint[2] + deltaPointsWorld[2],\r\n    ];\r\n\r\n    magnifyViewport.setCamera({\r\n      focalPoint: updatedFocalPoint,\r\n      position: updatedPosition,\r\n    });\r\n\r\n    magnifyViewport.render();\r\n  };\r\n\r\n  _dragEndCallback = (evt: EventTypes.InteractionEventType) => {\r\n    const { element } = evt.detail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    renderingEngine.disableElement(MAGNIFY_VIEWPORT_ID);\r\n\r\n    const viewportElement = element.querySelector('.viewport-element');\r\n\r\n    const magnifyToolElement = viewportElement.querySelector(\r\n      '.magnifyTool'\r\n    ) as HTMLDivElement;\r\n\r\n    viewportElement.removeChild(magnifyToolElement);\r\n\r\n    this._deactivateDraw(element);\r\n    resetElementCursor(element);\r\n    this._hasBeenRemoved = true;\r\n  };\r\n\r\n  _activateDraw = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = true;\r\n    this._hasBeenRemoved = false;\r\n\r\n    element.addEventListener(\r\n      Events.MOUSE_UP,\r\n      this._dragEndCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._dragEndCallback as EventListener\r\n    );\r\n\r\n    element.addEventListener(\r\n      Events.TOUCH_END,\r\n      this._dragEndCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _deactivateDraw = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(\r\n      Events.MOUSE_UP,\r\n      this._dragEndCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._dragEndCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_END,\r\n      this._dragEndCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n  };\r\n}\r\n\r\nMagnifyTool.toolName = 'Magnify';\r\nexport default MagnifyTool;\r\n","import vtkOrientationMarkerWidget from '@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget';\r\nimport vtkAnnotatedCubeActor from '@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor';\r\nimport vtkAxesActor from '@kitware/vtk.js/Rendering/Core/AxesActor';\r\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\r\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\r\nimport vtkXMLPolyDataReader from '@kitware/vtk.js/IO/XML/XMLPolyDataReader';\r\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\r\n\r\nimport { BaseTool } from './base';\r\nimport {\r\n  Enums,\r\n  eventTarget,\r\n  getEnabledElementByIds,\r\n  getRenderingEngines,\r\n} from '@cornerstonejs/core';\r\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\r\nimport { getToolGroup } from '../store/ToolGroupManager';\r\nimport { Events } from '../enums';\r\n\r\nconst OverlayMarkerType = {\r\n  ANNOTATED_CUBE: 1,\r\n  AXES: 2,\r\n  CUSTOM: 3,\r\n};\r\n\r\n/**\r\n * The OrientationMarker is a tool that includes an orientation marker in viewports\r\n * when activated\r\n */\r\nclass OrientationMarkerTool extends BaseTool {\r\n  static toolName;\r\n  static CUBE = 1;\r\n  static AXIS = 2;\r\n  static VTPFILE = 3;\r\n  orientationMarkers;\r\n  polyDataURL;\r\n  _resizeObservers = new Map();\r\n\r\n  static OVERLAY_MARKER_TYPES = OverlayMarkerType;\r\n\r\n  constructor(\r\n    toolProps = {},\r\n    defaultToolProps = {\r\n      configuration: {\r\n        orientationWidget: {\r\n          enabled: true,\r\n          viewportCorner: vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT,\r\n          viewportSize: 0.15,\r\n          minPixelSize: 100,\r\n          maxPixelSize: 300,\r\n        },\r\n        overlayMarkerType:\r\n          OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE,\r\n        overlayConfiguration: {\r\n          [OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE]: {\r\n            faceProperties: {\r\n              xPlus: { text: 'R', faceColor: '#ffff00', faceRotation: 90 },\r\n              xMinus: { text: 'L', faceColor: '#ffff00', faceRotation: 270 },\r\n              yPlus: {\r\n                text: 'P',\r\n                faceColor: '#00ffff',\r\n                fontColor: 'white',\r\n                faceRotation: 180,\r\n              },\r\n              yMinus: { text: 'A', faceColor: '#00ffff', fontColor: 'white' },\r\n              zPlus: { text: 'S' },\r\n              zMinus: { text: 'I' },\r\n            },\r\n            defaultStyle: {\r\n              fontStyle: 'bold',\r\n              fontFamily: 'Arial',\r\n              fontColor: 'black',\r\n              fontSizeScale: (res) => res / 2,\r\n              faceColor: '#0000ff',\r\n              edgeThickness: 0.1,\r\n              edgeColor: 'black',\r\n              resolution: 400,\r\n            },\r\n          },\r\n          [OrientationMarkerTool.OVERLAY_MARKER_TYPES.AXES]: {},\r\n          [OrientationMarkerTool.OVERLAY_MARKER_TYPES.CUSTOM]: {\r\n            polyDataURL:\r\n              'https://raw.githubusercontent.com/Slicer/Slicer/80ad0a04dacf134754459557bf2638c63f3d1d1b/Base/Logic/Resources/OrientationMarkers/Human.vtp',\r\n          },\r\n        },\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n    this.orientationMarkers = {};\r\n  }\r\n\r\n  onSetToolEnabled = (): void => {\r\n    this.initViewports();\r\n    this._subscribeToViewportEvents();\r\n  };\r\n\r\n  onSetToolActive = (): void => {\r\n    this.initViewports();\r\n\r\n    this._subscribeToViewportEvents();\r\n  };\r\n\r\n  onSetToolDisabled = (): void => {\r\n    this.cleanUpData();\r\n    this._unsubscribeToViewportNewVolumeSet();\r\n  };\r\n\r\n  _getViewportsInfo = () => {\r\n    const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\r\n\r\n    return viewports;\r\n  };\r\n\r\n  resize = (viewportId) => {\r\n    const orientationMarker = this.orientationMarkers[viewportId];\r\n    if (!orientationMarker) {\r\n      return;\r\n    }\r\n\r\n    const { orientationWidget } = orientationMarker;\r\n    orientationWidget.updateViewport();\r\n  };\r\n\r\n  _unsubscribeToViewportNewVolumeSet() {\r\n    const unsubscribe = () => {\r\n      const viewportsInfo = this._getViewportsInfo();\r\n      viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\r\n        const { viewport } = getEnabledElementByIds(\r\n          viewportId,\r\n          renderingEngineId\r\n        );\r\n        const { element } = viewport;\r\n\r\n        element.removeEventListener(\r\n          Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\r\n          this.initViewports.bind(this)\r\n        );\r\n\r\n        const resizeObserver = this._resizeObservers.get(viewportId);\r\n        resizeObserver.unobserve(element);\r\n      });\r\n    };\r\n\r\n    eventTarget.removeEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {\r\n      if (evt.detail.toolGroupId !== this.toolGroupId) {\r\n        return;\r\n      }\r\n      unsubscribe();\r\n      this.initViewports();\r\n    });\r\n  }\r\n\r\n  _subscribeToViewportEvents() {\r\n    const subscribeToElementResize = () => {\r\n      const viewportsInfo = this._getViewportsInfo();\r\n      viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\r\n        const { viewport } = getEnabledElementByIds(\r\n          viewportId,\r\n          renderingEngineId\r\n        );\r\n        const { element } = viewport;\r\n        this.initViewports();\r\n\r\n        element.addEventListener(\r\n          Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\r\n          this.initViewports.bind(this)\r\n        );\r\n\r\n        const resizeObserver = new ResizeObserver(() => {\r\n          // Todo: i wish there was a better way to do this\r\n          setTimeout(() => {\r\n            const element = getEnabledElementByIds(\r\n              viewportId,\r\n              renderingEngineId\r\n            );\r\n            if (!element) {\r\n              return;\r\n            }\r\n            const { viewport } = element;\r\n            this.resize(viewportId);\r\n            viewport.render();\r\n          }, 100);\r\n        });\r\n\r\n        resizeObserver.observe(element);\r\n\r\n        this._resizeObservers.set(viewportId, resizeObserver);\r\n      });\r\n    };\r\n\r\n    subscribeToElementResize();\r\n\r\n    eventTarget.addEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {\r\n      if (evt.detail.toolGroupId !== this.toolGroupId) {\r\n        return;\r\n      }\r\n\r\n      subscribeToElementResize();\r\n      this.initViewports();\r\n    });\r\n  }\r\n\r\n  private cleanUpData() {\r\n    const renderingEngines = getRenderingEngines();\r\n    const renderingEngine = renderingEngines[0];\r\n    const viewports = renderingEngine.getViewports();\r\n\r\n    viewports.forEach((viewport) => {\r\n      const orientationMarker = this.orientationMarkers[viewport.id];\r\n      if (!orientationMarker) {\r\n        return;\r\n      }\r\n\r\n      const { actor, orientationWidget } = orientationMarker;\r\n      orientationWidget?.setEnabled(false);\r\n      orientationWidget?.delete();\r\n      actor?.delete();\r\n\r\n      const renderWindow = viewport\r\n        .getRenderingEngine()\r\n        .offscreenMultiRenderWindow.getRenderWindow();\r\n      renderWindow.render();\r\n      viewport.getRenderingEngine().render();\r\n\r\n      delete this.orientationMarkers[viewport.id];\r\n    });\r\n  }\r\n\r\n  private initViewports() {\r\n    const renderingEngines = getRenderingEngines();\r\n    const renderingEngine = renderingEngines[0];\r\n\r\n    if (!renderingEngine) {\r\n      return;\r\n    }\r\n\r\n    let viewports = renderingEngine.getViewports();\r\n    viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\r\n\r\n    viewports.forEach((viewport) => {\r\n      if (!viewport.getWidget(this.getToolName())) {\r\n        this.addAxisActorInViewport(viewport);\r\n      }\r\n    });\r\n  }\r\n\r\n  async addAxisActorInViewport(viewport) {\r\n    const viewportId = viewport.id;\r\n    const type = this.configuration.overlayMarkerType;\r\n\r\n    const overlayConfiguration = this.configuration.overlayConfiguration[type];\r\n\r\n    if (this.orientationMarkers[viewportId]) {\r\n      const { actor, orientationWidget } = this.orientationMarkers[viewportId];\r\n      // remove the previous one\r\n      viewport.getRenderer().removeActor(actor);\r\n      orientationWidget.setEnabled(false);\r\n    }\r\n\r\n    let actor;\r\n    if (type === 1) {\r\n      actor = this.createAnnotationCube(overlayConfiguration);\r\n    } else if (type === 2) {\r\n      actor = vtkAxesActor.newInstance();\r\n    } else if (type === 3) {\r\n      actor = await this.createCustomActor();\r\n    }\r\n\r\n    const renderer = viewport.getRenderer();\r\n    const renderWindow = viewport\r\n      .getRenderingEngine()\r\n      .offscreenMultiRenderWindow.getRenderWindow();\r\n\r\n    const {\r\n      enabled,\r\n      viewportCorner,\r\n      viewportSize,\r\n      minPixelSize,\r\n      maxPixelSize,\r\n    } = this.configuration.orientationWidget;\r\n\r\n    const orientationWidget = vtkOrientationMarkerWidget.newInstance({\r\n      actor,\r\n      interactor: renderWindow.getInteractor(),\r\n      parentRenderer: renderer,\r\n    });\r\n\r\n    orientationWidget.setEnabled(enabled);\r\n    orientationWidget.setViewportCorner(viewportCorner);\r\n    orientationWidget.setViewportSize(viewportSize);\r\n    orientationWidget.setMinPixelSize(minPixelSize);\r\n    orientationWidget.setMaxPixelSize(maxPixelSize);\r\n\r\n    orientationWidget.updateMarkerOrientation();\r\n    this.orientationMarkers[viewportId] = {\r\n      orientationWidget,\r\n      actor,\r\n    };\r\n    viewport.addWidget(this.getToolName(), orientationWidget);\r\n    renderWindow.render();\r\n    viewport.getRenderingEngine().render();\r\n  }\r\n\r\n  private async createCustomActor() {\r\n    const url =\r\n      this.configuration.overlayConfiguration[OverlayMarkerType.CUSTOM]\r\n        .polyDataURL;\r\n\r\n    const response = await fetch(url);\r\n    const arrayBuffer = await response.arrayBuffer();\r\n    const vtpReader = vtkXMLPolyDataReader.newInstance();\r\n    vtpReader.parseAsArrayBuffer(arrayBuffer);\r\n    vtpReader.update();\r\n\r\n    const polyData = vtkPolyData.newInstance();\r\n    polyData.shallowCopy(vtpReader.getOutputData());\r\n    polyData.getPointData().setActiveScalars('Color');\r\n    const mapper = vtkMapper.newInstance();\r\n    mapper.setInputData(polyData);\r\n    mapper.setColorModeToDirectScalars();\r\n\r\n    const actor = vtkActor.newInstance();\r\n    actor.setMapper(mapper);\r\n    actor.rotateZ(180);\r\n    return actor;\r\n  }\r\n\r\n  private createAnnotationCube(overlayConfiguration: any) {\r\n    const actor = vtkAnnotatedCubeActor.newInstance();\r\n    actor.setDefaultStyle({ ...overlayConfiguration.defaultStyle });\r\n    actor.setXPlusFaceProperty({\r\n      ...overlayConfiguration.faceProperties.xPlus,\r\n    });\r\n    actor.setXMinusFaceProperty({\r\n      ...overlayConfiguration.faceProperties.xMinus,\r\n    });\r\n    actor.setYPlusFaceProperty({\r\n      ...overlayConfiguration.faceProperties.yPlus,\r\n    });\r\n    actor.setYMinusFaceProperty({\r\n      ...overlayConfiguration.faceProperties.yMinus,\r\n    });\r\n    actor.setZPlusFaceProperty({\r\n      ...overlayConfiguration.faceProperties.zPlus,\r\n    });\r\n    actor.setZMinusFaceProperty({\r\n      ...overlayConfiguration.faceProperties.zMinus,\r\n    });\r\n    return actor;\r\n  }\r\n\r\n  async createAnnotatedCubeActor() {\r\n    const axes = vtkAnnotatedCubeActor.newInstance();\r\n    const { faceProperties, defaultStyle } = this.configuration.annotatedCube;\r\n\r\n    axes.setDefaultStyle(defaultStyle);\r\n\r\n    Object.keys(faceProperties).forEach((key) => {\r\n      const methodName = `set${\r\n        key.charAt(0).toUpperCase() + key.slice(1)\r\n      }FaceProperty`;\r\n      axes[methodName](faceProperties[key]);\r\n    });\r\n\r\n    return axes;\r\n  }\r\n}\r\n\r\nOrientationMarkerTool.toolName = 'OrientationMarker';\r\nexport default OrientationMarkerTool;\r\n","import { vec3 } from 'gl-matrix';\r\nimport {\r\n  metaData,\r\n  CONSTANTS,\r\n  getRenderingEngine,\r\n  utilities as csUtils,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport {\r\n  addAnnotation,\r\n  getAnnotations,\r\n} from '../stateManagement/annotation/annotationState';\r\n\r\nimport { getToolGroup } from '../store/ToolGroupManager';\r\n\r\nimport { drawLine as drawLineSvg } from '../drawingSvg';\r\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\r\n\r\nimport {\r\n  PublicToolProps,\r\n  ToolProps,\r\n  SVGDrawingHelper,\r\n  Annotation,\r\n} from '../types';\r\nimport { StyleSpecifier } from '../types/AnnotationStyle';\r\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\r\n\r\nconst { EPSILON } = CONSTANTS;\r\n\r\nexport interface OverlayGridAnnotation extends Annotation {\r\n  data: {\r\n    viewportData: Map<string, object>;\r\n    pointSets: Array<object>;\r\n  };\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nclass OverlayGridTool extends AnnotationDisplayTool {\r\n  static toolName;\r\n\r\n  public touchDragCallback: any;\r\n  public mouseDragCallback: any;\r\n  _throttledCalculateCachedStats: any;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        sourceImageIds: [],\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  onSetToolEnabled = (): void => {\r\n    this._init();\r\n  };\r\n\r\n  onSetToolActive = (): void => {\r\n    this._init();\r\n  };\r\n\r\n  _init = (): void => {\r\n    const sourceImageIds = this.configuration.sourceImageIds;\r\n    if (!sourceImageIds?.length) {\r\n      console.warn(\r\n        'OverlayGridTool: No sourceImageIds provided in configuration'\r\n      );\r\n      return;\r\n    }\r\n\r\n    const imagePlaneModule = metaData.get(\r\n      'imagePlaneModule',\r\n      sourceImageIds[0]\r\n    );\r\n\r\n    if (!imagePlaneModule) {\r\n      console.warn(\r\n        'OverlayGridTool: No imagePlaneModule found for sourceImageIds'\r\n      );\r\n      return;\r\n    }\r\n\r\n    const { frameOfReferenceUID } = imagePlaneModule;\r\n\r\n    const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\r\n\r\n    if (!viewportsInfo?.length) {\r\n      console.warn('OverlayGridTool: No viewports found');\r\n      return;\r\n    }\r\n\r\n    const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\r\n\r\n    if (!annotations?.length) {\r\n      const pointSets = sourceImageIds.map((id) => {\r\n        // check if pointSets for the imageId was calculated. If not calculate and store\r\n        return this.calculateImageIdPointSets(id);\r\n      });\r\n\r\n      const newAnnotation: OverlayGridAnnotation = {\r\n        highlighted: true,\r\n        invalidated: true,\r\n        metadata: {\r\n          toolName: this.getToolName(),\r\n          FrameOfReferenceUID: frameOfReferenceUID,\r\n          referencedImageId: null,\r\n        },\r\n        data: {\r\n          viewportData: new Map(),\r\n          pointSets,\r\n        },\r\n      };\r\n\r\n      addAnnotation(newAnnotation, frameOfReferenceUID);\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(\r\n      getRenderingEngine(viewportsInfo[0].renderingEngineId),\r\n      viewportsInfo.map(({ viewportId }) => viewportId)\r\n    );\r\n  };\r\n\r\n  /**\r\n   * Calculates the point sets based on the image corners relative to an imageId\r\n   * @param imageId - The imageId to calculate the point sets for\r\n   * @returns\r\n   */\r\n  calculateImageIdPointSets = (imageId: string) => {\r\n    const {\r\n      imagePositionPatient,\r\n      rows,\r\n      columns,\r\n      rowCosines,\r\n      columnCosines,\r\n      rowPixelSpacing,\r\n      columnPixelSpacing,\r\n    } = metaData.get('imagePlaneModule', imageId);\r\n\r\n    // top left world, top right world, bottom right world, bottom left world\r\n    const topLeft = <Types.Point3>[...imagePositionPatient];\r\n    const topRight = <Types.Point3>[...imagePositionPatient];\r\n    const bottomLeft = <Types.Point3>[...imagePositionPatient];\r\n    const bottomRight = <Types.Point3>[...imagePositionPatient];\r\n\r\n    vec3.scaleAndAdd(\r\n      topRight,\r\n      imagePositionPatient,\r\n      columnCosines,\r\n      columns * columnPixelSpacing\r\n    );\r\n    vec3.scaleAndAdd(\r\n      bottomLeft,\r\n      imagePositionPatient,\r\n      rowCosines,\r\n      rows * rowPixelSpacing\r\n    );\r\n\r\n    vec3.scaleAndAdd(\r\n      bottomRight,\r\n      bottomLeft,\r\n      columnCosines,\r\n      columns * columnPixelSpacing\r\n    );\r\n\r\n    // check if the topLeft and bottomLeft line is parallel to the viewUp\r\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\r\n    const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\r\n\r\n    return { pointSet1, pointSet2 };\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the length annotation in each\r\n   * request animation frame. It calculates the updated cached statistics if\r\n   * data is invalidated and cache it.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    const sourceImageIds = this.configuration.sourceImageIds;\r\n\r\n    let renderStatus = false;\r\n    if (!sourceImageIds?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const { viewport: targetViewport, FrameOfReferenceUID } = enabledElement;\r\n    const targetImageIds = targetViewport.getImageIds();\r\n    if (targetImageIds.length < 2) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n    const annotation = annotations[0];\r\n    const { annotationUID } = annotation;\r\n\r\n    const { focalPoint, viewPlaneNormal } = targetViewport.getCamera();\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n    const imageIdNormal = <Types.Point3>(\r\n      this.getImageIdNormal(sourceImageIds[0])\r\n    );\r\n\r\n    if (this.isParallel(viewPlaneNormal, imageIdNormal)) {\r\n      // If the source and target viewports are parallel, we don't need to render\r\n      return renderStatus;\r\n    }\r\n\r\n    const targetViewportPlane = csUtils.planar.planeEquation(\r\n      viewPlaneNormal,\r\n      focalPoint\r\n    );\r\n\r\n    const pointSets = annotation.data.pointSets;\r\n    const viewportData = annotation.data.viewportData;\r\n    for (let i = 0; i < sourceImageIds.length; i++) {\r\n      // check if pointSets for the imageId was calculated. If not calculate and store\r\n      const { pointSet1, pointSet2 } = pointSets[i];\r\n\r\n      const targetData =\r\n        viewportData.get(targetViewport.id) ||\r\n        this.initializeViewportData(viewportData, targetViewport.id);\r\n\r\n      // check if pointSetToUse was calculated. If not calculate and store\r\n      if (!targetData.pointSetsToUse[i]) {\r\n        let pointSetToUse = pointSet1;\r\n\r\n        let topBottomVec = vec3.subtract(\r\n          vec3.create(),\r\n          pointSet1[0],\r\n          pointSet1[1]\r\n        );\r\n        topBottomVec = vec3.normalize(\r\n          vec3.create(),\r\n          topBottomVec\r\n        ) as Types.Point3;\r\n\r\n        // check if it is perpendicular to the viewPlaneNormal which means\r\n        // the line does not intersect the viewPlaneNormal\r\n        if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\r\n          // 'use pointSet2';\r\n          pointSetToUse = pointSet2;\r\n        }\r\n\r\n        targetData.pointSetsToUse[i] = pointSetToUse;\r\n\r\n        targetData.lineStartsWorld[i] = csUtils.planar.linePlaneIntersection(\r\n          pointSetToUse[0],\r\n          pointSetToUse[1],\r\n          targetViewportPlane\r\n        );\r\n\r\n        targetData.lineEndsWorld[i] = csUtils.planar.linePlaneIntersection(\r\n          pointSetToUse[2],\r\n          pointSetToUse[3],\r\n          targetViewportPlane\r\n        );\r\n      }\r\n\r\n      const lineStartWorld = targetData.lineStartsWorld[i];\r\n      const lineEndWorld = targetData.lineEndsWorld[i];\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\r\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\r\n      const color = this.getStyle('color', styleSpecifier, annotation);\r\n      const shadow = this.getStyle('shadow', styleSpecifier, annotation);\r\n\r\n      const canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) =>\r\n        targetViewport.worldToCanvas(world)\r\n      );\r\n\r\n      const dataId = `${annotationUID}-line`;\r\n      const lineUID = `${i}`;\r\n      drawLineSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        lineUID,\r\n        canvasCoordinates[0],\r\n        canvasCoordinates[1],\r\n        {\r\n          color,\r\n          width: lineWidth,\r\n          lineDash,\r\n          shadow,\r\n        },\r\n        dataId\r\n      );\r\n    }\r\n\r\n    renderStatus = true;\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  private initializeViewportData = (viewportData, id) => {\r\n    viewportData.set(id, {\r\n      pointSetsToUse: [],\r\n      lineStartsWorld: [],\r\n      lineEndsWorld: [],\r\n    });\r\n\r\n    return viewportData.get(id);\r\n  };\r\n\r\n  private isPerpendicular = (\r\n    vec1: Types.Point3,\r\n    vec2: Types.Point3\r\n  ): boolean => {\r\n    const dot = vec3.dot(vec1, vec2);\r\n    return Math.abs(dot) < EPSILON;\r\n  };\r\n\r\n  private isParallel(vec1: Types.Point3, vec2: Types.Point3): boolean {\r\n    return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\r\n  }\r\n\r\n  private getImageIdNormal(imageId: string): vec3 {\r\n    const { imageOrientationPatient } = metaData.get(\r\n      'imagePlaneModule',\r\n      imageId\r\n    );\r\n    const rowCosineVec = vec3.fromValues(\r\n      imageOrientationPatient[0],\r\n      imageOrientationPatient[1],\r\n      imageOrientationPatient[2]\r\n    );\r\n    const colCosineVec = vec3.fromValues(\r\n      imageOrientationPatient[3],\r\n      imageOrientationPatient[4],\r\n      imageOrientationPatient[5]\r\n    );\r\n    return vec3.cross(vec3.create(), rowCosineVec, colCosineVec);\r\n  }\r\n}\r\n\r\nOverlayGridTool.toolName = 'OverlayGrid';\r\nexport default OverlayGridTool;\r\n","import { BaseTool } from './base';\r\nimport { getEnabledElement } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\r\n\r\n/**\r\n * Tool that pans the camera in the plane defined by the viewPlaneNormal and the viewUp.\r\n */\r\nclass PanTool extends BaseTool {\r\n  static toolName;\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\r\n    this._dragCallback(evt);\r\n  }\r\n\r\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\r\n    this._dragCallback(evt);\r\n  }\r\n\r\n  _dragCallback(evt: EventTypes.InteractionEventType) {\r\n    const { element, deltaPoints } = evt.detail;\r\n    const enabledElement = getEnabledElement(element);\r\n\r\n    const deltaPointsWorld = deltaPoints.world;\r\n    // This occurs when the mouse event is fired but the mouse hasn't moved a full pixel yet (high resolution mice)\r\n    if (\r\n      deltaPointsWorld[0] === 0 &&\r\n      deltaPointsWorld[1] === 0 &&\r\n      deltaPointsWorld[2] === 0\r\n    ) {\r\n      return;\r\n    }\r\n    const camera = enabledElement.viewport.getCamera();\r\n    const { focalPoint, position } = camera;\r\n\r\n    const updatedPosition = <Types.Point3>[\r\n      position[0] - deltaPointsWorld[0],\r\n      position[1] - deltaPointsWorld[1],\r\n      position[2] - deltaPointsWorld[2],\r\n    ];\r\n\r\n    const updatedFocalPoint = <Types.Point3>[\r\n      focalPoint[0] - deltaPointsWorld[0],\r\n      focalPoint[1] - deltaPointsWorld[1],\r\n      focalPoint[2] - deltaPointsWorld[2],\r\n    ];\r\n\r\n    enabledElement.viewport.setCamera({\r\n      focalPoint: updatedFocalPoint,\r\n      position: updatedPosition,\r\n    });\r\n    enabledElement.viewport.render();\r\n  }\r\n}\r\n\r\nPanTool.toolName = 'Pan';\r\nexport default PanTool;\r\n","import {\r\n  BaseVolumeViewport,\r\n  getEnabledElement,\r\n  Types,\r\n} from '@cornerstonejs/core';\r\nimport { mat4, vec3 } from 'gl-matrix';\r\nimport { BaseTool } from './base';\r\nimport angleBetweenLines from '../utilities/math/angle/angleBetweenLines';\r\nimport { PublicToolProps, ToolProps, EventTypes } from '../types';\r\n\r\n/**\r\n * The PlanarRotateTool is a tool that allows the user to rotate\r\n * the image by pressing the mouse click and dragging\r\n */\r\nclass PlanarRotateTool extends BaseTool {\r\n  static toolName;\r\n  touchDragCallback: (evt: EventTypes.MouseDragEventType) => void;\r\n  mouseDragCallback: (evt: EventTypes.MouseDragEventType) => void;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n\r\n    this.touchDragCallback = this._dragCallback.bind(this);\r\n    this.mouseDragCallback = this._dragCallback.bind(this);\r\n  }\r\n\r\n  _dragCallback(evt: EventTypes.MouseDragEventType) {\r\n    const { element, currentPoints, startPoints } = evt.detail;\r\n    const currentPointWorld = currentPoints.world;\r\n    const startPointWorld = startPoints.world;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const camera = viewport.getCamera();\r\n    const width = element.clientWidth;\r\n    const height = element.clientHeight;\r\n\r\n    const centerCanvas: Types.Point2 = [width * 0.5, height * 0.5];\r\n    const centerWorld = viewport.canvasToWorld(centerCanvas);\r\n\r\n    let angle = angleBetweenLines(\r\n      [startPointWorld, centerWorld],\r\n      [centerWorld, currentPointWorld]\r\n    );\r\n\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    const v1 = vec3.sub(vec3.create(), centerWorld, startPointWorld);\r\n    const v2 = vec3.sub(vec3.create(), centerWorld, currentPointWorld);\r\n    const cross = vec3.cross(vec3.create(), v1, v2);\r\n    if (vec3.dot(viewPlaneNormal, cross) > 0) {\r\n      angle = -angle;\r\n    }\r\n\r\n    if (Number.isNaN(angle)) {\r\n      return;\r\n    }\r\n\r\n    if (viewport instanceof BaseVolumeViewport) {\r\n      const rotAngle = (angle * Math.PI) / 180;\r\n      const rotMat = mat4.identity(new Float32Array(16));\r\n      mat4.rotate(rotMat, rotMat, rotAngle, viewPlaneNormal);\r\n      const rotatedViewUp = vec3.transformMat4(vec3.create(), viewUp, rotMat);\r\n      viewport.setCamera({ viewUp: rotatedViewUp as Types.Point3 });\r\n    } else {\r\n      const { rotation } = (viewport as Types.IStackViewport).getProperties();\r\n      viewport.setProperties({ rotation: rotation + angle });\r\n    }\r\n\r\n    viewport.render();\r\n  }\r\n}\r\n\r\nPlanarRotateTool.toolName = 'PlanarRotate';\r\nexport default PlanarRotateTool;\r\n","import {\r\n  getEnabledElement,\r\n  StackViewport,\r\n  VolumeViewport,\r\n  utilities,\r\n  getEnabledElementByIds,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport {\r\n  addAnnotation,\r\n  getAnnotations,\r\n} from '../stateManagement/annotation/annotationState';\r\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\r\nimport { drawLine } from '../drawingSvg';\r\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\r\nimport {\r\n  EventTypes,\r\n  PublicToolProps,\r\n  ToolProps,\r\n  SVGDrawingHelper,\r\n  Annotation,\r\n  Annotations,\r\n} from '../types';\r\nimport { ReferenceCursor } from '../types/ToolSpecificAnnotationTypes';\r\n\r\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\r\nimport { StyleSpecifier } from '../types/AnnotationStyle';\r\nimport { vec3 } from 'gl-matrix';\r\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\r\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\r\nimport {\r\n  hideElementCursor,\r\n  resetElementCursor,\r\n} from '../cursors/elementCursor';\r\nimport { getToolGroup } from '../store/ToolGroupManager';\r\n\r\n/**\r\n * ReferenceCursors is a tool that will show your cursors position in all other elements in the toolGroup if they have a matching FrameOfReference relative to its position in world space.\r\n * Also when positionSync is enabled, it will try to sync viewports so that the cursor can be displayed in the correct position in all viewports.\r\n *\r\n * Configuration:\r\n * - positionSync: boolean, if true, it will try to sync viewports so that the cursor can be displayed in the correct position in all viewports.\r\n * - disableCursor: boolean, if true, it will hide the cursor in all viewports. You need to disable and reactivate the tool for this to apply.\r\n * - displayThreshold: number, if the distance of the cursor in a viewport is bigger than this threshold the cursor will not be displayed.\r\n *\r\n * Only uses Active and Disabled state\r\n */\r\nclass ReferenceCursors extends AnnotationDisplayTool {\r\n  static toolName;\r\n  touchDragCallback: any;\r\n  mouseDragCallback: any;\r\n  _throttledCalculateCachedStats: any;\r\n  isDrawing = false;\r\n  isHandleOutsideImage = false;\r\n  _elementWithCursor: null | HTMLDivElement = null;\r\n  _currentCursorWorldPosition: null | Types.Point3 = null;\r\n  _currentCanvasPosition: null | Types.Point2 = null;\r\n  //need to keep track if this was enabled when tool was enabled because we need to know if we should reset cursors\r\n  _disableCursorEnabled = false;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        shadow: true,\r\n        preventHandleOutsideImage: false,\r\n        displayThreshold: 5,\r\n        positionSync: true,\r\n        disableCursor: false,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n    this._disableCursorEnabled = this.configuration.disableCursor;\r\n  }\r\n\r\n  /**\r\n   * Overwritten mouseMoveCallback since we want to keep track of the current mouse position and redraw on mouseMove\r\n   * @virtual Event handler for Cornerstone MOUSE_MOVE event.\r\n   *\r\n   *\r\n   * @param evt - The normalized mouse event\r\n   * @param filteredAnnotations - The annotations to check for hover interactions\r\n   * @returns True if the annotation needs to be re-drawn by the annotationRenderingEngine.\r\n   */\r\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): boolean => {\r\n    const { detail } = evt;\r\n    const { element, currentPoints } = detail;\r\n\r\n    //save current positions and current element the curser is hovering over\r\n    this._currentCursorWorldPosition = currentPoints.world;\r\n    this._currentCanvasPosition = currentPoints.canvas;\r\n    this._elementWithCursor = element;\r\n\r\n    const annotation = this.getActiveAnnotation(element);\r\n    if (annotation === null) {\r\n      this.createInitialAnnotation(currentPoints.world, element);\r\n      return false;\r\n    }\r\n    this.updateAnnotationPosition(element, annotation);\r\n    return false;\r\n  };\r\n\r\n  onSetToolActive(): void {\r\n    this._disableCursorEnabled = this.configuration.disableCursor;\r\n    if (!this._disableCursorEnabled) {\r\n      return;\r\n    }\r\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\r\n    if (!viewportIds) {\r\n      return;\r\n    }\r\n    const enabledElements = viewportIds.map((e) =>\r\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\r\n    );\r\n\r\n    enabledElements.forEach((element) => {\r\n      if (element) {\r\n        hideElementCursor(element.viewport.element);\r\n      }\r\n    });\r\n  }\r\n  onSetToolDisabled(): void {\r\n    if (!this._disableCursorEnabled) {\r\n      return;\r\n    }\r\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\r\n    if (!viewportIds) {\r\n      return;\r\n    }\r\n    const enabledElements = viewportIds.map((e) =>\r\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\r\n    );\r\n    enabledElements.forEach((element) => {\r\n      if (element) {\r\n        resetElementCursor(element.viewport.element);\r\n      }\r\n    });\r\n  }\r\n\r\n  createInitialAnnotation = (\r\n    worldPos: Types.Point3,\r\n    element: HTMLDivElement\r\n  ): void => {\r\n    const enabledElement = getEnabledElement(element);\r\n    if (!enabledElement) {\r\n      throw new Error('No enabled element found');\r\n    }\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n    if (!viewPlaneNormal || !viewUp) {\r\n      throw new Error('Camera not found');\r\n    }\r\n\r\n    const referencedImageId = this.getReferencedImageId(\r\n      viewport,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      viewUp\r\n    );\r\n\r\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n\r\n    const annotation = {\r\n      highlighted: true,\r\n      invalidated: true,\r\n      metadata: {\r\n        toolName: this.getToolName(),\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID,\r\n        referencedImageId,\r\n      },\r\n      data: {\r\n        label: '',\r\n        handles: {\r\n          points: [[...worldPos]] as [Types.Point3],\r\n          activeHandleIndex: null,\r\n          textBox: {\r\n            hasMoved: false,\r\n            worldPosition: <Types.Point3>[0, 0, 0],\r\n            worldBoundingBox: {\r\n              topLeft: <Types.Point3>[0, 0, 0],\r\n              topRight: <Types.Point3>[0, 0, 0],\r\n              bottomLeft: <Types.Point3>[0, 0, 0],\r\n              bottomRight: <Types.Point3>[0, 0, 0],\r\n            },\r\n          },\r\n        },\r\n      },\r\n    };\r\n\r\n    const annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    if (annotations.length > 0) {\r\n      return null;\r\n    }\r\n    const annotationId = addAnnotation(annotation, element);\r\n\r\n    if (annotationId === null) {\r\n      return;\r\n    }\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName(),\r\n      false\r\n    );\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  getActiveAnnotation(element: HTMLDivElement): null | Annotation {\r\n    const annotations = getAnnotations(this.getToolName(), element);\r\n    if (!annotations.length) {\r\n      return null;\r\n    }\r\n    const targetAnnotation = annotations[0];\r\n    return targetAnnotation;\r\n  }\r\n\r\n  /**\r\n   * updates the position of the annotation to match the currently set world position\r\n   */\r\n  updateAnnotationPosition(\r\n    element: HTMLDivElement,\r\n    annotation: Annotation\r\n  ): void {\r\n    const worldPos = this._currentCursorWorldPosition;\r\n    if (!worldPos) {\r\n      return;\r\n    }\r\n    if (!annotation.data?.handles?.points) {\r\n      return;\r\n    }\r\n    annotation.data.handles.points = [[...worldPos]];\r\n    annotation.invalidated = true;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName(),\r\n      false\r\n    );\r\n    const enabledElement = getEnabledElement(element);\r\n    if (!enabledElement) {\r\n      return;\r\n    }\r\n    const { renderingEngine } = enabledElement;\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  }\r\n\r\n  //checks if we need to update the annotation position due to camera changes\r\n  onCameraModified = (evt: any): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element, previousCamera, camera } = eventDetail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const viewport = enabledElement.viewport as\r\n      | Types.IVolumeViewport\r\n      | Types.IStackViewport;\r\n\r\n    //only react to changes for element with cursor, otherwise would cause infinite loop\r\n    if (element !== this._elementWithCursor) {\r\n      return;\r\n    }\r\n    //check if camera moved along its normal\r\n    const oldFocalPoint = previousCamera.focalPoint;\r\n    const cameraNormal = camera.viewPlaneNormal;\r\n    const newFocalPoint = camera.focalPoint;\r\n\r\n    const deltaCameraFocalPoint: Types.Point3 = [0, 0, 0];\r\n    vtkMath.subtract(newFocalPoint, oldFocalPoint, deltaCameraFocalPoint);\r\n    //check if focal point changed\r\n    if (deltaCameraFocalPoint.reduce((a, b) => a + b, 0) === 0) {\r\n      return;\r\n    }\r\n    //if nomrmal is perpendicular to focal point change, then we are not moving along the normal\r\n    const dotProduct = vtkMath.dot(deltaCameraFocalPoint, cameraNormal);\r\n    //dot product is 0 -> perpendicular\r\n    if (Math.abs(dotProduct) < 1e-2) {\r\n      return;\r\n    }\r\n\r\n    //need to update the position of the annotation since camera changed\r\n    if (!this._currentCanvasPosition) {\r\n      return;\r\n    }\r\n\r\n    const newWorldPos = viewport.canvasToWorld(this._currentCanvasPosition);\r\n    this._currentCursorWorldPosition = newWorldPos;\r\n    this.updateAnnotationPosition(element, this.getActiveAnnotation(element));\r\n  };\r\n\r\n  //display annotation if current viewing plane has a max distance of \"displayThreshold\" from the annotation\r\n  filterInteractableAnnotationsForElement(\r\n    element: HTMLDivElement,\r\n    annotations: Annotations\r\n  ): Annotations {\r\n    //calculate distance of current viewport to annotation\r\n    if (!(annotations instanceof Array) || annotations.length === 0) {\r\n      return [];\r\n    }\r\n    const annotation = annotations[0];\r\n    const viewport = getEnabledElement(element)?.viewport;\r\n    if (!viewport) {\r\n      return [];\r\n    }\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, focalPoint } = camera;\r\n    if (!viewPlaneNormal || !focalPoint) {\r\n      return [];\r\n    }\r\n    const points = annotation.data?.handles?.points;\r\n    if (!(points instanceof Array) || points.length !== 1) {\r\n      return [];\r\n    }\r\n    const worldPos = points[0];\r\n    const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\r\n    const distance = utilities.planar.planeDistanceToPoint(plane, worldPos);\r\n    return distance < this.configuration.displayThreshold ? [annotation] : [];\r\n  }\r\n\r\n  /**\r\n   * Draws the cursor representation on the enabledElement\r\n   * Checks if a stack change has happened and updates annotation in that case\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n    const { viewport, FrameOfReferenceUID } = enabledElement;\r\n\r\n    const isElementWithCursor = this._elementWithCursor === viewport.element;\r\n\r\n    //update stack position if position sync is enabled\r\n    if (this.configuration.positionSync && !isElementWithCursor) {\r\n      this.updateViewportImage(viewport);\r\n    }\r\n\r\n    const { element } = viewport;\r\n\r\n    let annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    //the viewport change from updateStackPosition might not be applied yet, so sometimes the annotation might not be immediately visible\r\n    annotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    ) as Annotations;\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[i] as ReferenceCursor;\r\n      const { annotationUID, data } = annotation;\r\n      const { handles } = data;\r\n      const { points } = handles;\r\n\r\n      if (!annotationUID) {\r\n        return renderStatus;\r\n      }\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const lineWidthBase = parseFloat(\r\n        this.getStyle('lineWidth', styleSpecifier, annotation) as string\r\n      );\r\n\r\n      const lineWidth =\r\n        typeof lineWidthBase === 'number' && isElementWithCursor\r\n          ? lineWidthBase\r\n          : lineWidthBase;\r\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\r\n      const color = this.getStyle('color', styleSpecifier, annotation);\r\n\r\n      if (points[0].some((e) => isNaN(e))) {\r\n        return renderStatus;\r\n      }\r\n      const canvasCoordinates = points.map((p) =>\r\n        viewport.worldToCanvas(p)\r\n      ) as [Types.Point2];\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n\r\n      if (!isAnnotationVisible(annotationUID)) {\r\n        continue;\r\n      }\r\n\r\n      const crosshairUIDs = {\r\n        upper: 'upper',\r\n        right: 'right',\r\n        lower: 'lower',\r\n        left: 'left',\r\n      };\r\n      const [x, y] = canvasCoordinates[0];\r\n      const centerSpace = isElementWithCursor ? 20 : 7;\r\n      const lineLength = isElementWithCursor ? 5 : 7;\r\n      drawLine(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        crosshairUIDs.upper,\r\n        [x, y - (centerSpace / 2 + lineLength)],\r\n        [x, y - centerSpace / 2],\r\n        { color, lineDash, lineWidth }\r\n      );\r\n      drawLine(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        crosshairUIDs.lower,\r\n        [x, y + (centerSpace / 2 + lineLength)],\r\n        [x, y + centerSpace / 2],\r\n        { color, lineDash, lineWidth }\r\n      );\r\n      drawLine(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        crosshairUIDs.right,\r\n        [x + (centerSpace / 2 + lineLength), y],\r\n        [x + centerSpace / 2, y],\r\n        { color, lineDash, lineWidth }\r\n      );\r\n      drawLine(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        crosshairUIDs.left,\r\n        [x - (centerSpace / 2 + lineLength), y],\r\n        [x - centerSpace / 2, y],\r\n        { color, lineDash, lineWidth }\r\n      );\r\n      renderStatus = true;\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  updateViewportImage(\r\n    viewport: Types.IStackViewport | Types.IVolumeViewport\r\n  ): void {\r\n    const currentMousePosition = this._currentCursorWorldPosition;\r\n\r\n    if (!currentMousePosition || currentMousePosition.some((e) => isNaN(e))) {\r\n      return;\r\n    }\r\n\r\n    if (viewport instanceof StackViewport) {\r\n      const closestIndex = utilities.getClosestStackImageIndexForPoint(\r\n        currentMousePosition,\r\n        viewport\r\n      );\r\n\r\n      if (closestIndex === null) {\r\n        return;\r\n      }\r\n      if (closestIndex !== viewport.getCurrentImageIdIndex()) {\r\n        viewport.setImageIdIndex(closestIndex);\r\n      }\r\n    } else if (viewport instanceof VolumeViewport) {\r\n      const { focalPoint, viewPlaneNormal } = viewport.getCamera();\r\n      if (!focalPoint || !viewPlaneNormal) {\r\n        return;\r\n      }\r\n      const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\r\n      const currentDistance = utilities.planar.planeDistanceToPoint(\r\n        plane,\r\n        currentMousePosition,\r\n        true\r\n      );\r\n\r\n      if (Math.abs(currentDistance) < 0.5) {\r\n        return;\r\n      }\r\n      const normalizedViewPlane = vec3.normalize(\r\n        vec3.create(),\r\n        vec3.fromValues(...viewPlaneNormal)\r\n      );\r\n      const scaledPlaneNormal = vec3.scale(\r\n        vec3.create(),\r\n        normalizedViewPlane,\r\n        currentDistance\r\n      );\r\n      const newFocalPoint = vec3.add(\r\n        vec3.create(),\r\n        vec3.fromValues(...focalPoint),\r\n        scaledPlaneNormal\r\n      ) as Types.Point3;\r\n      //TODO: make check if new focal point is within bounds of volume\r\n      const isInBounds = true;\r\n      if (isInBounds) {\r\n        viewport.setCamera({ focalPoint: newFocalPoint });\r\n        const renderingEngine = viewport.getRenderingEngine();\r\n        if (renderingEngine) {\r\n          renderingEngine.renderViewport(viewport.id);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nReferenceCursors.toolName = 'ReferenceCursors';\r\nexport default ReferenceCursors;\r\n","import { vec3 } from 'gl-matrix';\r\nimport {\r\n  getRenderingEngines,\r\n  CONSTANTS,\r\n  utilities as csUtils,\r\n} from '@cornerstonejs/core';\r\nimport { type Types, getEnabledElementByViewportId } from '@cornerstonejs/core';\r\n\r\nimport { addAnnotation } from '../stateManagement/annotation/annotationState';\r\n\r\nimport { drawLine as drawLineSvg } from '../drawingSvg';\r\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\r\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\r\nimport { PublicToolProps, ToolProps, SVGDrawingHelper } from '../types';\r\nimport { ReferenceLineAnnotation } from '../types/ToolSpecificAnnotationTypes';\r\nimport { StyleSpecifier } from '../types/AnnotationStyle';\r\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\r\n\r\nconst { EPSILON } = CONSTANTS;\r\n\r\n/**\r\n * @public\r\n */\r\nclass ReferenceLines extends AnnotationDisplayTool {\r\n  static toolName;\r\n\r\n  public touchDragCallback: any;\r\n  public mouseDragCallback: any;\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    renderingEngine: any;\r\n    sourceViewportId: string;\r\n    annotation: ReferenceLineAnnotation;\r\n  } | null = {} as any;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        sourceViewportId: '',\r\n        showFullDimension: false,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n\r\n    // this._throttledCalculateCachedStats = throttle(\r\n    //   this._calculateCachedStats,\r\n    //   100,\r\n    //   { trailing: true }\r\n    // );\r\n  }\r\n\r\n  _init = (): void => {\r\n    const renderingEngines = getRenderingEngines();\r\n    const renderingEngine = renderingEngines[0];\r\n\r\n    // Todo: handle this case where it is too soon to get the rendering engine\r\n    if (!renderingEngine) {\r\n      return;\r\n    }\r\n\r\n    let viewports = renderingEngine.getViewports();\r\n    viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\r\n\r\n    const sourceViewport = renderingEngine.getViewport(\r\n      this.configuration.sourceViewportId\r\n    ) as Types.IVolumeViewport;\r\n\r\n    if (!sourceViewport?.getImageData()) {\r\n      return;\r\n    }\r\n\r\n    const { element } = sourceViewport;\r\n    const { viewUp, viewPlaneNormal } = sourceViewport.getCamera();\r\n\r\n    const sourceViewportCanvasCornersInWorld =\r\n      csUtils.getViewportImageCornersInWorld(sourceViewport);\r\n\r\n    let annotation = this.editData.annotation;\r\n    const FrameOfReferenceUID = sourceViewport.getFrameOfReferenceUID();\r\n\r\n    if (!annotation) {\r\n      const newAnnotation: ReferenceLineAnnotation = {\r\n        highlighted: true,\r\n        invalidated: true,\r\n        metadata: {\r\n          toolName: this.getToolName(),\r\n          viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n          viewUp: <Types.Point3>[...viewUp],\r\n          FrameOfReferenceUID,\r\n          referencedImageId: null,\r\n        },\r\n        data: {\r\n          handles: {\r\n            points: sourceViewportCanvasCornersInWorld,\r\n          },\r\n        },\r\n      };\r\n\r\n      addAnnotation(newAnnotation, element);\r\n      annotation = newAnnotation;\r\n    } else {\r\n      this.editData.annotation.data.handles.points =\r\n        sourceViewportCanvasCornersInWorld;\r\n    }\r\n\r\n    this.editData = {\r\n      sourceViewportId: sourceViewport.id,\r\n      renderingEngine,\r\n      annotation,\r\n    };\r\n\r\n    triggerAnnotationRenderForViewportIds(\r\n      renderingEngine,\r\n      viewports\r\n        .filter((viewport) => viewport.id !== sourceViewport.id)\r\n        .map((viewport) => viewport.id)\r\n    );\r\n  };\r\n\r\n  onSetToolEnabled = (): void => {\r\n    this._init();\r\n  };\r\n\r\n  onSetToolConfiguration = (): void => {\r\n    this._init();\r\n  };\r\n\r\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\r\n    // If the camera is modified, we need to update the reference lines\r\n    // we really don't care which viewport triggered the\r\n    // camera modification, since we want to update all of them\r\n    // with respect to the targetViewport\r\n    this._init();\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the length annotation in each\r\n   * request animation frame. It calculates the updated cached statistics if\r\n   * data is invalidated and cache it.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    const { viewport: targetViewport } = enabledElement;\r\n    const { annotation, sourceViewportId } = this.editData;\r\n\r\n    let renderStatus = false;\r\n\r\n    // we need to grab the viewport again since there might have been\r\n    // a change in the viewport state since the last time we cached it\r\n    const { viewport: sourceViewport } =\r\n      getEnabledElementByViewportId(sourceViewportId) || {};\r\n\r\n    if (!sourceViewport) {\r\n      return renderStatus;\r\n    }\r\n\r\n    if (sourceViewport.id === targetViewport.id) {\r\n      // If the source viewport is the same as the current viewport, we don't need to render\r\n      return renderStatus;\r\n    }\r\n\r\n    if (!annotation || !annotation?.data?.handles?.points) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    // top left world, top right world, bottom right world, bottom left world\r\n    const topLeft = annotation.data.handles.points[0];\r\n    const topRight = annotation.data.handles.points[1];\r\n    const bottomLeft = annotation.data.handles.points[2];\r\n    const bottomRight = annotation.data.handles.points[3];\r\n\r\n    const { focalPoint, viewPlaneNormal, viewUp } = targetViewport.getCamera();\r\n    const { viewPlaneNormal: sourceViewPlaneNormal } =\r\n      sourceViewport.getCamera();\r\n\r\n    if (this.isParallel(viewPlaneNormal, sourceViewPlaneNormal)) {\r\n      // If the source and target viewports are parallel, we don't need to render\r\n      return renderStatus;\r\n    }\r\n\r\n    const targetViewportPlane = csUtils.planar.planeEquation(\r\n      viewPlaneNormal,\r\n      focalPoint\r\n    );\r\n\r\n    // check if the topLeft and bottomLeft line is parallel to the viewUp\r\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\r\n    const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\r\n\r\n    let pointSetToUse = pointSet1;\r\n\r\n    let topBottomVec = vec3.subtract(vec3.create(), pointSet1[0], pointSet1[1]);\r\n    topBottomVec = vec3.normalize(vec3.create(), topBottomVec) as Types.Point3;\r\n\r\n    let topRightVec = vec3.subtract(vec3.create(), pointSet1[2], pointSet1[0]);\r\n    topRightVec = vec3.normalize(vec3.create(), topRightVec);\r\n\r\n    const newNormal = vec3.cross(\r\n      vec3.create(),\r\n      topBottomVec,\r\n      topRightVec\r\n    ) as Types.Point3;\r\n\r\n    if (this.isParallel(newNormal, viewPlaneNormal)) {\r\n      return renderStatus;\r\n    }\r\n\r\n    // check if it is perpendicular to the viewPlaneNormal which means\r\n    // the line does not intersect the viewPlaneNormal\r\n    if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\r\n      // 'use pointSet2';\r\n      pointSetToUse = pointSet2;\r\n    }\r\n\r\n    const lineStartWorld = csUtils.planar.linePlaneIntersection(\r\n      pointSetToUse[0],\r\n      pointSetToUse[1],\r\n      targetViewportPlane\r\n    );\r\n\r\n    const lineEndWorld = csUtils.planar.linePlaneIntersection(\r\n      pointSetToUse[2],\r\n      pointSetToUse[3],\r\n      targetViewportPlane\r\n    );\r\n    const { annotationUID } = annotation;\r\n\r\n    styleSpecifier.annotationUID = annotationUID;\r\n    const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\r\n    const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\r\n    const color = this.getStyle('color', styleSpecifier, annotation);\r\n    const shadow = this.getStyle('shadow', styleSpecifier, annotation);\r\n\r\n    let canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) =>\r\n      targetViewport.worldToCanvas(world)\r\n    );\r\n\r\n    if (this.configuration.showFullDimension) {\r\n      canvasCoordinates = this.handleFullDimension(\r\n        targetViewport,\r\n        lineStartWorld,\r\n        viewPlaneNormal,\r\n        viewUp,\r\n        lineEndWorld,\r\n        canvasCoordinates\r\n      );\r\n    }\r\n\r\n    if (canvasCoordinates.length < 2) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const dataId = `${annotationUID}-line`;\r\n    const lineUID = '1';\r\n    drawLineSvg(\r\n      svgDrawingHelper,\r\n      annotationUID,\r\n      lineUID,\r\n      canvasCoordinates[0],\r\n      canvasCoordinates[1],\r\n      {\r\n        color,\r\n        width: lineWidth,\r\n        lineDash,\r\n        shadow,\r\n      },\r\n      dataId\r\n    );\r\n\r\n    renderStatus = true;\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  isPerpendicular = (vec1: Types.Point3, vec2: Types.Point3): boolean => {\r\n    const dot = vec3.dot(vec1, vec2);\r\n    return Math.abs(dot) < EPSILON;\r\n  };\r\n\r\n  private handleFullDimension(\r\n    targetViewport: Types.IStackViewport | Types.IVolumeViewport,\r\n    lineStartWorld: Types.Point3,\r\n    viewPlaneNormal: Types.Point3,\r\n    viewUp: Types.Point3,\r\n    lineEndWorld: Types.Point3,\r\n    canvasCoordinates: Types.Point2[]\r\n  ) {\r\n    const renderingEngine = targetViewport.getRenderingEngine();\r\n    const targetId = this.getTargetId(targetViewport);\r\n    const targetImage = this.getTargetIdImage(targetId, renderingEngine);\r\n\r\n    const referencedImageId = this.getReferencedImageId(\r\n      targetViewport,\r\n      lineStartWorld,\r\n      viewPlaneNormal,\r\n      viewUp\r\n    );\r\n\r\n    if (referencedImageId && targetImage) {\r\n      try {\r\n        const { imageData, dimensions } = targetImage;\r\n\r\n        // Calculate bound image coordinates\r\n        const [\r\n          topLeftImageCoord,\r\n          topRightImageCoord,\r\n          bottomRightImageCoord,\r\n          bottomLeftImageCoord,\r\n        ] = [\r\n          imageData.indexToWorld([0, 0, 0]) as Types.Point3,\r\n          imageData.indexToWorld([dimensions[0] - 1, 0, 0]) as Types.Point3,\r\n          imageData.indexToWorld([\r\n            dimensions[0] - 1,\r\n            dimensions[1] - 1,\r\n            0,\r\n          ]) as Types.Point3,\r\n          imageData.indexToWorld([0, dimensions[1] - 1, 0]) as Types.Point3,\r\n        ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\r\n\r\n        // Calculate line start and end image coordinates\r\n        const [lineStartImageCoord, lineEndImageCoord] = [\r\n          lineStartWorld,\r\n          lineEndWorld,\r\n        ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\r\n\r\n        // Calculate intersection points between line and image bounds\r\n        canvasCoordinates = [\r\n          [topLeftImageCoord, topRightImageCoord],\r\n          [topRightImageCoord, bottomRightImageCoord],\r\n          [bottomLeftImageCoord, bottomRightImageCoord],\r\n          [topLeftImageCoord, bottomLeftImageCoord],\r\n        ]\r\n          .map(([start, end]) =>\r\n            this.intersectInfiniteLines(\r\n              start,\r\n              end,\r\n              lineStartImageCoord,\r\n              lineEndImageCoord\r\n            )\r\n          )\r\n          .filter((point) => point && this.isInBound(point, dimensions))\r\n          .map((point) => {\r\n            const world = csUtils.imageToWorldCoords(\r\n              referencedImageId,\r\n              point as Types.Point2\r\n            );\r\n            return targetViewport.worldToCanvas(world);\r\n          });\r\n      } catch (err) {\r\n        console.log(err);\r\n      }\r\n    }\r\n    return canvasCoordinates;\r\n  }\r\n\r\n  // get the intersection point between two infinite lines, not line segments\r\n  intersectInfiniteLines(\r\n    line1Start: Types.Point2,\r\n    line1End: Types.Point2,\r\n    line2Start: Types.Point2,\r\n    line2End: Types.Point2\r\n  ) {\r\n    const [x1, y1] = line1Start;\r\n    const [x2, y2] = line1End;\r\n    const [x3, y3] = line2Start;\r\n    const [x4, y4] = line2End;\r\n\r\n    // Compute a1, b1, c1, where line joining points 1 and 2 is \"a1 x  +  b1 y  +  c1  =  0\"\r\n    const a1 = y2 - y1;\r\n    const b1 = x1 - x2;\r\n    const c1 = x2 * y1 - x1 * y2;\r\n\r\n    // Compute a2, b2, c2\r\n    const a2 = y4 - y3;\r\n    const b2 = x3 - x4;\r\n    const c2 = x4 * y3 - x3 * y4;\r\n\r\n    if (Math.abs(a1 * b2 - a2 * b1) < EPSILON) {\r\n      return;\r\n    }\r\n\r\n    const x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);\r\n    const y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1);\r\n\r\n    return [x, y];\r\n  }\r\n\r\n  isParallel(vec1: Types.Point3, vec2: Types.Point3): boolean {\r\n    return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\r\n  }\r\n\r\n  isInBound(point: number[], dimensions: Types.Point3): boolean {\r\n    return (\r\n      point[0] >= 0 &&\r\n      point[0] <= dimensions[0] &&\r\n      point[1] >= 0 &&\r\n      point[1] <= dimensions[1]\r\n    );\r\n  }\r\n}\r\n\r\nReferenceLines.toolName = 'ReferenceLines';\r\nexport default ReferenceLines;\r\n","import AnnotationDisplayTool from './base/AnnotationDisplayTool';\r\nimport { vec3 } from 'gl-matrix';\r\nimport {\r\n  getEnabledElementByIds,\r\n  getRenderingEngines,\r\n  utilities as csUtils,\r\n} from '@cornerstonejs/core';\r\nimport { ScaleOverlayAnnotation } from '../types/ToolSpecificAnnotationTypes';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport {\r\n  addAnnotation,\r\n  getAnnotations,\r\n} from '../stateManagement/annotation/annotationState';\r\nimport {\r\n  drawLine as drawLineSvg,\r\n  drawTextBox as drawTextBoxSvg,\r\n} from '../drawingSvg';\r\nimport {\r\n  EventTypes,\r\n  PublicToolProps,\r\n  ToolProps,\r\n  SVGDrawingHelper,\r\n} from '../types';\r\nimport { StyleSpecifier } from '../types/AnnotationStyle';\r\nimport { getToolGroup } from '../store/ToolGroupManager';\r\n\r\nconst SCALEOVERLAYTOOL_ID = 'scaleoverlay-viewport';\r\nconst viewportsWithAnnotations = [];\r\n\r\n/**\r\n * @public\r\n * @class ScaleOverlayTool\r\n * @memberof Tools\r\n *\r\n * @classdesc Tool for displaying a scale overlay on the image.\r\n * @extends Tools.Base.BaseTool\r\n */\r\nclass ScaleOverlayTool extends AnnotationDisplayTool {\r\n  static toolName;\r\n\r\n  public touchDragCallback: any;\r\n  public mouseDragCallback: any;\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    renderingEngine: any;\r\n    viewport: any;\r\n    annotation: ScaleOverlayAnnotation;\r\n  } | null = {} as any;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      configuration: {\r\n        viewportId: '',\r\n        scaleLocation: 'bottom',\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  _init = (): void => {\r\n    const renderingEngines = getRenderingEngines();\r\n    const renderingEngine = renderingEngines[0];\r\n\r\n    if (!renderingEngine) {\r\n      return;\r\n    }\r\n\r\n    // get viewports with tool enabled\r\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\r\n\r\n    if (!viewportIds) {\r\n      return;\r\n    }\r\n\r\n    // get enabled elements\r\n    const enabledElements = viewportIds.map((e) =>\r\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\r\n    );\r\n\r\n    let { viewport } = enabledElements[0];\r\n    const { FrameOfReferenceUID } = enabledElements[0];\r\n\r\n    // onCameraModified, configuration.viewportId is set to the active\r\n    // viewport Id, here we are setting the viewport variable to the\r\n    // viewport with the matching Id\r\n    if (this.configuration.viewportId) {\r\n      enabledElements.forEach((element) => {\r\n        if (element.viewport.id == this.configuration.viewportId) {\r\n          viewport = element.viewport;\r\n        }\r\n      });\r\n    }\r\n\r\n    if (!viewport) {\r\n      return;\r\n    }\r\n\r\n    const { viewUp, viewPlaneNormal } = viewport.getCamera();\r\n\r\n    const viewportCanvasCornersInWorld =\r\n      csUtils.getViewportImageCornersInWorld(viewport);\r\n\r\n    let annotation = this.editData.annotation;\r\n\r\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\r\n\r\n    // if annotations have been created, get the annotation for the\r\n    // current viewport Id\r\n    if (annotations.length) {\r\n      annotation = annotations.filter(\r\n        (thisAnnotation) => thisAnnotation.data.viewportId == viewport.id\r\n      )[0] as ScaleOverlayAnnotation;\r\n    }\r\n\r\n    // viewportsWithAnnotations stores which viewports have an annotation,\r\n    // if the viewport does not have an annotation, create a new one\r\n    if (!viewportsWithAnnotations.includes(viewport.id)) {\r\n      const newAnnotation: ScaleOverlayAnnotation = {\r\n        metadata: {\r\n          toolName: this.getToolName(),\r\n          viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n          viewUp: <Types.Point3>[...viewUp],\r\n          FrameOfReferenceUID,\r\n          referencedImageId: null,\r\n        },\r\n        data: {\r\n          handles: {\r\n            points: viewportCanvasCornersInWorld,\r\n          },\r\n          viewportId: viewport.id,\r\n        },\r\n      };\r\n\r\n      viewportsWithAnnotations.push(viewport.id);\r\n\r\n      addAnnotation(newAnnotation, viewport.element);\r\n      annotation = newAnnotation;\r\n    } else if (\r\n      this.editData.annotation &&\r\n      this.editData.annotation.data.viewportId == viewport.id\r\n    ) {\r\n      this.editData.annotation.data.handles.points =\r\n        viewportCanvasCornersInWorld;\r\n      this.editData.annotation.data.viewportId = viewport.id;\r\n    }\r\n\r\n    this.editData = {\r\n      viewport,\r\n      renderingEngine,\r\n      annotation,\r\n    };\r\n  };\r\n\r\n  onSetToolEnabled = (): void => {\r\n    this._init();\r\n  };\r\n\r\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\r\n    // If the camera is modified, we need to update the viewport\r\n    // that the camera was modified on\r\n    this.configuration.viewportId = evt.detail.viewportId;\r\n    this._init();\r\n  };\r\n\r\n  /**\r\n   * Used to draw the scale annotation in each request animation\r\n   * frame.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   * @returns\r\n   */\r\n\r\n  renderAnnotation(\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ) {\r\n    if (!this.editData.viewport) {\r\n      return;\r\n    }\r\n    const location = this.configuration.scaleLocation;\r\n    const { viewport } = enabledElement;\r\n\r\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\r\n    const annotation = annotations.filter(\r\n      (thisAnnotation) => thisAnnotation.data.viewportId == viewport.id\r\n    )[0];\r\n    const canvas = enabledElement.viewport.canvas;\r\n\r\n    const renderStatus = false;\r\n\r\n    if (!viewport) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    const canvasSize = {\r\n      width: canvas.width / window.devicePixelRatio || 1,\r\n      height: canvas.height / window.devicePixelRatio || 1,\r\n    };\r\n\r\n    const topLeft = annotation.data.handles.points[0];\r\n    const topRight = annotation.data.handles.points[1];\r\n    const bottomLeft = annotation.data.handles.points[2];\r\n    const bottomRight = annotation.data.handles.points[3];\r\n\r\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\r\n\r\n    const worldWidthViewport = vec3.distance(bottomLeft, bottomRight);\r\n    const worldHeightViewport = vec3.distance(topLeft, bottomLeft);\r\n\r\n    // hscaleBounds and vscaleBounds compute the max bound for scales on the image\r\n    const hscaleBounds = this.computeScaleBounds(\r\n      canvasSize,\r\n      0.05,\r\n      0.05,\r\n      location\r\n    );\r\n\r\n    const vscaleBounds = this.computeScaleBounds(\r\n      canvasSize,\r\n      0.05,\r\n      0.05,\r\n      location\r\n    );\r\n\r\n    // Computes which scale size to use, ex: 100mm, 50mm\r\n    const scaleSize = this.computeScaleSize(\r\n      worldWidthViewport,\r\n      worldHeightViewport,\r\n      location\r\n    );\r\n\r\n    // Applies the scale with the predetermined size to the image in\r\n    // world coordinates, then converts them to canvas coordinates\r\n    const canvasCoordinates = this.computeWorldScaleCoordinates(\r\n      scaleSize,\r\n      location,\r\n      pointSet1\r\n    ).map((world) => viewport.worldToCanvas(world));\r\n\r\n    // Uses the bounds and canvas size to center the scale\r\n    // based on the location\r\n    const scaleCanvasCoordinates = this.computeCanvasScaleCoordinates(\r\n      canvasSize,\r\n      canvasCoordinates,\r\n      vscaleBounds,\r\n      hscaleBounds,\r\n      location\r\n    );\r\n\r\n    // Computes the end scale ticks coordinates\r\n    const scaleTicks = this.computeEndScaleTicks(\r\n      scaleCanvasCoordinates,\r\n      location\r\n    );\r\n\r\n    const { annotationUID } = annotation;\r\n\r\n    styleSpecifier.annotationUID = annotationUID;\r\n    const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\r\n    const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\r\n    const color = this.getStyle('color', styleSpecifier, annotation);\r\n    const shadow = this.getStyle('shadow', styleSpecifier, annotation);\r\n\r\n    const scaleId = `${annotationUID}-scaleline`;\r\n    const scaleLineUID = '1';\r\n    drawLineSvg(\r\n      svgDrawingHelper,\r\n      annotationUID,\r\n      scaleLineUID,\r\n      scaleCanvasCoordinates[0],\r\n      scaleCanvasCoordinates[1],\r\n      {\r\n        color,\r\n        width: lineWidth,\r\n        lineDash,\r\n        shadow,\r\n      },\r\n      scaleId\r\n    );\r\n    const leftTickId = `${annotationUID}-left`;\r\n    const leftTickUID = '2';\r\n\r\n    drawLineSvg(\r\n      svgDrawingHelper,\r\n      annotationUID,\r\n      leftTickUID,\r\n      scaleTicks.endTick1[0] as Types.Point2,\r\n      scaleTicks.endTick1[1] as Types.Point2,\r\n      {\r\n        color,\r\n        width: lineWidth,\r\n        lineDash,\r\n        shadow,\r\n      },\r\n      leftTickId\r\n    );\r\n    const rightTickId = `${annotationUID}-right`;\r\n    const rightTickUID = '3';\r\n\r\n    drawLineSvg(\r\n      svgDrawingHelper,\r\n      annotationUID,\r\n      rightTickUID,\r\n      scaleTicks.endTick2[0] as Types.Point2,\r\n      scaleTicks.endTick2[1] as Types.Point2,\r\n      {\r\n        color,\r\n        width: lineWidth,\r\n        lineDash,\r\n        shadow,\r\n      },\r\n      rightTickId\r\n    );\r\n\r\n    const locationTextOffest = {\r\n      bottom: [-10, -42],\r\n      top: [-12, -35],\r\n      left: [-40, -20],\r\n      right: [-50, -20],\r\n    };\r\n\r\n    const textCanvasCoordinates = [\r\n      scaleCanvasCoordinates[0][0] + locationTextOffest[location][0],\r\n      scaleCanvasCoordinates[0][1] + locationTextOffest[location][1],\r\n    ];\r\n    const textBoxLines = this._getTextLines(scaleSize);\r\n\r\n    const { tickIds, tickUIDs, tickCoordinates } = this.computeInnerScaleTicks(\r\n      scaleSize,\r\n      location,\r\n      annotationUID,\r\n      scaleTicks.endTick1,\r\n      scaleTicks.endTick2\r\n    );\r\n\r\n    // draws inner ticks for scale\r\n    for (let i = 0; i < tickUIDs.length; i++) {\r\n      drawLineSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        tickUIDs[i],\r\n        tickCoordinates[i][0],\r\n        tickCoordinates[i][1],\r\n        {\r\n          color,\r\n          width: lineWidth,\r\n          lineDash,\r\n          shadow,\r\n        },\r\n        tickIds[i]\r\n      );\r\n    }\r\n\r\n    const textUID = 'text0';\r\n    drawTextBoxSvg(\r\n      svgDrawingHelper,\r\n      annotationUID,\r\n      textUID,\r\n      textBoxLines,\r\n      [textCanvasCoordinates[0], textCanvasCoordinates[1]],\r\n      {\r\n        fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\r\n        fontSize: '14px',\r\n        lineDash: '2,3',\r\n        lineWidth: '1',\r\n        shadow: true,\r\n        color: color,\r\n      }\r\n    );\r\n\r\n    return renderStatus;\r\n  }\r\n\r\n  _getTextLines(scaleSize: number): string[] | undefined {\r\n    let scaleSizeDisplayValue;\r\n    let scaleSizeUnits;\r\n    if (scaleSize >= 50) {\r\n      scaleSizeDisplayValue = scaleSize / 10; //convert to cm\r\n      scaleSizeUnits = ' cm';\r\n    } else {\r\n      scaleSizeDisplayValue = scaleSize; //convert to cm\r\n      scaleSizeUnits = ' mm';\r\n    }\r\n\r\n    const textLines = [scaleSizeDisplayValue.toString().concat(scaleSizeUnits)];\r\n\r\n    return textLines;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param worldWidthViewport\r\n   * @returns currentScaleSize\r\n   */\r\n  computeScaleSize = (\r\n    worldWidthViewport: number,\r\n    worldHeightViewport: number,\r\n    location: any\r\n  ) => {\r\n    const scaleSizes = [\r\n      16000, 8000, 4000, 2000, 1000, 500, 250, 100, 50, 25, 10, 5, 2,\r\n    ];\r\n    let currentScaleSize;\r\n    if (location == 'top' || location == 'bottom') {\r\n      currentScaleSize = scaleSizes.filter(\r\n        (scaleSize) =>\r\n          scaleSize < worldWidthViewport * 0.6 &&\r\n          scaleSize > worldWidthViewport * 0.2\r\n      );\r\n    } else {\r\n      currentScaleSize = scaleSizes.filter(\r\n        (scaleSize) =>\r\n          scaleSize < worldHeightViewport * 0.6 &&\r\n          scaleSize > worldHeightViewport * 0.2\r\n      );\r\n    }\r\n\r\n    return currentScaleSize[0];\r\n  };\r\n\r\n  /**\r\n   *  calculates scale ticks for ends of the scale\r\n   * @param canvasCoordinates\r\n   * @returns leftTick, rightTick\r\n   */\r\n  computeEndScaleTicks = (canvasCoordinates, location) => {\r\n    const locationTickOffset = {\r\n      bottom: [\r\n        [0, -10],\r\n        [0, -10],\r\n      ],\r\n      top: [\r\n        [0, 10],\r\n        [0, 10],\r\n      ],\r\n      left: [\r\n        [0, 0],\r\n        [10, 0],\r\n      ],\r\n      right: [\r\n        [0, 0],\r\n        [-10, 0],\r\n      ],\r\n    };\r\n\r\n    const endTick1 = [\r\n      [\r\n        canvasCoordinates[1][0] + locationTickOffset[location][0][0],\r\n        canvasCoordinates[1][1] + locationTickOffset[location][0][0],\r\n      ],\r\n      [\r\n        canvasCoordinates[1][0] + locationTickOffset[location][1][0],\r\n        canvasCoordinates[1][1] + locationTickOffset[location][1][1],\r\n      ],\r\n    ];\r\n    const endTick2 = [\r\n      [\r\n        canvasCoordinates[0][0] + locationTickOffset[location][0][0],\r\n        canvasCoordinates[0][1] + locationTickOffset[location][0][0],\r\n      ],\r\n      [\r\n        canvasCoordinates[0][0] + locationTickOffset[location][1][0],\r\n        canvasCoordinates[0][1] + locationTickOffset[location][1][1],\r\n      ],\r\n    ];\r\n\r\n    return {\r\n      endTick1: endTick1,\r\n      endTick2: endTick2,\r\n    };\r\n  };\r\n\r\n  computeInnerScaleTicks = (\r\n    scaleSize: number,\r\n    location: string,\r\n    annotationUID: string,\r\n    leftTick: any[][],\r\n    rightTick: any[][]\r\n  ) => {\r\n    let canvasScaleSize;\r\n    if (location == 'bottom' || location == 'top') {\r\n      canvasScaleSize = rightTick[0][0] - leftTick[0][0];\r\n    } else if (location == 'left' || location == 'right') {\r\n      canvasScaleSize = rightTick[0][1] - leftTick[0][1];\r\n    }\r\n    const tickIds = [];\r\n    const tickUIDs = [];\r\n    const tickCoordinates = [];\r\n    let numberSmallTicks = scaleSize;\r\n\r\n    if (scaleSize >= 50) {\r\n      numberSmallTicks = scaleSize / 10;\r\n    }\r\n\r\n    const tickSpacing = canvasScaleSize / numberSmallTicks;\r\n\r\n    for (let i = 0; i < numberSmallTicks - 1; i++) {\r\n      const locationOffset = {\r\n        bottom: [\r\n          [tickSpacing * (i + 1), 0],\r\n          [tickSpacing * (i + 1), 5],\r\n        ],\r\n        top: [\r\n          [tickSpacing * (i + 1), 0],\r\n          [tickSpacing * (i + 1), -5],\r\n        ],\r\n        left: [\r\n          [0, tickSpacing * (i + 1)],\r\n          [-5, tickSpacing * (i + 1)],\r\n        ],\r\n        right: [\r\n          [0, tickSpacing * (i + 1)],\r\n          [5, tickSpacing * (i + 1)],\r\n        ],\r\n      };\r\n      tickIds.push(`${annotationUID}-tick${i}`);\r\n      tickUIDs.push(`tick${i}`);\r\n      if ((i + 1) % 5 == 0) {\r\n        tickCoordinates.push([\r\n          [\r\n            leftTick[0][0] + locationOffset[location][0][0],\r\n            leftTick[0][1] + locationOffset[location][0][1],\r\n          ],\r\n          [\r\n            leftTick[1][0] + locationOffset[location][0][0],\r\n            leftTick[1][1] + locationOffset[location][0][1],\r\n          ],\r\n        ]);\r\n      } else {\r\n        tickCoordinates.push([\r\n          [\r\n            leftTick[0][0] + locationOffset[location][0][0],\r\n            leftTick[0][1] + locationOffset[location][0][1],\r\n          ],\r\n          [\r\n            leftTick[1][0] + locationOffset[location][1][0],\r\n            leftTick[1][1] + locationOffset[location][1][1],\r\n          ],\r\n        ]);\r\n      }\r\n    }\r\n\r\n    return { tickIds, tickUIDs, tickCoordinates };\r\n  };\r\n\r\n  computeWorldScaleCoordinates = (scaleSize, location, pointSet) => {\r\n    let worldCoordinates;\r\n    let topBottomVec = vec3.subtract(vec3.create(), pointSet[0], pointSet[1]);\r\n    topBottomVec = vec3.normalize(vec3.create(), topBottomVec) as Types.Point3;\r\n\r\n    let topRightVec = vec3.subtract(vec3.create(), pointSet[2], pointSet[0]);\r\n    topRightVec = vec3.normalize(vec3.create(), topRightVec);\r\n\r\n    const midpointLocation = {\r\n      bottom: [pointSet[1], pointSet[2]],\r\n      top: [pointSet[0], pointSet[3]],\r\n      right: [pointSet[2], pointSet[3]],\r\n      left: [pointSet[0], pointSet[1]],\r\n    };\r\n\r\n    const midpoint = vec3\r\n      .add(\r\n        vec3.create(),\r\n        midpointLocation[location][0],\r\n        midpointLocation[location][0]\r\n      )\r\n      .map((i) => i / 2) as Types.Point3;\r\n\r\n    const offset =\r\n      scaleSize /\r\n      2 /\r\n      Math.sqrt(\r\n        Math.pow(topBottomVec[0], 2) +\r\n          Math.pow(topBottomVec[1], 2) +\r\n          Math.pow(topBottomVec[2], 2)\r\n      );\r\n\r\n    if (location == 'top' || location == 'bottom') {\r\n      worldCoordinates = [\r\n        vec3.subtract(\r\n          vec3.create(),\r\n          midpoint,\r\n          topRightVec.map((i) => i * offset) as Types.Point3\r\n        ),\r\n        vec3.add(\r\n          vec3.create(),\r\n          midpoint,\r\n          topRightVec.map((i) => i * offset) as Types.Point3\r\n        ),\r\n      ];\r\n    } else if (location == 'left' || location == 'right') {\r\n      worldCoordinates = [\r\n        vec3.add(\r\n          vec3.create(),\r\n          midpoint,\r\n          topBottomVec.map((i) => i * offset) as Types.Point3\r\n        ),\r\n        vec3.subtract(\r\n          vec3.create(),\r\n          midpoint,\r\n          topBottomVec.map((i) => i * offset) as Types.Point3\r\n        ),\r\n      ];\r\n    }\r\n\r\n    return worldCoordinates;\r\n  };\r\n\r\n  /**\r\n   * Computes the centered canvas coordinates for scale\r\n   * @param canvasSize\r\n   * @param canvasCoordinates\r\n   * @param vscaleBounds\r\n   * @returns scaleCanvasCoordinates\r\n   */\r\n  computeCanvasScaleCoordinates = (\r\n    canvasSize,\r\n    canvasCoordinates,\r\n    vscaleBounds,\r\n    hscaleBounds,\r\n    location\r\n  ) => {\r\n    let scaleCanvasCoordinates;\r\n    if (location == 'top' || location == 'bottom') {\r\n      const worldDistanceOnCanvas =\r\n        canvasCoordinates[0][0] - canvasCoordinates[1][0];\r\n      scaleCanvasCoordinates = [\r\n        [canvasSize.width / 2 - worldDistanceOnCanvas / 2, vscaleBounds.height],\r\n        [canvasSize.width / 2 + worldDistanceOnCanvas / 2, vscaleBounds.height],\r\n      ];\r\n    } else if (location == 'left' || location == 'right') {\r\n      const worldDistanceOnCanvas =\r\n        canvasCoordinates[0][1] - canvasCoordinates[1][1];\r\n      scaleCanvasCoordinates = [\r\n        [hscaleBounds.width, canvasSize.height / 2 - worldDistanceOnCanvas / 2],\r\n        [hscaleBounds.width, canvasSize.height / 2 + worldDistanceOnCanvas / 2],\r\n      ];\r\n    }\r\n\r\n    return scaleCanvasCoordinates;\r\n  };\r\n\r\n  /**\r\n   * Computes the max bound for scales on the image\r\n   * @param  {{width: number, height: number}} canvasSize\r\n   * @param  {number} horizontalReduction\r\n   * @param  {number} verticalReduction\r\n   * @returns {Object.<string, { x:number, y:number }>}\r\n   */\r\n  computeScaleBounds = (\r\n    canvasSize,\r\n    horizontalReduction,\r\n    verticalReduction,\r\n    location\r\n  ) => {\r\n    const hReduction = horizontalReduction * Math.min(1000, canvasSize.width);\r\n    const vReduction = verticalReduction * Math.min(1000, canvasSize.height);\r\n    const locationBounds = {\r\n      bottom: [-vReduction, -hReduction],\r\n      top: [vReduction, hReduction],\r\n      left: [vReduction, hReduction],\r\n      right: [-vReduction, -hReduction],\r\n    };\r\n    const canvasBounds = {\r\n      bottom: [canvasSize.height, canvasSize.width],\r\n      top: [0, canvasSize.width],\r\n      left: [canvasSize.height, 0],\r\n      right: [canvasSize.height, canvasSize.width],\r\n    };\r\n\r\n    return {\r\n      height: canvasBounds[location][0] + locationBounds[location][0],\r\n      width: canvasBounds[location][1] + locationBounds[location][1],\r\n    };\r\n  };\r\n}\r\n\r\nScaleOverlayTool.toolName = 'ScaleOverlay';\r\nexport default ScaleOverlayTool;\r\n","import { getEnabledElement } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport { BaseTool } from './base';\r\nimport { getAnnotations } from '../stateManagement';\r\nimport {\r\n  EventTypes,\r\n  PublicToolProps,\r\n  ToolProps,\r\n  SVGDrawingHelper,\r\n  ContourAnnotation,\r\n} from '../types';\r\nimport { point } from '../utilities/math';\r\nimport { Events, ToolModes, AnnotationStyleStates } from '../enums';\r\nimport { ToolGroupManager } from '../store';\r\nimport { triggerAnnotationRenderForViewportIds } from '../utilities/triggerAnnotationRenderForViewportIds';\r\nimport {\r\n  hideElementCursor,\r\n  resetElementCursor,\r\n} from '../cursors/elementCursor';\r\nimport { StyleSpecifier } from '../types/AnnotationStyle';\r\nimport { getStyleProperty } from '../stateManagement/annotation/config/helpers';\r\nimport { triggerAnnotationModified } from '../stateManagement/annotation/helpers/state';\r\nimport CircleSculptCursor from './SculptorTool/CircleSculptCursor';\r\nimport type { ISculptToolShape } from '../types/ISculptToolShape';\r\nimport { distancePointToContour } from './distancePointToContour';\r\n\r\nexport type SculptData = {\r\n  mousePoint: Types.Point3;\r\n  mouseCanvasPoint: Types.Point2;\r\n  points: Array<Types.Point3>;\r\n  maxSpacing: number;\r\n  element: HTMLDivElement;\r\n};\r\n\r\ntype CommonData = {\r\n  activeAnnotationUID: string | null;\r\n  viewportIdsToRender: any[];\r\n  isEditingOpenContour: boolean;\r\n  canvasLocation: Types.Point2 | undefined;\r\n};\r\n\r\n/**\r\n * This tool allows modifying the contour data for planar freehand by sculpting\r\n * it externally using another shape to push the contour in one direction or the other.\r\n */\r\nclass SculptorTool extends BaseTool {\r\n  static toolName: string;\r\n  registeredShapes = new Map();\r\n  private isActive = false;\r\n  private selectedShape: string;\r\n  private commonData: CommonData = {\r\n    activeAnnotationUID: null,\r\n    viewportIdsToRender: [],\r\n    isEditingOpenContour: false,\r\n    canvasLocation: undefined,\r\n  };\r\n  private sculptData?: SculptData;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        minSpacing: 1,\r\n        referencedToolNames: [\r\n          'PlanarFreehandROI',\r\n          'PlanarFreehandContourSegmentationTool',\r\n        ],\r\n        toolShape: 'circle',\r\n        referencedToolName: 'PlanarFreehandROI',\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n    this.registerShapes(CircleSculptCursor.shapeName, CircleSculptCursor);\r\n    this.setToolShape(this.configuration.toolShape);\r\n  }\r\n\r\n  /**\r\n   * Register different tool shapes for sculptor tool\r\n   * @param shapeName name of shape\r\n   * @param shapeClass shape class\r\n   */\r\n  registerShapes<T extends ISculptToolShape>(\r\n    shapeName: string,\r\n    shapeClass: new () => T\r\n  ): void {\r\n    const shape = new shapeClass();\r\n    this.registeredShapes.set(shapeName, shape);\r\n  }\r\n\r\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\r\n    const eventData = evt.detail;\r\n    const element = eventData.element;\r\n\r\n    this.configureToolSize(evt);\r\n    this.selectFreehandTool(eventData);\r\n\r\n    if (this.commonData.activeAnnotationUID === null) {\r\n      return;\r\n    }\r\n\r\n    this.isActive = true;\r\n\r\n    hideElementCursor(element);\r\n    this.activateModify(element);\r\n    return true;\r\n  };\r\n\r\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    if (this.mode === ToolModes.Active) {\r\n      this.configureToolSize(evt);\r\n      this.updateCursor(evt);\r\n    } else {\r\n      this.commonData.canvasLocation = undefined;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Sculpts the freehand ROI with freehandSculpter tool, moving,\r\n   * adding and removing handles as necessary.\r\n   *\r\n   * @param eventData - Data object associated with the event.\r\n   * @param points - Array of points\r\n   */\r\n  protected sculpt(eventData: any, points: Array<Types.Point3>): void {\r\n    const config = this.configuration;\r\n    const element = eventData.element;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const cursorShape = this.registeredShapes.get(this.selectedShape);\r\n\r\n    this.sculptData = {\r\n      mousePoint: eventData.currentPoints.world,\r\n      mouseCanvasPoint: eventData.currentPoints.canvas,\r\n      points,\r\n      maxSpacing: cursorShape.getMaxSpacing(config.minSpacing),\r\n      element: element,\r\n    };\r\n\r\n    const pushedHandles = cursorShape.pushHandles(viewport, this.sculptData);\r\n\r\n    if (pushedHandles.first !== undefined) {\r\n      this.insertNewHandles(pushedHandles);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Interpolates or fills in points between two points within a specified\r\n   * maximum spacing constraint.\r\n   */\r\n  protected interpolatePointsWithinMaxSpacing(\r\n    i: number,\r\n    points: Array<Types.Point3>,\r\n    indicesToInsertAfter: Array<number>,\r\n    maxSpacing: number\r\n  ): void {\r\n    const { element } = this.sculptData;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const nextHandleIndex = contourIndex(i + 1, points.length);\r\n\r\n    const currentCanvasPoint = viewport.worldToCanvas(points[i]);\r\n    const nextCanvasPoint = viewport.worldToCanvas(points[nextHandleIndex]);\r\n\r\n    const distanceToNextHandle = point.distanceToPoint(\r\n      currentCanvasPoint,\r\n      nextCanvasPoint\r\n    );\r\n\r\n    if (distanceToNextHandle > maxSpacing) {\r\n      indicesToInsertAfter.push(i);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates cursor size\r\n   *\r\n   * @param evt - The event\r\n   */\r\n  private updateCursor(evt: EventTypes.InteractionEventType): void {\r\n    const eventData = evt.detail;\r\n    const element = eventData.element;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine, viewport } = enabledElement;\r\n\r\n    this.commonData.viewportIdsToRender = [viewport.id];\r\n\r\n    const annotations = this.filterSculptableAnnotationsForElement(element);\r\n\r\n    if (!annotations?.length) {\r\n      return;\r\n    }\r\n\r\n    const activeAnnotation = annotations.find(\r\n      (annotation) =>\r\n        annotation.annotationUID === this.commonData.activeAnnotationUID\r\n    );\r\n\r\n    this.commonData.canvasLocation = eventData.currentPoints.canvas;\r\n\r\n    if (this.isActive) {\r\n      activeAnnotation.highlighted = true;\r\n    } else {\r\n      const cursorShape = this.registeredShapes.get(this.selectedShape);\r\n      const canvasCoords = eventData.currentPoints.canvas;\r\n      cursorShape.updateToolSize(canvasCoords, viewport, activeAnnotation);\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(\r\n      renderingEngine,\r\n      this.commonData.viewportIdsToRender\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns sculptable freehand ROI annotations\r\n   *\r\n   * @param element - The viewport element\r\n   */\r\n  private filterSculptableAnnotationsForElement(\r\n    element: HTMLDivElement\r\n  ): ContourAnnotation[] {\r\n    const config = this.configuration;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngineId, viewportId } = enabledElement;\r\n    const sculptableAnnotations = [];\r\n\r\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\r\n      viewportId,\r\n      renderingEngineId\r\n    );\r\n\r\n    const toolInstance = toolGroup.getToolInstance(config.referencedToolName);\r\n\r\n    config.referencedToolNames.forEach((referencedToolName: string) => {\r\n      const annotations = getAnnotations(referencedToolName, element);\r\n      if (annotations) {\r\n        sculptableAnnotations.push(...annotations);\r\n      }\r\n    });\r\n\r\n    return toolInstance.filterInteractableAnnotationsForElement(\r\n      element,\r\n      sculptableAnnotations\r\n    );\r\n  }\r\n\r\n  /** Just pass the tool size interaction onto the internal tool size */\r\n  private configureToolSize(evt: EventTypes.InteractionEventType): void {\r\n    const cursorShape = this.registeredShapes.get(this.selectedShape);\r\n    cursorShape.configureToolSize(evt);\r\n  }\r\n\r\n  /**\r\n   * Inserts additional handles in sparsely sampled regions of the contour\r\n   */\r\n  private insertNewHandles(pushedHandles: {\r\n    first: number;\r\n    last: number | undefined;\r\n  }): void {\r\n    const indicesToInsertAfter = this.findNewHandleIndices(pushedHandles);\r\n    let newIndexModifier = 0;\r\n    for (let i = 0; i < indicesToInsertAfter?.length; i++) {\r\n      const insertIndex = indicesToInsertAfter[i] + 1 + newIndexModifier;\r\n\r\n      this.insertHandleRadially(insertIndex);\r\n      newIndexModifier++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns an array of indicies that describe where new handles should be inserted\r\n   *\r\n   * @param pushedHandles - The first and last handles that were pushed.\r\n   */\r\n  private findNewHandleIndices(pushedHandles: {\r\n    first: number | undefined;\r\n    last: number | undefined;\r\n  }): Array<number> {\r\n    const { points, maxSpacing } = this.sculptData;\r\n    const indicesToInsertAfter = [];\r\n\r\n    for (let i = pushedHandles.first; i <= pushedHandles.last; i++) {\r\n      this.interpolatePointsWithinMaxSpacing(\r\n        i,\r\n        points,\r\n        indicesToInsertAfter,\r\n        maxSpacing\r\n      );\r\n    }\r\n\r\n    return indicesToInsertAfter;\r\n  }\r\n\r\n  /**\r\n   * Inserts a handle on the surface of the circle defined by toolSize and the mousePoint.\r\n   *\r\n   * @param insertIndex - The index to insert the new handle.\r\n   */\r\n  private insertHandleRadially(insertIndex: number): void {\r\n    const { points } = this.sculptData;\r\n\r\n    if (\r\n      insertIndex > points.length - 1 &&\r\n      this.commonData.isEditingOpenContour\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    const cursorShape = this.registeredShapes.get(this.selectedShape);\r\n\r\n    const previousIndex = insertIndex - 1;\r\n    const nextIndex = contourIndex(insertIndex, points.length);\r\n    const insertPosition = cursorShape.getInsertPosition(\r\n      previousIndex,\r\n      nextIndex,\r\n      this.sculptData\r\n    );\r\n    const handleData = insertPosition;\r\n\r\n    points.splice(insertIndex, 0, handleData);\r\n  }\r\n\r\n  /**\r\n   * Select the freehand tool to be edited\r\n   *\r\n   * @param eventData - Data object associated with the event.\r\n   */\r\n  private selectFreehandTool(eventData: any): void {\r\n    const closestAnnotationUID =\r\n      this.getClosestFreehandToolOnElement(eventData);\r\n\r\n    if (closestAnnotationUID === undefined) {\r\n      return;\r\n    }\r\n\r\n    this.commonData.activeAnnotationUID = closestAnnotationUID;\r\n  }\r\n\r\n  /**\r\n   * Finds the nearest handle to the mouse cursor for all freehand\r\n   * data on the element.\r\n   *\r\n   * @param eventData - Data object associated with the event.\r\n   */\r\n  private getClosestFreehandToolOnElement(eventData: any): string {\r\n    const { element } = eventData;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const config = this.configuration;\r\n\r\n    const annotations = this.filterSculptableAnnotationsForElement(element);\r\n\r\n    if (!annotations?.length) {\r\n      return;\r\n    }\r\n\r\n    const canvasPoints = eventData.currentPoints.canvas;\r\n\r\n    const closest = {\r\n      distance: Infinity,\r\n      toolIndex: undefined,\r\n      annotationUID: undefined,\r\n    };\r\n\r\n    for (let i = 0; i < annotations?.length; i++) {\r\n      if (annotations[i].isLocked || !annotations[i].isVisible) {\r\n        continue;\r\n      }\r\n\r\n      const distanceFromTool = distancePointToContour(\r\n        viewport,\r\n        annotations[i],\r\n        canvasPoints\r\n      );\r\n\r\n      if (distanceFromTool === -1) {\r\n        continue;\r\n      }\r\n\r\n      if (distanceFromTool < closest.distance) {\r\n        closest.distance = distanceFromTool;\r\n        closest.toolIndex = i;\r\n        closest.annotationUID = annotations[i].annotationUID;\r\n      }\r\n    }\r\n\r\n    this.commonData.isEditingOpenContour =\r\n      !annotations[closest.toolIndex].data.contour.closed;\r\n\r\n    config.referencedToolName =\r\n      annotations[closest.toolIndex].metadata.toolName;\r\n\r\n    return closest.annotationUID;\r\n  }\r\n\r\n  /**\r\n   * Event handler for MOUSE_UP during the active loop.\r\n   *\r\n   * @param evt - The event\r\n   */\r\n  private endCallback = (\r\n    evt: EventTypes.MouseUpEventType | EventTypes.MouseClickEventType\r\n  ): void => {\r\n    const eventData = evt.detail;\r\n    const { element } = eventData;\r\n    const config = this.configuration;\r\n    const enabledElement = getEnabledElement(element);\r\n\r\n    this.isActive = false;\r\n    this.deactivateModify(element);\r\n    resetElementCursor(element);\r\n\r\n    const { renderingEngineId, viewportId } = enabledElement;\r\n\r\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\r\n      viewportId,\r\n      renderingEngineId\r\n    );\r\n\r\n    const toolInstance = toolGroup.getToolInstance(config.referencedToolName);\r\n\r\n    const annotations = this.filterSculptableAnnotationsForElement(element);\r\n\r\n    const activeAnnotation = annotations.find(\r\n      (annotation) =>\r\n        annotation.annotationUID === this.commonData.activeAnnotationUID\r\n    );\r\n\r\n    if (toolInstance.configuration.calculateStats) {\r\n      activeAnnotation.invalidated = true;\r\n    }\r\n\r\n    triggerAnnotationModified(activeAnnotation, element);\r\n  };\r\n\r\n  /**\r\n   * Event handler for MOUSE_DRAG during the active loop.\r\n   *\r\n   * @param evt - The event\r\n   */\r\n  private dragCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventData = evt.detail;\r\n    const element = eventData.element;\r\n\r\n    this.updateCursor(evt);\r\n\r\n    const annotations = this.filterSculptableAnnotationsForElement(element);\r\n    const activeAnnotation = annotations.find(\r\n      (annotation) =>\r\n        annotation.annotationUID === this.commonData.activeAnnotationUID\r\n    );\r\n\r\n    if (!annotations?.length || !this.isActive) {\r\n      return;\r\n    }\r\n\r\n    const points = activeAnnotation.data.contour.polyline;\r\n\r\n    this.sculpt(eventData, points);\r\n  };\r\n\r\n  /**\r\n   * Attaches event listeners to the element such that is is visible, modifiable, and new data can be created.\r\n   * @param element - - The viewport element to attach event listeners to.\r\n   */\r\n  protected activateModify(element: HTMLDivElement): void {\r\n    element.addEventListener(\r\n      Events.MOUSE_UP,\r\n      this.endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this.endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this.dragCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_TAP,\r\n      this.endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_END,\r\n      this.endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this.dragCallback as EventListener\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Removes event listeners from the element.\r\n   * @param element - The viewport element to remove event listeners from.\r\n   */\r\n  protected deactivateModify(element: HTMLDivElement): void {\r\n    element.removeEventListener(\r\n      Events.MOUSE_UP,\r\n      this.endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this.endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this.dragCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_TAP,\r\n      this.endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_END,\r\n      this.endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this.dragCallback as EventListener\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Sets the tool shape to the specified tool\r\n   */\r\n  public setToolShape(toolShape: string): void {\r\n    this.selectedShape =\r\n      this.registeredShapes.get(toolShape) ?? CircleSculptCursor.shapeName;\r\n  }\r\n\r\n  /**\r\n   * Renders the cursor annotation on screen so that the user can choose the\r\n   * annotation size.\r\n   */\r\n  renderAnnotation(\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): void {\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n\r\n    const viewportIdsToRender = this.commonData.viewportIdsToRender;\r\n\r\n    if (\r\n      !this.commonData.canvasLocation ||\r\n      this.mode !== ToolModes.Active ||\r\n      !viewportIdsToRender.includes(viewport.id)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    const annotations = this.filterSculptableAnnotationsForElement(element);\r\n\r\n    if (!annotations?.length) {\r\n      return;\r\n    }\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    let color = getStyleProperty(\r\n      'color',\r\n      styleSpecifier,\r\n      AnnotationStyleStates.Default,\r\n      this.mode\r\n    );\r\n\r\n    if (this.isActive) {\r\n      color = getStyleProperty(\r\n        'color',\r\n        styleSpecifier,\r\n        AnnotationStyleStates.Highlighted,\r\n        this.mode\r\n      );\r\n    }\r\n\r\n    const cursorShape = this.registeredShapes.get(this.selectedShape);\r\n\r\n    cursorShape.renderShape(svgDrawingHelper, this.commonData.canvasLocation, {\r\n      color,\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Function calculates the index of a contour given a position `i` and the length of the contour.\r\n * It ensures that the resulting index is within the bounds of the contour by wrapping around if needed.\r\n * This function is useful for obtaining neighboring indices or other related indices within the contour,\r\n * such as for navigating or accessing elements in a circular or looped structure\r\n */\r\nexport const contourIndex = (i: number, length: number): number => {\r\n  return (i + length) % length;\r\n};\r\n\r\nSculptorTool.toolName = 'SculptorTool';\r\nexport default SculptorTool;\r\n","import { getRenderingEngine } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport {\r\n  addAnnotation,\r\n  getAnnotations,\r\n} from '../stateManagement/annotation/annotationState';\r\nimport { drawPath } from '../drawingSvg';\r\nimport { getToolGroup } from '../store/ToolGroupManager';\r\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\r\nimport { PublicToolProps, ToolProps, SVGDrawingHelper } from '../types';\r\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\r\nimport { Annotation } from '../types';\r\nimport { distanceToPoint } from '../utilities/math/point';\r\nimport { pointToString } from '../utilities/pointToString';\r\nimport { polyDataUtils } from '../utilities';\r\n\r\nexport interface SegmentationIntersectionAnnotation extends Annotation {\r\n  data: {\r\n    actorsWorldPointsMap: Map<string, Map<string, object>>;\r\n  };\r\n}\r\n\r\nclass SegmentationIntersectionTool extends AnnotationDisplayTool {\r\n  static toolName;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      configuration: {\r\n        opacity: 0.5,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  /**\r\n   * Initialize the annotation data and calculates surface intersections\r\n   * @returns\r\n   */\r\n  _init = (): void => {\r\n    const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\r\n\r\n    if (!viewportsInfo?.length) {\r\n      console.warn(this.getToolName() + 'Tool: No viewports found');\r\n      return;\r\n    }\r\n\r\n    const firstViewport = getRenderingEngine(\r\n      viewportsInfo[0].renderingEngineId\r\n    )?.getViewport(viewportsInfo[0].viewportId);\r\n\r\n    if (!firstViewport) {\r\n      return;\r\n    }\r\n    const frameOfReferenceUID = firstViewport.getFrameOfReferenceUID();\r\n    const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\r\n\r\n    if (!annotations?.length) {\r\n      const actorsWorldPointsMap = new Map();\r\n      calculateSurfaceSegmentationIntersections(\r\n        actorsWorldPointsMap,\r\n        viewportsInfo\r\n      );\r\n      const newAnnotation: SegmentationIntersectionAnnotation = {\r\n        highlighted: true,\r\n        invalidated: true,\r\n        metadata: {\r\n          toolName: this.getToolName(),\r\n          FrameOfReferenceUID: frameOfReferenceUID,\r\n          referencedImageId: null,\r\n        },\r\n        data: {\r\n          actorsWorldPointsMap,\r\n        },\r\n      };\r\n\r\n      addAnnotation(newAnnotation, frameOfReferenceUID);\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(\r\n      getRenderingEngine(viewportsInfo[0].renderingEngineId),\r\n      viewportsInfo.map(({ viewportId }) => viewportId)\r\n    );\r\n  };\r\n\r\n  onSetToolEnabled = (): void => {\r\n    this._init();\r\n  };\r\n\r\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\r\n    this._init();\r\n  };\r\n\r\n  /**\r\n   * Renders the surface intersections\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    const { viewport, FrameOfReferenceUID } = enabledElement;\r\n\r\n    let renderStatus = false;\r\n\r\n    const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n    const annotation = annotations[0];\r\n    const { annotationUID } = annotation;\r\n    const actorsWorldPointsMap = annotation.data.actorsWorldPointsMap;\r\n\r\n    calculateSurfaceSegmentationIntersectionsForViewport(\r\n      actorsWorldPointsMap,\r\n      viewport\r\n    );\r\n\r\n    const actorEntries = viewport.getActors();\r\n    const cacheId = getCacheId(viewport);\r\n\r\n    actorEntries.forEach((actorEntry) => {\r\n      if (!actorEntry?.clippingFilter) {\r\n        return;\r\n      }\r\n      const actorWorldPointMap = actorsWorldPointsMap.get(actorEntry.uid);\r\n      if (!actorWorldPointMap) {\r\n        return;\r\n      }\r\n      if (!actorWorldPointMap.get(cacheId)) {\r\n        return;\r\n      }\r\n      let polyLineIdx = 1;\r\n      const { worldPointsSet, color } = actorWorldPointMap.get(cacheId);\r\n      for (let i = 0; i < worldPointsSet.length; i++) {\r\n        const worldPoints = worldPointsSet[i];\r\n        const canvasPoints = worldPoints.map((point) =>\r\n          viewport.worldToCanvas(point)\r\n        );\r\n\r\n        const options = {\r\n          color: color,\r\n          fillColor: color,\r\n          fillOpacity: this.configuration.opacity,\r\n          closePath: true,\r\n          lineWidth: 2,\r\n        };\r\n\r\n        const polyLineUID = actorEntry.uid + '#' + polyLineIdx;\r\n        drawPath(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          polyLineUID,\r\n          canvasPoints,\r\n          options\r\n        );\r\n        polyLineIdx++;\r\n      }\r\n    });\r\n\r\n    renderStatus = true;\r\n    return renderStatus;\r\n  };\r\n}\r\n\r\n/**\r\n * Calculates surface intersections points for all surface actors in a list of viewports\r\n * @param actorWorldPointsMap\r\n * @param viewportsInfo\r\n */\r\nfunction calculateSurfaceSegmentationIntersections(\r\n  actorsWorldPointsMap,\r\n  viewportsInfo\r\n) {\r\n  viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\r\n    const viewport =\r\n      getRenderingEngine(renderingEngineId)?.getViewport(viewportId);\r\n    calculateSurfaceSegmentationIntersectionsForViewport(\r\n      actorsWorldPointsMap,\r\n      viewport\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n * Calculates surface intersections points for all surface actors in a viewport\r\n * generating a set of polyline points for each actor\r\n * @param actorWorldPointsMap\r\n * @param viewport\r\n */\r\nfunction calculateSurfaceSegmentationIntersectionsForViewport(\r\n  actorsWorldPointsMap,\r\n  viewport\r\n) {\r\n  const actorEntries = viewport.getActors();\r\n\r\n  // we should not use the focalPoint here, since the pan and zoom updates it,\r\n  // imageIndex is reliable enough\r\n  const cacheId = getCacheId(viewport);\r\n\r\n  actorEntries.forEach((actorEntry) => {\r\n    if (!actorEntry?.clippingFilter) {\r\n      return;\r\n    }\r\n\r\n    let actorWorldPointsMap = actorsWorldPointsMap.get(actorEntry.uid);\r\n    if (!actorWorldPointsMap) {\r\n      actorWorldPointsMap = new Map();\r\n      actorsWorldPointsMap.set(actorEntry.uid, actorWorldPointsMap);\r\n    }\r\n    if (!actorWorldPointsMap.get(cacheId)) {\r\n      const polyData = actorEntry.clippingFilter.getOutputData();\r\n      const worldPointsSet = polyDataUtils.getPolyDataPoints(polyData);\r\n      if (!worldPointsSet) {\r\n        return;\r\n      }\r\n\r\n      // worldPointsSet = removeExtraPoints(viewport, worldPointsSet);\r\n      const colorArray = actorEntry.actor.getProperty().getColor();\r\n      const color = colorToString(colorArray);\r\n      actorWorldPointsMap.set(cacheId, { worldPointsSet, color });\r\n    }\r\n  });\r\n}\r\n\r\nfunction getCacheId(viewport) {\r\n  const { viewPlaneNormal } = viewport.getCamera();\r\n  const imageIndex = viewport.getCurrentImageIdIndex();\r\n  return `${viewport.id}-${pointToString(viewPlaneNormal)}-${imageIndex}`;\r\n}\r\n\r\n/**\r\n * Transform a color array into a string\r\n * @param colorArray\r\n * @returns\r\n */\r\nfunction colorToString(colorArray): string {\r\n  function colorComponentToString(component) {\r\n    let componentString = Math.floor(component * 255).toString(16);\r\n    if (componentString.length === 1) {\r\n      componentString = '0' + componentString;\r\n    }\r\n    return componentString;\r\n  }\r\n  return (\r\n    '#' +\r\n    colorComponentToString(colorArray[0]) +\r\n    colorComponentToString(colorArray[1]) +\r\n    colorComponentToString(colorArray[2])\r\n  );\r\n}\r\n\r\n/**\r\n * Remove duplicate and unnecessary points\r\n * @param worldPoints\r\n * @param canvasPoints\r\n * @returns\r\n */\r\nfunction removeExtraPoints(viewport, worldPointsSet) {\r\n  return worldPointsSet.map((worldPoints) => {\r\n    const canvasPoints = worldPoints.map((point) => {\r\n      const canvasPoint = viewport.worldToCanvas(point);\r\n      return [Math.floor(canvasPoint[0]), Math.floor(canvasPoint[1])];\r\n    });\r\n\r\n    let lastPoint;\r\n    const newWorldPoints = [];\r\n    let newCanvasPoints = [];\r\n    // removing duplicate points\r\n    for (let i = 0; i < worldPoints.length; i++) {\r\n      if (lastPoint) {\r\n        if (distanceToPoint(lastPoint, canvasPoints[i]) > 0) {\r\n          newWorldPoints.push(worldPoints[i]);\r\n          newCanvasPoints.push(canvasPoints[i]);\r\n        }\r\n      }\r\n      lastPoint = canvasPoints[i];\r\n    }\r\n\r\n    // checking if a middle point is near the start\r\n    const firstPoint = newCanvasPoints[0];\r\n    for (\r\n      let j = Math.min(30, newCanvasPoints.length);\r\n      j < newCanvasPoints.length;\r\n      j++\r\n    ) {\r\n      if (distanceToPoint(firstPoint, newCanvasPoints[j]) < 0.5) {\r\n        newCanvasPoints = newCanvasPoints.slice(0, j);\r\n        return newWorldPoints.slice(0, j);\r\n      }\r\n    }\r\n    return newWorldPoints;\r\n  });\r\n}\r\n\r\nSegmentationIntersectionTool.toolName = 'SegmentationIntersection';\r\nexport default SegmentationIntersectionTool;\r\n","import { getEnabledElementByIds, VolumeViewport } from '@cornerstonejs/core';\r\nimport { BaseTool } from './base';\r\nimport { scroll } from '../utilities';\r\nimport { PublicToolProps, ToolProps, EventTypes } from '../types';\r\n\r\n/**\r\n * The StackScrollTool is a tool that allows the user to scroll through a\r\n * stack of images by pressing the mouse click and dragging\r\n */\r\nclass StackScrollTool extends BaseTool {\r\n  static toolName;\r\n  deltaY: number;\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        invert: false,\r\n        debounceIfNotLoaded: true,\r\n        loop: false,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n    this.deltaY = 1;\r\n  }\r\n\r\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\r\n    this._dragCallback(evt);\r\n  }\r\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\r\n    this._dragCallback(evt);\r\n  }\r\n\r\n  _dragCallback(evt: EventTypes.InteractionEventType) {\r\n    const { deltaPoints, viewportId, renderingEngineId } = evt.detail;\r\n    const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\r\n\r\n    const targetId = this.getTargetId(viewport);\r\n    const { debounceIfNotLoaded, invert, loop } = this.configuration;\r\n\r\n    const deltaPointY = deltaPoints.canvas[1];\r\n    let volumeId;\r\n    if (viewport instanceof VolumeViewport) {\r\n      volumeId = targetId.split(/volumeId:|\\?/)[1];\r\n    }\r\n\r\n    const pixelsPerImage = this._getPixelPerImage(viewport);\r\n    const deltaY = deltaPointY + this.deltaY;\r\n\r\n    if (!pixelsPerImage) {\r\n      return;\r\n    }\r\n\r\n    if (Math.abs(deltaY) >= pixelsPerImage) {\r\n      const imageIdIndexOffset = Math.round(deltaY / pixelsPerImage);\r\n\r\n      scroll(viewport, {\r\n        delta: invert ? -imageIdIndexOffset : imageIdIndexOffset,\r\n        volumeId,\r\n        debounceLoading: debounceIfNotLoaded,\r\n        loop: loop,\r\n      });\r\n\r\n      this.deltaY = deltaY % pixelsPerImage;\r\n    } else {\r\n      this.deltaY = deltaY;\r\n    }\r\n  }\r\n\r\n  _getPixelPerImage(viewport) {\r\n    const { element } = viewport;\r\n    const numberOfSlices = viewport.getNumberOfSlices();\r\n\r\n    // The Math.max here makes it easier to mouseDrag-scroll small or really large image stacks\r\n    return Math.max(2, element.offsetHeight / Math.max(numberOfSlices, 8));\r\n  }\r\n}\r\n\r\nStackScrollTool.toolName = 'StackScroll';\r\nexport default StackScrollTool;\r\n","import { getEnabledElement, utilities } from '@cornerstonejs/core';\r\nimport { BaseTool } from './base';\r\nimport { MouseWheelEventType } from '../types/EventTypes';\r\nimport scroll from '../utilities/scroll';\r\n\r\n/**\r\n * The StackScrollMouseWheelTool is a tool that allows the user to scroll through a\r\n * stack of images using the mouse wheel\r\n */\r\nclass StackScrollMouseWheelTool extends BaseTool {\r\n  static toolName;\r\n\r\n  _configuration: any;\r\n\r\n  constructor(\r\n    toolProps = {},\r\n    defaultToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        invert: false,\r\n        debounceIfNotLoaded: true,\r\n        loop: false,\r\n        scrollSlabs: false,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  mouseWheelCallback(evt: MouseWheelEventType): void {\r\n    const { wheel, element } = evt.detail;\r\n    const { direction } = wheel;\r\n    const { invert } = this.configuration;\r\n    const { viewport } = getEnabledElement(element);\r\n    const delta = direction * (invert ? -1 : 1);\r\n\r\n    const targetId = this.getTargetId(viewport);\r\n    const volumeId = utilities.getVolumeId(targetId);\r\n\r\n    scroll(viewport, {\r\n      delta,\r\n      debounceLoading: this.configuration.debounceIfNotLoaded,\r\n      loop: this.configuration.loop,\r\n      volumeId,\r\n      scrollSlabs: this.configuration.scrollSlabs,\r\n    });\r\n  }\r\n}\r\n\r\nStackScrollMouseWheelTool.toolName = 'StackScrollMouseWheel';\r\nexport default StackScrollMouseWheelTool;\r\n","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\r\nimport { Events } from '../enums';\r\nimport {\r\n  eventTarget,\r\n  getEnabledElement,\r\n  getEnabledElementByIds,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport { mat4, vec3 } from 'gl-matrix';\r\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\r\nimport { BaseTool } from './base';\r\nimport { getToolGroup } from '../store/ToolGroupManager';\r\n\r\nclass TrackballRotateTool extends BaseTool {\r\n  static toolName;\r\n  touchDragCallback: (evt: EventTypes.InteractionEventType) => void;\r\n  mouseDragCallback: (evt: EventTypes.InteractionEventType) => void;\r\n  cleanUp: () => void;\r\n  _resizeObservers = new Map();\r\n  _viewportAddedListener: (evt: any) => void;\r\n  _hasResolutionChanged = false;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        rotateIncrementDegrees: 2,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n    this.touchDragCallback = this._dragCallback.bind(this);\r\n    this.mouseDragCallback = this._dragCallback.bind(this);\r\n  }\r\n\r\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType) => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const actorEntry = viewport.getDefaultActor();\r\n    const actor = actorEntry.actor as Types.VolumeActor;\r\n    const mapper = actor.getMapper();\r\n    const originalSampleDistance = mapper.getSampleDistance();\r\n\r\n    if (!this._hasResolutionChanged) {\r\n      mapper.setSampleDistance(originalSampleDistance * 2);\r\n      this._hasResolutionChanged = true;\r\n\r\n      if (this.cleanUp !== null) {\r\n        // Clean up previous event listener\r\n        document.removeEventListener('mouseup', this.cleanUp);\r\n      }\r\n\r\n      this.cleanUp = () => {\r\n        mapper.setSampleDistance(originalSampleDistance);\r\n        viewport.render();\r\n        this._hasResolutionChanged = false;\r\n      };\r\n\r\n      document.addEventListener('mouseup', this.cleanUp, { once: true });\r\n    }\r\n    return true;\r\n  };\r\n\r\n  _getViewportsInfo = () => {\r\n    const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\r\n    return viewports;\r\n  };\r\n\r\n  onSetToolActive = () => {\r\n    const subscribeToElementResize = () => {\r\n      const viewportsInfo = this._getViewportsInfo();\r\n      viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\r\n        if (!this._resizeObservers.has(viewportId)) {\r\n          const { viewport } = getEnabledElementByIds(\r\n            viewportId,\r\n            renderingEngineId\r\n          ) || { viewport: null };\r\n\r\n          if (!viewport) {\r\n            return;\r\n          }\r\n\r\n          const { element } = viewport;\r\n\r\n          const resizeObserver = new ResizeObserver(() => {\r\n            const element = getEnabledElementByIds(\r\n              viewportId,\r\n              renderingEngineId\r\n            );\r\n            if (!element) {\r\n              return;\r\n            }\r\n            const { viewport } = element;\r\n            viewport.resetCamera();\r\n            viewport.render();\r\n          });\r\n\r\n          resizeObserver.observe(element);\r\n          this._resizeObservers.set(viewportId, resizeObserver);\r\n        }\r\n      });\r\n    };\r\n\r\n    subscribeToElementResize();\r\n\r\n    this._viewportAddedListener = (evt) => {\r\n      if (evt.detail.toolGroupId === this.toolGroupId) {\r\n        subscribeToElementResize();\r\n      }\r\n    };\r\n\r\n    eventTarget.addEventListener(\r\n      Events.TOOLGROUP_VIEWPORT_ADDED,\r\n      this._viewportAddedListener\r\n    );\r\n  };\r\n\r\n  onSetToolDisabled = () => {\r\n    // Disconnect all resize observers\r\n    this._resizeObservers.forEach((resizeObserver, viewportId) => {\r\n      resizeObserver.disconnect();\r\n      this._resizeObservers.delete(viewportId);\r\n    });\r\n\r\n    if (this._viewportAddedListener) {\r\n      eventTarget.removeEventListener(\r\n        Events.TOOLGROUP_VIEWPORT_ADDED,\r\n        this._viewportAddedListener\r\n      );\r\n      this._viewportAddedListener = null; // Clear the reference to the listener\r\n    }\r\n  };\r\n\r\n  rotateCamera = (viewport, centerWorld, axis, angle) => {\r\n    const vtkCamera = viewport.getVtkActiveCamera();\r\n    const viewUp = vtkCamera.getViewUp();\r\n    const focalPoint = vtkCamera.getFocalPoint();\r\n    const position = vtkCamera.getPosition();\r\n\r\n    const newPosition: Types.Point3 = [0, 0, 0];\r\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\r\n    const newViewUp: Types.Point3 = [0, 0, 0];\r\n\r\n    const transform = mat4.identity(new Float32Array(16));\r\n    mat4.translate(transform, transform, centerWorld);\r\n    mat4.rotate(transform, transform, angle, axis);\r\n    mat4.translate(transform, transform, [\r\n      -centerWorld[0],\r\n      -centerWorld[1],\r\n      -centerWorld[2],\r\n    ]);\r\n    vec3.transformMat4(newPosition, position, transform);\r\n    vec3.transformMat4(newFocalPoint, focalPoint, transform);\r\n\r\n    mat4.identity(transform);\r\n    mat4.rotate(transform, transform, angle, axis);\r\n    vec3.transformMat4(newViewUp, viewUp, transform);\r\n\r\n    viewport.setCamera({\r\n      position: newPosition,\r\n      viewUp: newViewUp,\r\n      focalPoint: newFocalPoint,\r\n    });\r\n  };\r\n\r\n  _dragCallback(evt: EventTypes.InteractionEventType): void {\r\n    const { element, currentPoints, lastPoints } = evt.detail;\r\n    const currentPointsCanvas = currentPoints.canvas;\r\n    const lastPointsCanvas = lastPoints.canvas;\r\n    const { rotateIncrementDegrees } = this.configuration;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    const camera = viewport.getCamera();\r\n    const width = element.clientWidth;\r\n    const height = element.clientHeight;\r\n\r\n    const normalizedPosition = [\r\n      currentPointsCanvas[0] / width,\r\n      currentPointsCanvas[1] / height,\r\n    ];\r\n\r\n    const normalizedPreviousPosition = [\r\n      lastPointsCanvas[0] / width,\r\n      lastPointsCanvas[1] / height,\r\n    ];\r\n\r\n    const center: Types.Point2 = [width * 0.5, height * 0.5];\r\n    // NOTE: centerWorld corresponds to the focal point in cornerstone3D\r\n    const centerWorld = viewport.canvasToWorld(center);\r\n    const normalizedCenter = [0.5, 0.5];\r\n\r\n    const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;\r\n    const op = [normalizedPreviousPosition[0], 0, 0];\r\n    const oe = [normalizedPosition[0], 0, 0];\r\n\r\n    const opsq = op[0] ** 2;\r\n    const oesq = oe[0] ** 2;\r\n\r\n    const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);\r\n    const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);\r\n\r\n    const nop: Types.Point3 = [op[0], 0, lop];\r\n    vtkMath.normalize(nop);\r\n    const noe: Types.Point3 = [oe[0], 0, loe];\r\n    vtkMath.normalize(noe);\r\n\r\n    const dot = vtkMath.dot(nop, noe);\r\n    if (Math.abs(dot) > 0.0001) {\r\n      const angleX =\r\n        -2 *\r\n        Math.acos(vtkMath.clampValue(dot, -1.0, 1.0)) *\r\n        Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *\r\n        rotateIncrementDegrees;\r\n\r\n      const upVec = camera.viewUp;\r\n      const atV = camera.viewPlaneNormal;\r\n      const rightV: Types.Point3 = [0, 0, 0];\r\n      const forwardV: Types.Point3 = [0, 0, 0];\r\n\r\n      vtkMath.cross(upVec, atV, rightV);\r\n      vtkMath.normalize(rightV);\r\n\r\n      vtkMath.cross(atV, rightV, forwardV);\r\n      vtkMath.normalize(forwardV);\r\n      vtkMath.normalize(upVec);\r\n\r\n      this.rotateCamera(viewport, centerWorld, forwardV, angleX);\r\n\r\n      const angleY =\r\n        (normalizedPreviousPosition[1] - normalizedPosition[1]) *\r\n        rotateIncrementDegrees;\r\n\r\n      this.rotateCamera(viewport, centerWorld, rightV, angleY);\r\n\r\n      viewport.render();\r\n    }\r\n  }\r\n}\r\n\r\nTrackballRotateTool.toolName = 'TrackballRotate';\r\nexport default TrackballRotateTool;\r\n","import { BaseTool } from './base';\r\nimport { getEnabledElement } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { mat4, vec3 } from 'gl-matrix';\r\nimport { PublicToolProps, ToolProps } from '../types';\r\nimport { MouseWheelEventType } from '../types/EventTypes';\r\n\r\nconst DIRECTIONS = {\r\n  X: [1, 0, 0],\r\n  Y: [0, 1, 0],\r\n  Z: [0, 0, 1],\r\n  CUSTOM: [],\r\n};\r\n\r\n/**\r\n * Tool that rotates the camera on mouse wheel.\r\n * It rotates the camera around the focal point, and around a defined axis. Default\r\n * axis is set to be Z axis, but it can be configured to any custom normalized axis.\r\n *\r\n */\r\nclass VolumeRotateMouseWheelTool extends BaseTool {\r\n  static toolName;\r\n  _configuration: any;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        direction: DIRECTIONS.Z,\r\n        rotateIncrementDegrees: 30,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  mouseWheelCallback(evt: MouseWheelEventType) {\r\n    // https://github.com/kitware/vtk-js/blob/HEAD/Sources/Interaction/Manipulators/MouseCameraUnicamRotateManipulator/index.js#L73\r\n    const { element, wheel } = evt.detail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const { direction, rotateIncrementDegrees } = this.configuration;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewUp, position, focalPoint } = camera;\r\n\r\n    const { direction: deltaY } = wheel;\r\n\r\n    const [cx, cy, cz] = focalPoint;\r\n    const [ax, ay, az] = direction;\r\n\r\n    //Calculate angle in radian as glmatrix rotate is in radian\r\n    const angle = (deltaY * (rotateIncrementDegrees * Math.PI)) / 180;\r\n\r\n    // position[3] = 1.0\r\n    // focalPoint[3] = 1.0\r\n    // viewUp[3] = 0.0\r\n\r\n    const newPosition: Types.Point3 = [0, 0, 0];\r\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\r\n    const newViewUp: Types.Point3 = [0, 0, 0];\r\n\r\n    const transform = mat4.identity(new Float32Array(16));\r\n    mat4.translate(transform, transform, [cx, cy, cz]);\r\n    mat4.rotate(transform, transform, angle, [ax, ay, az]);\r\n    mat4.translate(transform, transform, [-cx, -cy, -cz]);\r\n    vec3.transformMat4(newPosition, position, transform);\r\n    vec3.transformMat4(newFocalPoint, focalPoint, transform);\r\n\r\n    mat4.identity(transform);\r\n    mat4.rotate(transform, transform, angle, [ax, ay, az]);\r\n    vec3.transformMat4(<Types.Point3>newViewUp, viewUp, transform);\r\n\r\n    viewport.setCamera({\r\n      position: newPosition,\r\n      viewUp: newViewUp,\r\n      focalPoint: newFocalPoint,\r\n    });\r\n\r\n    viewport.render();\r\n  }\r\n}\r\n\r\nVolumeRotateMouseWheelTool.toolName = 'VolumeRotateMouseWheel';\r\nexport default VolumeRotateMouseWheelTool;\r\n","import { AnnotationTool } from './base';\r\n\r\nimport { getEnabledElement, utilities } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport {\r\n  addAnnotation,\r\n  getAnnotations,\r\n  removeAnnotation,\r\n} from '../stateManagement';\r\nimport { triggerAnnotationCompleted } from '../stateManagement/annotation/helpers/state';\r\nimport { drawRect as drawRectSvg } from '../drawingSvg';\r\nimport { state } from '../store';\r\nimport { Events } from '../enums';\r\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\r\nimport {\r\n  resetElementCursor,\r\n  hideElementCursor,\r\n} from '../cursors/elementCursor';\r\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\r\n\r\nimport {\r\n  EventTypes,\r\n  ToolProps,\r\n  PublicToolProps,\r\n  SVGDrawingHelper,\r\n} from '../types';\r\nimport { RectangleROIAnnotation } from '../types/ToolSpecificAnnotationTypes';\r\nimport { StyleSpecifier } from '../types/AnnotationStyle';\r\n\r\nimport { windowLevel } from '../utilities/voi';\r\n\r\nimport { clip } from '../utilities';\r\n\r\n/**\r\n * WindowLevelRegion tool manipulates the windowLevel applied to a viewport. It\r\n * provides a way to set the windowCenter and windowWidth of a viewport\r\n * by dragging mouse over the image to draw a rectangle region which is used to calculate\r\n * the windowCenter and windowWidth based on the ROI\r\n *\r\n */\r\n\r\nclass WindowLevelRegionTool extends AnnotationTool {\r\n  static toolName;\r\n\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: string[];\r\n  } | null;\r\n  isDrawing: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        // The minimum window width to be applied to the viewport regardless of the calculated value\r\n        minWindowWidth: 10,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the current imageId to create\r\n   * a RectangleROI Annotation and stores it in the annotationManager\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation = (evt: EventTypes.InteractionEventType): any => {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    const referencedImageId = this.getReferencedImageId(\r\n      viewport,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      viewUp\r\n    );\r\n\r\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n\r\n    const annotation = {\r\n      invalidated: true,\r\n      highlighted: true,\r\n      metadata: {\r\n        toolName: this.getToolName(),\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID,\r\n        referencedImageId,\r\n      },\r\n      data: {\r\n        handles: {\r\n          points: [\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n          ],\r\n        },\r\n        cachedStats: {},\r\n      },\r\n    };\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n    };\r\n    this._activateDraw(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  };\r\n\r\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender } = this.editData;\r\n\r\n    this._deactivateDraw(element);\r\n\r\n    resetElementCursor(element);\r\n\r\n    const { renderingEngine } = getEnabledElement(element);\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n\r\n    removeAnnotation(annotation.annotationUID);\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    triggerAnnotationCompleted(annotation);\r\n\r\n    this.applyWindowLevelRegion(annotation, element);\r\n  };\r\n\r\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    this.isDrawing = true;\r\n\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender } = this.editData;\r\n    const { data } = annotation;\r\n    const { currentPoints } = eventDetail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\r\n    const worldPos = currentPoints.world;\r\n\r\n    const { points } = data.handles;\r\n    const DEFAULT_HANDLE_INDEX = 3;\r\n    points[DEFAULT_HANDLE_INDEX] = [...worldPos];\r\n\r\n    const bottomLeftCanvas = worldToCanvas(points[0]);\r\n    const topRightCanvas = worldToCanvas(points[3]);\r\n\r\n    const bottomRightCanvas = <Types.Point2>[\r\n      topRightCanvas[0],\r\n      bottomLeftCanvas[1],\r\n    ];\r\n    const topLeftCanvas = <Types.Point2>[\r\n      bottomLeftCanvas[0],\r\n      topRightCanvas[1],\r\n    ];\r\n\r\n    const bottomRightWorld = canvasToWorld(bottomRightCanvas);\r\n    const topLeftWorld = canvasToWorld(topLeftCanvas);\r\n\r\n    points[1] = bottomRightWorld;\r\n    points[2] = topLeftWorld;\r\n\r\n    annotation.invalidated = true;\r\n\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  /**\r\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\r\n   */\r\n  _activateDraw = (element) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\r\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\r\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  /**\r\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\r\n   */\r\n  _deactivateDraw = (element) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\r\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\r\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the rectangleROI annotation in each\r\n   * request animation frame. It calculates the updated cached statistics if\r\n   * data is invalidated and cache it.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n\r\n    let annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    annotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    );\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[i] as RectangleROIAnnotation;\r\n      const { annotationUID, data } = annotation;\r\n      const { points } = data.handles;\r\n\r\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\r\n        annotation,\r\n        styleSpecifier,\r\n      });\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n\r\n      const dataId = `${annotationUID}-rect`;\r\n      const rectangleUID = '0';\r\n      drawRectSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        rectangleUID,\r\n        canvasCoordinates[0],\r\n        canvasCoordinates[3],\r\n        {\r\n          color,\r\n          lineDash,\r\n          lineWidth,\r\n        },\r\n        dataId\r\n      );\r\n\r\n      renderStatus = true;\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  applyWindowLevelRegion = (annotation, element): void => {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const imageData = windowLevel.extractWindowLevelRegionToolData(viewport);\r\n    const { data } = annotation;\r\n    const { points } = data.handles;\r\n\r\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n    const startCanvas = canvasCoordinates[0];\r\n    const endCanvas = canvasCoordinates[3];\r\n\r\n    let left = Math.min(startCanvas[0], endCanvas[0]);\r\n    let top = Math.min(startCanvas[1], endCanvas[1]);\r\n    let width = Math.abs(startCanvas[0] - endCanvas[0]);\r\n    let height = Math.abs(startCanvas[1] - endCanvas[1]);\r\n\r\n    left = clip(left, 0, imageData.width);\r\n    top = clip(top, 0, imageData.height);\r\n    width = Math.floor(Math.min(width, Math.abs(imageData.width - left)));\r\n    height = Math.floor(Math.min(height, Math.abs(imageData.height - top)));\r\n\r\n    // Get the pixel data in the rectangular region\r\n    const pixelLuminanceData = windowLevel.getLuminanceFromRegion(\r\n      imageData,\r\n      Math.round(left),\r\n      Math.round(top),\r\n      width,\r\n      height\r\n    );\r\n\r\n    // Calculate the minimum and maximum pixel values\r\n    const minMaxMean = windowLevel.calculateMinMaxMean(\r\n      pixelLuminanceData,\r\n      imageData.minPixelValue,\r\n      imageData.maxPixelValue\r\n    );\r\n\r\n    // Adjust the viewport window width and center based on the calculated values\r\n    if (this.configuration.minWindowWidth === undefined) {\r\n      this.configuration.minWindowWidth = 10;\r\n    }\r\n\r\n    const windowWidth = Math.max(\r\n      Math.abs(minMaxMean.max - minMaxMean.min),\r\n      this.configuration.minWindowWidth\r\n    );\r\n    const windowCenter = minMaxMean.mean;\r\n\r\n    const voiRange = utilities.windowLevel.toLowHighRange(\r\n      windowWidth,\r\n      windowCenter\r\n    );\r\n\r\n    viewport.setProperties({ voiRange });\r\n    viewport.render();\r\n  };\r\n\r\n  cancel = (): void => {\r\n    return null;\r\n  };\r\n\r\n  isPointNearTool = () => {\r\n    return null;\r\n  };\r\n\r\n  toolSelectedCallback = (): void => {\r\n    return null;\r\n  };\r\n\r\n  handleSelectedCallback = (): void => {\r\n    return null;\r\n  };\r\n\r\n  _activateModify = (): void => {\r\n    return null;\r\n  };\r\n\r\n  _deactivateModify = (): void => {\r\n    return null;\r\n  };\r\n}\r\n\r\nWindowLevelRegionTool.toolName = 'WindowLevelRegion';\r\nexport default WindowLevelRegionTool;\r\n","import { BaseTool } from './base';\r\nimport {\r\n  getEnabledElement,\r\n  VolumeViewport,\r\n  cache,\r\n  Types,\r\n  utilities,\r\n} from '@cornerstonejs/core';\r\nimport { EventTypes } from '../types';\r\n\r\n// Todo: should move to configuration\r\nconst DEFAULT_MULTIPLIER = 4;\r\nconst DEFAULT_IMAGE_DYNAMIC_RANGE = 1024;\r\nconst PT = 'PT';\r\n\r\n/**\r\n * WindowLevel tool manipulates the windowLevel applied to a viewport. It\r\n * provides a way to set the windowCenter and windowWidth of a viewport\r\n * by dragging mouse over the image.\r\n *\r\n */\r\nclass WindowLevelTool extends BaseTool {\r\n  static toolName;\r\n  constructor(\r\n    toolProps = {},\r\n    defaultToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\r\n    this.mouseDragCallback(evt);\r\n  }\r\n\r\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\r\n    const { element, deltaPoints } = evt.detail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine, viewport } = enabledElement;\r\n\r\n    let volumeId,\r\n      lower,\r\n      upper,\r\n      modality,\r\n      newRange,\r\n      viewportsContainingVolumeUID;\r\n    let isPreScaled = false;\r\n\r\n    const properties = viewport.getProperties();\r\n    if (viewport instanceof VolumeViewport) {\r\n      const targetId = this.getTargetId(viewport as Types.IVolumeViewport);\r\n      volumeId = utilities.getVolumeId(targetId);\r\n      viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(\r\n        volumeId,\r\n        renderingEngine.id\r\n      );\r\n      ({ lower, upper } = properties.voiRange);\r\n      const volume = cache.getVolume(volumeId);\r\n      if (!volume) {\r\n        throw new Error('Volume not found ' + volumeId);\r\n      }\r\n      modality = volume.metadata.Modality;\r\n      isPreScaled = volume.scaling && Object.keys(volume.scaling).length > 0;\r\n    } else if (properties.voiRange) {\r\n      modality = (viewport as any).modality;\r\n      ({ lower, upper } = properties.voiRange);\r\n      const { preScale = { scaled: false } } = viewport.getImageData?.() || {};\r\n      isPreScaled =\r\n        preScale.scaled && preScale.scalingParameters?.suvbw !== undefined;\r\n    } else {\r\n      throw new Error('Viewport is not a valid type');\r\n    }\r\n\r\n    // If modality is PT an the viewport is pre-scaled (SUV),\r\n    // treat it special to not include the canvas delta in\r\n    // the x direction. For other modalities, use the canvas delta in both\r\n    // directions, and if the viewport is a volumeViewport, the multiplier\r\n    // is calculate using the volume min and max.\r\n    if (modality === PT && isPreScaled) {\r\n      newRange = this.getPTScaledNewRange({\r\n        deltaPointsCanvas: deltaPoints.canvas,\r\n        lower,\r\n        upper,\r\n        clientHeight: element.clientHeight,\r\n        isPreScaled,\r\n        viewport,\r\n        volumeId,\r\n      });\r\n    } else {\r\n      newRange = this.getNewRange({\r\n        viewport,\r\n        deltaPointsCanvas: deltaPoints.canvas,\r\n        volumeId,\r\n        lower,\r\n        upper,\r\n      });\r\n    }\r\n\r\n    // If the range is not valid. Do nothing\r\n    if (newRange.lower >= newRange.upper) {\r\n      return;\r\n    }\r\n\r\n    viewport.setProperties({\r\n      voiRange: newRange,\r\n    });\r\n\r\n    viewport.render();\r\n\r\n    if (viewport instanceof VolumeViewport) {\r\n      viewportsContainingVolumeUID.forEach((vp) => {\r\n        if (viewport !== vp) {\r\n          vp.render();\r\n        }\r\n      });\r\n      return;\r\n    }\r\n  }\r\n\r\n  getPTScaledNewRange({\r\n    deltaPointsCanvas,\r\n    lower,\r\n    upper,\r\n    clientHeight,\r\n    viewport,\r\n    volumeId,\r\n    isPreScaled,\r\n  }) {\r\n    let multiplier = DEFAULT_MULTIPLIER;\r\n\r\n    if (isPreScaled) {\r\n      multiplier = 5 / clientHeight;\r\n    } else {\r\n      multiplier =\r\n        this._getMultiplierFromDynamicRange(viewport, volumeId) ||\r\n        DEFAULT_MULTIPLIER;\r\n    }\r\n\r\n    const deltaY = deltaPointsCanvas[1];\r\n    const wcDelta = deltaY * multiplier;\r\n\r\n    upper -= wcDelta;\r\n    upper = isPreScaled ? Math.max(upper, 0.1) : upper;\r\n\r\n    return { lower, upper };\r\n  }\r\n\r\n  getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }) {\r\n    const multiplier =\r\n      this._getMultiplierFromDynamicRange(viewport, volumeId) ||\r\n      DEFAULT_MULTIPLIER;\r\n\r\n    const wwDelta = deltaPointsCanvas[0] * multiplier;\r\n    const wcDelta = deltaPointsCanvas[1] * multiplier;\r\n\r\n    let { windowWidth, windowCenter } = utilities.windowLevel.toWindowLevel(\r\n      lower,\r\n      upper\r\n    );\r\n\r\n    windowWidth += wwDelta;\r\n    windowCenter += wcDelta;\r\n\r\n    windowWidth = Math.max(windowWidth, 1);\r\n\r\n    // Convert back to range\r\n    return utilities.windowLevel.toLowHighRange(windowWidth, windowCenter);\r\n  }\r\n\r\n  _getMultiplierFromDynamicRange(viewport, volumeId) {\r\n    let imageDynamicRange;\r\n\r\n    if (volumeId) {\r\n      const imageVolume = cache.getVolume(volumeId);\r\n      const { dimensions } = imageVolume;\r\n      const scalarData = imageVolume.getScalarData();\r\n      const calculatedDynamicRange = this._getImageDynamicRangeFromMiddleSlice(\r\n        scalarData,\r\n        dimensions\r\n      );\r\n      const BitsStored = imageVolume?.metadata?.BitsStored;\r\n      const metadataDynamicRange = BitsStored ? 2 ** BitsStored : Infinity;\r\n      // Burned in Pixels often use pixel values above the BitsStored.\r\n      // This results in a multiplier which is way higher than what you would\r\n      // want in practice. Thus we take the min between the metadata dynamic\r\n      // range and actual middel slice dynamic range.\r\n      imageDynamicRange = Math.min(\r\n        calculatedDynamicRange,\r\n        metadataDynamicRange\r\n      );\r\n    } else {\r\n      imageDynamicRange = this._getImageDynamicRangeFromViewport(viewport);\r\n    }\r\n\r\n    const ratio = imageDynamicRange / DEFAULT_IMAGE_DYNAMIC_RANGE;\r\n\r\n    return ratio > 1 ? Math.round(ratio) : ratio;\r\n  }\r\n\r\n  _getImageDynamicRangeFromViewport(viewport) {\r\n    const { imageData } = viewport.getImageData();\r\n    const dimensions = imageData.getDimensions();\r\n\r\n    if (imageData.getRange) {\r\n      const imageDataRange = imageData.getRange();\r\n      return imageDataRange[1] - imageDataRange[0];\r\n    }\r\n    let scalarData;\r\n    // if getScalarData is a method on imageData\r\n    if (imageData.getScalarData) {\r\n      scalarData = imageData.getScalarData();\r\n    } else {\r\n      scalarData = imageData.getPointData().getScalars().getData();\r\n    }\r\n\r\n    if (dimensions[2] !== 1) {\r\n      return this._getImageDynamicRangeFromMiddleSlice(scalarData, dimensions);\r\n    }\r\n\r\n    let range;\r\n    if (scalarData.getRange) {\r\n      range = scalarData.getRange();\r\n    } else {\r\n      const { min, max } = this._getMinMax(scalarData, scalarData.length);\r\n      range = [min, max];\r\n    }\r\n\r\n    return range[1] - range[0];\r\n  }\r\n\r\n  _getImageDynamicRangeFromMiddleSlice = (scalarData, dimensions) => {\r\n    const middleSliceIndex = Math.floor(dimensions[2] / 2);\r\n\r\n    const frameLength = dimensions[0] * dimensions[1];\r\n    let bytesPerVoxel;\r\n    let TypedArrayConstructor;\r\n\r\n    if (scalarData instanceof Float32Array) {\r\n      bytesPerVoxel = 4;\r\n      TypedArrayConstructor = Float32Array;\r\n    } else if (scalarData instanceof Uint8Array) {\r\n      bytesPerVoxel = 1;\r\n      TypedArrayConstructor = Uint8Array;\r\n    } else if (scalarData instanceof Uint16Array) {\r\n      bytesPerVoxel = 2;\r\n      TypedArrayConstructor = Uint16Array;\r\n    } else if (scalarData instanceof Int16Array) {\r\n      bytesPerVoxel = 2;\r\n      TypedArrayConstructor = Int16Array;\r\n    }\r\n\r\n    const buffer = scalarData.buffer;\r\n    const byteOffset = middleSliceIndex * frameLength * bytesPerVoxel;\r\n    const frame = new TypedArrayConstructor(buffer, byteOffset, frameLength);\r\n\r\n    const { max, min } = this._getMinMax(frame, frameLength);\r\n\r\n    return max - min;\r\n  };\r\n\r\n  private _getMinMax(frame: Uint8Array | Float32Array, frameLength: number) {\r\n    let min = Infinity;\r\n    let max = -Infinity;\r\n\r\n    for (let i = 0; i < frameLength; i++) {\r\n      const voxel = frame[i];\r\n\r\n      if (voxel < min) {\r\n        min = voxel;\r\n      }\r\n\r\n      if (voxel > max) {\r\n        max = voxel;\r\n      }\r\n    }\r\n    return { max, min };\r\n  }\r\n}\r\n\r\nWindowLevelTool.toolName = 'WindowLevel';\r\nexport default WindowLevelTool;\r\n","import { vec3 } from 'gl-matrix';\r\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\r\nimport { getEnabledElement, Types } from '@cornerstonejs/core';\r\nimport { BaseTool } from './base';\r\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\r\n\r\n/**\r\n * ZoomTool tool manipulates the camera zoom applied to a viewport. It\r\n * provides a way to set the zoom of a viewport by dragging mouse over the image.\r\n *\r\n */\r\nclass ZoomTool extends BaseTool {\r\n  static toolName;\r\n  touchDragCallback: (evt: EventTypes.InteractionEventType) => void;\r\n  mouseDragCallback: (evt: EventTypes.InteractionEventType) => void;\r\n  initialMousePosWorld: Types.Point3;\r\n  dirVec: Types.Point3;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        // whether zoom to the center of the image OR zoom to the mouse position\r\n        zoomToCenter: false,\r\n        minZoomScale: 0.1,\r\n        maxZoomScale: 30,\r\n        pinchToZoom: true,\r\n        pan: true,\r\n        invert: false,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n    this.initialMousePosWorld = [0, 0, 0];\r\n    this.dirVec = [0, 0, 0];\r\n    if (this.configuration.pinchToZoom) {\r\n      this.touchDragCallback = this._pinchCallback.bind(this);\r\n    } else {\r\n      this.touchDragCallback = this._dragCallback.bind(this);\r\n    }\r\n    this.mouseDragCallback = this._dragCallback.bind(this);\r\n  }\r\n\r\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\r\n    const eventData = evt.detail;\r\n    const { element, currentPoints } = eventData;\r\n    const worldPos = currentPoints.world;\r\n    const enabledElement = getEnabledElement(element);\r\n\r\n    const camera = enabledElement.viewport.getCamera();\r\n    const { focalPoint } = camera;\r\n\r\n    this.initialMousePosWorld = worldPos;\r\n\r\n    // The direction vector from the clicked location to the focal point\r\n    // which would act as the vector to translate the image (if zoomToCenter is false)\r\n    let dirVec = vec3.fromValues(\r\n      focalPoint[0] - worldPos[0],\r\n      focalPoint[1] - worldPos[1],\r\n      focalPoint[2] - worldPos[2]\r\n    );\r\n\r\n    dirVec = vec3.normalize(vec3.create(), dirVec);\r\n\r\n    this.dirVec = dirVec as Types.Point3;\r\n\r\n    // we should not return true here, returning true in the preMouseDownCallback\r\n    // means that the event is handled by the tool and no other methods\r\n    // can claim the event, which will result in a bug where having Zoom on primary\r\n    // and clicking on an annotation will not manipulate the annotation, but will\r\n    // instead zoom the image (which is not what we want), so we return false here\r\n    return false;\r\n  };\r\n\r\n  preTouchStartCallback = (evt: EventTypes.InteractionEventType): boolean => {\r\n    if (!this.configuration.pinchToZoom) {\r\n      return this.preMouseDownCallback(evt);\r\n    }\r\n  };\r\n\r\n  _pinchCallback(evt: EventTypes.InteractionEventType) {\r\n    const pointsList = (evt as EventTypes.TouchStartEventType).detail\r\n      .currentPointsList;\r\n\r\n    if (pointsList.length > 1) {\r\n      const { element, currentPoints } = evt.detail;\r\n      const enabledElement = getEnabledElement(element);\r\n      const { viewport } = enabledElement;\r\n      const camera = viewport.getCamera();\r\n      const worldPos = currentPoints.world;\r\n      const { focalPoint } = camera;\r\n      this.initialMousePosWorld = worldPos;\r\n      // The direction vector from the clicked location to the focal point\r\n      // which would act as the vector to translate the image (if zoomToCenter is false)\r\n      let dirVec = vec3.fromValues(\r\n        focalPoint[0] - worldPos[0],\r\n        focalPoint[1] - worldPos[1],\r\n        focalPoint[2] - worldPos[2]\r\n      );\r\n      dirVec = vec3.normalize(vec3.create(), dirVec);\r\n\r\n      this.dirVec = dirVec as Types.Point3;\r\n      if (camera.parallelProjection) {\r\n        this._dragParallelProjection(evt, viewport, camera, true);\r\n      } else {\r\n        this._dragPerspectiveProjection(evt, viewport, camera, true);\r\n      }\r\n      viewport.render();\r\n    }\r\n\r\n    if (this.configuration.pan) {\r\n      this._panCallback(evt);\r\n    }\r\n  }\r\n\r\n  // Takes ICornerstoneEvent, Mouse or Touch\r\n  _dragCallback(evt: EventTypes.InteractionEventType) {\r\n    const { element } = evt.detail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    const camera = viewport.getCamera();\r\n\r\n    if (camera.parallelProjection) {\r\n      this._dragParallelProjection(evt, viewport, camera);\r\n    } else {\r\n      this._dragPerspectiveProjection(evt, viewport, camera);\r\n    }\r\n\r\n    viewport.render();\r\n  }\r\n\r\n  _dragParallelProjection = (\r\n    evt: EventTypes.InteractionEventType,\r\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\r\n    camera: Types.ICamera,\r\n    pinch = false\r\n  ): void => {\r\n    const { element, deltaPoints } = evt.detail;\r\n    const deltaY = pinch\r\n      ? (evt as EventTypes.TouchDragEventType).detail.deltaDistance.canvas\r\n      : deltaPoints.canvas[1];\r\n\r\n    const size = [element.clientWidth, element.clientHeight];\r\n    const { parallelScale, focalPoint, position } = camera;\r\n\r\n    const zoomScale = 5 / size[1];\r\n    const k = deltaY * zoomScale * (this.configuration.invert ? -1 : 1);\r\n\r\n    const parallelScaleToSet = (1.0 - k) * parallelScale;\r\n\r\n    let focalPointToSet = focalPoint;\r\n    let positionToSet = position;\r\n\r\n    // if we're not zooming to the center, we need to adjust the focal point\r\n    // and position to set the focal point and position to the value that\r\n    // would simulate the zoom to the mouse position\r\n    if (!this.configuration.zoomToCenter) {\r\n      // Distance of the initial mouse position (world) to the focal point\r\n      // which is always the center of the canvas.\r\n      const distanceToCanvasCenter = vec3.distance(\r\n        focalPoint,\r\n        this.initialMousePosWorld\r\n      );\r\n\r\n      positionToSet = vec3.scaleAndAdd(\r\n        vec3.create(),\r\n        position,\r\n        this.dirVec,\r\n        -distanceToCanvasCenter * k\r\n      ) as Types.Point3;\r\n\r\n      focalPointToSet = vec3.scaleAndAdd(\r\n        vec3.create(),\r\n        focalPoint,\r\n        this.dirVec,\r\n        -distanceToCanvasCenter * k\r\n      ) as Types.Point3;\r\n    }\r\n\r\n    // If it is a regular GPU accelerated viewport, then parallel scale\r\n    // has a physical meaning and we can use that to determine the threshold\r\n    // Added spacing preset in case there is no imageData on viewport\r\n    const imageData = viewport.getImageData();\r\n    let spacing = [1, 1, 1];\r\n    if (imageData) {\r\n      spacing = imageData.spacing;\r\n    }\r\n\r\n    const { minZoomScale, maxZoomScale } = this.configuration;\r\n\r\n    const t = element.clientHeight * spacing[1] * 0.5;\r\n    const scale = t / parallelScaleToSet;\r\n\r\n    let cappedParallelScale = parallelScaleToSet;\r\n    let thresholdExceeded = false;\r\n\r\n    if (imageData) {\r\n      if (scale < minZoomScale) {\r\n        cappedParallelScale = t / minZoomScale;\r\n        thresholdExceeded = true;\r\n      } else if (scale >= maxZoomScale) {\r\n        cappedParallelScale = t / maxZoomScale;\r\n        thresholdExceeded = true;\r\n      }\r\n    }\r\n\r\n    viewport.setCamera({\r\n      parallelScale: cappedParallelScale,\r\n      focalPoint: thresholdExceeded ? focalPoint : focalPointToSet,\r\n      position: thresholdExceeded ? position : positionToSet,\r\n    });\r\n  };\r\n\r\n  _dragPerspectiveProjection = (\r\n    evt: EventTypes.InteractionEventType,\r\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\r\n    camera: Types.ICamera,\r\n    pinch = false\r\n  ): void => {\r\n    const { element, deltaPoints } = evt.detail;\r\n    const deltaY = pinch\r\n      ? (evt as EventTypes.TouchDragEventType).detail.deltaDistance.canvas\r\n      : deltaPoints.canvas[1];\r\n\r\n    const size = [element.clientWidth, element.clientHeight];\r\n    const { position, focalPoint, viewPlaneNormal } = camera;\r\n\r\n    const distance = vtkMath.distance2BetweenPoints(position, focalPoint);\r\n    const zoomScale = Math.sqrt(distance) / size[1];\r\n\r\n    const directionOfProjection = [\r\n      -viewPlaneNormal[0],\r\n      -viewPlaneNormal[1],\r\n      -viewPlaneNormal[2],\r\n    ];\r\n\r\n    const k = this.configuration.invert\r\n      ? deltaY / zoomScale\r\n      : deltaY * zoomScale;\r\n\r\n    let tmp = k * directionOfProjection[0];\r\n    position[0] += tmp;\r\n    focalPoint[0] += tmp;\r\n\r\n    tmp = k * directionOfProjection[1];\r\n    position[1] += tmp;\r\n    focalPoint[1] += tmp;\r\n\r\n    tmp = k * directionOfProjection[2];\r\n    position[2] += tmp;\r\n    focalPoint[2] += tmp;\r\n\r\n    viewport.setCamera({ position, focalPoint });\r\n  };\r\n\r\n  _panCallback(evt: EventTypes.InteractionEventType) {\r\n    const { element, deltaPoints } = evt.detail;\r\n    const enabledElement = getEnabledElement(element);\r\n\r\n    const deltaPointsWorld = deltaPoints.world;\r\n    const camera = enabledElement.viewport.getCamera();\r\n    const { focalPoint, position } = camera;\r\n\r\n    const updatedPosition = <Types.Point3>[\r\n      position[0] - deltaPointsWorld[0],\r\n      position[1] - deltaPointsWorld[1],\r\n      position[2] - deltaPointsWorld[2],\r\n    ];\r\n\r\n    const updatedFocalPoint = <Types.Point3>[\r\n      focalPoint[0] - deltaPointsWorld[0],\r\n      focalPoint[1] - deltaPointsWorld[1],\r\n      focalPoint[2] - deltaPointsWorld[2],\r\n    ];\r\n\r\n    enabledElement.viewport.setCamera({\r\n      focalPoint: updatedFocalPoint,\r\n      position: updatedPosition,\r\n    });\r\n    enabledElement.viewport.render();\r\n  }\r\n}\r\n\r\nZoomTool.toolName = 'Zoom';\r\nexport default ZoomTool;\r\n","import { Events } from '../../enums';\r\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { AnnotationTool } from '../base';\r\nimport throttle from '../../utilities/throttle';\r\nimport {\r\n  addAnnotation,\r\n  getAnnotations,\r\n  removeAnnotation,\r\n} from '../../stateManagement/annotation/annotationState';\r\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\r\nimport * as lineSegment from '../../utilities/math/line';\r\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\r\nimport { roundNumber } from '../../utilities';\r\n\r\nimport {\r\n  drawHandles as drawHandlesSvg,\r\n  drawLine as drawLineSvg,\r\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\r\n} from '../../drawingSvg';\r\nimport { state } from '../../store';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\nimport {\r\n  triggerAnnotationCompleted,\r\n  triggerAnnotationModified,\r\n} from '../../stateManagement/annotation/helpers/state';\r\n\r\nimport {\r\n  resetElementCursor,\r\n  hideElementCursor,\r\n} from '../../cursors/elementCursor';\r\n\r\nimport {\r\n  EventTypes,\r\n  ToolHandle,\r\n  TextBoxHandle,\r\n  PublicToolProps,\r\n  ToolProps,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\nimport { AngleAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\n\r\nclass AngleTool extends AnnotationTool {\r\n  static toolName;\r\n\r\n  public touchDragCallback: any;\r\n  public mouseDragCallback: any;\r\n  angleStartedNotYetCompleted: boolean;\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: string[];\r\n    handleIndex?: number;\r\n    movingTextBox?: boolean;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        shadow: true,\r\n        preventHandleOutsideImage: false,\r\n        getTextLines: defaultGetTextLines,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n\r\n    this._throttledCalculateCachedStats = throttle(\r\n      this._calculateCachedStats,\r\n      100,\r\n      { trailing: true }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the current imageId to create\r\n   * a Length Annotation and stores it in the annotationManager\r\n   *\r\n   * @param evt -  EventTypes.InteractionEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation = (\r\n    evt: EventTypes.InteractionEventType\r\n  ): AngleAnnotation => {\r\n    if (this.angleStartedNotYetCompleted) {\r\n      return;\r\n    }\r\n\r\n    this.angleStartedNotYetCompleted = true;\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n\r\n    const worldPos = currentPoints.world;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    hideElementCursor(element);\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    const referencedImageId = this.getReferencedImageId(\r\n      viewport,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      viewUp\r\n    );\r\n\r\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n\r\n    const annotation = {\r\n      highlighted: true,\r\n      invalidated: true,\r\n      metadata: {\r\n        toolName: this.getToolName(),\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID,\r\n        referencedImageId,\r\n        ...viewport.getViewReference({ points: [worldPos] }),\r\n      },\r\n      data: {\r\n        handles: {\r\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\r\n          activeHandleIndex: null,\r\n          textBox: {\r\n            hasMoved: false,\r\n            worldPosition: <Types.Point3>[0, 0, 0],\r\n            worldBoundingBox: {\r\n              topLeft: <Types.Point3>[0, 0, 0],\r\n              topRight: <Types.Point3>[0, 0, 0],\r\n              bottomLeft: <Types.Point3>[0, 0, 0],\r\n              bottomRight: <Types.Point3>[0, 0, 0],\r\n            },\r\n          },\r\n        },\r\n        label: '',\r\n        cachedStats: {},\r\n      },\r\n    };\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex: 1,\r\n      movingTextBox: false,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n    };\r\n    this._activateDraw(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  };\r\n\r\n  /**\r\n   * It returns if the canvas point is near the provided length annotation in the provided\r\n   * element or not. A proximity is passed to the function to determine the\r\n   * proximity of the point to the annotation in number of pixels.\r\n   *\r\n   * @param element - HTML Element\r\n   * @param annotation - Annotation\r\n   * @param canvasCoords - Canvas coordinates\r\n   * @param proximity - Proximity to tool to consider\r\n   * @returns Boolean, whether the canvas point is near tool\r\n   */\r\n  isPointNearTool = (\r\n    element: HTMLDivElement,\r\n    annotation: AngleAnnotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): boolean => {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const { data } = annotation;\r\n    const [point1, point2, point3] = data.handles.points;\r\n    const canvasPoint1 = viewport.worldToCanvas(point1);\r\n    const canvasPoint2 = viewport.worldToCanvas(point2);\r\n\r\n    const line1 = {\r\n      start: {\r\n        x: canvasPoint1[0],\r\n        y: canvasPoint1[1],\r\n      },\r\n      end: {\r\n        x: canvasPoint2[0],\r\n        y: canvasPoint2[1],\r\n      },\r\n    };\r\n\r\n    const distanceToPoint = lineSegment.distanceToPoint(\r\n      [line1.start.x, line1.start.y],\r\n      [line1.end.x, line1.end.y],\r\n      [canvasCoords[0], canvasCoords[1]]\r\n    );\r\n\r\n    if (distanceToPoint <= proximity) {\r\n      return true;\r\n    }\r\n    if (!point3) {\r\n      return false;\r\n    }\r\n\r\n    const canvasPoint3 = viewport.worldToCanvas(point3);\r\n\r\n    const line2 = {\r\n      start: {\r\n        x: canvasPoint2[0],\r\n        y: canvasPoint2[1],\r\n      },\r\n      end: {\r\n        x: canvasPoint3[0],\r\n        y: canvasPoint3[1],\r\n      },\r\n    };\r\n\r\n    const distanceToPoint2 = lineSegment.distanceToPoint(\r\n      [line2.start.x, line2.start.y],\r\n      [line2.end.x, line2.end.y],\r\n      [canvasCoords[0], canvasCoords[1]]\r\n    );\r\n\r\n    if (distanceToPoint2 <= proximity) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  toolSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: AngleAnnotation\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      movingTextBox: false,\r\n    };\r\n\r\n    this._activateModify(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  handleSelectedCallback(\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: AngleAnnotation,\r\n    handle: ToolHandle\r\n  ): void {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const { data } = annotation;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    let movingTextBox = false;\r\n    let handleIndex;\r\n\r\n    if ((handle as TextBoxHandle).worldPosition) {\r\n      movingTextBox = true;\r\n    } else {\r\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\r\n    }\r\n\r\n    // Find viewports to render on drag.\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex,\r\n      movingTextBox,\r\n    };\r\n    this._activateModify(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  }\r\n\r\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\r\n      this.editData;\r\n\r\n    const { data } = annotation;\r\n    if (newAnnotation && !hasMoved) {\r\n      // when user starts the drawing by click, and moving the mouse, instead\r\n      // of click and drag\r\n      return;\r\n    }\r\n\r\n    // If preventing new measurement means we are in the middle of an existing measurement\r\n    // we shouldn't deactivate modify or draw\r\n    if (this.angleStartedNotYetCompleted && data.handles.points.length === 2) {\r\n      // adds the last point to the measurement\r\n      this.editData.handleIndex = 2;\r\n      return;\r\n    }\r\n\r\n    this.angleStartedNotYetCompleted = false;\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateModify(element);\r\n    this._deactivateDraw(element);\r\n    resetElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    if (\r\n      this.isHandleOutsideImage &&\r\n      this.configuration.preventHandleOutsideImage\r\n    ) {\r\n      removeAnnotation(annotation.annotationUID);\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    if (newAnnotation) {\r\n      triggerAnnotationCompleted(annotation);\r\n    }\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n  };\r\n\r\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    this.isDrawing = true;\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (movingTextBox) {\r\n      // Drag mode - moving text box\r\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n\r\n      const { textBox } = data.handles;\r\n      const { worldPosition } = textBox;\r\n\r\n      worldPosition[0] += worldPosDelta[0];\r\n      worldPosition[1] += worldPosDelta[1];\r\n      worldPosition[2] += worldPosDelta[2];\r\n\r\n      textBox.hasMoved = true;\r\n    } else if (handleIndex === undefined) {\r\n      // Drag mode - moving handle\r\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n\r\n      const points = data.handles.points;\r\n\r\n      points.forEach((point) => {\r\n        point[0] += worldPosDelta[0];\r\n        point[1] += worldPosDelta[1];\r\n        point[2] += worldPosDelta[2];\r\n      });\r\n      annotation.invalidated = true;\r\n    } else {\r\n      // Move mode - after double click, and mouse move to draw\r\n      const { currentPoints } = eventDetail;\r\n      const worldPos = currentPoints.world;\r\n\r\n      data.handles.points[handleIndex] = [...worldPos];\r\n      annotation.invalidated = true;\r\n    }\r\n\r\n    this.editData.hasMoved = true;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  cancel = (element: HTMLDivElement) => {\r\n    // If it is mid-draw or mid-modify\r\n    if (this.isDrawing) {\r\n      this.isDrawing = false;\r\n      this._deactivateDraw(element);\r\n      this._deactivateModify(element);\r\n      resetElementCursor(element);\r\n\r\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\r\n      const { data } = annotation;\r\n\r\n      annotation.highlighted = false;\r\n      data.handles.activeHandleIndex = null;\r\n\r\n      const enabledElement = getEnabledElement(element);\r\n      const { renderingEngine } = enabledElement;\r\n\r\n      triggerAnnotationRenderForViewportIds(\r\n        renderingEngine,\r\n        viewportIdsToRender\r\n      );\r\n\r\n      if (newAnnotation) {\r\n        triggerAnnotationCompleted(annotation);\r\n      }\r\n\r\n      this.editData = null;\r\n      this.angleStartedNotYetCompleted = false;\r\n      return annotation.annotationUID;\r\n    }\r\n  };\r\n\r\n  _activateModify = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(\r\n      Events.MOUSE_UP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._endCallback as EventListener\r\n    );\r\n\r\n    element.addEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _deactivateModify = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(\r\n      Events.MOUSE_UP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _activateDraw = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(\r\n      Events.MOUSE_UP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_MOVE,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._endCallback as EventListener\r\n    );\r\n\r\n    element.addEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _deactivateDraw = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(\r\n      Events.MOUSE_UP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_MOVE,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._endCallback as EventListener\r\n    );\r\n\r\n    element.removeEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the length annotation in each\r\n   * request animation frame. It calculates the updated cached statistics if\r\n   * data is invalidated and cache it.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n\r\n    let annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    annotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    );\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const targetId = this.getTargetId(viewport);\r\n    const renderingEngine = viewport.getRenderingEngine();\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    // Draw SVG\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[i] as AngleAnnotation;\r\n      const { annotationUID, data } = annotation;\r\n      const { points, activeHandleIndex } = data.handles;\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\r\n        annotation,\r\n        styleSpecifier,\r\n      });\r\n\r\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\r\n      if (\r\n        !data.cachedStats[targetId] ||\r\n        data.cachedStats[targetId].angle == null\r\n      ) {\r\n        data.cachedStats[targetId] = {\r\n          angle: null,\r\n        };\r\n\r\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\r\n      } else if (annotation.invalidated) {\r\n        this._throttledCalculateCachedStats(\r\n          annotation,\r\n          renderingEngine,\r\n          enabledElement\r\n        );\r\n      }\r\n\r\n      let activeHandleCanvasCoords;\r\n\r\n      if (\r\n        !isAnnotationLocked(annotation) &&\r\n        !this.editData &&\r\n        activeHandleIndex !== null\r\n      ) {\r\n        // Not locked or creating and hovering over handle, so render handle.\r\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\r\n      }\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n\r\n      if (activeHandleCanvasCoords) {\r\n        const handleGroupUID = '0';\r\n\r\n        drawHandlesSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          handleGroupUID,\r\n          canvasCoordinates,\r\n          {\r\n            color,\r\n            lineDash,\r\n            lineWidth,\r\n          }\r\n        );\r\n      }\r\n\r\n      let lineUID = '1';\r\n      drawLineSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        lineUID,\r\n        canvasCoordinates[0],\r\n        canvasCoordinates[1],\r\n        {\r\n          color,\r\n          width: lineWidth,\r\n          lineDash,\r\n        }\r\n      );\r\n\r\n      renderStatus = true;\r\n\r\n      // Don't add textBox until annotation has 3 anchor points (actually 4 because of the center point)\r\n      if (canvasCoordinates.length !== 3) {\r\n        return renderStatus;\r\n      }\r\n\r\n      lineUID = '2';\r\n\r\n      drawLineSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        lineUID,\r\n        canvasCoordinates[1],\r\n        canvasCoordinates[2],\r\n        {\r\n          color,\r\n          width: lineWidth,\r\n          lineDash,\r\n        }\r\n      );\r\n\r\n      if (!data.cachedStats[targetId]?.angle) {\r\n        continue;\r\n      }\r\n\r\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\r\n      if (!options.visibility) {\r\n        data.handles.textBox = {\r\n          hasMoved: false,\r\n          worldPosition: <Types.Point3>[0, 0, 0],\r\n          worldBoundingBox: {\r\n            topLeft: <Types.Point3>[0, 0, 0],\r\n            topRight: <Types.Point3>[0, 0, 0],\r\n            bottomLeft: <Types.Point3>[0, 0, 0],\r\n            bottomRight: <Types.Point3>[0, 0, 0],\r\n          },\r\n        };\r\n        continue;\r\n      }\r\n\r\n      const textLines = this.configuration.getTextLines(data, targetId);\r\n\r\n      if (!data.handles.textBox.hasMoved) {\r\n        // linked to the vertex by default\r\n        const canvasTextBoxCoords = canvasCoordinates[1];\r\n\r\n        data.handles.textBox.worldPosition =\r\n          viewport.canvasToWorld(canvasTextBoxCoords);\r\n      }\r\n\r\n      const textBoxPosition = viewport.worldToCanvas(\r\n        data.handles.textBox.worldPosition\r\n      );\r\n\r\n      const textBoxUID = '1';\r\n      const boundingBox = drawLinkedTextBoxSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        textBoxUID,\r\n        textLines,\r\n        textBoxPosition,\r\n        canvasCoordinates,\r\n        {},\r\n        options\r\n      );\r\n\r\n      const { x: left, y: top, width, height } = boundingBox;\r\n\r\n      data.handles.textBox.worldBoundingBox = {\r\n        topLeft: viewport.canvasToWorld([left, top]),\r\n        topRight: viewport.canvasToWorld([left + width, top]),\r\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\r\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\r\n      };\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\r\n    const data = annotation.data;\r\n    const { element } = enabledElement.viewport;\r\n\r\n    // Until we have all three anchors bail out\r\n    if (data.handles.points.length !== 3) {\r\n      return;\r\n    }\r\n\r\n    const worldPos1 = data.handles.points[0];\r\n    const worldPos2 = data.handles.points[1];\r\n    const worldPos3 = data.handles.points[2];\r\n\r\n    const { cachedStats } = data;\r\n    const targetIds = Object.keys(cachedStats);\r\n\r\n    for (let i = 0; i < targetIds.length; i++) {\r\n      const targetId = targetIds[i];\r\n      const angle = angleBetweenLines(\r\n        [worldPos1, worldPos2],\r\n        [worldPos2, worldPos3]\r\n      );\r\n      const { dimensions, imageData } = this.getTargetIdImage(\r\n        targetId,\r\n        renderingEngine\r\n      );\r\n\r\n      // Decide if there's at least one handle is outside of image\r\n      this.isHandleOutsideImage = [worldPos1, worldPos2, worldPos3]\r\n        .map((worldPos) => csUtils.transformWorldToIndex(imageData, worldPos))\r\n        .some((index) => !csUtils.indexWithinDimensions(index, dimensions));\r\n      cachedStats[targetId] = {\r\n        angle: isNaN(angle) ? 'Incomplete Angle' : angle,\r\n      };\r\n    }\r\n\r\n    annotation.invalidated = false;\r\n\r\n    // Dispatching annotation modified\r\n    triggerAnnotationModified(annotation, element);\r\n\r\n    return cachedStats;\r\n  }\r\n}\r\n\r\nfunction defaultGetTextLines(data, targetId): string[] {\r\n  const cachedVolumeStats = data.cachedStats[targetId];\r\n  const { angle } = cachedVolumeStats;\r\n\r\n  if (angle === undefined) {\r\n    return;\r\n  }\r\n\r\n  if (isNaN(angle)) {\r\n    // The verbiage for incomplete angle is set in cachedStats\r\n    return [`${angle}`];\r\n  }\r\n\r\n  const textLines = [`${roundNumber(angle)} ${String.fromCharCode(176)}`];\r\n\r\n  return textLines;\r\n}\r\n\r\nAngleTool.toolName = 'Angle';\r\nexport default AngleTool;\r\n","import { Events } from '../../enums';\r\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport {AnnotationTool} from '../base';\r\nimport {addAnnotation, getAnnotations, removeAnnotation,} from '../../stateManagement/annotation/annotationState';\r\nimport {isAnnotationLocked} from '../../stateManagement/annotation/annotationLocking';\r\nimport * as lineSegment from '../../utilities/math/line';\r\n\r\nimport {\r\n  drawHandles as drawHandlesSvg,\r\n  drawLine as drawLineSvg,\r\n  drawLinkedTextBox as drawLinkedTextBoxSvg\r\n} from '../../drawingSvg';\r\nimport {state} from '../../store';\r\nimport {getViewportIdsWithToolToRender} from '../../utilities/viewportFilters';\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\nimport {\r\n  triggerAnnotationCompleted,\r\n  triggerAnnotationModified,\r\n} from '../../stateManagement/annotation/helpers/state';\r\n\r\nimport {hideElementCursor, resetElementCursor,} from '../../cursors/elementCursor';\r\n\r\nimport {EventTypes, PublicToolProps, SVGDrawingHelper, TextBoxHandle, ToolHandle, ToolProps,} from '../../types';\r\nimport {ArrowAnnotation} from '../../types/ToolSpecificAnnotationTypes';\r\nimport {StyleSpecifier} from '../../types/AnnotationStyle';\r\n\r\nenum AnnotationMode {\r\n  POINTS = 'points',\r\n  MOVABLE_POINTS = 'movable',\r\n  DENTASCAN = 'dentascan'\r\n}\r\n\r\nclass ArrowAnnotateTool extends AnnotationTool {\r\n  static toolName;\r\n\r\n  public touchDragCallback: any;\r\n  public mouseDragCallback: any;\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: string[];\r\n    handleIndex?: number;\r\n    movingTextBox?: boolean;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        shadow: true,\r\n        getTextCallback,\r\n        changeTextCallback,\r\n        preventHandleOutsideImage: false,\r\n        arrowFirst: false,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  removeArrowAnnotation = (uid) => {\r\n    removeAnnotation(uid)\r\n  }\r\n\r\n  addNewAnnotationWithMode = (element, points, mode, color): ArrowAnnotation => {\r\n    // Create annotation\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    hideElementCursor(element);\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    const referencedImageId = this.getReferencedImageId(\r\n        viewport,\r\n        points[0],\r\n        viewPlaneNormal,\r\n        viewUp\r\n    );\r\n\r\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n\r\n    let annotation = {\r\n      creation: true,\r\n      highlighted: true,\r\n      invalidated: true,\r\n      isLocked: mode !== AnnotationMode.MOVABLE_POINTS,\r\n      isVisible: mode !== AnnotationMode.MOVABLE_POINTS,\r\n      metadata: {\r\n        dentascan: mode === AnnotationMode.DENTASCAN,\r\n        handmade: mode === AnnotationMode.MOVABLE_POINTS,\r\n        color: color,\r\n        toolName: this.getToolName(),\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID,\r\n        referencedImageId,\r\n      },\r\n      data: {\r\n        text: '',\r\n        handles: {\r\n          points: points,\r\n          activeHandleIndex: null,\r\n          arrowFirst: false,\r\n          textBox: {\r\n            hasMoved: false,\r\n            worldPosition: <Types.Point3>[0, 0, 0],\r\n            worldBoundingBox: {\r\n              topLeft: <Types.Point3>[0, 0, 0],\r\n              topRight: <Types.Point3>[0, 0, 0],\r\n              bottomLeft: <Types.Point3>[0, 0, 0],\r\n              bottomRight: <Types.Point3>[0, 0, 0],\r\n            },\r\n          },\r\n        },\r\n        label: '',\r\n      },\r\n      annotationUID: \"\"\r\n    };\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex: 1,\r\n      movingTextBox: false,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n    };\r\n\r\n    // evt.preventDefault();\r\n\r\n    this._activateDraw(element);\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    // End annotation\r\n    annotation.data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateModify(element);\r\n    this._deactivateDraw(element);\r\n    resetElementCursor(element);\r\n\r\n    if (\r\n        this.isHandleOutsideImage &&\r\n        this.configuration.preventHandleOutsideImage\r\n    ) {\r\n      removeAnnotation(annotation.annotationUID);\r\n    }\r\n\r\n    annotation.data.text = \"\";\r\n\r\n    triggerAnnotationCompleted(annotation);\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n\r\n    return annotation;\r\n  };\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the current imageId to create\r\n   * a Length Annotation and stores it in the annotationManager\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation = (\r\n    evt: EventTypes.InteractionEventType\r\n  ): ArrowAnnotation => {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    hideElementCursor(element);\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    const referencedImageId = this.getReferencedImageId(\r\n      viewport,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      viewUp\r\n    );\r\n\r\n    const { arrowFirst } = this.configuration;\r\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n\r\n    let annotation = {\r\n      creation: true,\r\n      highlighted: true,\r\n      invalidated: true,\r\n      metadata: {\r\n        dentascan: false,\r\n        handmade: true,\r\n        color: 'rgb(0, 255, 0)',\r\n        toolName: this.getToolName(),\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID,\r\n        referencedImageId,\r\n        ...viewport.getViewReference({ points: [worldPos] }),\r\n      },\r\n      data: {\r\n        text: '',\r\n        handles: {\r\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\r\n          activeHandleIndex: null,\r\n          arrowFirst,\r\n          textBox: {\r\n            hasMoved: false,\r\n            worldPosition: <Types.Point3>[0, 0, 0],\r\n            worldBoundingBox: {\r\n              topLeft: <Types.Point3>[0, 0, 0],\r\n              topRight: <Types.Point3>[0, 0, 0],\r\n              bottomLeft: <Types.Point3>[0, 0, 0],\r\n              bottomRight: <Types.Point3>[0, 0, 0],\r\n            },\r\n          },\r\n        },\r\n        label: '',\r\n      },\r\n    };\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex: 1,\r\n      movingTextBox: false,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n    };\r\n\r\n    evt.preventDefault();\r\n\r\n    this._activateDraw(element);\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  };\r\n\r\n  /**\r\n   * It returns if the canvas point is near the provided length annotation in the provided\r\n   * element or not. A proximity is passed to the function to determine the\r\n   * proximity of the point to the annotation in number of pixels.\r\n   *\r\n   * @param element - HTML Element\r\n   * @param annotation - Annotation\r\n   * @param canvasCoords - Canvas coordinates\r\n   * @param proximity - Proximity to tool to consider\r\n   * @returns Boolean, whether the canvas point is near tool\r\n   */\r\n  isPointNearTool = (\r\n    element: HTMLDivElement,\r\n    annotation: ArrowAnnotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): boolean => {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const { data } = annotation;\r\n    const [point1, point2] = data.handles.points;\r\n    const canvasPoint1 = viewport.worldToCanvas(point1);\r\n    const canvasPoint2 = viewport.worldToCanvas(point2);\r\n\r\n    const line = {\r\n      start: {\r\n        x: canvasPoint1[0],\r\n        y: canvasPoint1[1],\r\n      },\r\n      end: {\r\n        x: canvasPoint2[0],\r\n        y: canvasPoint2[1],\r\n      },\r\n    };\r\n\r\n    const distanceToPoint = lineSegment.distanceToPoint(\r\n      [line.start.x, line.start.y],\r\n      [line.end.x, line.end.y],\r\n      [canvasCoords[0], canvasCoords[1]]\r\n    );\r\n\r\n    if (distanceToPoint <= proximity) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  toolSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: ArrowAnnotation\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      movingTextBox: false,\r\n    };\r\n\r\n    this._activateModify(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  handleSelectedCallback(\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: ArrowAnnotation,\r\n    handle: ToolHandle\r\n  ): void {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const { data } = annotation;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    let movingTextBox = false;\r\n    let handleIndex;\r\n\r\n    if ((handle as TextBoxHandle).worldPosition) {\r\n      movingTextBox = true;\r\n    } else {\r\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\r\n    }\r\n\r\n    // Find viewports to render on drag.\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex,\r\n      movingTextBox,\r\n    };\r\n    this._activateModify(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  }\r\n\r\n  _manageClickCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    // @ts-ignore\r\n    const { mouseButton } = eventDetail;\r\n    //Skip first click when new annotation if created\r\n    if(this.editData.annotation.creation){\r\n      this.editData.annotation.creation = false\r\n      return\r\n    }\r\n\r\n    //Left click\r\n    if(mouseButton === 1) {\r\n      this._prolongateCallback(evt)\r\n    }\r\n    //Right click\r\n    else if(mouseButton === 2) {\r\n      this._endCallback(evt)\r\n    }\r\n  }\r\n\r\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    // @ts-ignore\r\n    const { element, currentPoints, mouseButton } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (newAnnotation && !hasMoved) {\r\n      // when user starts the drawing by click, and moving the mouse, instead\r\n      // of click and drag\r\n      return;\r\n    }\r\n\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateModify(element);\r\n    this._deactivateDraw(element);\r\n    resetElementCursor(element);\r\n\r\n    const { viewport, renderingEngine } = getEnabledElement(element);\r\n\r\n    if (\r\n      this.isHandleOutsideImage &&\r\n      this.configuration.preventHandleOutsideImage\r\n    ) {\r\n      removeAnnotation(annotation.annotationUID);\r\n    }\r\n\r\n    if (newAnnotation) {\r\n      annotation.data.text = \"\";\r\n\r\n      triggerAnnotationCompleted(annotation);\r\n\r\n      triggerAnnotationRenderForViewportIds(\r\n        renderingEngine,\r\n        viewportIdsToRender\r\n      );\r\n    } else {\r\n      triggerAnnotationModified(annotation, element);\r\n    }\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n  };\r\n\r\n  // Prolongate polyline when left click during annotation creation\r\n  _prolongateCallback = (\r\n      evt: EventTypes.InteractionEventType,\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\r\n        this.editData;\r\n    const { data } = annotation;\r\n\r\n    data.handles.points[handleIndex] = [...worldPos];\r\n    data.handles.points.push(<Types.Point3>[...worldPos]);\r\n    this.editData.handleIndex += 1\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  }\r\n\r\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    this.isDrawing = true;\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (movingTextBox) {\r\n      // Drag mode - moving text box\r\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n\r\n      const { textBox } = data.handles;\r\n      const { worldPosition } = textBox;\r\n\r\n      worldPosition[0] += worldPosDelta[0];\r\n      worldPosition[1] += worldPosDelta[1];\r\n      worldPosition[2] += worldPosDelta[2];\r\n\r\n      textBox.hasMoved = true;\r\n    } else if (handleIndex === undefined) {\r\n      // Drag mode - moving handle\r\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n\r\n      const points = data.handles.points;\r\n\r\n      points.forEach((point) => {\r\n        point[0] += worldPosDelta[0];\r\n        point[1] += worldPosDelta[1];\r\n        point[2] += worldPosDelta[2];\r\n      });\r\n      annotation.invalidated = true;\r\n    } else {\r\n      // Move mode - after double click, and mouse move to draw\r\n      const { currentPoints } = eventDetail;\r\n      const worldPos = currentPoints.world;\r\n\r\n      data.handles.points[handleIndex] = [...worldPos];\r\n      annotation.invalidated = true;\r\n    }\r\n\r\n    this.editData.hasMoved = true;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  touchTapCallback = (evt: EventTypes.TouchTapEventType) => {\r\n    if (evt.detail.taps == 2) {\r\n      this.doubleClickCallback(evt);\r\n    }\r\n  };\r\n\r\n  doubleClickCallback = (evt: EventTypes.TouchTapEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    let annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    annotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    );\r\n\r\n    if (!annotations?.length) {\r\n      return;\r\n    }\r\n\r\n    const clickedAnnotation = annotations.find((annotation) =>\r\n      this.isPointNearTool(\r\n        element,\r\n        annotation as ArrowAnnotation,\r\n        eventDetail.currentPoints.canvas,\r\n        6 // Todo: get from configuration\r\n      )\r\n    );\r\n\r\n    if (!clickedAnnotation) {\r\n      return;\r\n    }\r\n\r\n    const annotation = clickedAnnotation as ArrowAnnotation;\r\n\r\n    this.configuration.changeTextCallback(\r\n      clickedAnnotation,\r\n      evt.detail,\r\n      this._doneChangingTextCallback.bind(this, element, annotation)\r\n    );\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n\r\n    // This double click was handled and the dialogue was displayed.\r\n    // No need for any other listener to handle it too - stopImmediatePropagation\r\n    // helps ensure this primarily so that no other listeners on the target element\r\n    // get called.\r\n    evt.stopImmediatePropagation();\r\n    evt.preventDefault();\r\n  };\r\n\r\n  _doneChangingTextCallback(element, annotation, updatedText): void {\r\n    annotation.data.text = updatedText;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    // Dispatching annotation modified\r\n    triggerAnnotationModified(annotation, element);\r\n  }\r\n\r\n  cancel = (element: HTMLDivElement) => {\r\n    // If it is mid-draw or mid-modify\r\n    if (this.isDrawing) {\r\n      this.isDrawing = false;\r\n      this._deactivateDraw(element);\r\n      this._deactivateModify(element);\r\n      resetElementCursor(element);\r\n\r\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\r\n      const { data } = annotation;\r\n\r\n      annotation.highlighted = false;\r\n      data.handles.activeHandleIndex = null;\r\n\r\n      const { renderingEngine } = getEnabledElement(element);\r\n\r\n      triggerAnnotationRenderForViewportIds(\r\n        renderingEngine,\r\n        viewportIdsToRender\r\n      );\r\n\r\n      if (newAnnotation) {\r\n        triggerAnnotationCompleted(annotation);\r\n      }\r\n\r\n      this.editData = null;\r\n      return annotation.annotationUID;\r\n    }\r\n  };\r\n\r\n  _activateModify = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(\r\n      Events.MOUSE_UP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._endCallback as EventListener\r\n    );\r\n\r\n    element.addEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _deactivateModify = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(\r\n      Events.MOUSE_UP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._endCallback as EventListener\r\n    );\r\n\r\n    element.removeEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _activateDraw = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(\r\n      Events.MOUSE_UP,\r\n      this._manageClickCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_MOVE,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._manageClickCallback as EventListener\r\n    );\r\n\r\n    element.addEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._manageClickCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_END,\r\n      this._manageClickCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _deactivateDraw = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(\r\n      Events.MOUSE_UP,\r\n      this._manageClickCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_MOVE,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._manageClickCallback as EventListener\r\n    );\r\n\r\n    element.removeEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._manageClickCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_END,\r\n      this._manageClickCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the length annotation in each\r\n   * request animation frame. It calculates the updated cached statistics if\r\n   * data is invalidated and cache it.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper,\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n\r\n    let annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    // CHANGES: Comment here in order to see arrowAnnotationTool everywhere in volume,\r\n    // not just where it was created\r\n\r\n    // annotations = this.filterInteractableAnnotationsForElement(\r\n    //   element,\r\n    //   annotations\r\n    // );\r\n    //\r\n    // if (!annotations?.length) {\r\n    //   return renderStatus;\r\n    // }\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    // Draw SVG\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[i] as ArrowAnnotation;\r\n      // Display only visible annotations\r\n      if (!annotation.isVisible) {\r\n        continue;\r\n      }\r\n\r\n      const { annotationUID, data } = annotation;\r\n      const { handles, text } = data;\r\n      const { points, activeHandleIndex } = handles;\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const { lineWidth, lineDash } = this.getAnnotationStyle({ annotation, styleSpecifier });\r\n      const color = annotation.metadata.color ? annotation.metadata.color : 'rgb(255, 255, 255)'\r\n\r\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n      let activeHandleCanvasCoords;\r\n\r\n      if (\r\n        !isAnnotationLocked(annotation) &&\r\n        !this.editData &&\r\n        activeHandleIndex !== null\r\n      ) {\r\n        // Not locked or creating and hovering over handle, so render handle.\r\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\r\n      }\r\n\r\n      const handleGroupUID = '0';\r\n\r\n      if(annotation.metadata.handmade) {\r\n        drawHandlesSvg(\r\n            svgDrawingHelper,\r\n            annotationUID,\r\n            handleGroupUID,\r\n            canvasCoordinates,\r\n            {\r\n              color,\r\n              lineWidth,\r\n            });\r\n      }\r\n\r\n      let lineUID = 1;\r\n      for(let i = 0; i < canvasCoordinates.length - 1; i++)\r\n      {\r\n        drawLineSvg(\r\n            svgDrawingHelper,\r\n            annotationUID,\r\n            `${lineUID}`,\r\n            canvasCoordinates[i],\r\n            canvasCoordinates[i + 1],\r\n            {\r\n              color,\r\n              width: lineWidth,\r\n              lineDash: lineDash,\r\n            }\r\n        );\r\n        lineUID += 3;\r\n      }\r\n\r\n\r\n      renderStatus = true;\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n\r\n      if (!text) {\r\n        continue;\r\n      }\r\n\r\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\r\n      if (!options.visibility) {\r\n        data.handles.textBox = {\r\n          hasMoved: false,\r\n          worldPosition: <Types.Point3>[0, 0, 0],\r\n          worldBoundingBox: {\r\n            topLeft: <Types.Point3>[0, 0, 0],\r\n            topRight: <Types.Point3>[0, 0, 0],\r\n            bottomLeft: <Types.Point3>[0, 0, 0],\r\n            bottomRight: <Types.Point3>[0, 0, 0],\r\n          },\r\n        };\r\n        continue;\r\n      }\r\n\r\n      // Need to update to sync w/ annotation while unlinked/not moved\r\n      if (!data.handles.textBox.hasMoved) {\r\n        // linked to the point that doesn't have the arrowhead by default\r\n        const canvasTextBoxCoords = canvasCoordinates[1];\r\n\r\n        data.handles.textBox.worldPosition =\r\n          viewport.canvasToWorld(canvasTextBoxCoords);\r\n      }\r\n\r\n      const textBoxPosition = viewport.worldToCanvas(\r\n        data.handles.textBox.worldPosition\r\n      );\r\n\r\n      const textBoxUID = '1';\r\n      const boundingBox = drawLinkedTextBoxSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        textBoxUID,\r\n        [text],\r\n        textBoxPosition,\r\n        canvasCoordinates,\r\n        {},\r\n        options\r\n      );\r\n\r\n      const { x: left, y: top, width, height } = boundingBox;\r\n\r\n      data.handles.textBox.worldBoundingBox = {\r\n        topLeft: viewport.canvasToWorld([left, top]),\r\n        topRight: viewport.canvasToWorld([left + width, top]),\r\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\r\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\r\n      };\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  _isInsideVolume(index1, index2, dimensions) {\r\n    console.log('IS INSIDE VOLUME', index1, index2, dimensions)\r\n    return (\r\n      csUtils.indexWithinDimensions(index1, dimensions) &&\r\n      csUtils.indexWithinDimensions(index2, dimensions)\r\n    );\r\n  }\r\n}\r\n\r\nfunction getTextCallback(doneChangingTextCallback) {\r\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\r\n}\r\n\r\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\r\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\r\n}\r\n\r\nArrowAnnotateTool.toolName = 'ArrowAnnotate';\r\nexport default ArrowAnnotateTool;\r\n","import { vec2, vec3 } from 'gl-matrix';\r\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\r\nimport { roundNumber } from '../../utilities';\r\nimport { AnnotationTool } from '../base';\r\nimport throttle from '../../utilities/throttle';\r\nimport {\r\n  addAnnotation,\r\n  getAnnotations,\r\n  removeAnnotation,\r\n} from '../../stateManagement/annotation/annotationState';\r\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\r\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\r\nimport {\r\n  triggerAnnotationCompleted,\r\n  triggerAnnotationModified,\r\n} from '../../stateManagement/annotation/helpers/state';\r\nimport {\r\n  drawLine as drawLineSvg,\r\n  drawHandles as drawHandlesSvg,\r\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\r\n} from '../../drawingSvg';\r\nimport { state } from '../../store';\r\nimport { Events } from '../../enums';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport * as lineSegment from '../../utilities/math/line';\r\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\r\nimport {\r\n  resetElementCursor,\r\n  hideElementCursor,\r\n} from '../../cursors/elementCursor';\r\nimport {\r\n  EventTypes,\r\n  ToolHandle,\r\n  TextBoxHandle,\r\n  PublicToolProps,\r\n  ToolProps,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\nimport { BidirectionalAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\n\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\n\r\nconst { transformWorldToIndex } = csUtils;\r\n\r\n/**\r\n * BidirectionalTool let you draw annotations that measures the length and\r\n * width at the same time in `mm` unit. It is consisted of two perpendicular lines and\r\n * a text box. You can use the BidirectionalTool in all planes even in oblique\r\n * reconstructed planes. Note: annotation tools in cornerstone3DTools exists in the exact location\r\n * in the physical 3d space, as a result, by default, all annotations that are\r\n * drawing in the same frameOfReference will get shared between viewports that\r\n * are in the same frameOfReference.\r\n *\r\n * The resulting annotation's data (statistics) and metadata (the\r\n * state of the viewport while drawing was happening) will get added to the\r\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\r\n * or similar methods.\r\n *\r\n * ```js\r\n * cornerstoneTools.addTool(BidirectionalTool)\r\n *\r\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\r\n *\r\n * toolGroup.addTool(BidirectionalTool.toolName)\r\n *\r\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\r\n *\r\n * toolGroup.setToolActive(BidirectionalTool.toolName, {\r\n *   bindings: [\r\n *    {\r\n *       mouseButton: MouseBindings.Primary, // Left Click\r\n *     },\r\n *   ],\r\n * })\r\n * ```\r\n *\r\n * Read more in the Docs section of the website.\r\n */\r\n\r\nclass BidirectionalTool extends AnnotationTool {\r\n  static toolName;\r\n\r\n  touchDragCallback: any;\r\n  mouseDragCallback: any;\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: string[];\r\n    handleIndex?: number;\r\n    movingTextBox: boolean;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n  preventHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        preventHandleOutsideImage: false,\r\n        getTextLines: defaultGetTextLines,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n\r\n    this._throttledCalculateCachedStats = throttle(\r\n      this._calculateCachedStats,\r\n      100,\r\n      { trailing: true }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the current imageId to create\r\n   * a Bidirectional Annotation and stores it in the annotationManager\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation(\r\n    evt: EventTypes.InteractionEventType\r\n  ): BidirectionalAnnotation {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    const referencedImageId = this.getReferencedImageId(\r\n      viewport,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      viewUp\r\n    );\r\n\r\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n\r\n    const annotation: BidirectionalAnnotation = {\r\n      highlighted: true,\r\n      invalidated: true,\r\n      metadata: {\r\n        toolName: this.getToolName(),\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID,\r\n        referencedImageId,\r\n        ...viewport.getViewReference({ points: [worldPos] }),\r\n      },\r\n      data: {\r\n        handles: {\r\n          points: [\r\n            // long\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            // short\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n          ],\r\n          textBox: {\r\n            hasMoved: false,\r\n            worldPosition: <Types.Point3>[0, 0, 0],\r\n            worldBoundingBox: {\r\n              topLeft: <Types.Point3>[0, 0, 0],\r\n              topRight: <Types.Point3>[0, 0, 0],\r\n              bottomLeft: <Types.Point3>[0, 0, 0],\r\n              bottomRight: <Types.Point3>[0, 0, 0],\r\n            },\r\n          },\r\n          activeHandleIndex: null,\r\n        },\r\n        label: '',\r\n        cachedStats: {},\r\n      },\r\n    };\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex: 1,\r\n      movingTextBox: false,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n    };\r\n    this._activateDraw(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  }\r\n\r\n  /**\r\n   * It returns if the canvas point is near the provided annotation in the provided\r\n   * element or not. A proximity is passed to the function to determine the\r\n   * proximity of the point to the annotation in number of pixels.\r\n   *\r\n   * @param element - HTML Element\r\n   * @param annotation - Annotation\r\n   * @param canvasCoords - Canvas coordinates\r\n   * @param proximity - Proximity to tool to consider\r\n   * @returns Boolean, whether the canvas point is near tool\r\n   */\r\n  isPointNearTool = (\r\n    element: HTMLDivElement,\r\n    annotation: BidirectionalAnnotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): boolean => {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const { data } = annotation;\r\n    const { points } = data.handles;\r\n\r\n    // Check long axis\r\n    let canvasPoint1 = viewport.worldToCanvas(points[0]);\r\n    let canvasPoint2 = viewport.worldToCanvas(points[1]);\r\n\r\n    let line = {\r\n      start: {\r\n        x: canvasPoint1[0],\r\n        y: canvasPoint1[1],\r\n      },\r\n      end: {\r\n        x: canvasPoint2[0],\r\n        y: canvasPoint2[1],\r\n      },\r\n    };\r\n\r\n    let distanceToPoint = lineSegment.distanceToPoint(\r\n      [line.start.x, line.start.y],\r\n      [line.end.x, line.end.y],\r\n      [canvasCoords[0], canvasCoords[1]]\r\n    );\r\n\r\n    if (distanceToPoint <= proximity) {\r\n      return true;\r\n    }\r\n\r\n    // Check short axis\r\n    canvasPoint1 = viewport.worldToCanvas(points[2]);\r\n    canvasPoint2 = viewport.worldToCanvas(points[3]);\r\n\r\n    line = {\r\n      start: {\r\n        x: canvasPoint1[0],\r\n        y: canvasPoint1[1],\r\n      },\r\n      end: {\r\n        x: canvasPoint2[0],\r\n        y: canvasPoint2[1],\r\n      },\r\n    };\r\n\r\n    distanceToPoint = lineSegment.distanceToPoint(\r\n      [line.start.x, line.start.y],\r\n      [line.end.x, line.end.y],\r\n      [canvasCoords[0], canvasCoords[1]]\r\n    );\r\n\r\n    if (distanceToPoint <= proximity) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Handles the toolSelected callback for bidirectional tool\r\n   * @param evt - EventTypes.MouseDownEventType\r\n   * @param annotation - Bidirectional annotation\r\n   * @param interactionType - interaction type (mouse, touch)\r\n   */\r\n  toolSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: BidirectionalAnnotation\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      movingTextBox: false,\r\n    };\r\n\r\n    this._activateModify(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  /**\r\n   * Executes the callback for when mouse has selected a handle (anchor point) of\r\n   * the bidirectional tool or when the text box has been selected.\r\n   *\r\n   * @param evt - EventTypes.MouseDownEventType\r\n   * @param annotation - Bidirectional annotation\r\n   * @param handle - Handle index or selected textBox information\r\n   * @param interactionType - interaction type (mouse, touch)\r\n   */\r\n  handleSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: BidirectionalAnnotation,\r\n    handle: ToolHandle\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const data = annotation.data;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    let movingTextBox = false;\r\n    let handleIndex;\r\n\r\n    if ((handle as TextBoxHandle).worldPosition) {\r\n      movingTextBox = true;\r\n    } else {\r\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\r\n    }\r\n\r\n    // Find viewports to render on drag.\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    hideElementCursor(element);\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex,\r\n      movingTextBox,\r\n    };\r\n    this._activateModify(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  /**\r\n   * Handles the mouse up action for the bidirectional tool. It can be at the end\r\n   * of the annotation drawing (MouseUpEventType) or when the user clicks and release\r\n   * the mouse button instantly which let to the annotation to draw without holding\r\n   * the mouse button (MouseClickEventType).\r\n   *\r\n   * @param evt - mouse up or mouse click event types\r\n   */\r\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (newAnnotation && !hasMoved) {\r\n      return;\r\n    }\r\n\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateModify(element);\r\n    this._deactivateDraw(element);\r\n\r\n    resetElementCursor(element);\r\n\r\n    const { renderingEngine } = getEnabledElement(element);\r\n\r\n    if (this.editData.handleIndex !== undefined) {\r\n      const { points } = data.handles;\r\n      const firstLineSegmentLength = vec3.distance(points[0], points[1]);\r\n      const secondLineSegmentLength = vec3.distance(points[2], points[3]);\r\n\r\n      if (secondLineSegmentLength > firstLineSegmentLength) {\r\n        // Switch points so [0,1] is the long axis and [2,3] is the short axis.\r\n\r\n        const longAxis = [[...points[2]], [...points[3]]];\r\n\r\n        const shortAxisPoint0 = [...points[0]];\r\n        const shortAxisPoint1 = [...points[1]];\r\n\r\n        // shortAxis[0->1] should be perpendicular (counter-clockwise) to longAxis[0->1]\r\n        const longAxisVector = vec2.create();\r\n\r\n        vec2.set(\r\n          longAxisVector,\r\n          longAxis[1][0] - longAxis[0][0],\r\n          longAxis[1][1] - longAxis[1][0]\r\n        );\r\n\r\n        const counterClockWisePerpendicularToLongAxis = vec2.create();\r\n\r\n        vec2.set(\r\n          counterClockWisePerpendicularToLongAxis,\r\n          -longAxisVector[1],\r\n          longAxisVector[0]\r\n        );\r\n\r\n        const currentShortAxisVector = vec2.create();\r\n\r\n        vec2.set(\r\n          currentShortAxisVector,\r\n          shortAxisPoint1[0] - shortAxisPoint0[0],\r\n          shortAxisPoint1[1] - shortAxisPoint0[0]\r\n        );\r\n\r\n        let shortAxis;\r\n\r\n        if (\r\n          vec2.dot(\r\n            currentShortAxisVector,\r\n            counterClockWisePerpendicularToLongAxis\r\n          ) > 0\r\n        ) {\r\n          shortAxis = [shortAxisPoint0, shortAxisPoint1];\r\n        } else {\r\n          shortAxis = [shortAxisPoint1, shortAxisPoint0];\r\n        }\r\n\r\n        data.handles.points = [\r\n          longAxis[0],\r\n          longAxis[1],\r\n          shortAxis[0],\r\n          shortAxis[1],\r\n        ];\r\n      }\r\n    }\r\n\r\n    if (\r\n      this.isHandleOutsideImage &&\r\n      this.configuration.preventHandleOutsideImage\r\n    ) {\r\n      removeAnnotation(annotation.annotationUID);\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    if (newAnnotation) {\r\n      triggerAnnotationCompleted(annotation);\r\n    }\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n  };\r\n\r\n  /**\r\n   * @param evt - mouse move event type or mouse drag\r\n   */\r\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    this.isDrawing = true;\r\n\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine, viewport } = enabledElement;\r\n    const { worldToCanvas } = viewport;\r\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\r\n    const { data } = annotation;\r\n\r\n    const worldPos = currentPoints.world;\r\n\r\n    // Update first move handle\r\n    data.handles.points[handleIndex] = [...worldPos];\r\n\r\n    const canvasCoordPoints = data.handles.points.map(worldToCanvas);\r\n\r\n    const canvasCoords = {\r\n      longLineSegment: {\r\n        start: {\r\n          x: canvasCoordPoints[0][0],\r\n          y: canvasCoordPoints[0][1],\r\n        },\r\n        end: {\r\n          x: canvasCoordPoints[1][0],\r\n          y: canvasCoordPoints[1][1],\r\n        },\r\n      },\r\n      shortLineSegment: {\r\n        start: {\r\n          x: canvasCoordPoints[2][0],\r\n          y: canvasCoordPoints[2][1],\r\n        },\r\n        end: {\r\n          x: canvasCoordPoints[3][0],\r\n          y: canvasCoordPoints[3][1],\r\n        },\r\n      },\r\n    };\r\n\r\n    // ~~ calculate worldPos of our short axis handles\r\n    // short axis is perpendicular to long axis, and we set its length to be 2/3 of long axis\r\n    // (meaning each)\r\n    const dist = vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);\r\n\r\n    const shortAxisDistFromCenter = dist / 3;\r\n    // Calculate long line's incline\r\n    const dx =\r\n      canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;\r\n    const dy =\r\n      canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;\r\n    const length = Math.sqrt(dx * dx + dy * dy);\r\n    const vectorX = dx / length;\r\n    const vectorY = dy / length;\r\n    // middle point between long line segment's points\r\n    const xMid =\r\n      (canvasCoords.longLineSegment.start.x +\r\n        canvasCoords.longLineSegment.end.x) /\r\n      2;\r\n    const yMid =\r\n      (canvasCoords.longLineSegment.start.y +\r\n        canvasCoords.longLineSegment.end.y) /\r\n      2;\r\n    // short points 1/3 distance from center of long points\r\n    const startX = xMid + shortAxisDistFromCenter * vectorY;\r\n    const startY = yMid - shortAxisDistFromCenter * vectorX;\r\n    const endX = xMid - shortAxisDistFromCenter * vectorY;\r\n    const endY = yMid + shortAxisDistFromCenter * vectorX;\r\n\r\n    // Update perpendicular line segment's points\r\n    data.handles.points[2] = viewport.canvasToWorld([startX, startY]);\r\n    data.handles.points[3] = viewport.canvasToWorld([endX, endY]);\r\n\r\n    annotation.invalidated = true;\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    this.editData.hasMoved = true;\r\n  };\r\n\r\n  /**\r\n   * Mouse drag to edit annotation callback\r\n   * @param evt - mouse drag event\r\n   */\r\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    this.isDrawing = true;\r\n\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n    if (movingTextBox) {\r\n      const { deltaPoints } = eventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n\r\n      const { textBox } = data.handles;\r\n      const { worldPosition } = textBox;\r\n\r\n      worldPosition[0] += worldPosDelta[0];\r\n      worldPosition[1] += worldPosDelta[1];\r\n      worldPosition[2] += worldPosDelta[2];\r\n\r\n      textBox.hasMoved = true;\r\n    } else if (handleIndex === undefined) {\r\n      // Moving tool\r\n      const { deltaPoints } = eventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n      const points = data.handles.points;\r\n\r\n      points.forEach((point) => {\r\n        point[0] += worldPosDelta[0];\r\n        point[1] += worldPosDelta[1];\r\n        point[2] += worldPosDelta[2];\r\n      });\r\n      annotation.invalidated = true;\r\n    } else {\r\n      this._dragModifyHandle(evt);\r\n      annotation.invalidated = true;\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  /**\r\n   * Mouse dragging a handle callback\r\n   * @param evt - mouse drag event\r\n   */\r\n  _dragModifyHandle = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const { annotation, handleIndex: movingHandleIndex } = this.editData;\r\n    const { data } = annotation;\r\n\r\n    // Moving handle\r\n    const worldPos = currentPoints.world;\r\n    const canvasCoordHandlesCurrent = [\r\n      viewport.worldToCanvas(data.handles.points[0]),\r\n      viewport.worldToCanvas(data.handles.points[1]),\r\n      viewport.worldToCanvas(data.handles.points[2]),\r\n      viewport.worldToCanvas(data.handles.points[3]),\r\n    ];\r\n\r\n    const firstLineSegment = {\r\n      start: {\r\n        x: canvasCoordHandlesCurrent[0][0],\r\n        y: canvasCoordHandlesCurrent[0][1],\r\n      },\r\n      end: {\r\n        x: canvasCoordHandlesCurrent[1][0],\r\n        y: canvasCoordHandlesCurrent[1][1],\r\n      },\r\n    };\r\n    const secondLineSegment = {\r\n      start: {\r\n        x: canvasCoordHandlesCurrent[2][0],\r\n        y: canvasCoordHandlesCurrent[2][1],\r\n      },\r\n      end: {\r\n        x: canvasCoordHandlesCurrent[3][0],\r\n        y: canvasCoordHandlesCurrent[3][1],\r\n      },\r\n    };\r\n\r\n    // Handle we've selected's proposed point\r\n    const proposedPoint = <Types.Point3>[...worldPos];\r\n    const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);\r\n\r\n    if (movingHandleIndex === 0 || movingHandleIndex === 1) {\r\n      const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;\r\n\r\n      const fixedHandleCanvasCoord =\r\n        canvasCoordHandlesCurrent[fixedHandleIndex];\r\n\r\n      const fixedHandleToProposedCoordVec = vec2.set(\r\n        vec2.create(),\r\n        proposedCanvasCoord[0] - fixedHandleCanvasCoord[0],\r\n        proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]\r\n      );\r\n\r\n      const fixedHandleToOldCoordVec = vec2.set(\r\n        vec2.create(),\r\n        canvasCoordHandlesCurrent[movingHandleIndex][0] -\r\n          fixedHandleCanvasCoord[0],\r\n        canvasCoordHandlesCurrent[movingHandleIndex][1] -\r\n          fixedHandleCanvasCoord[1]\r\n      );\r\n\r\n      // normalize vector\r\n      vec2.normalize(\r\n        fixedHandleToProposedCoordVec,\r\n        fixedHandleToProposedCoordVec\r\n      );\r\n      vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);\r\n\r\n      // Check whether this\r\n      const proposedFirstLineSegment = {\r\n        start: {\r\n          x: fixedHandleCanvasCoord[0],\r\n          y: fixedHandleCanvasCoord[1],\r\n        },\r\n        end: {\r\n          x: proposedCanvasCoord[0],\r\n          y: proposedCanvasCoord[1],\r\n        },\r\n      };\r\n\r\n      // Note: this is the case when we are modifying the long axis line segment\r\n      // and we make it shorter and shorter until its second half size becomes zero\r\n      // which basically means that any more modification would make the long axis\r\n      // second half disappear. In this case, we just bail out and do not update\r\n      // since we don't want to disrupt the bidirectional shape.\r\n      if (\r\n        this._movingLongAxisWouldPutItThroughShortAxis(\r\n          proposedFirstLineSegment,\r\n          secondLineSegment\r\n        )\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      const centerOfRotation = fixedHandleCanvasCoord;\r\n\r\n      const angle = this._getSignedAngle(\r\n        fixedHandleToOldCoordVec,\r\n        fixedHandleToProposedCoordVec\r\n      );\r\n\r\n      // rotate handles around the center of rotation, first translate to origin,\r\n      // then rotate, then translate back\r\n      let firstPointX = canvasCoordHandlesCurrent[2][0];\r\n      let firstPointY = canvasCoordHandlesCurrent[2][1];\r\n\r\n      let secondPointX = canvasCoordHandlesCurrent[3][0];\r\n      let secondPointY = canvasCoordHandlesCurrent[3][1];\r\n\r\n      // translate to origin\r\n      firstPointX -= centerOfRotation[0];\r\n      firstPointY -= centerOfRotation[1];\r\n\r\n      secondPointX -= centerOfRotation[0];\r\n      secondPointY -= centerOfRotation[1];\r\n\r\n      // rotate\r\n      const rotatedFirstPoint =\r\n        firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);\r\n      const rotatedFirstPointY =\r\n        firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);\r\n\r\n      const rotatedSecondPoint =\r\n        secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);\r\n      const rotatedSecondPointY =\r\n        secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);\r\n\r\n      // translate back\r\n      firstPointX = rotatedFirstPoint + centerOfRotation[0];\r\n      firstPointY = rotatedFirstPointY + centerOfRotation[1];\r\n\r\n      secondPointX = rotatedSecondPoint + centerOfRotation[0];\r\n      secondPointY = rotatedSecondPointY + centerOfRotation[1];\r\n\r\n      // update handles\r\n      const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);\r\n      const newSecondPoint = viewport.canvasToWorld([\r\n        secondPointX,\r\n        secondPointY,\r\n      ]);\r\n\r\n      // the fixed handle is the one that is not being moved so we\r\n      // don't need to update it\r\n      data.handles.points[movingHandleIndex] = proposedPoint;\r\n      data.handles.points[2] = newFirstPoint;\r\n      data.handles.points[3] = newSecondPoint;\r\n    } else {\r\n      // Translation manipulator\r\n      const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;\r\n\r\n      const canvasCoordsCurrent = {\r\n        longLineSegment: {\r\n          start: firstLineSegment.start,\r\n          end: firstLineSegment.end,\r\n        },\r\n        shortLineSegment: {\r\n          start: secondLineSegment.start,\r\n          end: secondLineSegment.end,\r\n        },\r\n      };\r\n\r\n      const longLineSegmentVec = vec2.subtract(\r\n        vec2.create(),\r\n        [\r\n          canvasCoordsCurrent.longLineSegment.end.x,\r\n          canvasCoordsCurrent.longLineSegment.end.y,\r\n        ],\r\n        [\r\n          canvasCoordsCurrent.longLineSegment.start.x,\r\n          canvasCoordsCurrent.longLineSegment.start.y,\r\n        ]\r\n      );\r\n\r\n      const longLineSegmentVecNormalized = vec2.normalize(\r\n        vec2.create(),\r\n        longLineSegmentVec\r\n      );\r\n\r\n      const proposedToCurrentVec = vec2.subtract(\r\n        vec2.create(),\r\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\r\n        [\r\n          canvasCoordHandlesCurrent[movingHandleIndex][0],\r\n          canvasCoordHandlesCurrent[movingHandleIndex][1],\r\n        ]\r\n      );\r\n\r\n      const movementLength = vec2.length(proposedToCurrentVec);\r\n\r\n      const angle = this._getSignedAngle(\r\n        longLineSegmentVecNormalized,\r\n        proposedToCurrentVec\r\n      );\r\n\r\n      const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;\r\n\r\n      const newTranslatedPoint = vec2.scaleAndAdd(\r\n        vec2.create(),\r\n        [\r\n          canvasCoordHandlesCurrent[translateHandleIndex][0],\r\n          canvasCoordHandlesCurrent[translateHandleIndex][1],\r\n        ],\r\n        longLineSegmentVecNormalized,\r\n        movementAlongLineSegmentLength\r\n      );\r\n\r\n      // don't update if it passes through the other line segment\r\n      if (\r\n        this._movingLongAxisWouldPutItThroughShortAxis(\r\n          {\r\n            start: {\r\n              x: proposedCanvasCoord[0],\r\n              y: proposedCanvasCoord[1],\r\n            },\r\n            end: {\r\n              x: newTranslatedPoint[0],\r\n              y: newTranslatedPoint[1],\r\n            },\r\n          },\r\n          {\r\n            start: {\r\n              x: canvasCoordsCurrent.longLineSegment.start.x,\r\n              y: canvasCoordsCurrent.longLineSegment.start.y,\r\n            },\r\n            end: {\r\n              x: canvasCoordsCurrent.longLineSegment.end.x,\r\n              y: canvasCoordsCurrent.longLineSegment.end.y,\r\n            },\r\n          }\r\n        )\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      const intersectionPoint = lineSegment.intersectLine(\r\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\r\n        [newTranslatedPoint[0], newTranslatedPoint[1]],\r\n        [firstLineSegment.start.x, firstLineSegment.start.y],\r\n        [firstLineSegment.end.x, firstLineSegment.end.y]\r\n      );\r\n\r\n      // don't update if it doesn't intersect\r\n      if (!intersectionPoint) {\r\n        return;\r\n      }\r\n\r\n      data.handles.points[translateHandleIndex] = viewport.canvasToWorld(\r\n        newTranslatedPoint as Types.Point2\r\n      );\r\n      data.handles.points[movingHandleIndex] = proposedPoint;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Cancels an ongoing drawing of a bidirectional annotation\r\n   * @param element - HTML Element\r\n   */\r\n  cancel = (element: HTMLDivElement) => {\r\n    // If it is mid-draw or mid-modify\r\n    if (this.isDrawing) {\r\n      this.isDrawing = false;\r\n      this._deactivateDraw(element);\r\n      this._deactivateModify(element);\r\n      resetElementCursor(element);\r\n\r\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\r\n      const { data } = annotation;\r\n\r\n      annotation.highlighted = false;\r\n      data.handles.activeHandleIndex = null;\r\n\r\n      const { renderingEngine } = getEnabledElement(element);\r\n\r\n      triggerAnnotationRenderForViewportIds(\r\n        renderingEngine,\r\n        viewportIdsToRender\r\n      );\r\n\r\n      if (newAnnotation) {\r\n        triggerAnnotationCompleted(annotation);\r\n      }\r\n\r\n      this.editData = null;\r\n      return annotation.annotationUID;\r\n    }\r\n  };\r\n\r\n  _activateDraw = (element) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\r\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.addEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragDrawCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _deactivateDraw = (element) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\r\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.removeEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragDrawCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _activateModify = (element) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.addEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragModifyCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _deactivateModify = (element) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.removeEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragModifyCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the bidirectional annotation in each\r\n   * request animation frame. It calculates the updated cached statistics if\r\n   * data is invalidated and cache it.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = true;\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n    let annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    annotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    );\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const targetId = this.getTargetId(viewport);\r\n\r\n    const renderingEngine = viewport.getRenderingEngine();\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[i] as BidirectionalAnnotation;\r\n      const { annotationUID, data } = annotation;\r\n      const { points, activeHandleIndex } = data.handles;\r\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\r\n        annotation,\r\n        styleSpecifier,\r\n      });\r\n\r\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\r\n      // force to recalculate the stats from the points\r\n      if (\r\n        !data.cachedStats[targetId] ||\r\n        data.cachedStats[targetId].unit == null\r\n      ) {\r\n        data.cachedStats[targetId] = {\r\n          length: null,\r\n          width: null,\r\n          unit: null,\r\n        };\r\n\r\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\r\n      } else if (annotation.invalidated) {\r\n        this._throttledCalculateCachedStats(\r\n          annotation,\r\n          renderingEngine,\r\n          enabledElement\r\n        );\r\n      }\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n\r\n      let activeHandleCanvasCoords;\r\n\r\n      if (!isAnnotationVisible(annotationUID)) {\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        !isAnnotationLocked(annotation) &&\r\n        !this.editData &&\r\n        activeHandleIndex !== null\r\n      ) {\r\n        // Not locked or creating and hovering over handle, so render handle.\r\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\r\n      }\r\n\r\n      if (activeHandleCanvasCoords) {\r\n        const handleGroupUID = '0';\r\n\r\n        drawHandlesSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          handleGroupUID,\r\n          activeHandleCanvasCoords,\r\n          {\r\n            color,\r\n          }\r\n        );\r\n      }\r\n\r\n      const dataId1 = `${annotationUID}-line-1`;\r\n      const dataId2 = `${annotationUID}-line-2`;\r\n\r\n      const lineUID = '0';\r\n      drawLineSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        lineUID,\r\n        canvasCoordinates[0],\r\n        canvasCoordinates[1],\r\n        {\r\n          color,\r\n          lineDash,\r\n          lineWidth,\r\n          shadow,\r\n        },\r\n        dataId1\r\n      );\r\n\r\n      const secondLineUID = '1';\r\n      drawLineSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        secondLineUID,\r\n        canvasCoordinates[2],\r\n        canvasCoordinates[3],\r\n        {\r\n          color,\r\n          lineDash,\r\n          lineWidth,\r\n          shadow,\r\n        },\r\n        dataId2\r\n      );\r\n\r\n      renderStatus = true;\r\n\r\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\r\n      if (!options.visibility) {\r\n        data.handles.textBox = {\r\n          hasMoved: false,\r\n          worldPosition: <Types.Point3>[0, 0, 0],\r\n          worldBoundingBox: {\r\n            topLeft: <Types.Point3>[0, 0, 0],\r\n            topRight: <Types.Point3>[0, 0, 0],\r\n            bottomLeft: <Types.Point3>[0, 0, 0],\r\n            bottomRight: <Types.Point3>[0, 0, 0],\r\n          },\r\n        };\r\n        continue;\r\n      }\r\n\r\n      const textLines = this.configuration.getTextLines(data, targetId);\r\n      if (!textLines || textLines.length === 0) {\r\n        continue;\r\n      }\r\n\r\n      let canvasTextBoxCoords;\r\n\r\n      if (!data.handles.textBox.hasMoved) {\r\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\r\n\r\n        data.handles.textBox.worldPosition =\r\n          viewport.canvasToWorld(canvasTextBoxCoords);\r\n      }\r\n\r\n      const textBoxPosition = viewport.worldToCanvas(\r\n        data.handles.textBox.worldPosition\r\n      );\r\n\r\n      const textBoxUID = '1';\r\n      const boundingBox = drawLinkedTextBoxSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        textBoxUID,\r\n        textLines,\r\n        textBoxPosition,\r\n        canvasCoordinates,\r\n        {},\r\n        options\r\n      );\r\n\r\n      const { x: left, y: top, width, height } = boundingBox;\r\n\r\n      data.handles.textBox.worldBoundingBox = {\r\n        topLeft: viewport.canvasToWorld([left, top]),\r\n        topRight: viewport.canvasToWorld([left + width, top]),\r\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\r\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\r\n      };\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  _movingLongAxisWouldPutItThroughShortAxis = (\r\n    firstLineSegment,\r\n    secondLineSegment\r\n  ) => {\r\n    const vectorInSecondLineDirection = vec2.create();\r\n\r\n    vec2.set(\r\n      vectorInSecondLineDirection,\r\n      secondLineSegment.end.x - secondLineSegment.start.x,\r\n      secondLineSegment.end.y - secondLineSegment.start.y\r\n    );\r\n\r\n    vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);\r\n\r\n    const extendedSecondLineSegment = {\r\n      start: {\r\n        x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,\r\n        y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,\r\n      },\r\n      end: {\r\n        x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,\r\n        y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,\r\n      },\r\n    };\r\n\r\n    // Add some buffer in the secondLineSegment when finding the proposedIntersectionPoint\r\n    // Of points to stop us getting stack when rotating quickly.\r\n\r\n    const proposedIntersectionPoint = lineSegment.intersectLine(\r\n      [extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y],\r\n      [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y],\r\n      [firstLineSegment.start.x, firstLineSegment.start.y],\r\n      [firstLineSegment.end.x, firstLineSegment.end.y]\r\n    );\r\n\r\n    const wouldPutThroughShortAxis = !proposedIntersectionPoint;\r\n\r\n    return wouldPutThroughShortAxis;\r\n  };\r\n\r\n  _calculateLength(pos1, pos2) {\r\n    const dx = pos1[0] - pos2[0];\r\n    const dy = pos1[1] - pos2[1];\r\n    const dz = pos1[2] - pos2[2];\r\n\r\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\r\n  }\r\n\r\n  _calculateCachedStats = (annotation, renderingEngine, enabledElement) => {\r\n    const { data } = annotation;\r\n    const { element } = enabledElement.viewport;\r\n\r\n    const worldPos1 = data.handles.points[0];\r\n    const worldPos2 = data.handles.points[1];\r\n    const worldPos3 = data.handles.points[2];\r\n    const worldPos4 = data.handles.points[3];\r\n\r\n    const { cachedStats } = data;\r\n    const targetIds = Object.keys(cachedStats);\r\n\r\n    for (let i = 0; i < targetIds.length; i++) {\r\n      const targetId = targetIds[i];\r\n\r\n      const image = this.getTargetIdImage(targetId, renderingEngine);\r\n\r\n      // If image does not exists for the targetId, skip. This can be due\r\n      // to various reasons such as if the target was a volumeViewport, and\r\n      // the volumeViewport has been decached in the meantime.\r\n      if (!image) {\r\n        continue;\r\n      }\r\n\r\n      const { imageData, dimensions } = image;\r\n      const index1 = transformWorldToIndex(imageData, worldPos1);\r\n      const index2 = transformWorldToIndex(imageData, worldPos2);\r\n      const index3 = transformWorldToIndex(imageData, worldPos3);\r\n      const index4 = transformWorldToIndex(imageData, worldPos4);\r\n\r\n      const handles1 = [index1, index2];\r\n      const handles2 = [index3, index4];\r\n\r\n      const { scale: scale1, units: units1 } = getCalibratedLengthUnitsAndScale(\r\n        image,\r\n        handles1\r\n      );\r\n\r\n      const { scale: scale2, units: units2 } = getCalibratedLengthUnitsAndScale(\r\n        image,\r\n        handles2\r\n      );\r\n\r\n      const dist1 = this._calculateLength(worldPos1, worldPos2) / scale1;\r\n      const dist2 = this._calculateLength(worldPos3, worldPos4) / scale2;\r\n      const length = dist1 > dist2 ? dist1 : dist2;\r\n      const width = dist1 > dist2 ? dist2 : dist1;\r\n\r\n      const lengthUnit = dist1 > dist2 ? units1 : units2;\r\n      const widthUnit = dist1 > dist2 ? units2 : units1;\r\n\r\n      this._isInsideVolume(index1, index2, index3, index4, dimensions)\r\n        ? (this.isHandleOutsideImage = false)\r\n        : (this.isHandleOutsideImage = true);\r\n\r\n      cachedStats[targetId] = {\r\n        length,\r\n        width,\r\n        unit: units1,\r\n        lengthUnit,\r\n        widthUnit,\r\n      };\r\n    }\r\n\r\n    annotation.invalidated = false;\r\n\r\n    // Dispatching annotation modified\r\n    triggerAnnotationModified(annotation, element);\r\n\r\n    return cachedStats;\r\n  };\r\n\r\n  _isInsideVolume = (index1, index2, index3, index4, dimensions): boolean => {\r\n    return (\r\n      csUtils.indexWithinDimensions(index1, dimensions) &&\r\n      csUtils.indexWithinDimensions(index2, dimensions) &&\r\n      csUtils.indexWithinDimensions(index3, dimensions) &&\r\n      csUtils.indexWithinDimensions(index4, dimensions)\r\n    );\r\n  };\r\n\r\n  _getSignedAngle = (vector1, vector2) => {\r\n    return Math.atan2(\r\n      vector1[0] * vector2[1] - vector1[1] * vector2[0],\r\n      vector1[0] * vector2[0] + vector1[1] * vector2[1]\r\n    );\r\n  };\r\n}\r\n\r\nfunction defaultGetTextLines(data, targetId): string[] {\r\n  const { cachedStats, label } = data;\r\n  const { length, width, unit, lengthUnit, widthUnit } = cachedStats[targetId];\r\n\r\n  const textLines = [];\r\n  if (label) {\r\n    textLines.push(label);\r\n  }\r\n  if (length === undefined) {\r\n    return textLines;\r\n  }\r\n\r\n  // spaceBetweenSlices & pixelSpacing &\r\n  // magnitude in each direction? Otherwise, this is \"px\"?\r\n  textLines.push(\r\n    `L: ${roundNumber(length)} ${lengthUnit || unit}`,\r\n    `W: ${roundNumber(width)} ${widthUnit || unit}`\r\n  );\r\n\r\n  return textLines;\r\n}\r\n\r\nBidirectionalTool.toolName = 'Bidirectional';\r\nexport default BidirectionalTool;\r\n","import { AnnotationTool } from '../base';\r\n\r\nimport {\r\n  getEnabledElement,\r\n  VolumeViewport,\r\n  utilities as csUtils,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { getCalibratedAspect } from '../../utilities/getCalibratedUnits';\r\nimport { getCalibratedLengthUnitsAndScale, roundNumber } from '../../utilities';\r\nimport throttle from '../../utilities/throttle';\r\nimport {\r\n  addAnnotation,\r\n  getAnnotations,\r\n  removeAnnotation,\r\n} from '../../stateManagement/annotation/annotationState';\r\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\r\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\r\nimport {\r\n  triggerAnnotationCompleted,\r\n  triggerAnnotationModified,\r\n} from '../../stateManagement/annotation/helpers/state';\r\nimport {\r\n  drawCircle as drawCircleSvg,\r\n  drawHandles as drawHandlesSvg,\r\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\r\n} from '../../drawingSvg';\r\nimport { state } from '../../store';\r\nimport { Events } from '../../enums';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\r\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\r\nimport {\r\n  resetElementCursor,\r\n  hideElementCursor,\r\n} from '../../cursors/elementCursor';\r\nimport {\r\n  EventTypes,\r\n  ToolHandle,\r\n  TextBoxHandle,\r\n  PublicToolProps,\r\n  ToolProps,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\nimport { CircleROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\n\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\nimport { pointInShapeCallback } from '../../utilities';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\r\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\r\nimport {\r\n  getCanvasCircleCorners,\r\n  getCanvasCircleRadius,\r\n} from '../../utilities/math/circle';\r\nimport { pointInEllipse } from '../../utilities/math/ellipse';\r\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\r\n\r\nconst { transformWorldToIndex } = csUtils;\r\n\r\n/**\r\n * CircleROITool let you draw annotations that measures the statistics\r\n * such as area, max, mean and stdDev of an elliptical region of interest.\r\n * You can use CircleROITool in all perpendicular views (axial, sagittal, coronal).\r\n * Note: annotation tools in cornerstone3DTools exists in the exact location\r\n * in the physical 3d space, as a result, by default, all annotations that are\r\n * drawing in the same frameOfReference will get shared between viewports that\r\n * are in the same frameOfReference. Circle tool's text box lines are dynamically\r\n * generated based on the viewport's underlying Modality. For instance, if\r\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\r\n * and if the viewport is displaying PET, the text box will show the statistics in\r\n * SUV units.\r\n *\r\n * The resulting annotation's data (statistics) and metadata (the\r\n * state of the viewport while drawing was happening) will get added to the\r\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\r\n * or similar methods.\r\n *\r\n * Changing tool configuration (see below) you can make the tool to draw the center\r\n * point circle with a given radius.\r\n *\r\n * ```js\r\n * cornerstoneTools.addTool(CircleROITool)\r\n *\r\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\r\n *\r\n * toolGroup.addTool(CircleROITool.toolName)\r\n *\r\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\r\n *\r\n * toolGroup.setToolActive(CircleROITool.toolName, {\r\n *   bindings: [\r\n *    {\r\n *       mouseButton: MouseBindings.Primary, // Left Click\r\n *     },\r\n *   ],\r\n * })\r\n *\r\n * // draw a circle at the center point with 4px radius.\r\n * toolGroup.setToolConfiguration(CircleROITool.toolName, {\r\n *   centerPointRadius: 4,\r\n * });\r\n * ```\r\n *\r\n * Read more in the Docs section of the website.\r\n */\r\n\r\nclass CircleROITool extends AnnotationTool {\r\n  static toolName;\r\n\r\n  touchDragCallback: any;\r\n  mouseDragCallback: any;\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: Array<string>;\r\n    handleIndex?: number;\r\n    movingTextBox?: boolean;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage = false;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        shadow: true,\r\n        preventHandleOutsideImage: false,\r\n        // Radius of the circle to draw  at the center point of the circle.\r\n        // Set this zero(0) in order not to draw the circle.\r\n        centerPointRadius: 0,\r\n        getTextLines: defaultGetTextLines,\r\n        statsCalculator: BasicStatsCalculator,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n\r\n    this._throttledCalculateCachedStats = throttle(\r\n      this._calculateCachedStats,\r\n      100,\r\n      { trailing: true }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the current imageId to create\r\n   * a CircleROI Annotation and stores it in the annotationManager\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation = (\r\n    evt: EventTypes.InteractionEventType\r\n  ): CircleROIAnnotation => {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    const referencedImageId = this.getReferencedImageId(\r\n      viewport,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      viewUp\r\n    );\r\n\r\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n\r\n    const annotation = {\r\n      highlighted: true,\r\n      invalidated: true,\r\n      metadata: {\r\n        toolName: this.getToolName(),\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID,\r\n        referencedImageId,\r\n        ...viewport.getViewReference({ points: [worldPos] }),\r\n      },\r\n      data: {\r\n        label: '',\r\n        handles: {\r\n          textBox: {\r\n            hasMoved: false,\r\n            worldPosition: <Types.Point3>[0, 0, 0],\r\n            worldBoundingBox: {\r\n              topLeft: <Types.Point3>[0, 0, 0],\r\n              topRight: <Types.Point3>[0, 0, 0],\r\n              bottomLeft: <Types.Point3>[0, 0, 0],\r\n              bottomRight: <Types.Point3>[0, 0, 0],\r\n            },\r\n          },\r\n          points: [[...worldPos], [...worldPos]] as [\r\n            Types.Point3, // center\r\n            Types.Point3 // end\r\n          ],\r\n          activeHandleIndex: null,\r\n        },\r\n        cachedStats: {},\r\n      },\r\n    };\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n    };\r\n    this._activateDraw(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  };\r\n\r\n  /**\r\n   * It returns if the canvas point is near the provided annotation in the provided\r\n   * element or not. A proximity is passed to the function to determine the\r\n   * proximity of the point to the annotation in number of pixels.\r\n   *\r\n   * @param element - HTML Element\r\n   * @param annotation - Annotation\r\n   * @param canvasCoords - Canvas coordinates\r\n   * @param proximity - Proximity to tool to consider\r\n   * @returns Boolean, whether the canvas point is near tool\r\n   */\r\n  isPointNearTool = (\r\n    element: HTMLDivElement,\r\n    annotation: CircleROIAnnotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): boolean => {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    const { data } = annotation;\r\n    const { points } = data.handles;\r\n\r\n    // For some reason Typescript doesn't understand this, so we need to be\r\n    // more specific about the type\r\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p)) as [\r\n      Types.Point2,\r\n      Types.Point2\r\n    ];\r\n\r\n    const radius = getCanvasCircleRadius(canvasCoordinates);\r\n    const radiusPoint = getCanvasCircleRadius([\r\n      canvasCoordinates[0],\r\n      canvasCoords,\r\n    ]);\r\n\r\n    if (Math.abs(radiusPoint - radius) < proximity / 2) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  toolSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: CircleROIAnnotation\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      movingTextBox: false,\r\n    };\r\n\r\n    hideElementCursor(element);\r\n\r\n    this._activateModify(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  handleSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: CircleROIAnnotation,\r\n    handle: ToolHandle\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const { data } = annotation;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    let movingTextBox = false;\r\n    let handleIndex;\r\n\r\n    if ((handle as TextBoxHandle).worldPosition) {\r\n      movingTextBox = true;\r\n    } else {\r\n      const { points } = data.handles;\r\n\r\n      handleIndex = points.findIndex((p) => p === handle);\r\n    }\r\n\r\n    // Find viewports to render on drag.\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex,\r\n      movingTextBox,\r\n    };\r\n    this._activateModify(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (newAnnotation && !hasMoved) {\r\n      return;\r\n    }\r\n\r\n    // Circle ROI tool should reset its highlight to false on mouse up (as opposed\r\n    // to other tools that keep it highlighted until the user moves. The reason\r\n    // is that we use top-left and bottom-right handles to define the circle,\r\n    // and they are by definition not in the circle on mouse up.\r\n    annotation.highlighted = false;\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateModify(element);\r\n    this._deactivateDraw(element);\r\n\r\n    resetElementCursor(element);\r\n\r\n    const { renderingEngine } = getEnabledElement(element);\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n\r\n    if (\r\n      this.isHandleOutsideImage &&\r\n      this.configuration.preventHandleOutsideImage\r\n    ) {\r\n      removeAnnotation(annotation.annotationUID);\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    if (newAnnotation) {\r\n      triggerAnnotationCompleted(annotation);\r\n    }\r\n  };\r\n\r\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    this.isDrawing = true;\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const { currentPoints } = eventDetail;\r\n    const currentCanvasPoints = currentPoints.canvas;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine, viewport } = enabledElement;\r\n    const { canvasToWorld } = viewport;\r\n\r\n    //////\r\n    const { annotation, viewportIdsToRender } = this.editData;\r\n    const { data } = annotation;\r\n\r\n    data.handles.points = [\r\n      data.handles.points[0], // center stays\r\n      canvasToWorld(currentCanvasPoints), // end point moves (changing radius)\r\n    ];\r\n\r\n    annotation.invalidated = true;\r\n\r\n    this.editData.hasMoved = true;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    this.isDrawing = true;\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (movingTextBox) {\r\n      const { deltaPoints } = eventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n\r\n      const { textBox } = data.handles;\r\n      const { worldPosition } = textBox;\r\n\r\n      worldPosition[0] += worldPosDelta[0];\r\n      worldPosition[1] += worldPosDelta[1];\r\n      worldPosition[2] += worldPosDelta[2];\r\n\r\n      textBox.hasMoved = true;\r\n    } else if (handleIndex === undefined) {\r\n      // Moving tool\r\n      const { deltaPoints } = eventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n\r\n      const points = data.handles.points;\r\n\r\n      points.forEach((point) => {\r\n        point[0] += worldPosDelta[0];\r\n        point[1] += worldPosDelta[1];\r\n        point[2] += worldPosDelta[2];\r\n      });\r\n      annotation.invalidated = true;\r\n    } else {\r\n      this._dragHandle(evt);\r\n      annotation.invalidated = true;\r\n    }\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { canvasToWorld, worldToCanvas } = enabledElement.viewport;\r\n\r\n    const { annotation, handleIndex } = this.editData;\r\n    const { data } = annotation;\r\n    const { points } = data.handles;\r\n\r\n    const canvasCoordinates = points.map((p) => worldToCanvas(p));\r\n\r\n    // Move current point in that direction.\r\n    // Move other points in opposite direction.\r\n\r\n    const { currentPoints } = eventDetail;\r\n    const currentCanvasPoints = currentPoints.canvas;\r\n\r\n    if (handleIndex === 0) {\r\n      // Dragging center, move the circle ROI\r\n      const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];\r\n      const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];\r\n\r\n      const canvasCenter = currentCanvasPoints as Types.Point2;\r\n      const canvasEnd = <Types.Point2>[\r\n        canvasCoordinates[1][0] + dXCanvas,\r\n        canvasCoordinates[1][1] + dYCanvas,\r\n      ];\r\n\r\n      points[0] = canvasToWorld(canvasCenter);\r\n      points[1] = canvasToWorld(canvasEnd);\r\n    } else {\r\n      // Dragging end point, center stays\r\n      points[1] = canvasToWorld(currentCanvasPoints);\r\n    }\r\n  };\r\n\r\n  cancel = (element: HTMLDivElement) => {\r\n    // If it is mid-draw or mid-modify\r\n    if (this.isDrawing) {\r\n      this.isDrawing = false;\r\n      this._deactivateDraw(element);\r\n      this._deactivateModify(element);\r\n      resetElementCursor(element);\r\n\r\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\r\n      const { data } = annotation;\r\n\r\n      annotation.highlighted = false;\r\n      data.handles.activeHandleIndex = null;\r\n\r\n      const { renderingEngine } = getEnabledElement(element);\r\n\r\n      triggerAnnotationRenderForViewportIds(\r\n        renderingEngine,\r\n        viewportIdsToRender\r\n      );\r\n\r\n      if (newAnnotation) {\r\n        triggerAnnotationCompleted(annotation);\r\n      }\r\n\r\n      this.editData = null;\r\n      return annotation.annotationUID;\r\n    }\r\n  };\r\n\r\n  _activateModify = (element) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\r\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  _deactivateModify = (element) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\r\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  _activateDraw = (element) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\r\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\r\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  _deactivateDraw = (element) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\r\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\r\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the circleROI annotation in each\r\n   * request animation frame. It calculates the updated cached statistics if\r\n   * data is invalidated and cache it.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n\r\n    let annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    annotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    );\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const targetId = this.getTargetId(viewport);\r\n\r\n    const renderingEngine = viewport.getRenderingEngine();\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[i] as CircleROIAnnotation;\r\n      const { annotationUID, data } = annotation;\r\n      const { handles } = data;\r\n      const { points, activeHandleIndex } = handles;\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\r\n        annotation,\r\n        styleSpecifier,\r\n      });\r\n\r\n      const canvasCoordinates = points.map((p) =>\r\n        viewport.worldToCanvas(p)\r\n      ) as [Types.Point2, Types.Point2];\r\n      const center = canvasCoordinates[0];\r\n      const radius = getCanvasCircleRadius(canvasCoordinates);\r\n      const canvasCorners = getCanvasCircleCorners(canvasCoordinates);\r\n\r\n      const { centerPointRadius } = this.configuration;\r\n\r\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\r\n      // force to recalculate the stats from the points\r\n      if (\r\n        !data.cachedStats[targetId] ||\r\n        data.cachedStats[targetId].areaUnit == null\r\n      ) {\r\n        data.cachedStats[targetId] = {\r\n          Modality: null,\r\n          area: null,\r\n          max: null,\r\n          mean: null,\r\n          stdDev: null,\r\n          areaUnit: null,\r\n          radius: null,\r\n          radiusUnit: null,\r\n          perimeter: null,\r\n        };\r\n\r\n        this._calculateCachedStats(\r\n          annotation,\r\n          viewport,\r\n          renderingEngine,\r\n          enabledElement\r\n        );\r\n      } else if (annotation.invalidated) {\r\n        this._throttledCalculateCachedStats(\r\n          annotation,\r\n          viewport,\r\n          renderingEngine,\r\n          enabledElement\r\n        );\r\n        // If the invalidated data is as a result of volumeViewport manipulation\r\n        // of the tools, we need to invalidate the related viewports data, so that\r\n        // when scrolling to the related slice in which the tool were manipulated\r\n        // we re-render the correct tool position. This is due to stackViewport\r\n        // which doesn't have the full volume at each time, and we are only working\r\n        // on one slice at a time.\r\n        if (viewport instanceof VolumeViewport) {\r\n          const { referencedImageId } = annotation.metadata;\r\n\r\n          // invalidate all the relevant stackViewports if they are not\r\n          // at the referencedImageId\r\n          for (const targetId in data.cachedStats) {\r\n            if (targetId.startsWith('imageId')) {\r\n              const viewports = renderingEngine.getStackViewports();\r\n\r\n              const invalidatedStack = viewports.find((vp) => {\r\n                // The stack viewport that contains the imageId but is not\r\n                // showing it currently\r\n                const referencedImageURI =\r\n                  csUtils.imageIdToURI(referencedImageId);\r\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\r\n                const currentImageURI = csUtils.imageIdToURI(\r\n                  vp.getCurrentImageId()\r\n                );\r\n                return hasImageURI && currentImageURI !== referencedImageURI;\r\n              });\r\n\r\n              if (invalidatedStack) {\r\n                delete data.cachedStats[targetId];\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n\r\n      let activeHandleCanvasCoords;\r\n\r\n      if (!isAnnotationVisible(annotationUID)) {\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        !isAnnotationLocked(annotation) &&\r\n        !this.editData &&\r\n        activeHandleIndex !== null\r\n      ) {\r\n        // Not locked or creating and hovering over handle, so render handle.\r\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\r\n      }\r\n\r\n      if (activeHandleCanvasCoords) {\r\n        const handleGroupUID = '0';\r\n        drawHandlesSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          handleGroupUID,\r\n          activeHandleCanvasCoords,\r\n          {\r\n            color,\r\n          }\r\n        );\r\n      }\r\n\r\n      const dataId = `${annotationUID}-circle`;\r\n      const circleUID = '0';\r\n      drawCircleSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        circleUID,\r\n        center,\r\n        radius,\r\n        {\r\n          color,\r\n          lineDash,\r\n          lineWidth,\r\n        },\r\n        dataId\r\n      );\r\n\r\n      // draw center point, if \"centerPointRadius\" configuration is valid.\r\n      if (centerPointRadius > 0) {\r\n        if (radius > 3 * centerPointRadius) {\r\n          drawCircleSvg(\r\n            svgDrawingHelper,\r\n            annotationUID,\r\n            `${circleUID}-center`,\r\n            center,\r\n            centerPointRadius,\r\n            {\r\n              color,\r\n              lineDash,\r\n              lineWidth,\r\n            }\r\n          );\r\n        }\r\n      }\r\n\r\n      renderStatus = true;\r\n\r\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\r\n      if (!options.visibility) {\r\n        data.handles.textBox = {\r\n          hasMoved: false,\r\n          worldPosition: <Types.Point3>[0, 0, 0],\r\n          worldBoundingBox: {\r\n            topLeft: <Types.Point3>[0, 0, 0],\r\n            topRight: <Types.Point3>[0, 0, 0],\r\n            bottomLeft: <Types.Point3>[0, 0, 0],\r\n            bottomRight: <Types.Point3>[0, 0, 0],\r\n          },\r\n        };\r\n        continue;\r\n      }\r\n\r\n      const textLines = this.configuration.getTextLines(data, targetId);\r\n      if (!textLines || textLines.length === 0) {\r\n        continue;\r\n      }\r\n\r\n      // Poor man's cached?\r\n      let canvasTextBoxCoords;\r\n\r\n      if (!data.handles.textBox.hasMoved) {\r\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\r\n\r\n        data.handles.textBox.worldPosition =\r\n          viewport.canvasToWorld(canvasTextBoxCoords);\r\n      }\r\n\r\n      const textBoxPosition = viewport.worldToCanvas(\r\n        data.handles.textBox.worldPosition\r\n      );\r\n\r\n      const textBoxUID = '1';\r\n      const boundingBox = drawLinkedTextBoxSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        textBoxUID,\r\n        textLines,\r\n        textBoxPosition,\r\n        canvasCoordinates,\r\n        {},\r\n        options\r\n      );\r\n\r\n      const { x: left, y: top, width, height } = boundingBox;\r\n\r\n      data.handles.textBox.worldBoundingBox = {\r\n        topLeft: viewport.canvasToWorld([left, top]),\r\n        topRight: viewport.canvasToWorld([left + width, top]),\r\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\r\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\r\n      };\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  _calculateCachedStats = (\r\n    annotation,\r\n    viewport,\r\n    renderingEngine,\r\n    enabledElement\r\n  ) => {\r\n    const data = annotation.data;\r\n    const { element } = viewport;\r\n\r\n    const { points } = data.handles;\r\n\r\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\r\n\r\n    const [topLeftCanvas, bottomRightCanvas] = <Array<Types.Point2>>(\r\n      getCanvasCircleCorners(canvasCoordinates)\r\n    );\r\n\r\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\r\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\r\n    const { cachedStats } = data;\r\n\r\n    const targetIds = Object.keys(cachedStats);\r\n    const worldPos1 = topLeftWorld;\r\n    const worldPos2 = bottomRightWorld;\r\n\r\n    for (let i = 0; i < targetIds.length; i++) {\r\n      const targetId = targetIds[i];\r\n\r\n      const image = this.getTargetIdImage(targetId, renderingEngine);\r\n\r\n      // If image does not exists for the targetId, skip. This can be due\r\n      // to various reasons such as if the target was a volumeViewport, and\r\n      // the volumeViewport has been decached in the meantime.\r\n      if (!image) {\r\n        continue;\r\n      }\r\n\r\n      const { dimensions, imageData, metadata, hasPixelSpacing } = image;\r\n\r\n      const pos1Index = transformWorldToIndex(imageData, worldPos1);\r\n\r\n      pos1Index[0] = Math.floor(pos1Index[0]);\r\n      pos1Index[1] = Math.floor(pos1Index[1]);\r\n      pos1Index[2] = Math.floor(pos1Index[2]);\r\n\r\n      const pos2Index = transformWorldToIndex(imageData, worldPos2);\r\n\r\n      pos2Index[0] = Math.floor(pos2Index[0]);\r\n      pos2Index[1] = Math.floor(pos2Index[1]);\r\n      pos2Index[2] = Math.floor(pos2Index[2]);\r\n\r\n      // Check if one of the indexes are inside the volume, this then gives us\r\n      // Some area to do stats over.\r\n\r\n      if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {\r\n        const iMin = Math.min(pos1Index[0], pos2Index[0]);\r\n        const iMax = Math.max(pos1Index[0], pos2Index[0]);\r\n\r\n        const jMin = Math.min(pos1Index[1], pos2Index[1]);\r\n        const jMax = Math.max(pos1Index[1], pos2Index[1]);\r\n\r\n        const kMin = Math.min(pos1Index[2], pos2Index[2]);\r\n        const kMax = Math.max(pos1Index[2], pos2Index[2]);\r\n\r\n        const boundsIJK = [\r\n          [iMin, iMax],\r\n          [jMin, jMax],\r\n          [kMin, kMax],\r\n        ] as [Types.Point2, Types.Point2, Types.Point2];\r\n\r\n        const center = [\r\n          (topLeftWorld[0] + bottomRightWorld[0]) / 2,\r\n          (topLeftWorld[1] + bottomRightWorld[1]) / 2,\r\n          (topLeftWorld[2] + bottomRightWorld[2]) / 2,\r\n        ] as Types.Point3;\r\n\r\n        const ellipseObj = {\r\n          center,\r\n          xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\r\n          yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\r\n          zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\r\n        };\r\n\r\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\r\n          viewPlaneNormal,\r\n          viewUp,\r\n          worldPos1,\r\n          worldPos2\r\n        );\r\n        const isEmptyArea = worldWidth === 0 && worldHeight === 0;\r\n        const handles = [pos1Index, pos2Index];\r\n        const { scale, units, areaUnits } = getCalibratedLengthUnitsAndScale(\r\n          image,\r\n          handles\r\n        );\r\n        const aspect = getCalibratedAspect(image);\r\n        const area = Math.abs(\r\n          Math.PI *\r\n            (worldWidth / scale / 2) *\r\n            (worldHeight / aspect / scale / 2)\r\n        );\r\n\r\n        const modalityUnitOptions = {\r\n          isPreScaled: isViewportPreScaled(viewport, targetId),\r\n          isSuvScaled: this.isSuvScaled(\r\n            viewport,\r\n            targetId,\r\n            annotation.metadata.referencedImageId\r\n          ),\r\n        };\r\n\r\n        const modalityUnit = getModalityUnit(\r\n          metadata.Modality,\r\n          annotation.metadata.referencedImageId,\r\n          modalityUnitOptions\r\n        );\r\n\r\n        const pointsInShape = pointInShapeCallback(\r\n          imageData,\r\n          (pointLPS) =>\r\n            pointInEllipse(ellipseObj, pointLPS, {\r\n              fast: true,\r\n            }),\r\n          this.configuration.statsCalculator.statsCallback,\r\n          boundsIJK\r\n        );\r\n\r\n        const stats = this.configuration.statsCalculator.getStatistics();\r\n\r\n        cachedStats[targetId] = {\r\n          Modality: metadata.Modality,\r\n          area,\r\n          mean: stats.mean?.value,\r\n          max: stats.max?.value,\r\n          stdDev: stats.stdDev?.value,\r\n          statsArray: stats.array,\r\n          pointsInShape: pointsInShape,\r\n          isEmptyArea,\r\n          areaUnit: areaUnits,\r\n          radius: worldWidth / 2 / scale,\r\n          radiusUnit: units,\r\n          perimeter: (2 * Math.PI * (worldWidth / 2)) / scale,\r\n          modalityUnit,\r\n        };\r\n      } else {\r\n        this.isHandleOutsideImage = true;\r\n\r\n        cachedStats[targetId] = {\r\n          Modality: metadata.Modality,\r\n        };\r\n      }\r\n    }\r\n\r\n    annotation.invalidated = false;\r\n\r\n    // Dispatching annotation modified\r\n    triggerAnnotationModified(annotation, element);\r\n\r\n    return cachedStats;\r\n  };\r\n\r\n  _isInsideVolume = (index1, index2, dimensions) => {\r\n    return (\r\n      csUtils.indexWithinDimensions(index1, dimensions) &&\r\n      csUtils.indexWithinDimensions(index2, dimensions)\r\n    );\r\n  };\r\n}\r\n\r\nfunction defaultGetTextLines(data, targetId): string[] {\r\n  const cachedVolumeStats = data.cachedStats[targetId];\r\n  const {\r\n    radius,\r\n    radiusUnit,\r\n    area,\r\n    mean,\r\n    stdDev,\r\n    max,\r\n    isEmptyArea,\r\n    areaUnit,\r\n    modalityUnit,\r\n  } = cachedVolumeStats;\r\n  const textLines: string[] = [];\r\n\r\n  if (radius) {\r\n    const radiusLine = isEmptyArea\r\n      ? `Radius: Oblique not supported`\r\n      : `Radius: ${roundNumber(radius)} ${radiusUnit}`;\r\n    textLines.push(radiusLine);\r\n  }\r\n\r\n  if (area) {\r\n    const areaLine = isEmptyArea\r\n      ? `Area: Oblique not supported`\r\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\r\n    textLines.push(areaLine);\r\n  }\r\n\r\n  if (mean) {\r\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\r\n  }\r\n\r\n  if (max) {\r\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\r\n  }\r\n\r\n  if (stdDev) {\r\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\r\n  }\r\n\r\n  return textLines;\r\n}\r\n\r\nCircleROITool.toolName = 'CircleROI';\r\nexport default CircleROITool;\r\n","import { vec3 } from 'gl-matrix';\r\nimport { Events } from '../../enums';\r\nimport { getEnabledElement } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { AnnotationTool } from '../base';\r\nimport throttle from '../../utilities/throttle';\r\nimport {\r\n  addAnnotation,\r\n  getAnnotations,\r\n  removeAnnotation,\r\n} from '../../stateManagement/annotation/annotationState';\r\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\r\nimport {\r\n  triggerAnnotationCompleted,\r\n  triggerAnnotationModified,\r\n} from '../../stateManagement/annotation/helpers/state';\r\nimport * as lineSegment from '../../utilities/math/line';\r\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\r\nimport { midPoint2 } from '../../utilities/math/midPoint';\r\n\r\nimport {\r\n  drawHandles as drawHandlesSvg,\r\n  drawLine as drawLineSvg,\r\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\r\n  drawTextBox as drawTextBoxSvg,\r\n} from '../../drawingSvg';\r\nimport { state } from '../../store';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\n\r\nimport {\r\n  resetElementCursor,\r\n  hideElementCursor,\r\n} from '../../cursors/elementCursor';\r\n\r\nimport {\r\n  EventTypes,\r\n  ToolHandle,\r\n  TextBoxHandle,\r\n  PublicToolProps,\r\n  ToolProps,\r\n  InteractionTypes,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\nimport { CobbAngleAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\n\r\nclass CobbAngleTool extends AnnotationTool {\r\n  static toolName;\r\n\r\n  public touchDragCallback: any;\r\n  public mouseDragCallback: any;\r\n  angleStartedNotYetCompleted: boolean;\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: string[];\r\n    handleIndex?: number;\r\n    movingTextBox?: boolean;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n    isNearFirstLine?: boolean;\r\n    isNearSecondLine?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        shadow: true,\r\n        preventHandleOutsideImage: false,\r\n        getTextLines: defaultGetTextLines,\r\n        showArcLines: false,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n\r\n    this._throttledCalculateCachedStats = throttle(\r\n      this._calculateCachedStats,\r\n      25,\r\n      { trailing: true }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the current imageId to create\r\n   * a Length Annotation and stores it in the annotationManager\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation = (\r\n    evt: EventTypes.MouseDownActivateEventType\r\n  ): CobbAngleAnnotation => {\r\n    if (this.angleStartedNotYetCompleted) {\r\n      return;\r\n    }\r\n\r\n    this.angleStartedNotYetCompleted = true;\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    hideElementCursor(element);\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    const referencedImageId = this.getReferencedImageId(\r\n      viewport,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      viewUp\r\n    );\r\n\r\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n\r\n    const annotation = {\r\n      highlighted: true,\r\n      invalidated: true,\r\n      metadata: {\r\n        toolName: this.getToolName(),\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID,\r\n        referencedImageId,\r\n        ...viewport.getViewReference({ points: [worldPos] }),\r\n      },\r\n      data: {\r\n        handles: {\r\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\r\n          activeHandleIndex: null,\r\n          textBox: {\r\n            hasMoved: false,\r\n            worldPosition: <Types.Point3>[0, 0, 0],\r\n            worldBoundingBox: {\r\n              topLeft: <Types.Point3>[0, 0, 0],\r\n              topRight: <Types.Point3>[0, 0, 0],\r\n              bottomLeft: <Types.Point3>[0, 0, 0],\r\n              bottomRight: <Types.Point3>[0, 0, 0],\r\n            },\r\n          },\r\n        },\r\n        label: '',\r\n        cachedStats: {},\r\n      },\r\n    };\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex: 1,\r\n      movingTextBox: false,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n    };\r\n    this._activateDraw(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  };\r\n\r\n  /**\r\n   * It returns if the canvas point is near the provided length annotation in the provided\r\n   * element or not. A proximity is passed to the function to determine the\r\n   * proximity of the point to the annotation in number of pixels.\r\n   *\r\n   * @param element - HTML Element\r\n   * @param annotation - Annotation\r\n   * @param canvasCoords - Canvas coordinates\r\n   * @param proximity - Proximity to tool to consider\r\n   * @returns Boolean, whether the canvas point is near tool\r\n   */\r\n  isPointNearTool = (\r\n    element: HTMLDivElement,\r\n    annotation: CobbAngleAnnotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): boolean => {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const { data } = annotation;\r\n\r\n    const { distanceToPoint, distanceToPoint2 } = this.distanceToLines({\r\n      viewport,\r\n      points: data.handles.points,\r\n      canvasCoords,\r\n      proximity,\r\n    });\r\n\r\n    if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  toolSelectedCallback = (\r\n    evt: EventTypes.MouseDownEventType,\r\n    annotation: CobbAngleAnnotation,\r\n    interactionType: InteractionTypes,\r\n    canvasCoords: Types.Point2,\r\n    proximity = 6\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine, viewport } = enabledElement;\r\n\r\n    const { isNearFirstLine, isNearSecondLine } = this.distanceToLines({\r\n      viewport,\r\n      points: annotation.data.handles.points,\r\n      canvasCoords,\r\n      proximity,\r\n    });\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      movingTextBox: false,\r\n      isNearFirstLine,\r\n      isNearSecondLine,\r\n    };\r\n\r\n    this._activateModify(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  handleSelectedCallback(\r\n    evt: EventTypes.MouseDownEventType,\r\n    annotation: CobbAngleAnnotation,\r\n    handle: ToolHandle,\r\n    interactionType = 'mouse'\r\n  ): void {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const { data } = annotation;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    let movingTextBox = false;\r\n    let handleIndex;\r\n\r\n    if ((handle as TextBoxHandle).worldPosition) {\r\n      movingTextBox = true;\r\n    } else {\r\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\r\n    }\r\n\r\n    // Find viewports to render on drag.\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex,\r\n      movingTextBox,\r\n    };\r\n    this._activateModify(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  }\r\n\r\n  _mouseUpCallback = (\r\n    evt: EventTypes.MouseUpEventType | EventTypes.MouseClickEventType\r\n  ) => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\r\n      this.editData;\r\n\r\n    const { data } = annotation;\r\n    if (newAnnotation && !hasMoved) {\r\n      // when user starts the drawing by click, and moving the mouse, instead\r\n      // of click and drag\r\n      return;\r\n    }\r\n\r\n    // If preventing new measurement means we are in the middle of an existing measurement\r\n    // we shouldn't deactivate modify or draw\r\n    if (this.angleStartedNotYetCompleted && data.handles.points.length < 4) {\r\n      resetElementCursor(element);\r\n\r\n      // adds the first point of the second line\r\n      this.editData.handleIndex = data.handles.points.length;\r\n      return;\r\n    }\r\n\r\n    this.angleStartedNotYetCompleted = false;\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateModify(element);\r\n    this._deactivateDraw(element);\r\n    resetElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    if (\r\n      this.isHandleOutsideImage &&\r\n      this.configuration.preventHandleOutsideImage\r\n    ) {\r\n      removeAnnotation(annotation.annotationUID);\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    if (newAnnotation) {\r\n      triggerAnnotationCompleted(annotation);\r\n    }\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n  };\r\n\r\n  /**\r\n   * Handles the mouse down for all points that follow the very first mouse down.\r\n   * The very first mouse down is handled by addAnnotation.\r\n   * This method ensures that the state of the tool is correct for the drawing of the second line segment.\r\n   * In particular it ensures that the second segment can be created via a mouse down and drag.\r\n   */\r\n  _mouseDownCallback = (\r\n    evt: EventTypes.MouseUpEventType | EventTypes.MouseClickEventType\r\n  ) => {\r\n    const { annotation, handleIndex } = this.editData;\r\n    const eventDetail = evt.detail;\r\n    const { element, currentPoints } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n    const { data } = annotation;\r\n\r\n    if (handleIndex === 1) {\r\n      // This is the mouse down for the second point of the first segment.\r\n      // The mouse up takes care of adding the first point of the second segment.\r\n      data.handles.points[1] = worldPos;\r\n      this.editData.hasMoved =\r\n        data.handles.points[1][0] !== data.handles.points[0][0] ||\r\n        data.handles.points[1][1] !== data.handles.points[0][0];\r\n      return;\r\n    }\r\n\r\n    if (handleIndex === 3) {\r\n      // This is the mouse down for the second point of the second segment (i.e. the last point)\r\n      data.handles.points[3] = worldPos;\r\n      this.editData.hasMoved =\r\n        data.handles.points[3][0] !== data.handles.points[2][0] ||\r\n        data.handles.points[3][1] !== data.handles.points[2][0];\r\n\r\n      this.angleStartedNotYetCompleted = false;\r\n      return;\r\n    }\r\n\r\n    // This is the first mouse down of the first point of the second line segment.\r\n    // It is as if we have not moved yet because Cobb Angle has two, disjoint sections, each with its own move.\r\n    this.editData.hasMoved = false;\r\n    hideElementCursor(element);\r\n\r\n    // Add the last segment points for the subsequent drag/mouse move.\r\n    data.handles.points[2] = data.handles.points[3] = worldPos;\r\n    this.editData.handleIndex = data.handles.points.length - 1;\r\n  };\r\n\r\n  _mouseDragCallback = (\r\n    evt: EventTypes.MouseDragEventType | EventTypes.MouseMoveEventType\r\n  ) => {\r\n    this.isDrawing = true;\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex,\r\n      movingTextBox,\r\n      isNearFirstLine,\r\n      isNearSecondLine,\r\n    } = this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (movingTextBox) {\r\n      // Drag mode - moving text box\r\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n\r\n      const { textBox } = data.handles;\r\n      const { worldPosition } = textBox;\r\n\r\n      worldPosition[0] += worldPosDelta[0];\r\n      worldPosition[1] += worldPosDelta[1];\r\n      worldPosition[2] += worldPosDelta[2];\r\n\r\n      textBox.hasMoved = true;\r\n    } else if (\r\n      handleIndex === undefined &&\r\n      (isNearFirstLine || isNearSecondLine)\r\n    ) {\r\n      // select tool mode - moving annotation\r\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n      const points = data.handles.points;\r\n\r\n      // separate the logic for moving handles to move them separately\r\n      if (isNearFirstLine) {\r\n        const firstLinePoints = [points[0], points[1]];\r\n        firstLinePoints.forEach((point) => {\r\n          point[0] += worldPosDelta[0];\r\n          point[1] += worldPosDelta[1];\r\n          point[2] += worldPosDelta[2];\r\n        });\r\n      } else if (isNearSecondLine) {\r\n        const secondLinePoints = [points[2], points[3]];\r\n        secondLinePoints.forEach((point) => {\r\n          point[0] += worldPosDelta[0];\r\n          point[1] += worldPosDelta[1];\r\n          point[2] += worldPosDelta[2];\r\n        });\r\n      }\r\n\r\n      annotation.invalidated = true;\r\n    } else {\r\n      // Drag handle mode - after double click, and mouse move to draw\r\n      const { currentPoints } = eventDetail;\r\n      const worldPos = currentPoints.world;\r\n\r\n      data.handles.points[handleIndex] = [...worldPos];\r\n      annotation.invalidated = true;\r\n    }\r\n\r\n    this.editData.hasMoved = true;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  cancel = (element: HTMLDivElement) => {\r\n    // If it is mid-draw or mid-modify\r\n    if (!this.isDrawing) {\r\n      return;\r\n    }\r\n\r\n    this.isDrawing = false;\r\n    this._deactivateDraw(element);\r\n    this._deactivateModify(element);\r\n    resetElementCursor(element);\r\n\r\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (data.handles.points.length < 4) {\r\n      // If it is mid-draw\r\n      removeAnnotation(annotation.annotationUID);\r\n    }\r\n\r\n    annotation.highlighted = false;\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    if (newAnnotation) {\r\n      triggerAnnotationCompleted(annotation);\r\n    }\r\n\r\n    this.editData = null;\r\n    this.angleStartedNotYetCompleted = false;\r\n    return annotation.annotationUID;\r\n  };\r\n\r\n  _activateModify = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(\r\n      Events.MOUSE_UP,\r\n      this._mouseUpCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._mouseDragCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._mouseUpCallback as EventListener\r\n    );\r\n\r\n    // element.addEventListener(Events.TOUCH_END, this._mouseUpCallback)\r\n    // element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\r\n  };\r\n\r\n  _deactivateModify = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(\r\n      Events.MOUSE_UP,\r\n      this._mouseUpCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._mouseDragCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._mouseUpCallback as EventListener\r\n    );\r\n\r\n    // element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback)\r\n    // element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\r\n  };\r\n\r\n  _activateDraw = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(\r\n      Events.MOUSE_UP,\r\n      this._mouseUpCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._mouseDragCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_MOVE,\r\n      this._mouseDragCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._mouseUpCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_DOWN,\r\n      this._mouseDownCallback as EventListener\r\n    );\r\n\r\n    // element.addEventListener(Events.TOUCH_END, this._mouseUpCallback)\r\n    // element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\r\n  };\r\n\r\n  _deactivateDraw = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(\r\n      Events.MOUSE_UP,\r\n      this._mouseUpCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._mouseDragCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_MOVE,\r\n      this._mouseDragCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._mouseUpCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_DOWN,\r\n      this._mouseDownCallback as EventListener\r\n    );\r\n\r\n    // element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback)\r\n    // element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the length annotation in each\r\n   * request animation frame. It calculates the updated cached statistics if\r\n   * data is invalidated and cache it.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n\r\n    let annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    annotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    );\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const targetId = this.getTargetId(viewport);\r\n    const renderingEngine = viewport.getRenderingEngine();\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    // Draw SVG\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[i] as CobbAngleAnnotation;\r\n      const { annotationUID, data } = annotation;\r\n      const { points, activeHandleIndex } = data.handles;\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\r\n        annotation,\r\n        styleSpecifier,\r\n      });\r\n\r\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\r\n      if (\r\n        !data.cachedStats[targetId] ||\r\n        data.cachedStats[targetId].angle == null\r\n      ) {\r\n        data.cachedStats[targetId] = {\r\n          angle: null,\r\n          arc1Angle: null,\r\n          arc2Angle: null,\r\n          points: {\r\n            world: {\r\n              arc1Start: null,\r\n              arc1End: null,\r\n              arc2Start: null,\r\n              arc2End: null,\r\n              arc1Angle: null,\r\n              arc2Angle: null,\r\n            },\r\n            canvas: {\r\n              arc1Start: null,\r\n              arc1End: null,\r\n              arc2Start: null,\r\n              arc2End: null,\r\n              arc1Angle: null,\r\n              arc2Angle: null,\r\n            },\r\n          },\r\n        };\r\n\r\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\r\n      } else if (annotation.invalidated) {\r\n        this._throttledCalculateCachedStats(\r\n          annotation,\r\n          renderingEngine,\r\n          enabledElement\r\n        );\r\n      }\r\n\r\n      let activeHandleCanvasCoords;\r\n\r\n      if (\r\n        !isAnnotationLocked(annotation) &&\r\n        !this.editData &&\r\n        activeHandleIndex !== null\r\n      ) {\r\n        // Not locked or creating and hovering over handle, so render handle.\r\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\r\n      }\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n\r\n      if (activeHandleCanvasCoords) {\r\n        const handleGroupUID = '0';\r\n\r\n        drawHandlesSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          handleGroupUID,\r\n          canvasCoordinates,\r\n          {\r\n            color,\r\n            lineDash,\r\n            lineWidth,\r\n          }\r\n        );\r\n      }\r\n\r\n      const firstLine = [canvasCoordinates[0], canvasCoordinates[1]] as [\r\n        Types.Point2,\r\n        Types.Point2\r\n      ];\r\n      const secondLine = [canvasCoordinates[2], canvasCoordinates[3]] as [\r\n        Types.Point2,\r\n        Types.Point2\r\n      ];\r\n\r\n      let lineUID = 'line1';\r\n      drawLineSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        lineUID,\r\n        firstLine[0],\r\n        firstLine[1],\r\n        {\r\n          color,\r\n          width: lineWidth,\r\n          lineDash,\r\n        }\r\n      );\r\n\r\n      renderStatus = true;\r\n\r\n      // Don't add the stats until annotation has 4 anchor points\r\n      if (canvasCoordinates.length < 4) {\r\n        return renderStatus;\r\n      }\r\n\r\n      lineUID = 'line2';\r\n\r\n      drawLineSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        lineUID,\r\n        secondLine[0],\r\n        secondLine[1],\r\n        {\r\n          color,\r\n          width: lineWidth,\r\n          lineDash,\r\n        }\r\n      );\r\n\r\n      lineUID = 'linkLine';\r\n      const mid1 = midPoint2(firstLine[0], firstLine[1]);\r\n      const mid2 = midPoint2(secondLine[0], secondLine[1]);\r\n      drawLineSvg(svgDrawingHelper, annotationUID, lineUID, mid1, mid2, {\r\n        color,\r\n        lineWidth: '1',\r\n        lineDash: '1,4',\r\n      });\r\n\r\n      // Calculating the arcs\r\n\r\n      const { arc1Start, arc1End, arc2End, arc2Start } =\r\n        data.cachedStats[targetId].points.canvas;\r\n      const { arc1Angle, arc2Angle } = data.cachedStats[targetId];\r\n\r\n      if (this.configuration.showArcLines) {\r\n        lineUID = 'arc1';\r\n\r\n        drawLineSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          lineUID,\r\n          arc1Start as Types.Point2,\r\n          arc1End as Types.Point2,\r\n          {\r\n            color,\r\n            lineWidth: '1',\r\n          }\r\n        );\r\n\r\n        lineUID = 'arc2';\r\n\r\n        drawLineSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          lineUID,\r\n          arc2Start as Types.Point2,\r\n          arc2End as Types.Point2,\r\n          {\r\n            color,\r\n            lineWidth: '1',\r\n          }\r\n        );\r\n      }\r\n\r\n      if (!data.cachedStats[targetId]?.angle) {\r\n        continue;\r\n      }\r\n\r\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\r\n      if (!options.visibility) {\r\n        data.handles.textBox = {\r\n          hasMoved: false,\r\n          worldPosition: <Types.Point3>[0, 0, 0],\r\n          worldBoundingBox: {\r\n            topLeft: <Types.Point3>[0, 0, 0],\r\n            topRight: <Types.Point3>[0, 0, 0],\r\n            bottomLeft: <Types.Point3>[0, 0, 0],\r\n            bottomRight: <Types.Point3>[0, 0, 0],\r\n          },\r\n        };\r\n        continue;\r\n      }\r\n\r\n      const textLines = this.configuration.getTextLines(data, targetId);\r\n\r\n      if (!data.handles.textBox.hasMoved) {\r\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\r\n\r\n        data.handles.textBox.worldPosition =\r\n          viewport.canvasToWorld(canvasTextBoxCoords);\r\n      }\r\n\r\n      const textBoxPosition = viewport.worldToCanvas(\r\n        data.handles.textBox.worldPosition\r\n      );\r\n\r\n      const textBoxUID = 'cobbAngleText';\r\n      const boundingBox = drawLinkedTextBoxSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        textBoxUID,\r\n        textLines,\r\n        textBoxPosition,\r\n        canvasCoordinates,\r\n        {},\r\n        options\r\n      );\r\n\r\n      const { x: left, y: top, width, height } = boundingBox;\r\n\r\n      data.handles.textBox.worldBoundingBox = {\r\n        topLeft: viewport.canvasToWorld([left, top]),\r\n        topRight: viewport.canvasToWorld([left + width, top]),\r\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\r\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\r\n      };\r\n\r\n      if (this.configuration.showArcLines) {\r\n        const arc1TextBoxUID = 'arcAngle1';\r\n\r\n        const arc1TextLine = [\r\n          `${arc1Angle.toFixed(2)} ${String.fromCharCode(176)}`,\r\n        ];\r\n\r\n        const arch1TextPosCanvas = midPoint2(arc1Start, arc1End);\r\n\r\n        drawTextBoxSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          arc1TextBoxUID,\r\n          arc1TextLine,\r\n          arch1TextPosCanvas,\r\n          {\r\n            ...options,\r\n            padding: 3,\r\n          }\r\n        );\r\n\r\n        const arc2TextBoxUID = 'arcAngle2';\r\n\r\n        const arc2TextLine = [\r\n          `${arc2Angle.toFixed(2)} ${String.fromCharCode(176)}`,\r\n        ];\r\n\r\n        const arch2TextPosCanvas = midPoint2(arc2Start, arc2End);\r\n\r\n        drawTextBoxSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          arc2TextBoxUID,\r\n          arc2TextLine,\r\n          arch2TextPosCanvas,\r\n          {\r\n            ...options,\r\n            padding: 3,\r\n          }\r\n        );\r\n      }\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\r\n    const data = annotation.data;\r\n\r\n    // Until we have all four anchors bail out\r\n    if (data.handles.points.length !== 4) {\r\n      return;\r\n    }\r\n\r\n    const seg1: [Types.Point3, Types.Point3] = [null, null];\r\n    const seg2: [Types.Point3, Types.Point3] = [null, null];\r\n    let minDist = Number.MAX_VALUE;\r\n\r\n    // Order the endpoints of each line segment such that seg1[1] and seg2[0]\r\n    // are the closest (Euclidean distance-wise) to each other. Thus\r\n    // the angle formed between the vectors seg1[1]->seg1[0] and seg2[0]->seg[1]\r\n    // is calculated.\r\n    // The assumption here is that the Cobb angle line segments are drawn\r\n    // such that the segments intersect nearest the segment endpoints\r\n    // that are closest AND those closest endpoints are the tails of the\r\n    // vectors used to calculate the angle between the vectors/line segments.\r\n    for (let i = 0; i < 2; i += 1) {\r\n      for (let j = 2; j < 4; j += 1) {\r\n        const dist = vec3.distance(\r\n          data.handles.points[i],\r\n          data.handles.points[j]\r\n        );\r\n        if (dist < minDist) {\r\n          minDist = dist;\r\n          seg1[1] = data.handles.points[i];\r\n          seg1[0] = data.handles.points[(i + 1) % 2];\r\n          seg2[0] = data.handles.points[j];\r\n          seg2[1] = data.handles.points[2 + ((j - 1) % 2)];\r\n        }\r\n      }\r\n    }\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n\r\n    const canvasPoints = data.handles.points.map((p) =>\r\n      viewport.worldToCanvas(p)\r\n    );\r\n\r\n    const firstLine = [canvasPoints[0], canvasPoints[1]] as [\r\n      Types.Point2,\r\n      Types.Point2\r\n    ];\r\n    const secondLine = [canvasPoints[2], canvasPoints[3]] as [\r\n      Types.Point2,\r\n      Types.Point2\r\n    ];\r\n\r\n    const mid1 = midPoint2(firstLine[0], firstLine[1]);\r\n    const mid2 = midPoint2(secondLine[0], secondLine[1]);\r\n\r\n    const { arc1Start, arc1End, arc2End, arc2Start, arc1Angle, arc2Angle } =\r\n      this.getArcsStartEndPoints({\r\n        firstLine,\r\n        secondLine,\r\n        mid1,\r\n        mid2,\r\n      });\r\n\r\n    const { cachedStats } = data;\r\n    const targetIds = Object.keys(cachedStats);\r\n\r\n    for (let i = 0; i < targetIds.length; i++) {\r\n      const targetId = targetIds[i];\r\n\r\n      cachedStats[targetId] = {\r\n        angle: angleBetweenLines(seg1, seg2),\r\n        arc1Angle,\r\n        arc2Angle,\r\n        points: {\r\n          canvas: {\r\n            arc1Start,\r\n            arc1End,\r\n            arc2End,\r\n            arc2Start,\r\n          },\r\n          world: {\r\n            arc1Start: viewport.canvasToWorld(arc1Start),\r\n            arc1End: viewport.canvasToWorld(arc1End),\r\n            arc2End: viewport.canvasToWorld(arc2End),\r\n            arc2Start: viewport.canvasToWorld(arc2Start),\r\n          },\r\n        },\r\n      };\r\n    }\r\n\r\n    annotation.invalidated = false;\r\n\r\n    // Dispatching annotation modified\r\n    triggerAnnotationModified(annotation, element);\r\n\r\n    return cachedStats;\r\n  }\r\n\r\n  distanceToLines = ({ viewport, points, canvasCoords, proximity }) => {\r\n    const [point1, point2, point3, point4] = points;\r\n    const canvasPoint1 = viewport.worldToCanvas(point1);\r\n    const canvasPoint2 = viewport.worldToCanvas(point2);\r\n    const canvasPoint3 = viewport.worldToCanvas(point3);\r\n    const canvasPoint4 = viewport.worldToCanvas(point4);\r\n\r\n    const line1 = {\r\n      start: {\r\n        x: canvasPoint1[0],\r\n        y: canvasPoint1[1],\r\n      },\r\n      end: {\r\n        x: canvasPoint2[0],\r\n        y: canvasPoint2[1],\r\n      },\r\n    };\r\n\r\n    const line2 = {\r\n      start: {\r\n        x: canvasPoint3[0],\r\n        y: canvasPoint3[1],\r\n      },\r\n      end: {\r\n        x: canvasPoint4[0],\r\n        y: canvasPoint4[1],\r\n      },\r\n    };\r\n\r\n    const distanceToPoint = lineSegment.distanceToPoint(\r\n      [line1.start.x, line1.start.y],\r\n      [line1.end.x, line1.end.y],\r\n      [canvasCoords[0], canvasCoords[1]]\r\n    );\r\n\r\n    const distanceToPoint2 = lineSegment.distanceToPoint(\r\n      [line2.start.x, line2.start.y],\r\n      [line2.end.x, line2.end.y],\r\n      [canvasCoords[0], canvasCoords[1]]\r\n    );\r\n\r\n    let isNearFirstLine = false;\r\n    let isNearSecondLine = false;\r\n\r\n    if (distanceToPoint <= proximity) {\r\n      isNearFirstLine = true;\r\n    } else if (distanceToPoint2 <= proximity) {\r\n      isNearSecondLine = true;\r\n    }\r\n    return {\r\n      distanceToPoint,\r\n      distanceToPoint2,\r\n      isNearFirstLine,\r\n      isNearSecondLine,\r\n    };\r\n  };\r\n\r\n  getArcsStartEndPoints = ({\r\n    firstLine,\r\n    secondLine,\r\n    mid1,\r\n    mid2,\r\n  }): {\r\n    arc1Start: Types.Point2;\r\n    arc1End: Types.Point2;\r\n    arc2Start: Types.Point2;\r\n    arc2End: Types.Point2;\r\n    arc1Angle: number;\r\n    arc2Angle: number;\r\n  } => {\r\n    const linkLine = [mid1, mid2] as [Types.Point2, Types.Point2];\r\n\r\n    const arc1Angle = angleBetweenLines(firstLine, linkLine);\r\n    const arc2Angle = angleBetweenLines(secondLine, linkLine);\r\n\r\n    const arc1Side = arc1Angle > 90 ? 1 : 0;\r\n    const arc2Side = arc2Angle > 90 ? 0 : 1;\r\n\r\n    const midLinkLine = midPoint2(linkLine[0], linkLine[1]);\r\n\r\n    const linkLineLength = Math.sqrt(\r\n      (linkLine[1][0] - linkLine[0][0]) ** 2 +\r\n        (linkLine[1][1] - linkLine[0][1]) ** 2\r\n    );\r\n    const ratio = 0.1; // 10% of the line length\r\n\r\n    const midFirstLine = midPoint2(firstLine[0], firstLine[1]);\r\n    const midSecondLine = midPoint2(secondLine[0], secondLine[1]);\r\n\r\n    // For arc1Start\r\n    const directionVectorStartArc1 = [\r\n      firstLine[arc1Side][0] - midFirstLine[0],\r\n      firstLine[arc1Side][1] - midFirstLine[1],\r\n    ];\r\n    const magnitudeStartArc1 = Math.sqrt(\r\n      directionVectorStartArc1[0] ** 2 + directionVectorStartArc1[1] ** 2\r\n    );\r\n    const normalizedDirectionStartArc1 = [\r\n      directionVectorStartArc1[0] / magnitudeStartArc1,\r\n      directionVectorStartArc1[1] / magnitudeStartArc1,\r\n    ];\r\n    const arc1Start = [\r\n      midFirstLine[0] +\r\n        normalizedDirectionStartArc1[0] * linkLineLength * ratio,\r\n      midFirstLine[1] +\r\n        normalizedDirectionStartArc1[1] * linkLineLength * ratio,\r\n    ] as Types.Point2;\r\n\r\n    // Existing logic for arc1End\r\n    const directionVectorEndArc1 = [\r\n      midLinkLine[0] - mid1[0],\r\n      midLinkLine[1] - mid1[1],\r\n    ];\r\n    const magnitudeEndArc1 = Math.sqrt(\r\n      directionVectorEndArc1[0] ** 2 + directionVectorEndArc1[1] ** 2\r\n    );\r\n    const normalizedDirectionEndArc1 = [\r\n      directionVectorEndArc1[0] / magnitudeEndArc1,\r\n      directionVectorEndArc1[1] / magnitudeEndArc1,\r\n    ];\r\n    const arc1End = [\r\n      mid1[0] + normalizedDirectionEndArc1[0] * linkLineLength * ratio,\r\n      mid1[1] + normalizedDirectionEndArc1[1] * linkLineLength * ratio,\r\n    ] as Types.Point2;\r\n\r\n    // Similar logic for arc2Start\r\n    const directionVectorStartArc2 = [\r\n      secondLine[arc2Side][0] - midSecondLine[0],\r\n      secondLine[arc2Side][1] - midSecondLine[1],\r\n    ];\r\n    const magnitudeStartArc2 = Math.sqrt(\r\n      directionVectorStartArc2[0] ** 2 + directionVectorStartArc2[1] ** 2\r\n    );\r\n    const normalizedDirectionStartArc2 = [\r\n      directionVectorStartArc2[0] / magnitudeStartArc2,\r\n      directionVectorStartArc2[1] / magnitudeStartArc2,\r\n    ];\r\n    const arc2Start = [\r\n      midSecondLine[0] +\r\n        normalizedDirectionStartArc2[0] * linkLineLength * ratio,\r\n      midSecondLine[1] +\r\n        normalizedDirectionStartArc2[1] * linkLineLength * ratio,\r\n    ] as Types.Point2;\r\n\r\n    // Similar logic for arc2End\r\n    const directionVectorEndArc2 = [\r\n      midLinkLine[0] - mid2[0],\r\n      midLinkLine[1] - mid2[1],\r\n    ];\r\n    const magnitudeEndArc2 = Math.sqrt(\r\n      directionVectorEndArc2[0] ** 2 + directionVectorEndArc2[1] ** 2\r\n    );\r\n    const normalizedDirectionEndArc2 = [\r\n      directionVectorEndArc2[0] / magnitudeEndArc2,\r\n      directionVectorEndArc2[1] / magnitudeEndArc2,\r\n    ];\r\n    const arc2End = [\r\n      mid2[0] + normalizedDirectionEndArc2[0] * linkLineLength * ratio,\r\n      mid2[1] + normalizedDirectionEndArc2[1] * linkLineLength * ratio,\r\n    ] as Types.Point2;\r\n\r\n    return {\r\n      arc1Start,\r\n      arc1End,\r\n      arc2Start,\r\n      arc2End,\r\n      arc1Angle: arc1Angle > 90 ? 180 - arc1Angle : arc1Angle,\r\n      arc2Angle: arc2Angle > 90 ? 180 - arc2Angle : arc2Angle,\r\n    };\r\n  };\r\n}\r\n\r\nfunction defaultGetTextLines(data, targetId): string[] {\r\n  const cachedVolumeStats = data.cachedStats[targetId];\r\n  const { angle } = cachedVolumeStats;\r\n\r\n  if (angle === undefined) {\r\n    return;\r\n  }\r\n\r\n  const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];\r\n\r\n  return textLines;\r\n}\r\n\r\nCobbAngleTool.toolName = 'CobbAngle';\r\nexport default CobbAngleTool;\r\n","/* eslint-disable @typescript-eslint/no-empty-function */\r\nimport { getEnabledElement } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport {\r\n  drawHandles as drawHandlesSvg,\r\n  drawTextBox as drawTextBoxSvg,\r\n} from '../../drawingSvg';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport { hideElementCursor } from '../../cursors/elementCursor';\r\nimport {\r\n  EventTypes,\r\n  PublicToolProps,\r\n  SVGDrawingHelper,\r\n  ToolProps,\r\n} from '../../types';\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\nimport ProbeTool from './ProbeTool';\r\nimport { ProbeAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\r\n\r\nclass DragProbeTool extends ProbeTool {\r\n  static toolName;\r\n\r\n  touchDragCallback: any;\r\n  mouseDragCallback: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: string[];\r\n    newAnnotation?: boolean;\r\n  } | null;\r\n  eventDispatchDetail: {\r\n    viewportId: string;\r\n    renderingEngineId: string;\r\n  };\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        shadow: true,\r\n        preventHandleOutsideImage: false,\r\n        getTextLines: defaultGetTextLines,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  postMouseDownCallback = (\r\n    evt: EventTypes.InteractionEventType\r\n  ): ProbeAnnotation => {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    this.isDrawing = true;\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    const referencedImageId = this.getReferencedImageId(\r\n      viewport,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      viewUp\r\n    );\r\n\r\n    const annotation: ProbeAnnotation = {\r\n      invalidated: true,\r\n      highlighted: true,\r\n      isVisible: true,\r\n      metadata: {\r\n        toolName: this.getToolName(),\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\r\n        referencedImageId,\r\n      },\r\n      data: {\r\n        label: '',\r\n        handles: { points: [<Types.Point3>[...worldPos]] },\r\n        cachedStats: {},\r\n      },\r\n    };\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      newAnnotation: true,\r\n      viewportIdsToRender,\r\n    };\r\n    this._activateModify(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  };\r\n\r\n  postTouchStartCallback = (\r\n    evt: EventTypes.InteractionEventType\r\n  ): ProbeAnnotation => {\r\n    return this.postMouseDownCallback(evt);\r\n  };\r\n\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n    const { viewport } = enabledElement;\r\n\r\n    if (!this.editData) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const annotations = this.filterInteractableAnnotationsForElement(\r\n      viewport.element,\r\n      [this.editData.annotation]\r\n    );\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const targetId = this.getTargetId(viewport);\r\n    const renderingEngine = viewport.getRenderingEngine();\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    const annotation = this.editData.annotation;\r\n    const annotationUID = annotation.annotationUID;\r\n    const data = annotation.data;\r\n    const point = data.handles.points[0];\r\n    const canvasCoordinates = viewport.worldToCanvas(point);\r\n\r\n    styleSpecifier.annotationUID = annotationUID;\r\n\r\n    const { color } = this.getAnnotationStyle({\r\n      annotation,\r\n      styleSpecifier,\r\n    });\r\n\r\n    const modalityUnitOptions = {\r\n      isPreScaled: isViewportPreScaled(viewport, targetId),\r\n\r\n      isSuvScaled: this.isSuvScaled(\r\n        viewport,\r\n        targetId,\r\n        annotation.metadata.referencedImageId\r\n      ),\r\n    };\r\n\r\n    if (\r\n      !data.cachedStats[targetId] ||\r\n      data.cachedStats[targetId].value == null\r\n    ) {\r\n      data.cachedStats[targetId] = {\r\n        Modality: null,\r\n        index: null,\r\n        value: null,\r\n      };\r\n\r\n      this._calculateCachedStats(annotation, renderingEngine, enabledElement);\r\n    } else if (annotation.invalidated) {\r\n      this._calculateCachedStats(annotation, renderingEngine, enabledElement);\r\n    }\r\n\r\n    // If rendering engine has been destroyed while rendering\r\n    if (!viewport.getRenderingEngine()) {\r\n      console.warn('Rendering Engine has been destroyed');\r\n      return renderStatus;\r\n    }\r\n\r\n    const handleGroupUID = '0';\r\n\r\n    drawHandlesSvg(\r\n      svgDrawingHelper,\r\n      annotationUID,\r\n      handleGroupUID,\r\n      [canvasCoordinates],\r\n      { color }\r\n    );\r\n\r\n    renderStatus = true;\r\n\r\n    const textLines = this.configuration.getTextLines(data, targetId);\r\n    if (textLines) {\r\n      const textCanvasCoordinates = [\r\n        canvasCoordinates[0] + 6,\r\n        canvasCoordinates[1] - 6,\r\n      ];\r\n\r\n      const textUID = '0';\r\n      drawTextBoxSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        textUID,\r\n        textLines,\r\n        [textCanvasCoordinates[0], textCanvasCoordinates[1]],\r\n        this.getLinkedTextBoxStyle(styleSpecifier, annotation)\r\n      );\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n}\r\n\r\nfunction defaultGetTextLines(data, targetId): string[] {\r\n  const cachedVolumeStats = data.cachedStats[targetId];\r\n  const { index, value, modalityUnit } = cachedVolumeStats;\r\n\r\n  if (value === undefined) {\r\n    return;\r\n  }\r\n\r\n  const textLines = [];\r\n\r\n  textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\r\n\r\n  textLines.push(`${value.toFixed(2)} ${modalityUnit}`);\r\n\r\n  return textLines;\r\n}\r\n\r\nDragProbeTool.toolName = 'DragProbe';\r\nexport default DragProbeTool;\r\n","import { AnnotationTool } from '../base';\r\n\r\nimport {\r\n  getEnabledElement,\r\n  VolumeViewport,\r\n  utilities as csUtils,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\r\nimport { roundNumber } from '../../utilities';\r\nimport throttle from '../../utilities/throttle';\r\nimport {\r\n  addAnnotation,\r\n  getAnnotations,\r\n  removeAnnotation,\r\n} from '../../stateManagement/annotation/annotationState';\r\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\r\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\r\nimport {\r\n  triggerAnnotationCompleted,\r\n  triggerAnnotationModified,\r\n} from '../../stateManagement/annotation/helpers/state';\r\nimport {\r\n  drawCircle as drawCircleSvg,\r\n  drawEllipseByCoordinates as drawEllipseSvg,\r\n  drawHandles as drawHandlesSvg,\r\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\r\n} from '../../drawingSvg';\r\nimport { state } from '../../store';\r\nimport { Events } from '../../enums';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\r\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\r\nimport {\r\n  pointInEllipse,\r\n  getCanvasEllipseCorners,\r\n} from '../../utilities/math/ellipse';\r\nimport {\r\n  resetElementCursor,\r\n  hideElementCursor,\r\n} from '../../cursors/elementCursor';\r\nimport {\r\n  EventTypes,\r\n  ToolHandle,\r\n  TextBoxHandle,\r\n  PublicToolProps,\r\n  ToolProps,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\nimport { EllipticalROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\n\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\nimport { pointInShapeCallback } from '../../utilities/';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\r\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\r\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\r\n\r\nconst { transformWorldToIndex } = csUtils;\r\n\r\n/**\r\n * EllipticalROITool let you draw annotations that measures the statistics\r\n * such as area, max, mean and stdDev of an elliptical region of interest.\r\n * You can use EllipticalROITool in all perpendicular views (axial, sagittal, coronal).\r\n * Note: annotation tools in cornerstone3DTools exists in the exact location\r\n * in the physical 3d space, as a result, by default, all annotations that are\r\n * drawing in the same frameOfReference will get shared between viewports that\r\n * are in the same frameOfReference. Elliptical tool's text box lines are dynamically\r\n * generated based on the viewport's underlying Modality. For instance, if\r\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\r\n * and if the viewport is displaying PET, the text box will show the statistics in\r\n * SUV units.\r\n *\r\n * The resulting annotation's data (statistics) and metadata (the\r\n * state of the viewport while drawing was happening) will get added to the\r\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\r\n * or similar methods.\r\n *\r\n * Changing tool configuration (see below) you can make the tool to draw the center\r\n * point circle with a given radius.\r\n *\r\n * ```js\r\n * cornerstoneTools.addTool(EllipticalROITool)\r\n *\r\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\r\n *\r\n * toolGroup.addTool(EllipticalROITool.toolName)\r\n *\r\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\r\n *\r\n * toolGroup.setToolActive(EllipticalROITool.toolName, {\r\n *   bindings: [\r\n *    {\r\n *       mouseButton: MouseBindings.Primary, // Left Click\r\n *     },\r\n *   ],\r\n * })\r\n *\r\n * // draw a circle at the center point with 4px radius.\r\n * toolGroup.setToolConfiguration(EllipticalROITool.toolName, {\r\n *   centerPointRadius: 4,\r\n * });\r\n * ```\r\n *\r\n * Read more in the Docs section of the website.\r\n */\r\n\r\nclass EllipticalROITool extends AnnotationTool {\r\n  static toolName;\r\n\r\n  touchDragCallback: any;\r\n  mouseDragCallback: any;\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: Array<string>;\r\n    handleIndex?: number;\r\n    movingTextBox?: boolean;\r\n    centerWorld?: Array<number>;\r\n    canvasWidth?: number;\r\n    canvasHeight?: number;\r\n    originalHandleCanvas?: Array<number>;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage = false;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        shadow: true,\r\n        preventHandleOutsideImage: false,\r\n        // Radius of the circle to draw  at the center point of the ellipse.\r\n        // Set this zero(0) in order not to draw the circle.\r\n        centerPointRadius: 0,\r\n        getTextLines: defaultGetTextLines,\r\n        statsCalculator: BasicStatsCalculator,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n\r\n    this._throttledCalculateCachedStats = throttle(\r\n      this._calculateCachedStats,\r\n      100,\r\n      { trailing: true }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the current imageId to create\r\n   * a EllipticalROI Annotation and stores it in the annotationManager\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation = (\r\n    evt: EventTypes.InteractionEventType\r\n  ): EllipticalROIAnnotation => {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n    const canvasPos = currentPoints.canvas;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    const referencedImageId = this.getReferencedImageId(\r\n      viewport,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      viewUp\r\n    );\r\n\r\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n\r\n    const annotation = {\r\n      highlighted: true,\r\n      invalidated: true,\r\n      metadata: {\r\n        toolName: this.getToolName(),\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID,\r\n        referencedImageId,\r\n        ...viewport.getViewReference({ points: [worldPos] }),\r\n      },\r\n      data: {\r\n        label: '',\r\n        handles: {\r\n          textBox: {\r\n            hasMoved: false,\r\n            worldPosition: <Types.Point3>[0, 0, 0],\r\n            worldBoundingBox: {\r\n              topLeft: <Types.Point3>[0, 0, 0],\r\n              topRight: <Types.Point3>[0, 0, 0],\r\n              bottomLeft: <Types.Point3>[0, 0, 0],\r\n              bottomRight: <Types.Point3>[0, 0, 0],\r\n            },\r\n          },\r\n          points: [\r\n            [...worldPos],\r\n            [...worldPos],\r\n            [...worldPos],\r\n            [...worldPos],\r\n          ] as [Types.Point3, Types.Point3, Types.Point3, Types.Point3],\r\n          activeHandleIndex: null,\r\n        },\r\n        cachedStats: {},\r\n        initialRotation: viewport.getRotation(),\r\n      },\r\n    };\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      centerWorld: worldPos,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n    };\r\n    this._activateDraw(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  };\r\n\r\n  /**\r\n   * It returns if the canvas point is near the provided annotation in the provided\r\n   * element or not. A proximity is passed to the function to determine the\r\n   * proximity of the point to the annotation in number of pixels.\r\n   *\r\n   * @param element - HTML Element\r\n   * @param annotation - Annotation\r\n   * @param canvasCoords - Canvas coordinates\r\n   * @param proximity - Proximity to tool to consider\r\n   * @returns Boolean, whether the canvas point is near tool\r\n   */\r\n  isPointNearTool = (\r\n    element: HTMLDivElement,\r\n    annotation: EllipticalROIAnnotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): boolean => {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    const { data } = annotation;\r\n    const { points } = data.handles;\r\n\r\n    // For some reason Typescript doesn't understand this, so we need to be\r\n    // more specific about the type\r\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p)) as [\r\n      Types.Point2,\r\n      Types.Point2,\r\n      Types.Point2,\r\n      Types.Point2\r\n    ];\r\n    const canvasCorners = getCanvasEllipseCorners(canvasCoordinates);\r\n\r\n    const [canvasPoint1, canvasPoint2] = canvasCorners;\r\n\r\n    const minorEllipse = {\r\n      left: Math.min(canvasPoint1[0], canvasPoint2[0]) + proximity / 2,\r\n      top: Math.min(canvasPoint1[1], canvasPoint2[1]) + proximity / 2,\r\n      width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) - proximity,\r\n      height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) - proximity,\r\n    };\r\n\r\n    const majorEllipse = {\r\n      left: Math.min(canvasPoint1[0], canvasPoint2[0]) - proximity / 2,\r\n      top: Math.min(canvasPoint1[1], canvasPoint2[1]) - proximity / 2,\r\n      width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) + proximity,\r\n      height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) + proximity,\r\n    };\r\n\r\n    const pointInMinorEllipse = this._pointInEllipseCanvas(\r\n      minorEllipse,\r\n      canvasCoords\r\n    );\r\n    const pointInMajorEllipse = this._pointInEllipseCanvas(\r\n      majorEllipse,\r\n      canvasCoords\r\n    );\r\n\r\n    if (pointInMajorEllipse && !pointInMinorEllipse) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  toolSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: EllipticalROIAnnotation\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      movingTextBox: false,\r\n    };\r\n\r\n    hideElementCursor(element);\r\n\r\n    this._activateModify(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  handleSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: EllipticalROIAnnotation,\r\n    handle: ToolHandle\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const { data } = annotation;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    let movingTextBox = false;\r\n    let handleIndex;\r\n\r\n    let centerCanvas;\r\n    let centerWorld;\r\n    let canvasWidth;\r\n    let canvasHeight;\r\n    let originalHandleCanvas;\r\n\r\n    if ((handle as TextBoxHandle).worldPosition) {\r\n      movingTextBox = true;\r\n    } else {\r\n      const { points } = data.handles;\r\n      const { viewport } = getEnabledElement(element);\r\n      const { worldToCanvas, canvasToWorld } = viewport;\r\n\r\n      handleIndex = points.findIndex((p) => p === handle);\r\n\r\n      const pointsCanvas = points.map(worldToCanvas);\r\n\r\n      originalHandleCanvas = pointsCanvas[handleIndex];\r\n\r\n      canvasWidth = Math.abs(pointsCanvas[2][0] - pointsCanvas[3][0]);\r\n      canvasHeight = Math.abs(pointsCanvas[0][1] - pointsCanvas[1][1]);\r\n\r\n      centerCanvas = [\r\n        (pointsCanvas[2][0] + pointsCanvas[3][0]) / 2,\r\n        (pointsCanvas[0][1] + pointsCanvas[1][1]) / 2,\r\n      ];\r\n\r\n      centerWorld = canvasToWorld(centerCanvas);\r\n    }\r\n\r\n    // Find viewports to render on drag.\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex,\r\n      canvasWidth,\r\n      canvasHeight,\r\n      centerWorld,\r\n      originalHandleCanvas,\r\n      movingTextBox,\r\n    };\r\n    this._activateModify(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (newAnnotation && !hasMoved) {\r\n      return;\r\n    }\r\n\r\n    // Elliptical ROI tool should reset its highlight to false on mouse up (as opposed\r\n    // to other tools that keep it highlighted until the user moves. The reason\r\n    // is that we use top-left and bottom-right handles to define the ellipse,\r\n    // and they are by definition not in the ellipse on mouse up.\r\n    annotation.highlighted = false;\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateModify(element);\r\n    this._deactivateDraw(element);\r\n\r\n    resetElementCursor(element);\r\n\r\n    const { renderingEngine } = getEnabledElement(element);\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n\r\n    if (\r\n      this.isHandleOutsideImage &&\r\n      this.configuration.preventHandleOutsideImage\r\n    ) {\r\n      removeAnnotation(annotation.annotationUID);\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    if (newAnnotation) {\r\n      triggerAnnotationCompleted(annotation);\r\n    }\r\n  };\r\n\r\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    this.isDrawing = true;\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const { currentPoints } = eventDetail;\r\n    const currentCanvasPoints = currentPoints.canvas;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine, viewport } = enabledElement;\r\n    const { canvasToWorld } = viewport;\r\n\r\n    //////\r\n    const { annotation, viewportIdsToRender, centerWorld } = this.editData;\r\n    const centerCanvas = viewport.worldToCanvas(centerWorld as Types.Point3);\r\n    const { data } = annotation;\r\n\r\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\r\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\r\n\r\n    // Todo: why bottom is -dY, it should be +dY\r\n    const bottomCanvas = <Types.Point2>[centerCanvas[0], centerCanvas[1] - dY];\r\n    const topCanvas = <Types.Point2>[centerCanvas[0], centerCanvas[1] + dY];\r\n    const leftCanvas = <Types.Point2>[centerCanvas[0] - dX, centerCanvas[1]];\r\n    const rightCanvas = <Types.Point2>[centerCanvas[0] + dX, centerCanvas[1]];\r\n\r\n    data.handles.points = [\r\n      canvasToWorld(bottomCanvas),\r\n      canvasToWorld(topCanvas),\r\n      canvasToWorld(leftCanvas),\r\n      canvasToWorld(rightCanvas),\r\n    ];\r\n\r\n    annotation.invalidated = true;\r\n\r\n    this.editData.hasMoved = true;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    this.isDrawing = true;\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (movingTextBox) {\r\n      const { deltaPoints } = eventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n\r\n      const { textBox } = data.handles;\r\n      const { worldPosition } = textBox;\r\n\r\n      worldPosition[0] += worldPosDelta[0];\r\n      worldPosition[1] += worldPosDelta[1];\r\n      worldPosition[2] += worldPosDelta[2];\r\n\r\n      textBox.hasMoved = true;\r\n    } else if (handleIndex === undefined) {\r\n      // Moving tool\r\n      const { deltaPoints } = eventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n\r\n      const points = data.handles.points;\r\n\r\n      points.forEach((point) => {\r\n        point[0] += worldPosDelta[0];\r\n        point[1] += worldPosDelta[1];\r\n        point[2] += worldPosDelta[2];\r\n      });\r\n      annotation.invalidated = true;\r\n    } else {\r\n      this._dragHandle(evt);\r\n      annotation.invalidated = true;\r\n    }\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const { viewport } = getEnabledElement(element);\r\n    const { canvasToWorld, worldToCanvas } = viewport;\r\n\r\n    const {\r\n      annotation,\r\n      canvasWidth,\r\n      canvasHeight,\r\n      handleIndex,\r\n      centerWorld,\r\n      originalHandleCanvas,\r\n    } = this.editData;\r\n    const centerCanvas = viewport.worldToCanvas(centerWorld as Types.Point3);\r\n    const { data } = annotation;\r\n    const { points } = data.handles;\r\n\r\n    // Move current point in that direction.\r\n    // Move other points in opposite direction.\r\n\r\n    const { currentPoints } = eventDetail;\r\n    const currentCanvasPoints = currentPoints.canvas;\r\n\r\n    if (handleIndex === 0 || handleIndex === 1) {\r\n      // Dragging top or bottom point\r\n      const dYCanvas = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\r\n      const canvasBottom = <Types.Point2>[\r\n        centerCanvas[0],\r\n        centerCanvas[1] - dYCanvas,\r\n      ];\r\n      const canvasTop = <Types.Point2>[\r\n        centerCanvas[0],\r\n        centerCanvas[1] + dYCanvas,\r\n      ];\r\n\r\n      points[0] = canvasToWorld(canvasBottom);\r\n      points[1] = canvasToWorld(canvasTop);\r\n\r\n      const dXCanvas = currentCanvasPoints[0] - originalHandleCanvas[0];\r\n      const newHalfCanvasWidth = canvasWidth / 2 + dXCanvas;\r\n      const canvasLeft = <Types.Point2>[\r\n        centerCanvas[0] - newHalfCanvasWidth,\r\n        centerCanvas[1],\r\n      ];\r\n      const canvasRight = <Types.Point2>[\r\n        centerCanvas[0] + newHalfCanvasWidth,\r\n        centerCanvas[1],\r\n      ];\r\n\r\n      points[2] = canvasToWorld(canvasLeft);\r\n      points[3] = canvasToWorld(canvasRight);\r\n    } else {\r\n      // Dragging left or right point\r\n      const dXCanvas = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\r\n      const canvasLeft = <Types.Point2>[\r\n        centerCanvas[0] - dXCanvas,\r\n        centerCanvas[1],\r\n      ];\r\n      const canvasRight = <Types.Point2>[\r\n        centerCanvas[0] + dXCanvas,\r\n        centerCanvas[1],\r\n      ];\r\n\r\n      points[2] = canvasToWorld(canvasLeft);\r\n      points[3] = canvasToWorld(canvasRight);\r\n\r\n      const dYCanvas = currentCanvasPoints[1] - originalHandleCanvas[1];\r\n      const newHalfCanvasHeight = canvasHeight / 2 + dYCanvas;\r\n      const canvasBottom = <Types.Point2>[\r\n        centerCanvas[0],\r\n        centerCanvas[1] - newHalfCanvasHeight,\r\n      ];\r\n      const canvasTop = <Types.Point2>[\r\n        centerCanvas[0],\r\n        centerCanvas[1] + newHalfCanvasHeight,\r\n      ];\r\n\r\n      points[0] = canvasToWorld(canvasBottom);\r\n      points[1] = canvasToWorld(canvasTop);\r\n    }\r\n  };\r\n\r\n  cancel = (element: HTMLDivElement) => {\r\n    // If it is mid-draw or mid-modify\r\n    if (this.isDrawing) {\r\n      this.isDrawing = false;\r\n      this._deactivateDraw(element);\r\n      this._deactivateModify(element);\r\n      resetElementCursor(element);\r\n\r\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\r\n      const { data } = annotation;\r\n\r\n      annotation.highlighted = false;\r\n      data.handles.activeHandleIndex = null;\r\n\r\n      const { renderingEngine } = getEnabledElement(element);\r\n\r\n      triggerAnnotationRenderForViewportIds(\r\n        renderingEngine,\r\n        viewportIdsToRender\r\n      );\r\n\r\n      if (newAnnotation) {\r\n        triggerAnnotationCompleted(annotation);\r\n      }\r\n\r\n      this.editData = null;\r\n      return annotation.annotationUID;\r\n    }\r\n  };\r\n\r\n  _activateModify = (element) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\r\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  _deactivateModify = (element) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\r\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  _activateDraw = (element) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\r\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\r\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  _deactivateDraw = (element) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\r\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\r\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the ellipticalROI annotation in each\r\n   * request animation frame. It calculates the updated cached statistics if\r\n   * data is invalidated and cache it.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n\r\n    let annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    annotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    );\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const targetId = this.getTargetId(viewport);\r\n\r\n    const renderingEngine = viewport.getRenderingEngine();\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[i] as EllipticalROIAnnotation;\r\n      const { annotationUID, data } = annotation;\r\n      const { handles } = data;\r\n      const { points, activeHandleIndex } = handles;\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\r\n        annotation,\r\n        styleSpecifier,\r\n      });\r\n\r\n      const canvasCoordinates = points.map((p) =>\r\n        viewport.worldToCanvas(p)\r\n      ) as [Types.Point2, Types.Point2, Types.Point2, Types.Point2];\r\n\r\n      const rotation = Math.abs(\r\n        viewport.getRotation() - (data.initialRotation || 0)\r\n      );\r\n      const canvasCorners = <Array<Types.Point2>>(\r\n        getCanvasEllipseCorners(canvasCoordinates) // bottom, top, left, right, keep as is\r\n      );\r\n\r\n      const { centerPointRadius } = this.configuration;\r\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\r\n      // force to recalculate the stats from the points\r\n      if (\r\n        !data.cachedStats[targetId] ||\r\n        data.cachedStats[targetId].areaUnit == null\r\n      ) {\r\n        data.cachedStats[targetId] = {\r\n          Modality: null,\r\n          area: null,\r\n          max: null,\r\n          mean: null,\r\n          stdDev: null,\r\n          areaUnit: null,\r\n        };\r\n\r\n        this._calculateCachedStats(annotation, viewport, renderingEngine);\r\n      } else if (annotation.invalidated) {\r\n        this._throttledCalculateCachedStats(\r\n          annotation,\r\n          viewport,\r\n          renderingEngine,\r\n          enabledElement\r\n        );\r\n        // If the invalidated data is as a result of volumeViewport manipulation\r\n        // of the tools, we need to invalidate the related viewports data, so that\r\n        // when scrolling to the related slice in which the tool were manipulated\r\n        // we re-render the correct tool position. This is due to stackViewport\r\n        // which doesn't have the full volume at each time, and we are only working\r\n        // on one slice at a time.\r\n        if (viewport instanceof VolumeViewport) {\r\n          const { referencedImageId } = annotation.metadata;\r\n\r\n          // invalidate all the relevant stackViewports if they are not\r\n          // at the referencedImageId\r\n          for (const targetId in data.cachedStats) {\r\n            if (targetId.startsWith('imageId')) {\r\n              const viewports = renderingEngine.getStackViewports();\r\n\r\n              const invalidatedStack = viewports.find((vp) => {\r\n                // The stack viewport that contains the imageId but is not\r\n                // showing it currently\r\n                const referencedImageURI =\r\n                  csUtils.imageIdToURI(referencedImageId);\r\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\r\n                const currentImageURI = csUtils.imageIdToURI(\r\n                  vp.getCurrentImageId()\r\n                );\r\n                return hasImageURI && currentImageURI !== referencedImageURI;\r\n              });\r\n\r\n              if (invalidatedStack) {\r\n                delete data.cachedStats[targetId];\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n\r\n      let activeHandleCanvasCoords;\r\n\r\n      if (!isAnnotationVisible(annotationUID)) {\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        !isAnnotationLocked(annotation) &&\r\n        !this.editData &&\r\n        activeHandleIndex !== null\r\n      ) {\r\n        // Not locked or creating and hovering over handle, so render handle.\r\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\r\n      }\r\n\r\n      if (activeHandleCanvasCoords) {\r\n        const handleGroupUID = '0';\r\n        drawHandlesSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          handleGroupUID,\r\n          activeHandleCanvasCoords,\r\n          {\r\n            color,\r\n          }\r\n        );\r\n      }\r\n\r\n      const dataId = `${annotationUID}-ellipse`;\r\n      const ellipseUID = '0';\r\n      drawEllipseSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        ellipseUID,\r\n        canvasCoordinates,\r\n        {\r\n          color,\r\n          lineDash,\r\n          lineWidth,\r\n        },\r\n        dataId\r\n      );\r\n\r\n      // draw center point, if \"centerPointRadius\" configuration is valid.\r\n      if (centerPointRadius > 0) {\r\n        const minRadius = Math.min(\r\n          Math.abs(canvasCorners[0][0] - canvasCorners[1][0]) / 2, // horizontal radius\r\n          Math.abs(canvasCorners[0][1] - canvasCorners[1][1]) / 2 // vertical radius\r\n        );\r\n        if (minRadius > 3 * centerPointRadius) {\r\n          const centerPoint = this._getCanvasEllipseCenter(canvasCoordinates);\r\n          drawCircleSvg(\r\n            svgDrawingHelper,\r\n            annotationUID,\r\n            `${ellipseUID}-center`,\r\n            centerPoint,\r\n            centerPointRadius,\r\n            {\r\n              color,\r\n              lineDash,\r\n              lineWidth,\r\n            }\r\n          );\r\n        }\r\n      }\r\n\r\n      renderStatus = true;\r\n\r\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\r\n      if (!options.visibility) {\r\n        data.handles.textBox = {\r\n          hasMoved: false,\r\n          worldPosition: <Types.Point3>[0, 0, 0],\r\n          worldBoundingBox: {\r\n            topLeft: <Types.Point3>[0, 0, 0],\r\n            topRight: <Types.Point3>[0, 0, 0],\r\n            bottomLeft: <Types.Point3>[0, 0, 0],\r\n            bottomRight: <Types.Point3>[0, 0, 0],\r\n          },\r\n        };\r\n        continue;\r\n      }\r\n\r\n      const textLines = this.configuration.getTextLines(data, targetId);\r\n      if (!textLines || textLines.length === 0) {\r\n        continue;\r\n      }\r\n\r\n      // Poor man's cached?\r\n      let canvasTextBoxCoords;\r\n\r\n      if (!data.handles.textBox.hasMoved) {\r\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\r\n\r\n        data.handles.textBox.worldPosition =\r\n          viewport.canvasToWorld(canvasTextBoxCoords);\r\n      }\r\n\r\n      const textBoxPosition = viewport.worldToCanvas(\r\n        data.handles.textBox.worldPosition\r\n      );\r\n\r\n      const textBoxUID = '1';\r\n      const boundingBox = drawLinkedTextBoxSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        textBoxUID,\r\n        textLines,\r\n        textBoxPosition,\r\n        canvasCoordinates,\r\n        {},\r\n        options\r\n      );\r\n\r\n      const { x: left, y: top, width, height } = boundingBox;\r\n\r\n      data.handles.textBox.worldBoundingBox = {\r\n        topLeft: viewport.canvasToWorld([left, top]),\r\n        topRight: viewport.canvasToWorld([left + width, top]),\r\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\r\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\r\n      };\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  _calculateCachedStats = (annotation, viewport, renderingEngine) => {\r\n    const data = annotation.data;\r\n    const { element } = viewport;\r\n\r\n    const { points } = data.handles;\r\n\r\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\r\n\r\n    const [topLeftCanvas, bottomRightCanvas] = <Array<Types.Point2>>(\r\n      getCanvasEllipseCorners(canvasCoordinates)\r\n    );\r\n\r\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\r\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\r\n    const { cachedStats } = data;\r\n\r\n    const targetIds = Object.keys(cachedStats);\r\n    const worldPos1 = topLeftWorld;\r\n    const worldPos2 = bottomRightWorld;\r\n\r\n    for (let i = 0; i < targetIds.length; i++) {\r\n      const targetId = targetIds[i];\r\n\r\n      const image = this.getTargetIdImage(targetId, renderingEngine);\r\n\r\n      // If image does not exists for the targetId, skip. This can be due\r\n      // to various reasons such as if the target was a volumeViewport, and\r\n      // the volumeViewport has been decached in the meantime.\r\n      if (!image) {\r\n        continue;\r\n      }\r\n\r\n      const { dimensions, imageData, metadata } = image;\r\n\r\n      const pos1Index = transformWorldToIndex(imageData, worldPos1);\r\n\r\n      pos1Index[0] = Math.floor(pos1Index[0]);\r\n      pos1Index[1] = Math.floor(pos1Index[1]);\r\n      pos1Index[2] = Math.floor(pos1Index[2]);\r\n\r\n      const post2Index = transformWorldToIndex(imageData, worldPos2);\r\n\r\n      post2Index[0] = Math.floor(post2Index[0]);\r\n      post2Index[1] = Math.floor(post2Index[1]);\r\n      post2Index[2] = Math.floor(post2Index[2]);\r\n\r\n      // Check if one of the indexes are inside the volume, this then gives us\r\n      // Some area to do stats over.\r\n\r\n      this.isHandleOutsideImage = !this._isInsideVolume(\r\n        pos1Index,\r\n        post2Index,\r\n        dimensions\r\n      );\r\n\r\n      const iMin = Math.min(pos1Index[0], post2Index[0]);\r\n      const iMax = Math.max(pos1Index[0], post2Index[0]);\r\n\r\n      const jMin = Math.min(pos1Index[1], post2Index[1]);\r\n      const jMax = Math.max(pos1Index[1], post2Index[1]);\r\n\r\n      const kMin = Math.min(pos1Index[2], post2Index[2]);\r\n      const kMax = Math.max(pos1Index[2], post2Index[2]);\r\n\r\n      const boundsIJK = [\r\n        [iMin, iMax],\r\n        [jMin, jMax],\r\n        [kMin, kMax],\r\n      ] as [Types.Point2, Types.Point2, Types.Point2];\r\n\r\n      const center = [\r\n        (topLeftWorld[0] + bottomRightWorld[0]) / 2,\r\n        (topLeftWorld[1] + bottomRightWorld[1]) / 2,\r\n        (topLeftWorld[2] + bottomRightWorld[2]) / 2,\r\n      ] as Types.Point3;\r\n\r\n      const ellipseObj = {\r\n        center,\r\n        xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\r\n        yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\r\n        zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\r\n      };\r\n\r\n      const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\r\n        viewPlaneNormal,\r\n        viewUp,\r\n        worldPos1,\r\n        worldPos2\r\n      );\r\n      const isEmptyArea = worldWidth === 0 && worldHeight === 0;\r\n\r\n      const handles = [pos1Index, post2Index];\r\n      const { scale, areaUnits } = getCalibratedLengthUnitsAndScale(\r\n        image,\r\n        handles\r\n      );\r\n\r\n      const area =\r\n        Math.abs(Math.PI * (worldWidth / 2) * (worldHeight / 2)) /\r\n        scale /\r\n        scale;\r\n\r\n      const modalityUnitOptions = {\r\n        isPreScaled: isViewportPreScaled(viewport, targetId),\r\n\r\n        isSuvScaled: this.isSuvScaled(\r\n          viewport,\r\n          targetId,\r\n          annotation.metadata.referencedImageId\r\n        ),\r\n      };\r\n\r\n      const modalityUnit = getModalityUnit(\r\n        metadata.Modality,\r\n        annotation.metadata.referencedImageId,\r\n        modalityUnitOptions\r\n      );\r\n\r\n      const pointsInShape = pointInShapeCallback(\r\n        imageData,\r\n        (pointLPS) => pointInEllipse(ellipseObj, pointLPS, { fast: true }),\r\n        this.configuration.statsCalculator.statsCallback,\r\n        boundsIJK\r\n      );\r\n\r\n      const stats = this.configuration.statsCalculator.getStatistics();\r\n      cachedStats[targetId] = {\r\n        Modality: metadata.Modality,\r\n        area,\r\n        mean: stats.mean?.value,\r\n        max: stats.max?.value,\r\n        stdDev: stats.stdDev?.value,\r\n        statsArray: stats.array,\r\n        pointsInShape,\r\n        isEmptyArea,\r\n        areaUnit: areaUnits,\r\n        modalityUnit,\r\n      };\r\n    }\r\n\r\n    annotation.invalidated = false;\r\n\r\n    // Dispatching annotation modified\r\n    triggerAnnotationModified(annotation, element);\r\n\r\n    return cachedStats;\r\n  };\r\n\r\n  _isInsideVolume = (index1, index2, dimensions) => {\r\n    return (\r\n      csUtils.indexWithinDimensions(index1, dimensions) &&\r\n      csUtils.indexWithinDimensions(index2, dimensions)\r\n    );\r\n  };\r\n\r\n  /**\r\n   * This is a temporary function to use the old ellipse's canvas-based\r\n   * calculation for isPointNearTool, we should move the the world-based\r\n   * calculation to the tool's isPointNearTool function.\r\n   *\r\n   * @param ellipse - The ellipse object\r\n   * @param location - The location to check\r\n   * @returns True if the point is inside the ellipse\r\n   */\r\n  _pointInEllipseCanvas(ellipse, location: Types.Point2): boolean {\r\n    const xRadius = ellipse.width / 2;\r\n    const yRadius = ellipse.height / 2;\r\n\r\n    if (xRadius <= 0.0 || yRadius <= 0.0) {\r\n      return false;\r\n    }\r\n\r\n    const center = [ellipse.left + xRadius, ellipse.top + yRadius];\r\n    const normalized = [location[0] - center[0], location[1] - center[1]];\r\n\r\n    const inEllipse =\r\n      (normalized[0] * normalized[0]) / (xRadius * xRadius) +\r\n        (normalized[1] * normalized[1]) / (yRadius * yRadius) <=\r\n      1.0;\r\n\r\n    return inEllipse;\r\n  }\r\n\r\n  /**\r\n   * It takes the canvas coordinates of the ellipse corners and returns the center point of it\r\n   *\r\n   * @param ellipseCanvasPoints - The coordinates of the ellipse in the canvas.\r\n   * @returns center point.\r\n   */\r\n  _getCanvasEllipseCenter(ellipseCanvasPoints: Types.Point2[]): Types.Point2 {\r\n    const [bottom, top, left, right] = ellipseCanvasPoints;\r\n    const topLeft = [left[0], top[1]];\r\n    const bottomRight = [right[0], bottom[1]];\r\n    return [\r\n      (topLeft[0] + bottomRight[0]) / 2,\r\n      (topLeft[1] + bottomRight[1]) / 2,\r\n    ] as Types.Point2;\r\n  }\r\n}\r\n\r\nfunction defaultGetTextLines(data, targetId): string[] {\r\n  const cachedVolumeStats = data.cachedStats[targetId];\r\n  const { area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit } =\r\n    cachedVolumeStats;\r\n\r\n  const textLines: string[] = [];\r\n\r\n  if (area) {\r\n    const areaLine = isEmptyArea\r\n      ? `Area: Oblique not supported`\r\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\r\n    textLines.push(areaLine);\r\n  }\r\n\r\n  if (mean) {\r\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\r\n  }\r\n\r\n  if (max) {\r\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\r\n  }\r\n\r\n  if (stdDev) {\r\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\r\n  }\r\n\r\n  return textLines;\r\n}\r\n\r\nEllipticalROITool.toolName = 'EllipticalROI';\r\nexport default EllipticalROITool;\r\n","import { Events } from '../../enums';\r\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { AnnotationTool } from '../base';\r\nimport {\r\n  addAnnotation,\r\n  getAnnotations,\r\n  removeAnnotation,\r\n} from '../../stateManagement/annotation/annotationState';\r\n\r\nimport {\r\n  triggerAnnotationCompleted,\r\n  triggerAnnotationModified,\r\n} from '../../stateManagement/annotation/helpers/state';\r\nimport { drawArrow as drawArrowSvg } from '../../drawingSvg';\r\nimport { state } from '../../store';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\n\r\nimport { resetElementCursor } from '../../cursors/elementCursor';\r\n\r\nimport {\r\n  EventTypes,\r\n  ToolHandle,\r\n  PublicToolProps,\r\n  ToolProps,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\nimport { Annotation } from '../../types';\r\n\r\ntype Point2 = Types.Point2;\r\n\r\nclass KeyImageTool extends AnnotationTool {\r\n  static toolName;\r\n\r\n  public touchDragCallback: any;\r\n  public mouseDragCallback: any;\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: string[];\r\n    handleIndex?: number;\r\n    movingTextBox?: boolean;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        getTextCallback,\r\n        changeTextCallback,\r\n        canvasPosition: [10, 10],\r\n        canvasSize: 10,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the current imageId to create\r\n   * a Length Annotation and stores it in the annotationManager\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    const referencedImageId = this.getReferencedImageId(\r\n      viewport,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      viewUp\r\n    );\r\n\r\n    const annotation = KeyImageTool.createAnnotation({\r\n      metadata: { ...viewport.getViewReference(), referencedImageId },\r\n    });\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    this.configuration.getTextCallback((text) => {\r\n      if (!text) {\r\n        removeAnnotation(annotation.annotationUID);\r\n        triggerAnnotationRenderForViewportIds(\r\n          renderingEngine,\r\n          viewportIdsToRender\r\n        );\r\n        this.isDrawing = false;\r\n        return;\r\n      }\r\n      annotation.data.text = text;\r\n\r\n      triggerAnnotationCompleted(annotation);\r\n\r\n      triggerAnnotationRenderForViewportIds(\r\n        renderingEngine,\r\n        viewportIdsToRender\r\n      );\r\n    });\r\n\r\n    return annotation;\r\n  };\r\n\r\n  public cancel() {\r\n    // No op - the annotation can't be in a partial state\r\n  }\r\n\r\n  /**\r\n   * It returns if the canvas point is near the provided length annotation in the provided\r\n   * element or not. A proximity is passed to the function to determine the\r\n   * proximity of the point to the annotation in number of pixels.\r\n   *\r\n   * @param element - HTML Element\r\n   * @param annotation - Annotation\r\n   * @param canvasCoords - Canvas coordinates\r\n   * @param proximity - Proximity to tool to consider\r\n   * @returns Boolean, whether the canvas point is near tool\r\n   */\r\n  isPointNearTool = (\r\n    element: HTMLDivElement,\r\n    annotation: Annotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): boolean => {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const { data } = annotation;\r\n\r\n    const { canvasPosition, canvasSize } = this.configuration;\r\n    if (!canvasPosition?.length) {\r\n      return false;\r\n    }\r\n    if (\r\n      Math.abs(canvasCoords[0] - canvasPosition[0] + canvasSize / 2) <=\r\n        canvasSize / 2 &&\r\n      Math.abs(canvasCoords[1] - canvasPosition[1] + canvasSize / 2) <=\r\n        canvasSize / 2\r\n    ) {\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  toolSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: Annotation\r\n  ): void => {\r\n    annotation.highlighted = true;\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  handleSelectedCallback(\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: Annotation,\r\n    handle: ToolHandle\r\n  ): void {\r\n    // Nothing special to do here.\r\n  }\r\n\r\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    this._deactivateModify(element);\r\n    resetElementCursor(element);\r\n  };\r\n\r\n  doubleClickCallback = (evt: EventTypes.TouchTapEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    let annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    annotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    );\r\n\r\n    if (!annotations?.length) {\r\n      return;\r\n    }\r\n\r\n    const clickedAnnotation = annotations.find((annotation) =>\r\n      this.isPointNearTool(\r\n        element,\r\n        annotation as Annotation,\r\n        eventDetail.currentPoints.canvas,\r\n        6 // Todo: get from configuration\r\n      )\r\n    );\r\n\r\n    if (!clickedAnnotation) {\r\n      return;\r\n    }\r\n\r\n    const annotation = clickedAnnotation as Annotation;\r\n\r\n    this.configuration.changeTextCallback(\r\n      clickedAnnotation,\r\n      evt.detail,\r\n      this._doneChangingTextCallback.bind(this, element, annotation)\r\n    );\r\n\r\n    this.isDrawing = false;\r\n\r\n    // This double click was handled and the dialogue was displayed.\r\n    // No need for any other listener to handle it too - stopImmediatePropagation\r\n    // helps ensure this primarily so that no other listeners on the target element\r\n    // get called.\r\n    evt.stopImmediatePropagation();\r\n    evt.preventDefault();\r\n  };\r\n\r\n  _doneChangingTextCallback(element, annotation, updatedText): void {\r\n    annotation.data.text = updatedText;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    // Dispatching annotation modified\r\n    triggerAnnotationModified(annotation, element);\r\n  }\r\n\r\n  _activateModify = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(\r\n      Events.MOUSE_UP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._endCallback as EventListener\r\n    );\r\n\r\n    element.addEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _deactivateModify = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(\r\n      Events.MOUSE_UP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._endCallback as EventListener\r\n    );\r\n\r\n    element.removeEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the length annotation in each\r\n   * request animation frame. It calculates the updated cached statistics if\r\n   * data is invalidated and cache it.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n\r\n    let annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    annotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    );\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    // Draw SVG\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[i];\r\n      const { annotationUID } = annotation;\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const { color } = this.getAnnotationStyle({\r\n        annotation,\r\n        styleSpecifier,\r\n      });\r\n\r\n      const { canvasPosition, canvasSize } = this.configuration;\r\n      if (canvasPosition?.length) {\r\n        const arrowUID = '1';\r\n        drawArrowSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          arrowUID,\r\n          canvasPosition.map((it) => it + canvasSize) as Point2,\r\n          canvasPosition as Point2,\r\n          {\r\n            color,\r\n            width: 1,\r\n          }\r\n        );\r\n      }\r\n\r\n      renderStatus = true;\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  _isInsideVolume(index1, index2, dimensions) {\r\n    return (\r\n      csUtils.indexWithinDimensions(index1, dimensions) &&\r\n      csUtils.indexWithinDimensions(index2, dimensions)\r\n    );\r\n  }\r\n}\r\n\r\nfunction getTextCallback(doneChangingTextCallback) {\r\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\r\n}\r\n\r\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\r\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\r\n}\r\n\r\nKeyImageTool.toolName = 'KeyImage';\r\n\r\nexport default KeyImageTool;\r\n","import { Events } from '../../enums';\r\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\r\nimport { roundNumber } from '../../utilities';\r\nimport { AnnotationTool } from '../base';\r\nimport throttle from '../../utilities/throttle';\r\nimport {\r\n  addAnnotation,\r\n  getAnnotations,\r\n  removeAnnotation,\r\n} from '../../stateManagement/annotation/annotationState';\r\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\r\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\r\nimport {\r\n  triggerAnnotationCompleted,\r\n  triggerAnnotationModified,\r\n} from '../../stateManagement/annotation/helpers/state';\r\nimport * as lineSegment from '../../utilities/math/line';\r\n\r\nimport {\r\n  drawHandles as drawHandlesSvg,\r\n  drawLine as drawLineSvg,\r\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\r\n} from '../../drawingSvg';\r\nimport { state } from '../../store';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\n\r\nimport {\r\n  resetElementCursor,\r\n  hideElementCursor,\r\n} from '../../cursors/elementCursor';\r\n\r\nimport {\r\n  EventTypes,\r\n  ToolHandle,\r\n  TextBoxHandle,\r\n  PublicToolProps,\r\n  ToolProps,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\nimport { LengthAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\n\r\nconst { transformWorldToIndex } = csUtils;\r\n\r\n/**\r\n * LengthTool let you draw annotations that measures the length of two drawing\r\n * points on a slice. You can use the LengthTool in all imaging planes even in oblique\r\n * reconstructed planes. Note: annotation tools in cornerstone3DTools exists in the exact location\r\n * in the physical 3d space, as a result, by default, all annotations that are\r\n * drawing in the same frameOfReference will get shared between viewports that\r\n * are in the same frameOfReference.\r\n *\r\n * The resulting annotation's data (statistics) and metadata (the\r\n * state of the viewport while drawing was happening) will get added to the\r\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\r\n * or similar methods.\r\n *\r\n * ```js\r\n * cornerstoneTools.addTool(LengthTool)\r\n *\r\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\r\n *\r\n * toolGroup.addTool(LengthTool.toolName)\r\n *\r\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\r\n *\r\n * toolGroup.setToolActive(LengthTool.toolName, {\r\n *   bindings: [\r\n *    {\r\n *       mouseButton: MouseBindings.Primary, // Left Click\r\n *     },\r\n *   ],\r\n * })\r\n * ```\r\n *\r\n * Read more in the Docs section of the website.\r\n\r\n */\r\n\r\nclass LengthTool extends AnnotationTool {\r\n  static toolName;\r\n\r\n  public touchDragCallback: any;\r\n  public mouseDragCallback: any;\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: string[];\r\n    handleIndex?: number;\r\n    movingTextBox?: boolean;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        preventHandleOutsideImage: false,\r\n        getTextLines: defaultGetTextLines,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n\r\n    this._throttledCalculateCachedStats = throttle(\r\n      this._calculateCachedStats,\r\n      100,\r\n      { trailing: true }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the current imageId to create\r\n   * a Length Annotation and stores it in the annotationManager\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation = (\r\n    evt: EventTypes.InteractionEventType\r\n  ): LengthAnnotation => {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    hideElementCursor(element);\r\n    this.isDrawing = true;\r\n\r\n    const {\r\n      viewPlaneNormal,\r\n      viewUp,\r\n      position: cameraPosition,\r\n    } = viewport.getCamera();\r\n    const referencedImageId = this.getReferencedImageId(\r\n      viewport,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      viewUp\r\n    );\r\n\r\n    const annotation = {\r\n      highlighted: true,\r\n      invalidated: true,\r\n      metadata: {\r\n        ...viewport.getViewReference({ points: [worldPos] }),\r\n        toolName: this.getToolName(),\r\n        referencedImageId,\r\n        viewUp,\r\n        cameraPosition,\r\n      },\r\n      data: {\r\n        handles: {\r\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\r\n          activeHandleIndex: null,\r\n          textBox: {\r\n            hasMoved: false,\r\n            worldPosition: <Types.Point3>[0, 0, 0],\r\n            worldBoundingBox: {\r\n              topLeft: <Types.Point3>[0, 0, 0],\r\n              topRight: <Types.Point3>[0, 0, 0],\r\n              bottomLeft: <Types.Point3>[0, 0, 0],\r\n              bottomRight: <Types.Point3>[0, 0, 0],\r\n            },\r\n          },\r\n        },\r\n        label: '',\r\n        cachedStats: {},\r\n      },\r\n    };\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex: 1,\r\n      movingTextBox: false,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n    };\r\n    this._activateDraw(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  };\r\n\r\n  /**\r\n   * It returns if the canvas point is near the provided length annotation in the provided\r\n   * element or not. A proximity is passed to the function to determine the\r\n   * proximity of the point to the annotation in number of pixels.\r\n   *\r\n   * @param element - HTML Element\r\n   * @param annotation - Annotation\r\n   * @param canvasCoords - Canvas coordinates\r\n   * @param proximity - Proximity to tool to consider\r\n   * @returns Boolean, whether the canvas point is near tool\r\n   */\r\n  isPointNearTool = (\r\n    element: HTMLDivElement,\r\n    annotation: LengthAnnotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): boolean => {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const { data } = annotation;\r\n    const [point1, point2] = data.handles.points;\r\n    const canvasPoint1 = viewport.worldToCanvas(point1);\r\n    const canvasPoint2 = viewport.worldToCanvas(point2);\r\n\r\n    const line = {\r\n      start: {\r\n        x: canvasPoint1[0],\r\n        y: canvasPoint1[1],\r\n      },\r\n      end: {\r\n        x: canvasPoint2[0],\r\n        y: canvasPoint2[1],\r\n      },\r\n    };\r\n\r\n    const distanceToPoint = lineSegment.distanceToPoint(\r\n      [line.start.x, line.start.y],\r\n      [line.end.x, line.end.y],\r\n      [canvasCoords[0], canvasCoords[1]]\r\n    );\r\n\r\n    if (distanceToPoint <= proximity) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  toolSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: LengthAnnotation\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      movingTextBox: false,\r\n    };\r\n\r\n    this._activateModify(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  handleSelectedCallback(\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: LengthAnnotation,\r\n    handle: ToolHandle\r\n  ): void {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const { data } = annotation;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    let movingTextBox = false;\r\n    let handleIndex;\r\n\r\n    if ((handle as TextBoxHandle).worldPosition) {\r\n      movingTextBox = true;\r\n    } else {\r\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\r\n    }\r\n\r\n    // Find viewports to render on drag.\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex,\r\n      movingTextBox,\r\n    };\r\n    this._activateModify(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  }\r\n\r\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (newAnnotation && !hasMoved) {\r\n      // when user starts the drawing by click, and moving the mouse, instead\r\n      // of click and drag\r\n      return;\r\n    }\r\n\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateModify(element);\r\n    this._deactivateDraw(element);\r\n    resetElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    if (\r\n      this.isHandleOutsideImage &&\r\n      this.configuration.preventHandleOutsideImage\r\n    ) {\r\n      removeAnnotation(annotation.annotationUID);\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    if (newAnnotation) {\r\n      triggerAnnotationCompleted(annotation);\r\n    }\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n  };\r\n\r\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    this.isDrawing = true;\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (movingTextBox) {\r\n      // Drag mode - moving text box\r\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n\r\n      const { textBox } = data.handles;\r\n      const { worldPosition } = textBox;\r\n\r\n      worldPosition[0] += worldPosDelta[0];\r\n      worldPosition[1] += worldPosDelta[1];\r\n      worldPosition[2] += worldPosDelta[2];\r\n\r\n      textBox.hasMoved = true;\r\n    } else if (handleIndex === undefined) {\r\n      // Drag mode - moving handle\r\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n\r\n      const points = data.handles.points;\r\n\r\n      points.forEach((point) => {\r\n        point[0] += worldPosDelta[0];\r\n        point[1] += worldPosDelta[1];\r\n        point[2] += worldPosDelta[2];\r\n      });\r\n      annotation.invalidated = true;\r\n    } else {\r\n      // Move mode - after double click, and mouse move to draw\r\n      const { currentPoints } = eventDetail;\r\n      const worldPos = currentPoints.world;\r\n\r\n      data.handles.points[handleIndex] = [...worldPos];\r\n      annotation.invalidated = true;\r\n    }\r\n\r\n    this.editData.hasMoved = true;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  cancel = (element: HTMLDivElement) => {\r\n    // If it is mid-draw or mid-modify\r\n    if (this.isDrawing) {\r\n      this.isDrawing = false;\r\n      this._deactivateDraw(element);\r\n      this._deactivateModify(element);\r\n      resetElementCursor(element);\r\n\r\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\r\n      const { data } = annotation;\r\n\r\n      annotation.highlighted = false;\r\n      data.handles.activeHandleIndex = null;\r\n\r\n      const enabledElement = getEnabledElement(element);\r\n      const { renderingEngine } = enabledElement;\r\n\r\n      triggerAnnotationRenderForViewportIds(\r\n        renderingEngine,\r\n        viewportIdsToRender\r\n      );\r\n\r\n      if (newAnnotation) {\r\n        triggerAnnotationCompleted(annotation);\r\n      }\r\n\r\n      this.editData = null;\r\n      return annotation.annotationUID;\r\n    }\r\n  };\r\n\r\n  _activateModify = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(\r\n      Events.MOUSE_UP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._endCallback as EventListener\r\n    );\r\n\r\n    element.addEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _deactivateModify = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(\r\n      Events.MOUSE_UP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._endCallback as EventListener\r\n    );\r\n\r\n    element.removeEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _activateDraw = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(\r\n      Events.MOUSE_UP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_MOVE,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._endCallback as EventListener\r\n    );\r\n\r\n    element.addEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _deactivateDraw = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(\r\n      Events.MOUSE_UP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_MOVE,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._endCallback as EventListener\r\n    );\r\n\r\n    element.removeEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the length annotation in each\r\n   * request animation frame. It calculates the updated cached statistics if\r\n   * data is invalidated and cache it.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n\r\n    let annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    annotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    );\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const targetId = this.getTargetId(viewport);\r\n    const renderingEngine = viewport.getRenderingEngine();\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    // Draw SVG\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[i] as LengthAnnotation;\r\n      const { annotationUID, data } = annotation;\r\n      const { points, activeHandleIndex } = data.handles;\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\r\n        annotation,\r\n        styleSpecifier,\r\n      });\r\n\r\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n      let activeHandleCanvasCoords;\r\n\r\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\r\n      // force to recalculate the stats from the points\r\n      if (\r\n        !data.cachedStats[targetId] ||\r\n        data.cachedStats[targetId].unit == null\r\n      ) {\r\n        data.cachedStats[targetId] = {\r\n          length: null,\r\n          unit: null,\r\n        };\r\n\r\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\r\n      } else if (annotation.invalidated) {\r\n        this._throttledCalculateCachedStats(\r\n          annotation,\r\n          renderingEngine,\r\n          enabledElement\r\n        );\r\n      }\r\n\r\n      if (!isAnnotationVisible(annotationUID)) {\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        !isAnnotationLocked(annotation) &&\r\n        !this.editData &&\r\n        activeHandleIndex !== null\r\n      ) {\r\n        // Not locked or creating and hovering over handle, so render handle.\r\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\r\n      }\r\n\r\n      if (activeHandleCanvasCoords) {\r\n        const handleGroupUID = '0';\r\n\r\n        drawHandlesSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          handleGroupUID,\r\n          canvasCoordinates,\r\n          {\r\n            color,\r\n            lineDash,\r\n            lineWidth,\r\n          }\r\n        );\r\n      }\r\n\r\n      const dataId = `${annotationUID}-line`;\r\n      const lineUID = '1';\r\n      drawLineSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        lineUID,\r\n        canvasCoordinates[0],\r\n        canvasCoordinates[1],\r\n        {\r\n          color,\r\n          width: lineWidth,\r\n          lineDash,\r\n          shadow,\r\n        },\r\n        dataId\r\n      );\r\n\r\n      renderStatus = true;\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n\r\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\r\n      if (!options.visibility) {\r\n        data.handles.textBox = {\r\n          hasMoved: false,\r\n          worldPosition: <Types.Point3>[0, 0, 0],\r\n          worldBoundingBox: {\r\n            topLeft: <Types.Point3>[0, 0, 0],\r\n            topRight: <Types.Point3>[0, 0, 0],\r\n            bottomLeft: <Types.Point3>[0, 0, 0],\r\n            bottomRight: <Types.Point3>[0, 0, 0],\r\n          },\r\n        };\r\n        continue;\r\n      }\r\n\r\n      const textLines = this.configuration.getTextLines(data, targetId);\r\n\r\n      // Need to update to sync with annotation while unlinked/not moved\r\n      if (!data.handles.textBox.hasMoved) {\r\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\r\n\r\n        data.handles.textBox.worldPosition =\r\n          viewport.canvasToWorld(canvasTextBoxCoords);\r\n      }\r\n\r\n      const textBoxPosition = viewport.worldToCanvas(\r\n        data.handles.textBox.worldPosition\r\n      );\r\n\r\n      const textBoxUID = '1';\r\n      const boundingBox = drawLinkedTextBoxSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        textBoxUID,\r\n        textLines,\r\n        textBoxPosition,\r\n        canvasCoordinates,\r\n        {},\r\n        options\r\n      );\r\n\r\n      const { x: left, y: top, width, height } = boundingBox;\r\n\r\n      data.handles.textBox.worldBoundingBox = {\r\n        topLeft: viewport.canvasToWorld([left, top]),\r\n        topRight: viewport.canvasToWorld([left + width, top]),\r\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\r\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\r\n      };\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  _calculateLength(pos1, pos2) {\r\n    const dx = pos1[0] - pos2[0];\r\n    const dy = pos1[1] - pos2[1];\r\n    const dz = pos1[2] - pos2[2];\r\n\r\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\r\n  }\r\n\r\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\r\n    const data = annotation.data;\r\n    const { element } = enabledElement.viewport;\r\n\r\n    const worldPos1 = data.handles.points[0];\r\n    const worldPos2 = data.handles.points[1];\r\n    const { cachedStats } = data;\r\n    const targetIds = Object.keys(cachedStats);\r\n\r\n    // TODO clean up, this doesn't need a length per volume, it has no stats derived from volumes.\r\n\r\n    for (let i = 0; i < targetIds.length; i++) {\r\n      const targetId = targetIds[i];\r\n\r\n      const image = this.getTargetIdImage(targetId, renderingEngine);\r\n\r\n      // If image does not exists for the targetId, skip. This can be due\r\n      // to various reasons such as if the target was a volumeViewport, and\r\n      // the volumeViewport has been decached in the meantime.\r\n      if (!image) {\r\n        continue;\r\n      }\r\n\r\n      const { imageData, dimensions } = image;\r\n\r\n      const index1 = transformWorldToIndex(imageData, worldPos1);\r\n      const index2 = transformWorldToIndex(imageData, worldPos2);\r\n      const handles = [index1, index2];\r\n      const { scale, units } = getCalibratedLengthUnitsAndScale(image, handles);\r\n\r\n      const length = this._calculateLength(worldPos1, worldPos2) / scale;\r\n\r\n      this._isInsideVolume(index1, index2, dimensions)\r\n        ? (this.isHandleOutsideImage = false)\r\n        : (this.isHandleOutsideImage = true);\r\n\r\n      // TODO -> Do we instead want to clip to the bounds of the volume and only include that portion?\r\n      // Seems like a lot of work for an unrealistic case. At the moment bail out of stat calculation if either\r\n      // corner is off the canvas.\r\n\r\n      // todo: add insideVolume calculation, for removing tool if outside\r\n      cachedStats[targetId] = {\r\n        length,\r\n        unit: units,\r\n      };\r\n    }\r\n\r\n    annotation.invalidated = false;\r\n\r\n    // Dispatching annotation modified\r\n    triggerAnnotationModified(annotation, element);\r\n\r\n    return cachedStats;\r\n  }\r\n\r\n  _isInsideVolume(index1, index2, dimensions) {\r\n    return (\r\n      csUtils.indexWithinDimensions(index1, dimensions) &&\r\n      csUtils.indexWithinDimensions(index2, dimensions)\r\n    );\r\n  }\r\n}\r\n\r\nfunction defaultGetTextLines(data, targetId): string[] {\r\n  const cachedVolumeStats = data.cachedStats[targetId];\r\n  const { length, unit } = cachedVolumeStats;\r\n\r\n  // Can be null on load\r\n  if (length === undefined || length === null || isNaN(length)) {\r\n    return;\r\n  }\r\n\r\n  const textLines = [`${roundNumber(length)} ${unit}`];\r\n\r\n  return textLines;\r\n}\r\n\r\nLengthTool.toolName = 'Length';\r\nexport default LengthTool;\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport { utilities as csUtils } from '@cornerstonejs/core';\r\n\r\nimport LivewireContourTool from './LivewireContourTool';\r\nimport { LivewirePath } from '../../utilities/livewire/LiveWirePath';\r\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\r\nimport { ChangeTypes } from '../../enums';\r\nimport type { ContourSegmentationAnnotation } from '../../types';\r\nimport { drawPolyline as drawPolylineSvg } from '../../drawingSvg';\r\n\r\nclass LivewireContourSegmentationTool extends LivewireContourTool {\r\n  static toolName;\r\n\r\n  /**\r\n   * Updates the interpolated annotations with the currently displayed image data,\r\n   * performing hte livewire on the image data as generated.\r\n   * Note - this function is only called for interpolated livewire SEGMENTATION\r\n   * objects, and will return immediately otherwise.\r\n   *\r\n   * The work for the interpolation is performed in a microtask, enabling this\r\n   * method to return quickly for faster render speeds, but ensuring that the\r\n   * annotation data isn't updated before the changes are performed.  The removes\r\n   * some irritating flickering on navigation.\r\n   */\r\n  public updateInterpolatedAnnotation(\r\n    annotation: ContourSegmentationAnnotation,\r\n    enabledElement: Types.IEnabledElement\r\n  ) {\r\n    // The interpolation sources is used as a flag here - a true livewire\r\n    // behaviour would be to perform a livewire between the two planes\r\n    // closest to this plane for each point, and use that handle.  That is\r\n    // oblique, however, which is not currently supported.\r\n    if (\r\n      this.editData ||\r\n      !annotation.invalidated ||\r\n      !annotation.data.handles.interpolationSources\r\n    ) {\r\n      return;\r\n    }\r\n    annotation.data.contour.originalPolyline = annotation.data.contour.polyline;\r\n\r\n    // See docs above for why this is a microtask\r\n    queueMicrotask(() => {\r\n      if (!annotation.data.handles.interpolationSources) {\r\n        return;\r\n      }\r\n      const { points } = annotation.data.handles;\r\n\r\n      const { element } = enabledElement.viewport;\r\n      this.setupBaseEditData(points[0], element, annotation);\r\n      const { length: count } = points;\r\n      const { scissors } = this;\r\n      const { nearestEdge, repeatInterpolation } =\r\n        this.configuration.interpolation;\r\n      annotation.data.handles.originalPoints = points;\r\n      const { worldToSlice, sliceToWorld } = this.editData;\r\n      const handleSmoothing = [];\r\n\r\n      // New path generation - go through the handles and regenerate the polyline\r\n      if (nearestEdge) {\r\n        let lastPoint = worldToSlice(points[points.length - 1]);\r\n        // Nearest edge handling\r\n        points.forEach((point, hIndex) => {\r\n          const testPoint = worldToSlice(point);\r\n          lastPoint = testPoint;\r\n          handleSmoothing.push(testPoint);\r\n\r\n          // Fill the costs buffer and then find the minimum cost\r\n          // This is a little too aggressive about pulling the line in\r\n          scissors.startSearch(lastPoint);\r\n          scissors.findPathToPoint(testPoint);\r\n          // Fill the costs for a point a bit further along by searching for a\r\n          // point further along.\r\n          scissors.findPathToPoint(\r\n            worldToSlice(points[(hIndex + 3) % points.length])\r\n          );\r\n          const minPoint = scissors.findMinNearby(testPoint, nearestEdge);\r\n          if (!csUtils.isEqual(testPoint, minPoint)) {\r\n            handleSmoothing[hIndex] = minPoint;\r\n            lastPoint = minPoint;\r\n            points[hIndex] = sliceToWorld(minPoint);\r\n          }\r\n        });\r\n      }\r\n\r\n      // Regenerate the updated data based on the updated handles\r\n      const acceptedPath = new LivewirePath();\r\n      for (let i = 0; i < count; i++) {\r\n        scissors.startSearch(worldToSlice(points[i]));\r\n        const path = scissors.findPathToPoint(\r\n          worldToSlice(points[(i + 1) % count])\r\n        );\r\n        acceptedPath.addPoints(path);\r\n      }\r\n\r\n      // Now, update the rendering\r\n      this.updateAnnotation(acceptedPath);\r\n      this.scissors = null;\r\n      this.scissorsNext = null;\r\n      this.editData = null;\r\n      annotation.data.handles.interpolationSources = null;\r\n\r\n      if (repeatInterpolation) {\r\n        triggerAnnotationModified(\r\n          annotation,\r\n          enabledElement.viewport.element,\r\n          ChangeTypes.InterpolationUpdated\r\n        );\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Adds the update to the interpolated annotaiton on render an instance,\r\n   * but otherwise just calls the parent render annotation instance.\r\n   */\r\n  protected renderAnnotationInstance(renderContext): boolean {\r\n    const { enabledElement, svgDrawingHelper } = renderContext;\r\n    const annotation =\r\n      renderContext.annotation as ContourSegmentationAnnotation;\r\n    const { annotationUID } = annotation;\r\n    const { viewport } = enabledElement;\r\n    const { worldToCanvas } = viewport;\r\n    const { showInterpolationPolyline } =\r\n      this.configuration.interpolation || {};\r\n\r\n    this.updateInterpolatedAnnotation?.(annotation, enabledElement);\r\n    const { originalPolyline } = annotation.data.contour;\r\n\r\n    const rendered = super.renderAnnotationInstance(renderContext);\r\n\r\n    if (\r\n      showInterpolationPolyline &&\r\n      originalPolyline &&\r\n      annotation.autoGenerated\r\n    ) {\r\n      const polylineCanvasPoints = originalPolyline.map(\r\n        worldToCanvas\r\n      ) as Types.Point2[];\r\n      polylineCanvasPoints.push(polylineCanvasPoints[0]);\r\n      drawPolylineSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        'interpolationContour-0',\r\n        polylineCanvasPoints,\r\n        {\r\n          color: '#70ffff',\r\n          lineWidth: 1,\r\n          fillOpacity: 0,\r\n        }\r\n      );\r\n    }\r\n\r\n    return rendered;\r\n  }\r\n\r\n  protected isContourSegmentationTool(): boolean {\r\n    // Re-enable contour segmentation behavior disabled by LivewireContourTool\r\n    return true;\r\n  }\r\n}\r\n\r\nLivewireContourSegmentationTool.toolName = 'LivewireContourSegmentationTool';\r\nexport default LivewireContourSegmentationTool;\r\n","import { vec3 } from 'gl-matrix';\r\nimport {\r\n  getEnabledElement,\r\n  utilities as csUtils,\r\n  VolumeViewport,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { removeAnnotation } from '../../stateManagement/annotation/annotationState';\r\nimport { drawHandles as drawHandlesSvg } from '../../drawingSvg';\r\nimport { state } from '../../store';\r\nimport { Events, KeyboardBindings, ChangeTypes } from '../../enums';\r\nimport { resetElementCursor } from '../../cursors/elementCursor';\r\nimport type {\r\n  EventTypes,\r\n  ToolHandle,\r\n  PublicToolProps,\r\n  ToolProps,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\nimport getMouseModifierKey from '../../eventDispatchers/shared/getMouseModifier';\r\nimport { math, triggerAnnotationRenderForViewportIds } from '../../utilities';\r\nimport findHandlePolylineIndex from '../../utilities/contours/findHandlePolylineIndex';\r\nimport { LivewireContourAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\r\nimport {\r\n  triggerAnnotationModified,\r\n  triggerContourAnnotationCompleted,\r\n} from '../../stateManagement/annotation/helpers/state';\r\n\r\nimport { LivewireScissors } from '../../utilities/livewire/LivewireScissors';\r\nimport { LivewirePath } from '../../utilities/livewire/LiveWirePath';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\r\n\r\nconst CLICK_CLOSE_CURVE_SQR_DIST = 10 ** 2; // px\r\n\r\nclass LivewireContourTool extends ContourSegmentationBaseTool {\r\n  public static toolName: string;\r\n  protected scissors: LivewireScissors;\r\n  /** The scissors from the next handle, used for editing */\r\n  protected scissorsNext: LivewireScissors;\r\n\r\n  touchDragCallback: any;\r\n  mouseDragCallback: any;\r\n  editData: {\r\n    annotation: LivewireContourAnnotation;\r\n    viewportIdsToRender: Array<string>;\r\n    handleIndex?: number;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n    lastCanvasPoint?: Types.Point2;\r\n    confirmedPath?: LivewirePath;\r\n    currentPath?: LivewirePath;\r\n    /** The next path segment, on the other side of the handle */\r\n    confirmedPathNext?: LivewirePath;\r\n    closed?: boolean;\r\n    worldToSlice?: (point: Types.Point3) => Types.Point2;\r\n    sliceToWorld?: (point: Types.Point2) => Types.Point3;\r\n    originalPath?: Types.Point3[];\r\n    contourHoleProcessingEnabled?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage = false;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        preventHandleOutsideImage: false,\r\n        /**\r\n         * Specify which modifier key is used to add a hole to a contour. The\r\n         * modifier must be pressed when the first point of a new contour is added.\r\n         */\r\n        contourHoleAdditionModifierKey: KeyboardBindings.Shift,\r\n\r\n        /**\r\n         * Configuring this to a value larger than 0 will snap handles to nearby\r\n         * livewire points, within the given rectangle surrounding the clicked point.\r\n         * If set to 0, then the exact clicked point will be used instead, which may\r\n         * not be an edge and can result in jagged outlines.\r\n         * The unit is image pixels (index).\r\n         */\r\n        snapHandleNearby: 2,\r\n\r\n        /**\r\n         * Interpolation is only available for segmentation versions of these\r\n         * tools.  To use it on the segmentation tools, set enabled to true,\r\n         * and create two livewire contours in the same segment index, separated\r\n         * by at least one slice.\r\n         */\r\n        interpolation: {\r\n          enabled: false,\r\n\r\n          /**\r\n           * Set the nearestEdge to snap interpolated handles to an edge within\r\n           * the given number of pixels.  Setting to 0 disables snap to pixel\r\n           * for interpolation and the interpolated point will be used directly.\r\n           * Setting to too large a value may result in many points outside the contour\r\n           * being chosen.\r\n           */\r\n          nearestEdge: 2,\r\n          /**\r\n           * Set to true to show the interpolated polyline, which can be useful\r\n           * when understanding the nearest edge and\r\n           */\r\n          showInterpolationPolyline: false,\r\n        },\r\n\r\n        /**\r\n         * The polyline may get processed in order to reduce the number of points\r\n         * for better performance and storage.\r\n         */\r\n        decimate: {\r\n          enabled: false,\r\n          /** A maximum given distance 'epsilon' to decide if a point should or\r\n           * shouldn't be added the resulting polyline which will have a lower\r\n           * number of points for higher `epsilon` values.\r\n           */\r\n          epsilon: 0.1,\r\n        },\r\n\r\n        actions: {\r\n          undo: {\r\n            method: 'undo',\r\n            bindings: [\r\n              {\r\n                key: 'Escape',\r\n              },\r\n            ],\r\n          },\r\n        },\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  protected setupBaseEditData(\r\n    worldPos,\r\n    element,\r\n    annotation,\r\n    nextPos?,\r\n    contourHoleProcessingEnabled?\r\n  ) {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    this.isDrawing = true;\r\n\r\n    const viewportImageData = viewport.getImageData();\r\n    const { imageData: vtkImageData } = viewportImageData;\r\n    let worldToSlice: (point: Types.Point3) => Types.Point2;\r\n    let sliceToWorld: (point: Types.Point2) => Types.Point3;\r\n    let { scalarData } = viewportImageData;\r\n    let width;\r\n    let height;\r\n\r\n    if (!(viewport instanceof VolumeViewport) && scalarData) {\r\n      width = viewportImageData.dimensions[0];\r\n      height = viewportImageData.dimensions[1];\r\n\r\n      // Method only to simplify the code making stack and volume viewports code\r\n      // similar and avoiding `if(stack)/else` whenever a coordinate needs to be\r\n      // transformed because `worldToSlice` in this case returns the same IJK\r\n      // coordinate from index space.\r\n      worldToSlice = (point: Types.Point3) => {\r\n        const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);\r\n        return [ijkPoint[0], ijkPoint[1]];\r\n      };\r\n\r\n      // Method only to simplify the code making stack and volume viewports code\r\n      // similar and avoiding `if(stack)/else` whenever a coordinate needs to be\r\n      // transformed because `sliceToWorld` in this case receives the same IJK\r\n      // coordinate from index space.\r\n      sliceToWorld = (point: Types.Point2) =>\r\n        csUtils.transformIndexToWorld(vtkImageData, [point[0], point[1], 0]);\r\n    } else if (viewport instanceof VolumeViewport) {\r\n      const sliceImageData = csUtils.getCurrentVolumeViewportSlice(viewport);\r\n      const { sliceToIndexMatrix, indexToSliceMatrix } = sliceImageData;\r\n\r\n      worldToSlice = (point: Types.Point3) => {\r\n        const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);\r\n        const slicePoint = vec3.transformMat4(\r\n          [0, 0, 0],\r\n          ijkPoint,\r\n          indexToSliceMatrix\r\n        );\r\n\r\n        return [slicePoint[0], slicePoint[1]];\r\n      };\r\n\r\n      sliceToWorld = (point: Types.Point2) => {\r\n        const ijkPoint = vec3.transformMat4(\r\n          [0, 0, 0],\r\n          [point[0], point[1], 0],\r\n          sliceToIndexMatrix\r\n        ) as Types.Point3;\r\n\r\n        return csUtils.transformIndexToWorld(vtkImageData, ijkPoint);\r\n      };\r\n\r\n      scalarData = sliceImageData.scalarData;\r\n      width = sliceImageData.width;\r\n      height = sliceImageData.height;\r\n    } else {\r\n      throw new Error('Viewport not supported');\r\n    }\r\n    scalarData = csUtils.convertToGrayscale(scalarData, width, height);\r\n    const { voiRange } = viewport.getProperties();\r\n    const startPos = worldToSlice(worldPos);\r\n\r\n    this.scissors = LivewireScissors.createInstanceFromRawPixelData(\r\n      scalarData as Float32Array,\r\n      width,\r\n      height,\r\n      voiRange\r\n    );\r\n    if (nextPos) {\r\n      this.scissorsNext = LivewireScissors.createInstanceFromRawPixelData(\r\n        scalarData as Float32Array,\r\n        width,\r\n        height,\r\n        voiRange\r\n      );\r\n      this.scissorsNext.startSearch(worldToSlice(nextPos));\r\n    }\r\n\r\n    // Scissors always start at the startPos for both editing handles and\r\n    // for initial rendering\r\n    this.scissors.startSearch(startPos);\r\n\r\n    const newAnnotation = !nextPos;\r\n\r\n    const confirmedPath = new LivewirePath();\r\n    const currentPath = new LivewirePath();\r\n    const currentPathNext = newAnnotation ? undefined : new LivewirePath();\r\n\r\n    confirmedPath.addPoint(startPos);\r\n    confirmedPath.addControlPoint(startPos);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    const lastCanvasPoint = viewport.worldToCanvas(worldPos);\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      newAnnotation,\r\n      hasMoved: false,\r\n      lastCanvasPoint,\r\n      confirmedPath,\r\n      currentPath,\r\n      confirmedPathNext: currentPathNext,\r\n      closed: false,\r\n      handleIndex:\r\n        this.editData?.handleIndex ?? annotation.handles?.activeHandleIndex,\r\n      worldToSlice,\r\n      sliceToWorld,\r\n      contourHoleProcessingEnabled,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the current imageId to create\r\n   * a CircleROI Annotation and stores it in the annotationManager\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation(\r\n    evt: EventTypes.InteractionEventType\r\n  ): LivewireContourAnnotation {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const { world: worldPos } = currentPoints;\r\n    const { renderingEngine } = getEnabledElement(element);\r\n    const annotation = this.createAnnotation(evt);\r\n    const contourHoleProcessingEnabled =\r\n      getMouseModifierKey(evt.detail.event) ===\r\n      this.configuration.contourHoleAdditionModifierKey;\r\n\r\n    this.setupBaseEditData(\r\n      worldPos,\r\n      element,\r\n      annotation,\r\n      undefined,\r\n      contourHoleProcessingEnabled\r\n    );\r\n    this.addAnnotation(annotation, element);\r\n\r\n    this._activateDraw(element);\r\n    evt.preventDefault();\r\n    triggerAnnotationRenderForViewportIds(\r\n      renderingEngine,\r\n      this.editData.viewportIdsToRender\r\n    );\r\n\r\n    return annotation;\r\n  }\r\n\r\n  /**\r\n   * It returns if the canvas point is near the provided annotation in the provided\r\n   * element or not. A proximity is passed to the function to determine the\r\n   * proximity of the point to the annotation in number of pixels.\r\n   *\r\n   * @param element - HTML Element\r\n   * @param annotation - Annotation\r\n   * @param canvasCoords - Canvas coordinates\r\n   * @param proximity - Proximity to tool to consider\r\n   * @returns Boolean, whether the canvas point is near tool\r\n   */\r\n  isPointNearTool = (\r\n    element: HTMLDivElement,\r\n    annotation: LivewireContourAnnotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): boolean => {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const proximitySquared = proximity * proximity;\r\n    const canvasPoints = annotation.data.contour.polyline.map((p) =>\r\n      viewport.worldToCanvas(p)\r\n    );\r\n\r\n    let startPoint = canvasPoints[canvasPoints.length - 1];\r\n\r\n    for (let i = 0; i < canvasPoints.length; i++) {\r\n      const endPoint = canvasPoints[i];\r\n      const distanceToPointSquared = math.lineSegment.distanceToPointSquared(\r\n        startPoint,\r\n        endPoint,\r\n        canvasCoords\r\n      );\r\n\r\n      if (distanceToPointSquared <= proximitySquared) {\r\n        return true;\r\n      }\r\n\r\n      startPoint = endPoint;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  toolSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: LivewireContourAnnotation\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n    };\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    this._activateModify(element);\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n    evt.preventDefault();\r\n  };\r\n\r\n  handleSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: LivewireContourAnnotation,\r\n    handle: ToolHandle\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const { data } = annotation;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    const { points } = data.handles;\r\n    const handleIndex = points.findIndex((p) => p === handle);\r\n\r\n    // Find viewports to render on drag.\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex,\r\n    };\r\n    this._activateModify(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  _endCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    clearAnnotation = false\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      newAnnotation,\r\n      contourHoleProcessingEnabled,\r\n    } = this.editData;\r\n    const { data } = annotation;\r\n\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateModify(element);\r\n    this._deactivateDraw(element);\r\n\r\n    resetElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    if (\r\n      (this.isHandleOutsideImage &&\r\n        this.configuration.preventHandleOutsideImage) ||\r\n      clearAnnotation\r\n    ) {\r\n      removeAnnotation(annotation.annotationUID);\r\n      this.clearEditData();\r\n      triggerAnnotationRenderForViewportIds(\r\n        renderingEngine,\r\n        viewportIdsToRender\r\n      );\r\n      return;\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    const changeType = newAnnotation\r\n      ? ChangeTypes.Completed\r\n      : ChangeTypes.HandlesUpdated;\r\n\r\n    this.triggerChangeEvent(\r\n      annotation,\r\n      enabledElement,\r\n      changeType,\r\n      contourHoleProcessingEnabled\r\n    );\r\n    this.clearEditData();\r\n  };\r\n\r\n  protected clearEditData() {\r\n    this.editData = null;\r\n    this.scissors = null;\r\n    this.scissorsNext = null;\r\n    this.isDrawing = false;\r\n  }\r\n\r\n  /**\r\n   * Triggers an annotation complete or modified event based on changeType.\r\n   */\r\n  triggerChangeEvent = (\r\n    annotation: LivewireContourAnnotation,\r\n    enabledElement: Types.IEnabledElement,\r\n    changeType = ChangeTypes.StatsUpdated,\r\n    contourHoleProcessingEnabled = false\r\n  ): void => {\r\n    if (changeType === ChangeTypes.Completed) {\r\n      triggerContourAnnotationCompleted(\r\n        annotation,\r\n        contourHoleProcessingEnabled\r\n      );\r\n    } else {\r\n      triggerAnnotationModified(\r\n        annotation,\r\n        enabledElement.viewport.element,\r\n        changeType\r\n      );\r\n    }\r\n  };\r\n\r\n  private _mouseDownCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\r\n    const { annotation, viewportIdsToRender, worldToSlice, sliceToWorld } =\r\n      this.editData;\r\n\r\n    if (this.editData.closed) {\r\n      return;\r\n    }\r\n\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const { currentPoints } = eventDetail;\r\n    const { canvas: canvasPos, world: worldPosOriginal } = currentPoints;\r\n    let worldPos = worldPosOriginal;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n    const controlPoints = this.editData.currentPath.getControlPoints();\r\n    let closePath = controlPoints.length >= 2 && doubleClick;\r\n\r\n    // Check if user clicked on the first point to close the curve\r\n    if (controlPoints.length >= 2) {\r\n      const closestHandlePoint = {\r\n        index: -1,\r\n        distSquared: Infinity,\r\n      };\r\n\r\n      // Check if there is a control point close to the cursor\r\n      for (let i = 0, len = controlPoints.length; i < len; i++) {\r\n        const controlPoint = controlPoints[i];\r\n        const worldControlPoint = sliceToWorld(controlPoint);\r\n        const canvasControlPoint = viewport.worldToCanvas(worldControlPoint);\r\n\r\n        const distSquared = math.point.distanceToPointSquared(\r\n          canvasPos,\r\n          canvasControlPoint\r\n        );\r\n\r\n        if (\r\n          distSquared <= CLICK_CLOSE_CURVE_SQR_DIST &&\r\n          distSquared < closestHandlePoint.distSquared\r\n        ) {\r\n          closestHandlePoint.distSquared = distSquared;\r\n          closestHandlePoint.index = i;\r\n        }\r\n      }\r\n\r\n      if (closestHandlePoint.index === 0) {\r\n        closePath = true;\r\n      }\r\n    }\r\n\r\n    const { snapHandleNearby } = this.configuration;\r\n    // Snap the handles as they get created, but not during edit\r\n    if (snapHandleNearby && !this.editData.closed) {\r\n      const currentPath = new LivewirePath();\r\n      const snapPoint = this.scissors.findMinNearby(\r\n        worldToSlice(worldPosOriginal),\r\n        1\r\n      );\r\n      const pathPoints = this.scissors.findPathToPoint(snapPoint);\r\n      currentPath.addPoints(pathPoints);\r\n      currentPath.prependPath(this.editData.confirmedPath);\r\n      worldPos = sliceToWorld(snapPoint);\r\n      this.editData.currentPath = currentPath;\r\n    }\r\n\r\n    this.editData.closed = this.editData.closed || closePath;\r\n    this.editData.confirmedPath = this.editData.currentPath;\r\n\r\n    // Add the current cursor position as a new control point after clicking\r\n    const lastPoint = this.editData.currentPath.getLastPoint();\r\n\r\n    this.editData.confirmedPath.addControlPoint(lastPoint);\r\n    annotation.data.handles.points.push(sliceToWorld(lastPoint));\r\n\r\n    // Start a new search starting at the last control point\r\n    this.scissors.startSearch(worldToSlice(worldPos));\r\n\r\n    annotation.invalidated = true;\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    if (this.editData.closed) {\r\n      // Update the annotation because `editData` will be set to null\r\n      this.updateAnnotation(this.editData.confirmedPath);\r\n      this._endCallback(evt);\r\n    }\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  private _mouseMoveCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const { element, currentPoints } = evt.detail;\r\n    const { world: worldPos, canvas: canvasPos } = currentPoints;\r\n    const { renderingEngine } = getEnabledElement(element);\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData.lastCanvasPoint = canvasPos;\r\n\r\n    const { width: imgWidth, height: imgHeight } = this.scissors;\r\n    const { worldToSlice } = this.editData;\r\n    const slicePoint: Types.Point2 = worldToSlice(worldPos);\r\n\r\n    // Check if the point is inside the bounding box\r\n    if (\r\n      slicePoint[0] < 0 ||\r\n      slicePoint[1] < 0 ||\r\n      slicePoint[0] >= imgWidth ||\r\n      slicePoint[1] >= imgHeight\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    const pathPoints = this.scissors.findPathToPoint(slicePoint);\r\n    const currentPath = new LivewirePath();\r\n    currentPath.addPoints(pathPoints);\r\n\r\n    // Merge the \"confirmed\" path that goes from the first control point to the\r\n    // last one with the current path that goes from the last control point to\r\n    // the cursor point\r\n    currentPath.prependPath(this.editData.confirmedPath);\r\n\r\n    // Store the new path\r\n    this.editData.currentPath = currentPath;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n    evt.preventDefault();\r\n  };\r\n\r\n  public editHandle(\r\n    worldPos: Types.Point3,\r\n    element,\r\n    annotation: LivewireContourAnnotation,\r\n    handleIndex: number\r\n  ) {\r\n    const { data } = annotation;\r\n    const { points: handlePoints } = data.handles;\r\n    const { length: numHandles } = handlePoints;\r\n    const previousHandle =\r\n      handlePoints[(handleIndex - 1 + numHandles) % numHandles];\r\n    const nextHandle = handlePoints[(handleIndex + 1) % numHandles];\r\n\r\n    if (!this.editData?.confirmedPathNext) {\r\n      this.setupBaseEditData(previousHandle, element, annotation, nextHandle);\r\n      const { polyline } = data.contour;\r\n      const confirmedPath = new LivewirePath();\r\n      const confirmedPathNext = new LivewirePath();\r\n      const { worldToSlice } = this.editData;\r\n      const previousIndex = findHandlePolylineIndex(\r\n        annotation,\r\n        handleIndex - 1\r\n      );\r\n      const nextIndex = findHandlePolylineIndex(annotation, handleIndex + 1);\r\n      if (nextIndex === -1 || previousIndex === -1) {\r\n        throw new Error(\r\n          `Can't find handle index ${nextIndex === -1 && nextHandle} ${\r\n            previousIndex === -1 && previousHandle\r\n          }`\r\n        );\r\n      }\r\n      if (handleIndex === 0) {\r\n        // For this case, the next/previous indices are swapped, and the\r\n        // path data gets inserted in between the newly generated data, so\r\n        // handle this case specially\r\n        confirmedPathNext.addPoints(\r\n          polyline.slice(nextIndex + 1, previousIndex).map(worldToSlice)\r\n        );\r\n      } else {\r\n        confirmedPath.addPoints(\r\n          polyline.slice(0, previousIndex + 1).map(worldToSlice)\r\n        );\r\n        confirmedPathNext.addPoints(\r\n          polyline.slice(nextIndex, polyline.length).map(worldToSlice)\r\n        );\r\n      }\r\n      this.editData.confirmedPath = confirmedPath;\r\n      this.editData.confirmedPathNext = confirmedPathNext;\r\n    }\r\n    const { editData, scissors } = this;\r\n    const { worldToSlice, sliceToWorld } = editData;\r\n\r\n    const { activeHandleIndex } = data.handles;\r\n    if (activeHandleIndex === null || activeHandleIndex === undefined) {\r\n      data.handles.activeHandleIndex = handleIndex;\r\n    } else if (activeHandleIndex !== handleIndex) {\r\n      throw new Error(\r\n        `Trying to edit a different handle than the one currently being edited ${handleIndex}!==${data.handles.activeHandleIndex}`\r\n      );\r\n    }\r\n    const slicePos = worldToSlice(worldPos);\r\n    if (\r\n      slicePos[0] < 0 ||\r\n      slicePos[0] >= scissors.width ||\r\n      slicePos[1] < 0 ||\r\n      slicePos[1] >= scissors.height\r\n    ) {\r\n      // Find path to point hangs if the position is outside the image data\r\n      return;\r\n    }\r\n    handlePoints[handleIndex] = sliceToWorld(slicePos);\r\n\r\n    const pathPointsLeft = scissors.findPathToPoint(slicePos);\r\n    const pathPointsRight = this.scissorsNext.findPathToPoint(slicePos);\r\n    const currentPath = new LivewirePath();\r\n\r\n    // Merge the \"confirmed\" path that goes from the first control point to the\r\n    // last one with the current path that goes from the last control point to\r\n    // the cursor point\r\n    currentPath.prependPath(editData.confirmedPath);\r\n    if (handleIndex !== 0) {\r\n      currentPath.addPoints(pathPointsLeft);\r\n    }\r\n    currentPath.addPoints(pathPointsRight.reverse());\r\n    currentPath.appendPath(editData.confirmedPathNext);\r\n    if (handleIndex === 0) {\r\n      currentPath.addPoints(pathPointsLeft);\r\n    }\r\n\r\n    // Store the new path\r\n    editData.currentPath = currentPath;\r\n\r\n    annotation.invalidated = true;\r\n    editData.hasMoved = true;\r\n  }\r\n\r\n  private _dragCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    this.isDrawing = true;\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\r\n    if (handleIndex === undefined) {\r\n      // Drag mode - moving object\r\n      console.warn('No drag implemented for livewire');\r\n    } else {\r\n      // Move mode - after double click, and mouse move to draw\r\n      const { currentPoints } = eventDetail;\r\n      const worldPos = currentPoints.world;\r\n      this.editHandle(worldPos, element, annotation, handleIndex);\r\n    }\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  cancel = (element: HTMLDivElement) => {\r\n    // If it is not in mid-draw or mid-modify\r\n    if (!this.isDrawing) {\r\n      return;\r\n    }\r\n\r\n    this.isDrawing = false;\r\n    this._deactivateDraw(element);\r\n    this._deactivateModify(element);\r\n    resetElementCursor(element);\r\n\r\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\r\n\r\n    if (newAnnotation) {\r\n      removeAnnotation(annotation.annotationUID);\r\n    }\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    this.editData = null;\r\n    this.scissors = null;\r\n    return annotation.annotationUID;\r\n  };\r\n\r\n  private _activateModify = (element) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\r\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  private _deactivateModify = (element) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\r\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  private _activateDraw = (element) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\r\n    element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\r\n    element.addEventListener(\r\n      Events.MOUSE_DOUBLE_CLICK,\r\n      this._mouseDownCallback\r\n    );\r\n\r\n    element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\r\n  };\r\n\r\n  private _deactivateDraw = (element) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\r\n    element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\r\n    element.removeEventListener(\r\n      Events.MOUSE_DOUBLE_CLICK,\r\n      this._mouseDownCallback\r\n    );\r\n\r\n    element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\r\n  };\r\n\r\n  public renderAnnotation(\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean {\r\n    // Update the annotation that is in editData (being edited)\r\n    this.updateAnnotation(this.editData?.currentPath);\r\n\r\n    return super.renderAnnotation(enabledElement, svgDrawingHelper);\r\n  }\r\n\r\n  protected isContourSegmentationTool(): boolean {\r\n    // Disable contour segmentation behavior because it shall be activated only\r\n    // for LivewireContourSegmentationTool\r\n    return false;\r\n  }\r\n\r\n  protected createAnnotation(evt: EventTypes.InteractionEventType) {\r\n    const contourSegmentationAnnotation = super.createAnnotation(evt);\r\n    const { world: worldPos } = evt.detail.currentPoints;\r\n\r\n    const annotation = <LivewireContourAnnotation>csUtils.deepMerge(\r\n      contourSegmentationAnnotation,\r\n      {\r\n        data: {\r\n          handles: {\r\n            points: [[...worldPos]],\r\n          },\r\n        },\r\n      }\r\n    );\r\n    return annotation;\r\n  }\r\n\r\n  /**\r\n   * Clears any in progress edits, mostly used to get rid of accidentally started\r\n   * contours that happen on clicking not quite the right handle point.\r\n   * Eventually this is to be replaced with a proper undo, once that framework\r\n   * is available.\r\n   */\r\n  public undo(element, config, evt) {\r\n    if (!this.editData) {\r\n      // TODO - proper undo\r\n      return;\r\n    }\r\n    this._endCallback(evt, true);\r\n  }\r\n\r\n  /**\r\n   * Render an annotation instance\r\n   * @param renderContext - Render context that contains the annotation, enabledElement, etc.\r\n   * @returns True if the annotation is rendered or false otherwise\r\n   */\r\n  protected renderAnnotationInstance(renderContext: {\r\n    enabledElement: Types.IEnabledElement;\r\n    targetId: string;\r\n    annotation: LivewireContourAnnotation;\r\n    annotationStyle: Record<string, any>;\r\n    svgDrawingHelper: SVGDrawingHelper;\r\n  }): boolean {\r\n    const { annotation, enabledElement, svgDrawingHelper, annotationStyle } =\r\n      renderContext;\r\n\r\n    const { viewport } = enabledElement;\r\n    const { worldToCanvas } = viewport;\r\n    const { annotationUID, data, highlighted } = annotation;\r\n    const { handles } = data;\r\n    const newAnnotation = this.editData?.newAnnotation;\r\n    const { lineWidth, lineDash, color } = annotationStyle;\r\n\r\n    // Render the first control point only when the annotation is drawn for the\r\n    // first time to make it easier to know where the user needs to click to\r\n    // to close the ROI.\r\n    if (\r\n      highlighted ||\r\n      (newAnnotation &&\r\n        annotation.annotationUID === this.editData?.annotation?.annotationUID)\r\n    ) {\r\n      const handleGroupUID = '0';\r\n      const canvasHandles = handles.points.map(worldToCanvas);\r\n\r\n      drawHandlesSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        handleGroupUID,\r\n        canvasHandles,\r\n        {\r\n          color,\r\n          lineDash,\r\n          lineWidth,\r\n        }\r\n      );\r\n    }\r\n\r\n    // Let the base class render the contour\r\n    super.renderAnnotationInstance(renderContext);\r\n\r\n    return true;\r\n  }\r\n\r\n  protected updateAnnotation(livewirePath: LivewirePath) {\r\n    if (!this.editData || !livewirePath) {\r\n      return;\r\n    }\r\n\r\n    const { annotation, sliceToWorld, worldToSlice, closed, newAnnotation } =\r\n      this.editData;\r\n    let { pointArray: imagePoints } = livewirePath;\r\n\r\n    if (imagePoints.length > 1) {\r\n      imagePoints = [...imagePoints, imagePoints[0]];\r\n    }\r\n\r\n    // Save the annotation in clockwise winding direction only after closing it\r\n    // because reversing the handle points may cause some weird issues\r\n    const targetWindingDirection =\r\n      newAnnotation && closed ? ContourWindingDirection.Clockwise : undefined;\r\n\r\n    this.updateContourPolyline(\r\n      annotation,\r\n      {\r\n        points: imagePoints,\r\n        closed,\r\n        targetWindingDirection,\r\n      },\r\n      {\r\n        canvasToWorld: sliceToWorld,\r\n        worldToCanvas: worldToSlice,\r\n      }\r\n    );\r\n  }\r\n}\r\n\r\nLivewireContourTool.toolName = 'LivewireContour';\r\nexport default LivewireContourTool;\r\n","import { utilities } from '@cornerstonejs/core';\r\nimport type { PublicToolProps } from '../../types';\r\nimport type { AnnotationRenderContext } from '../../types';\r\nimport { PlanarFreehandContourSegmentationAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\r\nimport PlanarFreehandROITool from './PlanarFreehandROITool';\r\n\r\nclass PlanarFreehandContourSegmentationTool extends PlanarFreehandROITool {\r\n  static toolName;\r\n\r\n  constructor(toolProps: PublicToolProps) {\r\n    const initialProps = utilities.deepMerge(\r\n      {\r\n        configuration: {\r\n          calculateStats: false,\r\n          /**\r\n           * Allow open contours false means to not allow a final/complete\r\n           * annotation to be done as an open contour.  This does not mean\r\n           * that the contour won't be open during creation.\r\n           */\r\n          allowOpenContours: false,\r\n        },\r\n      },\r\n      toolProps\r\n    );\r\n\r\n    super(initialProps);\r\n  }\r\n\r\n  protected isContourSegmentationTool(): boolean {\r\n    // Re-enable contour segmentation behavior disabled by PlanarFreehandROITool\r\n    return true;\r\n  }\r\n\r\n  protected renderAnnotationInstance(\r\n    renderContext: AnnotationRenderContext\r\n  ): boolean {\r\n    const annotation =\r\n      renderContext.annotation as PlanarFreehandContourSegmentationAnnotation;\r\n    const { invalidated } = annotation;\r\n\r\n    // Render the annotation before triggering events\r\n    const renderResult = super.renderAnnotationInstance(renderContext);\r\n\r\n    if (invalidated) {\r\n      const { segmentationId } = annotation.data.segmentation;\r\n\r\n      // This event is trigged by ContourSegmentationBaseTool but PlanarFreehandROITool\r\n      // is the only contour class that does not call `renderAnnotationInstace` from\r\n      // its base class.\r\n      triggerSegmentationDataModified(segmentationId);\r\n    }\r\n\r\n    return renderResult;\r\n  }\r\n}\r\n\r\nPlanarFreehandContourSegmentationTool.toolName =\r\n  'PlanarFreehandContourSegmentationTool';\r\n\r\nexport default PlanarFreehandContourSegmentationTool;\r\n","/* eslint-disable @typescript-eslint/no-empty-function */\r\nimport { vec2 } from 'gl-matrix';\r\n\r\nimport {\r\n  getEnabledElement,\r\n  VolumeViewport,\r\n  utilities as csUtils,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { AnnotationTool } from '../base';\r\nimport {\r\n  addAnnotation,\r\n  getAnnotations,\r\n  removeAnnotation,\r\n} from '../../stateManagement/annotation/annotationState';\r\nimport {\r\n  triggerAnnotationCompleted,\r\n  triggerAnnotationModified,\r\n} from '../../stateManagement/annotation/helpers/state';\r\nimport { getCalibratedProbeUnitsAndValue } from '../../utilities/getCalibratedUnits';\r\nimport {\r\n  drawHandles as drawHandlesSvg,\r\n  drawTextBox as drawTextBoxSvg,\r\n} from '../../drawingSvg';\r\nimport { state } from '../../store';\r\nimport { Events } from '../../enums';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport { roundNumber } from '../../utilities';\r\nimport {\r\n  resetElementCursor,\r\n  hideElementCursor,\r\n} from '../../cursors/elementCursor';\r\n\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\n\r\nimport {\r\n  EventTypes,\r\n  ToolHandle,\r\n  PublicToolProps,\r\n  ToolProps,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\nimport { ProbeAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\nimport {\r\n  ModalityUnitOptions,\r\n  getModalityUnit,\r\n} from '../../utilities/getModalityUnit';\r\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\r\n\r\nconst { transformWorldToIndex } = csUtils;\r\n\r\n/**\r\n * ProbeTool let you get the underlying voxel value by putting a probe in that\r\n * location. It will give index of the location and value of the voxel.\r\n * You can use ProbeTool in all perpendicular views (axial, sagittal, coronal).\r\n * Note: annotation tools in cornerstone3DTools exists in the exact location\r\n * in the physical 3d space, as a result, by default, all annotations that are\r\n * drawing in the same frameOfReference will get shared between viewports that\r\n * are in the same frameOfReference. Probe tool's text box are dynamically\r\n * generated based on the viewport's underlying Modality. For instance, if\r\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\r\n * and if the viewport is displaying PET, the text box will show the statistics in\r\n * SUV units.\r\n *\r\n * The resulting annotation's data (statistics) and metadata (the\r\n * state of the viewport while drawing was happening) will get added to the\r\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\r\n * or similar methods.\r\n *\r\n * To use the ProbeTool, you first need to add it to cornerstoneTools, then create\r\n * a toolGroup and add the ProbeTool to it. Finally, setToolActive on the toolGroup\r\n *\r\n * ```js\r\n * cornerstoneTools.addTool(ProbeTool)\r\n *\r\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\r\n *\r\n * toolGroup.addTool(ProbeTool.toolName)\r\n *\r\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\r\n *\r\n * toolGroup.setToolActive(ProbeTool.toolName, {\r\n *   bindings: [\r\n *    {\r\n *       mouseButton: MouseBindings.Primary, // Left Click\r\n *     },\r\n *   ],\r\n * })\r\n * ```\r\n *\r\n * Read more in the Docs section of the website.\r\n *\r\n */\r\n\r\nclass ProbeTool extends AnnotationTool {\r\n  static toolName;\r\n\r\n  touchDragCallback: any;\r\n  mouseDragCallback: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: string[];\r\n    newAnnotation?: boolean;\r\n  } | null;\r\n  eventDispatchDetail: {\r\n    viewportId: string;\r\n    renderingEngineId: string;\r\n  };\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        shadow: true,\r\n        preventHandleOutsideImage: false,\r\n        getTextLines: defaultGetTextLines,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  // Not necessary for this tool but needs to be defined since it's an abstract\r\n  // method from the parent class.\r\n  isPointNearTool(): boolean {\r\n    return false;\r\n  }\r\n\r\n  toolSelectedCallback() {}\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the current imageId to create\r\n   * a Probe Annotation and stores it in the annotationManager\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation = (\r\n    evt: EventTypes.InteractionEventType\r\n  ): ProbeAnnotation => {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    this.isDrawing = true;\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    const referencedImageId = this.getReferencedImageId(\r\n      viewport,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      viewUp\r\n    );\r\n\r\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n\r\n    const annotation = {\r\n      invalidated: true,\r\n      highlighted: true,\r\n      metadata: {\r\n        toolName: this.getToolName(),\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID,\r\n        referencedImageId,\r\n      },\r\n      data: {\r\n        label: '',\r\n        handles: { points: [<Types.Point3>[...worldPos]] },\r\n        cachedStats: {},\r\n      },\r\n    };\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      newAnnotation: true,\r\n      viewportIdsToRender,\r\n    };\r\n    this._activateModify(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  };\r\n\r\n  /**\r\n   * It checks if the mouse click is near ProveTool, it overwrites the baseAnnotationTool\r\n   * getHandleNearImagePoint method.\r\n   *\r\n   * @param element - The element that the tool is attached to.\r\n   * @param annotation - The annotation object associated with the annotation\r\n   * @param canvasCoords - The coordinates of the mouse click on canvas\r\n   * @param proximity - The distance from the mouse cursor to the point\r\n   * that is considered \"near\".\r\n   * @returns The handle that is closest to the cursor, or null if the cursor\r\n   * is not near any of the handles.\r\n   */\r\n  getHandleNearImagePoint(\r\n    element: HTMLDivElement,\r\n    annotation: ProbeAnnotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): ToolHandle | undefined {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    const { data } = annotation;\r\n    const point = data.handles.points[0];\r\n    const annotationCanvasCoordinate = viewport.worldToCanvas(point);\r\n\r\n    const near =\r\n      vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\r\n\r\n    if (near === true) {\r\n      return point;\r\n    }\r\n  }\r\n\r\n  handleSelectedCallback(\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: ProbeAnnotation\r\n  ): void {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    // Find viewports to render on drag.\r\n\r\n    this.editData = {\r\n      //handle, // This would be useful for other tools with more than one handle\r\n      annotation,\r\n      viewportIdsToRender,\r\n    };\r\n    this._activateModify(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  }\r\n\r\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\r\n\r\n    const { viewportId, renderingEngine } = getEnabledElement(element);\r\n    this.eventDispatchDetail = {\r\n      viewportId,\r\n      renderingEngineId: renderingEngine.id,\r\n    };\r\n\r\n    this._deactivateModify(element);\r\n\r\n    resetElementCursor(element);\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n\r\n    if (\r\n      this.isHandleOutsideImage &&\r\n      this.configuration.preventHandleOutsideImage\r\n    ) {\r\n      removeAnnotation(annotation.annotationUID);\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    if (newAnnotation) {\r\n      triggerAnnotationCompleted(annotation);\r\n    }\r\n  };\r\n\r\n  _dragCallback = (evt) => {\r\n    this.isDrawing = true;\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n\r\n    const { annotation, viewportIdsToRender } = this.editData;\r\n    const { data } = annotation;\r\n\r\n    data.handles.points[0] = [...worldPos];\r\n    annotation.invalidated = true;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  cancel = (element: HTMLDivElement) => {\r\n    // If it is mid-draw or mid-modify\r\n    if (this.isDrawing) {\r\n      this.isDrawing = false;\r\n      this._deactivateModify(element);\r\n      resetElementCursor(element);\r\n\r\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\r\n      const { data } = annotation;\r\n\r\n      annotation.highlighted = false;\r\n      data.handles.activeHandleIndex = null;\r\n\r\n      const { renderingEngine } = getEnabledElement(element);\r\n\r\n      triggerAnnotationRenderForViewportIds(\r\n        renderingEngine,\r\n        viewportIdsToRender\r\n      );\r\n\r\n      if (newAnnotation) {\r\n        triggerAnnotationCompleted(annotation);\r\n      }\r\n\r\n      this.editData = null;\r\n      return annotation.annotationUID;\r\n    }\r\n  };\r\n\r\n  _activateModify = (element) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\r\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  _deactivateModify = (element) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\r\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the probe annotation in each\r\n   * request animation frame. It calculates the updated cached statistics if\r\n   * data is invalidated and cache it.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n\r\n    let annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    annotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    );\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const targetId = this.getTargetId(viewport);\r\n    const renderingEngine = viewport.getRenderingEngine();\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[i] as ProbeAnnotation;\r\n      const annotationUID = annotation.annotationUID;\r\n      const data = annotation.data;\r\n      const point = data.handles.points[0];\r\n      const canvasCoordinates = viewport.worldToCanvas(point);\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const { color } = this.getAnnotationStyle({ annotation, styleSpecifier });\r\n\r\n      if (!data.cachedStats) {\r\n        data.cachedStats = {};\r\n      }\r\n\r\n      if (\r\n        !data.cachedStats[targetId] ||\r\n        data.cachedStats[targetId].value == null\r\n      ) {\r\n        data.cachedStats[targetId] = {\r\n          Modality: null,\r\n          index: null,\r\n          value: null,\r\n        };\r\n\r\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\r\n      } else if (annotation.invalidated) {\r\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\r\n\r\n        // If the invalidated data is as a result of volumeViewport manipulation\r\n        // of the tools, we need to invalidate the related stackViewports data if\r\n        // they are not at the referencedImageId, so that\r\n        // when scrolling to the related slice in which the tool were manipulated\r\n        // we re-render the correct tool position. This is due to stackViewport\r\n        // which doesn't have the full volume at each time, and we are only working\r\n        // on one slice at a time.\r\n        if (viewport instanceof VolumeViewport) {\r\n          const { referencedImageId } = annotation.metadata;\r\n\r\n          // invalidate all the relevant stackViewports if they are not\r\n          // at the referencedImageId\r\n          for (const targetId in data.cachedStats) {\r\n            if (targetId.startsWith('imageId')) {\r\n              const viewports = renderingEngine.getStackViewports();\r\n\r\n              const invalidatedStack = viewports.find((vp) => {\r\n                // The stack viewport that contains the imageId but is not\r\n                // showing it currently\r\n                const referencedImageURI =\r\n                  csUtils.imageIdToURI(referencedImageId);\r\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\r\n                const currentImageURI = csUtils.imageIdToURI(\r\n                  vp.getCurrentImageId()\r\n                );\r\n                return hasImageURI && currentImageURI !== referencedImageURI;\r\n              });\r\n\r\n              if (invalidatedStack) {\r\n                delete data.cachedStats[targetId];\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n\r\n      const handleGroupUID = '0';\r\n\r\n      drawHandlesSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        handleGroupUID,\r\n        [canvasCoordinates],\r\n        { color }\r\n      );\r\n\r\n      renderStatus = true;\r\n\r\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\r\n      if (!options.visibility) {\r\n        continue;\r\n      }\r\n\r\n      const textLines = this.configuration.getTextLines(data, targetId);\r\n      if (textLines) {\r\n        const textCanvasCoordinates = [\r\n          canvasCoordinates[0] + 6,\r\n          canvasCoordinates[1] - 6,\r\n        ];\r\n\r\n        const textUID = '0';\r\n        drawTextBoxSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          textUID,\r\n          textLines,\r\n          [textCanvasCoordinates[0], textCanvasCoordinates[1]],\r\n          options\r\n        );\r\n      }\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\r\n    const data = annotation.data;\r\n    const { renderingEngineId, viewport } = enabledElement;\r\n    const { element } = viewport;\r\n\r\n    const worldPos = data.handles.points[0];\r\n    const { cachedStats } = data;\r\n\r\n    const targetIds = Object.keys(cachedStats);\r\n\r\n    for (let i = 0; i < targetIds.length; i++) {\r\n      const targetId = targetIds[i];\r\n\r\n      const modalityUnitOptions = {\r\n        isPreScaled: isViewportPreScaled(viewport, targetId),\r\n        isSuvScaled: this.isSuvScaled(\r\n          viewport,\r\n          targetId,\r\n          annotation.metadata.referencedImageId\r\n        ),\r\n      };\r\n\r\n      const image = this.getTargetIdImage(targetId, renderingEngine);\r\n\r\n      // If image does not exists for the targetId, skip. This can be due\r\n      // to various reasons such as if the target was a volumeViewport, and\r\n      // the volumeViewport has been decached in the meantime.\r\n      if (!image) {\r\n        continue;\r\n      }\r\n\r\n      const { dimensions, imageData, metadata } = image;\r\n      const scalarData =\r\n        'getScalarData' in image ? image.getScalarData() : image.scalarData;\r\n\r\n      const modality = metadata.Modality;\r\n      const index = transformWorldToIndex(imageData, worldPos).map(Math.round);\r\n\r\n      const samplesPerPixel =\r\n        scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];\r\n\r\n      if (csUtils.indexWithinDimensions(index, dimensions)) {\r\n        this.isHandleOutsideImage = false;\r\n        const yMultiple = dimensions[0] * samplesPerPixel;\r\n        const zMultiple = dimensions[0] * dimensions[1] * samplesPerPixel;\r\n\r\n        const baseIndex =\r\n          index[2] * zMultiple +\r\n          index[1] * yMultiple +\r\n          index[0] * samplesPerPixel;\r\n        let value =\r\n          samplesPerPixel > 2\r\n            ? [\r\n                scalarData[baseIndex],\r\n                scalarData[baseIndex + 1],\r\n                scalarData[baseIndex + 2],\r\n              ]\r\n            : scalarData[baseIndex];\r\n\r\n        // Index[2] for stackViewport is always 0, but for visualization\r\n        // we reset it to be imageId index\r\n        if (targetId.startsWith('imageId:')) {\r\n          const imageId = targetId.split('imageId:')[1];\r\n          const imageURI = csUtils.imageIdToURI(imageId);\r\n          const viewports = csUtils.getViewportsWithImageURI(\r\n            imageURI,\r\n            renderingEngineId\r\n          );\r\n\r\n          const viewport = viewports[0];\r\n\r\n          index[2] = viewport.getCurrentImageIdIndex();\r\n        }\r\n\r\n        let modalityUnit;\r\n\r\n        if (modality === 'US') {\r\n          const calibratedResults = getCalibratedProbeUnitsAndValue(image, [\r\n            index,\r\n          ]);\r\n\r\n          const hasEnhancedRegionValues = calibratedResults.values.every(\r\n            (value) => value !== null\r\n          );\r\n\r\n          value = hasEnhancedRegionValues ? calibratedResults.values : value;\r\n          modalityUnit = hasEnhancedRegionValues\r\n            ? calibratedResults.units\r\n            : 'raw';\r\n        } else {\r\n          modalityUnit = getModalityUnit(\r\n            modality,\r\n            annotation.metadata.referencedImageId,\r\n            modalityUnitOptions\r\n          );\r\n        }\r\n\r\n        cachedStats[targetId] = {\r\n          index,\r\n          value,\r\n          Modality: modality,\r\n          modalityUnit,\r\n        };\r\n      } else {\r\n        this.isHandleOutsideImage = true;\r\n        cachedStats[targetId] = {\r\n          index,\r\n          Modality: modality,\r\n        };\r\n      }\r\n\r\n      annotation.invalidated = false;\r\n\r\n      // Dispatching annotation modified\r\n      triggerAnnotationModified(annotation, element);\r\n    }\r\n\r\n    return cachedStats;\r\n  }\r\n}\r\n\r\nfunction defaultGetTextLines(data, targetId): string[] {\r\n  const cachedVolumeStats = data.cachedStats[targetId];\r\n  const { index, value, modalityUnit } = cachedVolumeStats;\r\n\r\n  if (value === undefined) {\r\n    return;\r\n  }\r\n\r\n  const textLines = [];\r\n\r\n  textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\r\n\r\n  if (value instanceof Array && modalityUnit instanceof Array) {\r\n    for (let i = 0; i < value.length; i++) {\r\n      textLines.push(`${roundNumber(value[i])} ${modalityUnit[i]}`);\r\n    }\r\n  } else {\r\n    textLines.push(`${roundNumber(value)} ${modalityUnit}`);\r\n  }\r\n\r\n  return textLines;\r\n}\r\n\r\nProbeTool.toolName = 'Probe';\r\nexport default ProbeTool;\r\n","import { AnnotationTool } from '../base';\r\n\r\nimport {\r\n  getEnabledElement,\r\n  VolumeViewport,\r\n  utilities as csUtils,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\r\nimport { roundNumber } from '../../utilities';\r\nimport throttle from '../../utilities/throttle';\r\nimport {\r\n  addAnnotation,\r\n  getAnnotations,\r\n  removeAnnotation,\r\n} from '../../stateManagement';\r\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\r\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\r\nimport {\r\n  triggerAnnotationCompleted,\r\n  triggerAnnotationModified,\r\n} from '../../stateManagement/annotation/helpers/state';\r\nimport {\r\n  drawHandles as drawHandlesSvg,\r\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\r\n  drawRectByCoordinates as drawRectSvg,\r\n} from '../../drawingSvg';\r\nimport { state } from '../../store';\r\nimport { Events } from '../../enums';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport * as rectangle from '../../utilities/math/rectangle';\r\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\r\nimport getWorldWidthAndHeightFromCorners from '../../utilities/planar/getWorldWidthAndHeightFromCorners';\r\nimport {\r\n  resetElementCursor,\r\n  hideElementCursor,\r\n} from '../../cursors/elementCursor';\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\n\r\nimport {\r\n  EventTypes,\r\n  ToolHandle,\r\n  TextBoxHandle,\r\n  ToolProps,\r\n  PublicToolProps,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\nimport { RectangleROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\r\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\r\nimport { pointInShapeCallback } from '../../utilities/';\r\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\r\n\r\nconst { transformWorldToIndex } = csUtils;\r\n\r\n/**\r\n * RectangleROIAnnotation let you draw annotations that measures the statistics\r\n * such as area, max, mean and stdDev of a Rectangular region of interest.\r\n * You can use RectangleROIAnnotation in all perpendicular views (axial, sagittal, coronal).\r\n * Note: annotation tools in cornerstone3DTools exists in the exact location\r\n * in the physical 3d space, as a result, by default, all annotations that are\r\n * drawing in the same frameOfReference will get shared between viewports that\r\n * are in the same frameOfReference. RectangleROI tool's text box lines are dynamically\r\n * generated based on the viewport's underlying Modality. For instance, if\r\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\r\n * and if the viewport is displaying PET, the text box will show the statistics in\r\n * SUV units.\r\n *\r\n * The resulting annotation's data (statistics) and metadata (the\r\n * state of the viewport while drawing was happening) will get added to the\r\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\r\n * or similar methods.\r\n *\r\n * ```js\r\n * cornerstoneTools.addTool(RectangleROITool)\r\n *\r\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\r\n *\r\n * toolGroup.addTool(RectangleROITool.toolName)\r\n *\r\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\r\n *\r\n * toolGroup.setToolActive(RectangleROITool.toolName, {\r\n *   bindings: [\r\n *    {\r\n *       mouseButton: MouseBindings.Primary, // Left Click\r\n *     },\r\n *   ],\r\n * })\r\n * ```\r\n *\r\n * Read more in the Docs section of the website.\r\n */\r\n\r\nclass RectangleROITool extends AnnotationTool {\r\n  static toolName;\r\n\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: string[];\r\n    handleIndex?: number;\r\n    movingTextBox?: boolean;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        shadow: true,\r\n        preventHandleOutsideImage: false,\r\n        getTextLines: defaultGetTextLines,\r\n        statsCalculator: BasicStatsCalculator,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n\r\n    this._throttledCalculateCachedStats = throttle(\r\n      this._calculateCachedStats,\r\n      100,\r\n      { trailing: true }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the current imageId to create\r\n   * a RectangleROI Annotation and stores it in the annotationManager\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation = (\r\n    evt: EventTypes.InteractionEventType\r\n  ): RectangleROIAnnotation => {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    const referencedImageId = this.getReferencedImageId(\r\n      viewport,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      viewUp\r\n    );\r\n\r\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n\r\n    const annotation = {\r\n      invalidated: true,\r\n      highlighted: true,\r\n      metadata: {\r\n        toolName: this.getToolName(),\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID,\r\n        referencedImageId,\r\n        ...viewport.getViewReference({ points: [worldPos] }),\r\n      },\r\n      data: {\r\n        label: '',\r\n        handles: {\r\n          points: [\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n          ],\r\n          textBox: {\r\n            hasMoved: false,\r\n            worldPosition: <Types.Point3>[0, 0, 0],\r\n            worldBoundingBox: {\r\n              topLeft: <Types.Point3>[0, 0, 0],\r\n              topRight: <Types.Point3>[0, 0, 0],\r\n              bottomLeft: <Types.Point3>[0, 0, 0],\r\n              bottomRight: <Types.Point3>[0, 0, 0],\r\n            },\r\n          },\r\n          activeHandleIndex: null,\r\n        },\r\n        cachedStats: {},\r\n      },\r\n    };\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex: 3,\r\n      movingTextBox: false,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n    };\r\n    this._activateDraw(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  };\r\n\r\n  /**\r\n   * It returns if the canvas point is near the provided annotation in the provided\r\n   * element or not. A proximity is passed to the function to determine the\r\n   * proximity of the point to the annotation in number of pixels.\r\n   *\r\n   * @param element - HTML Element\r\n   * @param annotation - Annotation\r\n   * @param canvasCoords - Canvas coordinates\r\n   * @param proximity - Proximity to tool to consider\r\n   * @returns Boolean, whether the canvas point is near tool\r\n   */\r\n  isPointNearTool = (\r\n    element: HTMLDivElement,\r\n    annotation: RectangleROIAnnotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): boolean => {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    const { data } = annotation;\r\n    const { points } = data.handles;\r\n\r\n    const canvasPoint1 = viewport.worldToCanvas(points[0]);\r\n    const canvasPoint2 = viewport.worldToCanvas(points[3]);\r\n\r\n    const rect = this._getRectangleImageCoordinates([\r\n      canvasPoint1,\r\n      canvasPoint2,\r\n    ]);\r\n\r\n    const point = [canvasCoords[0], canvasCoords[1]];\r\n    const { left, top, width, height } = rect;\r\n\r\n    const distanceToPoint = rectangle.distanceToPoint(\r\n      [left, top, width, height],\r\n      point as Types.Point2\r\n    );\r\n\r\n    if (distanceToPoint <= proximity) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  toolSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: RectangleROIAnnotation\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      movingTextBox: false,\r\n    };\r\n\r\n    this._activateModify(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  handleSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: RectangleROIAnnotation,\r\n    handle: ToolHandle\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const { data } = annotation;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    let movingTextBox = false;\r\n    let handleIndex;\r\n\r\n    if ((handle as TextBoxHandle).worldPosition) {\r\n      movingTextBox = true;\r\n    } else {\r\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\r\n    }\r\n\r\n    // Find viewports to render on drag.\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex,\r\n      movingTextBox,\r\n    };\r\n    this._activateModify(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (newAnnotation && !hasMoved) {\r\n      return;\r\n    }\r\n\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateModify(element);\r\n    this._deactivateDraw(element);\r\n\r\n    resetElementCursor(element);\r\n\r\n    const { renderingEngine } = getEnabledElement(element);\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n\r\n    if (\r\n      this.isHandleOutsideImage &&\r\n      this.configuration.preventHandleOutsideImage\r\n    ) {\r\n      removeAnnotation(annotation.annotationUID);\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    if (newAnnotation) {\r\n      triggerAnnotationCompleted(annotation);\r\n    }\r\n  };\r\n\r\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    this.isDrawing = true;\r\n\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (movingTextBox) {\r\n      // Drag mode - Move the text boxes world position\r\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n\r\n      const { textBox } = data.handles;\r\n      const { worldPosition } = textBox;\r\n\r\n      worldPosition[0] += worldPosDelta[0];\r\n      worldPosition[1] += worldPosDelta[1];\r\n      worldPosition[2] += worldPosDelta[2];\r\n\r\n      textBox.hasMoved = true;\r\n    } else if (handleIndex === undefined) {\r\n      // Drag mode - Moving tool, so move all points by the world points delta\r\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n\r\n      const { points } = data.handles;\r\n\r\n      points.forEach((point) => {\r\n        point[0] += worldPosDelta[0];\r\n        point[1] += worldPosDelta[1];\r\n        point[2] += worldPosDelta[2];\r\n      });\r\n      annotation.invalidated = true;\r\n    } else {\r\n      // Moving handle.\r\n      const { currentPoints } = eventDetail;\r\n      const enabledElement = getEnabledElement(element);\r\n      const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\r\n      const worldPos = currentPoints.world;\r\n\r\n      const { points } = data.handles;\r\n\r\n      // Move this handle.\r\n      points[handleIndex] = [...worldPos];\r\n\r\n      let bottomLeftCanvas;\r\n      let bottomRightCanvas;\r\n      let topLeftCanvas;\r\n      let topRightCanvas;\r\n\r\n      let bottomLeftWorld;\r\n      let bottomRightWorld;\r\n      let topLeftWorld;\r\n      let topRightWorld;\r\n\r\n      switch (handleIndex) {\r\n        case 0:\r\n        case 3:\r\n          // Moving bottomLeft or topRight\r\n\r\n          bottomLeftCanvas = worldToCanvas(points[0]);\r\n          topRightCanvas = worldToCanvas(points[3]);\r\n\r\n          bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\r\n          topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\r\n\r\n          bottomRightWorld = canvasToWorld(bottomRightCanvas);\r\n          topLeftWorld = canvasToWorld(topLeftCanvas);\r\n\r\n          points[1] = bottomRightWorld;\r\n          points[2] = topLeftWorld;\r\n\r\n          break;\r\n        case 1:\r\n        case 2:\r\n          // Moving bottomRight or topLeft\r\n          bottomRightCanvas = worldToCanvas(points[1]);\r\n          topLeftCanvas = worldToCanvas(points[2]);\r\n\r\n          bottomLeftCanvas = <Types.Point2>[\r\n            topLeftCanvas[0],\r\n            bottomRightCanvas[1],\r\n          ];\r\n          topRightCanvas = <Types.Point2>[\r\n            bottomRightCanvas[0],\r\n            topLeftCanvas[1],\r\n          ];\r\n\r\n          bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\r\n          topRightWorld = canvasToWorld(topRightCanvas);\r\n\r\n          points[0] = bottomLeftWorld;\r\n          points[3] = topRightWorld;\r\n\r\n          break;\r\n      }\r\n      annotation.invalidated = true;\r\n    }\r\n\r\n    this.editData.hasMoved = true;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  cancel = (element: HTMLDivElement) => {\r\n    // If it is mid-draw or mid-modify\r\n    if (this.isDrawing) {\r\n      this.isDrawing = false;\r\n      this._deactivateDraw(element);\r\n      this._deactivateModify(element);\r\n      resetElementCursor(element);\r\n\r\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\r\n\r\n      const { data } = annotation;\r\n\r\n      annotation.highlighted = false;\r\n      data.handles.activeHandleIndex = null;\r\n\r\n      const { renderingEngine } = getEnabledElement(element);\r\n\r\n      triggerAnnotationRenderForViewportIds(\r\n        renderingEngine,\r\n        viewportIdsToRender\r\n      );\r\n\r\n      if (newAnnotation) {\r\n        triggerAnnotationCompleted(annotation);\r\n      }\r\n\r\n      this.editData = null;\r\n      return annotation.annotationUID;\r\n    }\r\n  };\r\n  /**\r\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\r\n   */\r\n  _activateDraw = (element) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\r\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\r\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  /**\r\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\r\n   */\r\n  _deactivateDraw = (element) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\r\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\r\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  /**\r\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\r\n   */\r\n  _activateModify = (element) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\r\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  /**\r\n   * Remove event handlers for the modify event loop, and enable default event propagation.\r\n   */\r\n  _deactivateModify = (element) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\r\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the rectangleROI annotation in each\r\n   * request animation frame. It calculates the updated cached statistics if\r\n   * data is invalidated and cache it.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n\r\n    let annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    annotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    );\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const targetId = this.getTargetId(viewport);\r\n    const renderingEngine = viewport.getRenderingEngine();\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[i] as RectangleROIAnnotation;\r\n      const { annotationUID, data } = annotation;\r\n      const { points, activeHandleIndex } = data.handles;\r\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\r\n        annotation,\r\n        styleSpecifier,\r\n      });\r\n\r\n      const { viewPlaneNormal, viewUp } = viewport.getCamera();\r\n\r\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\r\n      // force to recalculate the stats from the points\r\n      if (\r\n        !data.cachedStats[targetId] ||\r\n        data.cachedStats[targetId].areaUnit == null\r\n      ) {\r\n        data.cachedStats[targetId] = {\r\n          Modality: null,\r\n          area: null,\r\n          max: null,\r\n          mean: null,\r\n          stdDev: null,\r\n          areaUnit: null,\r\n        };\r\n\r\n        this._calculateCachedStats(\r\n          annotation,\r\n          viewPlaneNormal,\r\n          viewUp,\r\n          renderingEngine,\r\n          enabledElement\r\n        );\r\n      } else if (annotation.invalidated) {\r\n        this._throttledCalculateCachedStats(\r\n          annotation,\r\n          viewPlaneNormal,\r\n          viewUp,\r\n          renderingEngine,\r\n          enabledElement\r\n        );\r\n\r\n        // If the invalidated data is as a result of volumeViewport manipulation\r\n        // of the tools, we need to invalidate the related stackViewports data if\r\n        // they are not at the referencedImageId, so that\r\n        // when scrolling to the related slice in which the tool were manipulated\r\n        // we re-render the correct tool position. This is due to stackViewport\r\n        // which doesn't have the full volume at each time, and we are only working\r\n        // on one slice at a time.\r\n        if (viewport instanceof VolumeViewport) {\r\n          const { referencedImageId } = annotation.metadata;\r\n\r\n          // invalidate all the relevant stackViewports if they are not\r\n          // at the referencedImageId\r\n          for (const targetId in data.cachedStats) {\r\n            if (targetId.startsWith('imageId')) {\r\n              const viewports = renderingEngine.getStackViewports();\r\n\r\n              const invalidatedStack = viewports.find((vp) => {\r\n                // The stack viewport that contains the imageId but is not\r\n                // showing it currently\r\n                const referencedImageURI =\r\n                  csUtils.imageIdToURI(referencedImageId);\r\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\r\n                const currentImageURI = csUtils.imageIdToURI(\r\n                  vp.getCurrentImageId()\r\n                );\r\n                return hasImageURI && currentImageURI !== referencedImageURI;\r\n              });\r\n\r\n              if (invalidatedStack) {\r\n                delete data.cachedStats[targetId];\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n\r\n      let activeHandleCanvasCoords;\r\n\r\n      if (!isAnnotationVisible(annotationUID)) {\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        !isAnnotationLocked(annotation) &&\r\n        !this.editData &&\r\n        activeHandleIndex !== null\r\n      ) {\r\n        // Not locked or creating and hovering over handle, so render handle.\r\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\r\n      }\r\n\r\n      if (activeHandleCanvasCoords) {\r\n        const handleGroupUID = '0';\r\n\r\n        drawHandlesSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          handleGroupUID,\r\n          activeHandleCanvasCoords,\r\n          {\r\n            color,\r\n          }\r\n        );\r\n      }\r\n\r\n      const dataId = `${annotationUID}-rect`;\r\n      const rectangleUID = '0';\r\n      drawRectSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        rectangleUID,\r\n        canvasCoordinates,\r\n        {\r\n          color,\r\n          lineDash,\r\n          lineWidth,\r\n        },\r\n        dataId\r\n      );\r\n\r\n      renderStatus = true;\r\n\r\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\r\n      if (!options.visibility) {\r\n        data.handles.textBox = {\r\n          hasMoved: false,\r\n          worldPosition: <Types.Point3>[0, 0, 0],\r\n          worldBoundingBox: {\r\n            topLeft: <Types.Point3>[0, 0, 0],\r\n            topRight: <Types.Point3>[0, 0, 0],\r\n            bottomLeft: <Types.Point3>[0, 0, 0],\r\n            bottomRight: <Types.Point3>[0, 0, 0],\r\n          },\r\n        };\r\n        continue;\r\n      }\r\n\r\n      const textLines = this.configuration.getTextLines(data, targetId);\r\n      if (!textLines || textLines.length === 0) {\r\n        continue;\r\n      }\r\n\r\n      if (!data.handles.textBox.hasMoved) {\r\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\r\n\r\n        data.handles.textBox.worldPosition =\r\n          viewport.canvasToWorld(canvasTextBoxCoords);\r\n      }\r\n\r\n      const textBoxPosition = viewport.worldToCanvas(\r\n        data.handles.textBox.worldPosition\r\n      );\r\n\r\n      const textBoxUID = '1';\r\n      const boundingBox = drawLinkedTextBoxSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        textBoxUID,\r\n        textLines,\r\n        textBoxPosition,\r\n        canvasCoordinates,\r\n        {},\r\n        options\r\n      );\r\n\r\n      const { x: left, y: top, width, height } = boundingBox;\r\n\r\n      data.handles.textBox.worldBoundingBox = {\r\n        topLeft: viewport.canvasToWorld([left, top]),\r\n        topRight: viewport.canvasToWorld([left + width, top]),\r\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\r\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\r\n      };\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  _getRectangleImageCoordinates = (\r\n    points: Array<Types.Point2>\r\n  ): {\r\n    left: number;\r\n    top: number;\r\n    width: number;\r\n    height: number;\r\n  } => {\r\n    const [point0, point1] = points;\r\n\r\n    return {\r\n      left: Math.min(point0[0], point1[0]),\r\n      top: Math.min(point0[1], point1[1]),\r\n      width: Math.abs(point0[0] - point1[0]),\r\n      height: Math.abs(point0[1] - point1[1]),\r\n    };\r\n  };\r\n\r\n  /**\r\n   * _calculateCachedStats - For each volume in the frame of reference that a\r\n   * tool instance in particular viewport defines as its target volume, find the\r\n   * volume coordinates (i,j,k) being probed by the two corners. One of i,j or k\r\n   * will be constant across the two points. In the other two directions iterate\r\n   * over the voxels and calculate the first and second-order statistics.\r\n   *\r\n   * @param data - The annotation tool-specific data.\r\n   * @param viewPlaneNormal - The normal vector of the camera.\r\n   * @param viewUp - The viewUp vector of the camera.\r\n   */\r\n  _calculateCachedStats = (\r\n    annotation,\r\n    viewPlaneNormal,\r\n    viewUp,\r\n    renderingEngine,\r\n    enabledElement\r\n  ) => {\r\n    const { data } = annotation;\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n\r\n    const worldPos1 = data.handles.points[0];\r\n    const worldPos2 = data.handles.points[3];\r\n    const { cachedStats } = data;\r\n\r\n    const targetIds = Object.keys(cachedStats);\r\n\r\n    for (let i = 0; i < targetIds.length; i++) {\r\n      const targetId = targetIds[i];\r\n\r\n      const image = this.getTargetIdImage(targetId, renderingEngine);\r\n\r\n      // If image does not exists for the targetId, skip. This can be due\r\n      // to various reasons such as if the target was a volumeViewport, and\r\n      // the volumeViewport has been decached in the meantime.\r\n      if (!image) {\r\n        continue;\r\n      }\r\n\r\n      const { dimensions, imageData, metadata } = image;\r\n\r\n      const pos1Index = transformWorldToIndex(imageData, worldPos1);\r\n\r\n      pos1Index[0] = Math.floor(pos1Index[0]);\r\n      pos1Index[1] = Math.floor(pos1Index[1]);\r\n      pos1Index[2] = Math.floor(pos1Index[2]);\r\n\r\n      const pos2Index = transformWorldToIndex(imageData, worldPos2);\r\n\r\n      pos2Index[0] = Math.floor(pos2Index[0]);\r\n      pos2Index[1] = Math.floor(pos2Index[1]);\r\n      pos2Index[2] = Math.floor(pos2Index[2]);\r\n\r\n      // Check if one of the indexes are inside the volume, this then gives us\r\n      // Some area to do stats over.\r\n\r\n      if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {\r\n        this.isHandleOutsideImage = false;\r\n\r\n        // Calculate index bounds to iterate over\r\n\r\n        const iMin = Math.min(pos1Index[0], pos2Index[0]);\r\n        const iMax = Math.max(pos1Index[0], pos2Index[0]);\r\n\r\n        const jMin = Math.min(pos1Index[1], pos2Index[1]);\r\n        const jMax = Math.max(pos1Index[1], pos2Index[1]);\r\n\r\n        const kMin = Math.min(pos1Index[2], pos2Index[2]);\r\n        const kMax = Math.max(pos1Index[2], pos2Index[2]);\r\n\r\n        const boundsIJK = [\r\n          [iMin, iMax],\r\n          [jMin, jMax],\r\n          [kMin, kMax],\r\n        ] as [Types.Point2, Types.Point2, Types.Point2];\r\n\r\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(\r\n          viewPlaneNormal,\r\n          viewUp,\r\n          worldPos1,\r\n          worldPos2\r\n        );\r\n\r\n        const handles = [pos1Index, pos2Index];\r\n        const { scale, areaUnits } = getCalibratedLengthUnitsAndScale(\r\n          image,\r\n          handles\r\n        );\r\n\r\n        const area = Math.abs(worldWidth * worldHeight) / (scale * scale);\r\n\r\n        const modalityUnitOptions = {\r\n          isPreScaled: isViewportPreScaled(viewport, targetId),\r\n\r\n          isSuvScaled: this.isSuvScaled(\r\n            viewport,\r\n            targetId,\r\n            annotation.metadata.referencedImageId\r\n          ),\r\n        };\r\n\r\n        const modalityUnit = getModalityUnit(\r\n          metadata.Modality,\r\n          annotation.metadata.referencedImageId,\r\n          modalityUnitOptions\r\n        );\r\n\r\n        const pointsInShape = pointInShapeCallback(\r\n          imageData,\r\n          () => true,\r\n          this.configuration.statsCalculator.statsCallback,\r\n          boundsIJK\r\n        );\r\n\r\n        const stats = this.configuration.statsCalculator.getStatistics();\r\n\r\n        cachedStats[targetId] = {\r\n          Modality: metadata.Modality,\r\n          area,\r\n          mean: stats.mean?.value,\r\n          stdDev: stats.stdDev?.value,\r\n          max: stats.max?.value,\r\n          statsArray: stats.array,\r\n          pointsInShape: pointsInShape,\r\n          areaUnit: areaUnits,\r\n          modalityUnit,\r\n        };\r\n      } else {\r\n        this.isHandleOutsideImage = true;\r\n        cachedStats[targetId] = {\r\n          Modality: metadata.Modality,\r\n        };\r\n      }\r\n    }\r\n\r\n    annotation.invalidated = false;\r\n\r\n    // Dispatching annotation modified\r\n    triggerAnnotationModified(annotation, element);\r\n\r\n    return cachedStats;\r\n  };\r\n\r\n  _isInsideVolume = (index1, index2, dimensions) => {\r\n    return (\r\n      csUtils.indexWithinDimensions(index1, dimensions) &&\r\n      csUtils.indexWithinDimensions(index2, dimensions)\r\n    );\r\n  };\r\n}\r\n\r\n/**\r\n * _getTextLines - Returns the Area, mean and std deviation of the area of the\r\n * target volume enclosed by the rectangle.\r\n *\r\n * @param data - The annotation tool-specific data.\r\n * @param targetId - The volumeId of the volume to display the stats for.\r\n */\r\nfunction defaultGetTextLines(data, targetId: string): string[] {\r\n  const cachedVolumeStats = data.cachedStats[targetId];\r\n  const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\r\n\r\n  if (mean === undefined) {\r\n    return;\r\n  }\r\n\r\n  const textLines: string[] = [];\r\n\r\n  textLines.push(`Area: ${roundNumber(area)} ${areaUnit}`);\r\n  textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\r\n  textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\r\n  textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\r\n\r\n  return textLines;\r\n}\r\n\r\nRectangleROITool.toolName = 'RectangleROI';\r\nexport default RectangleROITool;\r\n","import { utilities } from '@cornerstonejs/core';\r\nimport { PublicToolProps } from '../../types';\r\nimport SplineROITool from './SplineROITool';\r\n\r\nclass SplineContourSegmentationTool extends SplineROITool {\r\n  static toolName;\r\n\r\n  constructor(toolProps: PublicToolProps) {\r\n    const initialProps = utilities.deepMerge(\r\n      {\r\n        configuration: {\r\n          calculateStats: false,\r\n        },\r\n      },\r\n      toolProps\r\n    );\r\n\r\n    super(initialProps);\r\n  }\r\n\r\n  protected isContourSegmentationTool(): boolean {\r\n    // Re-enable contour segmentation behavior disabled by SplineROITool\r\n    return true;\r\n  }\r\n}\r\n\r\nSplineContourSegmentationTool.toolName = 'SplineContourSegmentationTool';\r\nexport default SplineContourSegmentationTool;\r\n","import {\r\n  getEnabledElement,\r\n  eventTarget,\r\n  triggerEvent,\r\n  utilities,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport { vec3 } from 'gl-matrix';\r\nimport {\r\n  getChildAnnotations,\r\n  removeAnnotation,\r\n} from '../../stateManagement/annotation/annotationState';\r\nimport {\r\n  drawHandles as drawHandlesSvg,\r\n  drawPolyline as drawPolylineSvg,\r\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\r\n} from '../../drawingSvg';\r\nimport { state } from '../../store';\r\nimport {\r\n  Events,\r\n  MouseBindings,\r\n  KeyboardBindings,\r\n  ChangeTypes,\r\n} from '../../enums';\r\nimport { resetElementCursor } from '../../cursors/elementCursor';\r\nimport type {\r\n  Annotation,\r\n  EventTypes,\r\n  ToolHandle,\r\n  TextBoxHandle,\r\n  PublicToolProps,\r\n  ToolProps,\r\n  AnnotationRenderContext,\r\n} from '../../types';\r\nimport {\r\n  math,\r\n  throttle,\r\n  roundNumber,\r\n  triggerAnnotationRenderForViewportIds,\r\n  getCalibratedLengthUnitsAndScale,\r\n} from '../../utilities';\r\nimport getMouseModifierKey from '../../eventDispatchers/shared/getMouseModifier';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\r\n\r\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\r\nimport type { SplineROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\nimport type {\r\n  AnnotationModifiedEventDetail,\r\n  ContourAnnotationCompletedEventDetail,\r\n} from '../../types/EventTypes';\r\nimport { ISpline } from '../../types/ISpline';\r\nimport { CardinalSpline } from './splines/CardinalSpline';\r\nimport { LinearSpline } from './splines/LinearSpline';\r\nimport { CatmullRomSpline } from './splines/CatmullRomSpline';\r\nimport { BSpline } from './splines/BSpline';\r\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\r\n\r\nconst SPLINE_MIN_POINTS = 3;\r\nconst SPLINE_CLICK_CLOSE_CURVE_DIST = 10;\r\n\r\nconst DEFAULT_SPLINE_CONFIG = {\r\n  resolution: 20,\r\n  controlPointAdditionDistance: 6,\r\n  controlPointDeletionDistance: 6,\r\n  showControlPointsConnectors: false,\r\n  controlPointAdditionEnabled: true,\r\n  controlPointDeletionEnabled: true,\r\n};\r\n\r\nenum SplineTypesEnum {\r\n  Cardinal = 'CARDINAL',\r\n  Linear = 'LINEAR',\r\n  CatmullRom = 'CATMULLROM',\r\n  BSpline = 'BSPLINE',\r\n}\r\n\r\nenum SplineToolActions {\r\n  AddControlPoint = 'addControlPoint',\r\n  DeleteControlPoint = 'deleteControlPoint',\r\n}\r\n\r\nclass SplineROITool extends ContourSegmentationBaseTool {\r\n  static toolName;\r\n  static SplineTypes = SplineTypesEnum;\r\n  static Actions = SplineToolActions;\r\n\r\n  touchDragCallback: any;\r\n  mouseDragCallback: any;\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    annotation: SplineROIAnnotation;\r\n    viewportIdsToRender: Array<string>;\r\n    handleIndex?: number;\r\n    movingTextBox?: boolean;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n    lastCanvasPoint?: Types.Point2;\r\n    contourHoleProcessingEnabled?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage = false;\r\n  fireChangeOnUpdate: {\r\n    annotationUID: string;\r\n    changeType: ChangeTypes;\r\n    contourHoleProcessingEnabled: boolean;\r\n  } = null;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        preventHandleOutsideImage: false,\r\n        calculateStats: true,\r\n        getTextLines: defaultGetTextLines,\r\n        /**\r\n         * Specify which modifier key is used to add a hole to a contour. The\r\n         * modifier must be pressed when the first point of a new contour is added.\r\n         */\r\n        contourHoleAdditionModifierKey: KeyboardBindings.Shift,\r\n        /**\r\n         * The polyline may get processed in order to reduce the number of points\r\n         * for better performance and storage.\r\n         */\r\n        decimate: {\r\n          enabled: false,\r\n          /** A maximum given distance 'epsilon' to decide if a point should or\r\n           * shouldn't be added the resulting polyline which will have a lower\r\n           * number of points for higher `epsilon` values.\r\n           */\r\n          epsilon: 0.1,\r\n        },\r\n        spline: {\r\n          configuration: {\r\n            [SplineTypesEnum.Cardinal]: {\r\n              Class: CardinalSpline,\r\n              scale: 0.5,\r\n            },\r\n            [SplineTypesEnum.CatmullRom]: {\r\n              Class: CatmullRomSpline,\r\n            },\r\n            [SplineTypesEnum.Linear]: {\r\n              Class: LinearSpline,\r\n            },\r\n            [SplineTypesEnum.BSpline]: {\r\n              Class: BSpline,\r\n              controlPointAdditionEnabled: false,\r\n              controlPointDeletionEnabled: false,\r\n              showControlPointsConnectors: true,\r\n            },\r\n          },\r\n          type: SplineTypesEnum.CatmullRom,\r\n          drawPreviewEnabled: true,\r\n          lastControlPointDeletionKeys: ['Backspace', 'Delete'],\r\n        },\r\n        actions: {\r\n          [SplineToolActions.AddControlPoint]: {\r\n            method: 'addControlPointCallback',\r\n            bindings: [\r\n              {\r\n                mouseButton: MouseBindings.Primary,\r\n                modifierKey: KeyboardBindings.Shift,\r\n              },\r\n            ],\r\n          },\r\n          [SplineToolActions.DeleteControlPoint]: {\r\n            method: 'deleteControlPointCallback',\r\n            bindings: [\r\n              {\r\n                mouseButton: MouseBindings.Primary,\r\n                modifierKey: KeyboardBindings.Ctrl,\r\n              },\r\n            ],\r\n          },\r\n        },\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n\r\n    this._throttledCalculateCachedStats = throttle(\r\n      this._calculateCachedStats,\r\n      100,\r\n      { trailing: true }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the current imageId to create\r\n   * a CircleROI Annotation and stores it in the annotationManager\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation(evt: EventTypes.InteractionEventType): SplineROIAnnotation {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const { canvas: canvasPos } = currentPoints;\r\n    const contourHoleProcessingEnabled =\r\n      getMouseModifierKey(evt.detail.event) ===\r\n      this.configuration.contourHoleAdditionModifierKey;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n    const annotation = this.createAnnotation(evt) as SplineROIAnnotation;\r\n\r\n    this.isDrawing = true;\r\n    this.addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      movingTextBox: false,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n      lastCanvasPoint: canvasPos,\r\n      contourHoleProcessingEnabled,\r\n    };\r\n\r\n    this._activateDraw(element);\r\n    evt.preventDefault();\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  }\r\n\r\n  /**\r\n   * It returns if the canvas point is near the provided annotation in the provided\r\n   * element or not. A proximity is passed to the function to determine the\r\n   * proximity of the point to the annotation in number of pixels.\r\n   *\r\n   * @param element - HTML Element\r\n   * @param annotation - Annotation\r\n   * @param canvasCoords - Canvas coordinates\r\n   * @param proximity - Proximity to tool to consider\r\n   * @returns Boolean, whether the canvas point is near tool\r\n   */\r\n  isPointNearTool = (\r\n    element: HTMLDivElement,\r\n    annotation: SplineROIAnnotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): boolean => {\r\n    const { instance: spline } = annotation.data.spline;\r\n\r\n    return spline.isPointNearCurve(canvasCoords, proximity);\r\n  };\r\n\r\n  toolSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: SplineROIAnnotation\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      movingTextBox: false,\r\n    };\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    this._activateModify(element);\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n    evt.preventDefault();\r\n  };\r\n\r\n  handleSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: SplineROIAnnotation,\r\n    handle: ToolHandle\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const { data } = annotation;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    let movingTextBox = false;\r\n    let handleIndex;\r\n\r\n    if ((handle as TextBoxHandle).worldPosition) {\r\n      movingTextBox = true;\r\n    } else {\r\n      const { points } = data.handles;\r\n\r\n      handleIndex = points.findIndex((p) => p === handle);\r\n    }\r\n\r\n    // Find viewports to render on drag.\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex,\r\n      movingTextBox,\r\n    };\r\n    this._activateModify(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      newAnnotation,\r\n      contourHoleProcessingEnabled,\r\n    } = this.editData;\r\n    const { data } = annotation;\r\n    annotation.autoGenerated = false;\r\n\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateModify(element);\r\n    this._deactivateDraw(element);\r\n    resetElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    // Decide whether there's at least one point is outside image\r\n    const image = this.getTargetIdImage(\r\n      this.getTargetId(enabledElement.viewport),\r\n      enabledElement.renderingEngine\r\n    );\r\n    const { imageData, dimensions } = image;\r\n    this.isHandleOutsideImage = data.handles.points\r\n      .map((p) => utilities.transformWorldToIndex(imageData, p))\r\n      .some((index) => !utilities.indexWithinDimensions(index, dimensions));\r\n\r\n    if (\r\n      this.isHandleOutsideImage &&\r\n      this.configuration.preventHandleOutsideImage\r\n    ) {\r\n      removeAnnotation(annotation.annotationUID);\r\n    }\r\n\r\n    const changeType = newAnnotation\r\n      ? ChangeTypes.Completed\r\n      : ChangeTypes.HandlesUpdated;\r\n    if (!this.fireChangeOnUpdate) {\r\n      this.fireChangeOnUpdate = {\r\n        annotationUID: annotation.annotationUID,\r\n        changeType,\r\n        contourHoleProcessingEnabled,\r\n      };\r\n    } else {\r\n      this.fireChangeOnUpdate.annotationUID = annotation.annotationUID;\r\n      this.fireChangeOnUpdate.changeType = changeType;\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n  };\r\n\r\n  private _keyDownCallback = (evt: EventTypes.KeyDownEventType) => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const key = eventDetail.key ?? '';\r\n    const { lastControlPointDeletionKeys } = this.configuration.spline;\r\n    const deleteLastPoint = lastControlPointDeletionKeys.includes(key);\r\n\r\n    if (!deleteLastPoint) {\r\n      return;\r\n    }\r\n\r\n    const { annotation } = this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (data.handles.points.length === SPLINE_MIN_POINTS) {\r\n      this.cancel(element);\r\n      return;\r\n    } else {\r\n      const controlPointIndex = data.handles.points.length - 1;\r\n      this._deleteControlPointByIndex(element, annotation, controlPointIndex);\r\n    }\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  private _mouseMoveCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const { drawPreviewEnabled } = this.configuration.spline;\r\n\r\n    // Does not force a re-render if preview is not enabled\r\n    if (!drawPreviewEnabled) {\r\n      return;\r\n    }\r\n\r\n    const { element } = evt.detail;\r\n    const { renderingEngine } = getEnabledElement(element);\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData.lastCanvasPoint = evt.detail.currentPoints.canvas;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n    evt.preventDefault();\r\n  };\r\n\r\n  private _mouseDownCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\r\n    const { annotation, viewportIdsToRender } = this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (data.contour.closed) {\r\n      return;\r\n    }\r\n\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const { currentPoints } = eventDetail;\r\n    const { canvas: canvasPoint, world: worldPoint } = currentPoints;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n    let closeContour = data.handles.points.length >= 2 && doubleClick;\r\n    let addNewPoint = true;\r\n\r\n    // Check if user clicked on the first point to close the curve\r\n    if (data.handles.points.length >= 3) {\r\n      const { instance: spline } = data.spline;\r\n      const closestControlPoint = spline.getClosestControlPointWithinDistance(\r\n        canvasPoint,\r\n        SPLINE_CLICK_CLOSE_CURVE_DIST\r\n      );\r\n\r\n      if (closestControlPoint?.index === 0) {\r\n        addNewPoint = false;\r\n        closeContour = true;\r\n      }\r\n    }\r\n\r\n    if (addNewPoint) {\r\n      data.handles.points.push(worldPoint);\r\n    }\r\n\r\n    data.contour.closed = data.contour.closed || closeContour;\r\n    annotation.invalidated = true;\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    if (data.contour.closed) {\r\n      this._endCallback(evt);\r\n    }\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  private _dragCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    this.isDrawing = true;\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (movingTextBox) {\r\n      // Drag mode - moving text box\r\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n\r\n      const { textBox } = data.handles;\r\n      const { worldPosition } = textBox;\r\n\r\n      worldPosition[0] += worldPosDelta[0];\r\n      worldPosition[1] += worldPosDelta[1];\r\n      worldPosition[2] += worldPosDelta[2];\r\n\r\n      textBox.hasMoved = true;\r\n    } else if (handleIndex === undefined) {\r\n      // Drag mode - moving handle\r\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n\r\n      this.moveAnnotation(annotation, worldPosDelta);\r\n    } else {\r\n      // Move mode - after double click, and mouse move to draw\r\n      const { currentPoints } = eventDetail;\r\n      const worldPos = currentPoints.world;\r\n\r\n      data.handles.points[handleIndex] = [...worldPos];\r\n      annotation.invalidated = true;\r\n    }\r\n\r\n    this.editData.hasMoved = true;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  cancel(element: HTMLDivElement) {\r\n    // If it is not in mid-draw or mid-modify\r\n    if (!this.isDrawing) {\r\n      return;\r\n    }\r\n\r\n    this.isDrawing = false;\r\n    this._deactivateDraw(element);\r\n    this._deactivateModify(element);\r\n    resetElementCursor(element);\r\n\r\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\r\n\r\n    if (newAnnotation) {\r\n      removeAnnotation(annotation.annotationUID);\r\n    }\r\n\r\n    super.cancelAnnotation(annotation);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    this.editData = null;\r\n    return annotation.annotationUID;\r\n  }\r\n\r\n  /**\r\n   * Triggers an annotation completed event.\r\n   */\r\n  triggerAnnotationCompleted = (\r\n    annotation: SplineROIAnnotation,\r\n    contourHoleProcessingEnabled: boolean\r\n  ): void => {\r\n    const eventType = Events.ANNOTATION_COMPLETED;\r\n    const eventDetail: ContourAnnotationCompletedEventDetail = {\r\n      annotation,\r\n      changeType: ChangeTypes.Completed,\r\n      contourHoleProcessingEnabled,\r\n    };\r\n\r\n    triggerEvent(eventTarget, eventType, eventDetail);\r\n  };\r\n\r\n  /**\r\n   * Triggers an annotation modified event.\r\n   */\r\n  triggerAnnotationModified = (\r\n    annotation: SplineROIAnnotation,\r\n    enabledElement: Types.IEnabledElement,\r\n    changeType = ChangeTypes.StatsUpdated\r\n  ): void => {\r\n    const { viewportId, renderingEngineId } = enabledElement;\r\n    const eventType = Events.ANNOTATION_MODIFIED;\r\n    const eventDetail: AnnotationModifiedEventDetail = {\r\n      annotation,\r\n      viewportId,\r\n      renderingEngineId,\r\n      changeType,\r\n    };\r\n\r\n    triggerEvent(eventTarget, eventType, eventDetail);\r\n  };\r\n\r\n  /**\r\n   * Triggers an annotation complete or modified event based on changeType.\r\n   */\r\n  triggerChangeEvent = (\r\n    annotation: SplineROIAnnotation,\r\n    enabledElement: Types.IEnabledElement,\r\n    changeType = ChangeTypes.StatsUpdated,\r\n    contourHoleProcessingEnabled\r\n  ): void => {\r\n    if (changeType === ChangeTypes.Completed) {\r\n      this.triggerAnnotationCompleted(annotation, contourHoleProcessingEnabled);\r\n    } else {\r\n      this.triggerAnnotationModified(annotation, enabledElement, changeType);\r\n    }\r\n  };\r\n\r\n  private _activateModify = (element) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\r\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  private _deactivateModify = (element) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\r\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  private _activateDraw = (element) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(Events.KEY_DOWN, this._keyDownCallback);\r\n    element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\r\n    element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\r\n    element.addEventListener(\r\n      Events.MOUSE_DOUBLE_CLICK,\r\n      this._mouseDownCallback\r\n    );\r\n\r\n    element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\r\n  };\r\n\r\n  private _deactivateDraw = (element) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(Events.KEY_DOWN, this._keyDownCallback);\r\n    element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\r\n    element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\r\n    element.removeEventListener(\r\n      Events.MOUSE_DOUBLE_CLICK,\r\n      this._mouseDownCallback\r\n    );\r\n\r\n    element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\r\n  };\r\n\r\n  protected isContourSegmentationTool(): boolean {\r\n    // Disable contour segmentation behavior because it shall be activated only\r\n    // for SplineContourSegmentationTool\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Render an annotation instance\r\n   * @param renderContext - Render context that contains the annotation, enabledElement, etc.\r\n   * @returns True if the annotation is rendered or false otherwise\r\n   */\r\n  protected renderAnnotationInstance(\r\n    renderContext: AnnotationRenderContext\r\n  ): boolean {\r\n    const { enabledElement, targetId, svgDrawingHelper, annotationStyle } =\r\n      renderContext;\r\n    const { viewport } = enabledElement;\r\n    const { worldToCanvas } = viewport;\r\n    const { element } = viewport;\r\n    const annotation = renderContext.annotation as SplineROIAnnotation;\r\n    const { annotationUID, data, highlighted } = annotation;\r\n    const { handles } = data;\r\n    const { points: controlPoints, activeHandleIndex } = handles;\r\n    const newAnnotation = this.editData?.newAnnotation;\r\n\r\n    const {\r\n      lineWidth,\r\n      lineDash,\r\n      color,\r\n      locked: annotationLocked,\r\n    } = annotationStyle;\r\n\r\n    const canvasCoordinates = controlPoints.map((p) =>\r\n      worldToCanvas(p)\r\n    ) as Types.Point2[];\r\n\r\n    const { drawPreviewEnabled } = this.configuration.spline;\r\n    const splineType = annotation.data.spline.type;\r\n    const splineConfig = this._getSplineConfig(splineType);\r\n    const spline = annotation.data.spline.instance;\r\n\r\n    const childAnnotations = getChildAnnotations(annotation);\r\n    const missingAnnotation = childAnnotations.findIndex((it) => !it);\r\n    if (missingAnnotation !== -1) {\r\n      // Child annotations go AWOL for a variety of reasons, so report is specifically here\r\n      throw new Error(\r\n        `Can't find annotation for child ${annotation.childAnnotationUIDs.join()}`\r\n      );\r\n    }\r\n    // Update current and all child annotations/splines\r\n    const splineAnnotationsGroup = [annotation, ...childAnnotations].filter(\r\n      (annotation) => this._isSplineROIAnnotation(annotation)\r\n    ) as SplineROIAnnotation[];\r\n\r\n    splineAnnotationsGroup.forEach((annotation) => {\r\n      const spline = this._updateSplineInstance(element, annotation);\r\n      const splinePolylineCanvas = spline.getPolylinePoints();\r\n\r\n      this.updateContourPolyline(\r\n        annotation,\r\n        {\r\n          points: splinePolylineCanvas,\r\n          closed: data.contour.closed,\r\n          targetWindingDirection: ContourWindingDirection.Clockwise,\r\n        },\r\n        viewport\r\n      );\r\n    });\r\n\r\n    // Let the base class render the contour\r\n    super.renderAnnotationInstance(renderContext);\r\n\r\n    // If cachedStats does not exist, or the areaUnit is missing (as part of\r\n    // import/hydration etc.), force to recalculate the stats from the points\r\n    if (\r\n      !data.cachedStats[targetId] ||\r\n      data.cachedStats[targetId].areaUnit == null\r\n    ) {\r\n      data.cachedStats[targetId] = {\r\n        Modality: null,\r\n        area: null,\r\n        areaUnit: null,\r\n      };\r\n\r\n      this._calculateCachedStats(annotation, element);\r\n    } else if (annotation.invalidated) {\r\n      this._throttledCalculateCachedStats(annotation, element);\r\n    }\r\n\r\n    let activeHandleCanvasCoords;\r\n\r\n    if (!annotationLocked && !this.editData && activeHandleIndex !== null) {\r\n      // Not locked or creating and hovering over handle, so render handle.\r\n      activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\r\n    }\r\n\r\n    if (activeHandleCanvasCoords || newAnnotation || highlighted) {\r\n      const handleGroupUID = '0';\r\n\r\n      // Move this call to the base class (contour seg) in the near future\r\n      drawHandlesSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        handleGroupUID,\r\n        canvasCoordinates,\r\n        {\r\n          color,\r\n          lineWidth: Math.max(1, lineWidth),\r\n          handleRadius: '3',\r\n        }\r\n      );\r\n    }\r\n\r\n    if (\r\n      drawPreviewEnabled &&\r\n      spline.numControlPoints > 1 &&\r\n      this.editData?.lastCanvasPoint &&\r\n      !spline.closed\r\n    ) {\r\n      const { lastCanvasPoint } = this.editData;\r\n      const previewPolylinePoints = spline.getPreviewPolylinePoints(\r\n        lastCanvasPoint,\r\n        SPLINE_CLICK_CLOSE_CURVE_DIST\r\n      );\r\n\r\n      drawPolylineSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        'previewSplineChange',\r\n        previewPolylinePoints,\r\n        {\r\n          color: '#9EA0CA',\r\n          lineDash,\r\n          lineWidth: 1,\r\n        }\r\n      );\r\n    }\r\n\r\n    if (splineConfig.showControlPointsConnectors) {\r\n      const controlPointsConnectors = [...canvasCoordinates];\r\n\r\n      // Connect the last point to the first one when the spline is closed\r\n      if (spline.closed) {\r\n        controlPointsConnectors.push(canvasCoordinates[0]);\r\n      }\r\n\r\n      drawPolylineSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        'controlPointsConnectors',\r\n        controlPointsConnectors,\r\n        {\r\n          color: 'rgba(255, 255, 255, 0.5)',\r\n          lineWidth: 1,\r\n        }\r\n      );\r\n    }\r\n\r\n    this._renderStats(\r\n      annotation,\r\n      viewport,\r\n      svgDrawingHelper,\r\n      annotationStyle.textbox\r\n    );\r\n\r\n    if (this.fireChangeOnUpdate?.annotationUID === annotationUID) {\r\n      this.triggerChangeEvent(\r\n        annotation,\r\n        enabledElement,\r\n        this.fireChangeOnUpdate.changeType,\r\n        this.fireChangeOnUpdate.contourHoleProcessingEnabled\r\n      );\r\n      this.fireChangeOnUpdate = null;\r\n    }\r\n\r\n    annotation.invalidated = false;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Creates new interpolated handles for the spline control given the\r\n   * polyline data.  This allows creating the spline from polyline data\r\n   * directly.\r\n   */\r\n  protected createInterpolatedSplineControl(annotation) {\r\n    if (annotation.data.handles.points?.length) {\r\n      // The interpolation itself created the handles\r\n      return;\r\n    }\r\n    const { polyline } = annotation.data.contour;\r\n    if (!polyline || !polyline.length) {\r\n      return;\r\n    }\r\n    annotation.data.handles.points = [];\r\n    const { points } = annotation.data.handles;\r\n    const increment = Math.max(10, Math.floor(polyline.length / 20));\r\n    for (let i = 0; i < polyline.length - increment; i += increment) {\r\n      points.push(polyline[i]);\r\n    }\r\n    points.push(polyline[polyline.length - 1]);\r\n  }\r\n\r\n  protected createAnnotation(evt: EventTypes.InteractionEventType): Annotation {\r\n    const contourAnnotation = super.createAnnotation(evt);\r\n    const { world: worldPos } = evt.detail.currentPoints;\r\n    const { type: splineType } = this.configuration.spline;\r\n    const splineConfig = this._getSplineConfig(splineType);\r\n    const spline = new splineConfig.Class();\r\n    const createSpline = () => ({\r\n      type: splineConfig.type,\r\n      instance: spline,\r\n      resolution: splineConfig.resolution,\r\n    });\r\n\r\n    // Add an action to create a new spline data on creating an interpolated\r\n    // instance.\r\n    let onInterpolationComplete;\r\n    if (this.configuration.interpolation?.enabled) {\r\n      onInterpolationComplete = (annotation) => {\r\n        annotation.data.spline ||= createSpline();\r\n        this.createInterpolatedSplineControl(annotation);\r\n      };\r\n    }\r\n\r\n    return <SplineROIAnnotation>utilities.deepMerge(contourAnnotation, {\r\n      data: {\r\n        handles: {\r\n          points: [[...worldPos]],\r\n        },\r\n        spline: createSpline(),\r\n        cachedStats: {},\r\n      },\r\n      onInterpolationComplete,\r\n    });\r\n  }\r\n\r\n  private _renderStats = (\r\n    annotation,\r\n    viewport,\r\n    svgDrawingHelper,\r\n    textboxStyle\r\n  ) => {\r\n    const data = annotation.data;\r\n    const targetId = this.getTargetId(viewport);\r\n\r\n    if (!data.spline.instance.closed || !textboxStyle.visibility) {\r\n      return;\r\n    }\r\n\r\n    const textLines = this.configuration.getTextLines(data, targetId);\r\n    if (!textLines || textLines.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const canvasCoordinates = data.handles.points.map((p) =>\r\n      viewport.worldToCanvas(p)\r\n    );\r\n    if (!data.handles.textBox.hasMoved) {\r\n      const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\r\n\r\n      data.handles.textBox.worldPosition =\r\n        viewport.canvasToWorld(canvasTextBoxCoords);\r\n    }\r\n\r\n    const textBoxPosition = viewport.worldToCanvas(\r\n      data.handles.textBox.worldPosition\r\n    );\r\n\r\n    const textBoxUID = 'textBox';\r\n    const boundingBox = drawLinkedTextBoxSvg(\r\n      svgDrawingHelper,\r\n      annotation.annotationUID ?? '',\r\n      textBoxUID,\r\n      textLines,\r\n      textBoxPosition,\r\n      canvasCoordinates,\r\n      {},\r\n      textboxStyle\r\n    );\r\n\r\n    const { x: left, y: top, width, height } = boundingBox;\r\n\r\n    data.handles.textBox.worldBoundingBox = {\r\n      topLeft: viewport.canvasToWorld([left, top]),\r\n      topRight: viewport.canvasToWorld([left + width, top]),\r\n      bottomLeft: viewport.canvasToWorld([left, top + height]),\r\n      bottomRight: viewport.canvasToWorld([left + width, top + height]),\r\n    };\r\n  };\r\n\r\n  addControlPointCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: SplineROIAnnotation\r\n  ) => {\r\n    const { data } = annotation;\r\n    const splineType = data.spline.type;\r\n    const splineConfig = this._getSplineConfig(splineType);\r\n    const maxDist = splineConfig.controlPointAdditionDistance;\r\n\r\n    if (splineConfig.controlPointAdditionEnabled === false) {\r\n      return;\r\n    }\r\n\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine, viewport } = enabledElement;\r\n    const { canvasToWorld } = viewport;\r\n\r\n    const { instance: spline } = data.spline;\r\n    const canvasPos = evt.detail.currentPoints.canvas;\r\n    const closestPointInfo = spline.getClosestPoint(canvasPos);\r\n\r\n    if (closestPointInfo.distance > maxDist) {\r\n      return;\r\n    }\r\n\r\n    // Add a point at the `u` position from Parameter Space\r\n    const { index, point: canvasPoint } = spline.addControlPointAtU(\r\n      closestPointInfo.uValue\r\n    );\r\n\r\n    data.handles.points.splice(index, 0, canvasToWorld(canvasPoint));\r\n    annotation.invalidated = true;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  private _deleteControlPointByIndex(\r\n    element: HTMLDivElement,\r\n    annotation: SplineROIAnnotation,\r\n    controlPointIndex: number\r\n  ) {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { points: controlPoints } = annotation.data.handles;\r\n\r\n    // There is no curve with only 2 points\r\n    if (controlPoints.length === 3) {\r\n      removeAnnotation(annotation.annotationUID);\r\n    } else {\r\n      controlPoints.splice(controlPointIndex, 1);\r\n    }\r\n\r\n    const { renderingEngine } = enabledElement;\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    annotation.invalidated = true;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  }\r\n\r\n  deleteControlPointCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: SplineROIAnnotation\r\n  ) => {\r\n    const splineType = annotation.data.spline.type;\r\n    const splineConfig = this._getSplineConfig(splineType);\r\n    const maxDist = splineConfig.controlPointDeletionDistance;\r\n\r\n    if (splineConfig.controlPointDeletionEnabled === false) {\r\n      return;\r\n    }\r\n\r\n    const eventDetail = evt.detail;\r\n    const { element, currentPoints } = eventDetail;\r\n    const { canvas: canvasPos } = currentPoints;\r\n    const { instance: spline } = annotation.data.spline;\r\n    const closestControlPoint = spline.getClosestControlPointWithinDistance(\r\n      canvasPos,\r\n      maxDist\r\n    );\r\n\r\n    if (!closestControlPoint) {\r\n      return;\r\n    }\r\n\r\n    this._deleteControlPointByIndex(\r\n      element,\r\n      annotation,\r\n      closestControlPoint.index\r\n    );\r\n  };\r\n\r\n  _isSplineROIAnnotation(\r\n    annotation: Annotation\r\n  ): annotation is SplineROIAnnotation {\r\n    return !!(<SplineROIAnnotation>annotation).data?.spline;\r\n  }\r\n\r\n  /**\r\n   * Get a spline config merged with the default settings.\r\n   * @param type - Spline type (CARDINAL, CATMULLROM, LINEAR or BSPLINE)\r\n   * @returns Spline configuration\r\n   */\r\n  private _getSplineConfig(type: string) {\r\n    const { configuration: config } = this;\r\n    const splineConfigs = config.spline.configuration;\r\n\r\n    return Object.assign({ type }, DEFAULT_SPLINE_CONFIG, splineConfigs[type]);\r\n  }\r\n\r\n  private _updateSplineInstance(\r\n    element: HTMLDivElement,\r\n    annotation: SplineROIAnnotation\r\n  ): ISpline {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const { worldToCanvas } = viewport;\r\n    const { data } = annotation;\r\n    const { type: splineType, instance: spline } = annotation.data.spline;\r\n    const splineConfig = this._getSplineConfig(splineType);\r\n    const worldPoints = data.handles.points;\r\n    const canvasPoints = worldPoints.map(worldToCanvas);\r\n    const resolution =\r\n      splineConfig.resolution !== undefined\r\n        ? parseInt(splineConfig.resolution)\r\n        : undefined;\r\n    const scale =\r\n      splineConfig.scale !== undefined\r\n        ? parseFloat(splineConfig.scale)\r\n        : undefined;\r\n\r\n    spline.setControlPoints(canvasPoints);\r\n    spline.closed = !!data.contour.closed;\r\n\r\n    // Update spline resolution in case it has changed\r\n    if (\r\n      !spline.fixedResolution &&\r\n      resolution !== undefined &&\r\n      spline.resolution !== resolution\r\n    ) {\r\n      spline.resolution = resolution;\r\n      annotation.invalidated = true;\r\n    }\r\n\r\n    // Update Cardinal spline scale in case it has changed\r\n    if (\r\n      spline instanceof CardinalSpline &&\r\n      !spline.fixedScale &&\r\n      scale !== undefined &&\r\n      spline.scale !== scale\r\n    ) {\r\n      spline.scale = scale;\r\n      annotation.invalidated = true;\r\n    }\r\n\r\n    return spline;\r\n  }\r\n\r\n  private _calculateCachedStats = (\r\n    annotation: SplineROIAnnotation,\r\n    element: HTMLDivElement\r\n  ) => {\r\n    if (!this.configuration.calculateStats) {\r\n      return;\r\n    }\r\n    const data = annotation.data;\r\n\r\n    if (!data.contour.closed) {\r\n      return;\r\n    }\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n    const { cachedStats } = data;\r\n    const { polyline: points } = data.contour;\r\n    const targetIds = Object.keys(cachedStats);\r\n\r\n    for (let i = 0; i < targetIds.length; i++) {\r\n      const targetId = targetIds[i];\r\n      const image = this.getTargetIdImage(targetId, renderingEngine);\r\n\r\n      // If image does not exists for the targetId, skip. This can be due\r\n      // to various reasons such as if the target was a volumeViewport, and\r\n      // the volumeViewport has been decached in the meantime.\r\n      if (!image) {\r\n        continue;\r\n      }\r\n\r\n      const { metadata } = image;\r\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n      // Using an arbitrary start point (canvasPoint), calculate the\r\n      // mm spacing for the canvas in the X and Y directions.\r\n      const canvasPoint = canvasCoordinates[0];\r\n      const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\r\n      const deltaXPoint = viewport.canvasToWorld([\r\n        canvasPoint[0] + 1,\r\n        canvasPoint[1],\r\n      ]);\r\n      const deltaYPoint = viewport.canvasToWorld([\r\n        canvasPoint[0],\r\n        canvasPoint[1] + 1,\r\n      ]);\r\n\r\n      const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\r\n      const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\r\n\r\n      const { imageData } = image;\r\n      const { scale, areaUnits } = getCalibratedLengthUnitsAndScale(\r\n        image,\r\n        () => {\r\n          const {\r\n            maxX: canvasMaxX,\r\n            maxY: canvasMaxY,\r\n            minX: canvasMinX,\r\n            minY: canvasMinY,\r\n          } = math.polyline.getAABB(canvasCoordinates);\r\n\r\n          const topLeftBBWorld = viewport.canvasToWorld([\r\n            canvasMinX,\r\n            canvasMinY,\r\n          ]);\r\n\r\n          const topLeftBBIndex = utilities.transformWorldToIndex(\r\n            imageData,\r\n            topLeftBBWorld\r\n          );\r\n\r\n          const bottomRightBBWorld = viewport.canvasToWorld([\r\n            canvasMaxX,\r\n            canvasMaxY,\r\n          ]);\r\n\r\n          const bottomRightBBIndex = utilities.transformWorldToIndex(\r\n            imageData,\r\n            bottomRightBBWorld\r\n          );\r\n\r\n          return [topLeftBBIndex, bottomRightBBIndex];\r\n        }\r\n      );\r\n      let area = math.polyline.getArea(canvasCoordinates) / scale / scale;\r\n\r\n      // Convert from canvas_pixels ^2 to mm^2\r\n      area *= deltaInX * deltaInY;\r\n\r\n      cachedStats[targetId] = {\r\n        Modality: metadata.Modality,\r\n        area,\r\n        areaUnit: areaUnits,\r\n      };\r\n    }\r\n\r\n    this.triggerAnnotationModified(\r\n      annotation,\r\n      enabledElement,\r\n      ChangeTypes.StatsUpdated\r\n    );\r\n\r\n    return cachedStats;\r\n  };\r\n}\r\n\r\nfunction defaultGetTextLines(data, targetId): string[] {\r\n  const cachedVolumeStats = data.cachedStats[targetId];\r\n  const { area, isEmptyArea, areaUnit } = cachedVolumeStats;\r\n  const textLines: string[] = [];\r\n\r\n  if (area) {\r\n    const areaLine = isEmptyArea\r\n      ? `Area: Oblique not supported`\r\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\r\n\r\n    textLines.push(areaLine);\r\n  }\r\n\r\n  return textLines;\r\n}\r\n\r\nSplineROITool.toolName = 'SplineROI';\r\nexport default SplineROITool;\r\n","import { Events } from '../../enums';\r\nimport {\r\n  getEnabledElement,\r\n  utilities as csUtils,\r\n  StackViewport,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { AnnotationTool } from '../base';\r\nimport throttle from '../../utilities/throttle';\r\nimport {\r\n  addAnnotation,\r\n  getAnnotations,\r\n  removeAnnotation,\r\n} from '../../stateManagement/annotation/annotationState';\r\nimport {\r\n  triggerAnnotationCompleted,\r\n  triggerAnnotationModified,\r\n} from '../../stateManagement/annotation/helpers/state';\r\nimport { UltrasoundDirectionalAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\n\r\nimport {\r\n  drawHandle as drawHandleSvg,\r\n  drawLine as drawLineSvg,\r\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\r\n} from '../../drawingSvg';\r\nimport { state } from '../../store';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport { roundNumber } from '../../utilities';\r\nimport { distanceToPoint } from '../../utilities/math/point';\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\n\r\nimport {\r\n  resetElementCursor,\r\n  hideElementCursor,\r\n} from '../../cursors/elementCursor';\r\n\r\nimport {\r\n  EventTypes,\r\n  ToolHandle,\r\n  TextBoxHandle,\r\n  PublicToolProps,\r\n  ToolProps,\r\n  SVGDrawingHelper,\r\n  Annotation,\r\n  InteractionTypes,\r\n} from '../../types';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\nimport { getCalibratedProbeUnitsAndValue } from '../../utilities/getCalibratedUnits';\r\nconst { transformWorldToIndex } = csUtils;\r\n\r\n/**\r\n * The `UltrasoundDirectionalTool` class is a tool for creating directional ultrasound annotations.\r\n * It allows users to draw lines and measure distances between two points in the image.\r\n * It automatically calculates the distance based on the relevant unit of measurement.\r\n */\r\nclass UltrasoundDirectionalTool extends AnnotationTool {\r\n  static toolName;\r\n\r\n  public touchDragCallback: any;\r\n  public mouseDragCallback: any;\r\n  startedDrawing: boolean;\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: string[];\r\n    handleIndex?: number;\r\n    movingTextBox?: boolean;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        shadow: true,\r\n        preventHandleOutsideImage: false,\r\n        getTextLines: defaultGetTextLines,\r\n        /**\r\n         * Determines whether both horizontal and vertical distances should be displayed\r\n         * in the text lines when generating annotations' measurement information.\r\n         */\r\n        displayBothAxesDistances: false,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n\r\n    this._throttledCalculateCachedStats = throttle(\r\n      this._calculateCachedStats,\r\n      100,\r\n      { trailing: true }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the current imageId to create\r\n   * a Ultrasound Directional Tool and store it in the annotationManager\r\n   *\r\n   * @param evt -  EventTypes.InteractionEventType\r\n   * @returns The annotation object.\r\n   */\r\n  addNewAnnotation = (\r\n    evt: EventTypes.InteractionEventType\r\n  ): UltrasoundDirectionalAnnotation => {\r\n    if (this.startedDrawing) {\r\n      return;\r\n    }\r\n\r\n    this.startedDrawing = true;\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n\r\n    const worldPos = currentPoints.world;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    if (!(viewport instanceof StackViewport)) {\r\n      throw new Error(\r\n        'UltrasoundDirectionalTool can only be used on a StackViewport'\r\n      );\r\n    }\r\n\r\n    hideElementCursor(element);\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    const referencedImageId = this.getReferencedImageId(\r\n      viewport,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      viewUp\r\n    );\r\n\r\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n\r\n    const annotation = {\r\n      highlighted: true,\r\n      invalidated: true,\r\n      metadata: {\r\n        toolName: this.getToolName(),\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID,\r\n        referencedImageId,\r\n      },\r\n      data: {\r\n        handles: {\r\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\r\n          activeHandleIndex: null,\r\n          textBox: {\r\n            hasMoved: false,\r\n            worldPosition: <Types.Point3>[0, 0, 0],\r\n            worldBoundingBox: {\r\n              topLeft: <Types.Point3>[0, 0, 0],\r\n              topRight: <Types.Point3>[0, 0, 0],\r\n              bottomLeft: <Types.Point3>[0, 0, 0],\r\n              bottomRight: <Types.Point3>[0, 0, 0],\r\n            },\r\n          },\r\n        },\r\n        label: '',\r\n        cachedStats: {},\r\n      },\r\n    };\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex: 1,\r\n      movingTextBox: false,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n    };\r\n    this._activateDraw(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  };\r\n\r\n  /**\r\n   * It returns if the canvas point is near the provided length annotation in the provided\r\n   * element or not. A proximity is passed to the function to determine the\r\n   * proximity of the point to the annotation in number of pixels.\r\n   *\r\n   * @param element - HTML Element\r\n   * @param annotation - Annotation\r\n   * @param canvasCoords - Canvas coordinates\r\n   * @param proximity - Proximity to tool to consider\r\n   * @returns Boolean, whether the canvas point is near tool\r\n   */\r\n  isPointNearTool = (\r\n    element: HTMLDivElement,\r\n    annotation: UltrasoundDirectionalAnnotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): boolean => {\r\n    return false;\r\n  };\r\n\r\n  toolSelectedCallback(\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: Annotation,\r\n    interactionType: InteractionTypes,\r\n    canvasCoords?: Types.Point2\r\n  ): void {\r\n    return;\r\n  }\r\n\r\n  handleSelectedCallback(\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: UltrasoundDirectionalAnnotation,\r\n    handle: ToolHandle\r\n  ): void {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const { data } = annotation;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    let movingTextBox = false;\r\n    let handleIndex;\r\n    if ((handle as TextBoxHandle).worldPosition) {\r\n      movingTextBox = true;\r\n    } else {\r\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\r\n    }\r\n\r\n    // Find viewports to render on drag.\r\n\r\n    this.editData = {\r\n      handleIndex,\r\n      annotation,\r\n      viewportIdsToRender,\r\n    };\r\n    this._activateModify(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  }\r\n\r\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\r\n      this.editData;\r\n\r\n    const { data } = annotation;\r\n    if (newAnnotation && !hasMoved) {\r\n      // when user starts the drawing by click, and moving the mouse, instead\r\n      // of click and drag\r\n      return;\r\n    }\r\n\r\n    // If preventing new measurement means we are in the middle of an existing measurement\r\n    // we shouldn't deactivate modify or draw\r\n    if (this.startedDrawing && data.handles.points.length === 1) {\r\n      // adds the last point to the measurement\r\n      this.editData.handleIndex = 1;\r\n      return;\r\n    }\r\n\r\n    this.startedDrawing = false;\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateModify(element);\r\n    this._deactivateDraw(element);\r\n    resetElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    if (\r\n      this.isHandleOutsideImage &&\r\n      this.configuration.preventHandleOutsideImage\r\n    ) {\r\n      removeAnnotation(annotation.annotationUID);\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    if (newAnnotation) {\r\n      triggerAnnotationCompleted(annotation);\r\n    }\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n  };\r\n\r\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    this.isDrawing = true;\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (movingTextBox) {\r\n      // Drag mode - moving text box\r\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n\r\n      const { textBox } = data.handles;\r\n      const { worldPosition } = textBox;\r\n\r\n      worldPosition[0] += worldPosDelta[0];\r\n      worldPosition[1] += worldPosDelta[1];\r\n      worldPosition[2] += worldPosDelta[2];\r\n\r\n      textBox.hasMoved = true;\r\n    } else if (handleIndex === undefined) {\r\n      // Drag mode - moving handle\r\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n\r\n      const points = data.handles.points;\r\n\r\n      points.forEach((point) => {\r\n        point[0] += worldPosDelta[0];\r\n        point[1] += worldPosDelta[1];\r\n        point[2] += worldPosDelta[2];\r\n      });\r\n      annotation.invalidated = true;\r\n    } else {\r\n      // Move mode - after double click, and mouse move to draw\r\n      const { currentPoints } = eventDetail;\r\n      const worldPos = currentPoints.world;\r\n\r\n      data.handles.points[handleIndex] = [...worldPos];\r\n      annotation.invalidated = true;\r\n    }\r\n\r\n    this.editData.hasMoved = true;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  cancel = (element: HTMLDivElement) => {\r\n    // If it is mid-draw or mid-modify\r\n    if (this.isDrawing) {\r\n      this.isDrawing = false;\r\n      this._deactivateDraw(element);\r\n      this._deactivateModify(element);\r\n      resetElementCursor(element);\r\n\r\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\r\n      const { data } = annotation;\r\n\r\n      annotation.highlighted = false;\r\n      data.handles.activeHandleIndex = null;\r\n\r\n      const enabledElement = getEnabledElement(element);\r\n      const { renderingEngine } = enabledElement;\r\n\r\n      triggerAnnotationRenderForViewportIds(\r\n        renderingEngine,\r\n        viewportIdsToRender\r\n      );\r\n\r\n      if (newAnnotation) {\r\n        triggerAnnotationCompleted(annotation);\r\n      }\r\n\r\n      this.editData = null;\r\n      this.startedDrawing = false;\r\n      return annotation.annotationUID;\r\n    }\r\n  };\r\n\r\n  _activateModify = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(\r\n      Events.MOUSE_UP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._endCallback as EventListener\r\n    );\r\n\r\n    element.addEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _deactivateModify = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(\r\n      Events.MOUSE_UP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _activateDraw = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(\r\n      Events.MOUSE_UP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_MOVE,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._endCallback as EventListener\r\n    );\r\n\r\n    element.addEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _deactivateDraw = (element: HTMLDivElement) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(\r\n      Events.MOUSE_UP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_MOVE,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._endCallback as EventListener\r\n    );\r\n\r\n    element.removeEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the length annotation in each\r\n   * request animation frame. It calculates the updated cached statistics if\r\n   * data is invalidated and cache it.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n\r\n    let annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    annotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    );\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const targetId = this.getTargetId(viewport);\r\n    const renderingEngine = viewport.getRenderingEngine();\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    // Draw SVG\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[i] as UltrasoundDirectionalAnnotation;\r\n      const { annotationUID, data } = annotation;\r\n      const { points } = data.handles;\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const color = this.getStyle('color', styleSpecifier, annotation);\r\n\r\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\r\n      if (\r\n        !data.cachedStats[targetId] ||\r\n        data.cachedStats[targetId].xValues == null\r\n      ) {\r\n        data.cachedStats[targetId] = {\r\n          xValues: [0, 0],\r\n          yValues: [0, 0],\r\n          isHorizontal: false,\r\n          units: [''],\r\n          isUnitless: false,\r\n        };\r\n\r\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\r\n      } else if (annotation.invalidated) {\r\n        this._throttledCalculateCachedStats(\r\n          annotation,\r\n          renderingEngine,\r\n          enabledElement\r\n        );\r\n      }\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n\r\n      // draw first point\r\n      let handleGroupUID = '0';\r\n      drawHandleSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        handleGroupUID,\r\n        canvasCoordinates[0],\r\n        {\r\n          color,\r\n        },\r\n        0\r\n      );\r\n\r\n      renderStatus = true;\r\n\r\n      if (canvasCoordinates.length !== 2) {\r\n        return renderStatus;\r\n      }\r\n\r\n      handleGroupUID = '1';\r\n      drawHandleSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        handleGroupUID,\r\n        canvasCoordinates[1],\r\n        {\r\n          color,\r\n        },\r\n        1\r\n      );\r\n\r\n      const isUnitless = data.cachedStats[targetId].isUnitless;\r\n\r\n      if (!isUnitless) {\r\n        const canvasPoint1 = canvasCoordinates[0];\r\n        const canvasPoint2 = canvasCoordinates[1];\r\n\r\n        const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];\r\n        const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];\r\n\r\n        const isHorizontal = data.cachedStats[targetId].isHorizontal;\r\n\r\n        // then for the third point we need to go from first point towards\r\n        // the second point (it can be left or right in the horizontal orientation)\r\n        // or up or down in the vertical orientation, and only add\r\n        // the delta y to the x or y coordinate of the first point\r\n        let projectedPointCanvas = [0, 0] as Types.Point2;\r\n        if (isHorizontal) {\r\n          projectedPointCanvas = [\r\n            canvasPoint1[0] + canvasDeltaX,\r\n            canvasPoint1[1],\r\n          ];\r\n        } else {\r\n          projectedPointCanvas = [\r\n            canvasPoint1[0],\r\n            canvasPoint1[1] + canvasDeltaY,\r\n          ];\r\n        }\r\n\r\n        // create a line from the first point to the third point\r\n        let dataId = `${annotationUID}-line-1`;\r\n        let lineUID = '1';\r\n        drawLineSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          lineUID,\r\n          canvasCoordinates[0],\r\n          projectedPointCanvas,\r\n          {\r\n            color,\r\n            width: 1,\r\n            shadow: this.configuration.shadow,\r\n          },\r\n          dataId\r\n        );\r\n\r\n        // draw another line from first point to the projected one\r\n        dataId = `${annotationUID}-line-2`;\r\n        lineUID = '2';\r\n\r\n        drawLineSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          lineUID,\r\n          canvasCoordinates[1],\r\n          projectedPointCanvas,\r\n          {\r\n            color,\r\n            width: 1,\r\n            lineDash: [1, 1],\r\n            shadow: this.configuration.shadow,\r\n          },\r\n          dataId\r\n        );\r\n      } else {\r\n        // draw straight line between the two points\r\n        const dataId = `${annotationUID}-line-1`;\r\n        const lineUID = '1';\r\n        drawLineSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          lineUID,\r\n          canvasCoordinates[0],\r\n          canvasCoordinates[1],\r\n          {\r\n            color,\r\n            width: 1,\r\n            shadow: this.configuration.shadow,\r\n          },\r\n          dataId\r\n        );\r\n      }\r\n\r\n      // draw another line from first point to the\r\n\r\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\r\n      if (!options.visibility) {\r\n        data.handles.textBox = {\r\n          hasMoved: false,\r\n          worldPosition: <Types.Point3>[0, 0, 0],\r\n          worldBoundingBox: {\r\n            topLeft: <Types.Point3>[0, 0, 0],\r\n            topRight: <Types.Point3>[0, 0, 0],\r\n            bottomLeft: <Types.Point3>[0, 0, 0],\r\n            bottomRight: <Types.Point3>[0, 0, 0],\r\n          },\r\n        };\r\n        continue;\r\n      }\r\n\r\n      const textLines = this.configuration.getTextLines(\r\n        data,\r\n        targetId,\r\n        this.configuration\r\n      );\r\n\r\n      if (!data.handles.textBox.hasMoved) {\r\n        // linked to the vertex by default\r\n        const canvasTextBoxCoords = canvasCoordinates[1];\r\n\r\n        data.handles.textBox.worldPosition =\r\n          viewport.canvasToWorld(canvasTextBoxCoords);\r\n      }\r\n\r\n      const textBoxPosition = viewport.worldToCanvas(\r\n        data.handles.textBox.worldPosition\r\n      );\r\n\r\n      const textBoxUID = '1';\r\n      const boundingBox = drawLinkedTextBoxSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        textBoxUID,\r\n        textLines,\r\n        textBoxPosition,\r\n        canvasCoordinates,\r\n        {},\r\n        options\r\n      );\r\n\r\n      const { x: left, y: top, width, height } = boundingBox;\r\n\r\n      data.handles.textBox.worldBoundingBox = {\r\n        topLeft: viewport.canvasToWorld([left, top]),\r\n        topRight: viewport.canvasToWorld([left + width, top]),\r\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\r\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\r\n      };\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\r\n    const data = annotation.data;\r\n    const { element } = enabledElement.viewport;\r\n\r\n    // Until we have all two anchors bail out\r\n    if (data.handles.points.length !== 2) {\r\n      return;\r\n    }\r\n\r\n    const { cachedStats } = data;\r\n    const targetIds = Object.keys(cachedStats);\r\n\r\n    for (let i = 0; i < targetIds.length; i++) {\r\n      const targetId = targetIds[i];\r\n\r\n      const image = this.getTargetIdImage(targetId, renderingEngine);\r\n\r\n      // If image does not exists for the targetId, skip. This can be due\r\n      // to various reasons such as if the target was a volumeViewport, and\r\n      // the volumeViewport has been decached in the meantime.\r\n      if (!image) {\r\n        continue;\r\n      }\r\n\r\n      const { imageData } = image;\r\n\r\n      const worldPos1 = data.handles.points[0];\r\n      const worldPos2 = data.handles.points[1];\r\n\r\n      const imageIndex1 = transformWorldToIndex(imageData, worldPos1);\r\n      const imageIndex2 = transformWorldToIndex(imageData, worldPos2);\r\n\r\n      const { values: values1, units: units1 } =\r\n        getCalibratedProbeUnitsAndValue(image, [imageIndex1]);\r\n      const { values: values2, units: units2 } =\r\n        getCalibratedProbeUnitsAndValue(image, [imageIndex2]);\r\n\r\n      let xValues, yValues, units, isHorizontal;\r\n      let isUnitless = false;\r\n      if (\r\n        units1[0] !== units2[0] ||\r\n        units1[1] !== units2[1] ||\r\n        (units1[0] === 'raw' && units2[0] === 'raw')\r\n      ) {\r\n        // if units are not the same, we cannot calculate the diff\r\n        // so we just report the px distance\r\n        const value = distanceToPoint(worldPos1, worldPos2);\r\n\r\n        xValues = [value, 0];\r\n        yValues = [value, 0];\r\n        units = ['px'];\r\n        isUnitless = true;\r\n      } else {\r\n        const canvasPoint1 = enabledElement.viewport.worldToCanvas(worldPos1);\r\n        const canvasPoint2 = enabledElement.viewport.worldToCanvas(worldPos2);\r\n\r\n        const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];\r\n        const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];\r\n\r\n        isHorizontal = Math.abs(canvasDeltaX) > Math.abs(canvasDeltaY);\r\n        xValues = [values1[0], values2[0]];\r\n        yValues = [values1[1], values2[1]];\r\n\r\n        units = [units1[0], units1[1]];\r\n      }\r\n\r\n      cachedStats[targetId] = {\r\n        xValues,\r\n        yValues,\r\n        isHorizontal,\r\n        units,\r\n        isUnitless,\r\n      };\r\n    }\r\n\r\n    annotation.invalidated = false;\r\n\r\n    // Dispatching annotation modified\r\n    triggerAnnotationModified(annotation, element);\r\n\r\n    return cachedStats;\r\n  }\r\n}\r\n\r\nfunction defaultGetTextLines(data, targetId, configuration): string[] {\r\n  const cachedStats = data.cachedStats[targetId];\r\n  const { xValues, yValues, units, isUnitless, isHorizontal } = cachedStats;\r\n\r\n  if (isUnitless) {\r\n    return [`${roundNumber(xValues[0])} px`];\r\n  }\r\n\r\n  if (configuration.displayBothAxesDistances) {\r\n    const dist1 = Math.abs(xValues[1] - xValues[0]);\r\n    const dist2 = Math.abs(yValues[1] - yValues[0]);\r\n    return [\r\n      `${roundNumber(dist1)} ${units[0]}`,\r\n      `${roundNumber(dist2)} ${units[1]}`,\r\n    ];\r\n  }\r\n\r\n  if (isHorizontal) {\r\n    const dist = Math.abs(xValues[1] - xValues[0]);\r\n    return [`${roundNumber(dist)} ${units[0]}`];\r\n  } else {\r\n    const dist = Math.abs(yValues[1] - yValues[0]);\r\n    return [`${roundNumber(dist)} ${units[1]}`];\r\n  }\r\n}\r\n\r\nUltrasoundDirectionalTool.toolName = 'UltrasoundDirectionalTool';\r\nexport default UltrasoundDirectionalTool;\r\n","import { vec3, vec2 } from 'gl-matrix';\r\n\r\nimport {\r\n  getEnabledElement,\r\n  triggerEvent,\r\n  eventTarget,\r\n  utilities as csUtils,\r\n  cache,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport { AnnotationTool } from '../base';\r\n\r\nimport throttle from '../../utilities/throttle';\r\nimport {\r\n  addAnnotation,\r\n  getAnnotations,\r\n  removeAnnotation,\r\n} from '../../stateManagement';\r\nimport {\r\n  drawHandles as drawHandlesSvg,\r\n  drawRedactionRect as drawRedactionRectSvg,\r\n} from '../../drawingSvg';\r\nimport { state } from '../../store';\r\nimport { Events } from '../../enums';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport * as rectangle from '../../utilities/math/rectangle';\r\nimport {\r\n  resetElementCursor,\r\n  hideElementCursor,\r\n} from '../../cursors/elementCursor';\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\n\r\nimport { EventTypes, SVGDrawingHelper } from '../../types';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\r\nimport { VideoRedactionAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\n\r\nclass VideoRedactionTool extends AnnotationTool {\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportUIDsToRender: string[];\r\n    handleIndex?: number;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n  } | null;\r\n  _configuration: any;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n\r\n  constructor(toolConfiguration = {}) {\r\n    super(toolConfiguration, {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: { shadow: true, preventHandleOutsideImage: false },\r\n    });\r\n\r\n    this._throttledCalculateCachedStats = throttle(\r\n      this._calculateCachedStats,\r\n      100,\r\n      { trailing: true }\r\n    );\r\n  }\r\n\r\n  addNewAnnotation = (\r\n    evt: EventTypes.InteractionEventType\r\n  ): VideoRedactionAnnotation => {\r\n    const eventData = evt.detail;\r\n    const { currentPoints, element } = eventData;\r\n    const worldPos = currentPoints.world;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n    const referencedImageId = this.getReferencedImageId(\r\n      viewport,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      viewUp\r\n    );\r\n\r\n    const annotation = {\r\n      metadata: {\r\n        // We probably just want a different type of data here, hacking this\r\n        // together for now.\r\n        viewPlaneNormal: <Types.Point3>[0, 0, 1],\r\n        viewUp: <Types.Point3>[0, 1, 0],\r\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\r\n        referencedImageId,\r\n        toolName: this.getToolName(),\r\n      },\r\n      data: {\r\n        invalidated: true,\r\n        handles: {\r\n          points: [\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n          ],\r\n          activeHandleIndex: null,\r\n        },\r\n        cachedStats: {},\r\n        active: true,\r\n      },\r\n    };\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportUIDsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName(),\r\n      false\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportUIDsToRender,\r\n      handleIndex: 3,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n    };\r\n    this._activateDraw(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(\r\n      renderingEngine,\r\n      viewportUIDsToRender\r\n    );\r\n\r\n    return annotation;\r\n  };\r\n\r\n  getHandleNearImagePoint = (element, annotation, canvasCoords, proximity) => {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    const { data } = annotation;\r\n    const { points } = data.handles;\r\n\r\n    for (let i = 0; i < points.length; i++) {\r\n      const point = points[i];\r\n      const toolDataCanvasCoordinate = viewport.worldToCanvas(point);\r\n\r\n      const near =\r\n        vec2.distance(canvasCoords, <vec2>toolDataCanvasCoordinate) < proximity;\r\n\r\n      if (near === true) {\r\n        data.handles.activeHandleIndex = i;\r\n        return point;\r\n      }\r\n    }\r\n\r\n    data.handles.activeHandleIndex = null;\r\n  };\r\n\r\n  isPointNearTool = (element, annotation, canvasCoords, proximity) => {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    const { data } = annotation;\r\n    const { points } = data.handles;\r\n\r\n    const canvasPoint1 = viewport.worldToCanvas(points[0]);\r\n    const canvasPoint2 = viewport.worldToCanvas(points[3]);\r\n\r\n    const rect = this._getRectangleImageCoordinates([\r\n      canvasPoint1,\r\n      canvasPoint2,\r\n    ]);\r\n\r\n    const point = [canvasCoords[0], canvasCoords[1]] as Types.Point2;\r\n    const { left, top, width, height } = rect;\r\n\r\n    const distanceToPoint = rectangle.distanceToPoint(\r\n      [left, top, width, height],\r\n      point\r\n    );\r\n\r\n    if (distanceToPoint <= proximity) {\r\n      return true;\r\n    }\r\n  };\r\n\r\n  toolSelectedCallback = (evt, annotation, interactionType = 'mouse') => {\r\n    const eventData = evt.detail;\r\n    const { element } = eventData;\r\n\r\n    const { data } = annotation;\r\n\r\n    data.active = true;\r\n\r\n    const viewportUIDsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName(),\r\n      false\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportUIDsToRender,\r\n    };\r\n\r\n    this._activateModify(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(\r\n      renderingEngine,\r\n      viewportUIDsToRender\r\n    );\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  handleSelectedCallback = (\r\n    evt,\r\n    annotation,\r\n    handle,\r\n    interactionType = 'mouse'\r\n  ) => {\r\n    const eventData = evt.detail;\r\n    const { element } = eventData;\r\n    const { data } = annotation;\r\n\r\n    data.active = true;\r\n\r\n    let movingTextBox = false;\r\n    let handleIndex;\r\n\r\n    if (handle.worldPosition) {\r\n      movingTextBox = true;\r\n    } else {\r\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\r\n    }\r\n\r\n    // Find viewports to render on drag.\r\n    const viewportUIDsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName(),\r\n      false\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportUIDsToRender,\r\n      handleIndex,\r\n    };\r\n    this._activateModify(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(\r\n      renderingEngine,\r\n      viewportUIDsToRender\r\n    );\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  _mouseUpCallback = (evt) => {\r\n    const eventData = evt.detail;\r\n    const { element } = eventData;\r\n\r\n    const { annotation, viewportUIDsToRender, newAnnotation, hasMoved } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (newAnnotation && !hasMoved) {\r\n      return;\r\n    }\r\n\r\n    data.active = false;\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateModify(element);\r\n    this._deactivateDraw(element);\r\n\r\n    resetElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n\r\n    if (\r\n      this.isHandleOutsideImage &&\r\n      this.configuration.preventHandleOutsideImage\r\n    ) {\r\n      removeAnnotation(annotation.annotationUID);\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(\r\n      renderingEngine,\r\n      viewportUIDsToRender\r\n    );\r\n  };\r\n\r\n  _mouseDragCallback = (evt) => {\r\n    this.isDrawing = true;\r\n\r\n    const eventData = evt.detail;\r\n    const { element } = eventData;\r\n\r\n    const { annotation, viewportUIDsToRender, handleIndex } = this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (handleIndex === undefined) {\r\n      // Moving tool, so move all points by the world points delta\r\n      const { deltaPoints } = eventData;\r\n      const worldPosDelta = deltaPoints.world;\r\n\r\n      const { points } = data.handles;\r\n\r\n      points.forEach((point) => {\r\n        point[0] += worldPosDelta[0];\r\n        point[1] += worldPosDelta[1];\r\n        point[2] += worldPosDelta[2];\r\n      });\r\n      data.invalidated = true;\r\n    } else {\r\n      // Moving handle.\r\n      const { currentPoints } = eventData;\r\n      const enabledElement = getEnabledElement(element);\r\n      const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\r\n      const worldPos = currentPoints.world;\r\n\r\n      const { points } = data.handles;\r\n\r\n      // Move this handle.\r\n      points[handleIndex] = [...worldPos];\r\n\r\n      let bottomLeftCanvas;\r\n      let bottomRightCanvas;\r\n      let topLeftCanvas;\r\n      let topRightCanvas;\r\n\r\n      let bottomLeftWorld;\r\n      let bottomRightWorld;\r\n      let topLeftWorld;\r\n      let topRightWorld;\r\n\r\n      switch (handleIndex) {\r\n        case 0:\r\n        case 3:\r\n          // Moving bottomLeft or topRight\r\n\r\n          bottomLeftCanvas = worldToCanvas(points[0]);\r\n          topRightCanvas = worldToCanvas(points[3]);\r\n\r\n          bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\r\n          topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\r\n\r\n          bottomRightWorld = canvasToWorld(bottomRightCanvas);\r\n          topLeftWorld = canvasToWorld(topLeftCanvas);\r\n\r\n          points[1] = bottomRightWorld;\r\n          points[2] = topLeftWorld;\r\n\r\n          break;\r\n        case 1:\r\n        case 2:\r\n          // Moving bottomRight or topLeft\r\n          bottomRightCanvas = worldToCanvas(points[1]);\r\n          topLeftCanvas = worldToCanvas(points[2]);\r\n\r\n          bottomLeftCanvas = <Types.Point2>[\r\n            topLeftCanvas[0],\r\n            bottomRightCanvas[1],\r\n          ];\r\n          topRightCanvas = <Types.Point2>[\r\n            bottomRightCanvas[0],\r\n            topLeftCanvas[1],\r\n          ];\r\n\r\n          bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\r\n          topRightWorld = canvasToWorld(topRightCanvas);\r\n\r\n          points[0] = bottomLeftWorld;\r\n          points[3] = topRightWorld;\r\n\r\n          break;\r\n      }\r\n      data.invalidated = true;\r\n    }\r\n\r\n    this.editData.hasMoved = true;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(\r\n      renderingEngine,\r\n      viewportUIDsToRender\r\n    );\r\n  };\r\n\r\n  cancel(element) {\r\n    // If it is mid-draw or mid-modify\r\n    if (!this.isDrawing) {\r\n      return;\r\n    }\r\n    this.isDrawing = false;\r\n    this._deactivateDraw(element);\r\n    this._deactivateModify(element);\r\n    resetElementCursor(element);\r\n\r\n    const { annotation, viewportUIDsToRender } = this.editData;\r\n\r\n    const { data } = annotation;\r\n\r\n    data.active = false;\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(\r\n      renderingEngine,\r\n      viewportUIDsToRender\r\n    );\r\n\r\n    this.editData = null;\r\n    return annotation.metadata.annotationUID;\r\n  }\r\n  /**\r\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\r\n   */\r\n  _activateDraw = (element) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(Events.MOUSE_UP, this._mouseUpCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\r\n    element.addEventListener(Events.MOUSE_MOVE, this._mouseDragCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\r\n\r\n    element.addEventListener(Events.TOUCH_END, this._mouseUpCallback);\r\n    element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\r\n  };\r\n\r\n  /**\r\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\r\n   */\r\n  _deactivateDraw = (element) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(Events.MOUSE_UP, this._mouseUpCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\r\n    element.removeEventListener(Events.MOUSE_MOVE, this._mouseDragCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\r\n\r\n    element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback);\r\n    element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\r\n  };\r\n\r\n  /**\r\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\r\n   */\r\n  _activateModify = (element) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(Events.MOUSE_UP, this._mouseUpCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\r\n\r\n    element.addEventListener(Events.TOUCH_END, this._mouseUpCallback);\r\n    element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\r\n  };\r\n\r\n  /**\r\n   * Remove event handlers for the modify event loop, and enable default event propagation.\r\n   */\r\n  _deactivateModify = (element) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(Events.MOUSE_UP, this._mouseUpCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\r\n\r\n    element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback);\r\n    element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\r\n  };\r\n\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    const renderStatus = false;\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n\r\n    let annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    annotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    );\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const targetId = this.getTargetId(viewport);\r\n    const renderingEngine = viewport.getRenderingEngine();\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[i];\r\n      const { annotationUID } = annotation;\r\n      const toolMetadata = annotation.metadata;\r\n\r\n      const data = annotation.data;\r\n      const { points, activeHandleIndex } = data.handles;\r\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\r\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\r\n      const color = this.getStyle('color', styleSpecifier, annotation);\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return;\r\n      }\r\n\r\n      let activeHandleCanvasCoords;\r\n\r\n      if (\r\n        // !isToolDataLocked(toolData) &&\r\n        !this.editData &&\r\n        activeHandleIndex !== null\r\n      ) {\r\n        // Not locked or creating and hovering over handle, so render handle.\r\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\r\n      }\r\n\r\n      if (activeHandleCanvasCoords) {\r\n        const handleGroupUID = '0';\r\n\r\n        drawHandlesSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          handleGroupUID,\r\n          activeHandleCanvasCoords,\r\n          {\r\n            color,\r\n          }\r\n        );\r\n      }\r\n\r\n      const rectangleUID = '0';\r\n      drawRedactionRectSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        rectangleUID,\r\n        canvasCoordinates[0],\r\n        canvasCoordinates[3],\r\n        {\r\n          color: 'black',\r\n          lineDash,\r\n          lineWidth,\r\n        }\r\n      );\r\n    }\r\n  };\r\n\r\n  _getRectangleImageCoordinates = (\r\n    points: Array<Types.Point2>\r\n  ): {\r\n    left: number;\r\n    top: number;\r\n    width: number;\r\n    height: number;\r\n  } => {\r\n    const [point0, point1] = points;\r\n\r\n    return {\r\n      left: Math.min(point0[0], point1[0]),\r\n      top: Math.min(point0[1], point1[1]),\r\n      width: Math.abs(point0[0] - point1[0]),\r\n      height: Math.abs(point0[1] - point1[1]),\r\n    };\r\n  };\r\n\r\n  _getImageVolumeFromTargetUID(targetUID, renderingEngine) {\r\n    let imageVolume, viewport;\r\n    if (targetUID.startsWith('stackTarget')) {\r\n      const coloneIndex = targetUID.indexOf(':');\r\n      const viewportUID = targetUID.substring(coloneIndex + 1);\r\n      const viewport = renderingEngine.getViewport(viewportUID);\r\n      imageVolume = viewport.getImageData();\r\n    } else {\r\n      imageVolume = cache.getVolume(targetUID);\r\n    }\r\n\r\n    return { imageVolume, viewport };\r\n  }\r\n\r\n  /**\r\n   * _calculateCachedStats - For each volume in the frame of reference that a\r\n   * tool instance in particular viewport defines as its target volume, find the\r\n   * volume coordinates (i,j,k) being probed by the two corners. One of i,j or k\r\n   * will be constant across the two points. In the other two directions iterate\r\n   * over the voxels and calculate the first and second-order statistics.\r\n   *\r\n   * @param {object} data - The toolData tool-specific data.\r\n   * @param {Array<number>} viewPlaneNormal The normal vector of the camera.\r\n   * @param {Array<number>} viewUp The viewUp vector of the camera.\r\n   */\r\n  _calculateCachedStats = (\r\n    annotation,\r\n    viewPlaneNormal,\r\n    viewUp,\r\n    renderingEngine,\r\n    enabledElement\r\n  ) => {\r\n    const { data } = annotation;\r\n    const { viewportUID, renderingEngineUID, sceneUID } = enabledElement;\r\n\r\n    const worldPos1 = data.handles.points[0];\r\n    const worldPos2 = data.handles.points[3];\r\n    const { cachedStats } = data;\r\n\r\n    const targetUIDs = Object.keys(cachedStats);\r\n\r\n    for (let i = 0; i < targetUIDs.length; i++) {\r\n      const targetUID = targetUIDs[i];\r\n\r\n      const { imageVolume } = this._getImageVolumeFromTargetUID(\r\n        targetUID,\r\n        renderingEngine\r\n      );\r\n\r\n      const {\r\n        dimensions,\r\n        scalarData,\r\n        vtkImageData: imageData,\r\n        metadata,\r\n      } = imageVolume;\r\n      const worldPos1Index = vec3.fromValues(0, 0, 0);\r\n      const worldPos2Index = vec3.fromValues(0, 0, 0);\r\n\r\n      imageData.worldToIndexVec3(worldPos1, worldPos1Index);\r\n\r\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\r\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\r\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\r\n\r\n      imageData.worldToIndexVec3(worldPos2, worldPos2Index);\r\n\r\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\r\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\r\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\r\n\r\n      // Check if one of the indexes are inside the volume, this then gives us\r\n      // Some area to do stats over.\r\n\r\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\r\n        this.isHandleOutsideImage = false;\r\n\r\n        // Calculate index bounds to iterate over\r\n\r\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\r\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\r\n\r\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\r\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\r\n\r\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\r\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\r\n\r\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\r\n          viewPlaneNormal,\r\n          viewUp,\r\n          worldPos1,\r\n          worldPos2\r\n        );\r\n\r\n        const area = worldWidth * worldHeight;\r\n\r\n        let count = 0;\r\n        let mean = 0;\r\n        let stdDev = 0;\r\n\r\n        const yMultiple = dimensions[0];\r\n        const zMultiple = dimensions[0] * dimensions[1];\r\n\r\n        // This is a triple loop, but one of these 3 values will be constant\r\n        // In the planar view.\r\n        for (let k = kMin; k <= kMax; k++) {\r\n          for (let j = jMin; j <= jMax; j++) {\r\n            for (let i = iMin; i <= iMax; i++) {\r\n              const value = scalarData[k * zMultiple + j * yMultiple + i];\r\n\r\n              count++;\r\n              mean += value;\r\n            }\r\n          }\r\n        }\r\n\r\n        mean /= count;\r\n\r\n        for (let k = kMin; k <= kMax; k++) {\r\n          for (let j = jMin; j <= jMax; j++) {\r\n            for (let i = iMin; i <= iMax; i++) {\r\n              const value = scalarData[k * zMultiple + j * yMultiple + i];\r\n\r\n              const valueMinusMean = value - mean;\r\n\r\n              stdDev += valueMinusMean * valueMinusMean;\r\n            }\r\n          }\r\n        }\r\n\r\n        stdDev /= count;\r\n        stdDev = Math.sqrt(stdDev);\r\n\r\n        cachedStats[targetUID] = {\r\n          Modality: metadata.Modality,\r\n          area,\r\n          mean,\r\n          stdDev,\r\n        };\r\n      } else {\r\n        this.isHandleOutsideImage = true;\r\n        cachedStats[targetUID] = {\r\n          Modality: metadata.Modality,\r\n        };\r\n      }\r\n    }\r\n\r\n    data.invalidated = false;\r\n\r\n    // Dispatching measurement modified\r\n    const eventType = Events.ANNOTATION_MODIFIED;\r\n\r\n    const eventDetail = {\r\n      annotation,\r\n      viewportUID,\r\n      renderingEngineUID,\r\n      sceneUID: sceneUID,\r\n    };\r\n    triggerEvent(eventTarget, eventType, eventDetail);\r\n\r\n    return cachedStats;\r\n  };\r\n\r\n  _isInsideVolume = (index1, index2, dimensions) => {\r\n    return (\r\n      csUtils.indexWithinDimensions(index1, dimensions) &&\r\n      csUtils.indexWithinDimensions(index2, dimensions)\r\n    );\r\n  };\r\n\r\n  _getTargetStackUID(viewport) {\r\n    return `stackTarget:${viewport.uid}`;\r\n  }\r\n\r\n  _getTargetVolumeUID = (scene) => {\r\n    if (this.configuration.volumeUID) {\r\n      return this.configuration.volumeUID;\r\n    }\r\n\r\n    const volumeActors = scene.getVolumeActors();\r\n\r\n    if (!volumeActors && !volumeActors.length) {\r\n      // No stack to scroll through\r\n      return;\r\n    }\r\n\r\n    return volumeActors[0].uid;\r\n  };\r\n}\r\n\r\nVideoRedactionTool.toolName = 'VideoRedaction';\r\nexport default VideoRedactionTool;\r\n","import {\r\n  utilities,\r\n  getEnabledElement,\r\n  StackViewport,\r\n  cache,\r\n  VideoViewport,\r\n  BaseVolumeViewport,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport BaseTool from './BaseTool';\r\nimport { getAnnotationManager } from '../../stateManagement/annotation/annotationState';\r\nimport { Annotation, Annotations, SVGDrawingHelper } from '../../types';\r\nimport triggerAnnotationRender from '../../utilities/triggerAnnotationRender';\r\nimport filterAnnotationsForDisplay from '../../utilities/planar/filterAnnotationsForDisplay';\r\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\r\nimport { getState } from '../../stateManagement/annotation/config';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\n\r\n/**\r\n * Abstract class for tools which create and display annotations on the\r\n * cornerstone3D canvas. In addition, it provides a base class for segmentation\r\n * tools that require drawing an annotation before running the segmentation strategy\r\n * for instance threshold segmentation based on an area and a threshold.\r\n * Annotation tools make use of drawing utilities to draw SVG elements on the viewport.\r\n *\r\n * To create a new annotation tool, derive from this class and implement the\r\n * abstract methods.\r\n */\r\nabstract class AnnotationDisplayTool extends BaseTool {\r\n  static toolName;\r\n\r\n  // ===================================================================\r\n  // Abstract Methods - Must be implemented.\r\n  // ===================================================================\r\n\r\n  /**\r\n   * @abstract renderAnnotation it used to draw the tool's annotation in each\r\n   * request animation frame\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  abstract renderAnnotation(\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  );\r\n\r\n  /**\r\n   * @virtual Given the element and annotations which is an array of annotation, it\r\n   * filters the annotations array to only include the annotation based on the viewportType.\r\n   * If the viewport is StackViewport, it filters based on the current imageId of the viewport,\r\n   * if the viewport is volumeViewport, it only returns those that are within the\r\n   * same slice as the current rendered slice in the volume viewport.\r\n   * imageId as the enabledElement.\r\n   * @param element - The HTML element\r\n   * @param annotations - The annotations to filter (array of annotation)\r\n   * @returns The filtered annotations\r\n   */\r\n  filterInteractableAnnotationsForElement(\r\n    element: HTMLDivElement,\r\n    annotations: Annotations\r\n  ): Annotations | undefined {\r\n    if (!annotations || !annotations.length) {\r\n      return;\r\n    }\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    return filterAnnotationsForDisplay(viewport, annotations);\r\n  }\r\n\r\n  /**\r\n   * On Image Calibration, take all the annotation from the AnnotationState manager,\r\n   * and invalidate them to force them to be re-rendered and their stats to be recalculated.\r\n   * Then use the old and new imageData (non-calibrated and calibrated) to calculate the\r\n   * new position for the annotations in the space of the new imageData.\r\n   *\r\n   * @param evt - The calibration event\r\n   *\r\n   */\r\n  public onImageSpacingCalibrated = (\r\n    evt: Types.EventTypes.ImageSpacingCalibratedEvent\r\n  ) => {\r\n    const { element, imageId } = evt.detail;\r\n\r\n    const imageURI = utilities.imageIdToURI(imageId);\r\n    const annotationManager = getAnnotationManager();\r\n    const framesOfReference = annotationManager.getFramesOfReference();\r\n\r\n    // For each frame Of Reference\r\n    framesOfReference.forEach((frameOfReference) => {\r\n      const frameOfReferenceSpecificAnnotations =\r\n        annotationManager.getAnnotations(frameOfReference);\r\n\r\n      const toolSpecificAnnotations =\r\n        frameOfReferenceSpecificAnnotations[this.getToolName()];\r\n\r\n      if (!toolSpecificAnnotations || !toolSpecificAnnotations.length) {\r\n        return;\r\n      }\r\n\r\n      // for this specific tool\r\n      toolSpecificAnnotations.forEach((annotation) => {\r\n        if (!annotation.metadata?.referencedImageId) {\r\n          return;\r\n        }\r\n\r\n        // if the annotation is drawn on the same imageId\r\n        const referencedImageURI = utilities.imageIdToURI(\r\n          annotation.metadata.referencedImageId\r\n        );\r\n\r\n        if (referencedImageURI === imageURI) {\r\n          // make them invalid since the image has been calibrated so that\r\n          // we can update the cachedStats and also rendering\r\n          annotation.invalidated = true;\r\n          annotation.data.cachedStats = {};\r\n        }\r\n      });\r\n      triggerAnnotationRender(element);\r\n    });\r\n  };\r\n\r\n  protected getReferencedImageIds(\r\n    viewport: Types.IViewport,\r\n  ): string[] {\r\n    const targetId = this.getTargetId(viewport);\r\n\r\n    let referencedImageIds;\r\n\r\n    if (viewport instanceof StackViewport) {\r\n      referencedImageIds = [targetId.split('imageId:')[1]];\r\n    } else if (viewport instanceof VideoViewport) {\r\n      referencedImageIds = [targetId.split('videoId:')[1]];\r\n    } else {\r\n      const volumeId = utilities.getVolumeId(targetId);\r\n      const imageVolume = cache.getVolume(volumeId);\r\n\r\n      referencedImageIds = imageVolume.imageIds;\r\n    }\r\n\r\n    return referencedImageIds;\r\n  }\r\n\r\n  protected getReferencedImageId(\r\n    viewport: Types.IViewport,\r\n    worldPos: Types.Point3,\r\n    viewPlaneNormal: Types.Point3,\r\n    viewUp: Types.Point3\r\n  ): string {\r\n    const targetId = this.getTargetId(viewport);\r\n\r\n    let referencedImageId = targetId.split(/^[a-zA-Z]+:/)[1];\r\n\r\n    if (viewport instanceof BaseVolumeViewport) {\r\n      const volumeId = utilities.getVolumeId(targetId);\r\n      const imageVolume = cache.getVolume(volumeId);\r\n\r\n      referencedImageId = utilities.getClosestImageId(\r\n        imageVolume,\r\n        worldPos,\r\n        viewPlaneNormal\r\n      );\r\n    }\r\n\r\n    return referencedImageId;\r\n  }\r\n\r\n  /**\r\n   * It takes the property (color, lineDash, etc.) and based on the state of the\r\n   * annotation (selected, highlighted etc.) it returns the appropriate value\r\n   * based on the central toolStyle settings for each level of specification.\r\n   * @param property - The name of the style property to get.\r\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\r\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\r\n   * met (hierarchy is checked from most specific to least specific which is\r\n   * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\r\n   * @param annotation - The annotation for the tool that is\r\n   * currently active.\r\n   * @returns The value of the property.\r\n   */\r\n  public getStyle(\r\n    property: string,\r\n    specifications: StyleSpecifier,\r\n    annotation?: Annotation\r\n  ): unknown {\r\n    return getStyleProperty(\r\n      property,\r\n      specifications,\r\n      getState(annotation),\r\n      this.mode\r\n    );\r\n  }\r\n}\r\n\r\nAnnotationDisplayTool.toolName = 'AnnotationDisplayTool';\r\nexport default AnnotationDisplayTool;\r\n","import { utilities, BaseVolumeViewport } from '@cornerstonejs/core';\r\nimport { Types } from '@cornerstonejs/core';\r\nimport ToolModes from '../../enums/ToolModes';\r\nimport StrategyCallbacks from '../../enums/StrategyCallbacks';\r\nimport { InteractionTypes, ToolProps, PublicToolProps } from '../../types';\r\n\r\nexport interface IBaseTool {\r\n  /** ToolGroup ID the tool instance belongs to */\r\n  toolGroupId: string;\r\n  /** Tool supported interaction types */\r\n  supportedInteractionTypes: InteractionTypes[];\r\n  /** Tool Mode : Active, Passive, Enabled, Disabled */\r\n  mode: ToolModes;\r\n  /** Tool Configuration */\r\n  configuration: {\r\n    preventHandleOutsideImage?: boolean;\r\n    strategies?: Record<string, any>;\r\n    defaultStrategy?: string;\r\n    activeStrategy?: string;\r\n    strategyOptions?: Record<string, unknown>;\r\n  };\r\n}\r\n\r\n/**\r\n * Abstract base class from which all tools derive.\r\n * Deals with cleanly merging custom and default configuration, and strategy\r\n * application.\r\n */\r\nabstract class BaseTool implements IBaseTool {\r\n  static toolName;\r\n  /** Supported Interaction Types - currently only Mouse */\r\n  public supportedInteractionTypes: InteractionTypes[];\r\n  public configuration: Record<string, any>;\r\n  /** ToolGroup ID the tool instance belongs to */\r\n  public toolGroupId: string;\r\n  /** Tool Mode - Active/Passive/Enabled/Disabled/ */\r\n  public mode: ToolModes;\r\n\r\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\r\n    const initialProps = utilities.deepMerge(defaultToolProps, toolProps);\r\n\r\n    const {\r\n      configuration = {},\r\n      supportedInteractionTypes,\r\n      toolGroupId,\r\n    } = initialProps;\r\n\r\n    // If strategies are not initialized in the tool config\r\n    if (!configuration.strategies) {\r\n      configuration.strategies = {};\r\n      configuration.defaultStrategy = undefined;\r\n      configuration.activeStrategy = undefined;\r\n      configuration.strategyOptions = {};\r\n    }\r\n\r\n    this.toolGroupId = toolGroupId;\r\n    this.supportedInteractionTypes = supportedInteractionTypes || [];\r\n    this.configuration = Object.assign({}, configuration);\r\n    this.mode = ToolModes.Disabled;\r\n  }\r\n\r\n  /**\r\n   * Returns the name of the tool\r\n   * @returns The name of the tool.\r\n   */\r\n  public getToolName(): string {\r\n    // Since toolName is static we get it from the class constructor\r\n    return (<typeof BaseTool>this.constructor).toolName;\r\n  }\r\n\r\n  /**\r\n   * Applies the active strategy function to the enabled element with the specified\r\n   * operation data.\r\n   * @param enabledElement - The element that is being operated on.\r\n   * @param operationData - The data that needs to be passed to the strategy.\r\n   * @returns The result of the strategy.\r\n   */\r\n  public applyActiveStrategy(\r\n    enabledElement: Types.IEnabledElement,\r\n    operationData: unknown\r\n  ): any {\r\n    const { strategies, activeStrategy } = this.configuration;\r\n    return strategies[activeStrategy]?.call(\r\n      this,\r\n      enabledElement,\r\n      operationData\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Applies the active strategy, with a given event type being applied.\r\n   * The event type function is found by indexing it on the active strategy\r\n   * function.\r\n   *\r\n   * @param enabledElement - The element that is being operated on.\r\n   * @param operationData - The data that needs to be passed to the strategy.\r\n   * @param callbackType - the type of the callback\r\n   *\r\n   * @returns The result of the strategy.\r\n   */\r\n  public applyActiveStrategyCallback(\r\n    enabledElement: Types.IEnabledElement,\r\n    operationData: unknown,\r\n    callbackType: StrategyCallbacks | string\r\n  ): any {\r\n    const { strategies, activeStrategy } = this.configuration;\r\n\r\n    if (!strategies[activeStrategy]) {\r\n      throw new Error(\r\n        `applyActiveStrategyCallback: active strategy ${activeStrategy} not found, check tool configuration or spellings`\r\n      );\r\n    }\r\n\r\n    return strategies[activeStrategy][callbackType]?.call(\r\n      this,\r\n      enabledElement,\r\n      operationData\r\n    );\r\n  }\r\n\r\n  /**\r\n   * merges the new configuration with the tool configuration\r\n   * @param configuration - toolConfiguration\r\n   */\r\n  public setConfiguration(newConfiguration: Record<string, any>): void {\r\n    this.configuration = utilities.deepMerge(\r\n      this.configuration,\r\n      newConfiguration\r\n    );\r\n    //Prevent threshold array to concat instead of replacing by new value\r\n    if(newConfiguration.strategySpecificConfiguration?.THRESHOLD_INSIDE_CIRCLE){\r\n      this.configuration.strategySpecificConfiguration.THRESHOLD_INSIDE_CIRCLE.threshold =\r\n          newConfiguration.strategySpecificConfiguration.THRESHOLD_INSIDE_CIRCLE.threshold\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the active strategy for a tool. Strategies are\r\n   * multiple implementations of tool behavior that can be switched by tool\r\n   * configuration.\r\n   *\r\n   * @param strategyName - name of the strategy to be set as active\r\n   */\r\n  public setActiveStrategy(strategyName: string): void {\r\n    this.setConfiguration({ activeStrategy: strategyName });\r\n  }\r\n\r\n  /**\r\n   * Returns the volumeId for the volume viewport. It will grabbed the volumeId\r\n   * from the volumeId if particularly specified in the tool configuration, or if\r\n   * not, the first actorUID in the viewport is returned as the volumeId. NOTE: for\r\n   * segmentations, actorUID is not necessarily the volumeId since the segmentation\r\n   * can have multiple representations, use segmentation helpers to get the volumeId\r\n   * based on the actorUID.\r\n   *\r\n   * @param viewport - Volume viewport\r\n   * @returns the volumeId for the viewport if specified in the tool configuration,\r\n   * or the first actorUID in the viewport if not.\r\n   */\r\n  private getTargetVolumeId(viewport: Types.IViewport): string | undefined {\r\n    if (this.configuration.volumeId) {\r\n      return this.configuration.volumeId;\r\n    }\r\n\r\n    // If volume not specified, then return the actorUID for the\r\n    // default actor - first actor\r\n    const actorEntries = viewport.getActors();\r\n\r\n    if (!actorEntries) {\r\n      return;\r\n    }\r\n\r\n    // find the first image actor of instance type vtkVolume\r\n    return actorEntries.find(\r\n      (actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume'\r\n    )?.uid;\r\n  }\r\n\r\n  /**\r\n   * Get the image that is displayed for the targetId in the cachedStats\r\n   * which can be\r\n   * * imageId:<imageId>\r\n   * * volumeId:<volumeId>\r\n   * * videoId:<basePathForVideo>/frames/<frameSpecifier>\r\n   *\r\n   * @param targetId - annotation targetId stored in the cached stats\r\n   * @param renderingEngine - The rendering engine\r\n   * @returns The image data for the target.\r\n   */\r\n  protected getTargetIdImage(\r\n    targetId: string,\r\n    renderingEngine: Types.IRenderingEngine\r\n  ): Types.IImageData | Types.CPUIImageData | Types.IImageVolume {\r\n    if (targetId.startsWith('imageId:')) {\r\n      const imageId = targetId.split('imageId:')[1];\r\n      const imageURI = utilities.imageIdToURI(imageId);\r\n      let viewports = utilities.getViewportsWithImageURI(\r\n        imageURI,\r\n        renderingEngine.id\r\n      );\r\n\r\n      if (!viewports || !viewports.length) {\r\n        return;\r\n      }\r\n\r\n      viewports = viewports.filter((viewport) => {\r\n        return viewport.getCurrentImageId() === imageId;\r\n      });\r\n\r\n      if (!viewports || !viewports.length) {\r\n        return;\r\n      }\r\n\r\n      return viewports[0].getImageData();\r\n    } else if (targetId.startsWith('volumeId:')) {\r\n      const volumeId = utilities.getVolumeId(targetId);\r\n      const viewports = utilities.getViewportsWithVolumeId(\r\n        volumeId,\r\n        renderingEngine.id\r\n      );\r\n\r\n      if (!viewports || !viewports.length) {\r\n        return;\r\n      }\r\n\r\n      return viewports[0].getImageData();\r\n    } else if (targetId.startsWith('videoId:')) {\r\n      // Video id can be multi-valued for the frame information\r\n      const imageURI = utilities.imageIdToURI(targetId);\r\n      const viewports = utilities.getViewportsWithImageURI(\r\n        imageURI,\r\n        renderingEngine.id\r\n      );\r\n\r\n      if (!viewports || !viewports.length) {\r\n        return;\r\n      }\r\n\r\n      return viewports[0].getImageData();\r\n    } else {\r\n      throw new Error(\r\n        'getTargetIdImage: targetId must start with \"imageId:\" or \"volumeId:\"'\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the target Id for the viewport which will be used to store the cached\r\n   * statistics scoped to that target in the annotations.\r\n   * For StackViewport, targetId is the viewportId, but for the volume viewport,\r\n   * the targetId will be grabbed from the volumeId if particularly specified\r\n   * in the tool configuration, or if not, the first actorUID in the viewport.\r\n   *\r\n   * @param viewport - viewport to get the targetId for\r\n   * @returns targetId\r\n   */\r\n  protected getTargetId(viewport: Types.IViewport): string | undefined {\r\n    const targetId = viewport.getReferenceId?.();\r\n    if (targetId) {\r\n      return targetId;\r\n    }\r\n    if (viewport instanceof BaseVolumeViewport) {\r\n      return `volumeId:${this.getTargetVolumeId(viewport)}`;\r\n    }\r\n    throw new Error('getTargetId: viewport must have a getReferenceId method');\r\n  }\r\n}\r\n\r\n// Note: this is a workaround since terser plugin does not support static blocks\r\n// yet and we can't easily say static toolName = \"BaseTool\" in the class definition.\r\nBaseTool.toolName = 'BaseTool';\r\nexport default BaseTool;\r\n","import vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';\r\nimport vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\r\n\r\nimport {\r\n  cache,\r\n  getEnabledElementByIds,\r\n  StackViewport,\r\n  Types,\r\n  VolumeViewport,\r\n} from '@cornerstonejs/core';\r\n\r\nimport Representations from '../../../enums/SegmentationRepresentations';\r\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\r\nimport { getToolGroup } from '../../../store/ToolGroupManager';\r\nimport type {\r\n  LabelmapConfig,\r\n  LabelmapRenderingConfig,\r\n  LabelmapSegmentationData,\r\n} from '../../../types/LabelmapTypes';\r\nimport {\r\n  SegmentationRepresentationConfig,\r\n  ToolGroupSpecificRepresentation,\r\n} from '../../../types/SegmentationStateTypes';\r\n\r\nimport addLabelmapToElement from './addLabelmapToElement';\r\nimport removeLabelmapFromElement from './removeLabelmapFromElement';\r\nimport { isVolumeSegmentation } from '../../segmentation/strategies/utils/stackVolumeCheck';\r\nimport { polySeg } from '../../../stateManagement/segmentation';\r\n\r\nconst MAX_NUMBER_COLORS = 255;\r\nconst labelMapConfigCache = new Map();\r\n\r\nfunction getRepresentationRenderingConfig() {\r\n  const cfun = vtkColorTransferFunction.newInstance();\r\n  const ofun = vtkPiecewiseFunction.newInstance();\r\n  ofun.addPoint(0, 0);\r\n  return {\r\n    ofun,\r\n    cfun,\r\n  };\r\n}\r\n\r\nlet polySegConversionInProgress = false;\r\n\r\n/**\r\n * For each viewport, and for each segmentation, set the segmentation for the viewport's enabled element\r\n * Initializes the global and viewport specific state for the segmentation in the\r\n * SegmentationStateManager.\r\n * @param toolGroup - the tool group that contains the viewports\r\n * @param segmentationRepresentationUID - The uid of the segmentation representation\r\n * @param renderImmediate - If true, there will be a render call after the labelmap is removed\r\n */\r\nfunction removeSegmentationRepresentation(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string,\r\n  renderImmediate = false\r\n): void {\r\n  _removeLabelmapFromToolGroupViewports(\r\n    toolGroupId,\r\n    segmentationRepresentationUID\r\n  );\r\n  SegmentationState.removeSegmentationRepresentation(\r\n    toolGroupId,\r\n    segmentationRepresentationUID\r\n  );\r\n\r\n  if (renderImmediate) {\r\n    const viewportsInfo = getToolGroup(toolGroupId).getViewportsInfo();\r\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\r\n      const enabledElement = getEnabledElementByIds(\r\n        viewportId,\r\n        renderingEngineId\r\n      );\r\n      enabledElement.viewport.render();\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if a segmentation data have the same frameOfReference as the series\r\n * displayed in a given viewport\r\n * @param viewport\r\n * @param referencedVolumeId volume id of the segmentation reference series\r\n * @returns\r\n */\r\nfunction isSameFrameOfReference(viewport, referencedVolumeId) {\r\n  // if the referencedVolumeId is not defined, we acted as before to not break\r\n  // applications as referencedVolumeId is inserted in this change\r\n  // Can modify that in the future commits\r\n  if (!referencedVolumeId) {\r\n    return true;\r\n  }\r\n  const defaultActor = viewport.getDefaultActor();\r\n  if (!defaultActor) {\r\n    return false;\r\n  }\r\n  const { uid: defaultActorUID } = defaultActor;\r\n  const volume = cache.getVolume(defaultActorUID);\r\n\r\n  if (volume) {\r\n    const referencedVolume = cache.getVolume(referencedVolumeId);\r\n    if (\r\n      referencedVolume &&\r\n      volume.metadata.FrameOfReferenceUID ===\r\n        referencedVolume.metadata.FrameOfReferenceUID\r\n    ) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * It takes the enabled element, the segmentation Id, and the configuration, and\r\n * it sets the segmentation for the enabled element as a labelmap\r\n * @param enabledElement - The cornerstone enabled element\r\n * @param segmentationId - The id of the segmentation to be rendered.\r\n * @param configuration - The configuration object for the labelmap.\r\n */\r\nasync function render(\r\n  viewport: Types.IVolumeViewport | Types.IStackViewport,\r\n  representation: ToolGroupSpecificRepresentation,\r\n  toolGroupConfig: SegmentationRepresentationConfig\r\n): Promise<void> {\r\n  const {\r\n    colorLUTIndex,\r\n    active,\r\n    segmentationId,\r\n    segmentationRepresentationUID,\r\n    segmentsHidden,\r\n    config: renderingConfig,\r\n  } = representation;\r\n\r\n  const segmentation = SegmentationState.getSegmentation(segmentationId);\r\n\r\n  if (!segmentation) {\r\n    console.warn('No segmentation found for segmentationId: ', segmentationId);\r\n    return;\r\n  }\r\n\r\n  let labelmapData = segmentation.representationData[Representations.Labelmap];\r\n\r\n  let actorEntry = viewport.getActor(segmentationRepresentationUID);\r\n\r\n  if (\r\n    !labelmapData &&\r\n    polySeg.canComputeRequestedRepresentation(segmentationRepresentationUID) &&\r\n    !polySegConversionInProgress\r\n  ) {\r\n    // meaning the requested segmentation representationUID does not have\r\n    // labelmap data, BUT we might be able to request a conversion from\r\n    // another representation to labelmap\r\n    // we need to check if we can request polySEG to convert the other\r\n    // underlying representations to Surface\r\n    polySegConversionInProgress = true;\r\n\r\n    labelmapData = await polySeg.computeAndAddLabelmapRepresentation(\r\n      segmentationId,\r\n      {\r\n        segmentationRepresentationUID,\r\n        viewport,\r\n      }\r\n    );\r\n\r\n    if (!labelmapData) {\r\n      throw new Error(\r\n        `No labelmap data found for segmentationId ${segmentationId}.`\r\n      );\r\n    }\r\n\r\n    polySegConversionInProgress = false;\r\n  }\r\n\r\n  if (!labelmapData) {\r\n    return;\r\n  }\r\n\r\n  if (isVolumeSegmentation(labelmapData, viewport)) {\r\n    if (viewport instanceof StackViewport) {\r\n      return;\r\n    }\r\n\r\n    const { volumeId: labelmapUID } = labelmapData;\r\n\r\n    const labelmap = cache.getVolume(labelmapUID);\r\n\r\n    if (!labelmap) {\r\n      throw new Error(`No Labelmap found for volumeId: ${labelmapUID}`);\r\n    }\r\n\r\n    if (!isSameFrameOfReference(viewport, labelmapData?.referencedVolumeId)) {\r\n      return;\r\n    }\r\n\r\n    if (!actorEntry) {\r\n      // only add the labelmap to ToolGroup viewports if it is not already added\r\n      await _addLabelmapToViewport(\r\n        viewport,\r\n        labelmapData,\r\n        segmentationRepresentationUID\r\n      );\r\n    }\r\n\r\n    actorEntry = viewport.getActor(segmentationRepresentationUID);\r\n  } else {\r\n    if (viewport instanceof VolumeViewport) {\r\n      return;\r\n    }\r\n\r\n    // stack segmentation\r\n    const imageId = viewport.getCurrentImageId();\r\n    const { imageIdReferenceMap } = labelmapData;\r\n\r\n    // if the stack labelmap is not built for the current imageId that is\r\n    // rendered at the viewport then return\r\n    if (!imageIdReferenceMap.has(imageId)) {\r\n      return;\r\n    }\r\n\r\n    if (!actorEntry) {\r\n      // only add the labelmap to ToolGroup viewports if it is not already added\r\n      await _addLabelmapToViewport(\r\n        viewport,\r\n        labelmapData,\r\n        segmentationRepresentationUID\r\n      );\r\n    }\r\n\r\n    actorEntry = viewport.getActor(segmentationRepresentationUID);\r\n  }\r\n\r\n  if (!actorEntry) {\r\n    return;\r\n  }\r\n\r\n  const { cfun, ofun } = renderingConfig as LabelmapRenderingConfig;\r\n\r\n  const renderInactiveSegmentations =\r\n    toolGroupConfig.renderInactiveSegmentations;\r\n\r\n  _setLabelmapColorAndOpacity(\r\n    viewport.id,\r\n    actorEntry,\r\n    cfun,\r\n    ofun,\r\n    colorLUTIndex,\r\n    toolGroupConfig.representations[Representations.Labelmap],\r\n    representation,\r\n    active,\r\n    renderInactiveSegmentations,\r\n    segmentsHidden\r\n  );\r\n}\r\n\r\nfunction _setLabelmapColorAndOpacity(\r\n  viewportId: string,\r\n  actorEntry: Types.ActorEntry,\r\n  cfun: vtkColorTransferFunction,\r\n  ofun: vtkPiecewiseFunction,\r\n  colorLUTIndex: number,\r\n  toolGroupLabelmapConfig: LabelmapConfig,\r\n  segmentationRepresentation: ToolGroupSpecificRepresentation,\r\n  isActiveLabelmap: boolean,\r\n  renderInactiveSegmentations: boolean,\r\n  segmentsHidden: Set<number>\r\n): void {\r\n  const { segmentSpecificConfig, segmentationRepresentationSpecificConfig } =\r\n    segmentationRepresentation;\r\n\r\n  const segmentationRepresentationLabelmapConfig =\r\n    segmentationRepresentationSpecificConfig[Representations.Labelmap];\r\n\r\n  // Note: MAX_NUMBER_COLORS = 256 is needed because the current method to generate\r\n  // the default color table uses RGB.\r\n  const colorLUT = SegmentationState.getColorLUT(colorLUTIndex);\r\n  const numColors = Math.min(256, colorLUT.length);\r\n  const { uid: actorUID } = actorEntry;\r\n\r\n  // Note: right now outlineWidth and renderOutline are not configurable\r\n  // at the segment level, so we don't need to check for segment specific\r\n  // configuration in the loop, Todo: make them configurable at the segment level\r\n  const { outlineWidth, renderOutline, outlineOpacity } = _getLabelmapConfig(\r\n    toolGroupLabelmapConfig,\r\n    segmentationRepresentationLabelmapConfig,\r\n    isActiveLabelmap\r\n  );\r\n\r\n  // Todo: the below loop probably can be optimized so that we don't hit it\r\n  // unless a config has changed. Right now we get into the following loop\r\n  // even for brush drawing which does not makes sense\r\n  for (let i = 0; i < numColors; i++) {\r\n    const segmentIndex = i;\r\n    const segmentColor = colorLUT[segmentIndex];\r\n\r\n    const segmentSpecificLabelmapConfig =\r\n      segmentSpecificConfig[segmentIndex]?.[Representations.Labelmap];\r\n\r\n    const { fillAlpha, outlineWidth, renderFill, renderOutline } =\r\n      _getLabelmapConfig(\r\n        toolGroupLabelmapConfig,\r\n        segmentationRepresentationLabelmapConfig,\r\n        isActiveLabelmap,\r\n        segmentSpecificLabelmapConfig\r\n      );\r\n\r\n    const { forceOpacityUpdate, forceColorUpdate } =\r\n      _needsTransferFunctionUpdate(viewportId, actorUID, segmentIndex, {\r\n        fillAlpha,\r\n        renderFill,\r\n        renderOutline,\r\n        segmentColor,\r\n        outlineWidth,\r\n        segmentsHidden,\r\n      });\r\n\r\n    if (forceColorUpdate) {\r\n      cfun.addRGBPoint(\r\n        segmentIndex,\r\n        segmentColor[0] / MAX_NUMBER_COLORS,\r\n        segmentColor[1] / MAX_NUMBER_COLORS,\r\n        segmentColor[2] / MAX_NUMBER_COLORS\r\n      );\r\n    }\r\n\r\n    if (forceOpacityUpdate) {\r\n      if (renderFill) {\r\n        const segmentOpacity = segmentsHidden.has(segmentIndex)\r\n          ? 0\r\n          : (segmentColor[3] / 255) * fillAlpha;\r\n\r\n        ofun.removePoint(segmentIndex);\r\n        ofun.addPointLong(segmentIndex, segmentOpacity, 0.5, 1.0);\r\n      } else {\r\n        ofun.addPointLong(segmentIndex, 0.01, 0.5, 1.0);\r\n      }\r\n    }\r\n  }\r\n\r\n  const actor = actorEntry.actor as Types.VolumeActor;\r\n\r\n  actor.getProperty().setRGBTransferFunction(0, cfun);\r\n\r\n  ofun.setClamping(false);\r\n\r\n  actor.getProperty().setScalarOpacity(0, ofun);\r\n  actor.getProperty().setInterpolationTypeToNearest();\r\n  actor.getProperty().setUseLabelOutline(renderOutline);\r\n\r\n  // @ts-ignore - fix type in vtk\r\n  actor.getProperty().setLabelOutlineOpacity(outlineOpacity);\r\n\r\n  const { activeSegmentIndex } = SegmentationState.getSegmentation(\r\n    segmentationRepresentation.segmentationId\r\n  );\r\n\r\n  // create an array that contains all the segment indices and for the active\r\n  // segment index, use the activeSegmentOutlineWidthDelta, otherwise use the\r\n  // outlineWidth\r\n  // Pre-allocate the array with the required size to avoid dynamic resizing.\r\n  const outlineWidths = new Array(numColors - 1);\r\n\r\n  for (let i = 1; i < numColors; i++) {\r\n    // Start from 1 to skip the background segment index.\r\n    const isHidden = segmentsHidden.has(i);\r\n\r\n    if (isHidden) {\r\n      outlineWidths[i - 1] = 0;\r\n      continue;\r\n    }\r\n\r\n    outlineWidths[i - 1] =\r\n      i === activeSegmentIndex\r\n        ? outlineWidth + toolGroupLabelmapConfig.activeSegmentOutlineWidthDelta\r\n        : outlineWidth;\r\n  }\r\n\r\n  actor.getProperty().setLabelOutlineThickness(outlineWidths);\r\n\r\n  // Set visibility based on whether actor visibility is specifically asked\r\n  // to be turned on/off (on by default) AND whether is is in active but\r\n  // we are rendering inactive labelmap\r\n  const visible = isActiveLabelmap || renderInactiveSegmentations;\r\n  actor.setVisibility(visible);\r\n}\r\n\r\nfunction _getLabelmapConfig(\r\n  toolGroupLabelmapConfig: LabelmapConfig,\r\n  segmentationRepresentationLabelmapConfig: LabelmapConfig,\r\n  isActiveLabelmap: boolean,\r\n  segmentsLabelmapConfig?: LabelmapConfig\r\n) {\r\n  const segmentLabelmapConfig = segmentsLabelmapConfig || {};\r\n\r\n  const configToUse = {\r\n    ...toolGroupLabelmapConfig,\r\n    ...segmentationRepresentationLabelmapConfig,\r\n    ...segmentLabelmapConfig,\r\n  };\r\n\r\n  const fillAlpha = isActiveLabelmap\r\n    ? configToUse.fillAlpha\r\n    : configToUse.fillAlphaInactive;\r\n  const outlineWidth = isActiveLabelmap\r\n    ? configToUse.outlineWidthActive\r\n    : configToUse.outlineWidthInactive;\r\n\r\n  const renderFill = isActiveLabelmap\r\n    ? configToUse.renderFill\r\n    : configToUse.renderFillInactive;\r\n\r\n  const renderOutline = configToUse.renderOutline;\r\n\r\n  const outlineOpacity = isActiveLabelmap\r\n    ? configToUse.outlineOpacity\r\n    : configToUse.outlineOpacityInactive;\r\n\r\n  return {\r\n    fillAlpha,\r\n    outlineWidth,\r\n    renderFill,\r\n    renderOutline,\r\n    outlineOpacity,\r\n  };\r\n}\r\n\r\nfunction _needsTransferFunctionUpdate(\r\n  viewportId: string,\r\n  actorUID: string,\r\n  segmentIndex: number,\r\n  {\r\n    fillAlpha,\r\n    renderFill,\r\n    renderOutline,\r\n    segmentColor,\r\n    outlineWidth,\r\n    segmentsHidden,\r\n  }: {\r\n    fillAlpha: number;\r\n    renderFill: boolean;\r\n    renderOutline: boolean;\r\n    outlineWidth: number;\r\n    segmentColor: number[];\r\n    segmentsHidden: Set<number>;\r\n  }\r\n) {\r\n  const cacheUID = `${viewportId}-${actorUID}-${segmentIndex}`;\r\n  const oldConfig = labelMapConfigCache.get(cacheUID);\r\n\r\n  if (!oldConfig) {\r\n    labelMapConfigCache.set(cacheUID, {\r\n      fillAlpha,\r\n      renderFill,\r\n      renderOutline,\r\n      outlineWidth,\r\n      segmentColor: segmentColor.slice(), // Create a copy\r\n      segmentsHidden: new Set(segmentsHidden), // Create a copy\r\n    });\r\n\r\n    return {\r\n      forceOpacityUpdate: true,\r\n      forceColorUpdate: true,\r\n    };\r\n  }\r\n\r\n  const {\r\n    fillAlpha: oldFillAlpha,\r\n    renderFill: oldRenderFill,\r\n    renderOutline: oldRenderOutline,\r\n    outlineWidth: oldOutlineWidth,\r\n    segmentColor: oldSegmentColor,\r\n    segmentsHidden: oldSegmentsHidden,\r\n  } = oldConfig;\r\n\r\n  const forceColorUpdate =\r\n    oldSegmentColor[0] !== segmentColor[0] ||\r\n    oldSegmentColor[1] !== segmentColor[1] ||\r\n    oldSegmentColor[2] !== segmentColor[2];\r\n\r\n  const forceOpacityUpdate =\r\n    oldSegmentColor[3] !== segmentColor[3] ||\r\n    oldFillAlpha !== fillAlpha ||\r\n    oldRenderFill !== renderFill ||\r\n    oldRenderOutline !== renderOutline ||\r\n    oldOutlineWidth !== outlineWidth ||\r\n    oldSegmentsHidden.has(segmentIndex) !== segmentsHidden.has(segmentIndex);\r\n\r\n  // update the cache\r\n  labelMapConfigCache.set(cacheUID, {\r\n    fillAlpha,\r\n    renderFill,\r\n    renderOutline,\r\n    outlineWidth,\r\n    segmentColor: segmentColor.slice(), // Create a copy\r\n    segmentsHidden: new Set(segmentsHidden), // Create a copy\r\n  });\r\n\r\n  return {\r\n    forceOpacityUpdate,\r\n    forceColorUpdate,\r\n  };\r\n}\r\n\r\nfunction _removeLabelmapFromToolGroupViewports(\r\n  toolGroupId: string,\r\n  segmentationRepresentationUID: string\r\n): void {\r\n  const toolGroup = getToolGroup(toolGroupId);\r\n\r\n  if (toolGroup === undefined) {\r\n    throw new Error(`ToolGroup with ToolGroupId ${toolGroupId} does not exist`);\r\n  }\r\n\r\n  const { viewportsInfo } = toolGroup;\r\n\r\n  for (const viewportInfo of viewportsInfo) {\r\n    const { viewportId, renderingEngineId } = viewportInfo;\r\n    const enabledElement = getEnabledElementByIds(\r\n      viewportId,\r\n      renderingEngineId\r\n    );\r\n    removeLabelmapFromElement(\r\n      enabledElement.viewport.element,\r\n      segmentationRepresentationUID\r\n    );\r\n  }\r\n}\r\n\r\nasync function _addLabelmapToViewport(\r\n  viewport: Types.IVolumeViewport | Types.IStackViewport,\r\n  labelmapData: LabelmapSegmentationData,\r\n  segmentationRepresentationUID\r\n): Promise<void> {\r\n  await addLabelmapToElement(\r\n    viewport.element,\r\n    labelmapData,\r\n    segmentationRepresentationUID\r\n  );\r\n}\r\n\r\nexport default {\r\n  getRepresentationRenderingConfig,\r\n  render,\r\n  removeSegmentationRepresentation,\r\n};\r\n\r\nexport {\r\n  getRepresentationRenderingConfig,\r\n  render,\r\n  removeSegmentationRepresentation,\r\n};\r\n","import {\r\n  getEnabledElement,\r\n  cache,\r\n  StackViewport,\r\n  utilities as csUtils,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\r\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\r\n\r\nimport {\r\n  drawHandles as drawHandlesSvg,\r\n  drawRect as drawRectSvg,\r\n} from '../../drawingSvg';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport { hideElementCursor } from '../../cursors/elementCursor';\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\r\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\r\nimport {\r\n  PublicToolProps,\r\n  ToolProps,\r\n  EventTypes,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\nimport { RectangleROIThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\nimport RectangleROITool from '../annotation/RectangleROITool';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\n\r\n/**\r\n * This tool is exactly the RectangleROITool but only draws a rectangle on the image,\r\n * and by using utility functions such as thresholdByRange and thresholdByROIStat it can be used to\r\n * create a segmentation. This tool, however, does not calculate the statistics\r\n * as RectangleROITool does.\r\n */\r\nclass RectangleROIThresholdTool extends RectangleROITool {\r\n  static toolName;\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: string[];\r\n    handleIndex?: number;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        shadow: true,\r\n        preventHandleOutsideImage: false,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the enabledElement it creates\r\n   * the edit data for the tool.\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    const targetId = this.getTargetId(viewport);\r\n    let referencedImageId, volumeId;\r\n\r\n    if (viewport instanceof StackViewport) {\r\n      referencedImageId = targetId.split('imageId:')[1];\r\n    } else {\r\n      volumeId = csUtils.getVolumeId(targetId);\r\n      const imageVolume = cache.getVolume(volumeId);\r\n      referencedImageId = csUtils.getClosestImageId(\r\n        imageVolume,\r\n        worldPos,\r\n        viewPlaneNormal\r\n      );\r\n    }\r\n\r\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n    // Todo: how not to store enabledElement on the annotation, segmentationModule needs the element to\r\n    // decide on the active segmentIndex, active segmentationIndex etc.\r\n    const annotation = {\r\n      highlighted: true,\r\n      invalidated: true,\r\n      metadata: {\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        enabledElement,\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID,\r\n        referencedImageId,\r\n        toolName: this.getToolName(),\r\n        volumeId,\r\n      },\r\n      data: {\r\n        label: '',\r\n        handles: {\r\n          // No need a textBox\r\n          textBox: {\r\n            hasMoved: false,\r\n            worldPosition: null,\r\n            worldBoundingBox: null,\r\n          },\r\n          points: [\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n          ],\r\n          activeHandleIndex: null,\r\n        },\r\n        segmentationId: null,\r\n      },\r\n    };\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex: 3,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n    };\r\n    this._activateDraw(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the RectangleROI Threshold annotation in each\r\n   * request animation frame.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n    let annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    annotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    );\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[i] as RectangleROIThresholdAnnotation;\r\n      const { annotationUID, data } = annotation;\r\n      const { points, activeHandleIndex } = data.handles;\r\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\r\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\r\n      const color = 'rgb(255, 255, 255)'\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n\r\n      // Todo: This is not correct way to add the event trigger,\r\n      // this will trigger on all mouse hover too. Problem is that we don't\r\n      // have a cached stats mechanism for this tool yet?\r\n      triggerAnnotationModified(annotation, element);\r\n\r\n      let activeHandleCanvasCoords;\r\n\r\n      if (!isAnnotationVisible(annotationUID)) {\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        !isAnnotationLocked(annotation) &&\r\n        !this.editData &&\r\n        activeHandleIndex !== null\r\n      ) {\r\n        // Not locked or creating and hovering over handle, so render handle.\r\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\r\n      }\r\n\r\n      if (activeHandleCanvasCoords) {\r\n        const handleGroupUID = '0';\r\n\r\n        drawHandlesSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          handleGroupUID,\r\n          activeHandleCanvasCoords,\r\n          {\r\n            color,\r\n          }\r\n        );\r\n      }\r\n\r\n      const rectangleUID = '0';\r\n      drawRectSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        rectangleUID,\r\n        canvasCoordinates[0],\r\n        canvasCoordinates[3],\r\n        {\r\n          color,\r\n          lineDash,\r\n          lineWidth,\r\n        }\r\n      );\r\n\r\n      renderStatus = true;\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n}\r\n\r\nRectangleROIThresholdTool.toolName = 'RectangleROIThreshold';\r\nexport default RectangleROIThresholdTool;\r\n","import {\r\n  getEnabledElement,\r\n  cache,\r\n  StackViewport,\r\n  metaData,\r\n  utilities as csUtils,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { vec3 } from 'gl-matrix';\r\nimport {\r\n  addAnnotation,\r\n  getAnnotations,\r\n  removeAnnotation,\r\n} from '../../stateManagement';\r\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\r\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\r\nimport {\r\n  drawHandles as drawHandlesSvg,\r\n  drawRect as drawRectSvg,\r\n} from '../../drawingSvg';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport throttle from '../../utilities/throttle';\r\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\r\nimport {\r\n  hideElementCursor,\r\n  resetElementCursor,\r\n} from '../../cursors/elementCursor';\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\nimport { triggerAnnotationCompleted } from '../../stateManagement/annotation/helpers/state';\r\n\r\nimport {\r\n  PublicToolProps,\r\n  ToolProps,\r\n  EventTypes,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\nimport { RectangleROIStartEndThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\nimport RectangleROITool from '../annotation/RectangleROITool';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\nimport { pointInShapeCallback } from '../../utilities/';\r\n\r\nconst { transformWorldToIndex } = csUtils;\r\n\r\n/**\r\n * This tool is similar to the RectangleROIThresholdTool which\r\n * only draws a rectangle on the image, and by using utility functions\r\n * such as thresholdByRange and thresholdByROIStat it can be used to\r\n * create a segmentation. The only difference is that it only acts on the\r\n * acquisition plane and not the 3D volume, and accepts a start and end\r\n * slice, and renders a dashed rectangle on the image between the start and end\r\n * but a solid rectangle on start and end slice. Utility functions should be used\r\n * to modify the start and end slice.\r\n * // Todo: right now only the first slice has grabbable handles, need to make\r\n * // it so that the handles are grabbable on all slices.\r\n */\r\nclass RectangleROIStartEndThresholdTool extends RectangleROITool {\r\n  static toolName;\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: string[];\r\n    handleIndex?: number;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      configuration: {\r\n        numSlicesToPropagate: 10,\r\n        computePointsInsideVolume: false,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n\r\n    this._throttledCalculateCachedStats = throttle(\r\n      this._calculateCachedStatsTool,\r\n      100,\r\n      { trailing: true }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the enabledElement it creates\r\n   * the edit data for the tool.\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    let referencedImageId, imageVolume, volumeId;\r\n    if (viewport instanceof StackViewport) {\r\n      throw new Error('Stack Viewport Not implemented');\r\n    } else {\r\n      const targetId = this.getTargetId(viewport);\r\n      volumeId = csUtils.getVolumeId(targetId);\r\n      imageVolume = cache.getVolume(volumeId);\r\n      referencedImageId = csUtils.getClosestImageId(\r\n        imageVolume,\r\n        worldPos,\r\n        viewPlaneNormal\r\n      );\r\n    }\r\n\r\n    if (!referencedImageId) {\r\n      throw new Error('This tool does not work on non-acquisition planes');\r\n    }\r\n\r\n    const startIndex = viewport.getCurrentImageIdIndex();\r\n    const spacingInNormal = csUtils.getSpacingInNormalDirection(\r\n      imageVolume,\r\n      viewPlaneNormal\r\n    );\r\n\r\n    // We cannot simply add numSlicesToPropagate to startIndex because\r\n    // the order of imageIds can be from top to bottom or bottom to top and\r\n    // we want to make sure it is always propagated in the direction of the\r\n    // view and also to make sure we don't go out of bounds.\r\n    const endIndex = this._getEndSliceIndex(\r\n      imageVolume,\r\n      worldPos,\r\n      spacingInNormal,\r\n      viewPlaneNormal\r\n    );\r\n\r\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n\r\n    const annotation = {\r\n      highlighted: true,\r\n      invalidated: true,\r\n      metadata: {\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        enabledElement,\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID,\r\n        referencedImageId,\r\n        toolName: this.getToolName(),\r\n        volumeId,\r\n        spacingInNormal,\r\n      },\r\n      data: {\r\n        label: '',\r\n        startSlice: startIndex,\r\n        endSlice: endIndex,\r\n        cachedStats: {\r\n          pointsInVolume: [],\r\n          projectionPoints: [],\r\n          projectionPointsImageIds: [referencedImageId],\r\n        },\r\n        handles: {\r\n          // No need a textBox\r\n          textBox: {\r\n            hasMoved: false,\r\n            worldPosition: null,\r\n            worldBoundingBox: null,\r\n          },\r\n          points: [\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n          ],\r\n          activeHandleIndex: null,\r\n        },\r\n        labelmapUID: null,\r\n      },\r\n    };\r\n\r\n    // update the projection points in 3D space, since we are projecting\r\n    // the points to the slice plane, we need to make sure the points are\r\n    // computed for later export\r\n    this._computeProjectionPoints(annotation, imageVolume);\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex: 3,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n    };\r\n    this._activateDraw(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  };\r\n\r\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (newAnnotation && !hasMoved) {\r\n      return;\r\n    }\r\n\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateModify(element);\r\n    this._deactivateDraw(element);\r\n\r\n    resetElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n\r\n    if (\r\n      this.isHandleOutsideImage &&\r\n      this.configuration.preventHandleOutsideImage\r\n    ) {\r\n      removeAnnotation(annotation.annotationUID);\r\n    }\r\n\r\n    const targetId = this.getTargetId(enabledElement.viewport);\r\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\r\n\r\n    if (this.configuration.calculatePointsInsideVolume) {\r\n      this._computePointsInsideVolume(annotation, imageVolume, enabledElement);\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(\r\n      enabledElement.renderingEngine,\r\n      viewportIdsToRender\r\n    );\r\n\r\n    if (newAnnotation) {\r\n      triggerAnnotationCompleted(annotation);\r\n    }\r\n  };\r\n\r\n  // Todo: make it work for planes other than acquisition planes\r\n  _computeProjectionPoints(\r\n    annotation: RectangleROIStartEndThresholdAnnotation,\r\n    imageVolume: Types.IImageVolume\r\n  ): void {\r\n    const { data, metadata } = annotation;\r\n    const { viewPlaneNormal, spacingInNormal } = metadata;\r\n    const { imageData } = imageVolume;\r\n    const { startSlice, endSlice } = data;\r\n    const { points } = data.handles;\r\n\r\n    const startIJK = transformWorldToIndex(imageData, points[0]);\r\n\r\n    if (startIJK[2] !== startSlice) {\r\n      throw new Error('Start slice does not match');\r\n    }\r\n\r\n    // substitute the end slice index 2 with startIJK index 2\r\n    const endIJK = vec3.fromValues(startIJK[0], startIJK[1], endSlice);\r\n\r\n    const startWorld = vec3.create();\r\n    imageData.indexToWorldVec3(startIJK, startWorld);\r\n\r\n    const endWorld = vec3.create();\r\n    imageData.indexToWorldVec3(endIJK, endWorld);\r\n\r\n    // distance between start and end slice in the world coordinate\r\n    const distance = vec3.distance(startWorld, endWorld);\r\n\r\n    // for each point inside points, navigate in the direction of the viewPlaneNormal\r\n    // with amount of spacingInNormal, and calculate the next slice until we reach the distance\r\n    const newProjectionPoints = [];\r\n    for (let dist = 0; dist < distance; dist += spacingInNormal) {\r\n      newProjectionPoints.push(\r\n        points.map((point) => {\r\n          const newPoint = vec3.create();\r\n          vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);\r\n          return Array.from(newPoint);\r\n        })\r\n      );\r\n    }\r\n\r\n    data.cachedStats.projectionPoints = newProjectionPoints;\r\n\r\n    // Find the imageIds for the projection points\r\n    const projectionPointsImageIds = [];\r\n    for (const RectanglePoints of newProjectionPoints) {\r\n      const imageId = csUtils.getClosestImageId(\r\n        imageVolume,\r\n        RectanglePoints[0],\r\n        viewPlaneNormal\r\n      );\r\n      projectionPointsImageIds.push(imageId);\r\n    }\r\n\r\n    data.cachedStats.projectionPointsImageIds = projectionPointsImageIds;\r\n  }\r\n\r\n  //This function return all the points inside the ROI for every slices between startSlice and endSlice\r\n  _computePointsInsideVolume(annotation, imageVolume, enabledElement) {\r\n    const { data } = annotation;\r\n    const projectionPoints = data.cachedStats.projectionPoints;\r\n\r\n    const pointsInsideVolume: Types.Point3[][] = [[]];\r\n\r\n    for (let i = 0; i < projectionPoints.length; i++) {\r\n      // If image does not exists for the targetId, skip. This can be due\r\n      // to various reasons such as if the target was a volumeViewport, and\r\n      // the volumeViewport has been decached in the meantime.\r\n      if (!imageVolume) {\r\n        continue;\r\n      }\r\n\r\n      const projectionPoint = projectionPoints[i][0];\r\n\r\n      const worldPos1 = data.handles.points[0];\r\n      const worldPos2 = data.handles.points[3];\r\n\r\n      const { dimensions, imageData } = imageVolume;\r\n\r\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\r\n      //We only need to change the Z of our bounds so we are getting the Z from the current projection point\r\n      const worldProjectionPointIndex = transformWorldToIndex(\r\n        imageData,\r\n        projectionPoint\r\n      );\r\n\r\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\r\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\r\n      worldPos1Index[2] = Math.floor(worldProjectionPointIndex[2]);\r\n\r\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\r\n\r\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\r\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\r\n      worldPos2Index[2] = Math.floor(worldProjectionPointIndex[2]);\r\n\r\n      // Check if one of the indexes are inside the volume, this then gives us\r\n      // Some area to do stats over.\r\n\r\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\r\n        this.isHandleOutsideImage = false;\r\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\r\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\r\n\r\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\r\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\r\n\r\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\r\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\r\n\r\n        const boundsIJK = [\r\n          [iMin, iMax],\r\n          [jMin, jMax],\r\n          [kMin, kMax],\r\n        ] as [Types.Point2, Types.Point2, Types.Point2];\r\n\r\n        const pointsInShape = pointInShapeCallback(\r\n          imageData,\r\n          () => true,\r\n          null,\r\n          boundsIJK\r\n        );\r\n\r\n        //@ts-ignore\r\n        pointsInsideVolume.push(pointsInShape);\r\n      }\r\n    }\r\n    data.cachedStats.pointsInVolume = pointsInsideVolume;\r\n  }\r\n\r\n  _calculateCachedStatsTool(annotation, enabledElement) {\r\n    const data = annotation.data;\r\n    const { viewport } = enabledElement;\r\n\r\n    const { cachedStats } = data;\r\n    const targetId = this.getTargetId(viewport);\r\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\r\n\r\n    // Todo: this shouldn't be here, this is a performance issue\r\n    // Since we are extending the RectangleROI class, we need to\r\n    // bring the logic for handle to some cachedStats calculation\r\n    this._computeProjectionPoints(annotation, imageVolume);\r\n\r\n    annotation.invalidated = false;\r\n\r\n    // Dispatching annotation modified\r\n    triggerAnnotationModified(annotation, viewport.element);\r\n\r\n    return cachedStats;\r\n  }\r\n\r\n  /**\r\n   * it is used to draw the rectangleROIStartEnd annotation in each\r\n   * request animation frame.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n    const { viewport } = enabledElement;\r\n\r\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const sliceIndex = viewport.getCurrentImageIdIndex();\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[\r\n        i\r\n      ] as RectangleROIStartEndThresholdAnnotation;\r\n      const { annotationUID, data } = annotation;\r\n      const { startSlice, endSlice } = data;\r\n      const { points, activeHandleIndex } = data.handles;\r\n\r\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\r\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\r\n      const color = 'rgb(255, 255, 255)'\r\n      // range of slices to render based on the start and end slice, like\r\n      // np.arange\r\n\r\n      // if indexIJK is outside the start/end slice, we don't render\r\n      if (\r\n        sliceIndex < Math.min(startSlice, endSlice) ||\r\n        sliceIndex > Math.max(startSlice, endSlice)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\r\n\r\n      if (annotation.invalidated) {\r\n        this._throttledCalculateCachedStats(annotation, enabledElement);\r\n      }\r\n\r\n      // if it is inside the start/end slice, but not exactly the first or\r\n      // last slice, we render the line in dash, but not the handles\r\n      let firstOrLastSlice = false;\r\n      if (sliceIndex === startSlice || sliceIndex === endSlice) {\r\n        firstOrLastSlice = true;\r\n      }\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n\r\n      let activeHandleCanvasCoords;\r\n\r\n      if (!isAnnotationVisible(annotationUID)) {\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        !isAnnotationLocked(annotation) &&\r\n        !this.editData &&\r\n        activeHandleIndex !== null &&\r\n        firstOrLastSlice\r\n      ) {\r\n        // Not locked or creating and hovering over handle, so render handle.\r\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\r\n      }\r\n\r\n      if (activeHandleCanvasCoords) {\r\n        const handleGroupUID = '0';\r\n\r\n        drawHandlesSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          handleGroupUID,\r\n          activeHandleCanvasCoords,\r\n          {\r\n            color,\r\n          }\r\n        );\r\n      }\r\n\r\n      let lineDashToUse = lineDash;\r\n\r\n      if (!firstOrLastSlice) {\r\n        lineDashToUse = 2;\r\n      }\r\n\r\n      const rectangleUID = '0';\r\n      drawRectSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        rectangleUID,\r\n        canvasCoordinates[0],\r\n        canvasCoordinates[3],\r\n        {\r\n          color,\r\n          lineDash: lineDashToUse,\r\n          lineWidth,\r\n        }\r\n      );\r\n\r\n      renderStatus = true;\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  _getEndSliceIndex(\r\n    imageVolume: Types.IImageVolume,\r\n    worldPos: Types.Point3,\r\n    spacingInNormal: number,\r\n    viewPlaneNormal: Types.Point3\r\n  ): number | undefined {\r\n    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\r\n\r\n    // get end position by moving from worldPos in the direction of viewplaneNormal\r\n    // with amount of numSlicesToPropagate * spacingInNormal\r\n    const endPos = vec3.create();\r\n    vec3.scaleAndAdd(\r\n      endPos,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      numSlicesToPropagate * spacingInNormal\r\n    );\r\n\r\n    const halfSpacingInNormalDirection = spacingInNormal / 2;\r\n    // Loop through imageIds of the imageVolume and find the one that is closest to endPos\r\n    const { imageIds } = imageVolume;\r\n    let imageIdIndex;\r\n    for (let i = 0; i < imageIds.length; i++) {\r\n      const imageId = imageIds[i];\r\n\r\n      const { imagePositionPatient } = metaData.get(\r\n        'imagePlaneModule',\r\n        imageId\r\n      );\r\n\r\n      const dir = vec3.create();\r\n      vec3.sub(dir, endPos, imagePositionPatient);\r\n\r\n      const dot = vec3.dot(dir, viewPlaneNormal);\r\n\r\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\r\n        imageIdIndex = i;\r\n      }\r\n    }\r\n\r\n    return imageIdIndex;\r\n  }\r\n}\r\n\r\nRectangleROIStartEndThresholdTool.toolName = 'RectangleROIStartEndThreshold';\r\nexport default RectangleROIStartEndThresholdTool;\r\n","import {\r\n  utilities as csUtils,\r\n  cache,\r\n  getEnabledElement,\r\n  StackViewport,\r\n  eventTarget,\r\n  Enums,\r\n} from '@cornerstonejs/core';\r\nimport { vec3, vec2 } from 'gl-matrix';\r\n\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport type {\r\n  PublicToolProps,\r\n  ToolProps,\r\n  EventTypes,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\nimport { BaseTool } from '../base';\r\nimport {\r\n  fillInsideSphere,\r\n  thresholdInsideSphere,\r\n  replaceInsideSphere\r\n} from './strategies/fillSphere';\r\nimport { eraseInsideSphere } from './strategies/eraseSphere';\r\nimport {\r\n  thresholdInsideCircle,\r\n  fillInsideCircle,\r\n  replaceInsideCircle\r\n} from './strategies/fillCircle';\r\nimport { eraseInsideCircle } from './strategies/eraseCircle';\r\nimport {\r\n  Events,\r\n  ToolModes,\r\n  SegmentationRepresentations,\r\n  StrategyCallbacks,\r\n} from '../../enums';\r\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\r\nimport {\r\n  resetElementCursor,\r\n  hideElementCursor,\r\n} from '../../cursors/elementCursor';\r\n\r\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\r\nimport {\r\n  config as segmentationConfig,\r\n  segmentLocking,\r\n  segmentIndex as segmentIndexController,\r\n  state as segmentationState,\r\n  activeSegmentation,\r\n} from '../../stateManagement/segmentation';\r\nimport {\r\n  LabelmapSegmentationDataVolume,\r\n  LabelmapSegmentationDataStack,\r\n} from '../../types/LabelmapTypes';\r\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\r\n\r\n/**\r\n * A type for preview data/information, used to setup previews on hover, or\r\n * maintain the preview information.\r\n */\r\nexport type PreviewData = {\r\n  /**\r\n   *  The preview data returned from the strategy\r\n   */\r\n  preview: unknown;\r\n  timer?: number;\r\n  timerStart: number;\r\n  startPoint: Types.Point2;\r\n  element: HTMLDivElement;\r\n  isDrag: boolean;\r\n};\r\n\r\n/**\r\n * @public\r\n */\r\nclass BrushTool extends BaseTool {\r\n  static toolName;\r\n  private _editData: {\r\n    segmentsLocked: number[]; //\r\n    segmentationRepresentationUID?: string;\r\n    imageIdReferenceMap?: Map<string, string>;\r\n    volumeId?: string;\r\n    referencedVolumeId?: string;\r\n  } | null;\r\n  private _hoverData?: {\r\n    brushCursor: any;\r\n    segmentationId: string;\r\n    segmentIndex: number;\r\n    segmentationRepresentationUID: string;\r\n    segmentColor: [number, number, number, number];\r\n    viewportIdsToRender: string[];\r\n    centerCursorInWorld?: Array<number>;\r\n  };\r\n\r\n  private _previewData?: PreviewData = {\r\n    preview: null,\r\n    element: null,\r\n    timerStart: 0,\r\n    timer: null,\r\n    startPoint: [NaN, NaN],\r\n    isDrag: false,\r\n  };\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        strategies: {\r\n          FILL_INSIDE_CIRCLE: fillInsideCircle,\r\n          FILL_INSIDE_SPHERE: fillInsideSphere,\r\n          THRESHOLD_INSIDE_CIRCLE: thresholdInsideCircle,\r\n          THRESHOLD_INSIDE_SPHERE: thresholdInsideSphere,\r\n          ERASE_INSIDE_CIRCLE: eraseInsideCircle,\r\n          ERASE_INSIDE_SPHERE: eraseInsideSphere,\r\n          REPLACE_INSIDE_CIRCLE: replaceInsideCircle,\r\n          REPLACE_INSIDE_SPHERE: replaceInsideSphere,\r\n        },\r\n        strategySpecificConfiguration: {\r\n          THRESHOLD: {\r\n            threshold: [-1000, 3095],\r\n          },\r\n          REPLACE: {\r\n            targetSegmentIndex: 0,\r\n          }\r\n        },\r\n        defaultStrategy: 'FILL_INSIDE_CIRCLE',\r\n        activeStrategy: 'FILL_INSIDE_CIRCLE',\r\n        thresholdVolumeId: null,\r\n        brushSize: 10,\r\n        eraseFocusIndex: 0,\r\n        preview: {\r\n          // Have to enable the preview to use this\r\n          enabled: false,\r\n          previewColors: {},\r\n          // The time before showing a preview\r\n          previewTimeMs: 250,\r\n          // The distance to move to show a preview before preview time expired\r\n          previewMoveDistance: 8,\r\n          // The distance to drag before being considered a drag rather than click\r\n          dragMoveDistance: 4,\r\n          // The time to consider a mouse click a drag when moved less than dragMoveDistance\r\n          dragTimeMs: 500,\r\n        },\r\n        actions: {\r\n          [StrategyCallbacks.AcceptPreview]: {\r\n            method: StrategyCallbacks.AcceptPreview,\r\n            bindings: [\r\n              {\r\n                key: 'Enter',\r\n              },\r\n            ],\r\n          },\r\n          [StrategyCallbacks.RejectPreview]: {\r\n            method: StrategyCallbacks.RejectPreview,\r\n            bindings: [\r\n              {\r\n                key: 'Escape',\r\n              },\r\n            ],\r\n          },\r\n        },\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  onSetToolPassive = (evt) => {\r\n    this.disableCursor();\r\n  };\r\n\r\n  onSetToolEnabled = () => {\r\n    this.disableCursor();\r\n  };\r\n\r\n  onSetToolDisabled = (evt) => {\r\n    this.disableCursor();\r\n  };\r\n\r\n  private disableCursor() {\r\n    this._hoverData = undefined;\r\n    this.rejectPreview();\r\n  }\r\n\r\n  createEditData(element) {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    const toolGroupId = this.toolGroupId;\r\n\r\n    const activeSegmentationRepresentation =\r\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\r\n    if (!activeSegmentationRepresentation) {\r\n      throw new Error(\r\n        'No active segmentation detected, create a segmentation representation before using the brush tool'\r\n      );\r\n    }\r\n\r\n    const { segmentationId, type, segmentationRepresentationUID } =\r\n      activeSegmentationRepresentation;\r\n\r\n    if (type === SegmentationRepresentations.Contour) {\r\n      throw new Error('Not implemented yet');\r\n    }\r\n\r\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\r\n\r\n    const { representationData } =\r\n      segmentationState.getSegmentation(segmentationId);\r\n\r\n    const labelmapData =\r\n      representationData[SegmentationRepresentations.Labelmap];\r\n\r\n    if (isVolumeSegmentation(labelmapData, viewport)) {\r\n      const { volumeId } = representationData[\r\n        type\r\n      ] as LabelmapSegmentationDataVolume;\r\n      const actors = viewport.getActors();\r\n\r\n      const isStackViewport = viewport instanceof StackViewport;\r\n\r\n      if (isStackViewport) {\r\n        const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\r\n          detail: {\r\n            type: 'Segmentation',\r\n            message: 'Cannot perform brush operation on the selected viewport',\r\n          },\r\n          cancelable: true,\r\n        });\r\n        eventTarget.dispatchEvent(event);\r\n        return null;\r\n      }\r\n\r\n      // we used to take the first actor here but we should take the one that is\r\n      // probably the same size as the segmentation volume\r\n      const volumes = actors.map((actorEntry) =>\r\n        cache.getVolume(actorEntry.referenceId)\r\n      );\r\n\r\n      const segmentationVolume = cache.getVolume(volumeId);\r\n\r\n      const referencedVolumeIdToThreshold =\r\n        volumes.find((volume) =>\r\n          csUtils.isEqual(volume.dimensions, segmentationVolume.dimensions)\r\n        )?.volumeId || volumes[0]?.volumeId;\r\n\r\n      return {\r\n        volumeId,\r\n        referencedVolumeId:\r\n          this.configuration.thresholdVolumeId ?? referencedVolumeIdToThreshold,\r\n        segmentsLocked,\r\n        segmentationRepresentationUID,\r\n      };\r\n    } else {\r\n      const { imageIdReferenceMap } =\r\n        labelmapData as LabelmapSegmentationDataStack;\r\n\r\n      const currentImageId = viewport.getCurrentImageId();\r\n\r\n      if (!imageIdReferenceMap.get(currentImageId)) {\r\n        // if there is no stack segmentation slice for the current image\r\n        // we should not allow the user to perform any operation\r\n        return;\r\n      }\r\n\r\n      // here we should identify if we can perform sphere manipulation\r\n      // for these stack of images, if the metadata is not present\r\n      // to create a volume or if there are inconsistencies between\r\n      // the image metadata we should not allow the sphere manipulation\r\n      // and should throw an error or maybe simply just allow circle manipulation\r\n      // and not sphere manipulation\r\n      if (this.configuration.activeStrategy.includes('SPHERE')) {\r\n        throw new Error(\r\n          'Sphere manipulation is not supported for stacks of image segmentations yet'\r\n        );\r\n        // Todo: add sphere (volumetric) manipulation support for stacks of images\r\n        // we should basically check if the stack constructs a valid volume\r\n        // meaning all the metadata is present and consistent\r\n        // then we use a VoxelManager mapping to map a volume like appearance\r\n        // for the stack data.\r\n        // csUtils.isValidVolume(referencedImageIds\r\n      }\r\n\r\n      return {\r\n        imageIdReferenceMap,\r\n        segmentsLocked,\r\n        segmentationRepresentationUID,\r\n      };\r\n    }\r\n  }\r\n\r\n  preMouseDownCallback = (\r\n    evt: EventTypes.MouseDownActivateEventType\r\n  ): boolean => {\r\n    const eventData = evt.detail;\r\n    const { element } = eventData;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    this._editData = this.createEditData(element);\r\n    this._activateDraw(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    // This might be a mouse down\r\n    this._previewData.isDrag = false;\r\n    this._previewData.timerStart = Date.now();\r\n\r\n    const hoverData = this._hoverData || this.createHoverData(element);\r\n\r\n    triggerAnnotationRenderForViewportUIDs(\r\n      renderingEngine,\r\n      hoverData.viewportIdsToRender\r\n    );\r\n\r\n    this.applyActiveStrategyCallback(\r\n      enabledElement,\r\n      this.getOperationData(element),\r\n      StrategyCallbacks.OnInteractionStart\r\n    );\r\n\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * This call will be made when the mouse moves and the tool is active, but\r\n   * not actually drawing at the moment.\r\n   * The behavior is:\r\n   *    1. Update the cursor\r\n   *    2. Call the active strategy event 'preview' and 'rejectPreview'\r\n   *       on the mouse cursor position on a periodic basis to create a preview\r\n   *       when configured to do so.\r\n   *\r\n   * The preview will be shown after the mouse has been stationary for 250 ms.\r\n   * Any preview will be cancelled (immediately) after moving outside the center\r\n   * distance.\r\n   * As well, if the mouse moves but stays inside the center area for 250 ms,\r\n   * then the cancel will happen with a new preview being added.\r\n   *\r\n   * See mouse up details for how the preview gets accepted.\r\n   *\r\n   * The preview also needs to be cancelled on changing tools.\r\n   */\r\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    if (this.mode === ToolModes.Active) {\r\n      this.updateCursor(evt);\r\n      if (!this.configuration.preview.enabled) {\r\n        return;\r\n      }\r\n      const { previewTimeMs, previewMoveDistance, dragMoveDistance } =\r\n        this.configuration.preview;\r\n      const { currentPoints, element } = evt.detail;\r\n      const { canvas } = currentPoints;\r\n\r\n      const { preview, startPoint, timer, timerStart, isDrag } =\r\n        this._previewData;\r\n      const delta = vec2.distance(canvas, startPoint);\r\n      const time = Date.now() - timerStart;\r\n      if (\r\n        delta > previewMoveDistance ||\r\n        (time > previewTimeMs && delta > dragMoveDistance)\r\n      ) {\r\n        if (timer) {\r\n          window.clearTimeout(timer);\r\n          this._previewData.timer = null;\r\n        }\r\n        if (preview && !isDrag) {\r\n          this.rejectPreview(element);\r\n        }\r\n      }\r\n      if (!this._previewData.timer) {\r\n        const timer = window.setTimeout(this.previewCallback, 250);\r\n        Object.assign(this._previewData, {\r\n          timerStart: Date.now(),\r\n          timer,\r\n          startPoint: canvas,\r\n          element,\r\n        });\r\n      }\r\n    }\r\n  };\r\n\r\n  previewCallback = () => {\r\n    if (this._previewData.preview) {\r\n      return;\r\n    }\r\n    this._previewData.timer = null;\r\n    this._previewData.preview = this.applyActiveStrategyCallback(\r\n      getEnabledElement(this._previewData.element),\r\n      this.getOperationData(this._previewData.element),\r\n      StrategyCallbacks.Preview\r\n    );\r\n  };\r\n\r\n  private createHoverData(element, centerCursorInWorld?) {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    const viewportIdsToRender = [viewport.id];\r\n\r\n    const {\r\n      segmentIndex,\r\n      segmentationId,\r\n      segmentationRepresentationUID,\r\n      segmentColor,\r\n    } = this.getActiveSegmentationData() || {};\r\n\r\n    // Center of circle in canvas Coordinates\r\n    const brushCursor = {\r\n      metadata: {\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\r\n        referencedImageId: '',\r\n        toolName: this.getToolName(),\r\n        segmentColor,\r\n      },\r\n      data: {},\r\n    };\r\n\r\n    return {\r\n      brushCursor,\r\n      centerCursorInWorld,\r\n      segmentIndex,\r\n      segmentationId,\r\n      segmentationRepresentationUID,\r\n      segmentColor,\r\n      viewportIdsToRender,\r\n    };\r\n  }\r\n\r\n  private getActiveSegmentationData() {\r\n    const toolGroupId = this.toolGroupId;\r\n\r\n    const activeSegmentationRepresentation =\r\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\r\n    if (!activeSegmentationRepresentation) {\r\n      console.warn(\r\n        'No active segmentation detected, create one before using the brush tool'\r\n      );\r\n      return;\r\n    }\r\n\r\n    const { segmentationRepresentationUID, segmentationId } =\r\n      activeSegmentationRepresentation;\r\n    const segmentIndex =\r\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\r\n\r\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\r\n      toolGroupId,\r\n      segmentationRepresentationUID,\r\n      segmentIndex\r\n    );\r\n\r\n    return {\r\n      segmentIndex,\r\n      segmentationId,\r\n      segmentationRepresentationUID,\r\n      segmentColor,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Updates the cursor position and whether it is showing or not.\r\n   * Can be over-ridden to add more cursor details or a preview.\r\n   */\r\n  protected updateCursor(evt: EventTypes.InteractionEventType) {\r\n    const eventData = evt.detail;\r\n    const { element } = eventData;\r\n    const { currentPoints } = eventData;\r\n    const centerCursorInWorld = currentPoints.world;\r\n    this._hoverData = this.createHoverData(element, centerCursorInWorld);\r\n\r\n    this._calculateCursor(element, centerCursorInWorld);\r\n\r\n    if (!this._hoverData) {\r\n      return;\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportUIDs(\r\n      getEnabledElement(element).renderingEngine,\r\n      this._hoverData.viewportIdsToRender\r\n    );\r\n  }\r\n\r\n  private _dragCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventData = evt.detail;\r\n    const { element, currentPoints } = eventData;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    this.updateCursor(evt);\r\n\r\n    const { viewportIdsToRender } = this._hoverData;\r\n\r\n    triggerAnnotationRenderForViewportUIDs(\r\n      renderingEngine,\r\n      viewportIdsToRender\r\n    );\r\n\r\n    const delta = vec2.distance(\r\n      currentPoints.canvas,\r\n      this._previewData.startPoint\r\n    );\r\n    const { dragTimeMs, dragMoveDistance } = this.configuration.preview;\r\n    if (\r\n      !this._previewData.isDrag &&\r\n      this._previewData.preview &&\r\n      Date.now() - this._previewData.timerStart < dragTimeMs &&\r\n      delta < dragMoveDistance\r\n    ) {\r\n      // If we are showing a preview, then don't start dragging quite immediately\r\n      // so that click up can accept the preview.\r\n      return;\r\n    }\r\n\r\n    this._previewData.preview = this.applyActiveStrategy(\r\n      enabledElement,\r\n      this.getOperationData(element)\r\n    );\r\n    this._previewData.element = element;\r\n    // Add a bit of time to the timer start so small accidental movements dont\r\n    // cause issues on clicking\r\n    this._previewData.timerStart = Date.now() + dragTimeMs;\r\n    this._previewData.isDrag = true;\r\n    this._previewData.startPoint = currentPoints.canvas;\r\n  };\r\n\r\n  protected getOperationData(element?) {\r\n    const editData = this._editData || this.createEditData(element);\r\n\r\n    const {\r\n      segmentIndex,\r\n      segmentationId,\r\n      segmentationRepresentationUID,\r\n      brushCursor,\r\n    } = this._hoverData || this.createHoverData(element);\r\n    const { data, metadata = {} } = brushCursor || {};\r\n    const { viewPlaneNormal, viewUp } = metadata;\r\n    const operationData = {\r\n      ...editData,\r\n      points: data?.handles?.points,\r\n      segmentIndex,\r\n      previewColors: this.configuration.preview.enabled\r\n        ? this.configuration.preview.previewColors\r\n        : null,\r\n      viewPlaneNormal,\r\n      toolGroupId: this.toolGroupId,\r\n      segmentationId,\r\n      segmentationRepresentationUID,\r\n      viewUp,\r\n      strategySpecificConfiguration:\r\n        this.configuration.strategySpecificConfiguration,\r\n      eraseFocusIndex: this.configuration.eraseFocusIndex,\r\n      // Provide the preview information so that data can be used directly\r\n      preview: this._previewData?.preview,\r\n    };\r\n    return operationData;\r\n  }\r\n\r\n  private _calculateCursor(element, centerCursorInWorld) {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const camera = viewport.getCamera();\r\n    const { brushSize } = this.configuration;\r\n\r\n    const viewUp = vec3.fromValues(\r\n      camera.viewUp[0],\r\n      camera.viewUp[1],\r\n      camera.viewUp[2]\r\n    );\r\n\r\n    const viewPlaneNormal = vec3.fromValues(\r\n      camera.viewPlaneNormal[0],\r\n      camera.viewPlaneNormal[1],\r\n      camera.viewPlaneNormal[2]\r\n    );\r\n    const viewRight = vec3.create();\r\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\r\n\r\n    const bottomCursorInWorld = vec3.create();\r\n    const topCursorInWorld = vec3.create();\r\n    const leftCursorInWorld = vec3.create();\r\n    const rightCursorInWorld = vec3.create();\r\n\r\n    // Calculate the bottom and top points of the circle in world coordinates\r\n    for (let i = 0; i <= 2; i++) {\r\n      bottomCursorInWorld[i] = centerCursorInWorld[i] - viewUp[i] * brushSize;\r\n      topCursorInWorld[i] = centerCursorInWorld[i] + viewUp[i] * brushSize;\r\n      leftCursorInWorld[i] = centerCursorInWorld[i] - viewRight[i] * brushSize;\r\n      rightCursorInWorld[i] = centerCursorInWorld[i] + viewRight[i] * brushSize;\r\n    }\r\n\r\n    if (!this._hoverData) {\r\n      return;\r\n    }\r\n\r\n    const { brushCursor } = this._hoverData;\r\n    const { data } = brushCursor;\r\n\r\n    if (data.handles === undefined) {\r\n      data.handles = {};\r\n    }\r\n\r\n    data.handles.points = [\r\n      bottomCursorInWorld,\r\n      topCursorInWorld,\r\n      leftCursorInWorld,\r\n      rightCursorInWorld,\r\n    ];\r\n\r\n    const activeStrategy = this.configuration.activeStrategy;\r\n    const strategy = this.configuration.strategies[activeStrategy];\r\n\r\n    // Note: i don't think this is the best way to implement this\r\n    // but don't think we have a better way to do it for now\r\n    if (typeof strategy.computeInnerCircleRadius === 'function') {\r\n      strategy.computeInnerCircleRadius({\r\n        configuration: this.configuration,\r\n        viewport,\r\n      });\r\n    }\r\n\r\n    data.invalidated = false;\r\n  }\r\n\r\n  /**\r\n   * The end callback call is made when the mouse is released.  This will\r\n   * perform another active strategy render event to render the final position.\r\n   * As well, the finish strategy callback will be made during this time.\r\n   */\r\n  private _endCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventData = evt.detail;\r\n    const { element } = eventData;\r\n    const enabledElement = getEnabledElement(element);\r\n\r\n    const operationData = this.getOperationData(element);\r\n    // Don't re-fill when the preview is showing and the user clicks again\r\n    // otherwise the new area of hover may get filled, which is unexpected\r\n    if (!this._previewData.preview && !this._previewData.isDrag) {\r\n      this.applyActiveStrategy(enabledElement, operationData);\r\n    }\r\n\r\n    this._deactivateDraw(element);\r\n\r\n    resetElementCursor(element);\r\n\r\n    this.updateCursor(evt);\r\n\r\n    this._editData = null;\r\n\r\n    this.applyActiveStrategyCallback(\r\n      enabledElement,\r\n      operationData,\r\n      StrategyCallbacks.OnInteractionEnd\r\n    );\r\n\r\n    if (!this._previewData.isDrag) {\r\n      this.acceptPreview(element);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Cancels any preview view being shown, resetting any segments being shown.\r\n   */\r\n  public rejectPreview(element = this._previewData.element) {\r\n    if (!element || !this._previewData.preview) {\r\n      return;\r\n    }\r\n    const enabledElement = getEnabledElement(element);\r\n    this.applyActiveStrategyCallback(\r\n      enabledElement,\r\n      this.getOperationData(element),\r\n      StrategyCallbacks.RejectPreview\r\n    );\r\n    this._previewData.preview = null;\r\n    this._previewData.isDrag = false;\r\n  }\r\n\r\n  /**\r\n   * Accepts a preview, marking it as the active segment.\r\n   */\r\n  public acceptPreview(element = this._previewData.element) {\r\n    if (!element) {\r\n      return;\r\n    }\r\n    const enabledElement = getEnabledElement(element);\r\n\r\n    this.applyActiveStrategyCallback(\r\n      enabledElement,\r\n      this.getOperationData(element),\r\n      StrategyCallbacks.AcceptPreview\r\n    );\r\n    this._previewData.isDrag = false;\r\n    this._previewData.preview = null;\r\n  }\r\n\r\n  /**\r\n   * Add event handlers for the modify event loop, and prevent default event propagation.\r\n   */\r\n  private _activateDraw = (element: HTMLDivElement): void => {\r\n    element.addEventListener(\r\n      Events.MOUSE_UP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._endCallback as EventListener\r\n    );\r\n  };\r\n\r\n  /**\r\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\r\n   */\r\n  private _deactivateDraw = (element: HTMLDivElement): void => {\r\n    element.removeEventListener(\r\n      Events.MOUSE_UP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_DRAG,\r\n      this._dragCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.MOUSE_CLICK,\r\n      this._endCallback as EventListener\r\n    );\r\n  };\r\n\r\n  public invalidateBrushCursor() {\r\n    if (this._hoverData === undefined) {\r\n      return;\r\n    }\r\n    const { data } = this._hoverData.brushCursor;\r\n\r\n    data.invalidated = true;\r\n\r\n    // Todo: figure out if other brush metadata (other than segment color) should get updated\r\n    // during the brush cursor invalidation\r\n    const { segmentColor } = this.getActiveSegmentationData() || {};\r\n    this._hoverData.brushCursor.metadata.segmentColor = segmentColor;\r\n  }\r\n\r\n  renderAnnotation(\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): void {\r\n    if (!this._hoverData) {\r\n      return;\r\n    }\r\n\r\n    const { viewport } = enabledElement;\r\n\r\n    const viewportIdsToRender = this._hoverData.viewportIdsToRender;\r\n\r\n    if (!viewportIdsToRender.includes(viewport.id)) {\r\n      return;\r\n    }\r\n\r\n    const brushCursor = this._hoverData.brushCursor;\r\n\r\n    if (brushCursor.data.invalidated === true) {\r\n      const { centerCursorInWorld } = this._hoverData;\r\n      const { element } = viewport;\r\n\r\n      // This can be set true when changing the brush size programmatically\r\n      // whilst the cursor is being rendered.\r\n      this._calculateCursor(element, centerCursorInWorld);\r\n    }\r\n\r\n    const toolMetadata = brushCursor.metadata;\r\n    if (!toolMetadata) {\r\n      return;\r\n    }\r\n\r\n    const annotationUID = toolMetadata.brushCursorUID;\r\n\r\n    const data = brushCursor.data;\r\n    const { points } = data.handles;\r\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n    const bottom = canvasCoordinates[0];\r\n    const top = canvasCoordinates[1];\r\n\r\n    const center = [\r\n      Math.floor((bottom[0] + top[0]) / 2),\r\n      Math.floor((bottom[1] + top[1]) / 2),\r\n    ];\r\n\r\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\r\n\r\n    const color = `rgb(${toolMetadata.segmentColor?.slice(0, 3) || [0, 0, 0]})`;\r\n\r\n    // If rendering engine has been destroyed while rendering\r\n    if (!viewport.getRenderingEngine()) {\r\n      console.warn('Rendering Engine has been destroyed');\r\n      return;\r\n    }\r\n\r\n    const circleUID = '0';\r\n    drawCircleSvg(\r\n      svgDrawingHelper,\r\n      annotationUID,\r\n      circleUID,\r\n      center as Types.Point2,\r\n      radius,\r\n      {\r\n        color,\r\n      }\r\n    );\r\n\r\n    const activeStrategy = this.configuration.activeStrategy;\r\n    const { dynamicRadiusInCanvas } = this.configuration\r\n      .strategySpecificConfiguration[activeStrategy] || {\r\n      dynamicRadiusInCanvas: 0,\r\n    };\r\n\r\n    if (dynamicRadiusInCanvas) {\r\n      const circleUID1 = '1';\r\n      drawCircleSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        circleUID1,\r\n        center as Types.Point2,\r\n        dynamicRadiusInCanvas,\r\n        {\r\n          color,\r\n        }\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nBrushTool.toolName = 'Brush';\r\nexport default BrushTool;\r\n","import {\r\n  StackViewport,\r\n  Types,\r\n  cache,\r\n  getEnabledElement,\r\n  utilities as csUtils,\r\n  metaData,\r\n  triggerEvent,\r\n  eventTarget,\r\n} from '@cornerstonejs/core';\r\n\r\nimport { vec3 } from 'gl-matrix';\r\nimport { Events } from '../../enums';\r\nimport {\r\n  addAnnotation,\r\n  removeAnnotation,\r\n  getAnnotations,\r\n} from '../../stateManagement/annotation/annotationState';\r\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\r\nimport {\r\n  drawCircle as drawCircleSvg,\r\n  drawHandles as drawHandlesSvg,\r\n} from '../../drawingSvg';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport throttle from '../../utilities/throttle';\r\nimport { AnnotationModifiedEventDetail } from '../../types/EventTypes';\r\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\r\nimport {\r\n  hideElementCursor,\r\n  resetElementCursor,\r\n} from '../../cursors/elementCursor';\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\nimport { triggerAnnotationCompleted } from '../../stateManagement/annotation/helpers/state';\r\nimport {\r\n  PublicToolProps,\r\n  ToolProps,\r\n  EventTypes,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\nimport { CircleROIStartEndThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\nimport CircleROITool from '../annotation/CircleROITool';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\nimport {\r\n  getCanvasCircleCorners,\r\n  getCanvasCircleRadius,\r\n} from '../../utilities/math/circle';\r\nimport { pointInEllipse } from '../../utilities/math/ellipse';\r\nimport { pointInShapeCallback } from '../../utilities';\r\n\r\nconst { transformWorldToIndex } = csUtils;\r\n\r\nclass CircleROIStartEndThresholdTool extends CircleROITool {\r\n  static toolName;\r\n\r\n  touchDragCallback: any;\r\n  mouseDragCallback: any;\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: Array<string>;\r\n    handleIndex?: number;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage = false;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        numSlicesToPropagate: 10,\r\n        calculatePointsInsideVolume: false,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n\r\n    this._throttledCalculateCachedStats = throttle(\r\n      this._calculateCachedStatsTool,\r\n      100,\r\n      { trailing: true }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the current imageId to create\r\n   * a CircleROI Annotation and stores it in the annotationManager\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    let referencedImageId, imageVolume, volumeId;\r\n    if (viewport instanceof StackViewport) {\r\n      throw new Error('Stack Viewport Not implemented');\r\n    } else {\r\n      const targetId = this.getTargetId(viewport);\r\n      volumeId = csUtils.getVolumeId(targetId);\r\n      imageVolume = cache.getVolume(volumeId);\r\n\r\n      referencedImageId = csUtils.getClosestImageId(\r\n        imageVolume,\r\n        worldPos,\r\n        viewPlaneNormal\r\n      );\r\n    }\r\n\r\n    // if (!referencedImageId) {\r\n    //   throw new Error('This tool does not work on non-acquisition planes');\r\n    // }\r\n\r\n    const spacingInNormal = csUtils.getSpacingInNormalDirection(\r\n      imageVolume,\r\n      viewPlaneNormal\r\n    );\r\n\r\n    const newStartIndex = this._getStartSliceIndex(\r\n      imageVolume,\r\n      worldPos,\r\n      spacingInNormal,\r\n      viewPlaneNormal\r\n    );\r\n\r\n    // We cannot newStartIndex add numSlicesToPropagate to startIndex because\r\n    // the order of imageIds can be from top to bottom or bottom to top and\r\n    // we want to make sure it is always propagated in the direction of the\r\n    // view and also to make sure we don't go out of bounds.\r\n    const endIndex = this._getEndSliceIndex(\r\n      imageVolume,\r\n      worldPos,\r\n      spacingInNormal,\r\n      viewPlaneNormal\r\n    );\r\n\r\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n\r\n    const annotation = {\r\n      highlighted: true,\r\n      invalidated: true,\r\n      metadata: {\r\n        toolName: this.getToolName(),\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID,\r\n        referencedImageId,\r\n        volumeId,\r\n        spacingInNormal,\r\n        enabledElement,\r\n      },\r\n      data: {\r\n        label: '',\r\n        startSlice: newStartIndex,\r\n        endSlice: endIndex,\r\n\r\n        handles: {\r\n          textBox: {\r\n            hasMoved: false,\r\n            worldPosition: null,\r\n            worldBoundingBox: null,\r\n          },\r\n          points: [[...worldPos], [...worldPos]] as [\r\n            Types.Point3, // center\r\n            Types.Point3 // end\r\n          ],\r\n          activeHandleIndex: null,\r\n        },\r\n        cachedStats: {\r\n          pointsInVolume: [],\r\n          projectionPoints: [],\r\n        },\r\n        labelmapUID: null,\r\n      },\r\n    };\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n    };\r\n\r\n    this._activateDraw(element);\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  };\r\n\r\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (newAnnotation && !hasMoved) {\r\n      return;\r\n    }\r\n\r\n    // Circle ROI tool should reset its highlight to false on mouse up (as opposed\r\n    // to other tools that keep it highlighted until the user moves. The reason\r\n    // is that we use top-left and bottom-right handles to define the circle,\r\n    // and they are by definition not in the circle on mouse up.\r\n    annotation.highlighted = false;\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateModify(element);\r\n    this._deactivateDraw(element);\r\n\r\n    resetElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n\r\n    if (\r\n      this.isHandleOutsideImage &&\r\n      this.configuration.preventHandleOutsideImage\r\n    ) {\r\n      removeAnnotation(annotation.annotationUID);\r\n    }\r\n\r\n    const targetId = this.getTargetId(enabledElement.viewport);\r\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\r\n\r\n    if (this.configuration.calculatePointsInsideVolume) {\r\n      this._computePointsInsideVolume(annotation, imageVolume, enabledElement);\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(\r\n      enabledElement.renderingEngine,\r\n      viewportIdsToRender\r\n    );\r\n\r\n    if (newAnnotation) {\r\n      triggerAnnotationCompleted(annotation);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the circleROI annotation in each\r\n   * request animation frame. It calculates the updated cached statistics if\r\n   * data is invalidated and cache it.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n    const { viewport } = enabledElement;\r\n\r\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const sliceIndex = viewport.getCurrentImageIdIndex();\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[i] as CircleROIStartEndThresholdAnnotation;\r\n      const { annotationUID, data } = annotation;\r\n      const { startSlice, endSlice } = data;\r\n      const { points, activeHandleIndex } = data.handles;\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\r\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\r\n      const color = this.getStyle('color', styleSpecifier, annotation);\r\n\r\n      const canvasCoordinates = points.map((p) =>\r\n        viewport.worldToCanvas(p)\r\n      ) as [Types.Point2, Types.Point2];\r\n      const center = canvasCoordinates[0];\r\n\r\n      const radius = getCanvasCircleRadius(canvasCoordinates);\r\n      const { centerPointRadius } = this.configuration;\r\n\r\n      // range of slices to render based on the start and end slice, like\r\n      // np.arange\r\n\r\n      // if indexIJK is outside the start/end slice, we don't render\r\n      if (\r\n        sliceIndex < Math.min(startSlice, endSlice) ||\r\n        sliceIndex > Math.max(startSlice, endSlice)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\r\n\r\n      if (annotation.invalidated) {\r\n        this._throttledCalculateCachedStats(annotation, enabledElement);\r\n      }\r\n\r\n      const middleSlice = Math.round((startSlice + endSlice) / 2);\r\n      // if it is inside the start/end slice, but not exactly the first or\r\n      // last slice, we render the line in dash, but not the handles\r\n\r\n      let isMiddleSlice = false;\r\n      if (sliceIndex === middleSlice) {\r\n        isMiddleSlice = true;\r\n      }\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n\r\n      let activeHandleCanvasCoords;\r\n\r\n      if (!isAnnotationVisible(annotationUID)) {\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        !isAnnotationLocked(annotation) &&\r\n        !this.editData &&\r\n        activeHandleIndex !== null &&\r\n        isMiddleSlice\r\n      ) {\r\n        // Not locked or creating and hovering over handle, so render handle.\r\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\r\n      }\r\n\r\n      if (activeHandleCanvasCoords) {\r\n        const handleGroupUID = '0';\r\n\r\n        drawHandlesSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          handleGroupUID,\r\n          activeHandleCanvasCoords,\r\n          {\r\n            color,\r\n          }\r\n        );\r\n      }\r\n\r\n      let lineWidthToUse = lineWidth;\r\n\r\n      if (isMiddleSlice) {\r\n        lineWidthToUse = 3;\r\n      }\r\n\r\n      const circleUID = '0';\r\n      drawCircleSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        circleUID,\r\n        center,\r\n        radius,\r\n        {\r\n          color,\r\n          lineDash,\r\n          lineWidth: lineWidthToUse,\r\n        }\r\n      );\r\n\r\n      // draw center point, if \"centerPointRadius\" configuration is valid.\r\n      if (centerPointRadius > 0) {\r\n        if (radius > 3 * centerPointRadius) {\r\n          drawCircleSvg(\r\n            svgDrawingHelper,\r\n            annotationUID,\r\n            `${circleUID}-center`,\r\n            center,\r\n            centerPointRadius,\r\n            {\r\n              color,\r\n              lineDash,\r\n              lineWidth,\r\n            }\r\n          );\r\n        }\r\n      }\r\n\r\n      renderStatus = true;\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  // Todo: make it work for planes other than acquisition planes\r\n  _computeProjectionPoints(\r\n    annotation: CircleROIStartEndThresholdAnnotation,\r\n    imageVolume: Types.IImageVolume\r\n  ): void {\r\n    const { data, metadata } = annotation;\r\n    const { viewPlaneNormal, spacingInNormal } = metadata;\r\n    const { imageData } = imageVolume;\r\n    const { startSlice, endSlice } = data;\r\n    const { points } = data.handles;\r\n\r\n    const startIJK = transformWorldToIndex(imageData, points[0]);\r\n    startIJK[2] = startSlice;\r\n\r\n    if (startIJK[2] !== startSlice) {\r\n      throw new Error('Start slice does not match');\r\n    }\r\n\r\n    // substitute the end slice index 2 with startIJK index 2\r\n    const endIJK = vec3.fromValues(startIJK[0], startIJK[1], endSlice);\r\n\r\n    const startWorld = vec3.create();\r\n    imageData.indexToWorldVec3(startIJK, startWorld);\r\n\r\n    const endWorld = vec3.create();\r\n    imageData.indexToWorldVec3(endIJK, endWorld);\r\n\r\n    // distance between start and end slice in the world coordinate\r\n    const distance = vec3.distance(startWorld, endWorld);\r\n\r\n    // for each point inside points, navigate in the direction of the viewPlaneNormal\r\n    // with amount of spacingInNormal, and calculate the next slice until we reach the distance\r\n    const newProjectionPoints = [];\r\n    for (let dist = 0; dist < distance; dist += spacingInNormal) {\r\n      newProjectionPoints.push(\r\n        points.map((point) => {\r\n          const newPoint = vec3.create();\r\n          //@ts-ignore\r\n          vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);\r\n          return Array.from(newPoint);\r\n        })\r\n      );\r\n    }\r\n\r\n    data.cachedStats.projectionPoints = newProjectionPoints;\r\n  }\r\n\r\n  _computePointsInsideVolume(annotation, imageVolume, enabledElement) {\r\n    const { data } = annotation;\r\n    const { viewport } = enabledElement;\r\n    const projectionPoints = data.cachedStats.projectionPoints;\r\n\r\n    const pointsInsideVolume: Types.Point3[][] = [[]];\r\n\r\n    for (let i = 0; i < projectionPoints.length; i++) {\r\n      // If image does not exists for the targetId, skip. This can be due\r\n      // to various reasons such as if the target was a volumeViewport, and\r\n      // the volumeViewport has been decached in the meantime.\r\n      if (!imageVolume) {\r\n        continue;\r\n      }\r\n\r\n      const centerWorld = projectionPoints[i][0];\r\n      const canvasCoordinates = projectionPoints[i].map((p) =>\r\n        viewport.worldToCanvas(p)\r\n      );\r\n\r\n      const [topLeftCanvas, bottomRightCanvas] = <Array<Types.Point2>>(\r\n        getCanvasCircleCorners(canvasCoordinates)\r\n      );\r\n\r\n      const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\r\n      const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\r\n\r\n      const worldPos1 = topLeftWorld;\r\n      const worldPos2 = bottomRightWorld;\r\n\r\n      const { dimensions, imageData } = imageVolume;\r\n\r\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\r\n      const worldCenterIndex = transformWorldToIndex(imageData, centerWorld);\r\n\r\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\r\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\r\n      worldPos1Index[2] = Math.floor(worldCenterIndex[2]);\r\n\r\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\r\n\r\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\r\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\r\n      worldPos2Index[2] = Math.floor(worldCenterIndex[2]);\r\n\r\n      // Check if one of the indexes are inside the volume, this then gives us\r\n      // Some area to do stats over.\r\n\r\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\r\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\r\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\r\n\r\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\r\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\r\n\r\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\r\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\r\n\r\n        const boundsIJK = [\r\n          [iMin, iMax],\r\n          [jMin, jMax],\r\n          [kMin, kMax],\r\n        ] as [Types.Point2, Types.Point2, Types.Point2];\r\n\r\n        const center = centerWorld as Types.Point3;\r\n\r\n        const ellipseObj = {\r\n          center,\r\n          xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\r\n          yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\r\n          zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\r\n        };\r\n\r\n        const pointsInShape = pointInShapeCallback(\r\n          imageData,\r\n          //@ts-ignore\r\n          (pointLPS) => pointInEllipse(ellipseObj, pointLPS),\r\n          null,\r\n          boundsIJK\r\n        );\r\n\r\n        //@ts-ignore\r\n        pointsInsideVolume.push(pointsInShape);\r\n      }\r\n    }\r\n    data.cachedStats.pointsInVolume = pointsInsideVolume;\r\n  }\r\n\r\n  _calculateCachedStatsTool(annotation, enabledElement) {\r\n    const data = annotation.data;\r\n    const { viewportId, renderingEngineId, viewport } = enabledElement;\r\n\r\n    const { cachedStats } = data;\r\n    const targetId = this.getTargetId(viewport);\r\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\r\n\r\n    // Todo: this shouldn't be here, this is a performance issue\r\n    // Since we are extending the RectangleROI class, we need to\r\n    // bring the logic for handle to some cachedStats calculation\r\n    this._computeProjectionPoints(annotation, imageVolume);\r\n\r\n    annotation.invalidated = false;\r\n\r\n    // Dispatching annotation modified\r\n    const eventType = Events.ANNOTATION_MODIFIED;\r\n\r\n    const eventDetail: AnnotationModifiedEventDetail = {\r\n      annotation,\r\n      viewportId,\r\n      renderingEngineId,\r\n    };\r\n    triggerEvent(eventTarget, eventType, eventDetail);\r\n\r\n    return cachedStats;\r\n  }\r\n\r\n  _getStartSliceIndex(\r\n    imageVolume: Types.IImageVolume,\r\n    worldPos: Types.Point3,\r\n    spacingInNormal: number,\r\n    viewPlaneNormal: Types.Point3\r\n  ): number | undefined {\r\n    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\r\n\r\n    const numSlicesToPropagateFromStart = Math.round(numSlicesToPropagate / 2);\r\n    // get end position by moving from worldPos in the direction of viewplaneNormal\r\n    // with amount of numSlicesToPropagate * spacingInNormal\r\n    const startPos = vec3.create();\r\n    vec3.scaleAndAdd(\r\n      startPos,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      numSlicesToPropagateFromStart * -spacingInNormal\r\n    );\r\n\r\n    const imageIdIndex = this._getImageIdIndex(\r\n      imageVolume,\r\n      startPos,\r\n      spacingInNormal,\r\n      viewPlaneNormal\r\n    );\r\n\r\n    return imageIdIndex;\r\n  }\r\n\r\n  _getEndSliceIndex(\r\n    imageVolume: Types.IImageVolume,\r\n    worldPos: Types.Point3,\r\n    spacingInNormal: number,\r\n    viewPlaneNormal: Types.Point3\r\n  ): number | undefined {\r\n    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\r\n    const numSlicesToPropagateFromStart = Math.round(numSlicesToPropagate / 2);\r\n\r\n    // get end position by moving from worldPos in the direction of viewplaneNormal\r\n    // with amount of numSlicesToPropagate * spacingInNormal\r\n    const endPos = vec3.create();\r\n    vec3.scaleAndAdd(\r\n      endPos,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      numSlicesToPropagateFromStart * spacingInNormal\r\n    );\r\n\r\n    const imageIdIndex = this._getImageIdIndex(\r\n      imageVolume,\r\n      endPos,\r\n      spacingInNormal,\r\n      viewPlaneNormal\r\n    );\r\n\r\n    return imageIdIndex;\r\n  }\r\n\r\n  _getImageIdIndex(\r\n    imageVolume: Types.IImageVolume,\r\n    pos: vec3,\r\n    spacingInNormal: number,\r\n    viewPlaneNormal: Types.Point3\r\n  ): number | undefined {\r\n    const halfSpacingInNormalDirection = spacingInNormal / 2;\r\n    // Loop through imageIds of the imageVolume and find the one that is closest to endPos\r\n    const { imageIds } = imageVolume;\r\n    let imageIdIndex;\r\n    for (let i = 0; i < imageIds.length; i++) {\r\n      const imageId = imageIds[i];\r\n\r\n      const { imagePositionPatient } = metaData.get(\r\n        'imagePlaneModule',\r\n        imageId\r\n      );\r\n\r\n      const dir = vec3.create();\r\n      vec3.sub(dir, pos, imagePositionPatient);\r\n\r\n      const dot = vec3.dot(dir, viewPlaneNormal);\r\n\r\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\r\n        imageIdIndex = i;\r\n      }\r\n    }\r\n\r\n    return imageIdIndex;\r\n  }\r\n}\r\n\r\nCircleROIStartEndThresholdTool.toolName = 'CircleROIStartEndThreshold';\r\nexport default CircleROIStartEndThresholdTool;\r\n","import { cache, getEnabledElement } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { BaseTool } from '../base';\r\nimport {\r\n  PublicToolProps,\r\n  ToolProps,\r\n  EventTypes,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\n\r\nimport { fillInsideCircle } from './strategies/fillCircle';\r\nimport { eraseInsideCircle } from './strategies/eraseCircle';\r\nimport { Events } from '../../enums';\r\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\r\nimport {\r\n  resetElementCursor,\r\n  hideElementCursor,\r\n} from '../../cursors/elementCursor';\r\n\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\nimport {\r\n  segmentLocking,\r\n  activeSegmentation,\r\n  segmentIndex as segmentIndexController,\r\n  config as segmentationConfig,\r\n} from '../../stateManagement/segmentation';\r\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\r\nimport {\r\n  LabelmapSegmentationData,\r\n  LabelmapSegmentationDataStack,\r\n  LabelmapSegmentationDataVolume,\r\n} from '../../types/LabelmapTypes';\r\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\r\n\r\n/**\r\n * Tool for manipulating segmentation data by drawing a circle. It acts on the\r\n * active Segmentation on the viewport (enabled element) and requires an active\r\n * segmentation to be already present. By default it will use the activeSegmentIndex\r\n * for the segmentation to modify. You can use SegmentationModule to set the active\r\n * segmentation and segmentIndex.\r\n */\r\nclass CircleScissorsTool extends BaseTool {\r\n  static toolName;\r\n  editData: {\r\n    annotation: any;\r\n    segmentIndex: number;\r\n    //\r\n    volumeId: string;\r\n    referencedVolumeId: string;\r\n    imageIdReferenceMap: Map<string, string>;\r\n    //\r\n    segmentsLocked: number[];\r\n    segmentColor: [number, number, number, number];\r\n    viewportIdsToRender: string[];\r\n    handleIndex?: number;\r\n    movingTextBox: boolean;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n    centerCanvas?: Array<number>;\r\n    segmentationRepresentationUID?: string;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        strategies: {\r\n          FILL_INSIDE: fillInsideCircle,\r\n          ERASE_INSIDE: eraseInsideCircle,\r\n        },\r\n        defaultStrategy: 'FILL_INSIDE',\r\n        activeStrategy: 'FILL_INSIDE',\r\n        eraseFocusIndex: 0,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the enabledElement, it\r\n   * finds the active segmentation info and use it for the current tool.\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\r\n    // if we are already drawing, means we have started with a click, and now we\r\n    // are moving the mouse (not dragging) so the final click should not\r\n    // be handled by this preMouseDownCallback but rather the endCallback\r\n    if (this.isDrawing === true) {\r\n      return;\r\n    }\r\n\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n    const canvasPos = currentPoints.canvas;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n    const toolGroupId = this.toolGroupId;\r\n\r\n    const activeSegmentationRepresentation =\r\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\r\n    if (!activeSegmentationRepresentation) {\r\n      throw new Error(\r\n        'No active segmentation detected, create one before using scissors tool'\r\n      );\r\n    }\r\n\r\n    const { segmentationRepresentationUID, segmentationId, type } =\r\n      activeSegmentationRepresentation;\r\n    const segmentIndex =\r\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\r\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\r\n\r\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\r\n      toolGroupId,\r\n      segmentationRepresentationUID,\r\n      segmentIndex\r\n    );\r\n\r\n    const { representationData } = getSegmentation(segmentationId);\r\n\r\n    // Todo: are we going to support contour editing with rectangle scissors?\r\n    const labelmapData = representationData[type];\r\n\r\n    if (!labelmapData) {\r\n      throw new Error(\r\n        'No labelmap data found for the active segmentation, create one before using scissors tool'\r\n      );\r\n    }\r\n\r\n    // Todo: Used for drawing the svg only, we might not need it at all\r\n    const annotation = {\r\n      invalidated: true,\r\n      highlighted: true,\r\n      metadata: {\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\r\n        referencedImageId: '',\r\n        toolName: this.getToolName(),\r\n        segmentColor,\r\n      },\r\n      data: {\r\n        handles: {\r\n          points: [[...worldPos], [...worldPos], [...worldPos], [...worldPos]],\r\n          activeHandleIndex: null,\r\n        },\r\n        isDrawing: true,\r\n        cachedStats: {},\r\n      },\r\n    };\r\n\r\n    const viewportIdsToRender = [viewport.id];\r\n\r\n    this.editData = {\r\n      annotation,\r\n      centerCanvas: canvasPos,\r\n      segmentIndex,\r\n      segmentationId,\r\n      segmentsLocked,\r\n      segmentColor,\r\n      viewportIdsToRender,\r\n      handleIndex: 3,\r\n      movingTextBox: false,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n      segmentationRepresentationUID,\r\n    } as any;\r\n\r\n    if (\r\n      isVolumeSegmentation(labelmapData as LabelmapSegmentationData, viewport)\r\n    ) {\r\n      const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\r\n      const segmentation = cache.getVolume(volumeId);\r\n\r\n      this.editData = {\r\n        ...this.editData,\r\n        volumeId,\r\n        referencedVolumeId: segmentation.referencedVolumeId,\r\n      };\r\n    } else {\r\n      const { imageIdReferenceMap } =\r\n        labelmapData as LabelmapSegmentationDataStack;\r\n\r\n      this.editData = {\r\n        ...this.editData,\r\n        imageIdReferenceMap,\r\n      };\r\n    }\r\n\r\n    this._activateDraw(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return true;\r\n  };\r\n\r\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\r\n    this.isDrawing = true;\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const { currentPoints } = eventDetail;\r\n    const currentCanvasPoints = currentPoints.canvas;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine, viewport } = enabledElement;\r\n    const { canvasToWorld } = viewport;\r\n\r\n    //////\r\n    const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\r\n    const { data } = annotation;\r\n\r\n    // Center of circle in canvas Coordinates\r\n\r\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\r\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\r\n    const radius = Math.sqrt(dX * dX + dY * dY);\r\n\r\n    const bottomCanvas: Types.Point2 = [\r\n      centerCanvas[0],\r\n      centerCanvas[1] + radius,\r\n    ];\r\n    const topCanvas: Types.Point2 = [centerCanvas[0], centerCanvas[1] - radius];\r\n    const leftCanvas: Types.Point2 = [\r\n      centerCanvas[0] - radius,\r\n      centerCanvas[1],\r\n    ];\r\n    const rightCanvas: Types.Point2 = [\r\n      centerCanvas[0] + radius,\r\n      centerCanvas[1],\r\n    ];\r\n\r\n    data.handles.points = [\r\n      canvasToWorld(bottomCanvas),\r\n      canvasToWorld(topCanvas),\r\n      canvasToWorld(leftCanvas),\r\n      canvasToWorld(rightCanvas),\r\n    ];\r\n\r\n    annotation.invalidated = true;\r\n\r\n    this.editData.hasMoved = true;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, newAnnotation, hasMoved } = this.editData;\r\n    const { data } = annotation;\r\n    const { viewPlaneNormal, viewUp } = annotation.metadata;\r\n\r\n    if (newAnnotation && !hasMoved) {\r\n      return;\r\n    }\r\n\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateDraw(element);\r\n\r\n    resetElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n\r\n    const operationData = {\r\n      ...this.editData,\r\n      points: data.handles.points,\r\n      viewPlaneNormal,\r\n      viewUp,\r\n      strategySpecificConfiguration: {},\r\n      eraseFocusIndex: this.configuration.eraseFocusIndex\r\n    };\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n\r\n    this.applyActiveStrategy(enabledElement, operationData);\r\n  };\r\n\r\n  /**\r\n   * Add event handlers for the modify event loop, and prevent default event propagation.\r\n   */\r\n  _activateDraw = (element) => {\r\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\r\n\r\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\r\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\r\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\r\n  };\r\n\r\n  /**\r\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\r\n   */\r\n  _deactivateDraw = (element) => {\r\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\r\n\r\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\r\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the circleScissor annotation in each\r\n   * request animation frame. Note that the annotation are disappeared\r\n   * after the segmentation modification.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n    if (!this.editData) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const { viewport } = enabledElement;\r\n    const { viewportIdsToRender } = this.editData;\r\n\r\n    if (!viewportIdsToRender.includes(viewport.id)) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const { annotation } = this.editData;\r\n\r\n    // Todo: rectangle color based on segment index\r\n    const toolMetadata = annotation.metadata;\r\n    const annotationUID = annotation.annotationUID;\r\n\r\n    const data = annotation.data;\r\n    const { points } = data.handles;\r\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n    const bottom = canvasCoordinates[0];\r\n    const top = canvasCoordinates[1];\r\n\r\n    const center = [\r\n      Math.floor((bottom[0] + top[0]) / 2),\r\n      Math.floor((bottom[1] + top[1]) / 2),\r\n    ];\r\n\r\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\r\n\r\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\r\n\r\n    // If rendering engine has been destroyed while rendering\r\n    if (!viewport.getRenderingEngine()) {\r\n      console.warn('Rendering Engine has been destroyed');\r\n      return renderStatus;\r\n    }\r\n\r\n    const circleUID = '0';\r\n    drawCircleSvg(\r\n      svgDrawingHelper,\r\n      annotationUID,\r\n      circleUID,\r\n      center as Types.Point2,\r\n      radius,\r\n      {\r\n        color,\r\n      }\r\n    );\r\n\r\n    renderStatus = true;\r\n    return renderStatus;\r\n  };\r\n}\r\n\r\nCircleScissorsTool.toolName = 'CircleScissor';\r\nexport default CircleScissorsTool;\r\n","import {\r\n  cache,\r\n  getEnabledElement,\r\n  utilities as csUtils,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { BaseTool } from '../base';\r\nimport { PublicToolProps, ToolProps, EventTypes } from '../../types';\r\nimport { SegmentationRepresentations } from '../../enums';\r\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\r\nimport {\r\n  segmentLocking,\r\n  activeSegmentation,\r\n  segmentIndex as segmentIndexController,\r\n} from '../../stateManagement/segmentation';\r\nimport floodFill from '../../utilities/segmentation/floodFill';\r\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\r\nimport { FloodFillResult, FloodFillGetter } from '../../types';\r\nimport {\r\n  LabelmapSegmentationDataStack,\r\n  LabelmapSegmentationDataVolume,\r\n} from '../../types/LabelmapTypes';\r\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\r\n\r\nconst { transformWorldToIndex, isEqual } = csUtils;\r\n\r\ntype PaintFillToolHelpers = {\r\n  getScalarDataPositionFromPlane: (x: number, y: number) => number;\r\n  getLabelValue: (x: number, y: number, z: number) => number;\r\n  floodFillGetter: FloodFillGetter;\r\n  inPlaneSeedPoint: Types.Point2;\r\n  fixedDimensionValue: number;\r\n};\r\n\r\n/**\r\n * Tool for manipulating segmentation data by filling in regions. It acts on the\r\n * active Segmentation on the viewport (enabled element) and requires an active\r\n * segmentation to be already present. By default it will fill a given labelled\r\n * or empty region with the the activeSegmentIndex label. You can use the\r\n * SegmentationModule to set the active segmentation and segmentIndex.\r\n */\r\nclass PaintFillTool extends BaseTool {\r\n  static toolName;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the enabledElement, it\r\n   * finds the active segmentation info and use it for the current tool.\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal } = camera;\r\n    const toolGroupId = this.toolGroupId;\r\n\r\n    const activeSegmentationRepresentation =\r\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\r\n    if (!activeSegmentationRepresentation) {\r\n      throw new Error(\r\n        'No active segmentation detected, create one before using scissors tool'\r\n      );\r\n    }\r\n\r\n    const { segmentationId, type } = activeSegmentationRepresentation;\r\n    const segmentIndex =\r\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\r\n    const segmentsLocked: number[] =\r\n      segmentLocking.getLockedSegments(segmentationId);\r\n    const { representationData } = getSegmentation(segmentationId);\r\n\r\n    const labelmapData =\r\n      representationData[SegmentationRepresentations.Labelmap];\r\n\r\n    let dimensions: Types.Point3;\r\n    let direction: Types.Mat3;\r\n    let scalarData: Types.PixelDataTypedArray;\r\n    let index: Types.Point3;\r\n\r\n    if (isVolumeSegmentation(labelmapData, viewport)) {\r\n      const { volumeId } = representationData[\r\n        type\r\n      ] as LabelmapSegmentationDataVolume;\r\n\r\n      const segmentation = cache.getVolume(volumeId);\r\n      ({ dimensions, direction } = segmentation);\r\n      scalarData = segmentation.getScalarData();\r\n\r\n      index = transformWorldToIndex(segmentation.imageData, worldPos);\r\n    } else {\r\n      const { imageIdReferenceMap } =\r\n        labelmapData as LabelmapSegmentationDataStack;\r\n\r\n      const currentImageId = enabledElement.viewport.getCurrentImageId();\r\n      const currentSegmentationImageId =\r\n        imageIdReferenceMap.get(currentImageId);\r\n\r\n      if (!currentSegmentationImageId) {\r\n        throw new Error(\r\n          'No active segmentation imageId detected, create one before using scissors tool'\r\n        );\r\n      }\r\n\r\n      const segmentationImage = cache.getImage(currentSegmentationImageId);\r\n      scalarData = segmentationImage.getPixelData();\r\n      const { imageData } = viewport.getImageData();\r\n      dimensions = imageData.getDimensions();\r\n      direction = imageData.getDirection();\r\n      index = transformWorldToIndex(imageData, worldPos);\r\n    }\r\n\r\n    const fixedDimension = this.getFixedDimension(\r\n      viewPlaneNormal,\r\n      direction as number[]\r\n    );\r\n\r\n    if (fixedDimension === undefined) {\r\n      console.warn('Oblique paint fill not yet supported');\r\n      return;\r\n    }\r\n\r\n    const {\r\n      floodFillGetter,\r\n      getLabelValue,\r\n      getScalarDataPositionFromPlane,\r\n      inPlaneSeedPoint,\r\n      fixedDimensionValue,\r\n    } = this.generateHelpers(scalarData, dimensions, index, fixedDimension);\r\n\r\n    // Check if within volume\r\n    if (\r\n      index[0] < 0 ||\r\n      index[0] >= dimensions[0] ||\r\n      index[1] < 0 ||\r\n      index[1] >= dimensions[1] ||\r\n      index[2] < 0 ||\r\n      index[2] >= dimensions[2]\r\n    ) {\r\n      // Clicked outside segmentation volume, no good way to fill.\r\n      return;\r\n    }\r\n    //@ts-ignore // todo type\r\n    const clickedLabelValue = getLabelValue(index[0], index[1], index[2]);\r\n\r\n    if (segmentsLocked.includes(clickedLabelValue)) {\r\n      // Label is locked, cannot fill.\r\n      return;\r\n    }\r\n\r\n    const floodFillResult = floodFill(floodFillGetter, inPlaneSeedPoint);\r\n\r\n    const { flooded } = floodFillResult;\r\n\r\n    flooded.forEach((index) => {\r\n      const scalarDataPosition = getScalarDataPositionFromPlane(\r\n        index[0],\r\n        index[1]\r\n      );\r\n\r\n      scalarData[scalarDataPosition] = segmentIndex;\r\n    });\r\n\r\n    const framesModified = this.getFramesModified(\r\n      fixedDimension,\r\n      fixedDimensionValue,\r\n      floodFillResult\r\n    );\r\n\r\n    triggerSegmentationDataModified(segmentationId, framesModified);\r\n\r\n    return true;\r\n  };\r\n\r\n  private getFramesModified = (\r\n    fixedDimension: number,\r\n    fixedDimensionValue: number,\r\n    floodFillResult: FloodFillResult\r\n  ): number[] => {\r\n    const { boundaries } = floodFillResult;\r\n\r\n    if (fixedDimension === 2) {\r\n      return [fixedDimensionValue];\r\n    }\r\n\r\n    // For both the fixedDimensions being 0 and 1, the Z (stack) direction is j,\r\n    // so we don't need to find min/max i.\r\n\r\n    let minJ = Infinity;\r\n    let maxJ = -Infinity;\r\n\r\n    for (let b = 0; b < boundaries.length; b++) {\r\n      const j = boundaries[b][1];\r\n\r\n      if (j < minJ) {\r\n        minJ = j;\r\n      }\r\n      if (j > maxJ) {\r\n        maxJ = j;\r\n      }\r\n    }\r\n\r\n    const framesModified = [];\r\n\r\n    for (let frame = minJ; frame <= maxJ; frame++) {\r\n      framesModified.push(frame);\r\n    }\r\n\r\n    return framesModified;\r\n  };\r\n\r\n  private generateHelpers = (\r\n    scalarData: Types.PixelDataTypedArray,\r\n    dimensions: Types.Point3,\r\n    seedIndex3D: Types.Point3,\r\n    fixedDimension = 2\r\n  ): PaintFillToolHelpers => {\r\n    let fixedDimensionValue: number;\r\n    let inPlaneSeedPoint: Types.Point2;\r\n\r\n    switch (fixedDimension) {\r\n      case 0:\r\n        fixedDimensionValue = seedIndex3D[0]; // X\r\n        inPlaneSeedPoint = [seedIndex3D[1], seedIndex3D[2]]; // Y,Z\r\n        break;\r\n      case 1:\r\n        fixedDimensionValue = seedIndex3D[1]; // Y\r\n        inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[2]]; // X,Z\r\n        break;\r\n      case 2:\r\n        fixedDimensionValue = seedIndex3D[2]; // Z\r\n        inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[1]]; // X, Y\r\n        break;\r\n      default:\r\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\r\n    }\r\n\r\n    const getScalarDataPosition = (x: number, y: number, z: number): number => {\r\n      return z * dimensions[1] * dimensions[0] + y * dimensions[0] + x;\r\n    };\r\n\r\n    const getLabelValue = (x: number, y: number, z: number): number => {\r\n      return scalarData[getScalarDataPosition(x, y, z)];\r\n    };\r\n\r\n    const floodFillGetter = this.generateFloodFillGetter(\r\n      dimensions,\r\n      fixedDimension,\r\n      fixedDimensionValue,\r\n      getLabelValue\r\n    );\r\n\r\n    const getScalarDataPositionFromPlane =\r\n      this.generateGetScalarDataPositionFromPlane(\r\n        getScalarDataPosition,\r\n        fixedDimension,\r\n        fixedDimensionValue\r\n      );\r\n\r\n    return {\r\n      getScalarDataPositionFromPlane,\r\n      getLabelValue,\r\n      floodFillGetter,\r\n      inPlaneSeedPoint,\r\n      fixedDimensionValue,\r\n    };\r\n  };\r\n\r\n  private getFixedDimension(\r\n    viewPlaneNormal: Types.Point3,\r\n    direction: number[]\r\n  ): number | undefined {\r\n    const xDirection = direction.slice(0, 3);\r\n    const yDirection = direction.slice(3, 6);\r\n    const zDirection = direction.slice(6, 9);\r\n\r\n    const absoluteOfViewPlaneNormal = [\r\n      Math.abs(viewPlaneNormal[0]),\r\n      Math.abs(viewPlaneNormal[1]),\r\n      Math.abs(viewPlaneNormal[2]),\r\n    ];\r\n\r\n    const absoluteOfXDirection = [\r\n      Math.abs(xDirection[0]),\r\n      Math.abs(xDirection[1]),\r\n      Math.abs(xDirection[2]),\r\n    ];\r\n\r\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfXDirection)) {\r\n      return 0;\r\n    }\r\n\r\n    const absoluteOfYDirection = [\r\n      Math.abs(yDirection[0]),\r\n      Math.abs(yDirection[1]),\r\n      Math.abs(yDirection[2]),\r\n    ];\r\n\r\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfYDirection)) {\r\n      return 1;\r\n    }\r\n\r\n    const absoluteOfZDirection = [\r\n      Math.abs(zDirection[0]),\r\n      Math.abs(zDirection[1]),\r\n      Math.abs(zDirection[2]),\r\n    ];\r\n\r\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfZDirection)) {\r\n      return 2;\r\n    }\r\n  }\r\n\r\n  // Define a getter for the fill routine to access the working label map.\r\n  private generateFloodFillGetter = (\r\n    dimensions: Types.Point3,\r\n    fixedDimension: number,\r\n    fixedDimensionValue: number,\r\n    getLabelValue: PaintFillToolHelpers['getLabelValue']\r\n  ): FloodFillGetter => {\r\n    let floodFillGetter;\r\n\r\n    // In each helper we first check if out of bounds, as the flood filler\r\n    // doesn't know about the dimensions of the data structure that sits on top\r\n    // of the scalarData. E.g. if cols is 10, (0,1) and (10, 0) would point to\r\n    // the same position in these getters.\r\n\r\n    switch (fixedDimension) {\r\n      case 0:\r\n        floodFillGetter = (y, z) => {\r\n          if (y >= dimensions[1] || y < 0 || z >= dimensions[2] || z < 0) {\r\n            return;\r\n          }\r\n\r\n          return getLabelValue(fixedDimensionValue, y, z);\r\n        };\r\n        break;\r\n\r\n      case 1:\r\n        floodFillGetter = (x, z) => {\r\n          if (x >= dimensions[0] || x < 0 || z >= dimensions[2] || z < 0) {\r\n            return;\r\n          }\r\n\r\n          return getLabelValue(x, fixedDimensionValue, z);\r\n        };\r\n        break;\r\n\r\n      case 2:\r\n        floodFillGetter = (x, y) => {\r\n          if (x >= dimensions[0] || x < 0 || y >= dimensions[1] || y < 0) {\r\n            return;\r\n          }\r\n\r\n          return getLabelValue(x, y, fixedDimensionValue);\r\n        };\r\n        break;\r\n      default:\r\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\r\n    }\r\n\r\n    return floodFillGetter;\r\n  };\r\n\r\n  private generateGetScalarDataPositionFromPlane = (\r\n    getScalarDataPosition: (x: number, y: number, z: number) => number,\r\n    fixedDimension: number,\r\n    fixedDimensionValue: number\r\n  ): PaintFillToolHelpers['getScalarDataPositionFromPlane'] => {\r\n    let getScalarDataPositionFromPlane;\r\n\r\n    switch (fixedDimension) {\r\n      case 0:\r\n        getScalarDataPositionFromPlane = (y, z) => {\r\n          return getScalarDataPosition(fixedDimensionValue, y, z);\r\n        };\r\n        break;\r\n      case 1:\r\n        getScalarDataPositionFromPlane = (x, z) => {\r\n          return getScalarDataPosition(x, fixedDimensionValue, z);\r\n        };\r\n        break;\r\n      case 2:\r\n        getScalarDataPositionFromPlane = (x, y) => {\r\n          return getScalarDataPosition(x, y, fixedDimensionValue);\r\n        };\r\n        break;\r\n      default:\r\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\r\n    }\r\n\r\n    return getScalarDataPositionFromPlane;\r\n  };\r\n}\r\n\r\nPaintFillTool.toolName = 'PaintFill';\r\nexport default PaintFillTool;\r\n","import { cache, getEnabledElement, StackViewport } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { BaseTool } from '../base';\r\nimport {\r\n  PublicToolProps,\r\n  ToolProps,\r\n  EventTypes,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\nimport { fillInsideRectangle } from './strategies/fillRectangle';\r\nimport { eraseInsideRectangle } from './strategies/eraseRectangle';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\n\r\nimport { Events, SegmentationRepresentations } from '../../enums';\r\nimport { drawRect as drawRectSvg } from '../../drawingSvg';\r\nimport {\r\n  resetElementCursor,\r\n  hideElementCursor,\r\n} from '../../cursors/elementCursor';\r\nimport {\r\n  LabelmapSegmentationDataStack,\r\n  LabelmapSegmentationDataVolume,\r\n} from '../../types/LabelmapTypes';\r\n\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\nimport {\r\n  config as segmentationConfig,\r\n  segmentLocking,\r\n  segmentIndex as segmentIndexController,\r\n  activeSegmentation,\r\n} from '../../stateManagement/segmentation';\r\n\r\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\r\nimport { LabelmapSegmentationData } from '../../types/LabelmapTypes';\r\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\r\n\r\n/**\r\n * Tool for manipulating segmentation data by drawing a rectangle. It acts on the\r\n * active Segmentation on the viewport (enabled element) and requires an active\r\n * segmentation to be already present. By default it will use the activeSegmentIndex\r\n * for the segmentation to modify. You can use SegmentationModule to set the active\r\n * segmentation and segmentIndex.\r\n */\r\nclass RectangleScissorsTool extends BaseTool {\r\n  static toolName;\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    //\r\n    imageIdReferenceMap: Map<string, string>;\r\n    volumeId: string;\r\n    referencedVolumeId: string;\r\n    //\r\n    annotation: any;\r\n    segmentationId: string;\r\n    segmentIndex: number;\r\n    segmentsLocked: number[];\r\n    segmentColor: [number, number, number, number];\r\n    viewportIdsToRender: string[];\r\n    handleIndex?: number;\r\n    movingTextBox: boolean;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        strategies: {\r\n          FILL_INSIDE: fillInsideRectangle,\r\n          ERASE_INSIDE: eraseInsideRectangle,\r\n        },\r\n        defaultStrategy: 'FILL_INSIDE',\r\n        activeStrategy: 'FILL_INSIDE',\r\n        eraseFocusIndex: 0,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the enabledElement, it\r\n   * finds the active segmentation info and use it for the current tool.\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\r\n    // if we are already drawing, means we have started with a click, and now we\r\n    // are moving the mouse (not dragging) so the final click should not\r\n    // be handled by this preMouseDownCallback but rather the endCallback\r\n    if (this.isDrawing === true) {\r\n      return;\r\n    }\r\n\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n    const toolGroupId = this.toolGroupId;\r\n\r\n    const activeSegmentationRepresentation =\r\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\r\n    if (!activeSegmentationRepresentation) {\r\n      throw new Error(\r\n        'No active segmentation detected, create one before using scissors tool'\r\n      );\r\n    }\r\n\r\n    const { segmentationRepresentationUID, segmentationId, type } =\r\n      activeSegmentationRepresentation;\r\n    const segmentIndex =\r\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\r\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\r\n\r\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\r\n      toolGroupId,\r\n      segmentationRepresentationUID,\r\n      segmentIndex\r\n    );\r\n\r\n    const { representationData } = getSegmentation(segmentationId);\r\n    const labelmapData = representationData[\r\n      SegmentationRepresentations.Labelmap\r\n    ] as LabelmapSegmentationData;\r\n\r\n    // Todo: Used for drawing the svg only, we might not need it at all\r\n    const annotation = {\r\n      highlighted: true,\r\n      invalidated: true,\r\n      metadata: {\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\r\n        referencedImageId: '',\r\n        toolName: this.getToolName(),\r\n        segmentColor,\r\n      },\r\n      data: {\r\n        handles: {\r\n          points: [\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n          ],\r\n          activeHandleIndex: null,\r\n        },\r\n      },\r\n    };\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n    this.editData = {\r\n      annotation,\r\n      segmentIndex,\r\n      segmentationId,\r\n      segmentsLocked,\r\n      segmentColor,\r\n      viewportIdsToRender,\r\n      handleIndex: 3,\r\n      movingTextBox: false,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n      segmentationRepresentationUID,\r\n    } as any;\r\n\r\n    if (\r\n      isVolumeSegmentation(labelmapData as LabelmapSegmentationData, viewport)\r\n    ) {\r\n      const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\r\n      const segmentation = cache.getVolume(volumeId);\r\n\r\n      this.editData = {\r\n        ...this.editData,\r\n        volumeId,\r\n        referencedVolumeId: segmentation.referencedVolumeId,\r\n      };\r\n    } else {\r\n      const { imageIdReferenceMap } =\r\n        labelmapData as LabelmapSegmentationDataStack;\r\n\r\n      this.editData = {\r\n        ...this.editData,\r\n        imageIdReferenceMap,\r\n      };\r\n    }\r\n\r\n    this._activateDraw(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return true;\r\n  };\r\n\r\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\r\n    this.isDrawing = true;\r\n\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\r\n    const { data } = annotation;\r\n\r\n    // Moving handle.\r\n    const { currentPoints } = eventDetail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\r\n    const worldPos = currentPoints.world;\r\n\r\n    const { points } = data.handles;\r\n\r\n    // Move this handle.\r\n    points[handleIndex] = [...worldPos];\r\n\r\n    let bottomLeftCanvas;\r\n    let bottomRightCanvas;\r\n    let topLeftCanvas;\r\n    let topRightCanvas;\r\n\r\n    let bottomLeftWorld;\r\n    let bottomRightWorld;\r\n    let topLeftWorld;\r\n    let topRightWorld;\r\n\r\n    switch (handleIndex) {\r\n      case 0:\r\n      case 3:\r\n        // Moving bottomLeft or topRight\r\n\r\n        bottomLeftCanvas = worldToCanvas(points[0]);\r\n        topRightCanvas = worldToCanvas(points[3]);\r\n\r\n        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\r\n        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\r\n\r\n        bottomRightWorld = canvasToWorld(bottomRightCanvas);\r\n        topLeftWorld = canvasToWorld(topLeftCanvas);\r\n\r\n        points[1] = bottomRightWorld;\r\n        points[2] = topLeftWorld;\r\n\r\n        break;\r\n      case 1:\r\n      case 2:\r\n        // Moving bottomRight or topLeft\r\n        bottomRightCanvas = worldToCanvas(points[1]);\r\n        topLeftCanvas = worldToCanvas(points[2]);\r\n\r\n        bottomLeftCanvas = <Types.Point2>[\r\n          topLeftCanvas[0],\r\n          bottomRightCanvas[1],\r\n        ];\r\n        topRightCanvas = <Types.Point2>[bottomRightCanvas[0], topLeftCanvas[1]];\r\n\r\n        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\r\n        topRightWorld = canvasToWorld(topRightCanvas);\r\n\r\n        points[0] = bottomLeftWorld;\r\n        points[3] = topRightWorld;\r\n\r\n        break;\r\n    }\r\n    annotation.invalidated = true;\r\n\r\n    this.editData.hasMoved = true;\r\n\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, newAnnotation, hasMoved } = this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (newAnnotation && !hasMoved) {\r\n      return;\r\n    }\r\n\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateDraw(element);\r\n\r\n    resetElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n\r\n    const operationData = {\r\n      ...this.editData,\r\n      points: data.handles.points,\r\n      eraseFocusIndex: this.configuration.eraseFocusIndex\r\n    };\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n\r\n    this.applyActiveStrategy(enabledElement, operationData);\r\n  };\r\n\r\n  /**\r\n   * Add event handlers for the modify event loop, and prevent default event propagation.\r\n   */\r\n  _activateDraw = (element) => {\r\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\r\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\r\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  /**\r\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\r\n   */\r\n  _deactivateDraw = (element) => {\r\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\r\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\r\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the rectangleScissor annotation in each\r\n   * request animation frame. Note that the annotation are disappeared\r\n   * after the segmentation modification.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n    if (!this.editData) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const { viewport } = enabledElement;\r\n    const { annotation } = this.editData;\r\n\r\n    // Todo: rectangle color based on segment index\r\n    const toolMetadata = annotation.metadata;\r\n    const annotationUID = annotation.annotationUID;\r\n\r\n    const data = annotation.data;\r\n    const { points } = data.handles;\r\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\r\n\r\n    // If rendering engine has been destroyed while rendering\r\n    if (!viewport.getRenderingEngine()) {\r\n      console.warn('Rendering Engine has been destroyed');\r\n      return renderStatus;\r\n    }\r\n\r\n    const rectangleUID = '0';\r\n    drawRectSvg(\r\n      svgDrawingHelper,\r\n      annotationUID,\r\n      rectangleUID,\r\n      canvasCoordinates[0],\r\n      canvasCoordinates[3],\r\n      {\r\n        color,\r\n      }\r\n    );\r\n\r\n    renderStatus = true;\r\n\r\n    return renderStatus;\r\n  };\r\n}\r\n\r\nRectangleScissorsTool.toolName = 'RectangleScissor';\r\nexport default RectangleScissorsTool;\r\n","import { getEnabledElement } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { BaseTool } from '../base';\r\nimport {\r\n  PublicToolProps,\r\n  ToolProps,\r\n  EventTypes,\r\n  ToolGroupSpecificRepresentation,\r\n} from '../../types';\r\nimport { triggerSegmentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\nimport { getActiveSegmentationRepresentation } from '../../stateManagement/segmentation/activeSegmentation';\r\nimport RepresentationTypes from '../../enums/SegmentationRepresentations';\r\nimport { setActiveSegmentIndex } from '../../stateManagement/segmentation/segmentIndex';\r\nimport {\r\n  getHoveredContourSegmentationAnnotation,\r\n  getSegmentAtLabelmapBorder,\r\n  getSegmentAtWorldPoint,\r\n} from '../../utilities/segmentation';\r\nimport { state } from '../../store';\r\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\r\n\r\n/**\r\n * Represents a tool used for segment selection. It is used to select a segment\r\n * by hovering over it.\r\n *\r\n */\r\nclass SegmentSelectTool extends BaseTool {\r\n  static toolName;\r\n  private hoverTimer: ReturnType<typeof setTimeout> | null;\r\n\r\n  static SelectMode = {\r\n    Inside: 'Inside',\r\n    Border: 'Border',\r\n  };\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        hoverTimeout: 100,\r\n        mode: SegmentSelectTool.SelectMode.Border,\r\n        searchRadius: 6, // search for border in a 6px radius\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n    this.hoverTimer = null;\r\n  }\r\n\r\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): boolean => {\r\n    if (this.hoverTimer) {\r\n      clearTimeout(this.hoverTimer);\r\n    }\r\n\r\n    this.hoverTimer = setTimeout(() => {\r\n      this._setActiveSegment(evt);\r\n      this.hoverTimer = null;\r\n    }, this.configuration.hoverTimeout);\r\n\r\n    return true;\r\n  };\r\n\r\n  onSetToolEnabled = (): void => {\r\n    this.onSetToolActive();\r\n  };\r\n\r\n  onSetToolActive = (): void => {\r\n    this.hoverTimer = null;\r\n  };\r\n\r\n  onSetToolDisabled = (): void => {\r\n    this.hoverTimer = null;\r\n  };\r\n\r\n  _setActiveSegment(evt = {} as EventTypes.InteractionEventType): void {\r\n    if (state.isInteractingWithTool) {\r\n      return;\r\n    }\r\n\r\n    const { element, currentPoints } = evt.detail;\r\n\r\n    const worldPoint = currentPoints.world;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n\r\n    if (!enabledElement) {\r\n      return;\r\n    }\r\n\r\n    const { viewport } = enabledElement;\r\n\r\n    const activeSegmentationReps = getActiveSegmentationRepresentation(\r\n      this.toolGroupId\r\n    );\r\n\r\n    if (!activeSegmentationReps) {\r\n      return;\r\n    }\r\n\r\n    const supportedTypes = [\r\n      RepresentationTypes.Labelmap,\r\n      RepresentationTypes.Contour,\r\n    ];\r\n\r\n    if (supportedTypes.includes(activeSegmentationReps.type)) {\r\n      this._setActiveSegmentForType(\r\n        activeSegmentationReps,\r\n        worldPoint,\r\n        viewport\r\n      );\r\n    } else {\r\n      console.warn(\r\n        'SegmentSelectTool does not support the current segmentation type.'\r\n      );\r\n    }\r\n  }\r\n\r\n  _setActiveSegmentForType(\r\n    activeSegmentationReps: ToolGroupSpecificRepresentation,\r\n    worldPoint: Types.Point3,\r\n    viewport: Types.IStackViewport | Types.IVolumeViewport\r\n  ): void {\r\n    const imageDataInfo = viewport.getImageData();\r\n\r\n    if (!imageDataInfo) {\r\n      return;\r\n    }\r\n\r\n    const { segmentationId, type } = activeSegmentationReps;\r\n\r\n    let hoveredSegmentIndex;\r\n\r\n    if (this.configuration.mode === SegmentSelectTool.SelectMode.Inside) {\r\n      hoveredSegmentIndex = getSegmentAtWorldPoint(segmentationId, worldPoint, {\r\n        viewport,\r\n      });\r\n    } else {\r\n      switch (type) {\r\n        case SegmentationRepresentations.Labelmap:\r\n          hoveredSegmentIndex = getSegmentAtLabelmapBorder(\r\n            segmentationId,\r\n            worldPoint,\r\n            {\r\n              viewport,\r\n              searchRadius: this.configuration.searchRadius,\r\n            }\r\n          );\r\n          break;\r\n\r\n        case SegmentationRepresentations.Contour:\r\n          hoveredSegmentIndex =\r\n            getHoveredContourSegmentationAnnotation(segmentationId);\r\n          break;\r\n      }\r\n    }\r\n\r\n    // No need to select background\r\n    if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {\r\n      return;\r\n    }\r\n\r\n    setActiveSegmentIndex(segmentationId, hoveredSegmentIndex);\r\n\r\n    const renderingEngine = viewport.getRenderingEngine();\r\n    const viewportIds = renderingEngine.getViewports().map((v) => v.id);\r\n\r\n    // update states\r\n    triggerSegmentationModified(segmentationId);\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\r\n  }\r\n}\r\n\r\nSegmentSelectTool.toolName = 'SegmentSelectTool';\r\nexport default SegmentSelectTool;\r\n","import { cache, getEnabledElement } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { BaseTool } from '../base';\r\nimport {\r\n  PublicToolProps,\r\n  ToolProps,\r\n  EventTypes,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\n\r\nimport { fillInsideSphere } from './strategies/fillSphere';\r\nimport { eraseInsideSphere } from './strategies/eraseSphere';\r\nimport { Events, SegmentationRepresentations } from '../../enums';\r\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\r\nimport {\r\n  resetElementCursor,\r\n  hideElementCursor,\r\n} from '../../cursors/elementCursor';\r\n\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\nimport {\r\n  config as segmentationConfig,\r\n  segmentLocking,\r\n  segmentIndex as segmentIndexController,\r\n  activeSegmentation,\r\n} from '../../stateManagement/segmentation';\r\n\r\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\r\nimport {\r\n  LabelmapSegmentationData,\r\n  LabelmapSegmentationDataVolume,\r\n  LabelmapSegmentationDataStack,\r\n} from '../../types/LabelmapTypes';\r\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\r\n/**\r\n * Tool for manipulating segmentation data by drawing a sphere in 3d space. It acts on the\r\n * active Segmentation on the viewport (enabled element) and requires an active\r\n * segmentation to be already present. By default it will use the activeSegmentIndex\r\n * for the segmentation to modify. You can use SegmentationModule to set the active\r\n * segmentation and segmentIndex. Todo: sphere scissor has some memory problem which\r\n * lead to ui blocking behavior that needs to be fixed.\r\n */\r\nclass SphereScissorsTool extends BaseTool {\r\n  static toolName;\r\n  editData: {\r\n    annotation: any;\r\n    segmentIndex: number;\r\n    segmentsLocked: number[];\r\n    segmentationRepresentationUID: string;\r\n    //\r\n    volumeId: string;\r\n    referencedVolumeId: string;\r\n    imageIdReferenceMap: Map<string, string>;\r\n    //\r\n    toolGroupId: string;\r\n    segmentColor: [number, number, number, number];\r\n    viewportIdsToRender: string[];\r\n    handleIndex?: number;\r\n    movingTextBox: boolean;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n    centerCanvas?: Array<number>;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        strategies: {\r\n          FILL_INSIDE: fillInsideSphere,\r\n          ERASE_INSIDE: eraseInsideSphere,\r\n        },\r\n        defaultStrategy: 'FILL_INSIDE',\r\n        activeStrategy: 'FILL_INSIDE',\r\n        eraseFocusIndex: 0,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the enabledElement, it\r\n   * finds the active segmentation info and use it for the current tool.\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): true => {\r\n    // if we are already drawing, means we have started with a click, and now we\r\n    // are moving the mouse (not dragging) so the final click should not\r\n    // be handled by this preMouseDownCallback but rather the endCallback\r\n    if (this.isDrawing === true) {\r\n      return;\r\n    }\r\n\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n    const canvasPos = currentPoints.canvas;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n    const toolGroupId = this.toolGroupId;\r\n\r\n    const activeSegmentationRepresentation =\r\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\r\n    if (!activeSegmentationRepresentation) {\r\n      throw new Error(\r\n        'No active segmentation detected, create one before using scissors tool'\r\n      );\r\n    }\r\n\r\n    const { segmentationRepresentationUID, segmentationId } =\r\n      activeSegmentationRepresentation;\r\n    const segmentIndex =\r\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\r\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\r\n\r\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\r\n      toolGroupId,\r\n      segmentationRepresentationUID,\r\n      segmentIndex\r\n    );\r\n\r\n    this.isDrawing = true;\r\n\r\n    // Used for drawing the svg only, we might not need it at all\r\n    const annotation = {\r\n      metadata: {\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\r\n        referencedImageId: '',\r\n        toolName: this.getToolName(),\r\n        segmentColor,\r\n      },\r\n      data: {\r\n        invalidated: true,\r\n        handles: {\r\n          points: [[...worldPos], [...worldPos], [...worldPos], [...worldPos]],\r\n          activeHandleIndex: null,\r\n        },\r\n        cachedStats: {},\r\n        highlighted: true,\r\n      },\r\n    };\r\n\r\n    const viewportIdsToRender = [viewport.id];\r\n\r\n    this.editData = {\r\n      annotation,\r\n      centerCanvas: canvasPos,\r\n      segmentationRepresentationUID,\r\n      segmentIndex,\r\n      segmentationId,\r\n      segmentsLocked,\r\n      segmentColor,\r\n      toolGroupId,\r\n      viewportIdsToRender,\r\n      handleIndex: 3,\r\n      movingTextBox: false,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n    } as any;\r\n\r\n    const { representationData } = getSegmentation(segmentationId);\r\n    const labelmapData =\r\n      representationData[SegmentationRepresentations.Labelmap];\r\n\r\n    if (\r\n      isVolumeSegmentation(labelmapData as LabelmapSegmentationData, viewport)\r\n    ) {\r\n      const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\r\n      const segmentation = cache.getVolume(volumeId);\r\n\r\n      this.editData = {\r\n        ...this.editData,\r\n        volumeId,\r\n        referencedVolumeId: segmentation.referencedVolumeId,\r\n      };\r\n    } else {\r\n      const { imageIdReferenceMap } =\r\n        labelmapData as LabelmapSegmentationDataStack;\r\n\r\n      this.editData = {\r\n        ...this.editData,\r\n        imageIdReferenceMap,\r\n      };\r\n    }\r\n\r\n    this._activateDraw(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return true;\r\n  };\r\n\r\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\r\n    this.isDrawing = true;\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const { currentPoints } = eventDetail;\r\n    const currentCanvasPoints = currentPoints.canvas;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine, viewport } = enabledElement;\r\n    const { canvasToWorld } = viewport;\r\n\r\n    //////\r\n    const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\r\n    const { data } = annotation;\r\n\r\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\r\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\r\n    const radius = Math.sqrt(dX * dX + dY * dY);\r\n\r\n    const bottomCanvas: Types.Point2 = [\r\n      centerCanvas[0],\r\n      centerCanvas[1] + radius,\r\n    ];\r\n    const topCanvas: Types.Point2 = [centerCanvas[0], centerCanvas[1] - radius];\r\n    const leftCanvas: Types.Point2 = [\r\n      centerCanvas[0] - radius,\r\n      centerCanvas[1],\r\n    ];\r\n    const rightCanvas: Types.Point2 = [\r\n      centerCanvas[0] + radius,\r\n      centerCanvas[1],\r\n    ];\r\n\r\n    data.handles.points = [\r\n      canvasToWorld(bottomCanvas),\r\n      canvasToWorld(topCanvas),\r\n      canvasToWorld(leftCanvas),\r\n      canvasToWorld(rightCanvas),\r\n    ];\r\n\r\n    annotation.invalidated = true;\r\n\r\n    this.editData.hasMoved = true;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const {\r\n      annotation,\r\n      newAnnotation,\r\n      hasMoved,\r\n      segmentIndex,\r\n      segmentationRepresentationUID,\r\n      segmentsLocked,\r\n    } = this.editData;\r\n    const { data } = annotation;\r\n    const { viewPlaneNormal, viewUp } = annotation.metadata;\r\n\r\n    if (newAnnotation && !hasMoved) {\r\n      return;\r\n    }\r\n    annotation.highlighted = false;\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateDraw(element);\r\n\r\n    resetElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n\r\n    const operationData = {\r\n      ...this.editData,\r\n      points: data.handles.points,\r\n      segmentIndex,\r\n      segmentationRepresentationUID,\r\n      segmentsLocked,\r\n      viewPlaneNormal,\r\n      viewUp,\r\n      eraseFocusIndex: this.configuration.eraseFocusIndex\r\n    };\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n\r\n    this.applyActiveStrategy(enabledElement, operationData);\r\n  };\r\n\r\n  /**\r\n   * Add event handlers for the modify event loop, and prevent default event propagation.\r\n   */\r\n  _activateDraw = (element) => {\r\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\r\n\r\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\r\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\r\n  };\r\n\r\n  /**\r\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\r\n   */\r\n  _deactivateDraw = (element) => {\r\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\r\n\r\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\r\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\r\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the sphereScissor annotation in each\r\n   * request animation frame. Note that the annotation are disappeared\r\n   * after the segmentation modification.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n    if (!this.editData) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const { viewport } = enabledElement;\r\n    const { viewportIdsToRender } = this.editData;\r\n\r\n    if (!viewportIdsToRender.includes(viewport.id)) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const { annotation } = this.editData;\r\n\r\n    // Todo: rectangle color based on segment index\r\n    const toolMetadata = annotation.metadata;\r\n    const annotationUID = annotation.annotationUID;\r\n\r\n    const data = annotation.data;\r\n    const { points } = data.handles;\r\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n    const bottom = canvasCoordinates[0];\r\n    const top = canvasCoordinates[1];\r\n\r\n    const center = [\r\n      Math.floor((bottom[0] + top[0]) / 2),\r\n      Math.floor((bottom[1] + top[1]) / 2),\r\n    ];\r\n\r\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\r\n\r\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\r\n\r\n    // If rendering engine has been destroyed while rendering\r\n    if (!viewport.getRenderingEngine()) {\r\n      console.warn('Rendering Engine has been destroyed');\r\n      return renderStatus;\r\n    }\r\n\r\n    const circleUID = '0';\r\n    drawCircleSvg(\r\n      svgDrawingHelper,\r\n      annotationUID,\r\n      circleUID,\r\n      center as Types.Point2,\r\n      radius,\r\n      {\r\n        color,\r\n      }\r\n    );\r\n\r\n    renderStatus = true;\r\n\r\n    return renderStatus;\r\n  };\r\n}\r\n\r\nSphereScissorsTool.toolName = 'SphereScissor';\r\nexport default SphereScissorsTool;\r\n","import { cache, getEnabledElement, StackViewport } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { BaseTool } from '../base';\r\nimport {\r\n    PublicToolProps,\r\n    ToolProps,\r\n    EventTypes,\r\n    SVGDrawingHelper,\r\n} from '../../types';\r\nimport { fillReplace } from \"./strategies\";\r\nimport {activeSegmentation, segmentLocking, state as segmentationState} from \"../../stateManagement/segmentation\";\r\nimport {LabelmapSegmentationDataVolume} from \"../../types/LabelmapTypes\";\r\n\r\nclass UndoTool extends BaseTool {\r\n    static toolName;\r\n    _throttledCalculateCachedStats: any;\r\n    editData: {\r\n        annotation: any;\r\n        segmentationId: string;\r\n        segmentation: any;\r\n        segmentIndex: number;\r\n        segmentsLocked: number[];\r\n        segmentColor: [number, number, number, number];\r\n        viewportIdsToRender: string[];\r\n        handleIndex?: number;\r\n        movingTextBox: boolean;\r\n        newAnnotation?: boolean;\r\n        hasMoved?: boolean;\r\n    } | null;\r\n    isDrawing: boolean;\r\n    isHandleOutsideImage: boolean;\r\n\r\n    constructor(\r\n        toolProps: PublicToolProps = {},\r\n        defaultToolProps: ToolProps = {\r\n            supportedInteractionTypes: ['Mouse', 'Touch'],\r\n            configuration: {\r\n                strategies: {\r\n                    FILL_REPLACE: fillReplace\r\n                },\r\n                defaultStrategy: 'FILL_REPLACE',\r\n                activeStrategy: 'FILL_REPLACE',\r\n            },\r\n        }\r\n    ) {\r\n        super(toolProps, defaultToolProps);\r\n    }\r\n\r\n    onSetToolPassive = () => {\r\n        window.addEventListener('UNDO_REDO_TOOL', this.applyReplaceCallback)\r\n    };\r\n\r\n    applyReplaceCallback = (evt) => {\r\n        const {element, oldScalarData} = evt.detail\r\n        const toolGroupId = this.toolGroupId;\r\n\r\n        const activeSegmentationRepresentation =\r\n            activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\r\n        if (!activeSegmentationRepresentation) {\r\n            throw new Error(\r\n                'No active segmentation detected, create one before using the brush tool'\r\n            );\r\n        }\r\n\r\n        const { segmentationId, type } = activeSegmentationRepresentation;\r\n\r\n        const { representationData } =\r\n            segmentationState.getSegmentation(segmentationId);\r\n\r\n        // Todo: are we going to support contour editing with this tool?\r\n        const { volumeId } = representationData[type] as LabelmapSegmentationDataVolume;\r\n        const segmentation = cache.getVolume(volumeId);\r\n\r\n        const operationData = {\r\n            volume: segmentation,\r\n            segmentationId,\r\n            oldScalarData\r\n        }\r\n\r\n        const currentElement = getEnabledElement(element)\r\n        this.applyActiveStrategy(currentElement, operationData)\r\n    }\r\n\r\n\r\n}\r\n\r\nUndoTool.toolName = 'Undo';\r\nexport default UndoTool;\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport { Annotation } from './AnnotationTypes';\r\n\r\n/**\r\n * Polyline winding direction\r\n *\r\n * It is defined as -1 and 1 to make it easier to change its direction multiplying\r\n * by -1 whenever polyline.reverse() is called instead of using IF/ELSE\r\n */\r\nexport enum ContourWindingDirection {\r\n  CounterClockwise = -1,\r\n  Unknown = 0,\r\n  Clockwise = 1,\r\n}\r\n\r\nexport type ContourAnnotationData = {\r\n  data: {\r\n    contour: {\r\n      polyline: Types.Point3[];\r\n      closed: boolean;\r\n      windingDirection?: ContourWindingDirection;\r\n    };\r\n  };\r\n  onInterpolationComplete?: () => void;\r\n};\r\n\r\nexport type ContourAnnotation = Annotation & ContourAnnotationData;\r\n","import { getEnabledElements, utilities as csUtils } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport type { Annotation } from '../types';\r\n\r\nconst { isEqual } = csUtils;\r\n\r\n/**\r\n * Finds a all matching viewports in terms of the orientation of the annotation data\r\n * and the frame of reference. This doesn't mean the annotation IS being displayed\r\n * on these viewports, just that it could be by navigating the slice, and/or pan/zoom,\r\n * without changing the orientation.\r\n *\r\n * @param annotation - Annotation to find the viewports that it could display in\r\n * @returns All viewports to display in\r\n */\r\nexport default function getViewportsForAnnotation(\r\n  annotation: Annotation\r\n): (Types.IStackViewport | Types.IVolumeViewport)[] {\r\n  const { metadata } = annotation;\r\n\r\n  return getEnabledElements()\r\n    .filter((enabledElement) => {\r\n      if (enabledElement.FrameOfReferenceUID === metadata.FrameOfReferenceUID) {\r\n        const viewport = enabledElement.viewport;\r\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\r\n        return (\r\n          isEqual(viewPlaneNormal, metadata.viewPlaneNormal) &&\r\n          (!metadata.viewUp || isEqual(viewUp, metadata.viewUp))\r\n        );\r\n      }\r\n      return;\r\n    })\r\n    .map((enabledElement) => enabledElement.viewport);\r\n}\r\n","import { utilities } from '@cornerstonejs/core';\r\n\r\nimport {\r\n  getAnnotationNearPoint,\r\n  getAnnotationNearPointOnEnabledElement,\r\n} from './getAnnotationNearPoint';\r\n\r\n// Lodash/common JS functionality\r\nimport debounce from './debounce';\r\nimport throttle from './throttle';\r\nimport isObject from './isObject';\r\nimport clip from './clip';\r\nimport calibrateImageSpacing from './calibrateImageSpacing';\r\nimport {\r\n  getCalibratedLengthUnitsAndScale,\r\n  getCalibratedProbeUnitsAndValue,\r\n  getCalibratedAspect,\r\n} from './getCalibratedUnits';\r\nimport triggerAnnotationRenderForViewportIds from './triggerAnnotationRenderForViewportIds';\r\nimport triggerAnnotationRenderForToolGroupIds from './triggerAnnotationRenderForToolGroupIds';\r\nimport triggerAnnotationRender from './triggerAnnotationRender';\r\nimport jumpToSlice from './viewport/jumpToSlice';\r\n\r\nimport pointInShapeCallback from './pointInShapeCallback';\r\nimport { getSphereBoundsInfo } from './getSphereBoundsInfo';\r\nimport scroll from './scroll';\r\nimport { pointToString } from './pointToString';\r\nimport annotationFrameRange from './annotationFrameRange';\r\nimport pointInSurroundingSphereCallback from './pointInSurroundingSphereCallback';\r\nimport getViewportForAnnotation from './getViewportForAnnotation';\r\nimport {\r\n  annotationHydration,\r\n  getClosestImageIdForStackViewport,\r\n} from './annotationHydration';\r\n// name spaces\r\nimport * as contours from './contours';\r\nimport * as segmentation from './segmentation';\r\nimport * as drawing from './drawing';\r\nimport * as math from './math';\r\nimport * as planar from './planar';\r\nimport * as viewportFilters from './viewportFilters';\r\nimport * as orientation from './orientation';\r\nimport * as cine from './cine';\r\nimport * as boundingBox from './boundingBox';\r\nimport * as planarFreehandROITool from './planarFreehandROITool';\r\nimport * as rectangleROITool from './rectangleROITool';\r\nimport { stackPrefetch, stackContextPrefetch } from './stackPrefetch';\r\nimport * as viewport from './viewport';\r\nimport * as touch from './touch';\r\nimport * as dynamicVolume from './dynamicVolume';\r\nimport * as polyDataUtils from './polyData/utils';\r\nimport * as voi from './voi';\r\nimport * as contourSegmentation from './contourSegmentation';\r\n\r\nconst roundNumber = utilities.roundNumber;\r\n\r\n// Events\r\nimport { triggerEvent } from '@cornerstonejs/core';\r\n\r\nexport {\r\n  math,\r\n  planar,\r\n  viewportFilters,\r\n  drawing,\r\n  debounce,\r\n  dynamicVolume,\r\n  throttle,\r\n  orientation,\r\n  isObject,\r\n  touch,\r\n  triggerEvent,\r\n  calibrateImageSpacing,\r\n  getCalibratedLengthUnitsAndScale,\r\n  getCalibratedProbeUnitsAndValue,\r\n  getCalibratedAspect,\r\n  segmentation,\r\n  contours,\r\n  triggerAnnotationRenderForViewportIds,\r\n  triggerAnnotationRenderForToolGroupIds,\r\n  triggerAnnotationRender,\r\n  pointInShapeCallback,\r\n  getSphereBoundsInfo,\r\n  getAnnotationNearPoint,\r\n  getViewportForAnnotation,\r\n  getAnnotationNearPointOnEnabledElement,\r\n  jumpToSlice,\r\n  pointInSurroundingSphereCallback,\r\n  viewport,\r\n  cine,\r\n  clip,\r\n  boundingBox,\r\n  rectangleROITool,\r\n  planarFreehandROITool,\r\n  stackPrefetch,\r\n  stackContextPrefetch,\r\n  scroll,\r\n  roundNumber,\r\n  pointToString,\r\n  polyDataUtils,\r\n  voi,\r\n  annotationFrameRange,\r\n  contourSegmentation,\r\n  annotationHydration,\r\n  getClosestImageIdForStackViewport,\r\n};\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Find the closest point to the target point\r\n *\r\n * @param sourcePoints - The potential source points.\r\n * @param targetPoint - The target point, used to find the closest source.\r\n * @returns The closest point in the array of point sources\r\n */\r\nexport default function findClosestPoint(\r\n  sourcePoints: Array<Types.Point2>,\r\n  targetPoint: Types.Point2\r\n): Types.Point2 {\r\n  let minPoint = [0, 0];\r\n  let minDistance = Number.MAX_SAFE_INTEGER;\r\n\r\n  sourcePoints.forEach(function (sourcePoint) {\r\n    const distance = _distanceBetween(targetPoint, sourcePoint);\r\n\r\n    if (distance < minDistance) {\r\n      minDistance = distance;\r\n      minPoint = [...sourcePoint];\r\n    }\r\n  });\r\n\r\n  return minPoint as Types.Point2;\r\n}\r\n\r\n/**\r\n *\r\n * @private\r\n * @param p1\r\n * @param p2\r\n */\r\nfunction _distanceBetween(p1: Types.Point2, p2: Types.Point2): number {\r\n  const [x1, y1] = p1;\r\n  const [x2, y2] = p2;\r\n\r\n  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\r\n}\r\n","import { Types, cache } from '@cornerstonejs/core';\r\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\r\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\r\nimport { SegmentationRepresentations } from '../../enums';\r\n\r\nconst segmentIndicesCache = new Map<\r\n  string,\r\n  { indices: number[]; isDirty: boolean }\r\n>();\r\n\r\n/**\r\n * Sets the segmentation as dirty, indicating that it needs to be updated.\r\n * @param segmentationId - The ID of the segmentation.\r\n */\r\nexport const setSegmentationDirty = (segmentationId: string) => {\r\n  const cached = segmentIndicesCache.get(segmentationId);\r\n  if (cached) {\r\n    cached.isDirty = true;\r\n  }\r\n};\r\n\r\nexport const setSegmentationClean = (segmentationId: string) => {\r\n  const cached = segmentIndicesCache.get(segmentationId);\r\n  if (cached) {\r\n    cached.isDirty = false;\r\n  }\r\n};\r\n\r\nfunction getCachedSegmentIndices(segmentationId) {\r\n  const cached = segmentIndicesCache.get(segmentationId);\r\n  if (cached && !cached.isDirty) {\r\n    return cached.indices;\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Retrieves the unique segment indices from a given segmentation.\r\n *\r\n * @param segmentationId - The ID of the segmentation.\r\n * @returns An array of unique segment indices.\r\n * @throws If no geometryIds are found for the segmentationId.\r\n */\r\nfunction getUniqueSegmentIndices(segmentationId) {\r\n  // Attempt to fetch from cache first\r\n  const cachedResult = getCachedSegmentIndices(segmentationId);\r\n  if (cachedResult) {\r\n    return cachedResult;\r\n  }\r\n\r\n  const segmentation = getSegmentation(segmentationId);\r\n  if (!segmentation) {\r\n    throw new Error(\r\n      `No segmentation found for segmentationId ${segmentationId}`\r\n    );\r\n  }\r\n\r\n  let indices;\r\n  switch (segmentation.type) {\r\n    case SegmentationRepresentations.Labelmap:\r\n      indices = handleLabelmapSegmentation(segmentation, segmentationId);\r\n      break;\r\n    case SegmentationRepresentations.Contour:\r\n      indices = handleContourSegmentation(segmentation);\r\n      break;\r\n    case SegmentationRepresentations.Surface:\r\n      indices = handleSurfaceSegmentation(segmentation);\r\n      break;\r\n    default:\r\n      throw new Error(`Unsupported segmentation type: ${segmentation.type}`);\r\n  }\r\n\r\n  // Update cache\r\n  segmentIndicesCache.set(segmentationId, { indices, isDirty: false });\r\n  return indices;\r\n}\r\n\r\nfunction handleLabelmapSegmentation(segmentation, segmentationId) {\r\n  const labelmapData =\r\n    segmentation.representationData[SegmentationRepresentations.Labelmap];\r\n  const keySet = new Set();\r\n\r\n  if (isVolumeSegmentation(labelmapData)) {\r\n    addVolumeSegmentIndices(keySet, segmentationId);\r\n  } else {\r\n    addImageSegmentIndices(keySet, labelmapData.imageIdReferenceMap);\r\n  }\r\n\r\n  return Array.from(keySet)\r\n    .map(Number)\r\n    .sort((a, b) => a - b);\r\n}\r\n\r\nfunction addVolumeSegmentIndices(keySet, segmentationId) {\r\n  const volume = cache.getVolume(segmentationId);\r\n  const scalarData = volume.getScalarData();\r\n  scalarData.forEach((segmentIndex) => {\r\n    if (segmentIndex !== 0) {\r\n      keySet.add(segmentIndex);\r\n    }\r\n  });\r\n}\r\n\r\nfunction addImageSegmentIndices(keySet, imageIdReferenceMap) {\r\n  imageIdReferenceMap.forEach((segmentationImageId) => {\r\n    const image = cache.getImage(segmentationImageId);\r\n    const scalarData = image.getPixelData();\r\n    scalarData.forEach((segmentIndex) => {\r\n      if (segmentIndex !== 0) {\r\n        keySet.add(segmentIndex);\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nfunction handleContourSegmentation(segmentation) {\r\n  const { annotationUIDsMap, geometryIds } =\r\n    segmentation.representationData.CONTOUR || {};\r\n  if (!geometryIds) {\r\n    throw new Error(\r\n      `No geometryIds found for segmentationId ${segmentation.segmentationId}`\r\n    );\r\n  }\r\n\r\n  const indices = new Set([...annotationUIDsMap.keys()]);\r\n  geometryIds.forEach((geometryId) => {\r\n    const geometry = cache.getGeometry(geometryId);\r\n    indices.add((geometry.data as Types.IContourSet).getSegmentIndex());\r\n  });\r\n\r\n  return Array.from(indices).sort((a, b) => a - b);\r\n}\r\n\r\nfunction handleSurfaceSegmentation(segmentation) {\r\n  const geometryIds =\r\n    segmentation.representationData.SURFACE?.geometryIds ?? [];\r\n  return Array.from(geometryIds.keys())\r\n    .map(Number)\r\n    .sort((a, b) => a - b);\r\n}\r\n\r\nexport { getUniqueSegmentIndices };\r\n","import {\r\n  triggerEvent,\r\n  eventTarget,\r\n  getRenderingEngine,\r\n  Enums,\r\n  Types,\r\n} from '@cornerstonejs/core';\r\nimport { Events as csToolsEvents } from '../../enums';\r\nimport {\r\n  getToolGroup,\r\n  getToolGroupForViewport,\r\n} from '../../store/ToolGroupManager';\r\n\r\nimport { SegmentationDisplayTool } from '../../tools';\r\nimport { SegmentationRenderedEventDetail } from '../../types/EventTypes';\r\n\r\n/**\r\n * SegmentationRenderingEngine is a class that is responsible for rendering\r\n * segmentations for a toolGroup. It will call SegmentationDisplayTool to render the segmentation\r\n * based on the segmentation data and their configurations. Note: This is a Singleton class\r\n * and should not be instantiated directly. To trigger a render for all the\r\n * segmentations of a tool group you can use.\r\n *\r\n * ```\r\n * triggerSegmentationRender(toolGroupId)\r\n * ```\r\n */\r\nclass SegmentationRenderingEngine {\r\n  private _needsRender: Set<string> = new Set();\r\n  private _animationFrameSet = false;\r\n  private _animationFrameHandle: number | null = null;\r\n  public hasBeenDestroyed: boolean;\r\n\r\n  public removeToolGroup(toolGroupId) {\r\n    this._needsRender.delete(toolGroupId);\r\n\r\n    if (this._needsRender.size === 0) {\r\n      this._reset();\r\n    }\r\n  }\r\n\r\n  public renderToolGroupSegmentations(toolGroupId): void {\r\n    this._setToolGroupSegmentationToBeRenderedNextFrame([toolGroupId]);\r\n  }\r\n\r\n  /**\r\n   *  _throwIfDestroyed Throws an error if trying to interact with the `RenderingEngine`\r\n   * instance after its `destroy` method has been called.\r\n   */\r\n  private _throwIfDestroyed() {\r\n    if (this.hasBeenDestroyed) {\r\n      throw new Error(\r\n        'this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.'\r\n      );\r\n    }\r\n  }\r\n\r\n  private _setToolGroupSegmentationToBeRenderedNextFrame(\r\n    toolGroupIds: string[]\r\n  ) {\r\n    // Add the viewports to the set of flagged viewports\r\n    toolGroupIds.forEach((toolGroupId) => {\r\n      this._needsRender.add(toolGroupId);\r\n    });\r\n\r\n    // Render any flagged viewports\r\n    this._render();\r\n  }\r\n\r\n  /**\r\n   *  _render Sets up animation frame if necessary\r\n   */\r\n  private _render() {\r\n    // If we have viewports that need rendering and we have not already\r\n    // set the RAF callback to run on the next frame.\r\n    if (this._needsRender.size > 0 && this._animationFrameSet === false) {\r\n      this._animationFrameHandle = window.requestAnimationFrame(\r\n        this._renderFlaggedToolGroups\r\n      );\r\n\r\n      // Set the flag that we have already set up the next RAF call.\r\n      this._animationFrameSet = true;\r\n    }\r\n  }\r\n\r\n  private _renderFlaggedToolGroups = () => {\r\n    this._throwIfDestroyed();\r\n\r\n    // for each toolGroupId insides the _needsRender set, render the segmentation\r\n    const toolGroupIds = Array.from(this._needsRender.values());\r\n\r\n    for (const toolGroupId of toolGroupIds) {\r\n      this._triggerRender(toolGroupId);\r\n\r\n      // This viewport has been rendered, we can remove it from the set\r\n      this._needsRender.delete(toolGroupId);\r\n\r\n      // If there is nothing left that is flagged for rendering, stop here\r\n      // and allow RAF to be called again\r\n      if (this._needsRender.size === 0) {\r\n        this._animationFrameSet = false;\r\n        this._animationFrameHandle = null;\r\n        return;\r\n      }\r\n    }\r\n  };\r\n  _triggerRender(toolGroupId) {\r\n    const toolGroup = getToolGroup(toolGroupId);\r\n\r\n    if (!toolGroup) {\r\n      console.warn(`No tool group found with toolGroupId: ${toolGroupId}`);\r\n      return;\r\n    }\r\n\r\n    const { viewportsInfo } = toolGroup;\r\n\r\n    const viewports = viewportsInfo\r\n      .map(({ viewportId, renderingEngineId }) => {\r\n        const renderingEngine = getRenderingEngine(renderingEngineId);\r\n\r\n        if (!renderingEngine) {\r\n          console.warn('rendering Engine has been destroyed');\r\n          return;\r\n        }\r\n\r\n        const viewport = renderingEngine.getViewport(viewportId);\r\n\r\n        if (viewport) {\r\n          return viewport;\r\n        }\r\n      })\r\n      .filter(Boolean);\r\n\r\n    const segmentationDisplayToolInstance = toolGroup.getToolInstance(\r\n      SegmentationDisplayTool.toolName\r\n    ) as SegmentationDisplayTool;\r\n    if (!segmentationDisplayToolInstance) {\r\n      console.warn('No segmentation tool found inside', toolGroupId);\r\n      return;\r\n    }\r\n\r\n    function onSegmentationRender(evt: Types.EventTypes.ImageRenderedEvent) {\r\n      const { element, viewportId, renderingEngineId } = evt.detail;\r\n\r\n      element.removeEventListener(\r\n        Enums.Events.IMAGE_RENDERED,\r\n        onSegmentationRender as EventListener\r\n      );\r\n\r\n      const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\r\n\r\n      if (!toolGroup) {\r\n        console.warn('toolGroup has been destroyed');\r\n        return;\r\n      }\r\n\r\n      const eventDetail: SegmentationRenderedEventDetail = {\r\n        toolGroupId: toolGroup.id,\r\n        viewportId,\r\n      };\r\n\r\n      triggerEvent(eventTarget, csToolsEvents.SEGMENTATION_RENDERED, {\r\n        ...eventDetail,\r\n      });\r\n    }\r\n\r\n    // Todo: for other representations we probably need the drawSVG, but right now we are not using it\r\n    // drawSvg(element, (svgDrawingHelper) => {\r\n    //   const handleDrawSvg = (tool) => {\r\n    //     if (tool instanceof SegmentationDisplayTool && tool.renderAnnotation) {\r\n    //       tool.renderAnnotation({ detail: eventDetail })\r\n    //       triggerEvent(element, csToolsEvents.SEGMENTATION_RENDERED, { ...eventDetail })\r\n    //     }\r\n    //   }\r\n    //   enabledTools.forEach(handleDrawSvg)\r\n    // })\r\n\r\n    viewports.forEach(({ element }) => {\r\n      element.addEventListener(\r\n        Enums.Events.IMAGE_RENDERED,\r\n        onSegmentationRender as EventListener\r\n      );\r\n    });\r\n\r\n    segmentationDisplayToolInstance.renderSegmentation(toolGroupId);\r\n  }\r\n\r\n  /**\r\n   *  _reset Resets the `RenderingEngine`\r\n   */\r\n  private _reset() {\r\n    window.cancelAnimationFrame(this._animationFrameHandle);\r\n\r\n    this._needsRender.clear();\r\n    this._animationFrameSet = false;\r\n    this._animationFrameHandle = null;\r\n  }\r\n}\r\n\r\nconst segmentationRenderingEngine = new SegmentationRenderingEngine();\r\n\r\n/**\r\n * It triggers a render for all the segmentations of the tool group with the given Id.\r\n * @param toolGroupId - The Id of the tool group to render.\r\n */\r\nfunction triggerSegmentationRender(toolGroupId: string): void {\r\n  segmentationRenderingEngine.renderToolGroupSegmentations(toolGroupId);\r\n}\r\n\r\nexport { segmentationRenderingEngine, triggerSegmentationRender };\r\nexport default triggerSegmentationRender;\r\n","import {\r\n  getEnabledElement,\r\n  triggerEvent,\r\n  getRenderingEngine,\r\n} from '@cornerstonejs/core';\r\nimport { Events, ToolModes } from '../enums';\r\nimport { draw as drawSvg } from '../drawingSvg';\r\nimport getToolsWithModesForElement from './getToolsWithModesForElement';\r\nimport { AnnotationRenderedEventDetail } from '../types/EventTypes';\r\nconst { Active, Passive, Enabled } = ToolModes;\r\n\r\n/**\r\n * AnnotationRenderingEngine is a class that is responsible for rendering\r\n * annotations defined in the renderAnnotation method of annotation tools on the page.\r\n * It mimics the RenderingEngine in the Cornerstone Core. Here it uses requestAnimationFrame\r\n * is used to render annotations by calling renderAnnotations() on each enabled tool. Note: This\r\n * is a Singleton class and should not be instantiated directly. To trigger\r\n * an annotation render for an HTML element containing a viewport you can use\r\n *\r\n * ```\r\n * triggerAnnotationRender(element)\r\n * ```\r\n */\r\nclass AnnotationRenderingEngine {\r\n  public hasBeenDestroyed: boolean;\r\n  private _needsRender: Set<HTMLDivElement> = new Set();\r\n  private _animationFrameSet = false;\r\n  private _animationFrameHandle: number | null = null;\r\n  private _viewportElements: Map<string, HTMLDivElement>;\r\n\r\n  constructor() {\r\n    this._viewportElements = new Map();\r\n  }\r\n\r\n  /**\r\n   * Add the viewport's HTMLDivElement to the viewports for rendering. This method\r\n   * just informs the annotationRenderingEngine about the viewport and\r\n   * does not initiate a render.\r\n   * @param viewportId - Viewport Unique identifier\r\n   * @param element - HTMLDivElement\r\n   */\r\n  public addViewportElement(viewportId: string, element: HTMLDivElement) {\r\n    this._viewportElements.set(viewportId, element);\r\n  }\r\n\r\n  /**\r\n   * Remove the viewport's HTMLDivElement from subsequent annotation renders\r\n   * @param viewportId - Viewport Unique identifier\r\n   */\r\n  public removeViewportElement(viewportId: string, element: HTMLDivElement) {\r\n    this._viewportElements.delete(viewportId);\r\n\r\n    // delete element from needsRender if element exist\r\n    this._needsRender.delete(element);\r\n\r\n    // I don' think there is any disadvantage to canceling the animation frame\r\n    // and resetting the flags on viewport's element removal, since the removeVIewportElement\r\n    // might be as a result of reEnabling the element (in re-enable we disable first), hence the need to render the\r\n    // new one while removing the old one\r\n    this._reset();\r\n  }\r\n\r\n  /**\r\n   * It tells the AnnotationRenderingEngine to render the viewport element the next\r\n   * time it renders.\r\n   *\r\n   * @param element - The element to render.\r\n   */\r\n  public renderViewport(element: HTMLDivElement): void {\r\n    this._setViewportsToBeRenderedNextFrame([element]);\r\n  }\r\n\r\n  /**\r\n   * _throwIfDestroyed Throws an error if trying to interact with the `RenderingEngine`\r\n   * instance after its `destroy` method has been called.\r\n   */\r\n  private _throwIfDestroyed() {\r\n    if (this.hasBeenDestroyed) {\r\n      throw new Error(\r\n        'this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.'\r\n      );\r\n    }\r\n  }\r\n\r\n  private _renderFlaggedViewports = () => {\r\n    this._throwIfDestroyed();\r\n\r\n    const elements = Array.from(this._viewportElements.values());\r\n\r\n    for (let i = 0; i < elements.length; i++) {\r\n      const element = elements[i];\r\n      if (this._needsRender.has(element)) {\r\n        this._triggerRender(element);\r\n\r\n        // This viewport has been rendered, we can remove it from the set\r\n        this._needsRender.delete(element);\r\n\r\n        // If there is nothing left that is flagged for rendering, stop here\r\n        // and allow RAF to be called again\r\n        if (this._needsRender.size === 0) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    this._animationFrameSet = false;\r\n    this._animationFrameHandle = null;\r\n\r\n    // Call render again which will use RAF to call this function asynchronously\r\n    // if there is any viewport that needs to be rendered because when\r\n    // `triggerRender` is called inside the render loop a listener can flag new\r\n    // viewports that need to be rendered and some of the viewports that were\r\n    // already rendered can be added back to `_needsRender`.\r\n    this._render();\r\n  };\r\n\r\n  private _setAllViewportsToBeRenderedNextFrame() {\r\n    const elements = [...this._viewportElements.values()];\r\n\r\n    elements.forEach((element) => {\r\n      this._needsRender.add(element);\r\n    });\r\n\r\n    this._renderFlaggedViewports();\r\n  }\r\n\r\n  private _setViewportsToBeRenderedNextFrame(elements: HTMLDivElement[]) {\r\n    const elementsEnabled = [...this._viewportElements.values()];\r\n\r\n    // Add the viewports to the set of flagged viewports\r\n    elements.forEach((element) => {\r\n      // only enabledElement need to render\r\n      if (elementsEnabled.indexOf(element) !== -1) {\r\n        this._needsRender.add(element);\r\n      }\r\n    });\r\n\r\n    // Render any flagged viewports\r\n    this._render();\r\n  }\r\n\r\n  /**\r\n   * _render Sets up animation frame if necessary\r\n   */\r\n  private _render() {\r\n    // If we have viewports that need rendering and we have not already\r\n    // set the RAF callback to run on the next frame.\r\n    if (this._needsRender.size > 0 && this._animationFrameSet === false) {\r\n      this._animationFrameHandle = window.requestAnimationFrame(\r\n        this._renderFlaggedViewports\r\n      );\r\n\r\n      // Set the flag that we have already set up the next RAF call.\r\n      this._animationFrameSet = true;\r\n    }\r\n  }\r\n\r\n  _triggerRender(element) {\r\n    const enabledElement = getEnabledElement(element);\r\n\r\n    if (!enabledElement) {\r\n      // Happens during testing, and isn't an issue as it just means there\r\n      // is overlap between shutdown and re-render\r\n      // console.warn('Element has been disabled');\r\n      return;\r\n    }\r\n\r\n    const renderingEngine = getRenderingEngine(\r\n      enabledElement.renderingEngineId\r\n    );\r\n    if (!renderingEngine) {\r\n      console.warn('rendering Engine has been destroyed');\r\n      return;\r\n    }\r\n\r\n    const enabledTools = getToolsWithModesForElement(element, [\r\n      Active,\r\n      Passive,\r\n      Enabled,\r\n    ]);\r\n\r\n    const { renderingEngineId, viewportId } = enabledElement;\r\n    const eventDetail: AnnotationRenderedEventDetail = {\r\n      element,\r\n      renderingEngineId,\r\n      viewportId,\r\n    };\r\n\r\n    // const enabledToolsWithAnnotations = enabledTools.filter((tool) => {\r\n    //   const annotations = getAnnotations(tool.getToolName(), {FrameOfReferenceUID});\r\n    //   return annotations && annotations.length;\r\n    // });\r\n\r\n    drawSvg(element, (svgDrawingHelper) => {\r\n      let anyRendered = false;\r\n      const handleDrawSvg = (tool) => {\r\n        if (tool.renderAnnotation) {\r\n          const rendered = tool.renderAnnotation(\r\n            enabledElement,\r\n            svgDrawingHelper\r\n          );\r\n          anyRendered = anyRendered || rendered;\r\n        }\r\n      };\r\n\r\n      /**\r\n       * We should be able to filter tools that don't have annotations, but\r\n       * currently some of tools have renderAnnotation method BUT\r\n       * don't keep annotation in the state, so if we do so, the tool will not be\r\n       * rendered.\r\n       */\r\n      enabledTools.forEach(handleDrawSvg);\r\n\r\n      if (anyRendered) {\r\n        triggerEvent(element, Events.ANNOTATION_RENDERED, { ...eventDetail });\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * _reset Resets the `RenderingEngine`\r\n   */\r\n  private _reset() {\r\n    window.cancelAnimationFrame(this._animationFrameHandle);\r\n\r\n    this._needsRender.clear();\r\n    this._animationFrameSet = false;\r\n    this._animationFrameHandle = null;\r\n\r\n    this._setAllViewportsToBeRenderedNextFrame();\r\n  }\r\n}\r\n\r\nconst annotationRenderingEngine = new AnnotationRenderingEngine();\r\n\r\n/**\r\n * It triggers the rendering of the annotations for the given HTML element using\r\n * the `AnnotationRenderingEngine`\r\n * @param element - The element to render the annotation on.\r\n */\r\nfunction triggerAnnotationRender(element: HTMLDivElement): void {\r\n  annotationRenderingEngine.renderViewport(element);\r\n}\r\n\r\nexport { annotationRenderingEngine, triggerAnnotationRender };\r\n\r\nexport default triggerAnnotationRender;\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport triggerAnnotationRender from './triggerAnnotationRender';\r\n\r\nexport function triggerAnnotationRenderForViewportIds(\r\n  renderingEngine: Types.IRenderingEngine,\r\n  viewportIdsToRender: string[]\r\n): void {\r\n  if (!viewportIdsToRender.length || !renderingEngine) {\r\n    return;\r\n  }\r\n\r\n  viewportIdsToRender.forEach((viewportId) => {\r\n    const viewport = renderingEngine.getViewport(viewportId);\r\n    if (!viewport) {\r\n      console.warn(`Viewport not available for ${viewportId}`);\r\n      return;\r\n    }\r\n    const { element } = viewport;\r\n    triggerAnnotationRender(element);\r\n  });\r\n}\r\n\r\nexport default triggerAnnotationRenderForViewportIds;\r\n"],"names":["BASE","iconContent","iconSize","viewBox","x","y","mousePoint","mousePointerGroupString","SEGMENTATION_CURSOR_BOUNDARIES","MINUS_RECT","PLUS_RECT","SCISSOR_ICON","RECTANGLE_ICON","CIRCLE_ICON","CursorSVG","Angle","extend","ArrowAnnotate","Bidirectional","CobbAngle","CircleROI","EllipticalROI","FreehandROI","FreehandROISculptor","Length","Probe","RectangleROI","TextMarker","Crosshairs","Eraser","Magnify","Pan","Rotate","StackScroll","WindowLevelRegion","WindowLevel","Zoom","SegmentationFreeHandEraseInside","SegmentationFreeHandFillInside","SegmentationFreeHandEraseOutside","SegmentationFreeHandFillOutside","SegmentationRectangleEraseInside","RectangleScissor","CircleScissor","base","values","Object","assign","create","registerCursor","toolName","getDefinedSVGCursorDescriptor","name","svgCursorNames","keys","ELEMENT_CURSORS_MAP","Symbol","initElementCursor","element","cursor","_getElementCursors","_setElementCursor","cursors","style","MouseCursor","getDefinedCursor","getStyleProperty","resetElementCursor","hideElementCursor","map","WeakMap","defineProperty","value","get","set","DEFINED_CURSORS","STANDARD_CURSORS","Set","constructor","fallback","this","getName","addFallbackStyleProperty","definedCursors","getDefinedCursors","mouseCursor","has","setDefinedCursor","context","symbol","Map","standardCursorNames","ImageMouseCursor","url","super","getUniqueInstanceName","Number","prefix","utilities","STATE","AnnotationStyleStates","Highlighted","MODE","ToolModes","Active","SVGMouseCursor","pointer","color","urn","type","getCursorURN","descriptor","options","URL","createObjectURL","svgString","createSVGIconWithPointer","createSVGIcon","Blob","createSVGIconBlob","createSVGIconUrl","createSVGMouseCursor","format","template","dictionary","dict","defined","prototype","hasOwnProperty","bind","replace","match","key","svgSize","Math","max","cursorName","console","log","setElementCursor","CursorNames","annotationUID","drawingElementType","nodeUID","attributes","svgNode","forEach","currentValue","getAttribute","newValue","undefined","removeAttribute","setAttribute","svgDrawingHelper","circleUID","center","radius","dataId","fill","width","lineWidth","lineDash","fillOpacity","strokeOpacity","strokeWidth","svgNodeHash","existingCircleElement","getSvgNode","cx","cy","r","stroke","setNodeTouched","newCircleElement","document","createElementNS","appendNode","ellipseUID","canvasCoordinates","existingEllipse","bottom","top","left","right","w","hypot","h","angle","atan2","PI","rx","ry","transform","svgEllipseElement","corner1","corner2","handleGroupUID","handle","uniqueIndex","handleRadius","opacity","Error","side","parseFloat","height","existingHandleElement","newHandleElement","handlePoints","i","drawLine","lineUID","start","end","isNaN","shadow","existingLine","dropShadowStyle","svgLayerElement","id","x1","y1","x2","y2","newLine","drawPolyline","polylineUID","points","length","fillColor","closePath","existingPolyLine","pointsAttribute","point","toFixed","firstPoint","newPolyLine","drawPath","pathUID","pointsArrays","Array","isArray","existingNode","numArrays","numPoints","j","d","newNode","_createTextSpan","text","textSpanElement","textContent","_drawTextBackground","group","querySelector","removeChild","getBBox","insertBefore","firstChild","bBox","textUID","textLines","position","padding","fontFamily","fontSize","background","textGroupBoundingBox","svgns","existingTextGroup","textElement","textSpans","from","children","textSpan","appendChild","textGroupAttributes","textGroup","noSelectStyle","combinedStyle","_createTextElement","_drawTextGroup","centerX","centerY","linkUID","annotationAnchorPoints","refPoint","boundingBox","findClosestPoint","boundingBoxPoints","halfWidth","halfHeight","_boundingBoxPoints","textBoxUID","textBoxPosition","textBox","mergedOptions","centering","canvasBoundingBox","drawRectByCoordinates","rectangleUID","_width","existingRect","topLeft","topRight","bottomLeft","bottomRight","leftEdgeCenter","svgRectElement","drawRect","drawArrow","arrowUID","firstLine","cos","sin","secondLine","parseInt","drawRedactionRect","tlhc","min","abs","ChangeTypes","Events","SegmentationRepresentations","StrategyCallbacks","Swipe","MouseBindings","KeyboardBindings","onImageRendered","evt","triggerAnnotationRender","detail","enable","addEventListener","Enums","IMAGE_RENDERED","disable","removeEventListener","MOUSE_CLICK","MOUSE_DOWN","MOUSE_DOWN_ACTIVATE","MOUSE_DOUBLE_CLICK","MOUSE_DRAG","MOUSE_MOVE","MOUSE_UP","MOUSE_WHEEL","KEY_DOWN","KEY_UP","Passive","Enabled","onCameraModified","getToolsWithModesForMouseEvent","tool","CAMERA_MODIFIED","onImageSpacingCalibrated","IMAGE_SPACING_CALIBRATED","TOUCH_START","TOUCH_START_ACTIVATE","TOUCH_DRAG","TOUCH_END","TOUCH_TAP","TOUCH_PRESS","eventTarget","ANNOTATION_COMPLETED","InterpolationManager","handleAnnotationCompleted","ANNOTATION_MODIFIED","handleAnnotationUpdate","ANNOTATION_REMOVED","handleAnnotationDelete","onCameraReset","onResetCamera","CAMERA_RESET","DEFAULT_CONTOUR_SEG_TOOLNAME","async","contourSegmentationCompletedListener","sourceAnnotation","annotation","viewport","viewports","viewportWithToolRegistered","find","isFreehandContourSegToolRegisteredForViewport","getViewport","contourSegmentationAnnotations","sourceAnnotationUID","getAllAnnotations","filter","targetAnnotation","isReferenceViewable","metadata","getValidContourSegmentationAnnotations","sourcePolyline","convertContourPolylineToCanvasSpace","data","contour","polyline","targetAnnotationInfo","sourceAABB","math","targetPolyline","targetAABB","aabbIntersect","lineSegmentsIntersect","isContourHole","findIntersectingContour","contourHoleProcessingEnabled","createPolylineHole","PlanarFreehandContourSegmentationTool","warn","sourceStartPoint","mergePolylines","contourHolesData","getChildAnnotations","holeAnnotation","getContourHolesData","unassignedContourHolesSet","reassignedContourHolesMap","assignHoleToPolyline","parentPolyline","holeData","holes","push","delete","newPolylines","mergedPolyline","newPolyline","contourHolesDataArray","contourHoleData","clearParentAnnotation","enabledElement","getEnabledElement","handles","segmentation","removeAnnotation","startPoint","canvasToWorld","endPoint","newAnnotation","originalToolName","cachedStats","closed","spline","highlighted","invalidated","isLocked","isVisible","interpolationUID","interpolationCompleted","targetWindingDirection","Clockwise","addAnnotation","addChildAnnotation","renderingEngine","updatedTtoolNames","viewportIdsToRender","getViewportIdsWithToolToRender","triggerAnnotationRenderForViewportIds","Promise","resolve","window","requestAnimationFrame","updateViewports","combinePolylines","silent","toolGroup","renderingEngineId","errorMessage","hasTool","getToolOptions","projectedPolyline","worldToCanvas","windingDirection","holeWindingDirection","holeContour","holePolyline","updatedToolNames","mouseDoubleClickListener","mouseDownListener","mouseMoveListener","capture","preventGhostClick","touchStartListener","passive","wheelListener","toolGroupId","triggerSegmentationRender","segmentationId","modifiedSlicesToUse","representationData","toolGroupIds","labelmapRepresentationData","segmentationVolume","cache","getVolume","volumeId","imageData","vtkOpenGLTexture","slicesToUpdate","numSlices","getDimensions","setUpdatedFrame","modified","performVolumeLabelmapUpdate","toolGroupSegmentationRepresentations","viewportsInfo","getToolGroup","getViewportsInfo","representation","viewportId","getEnabledElementByIds","VolumeViewport","actorEntry","getActor","segmentationRepresentationUID","currentImageId","getCurrentImageId","segImageData","actor","getMapper","getInputData","imageIdReferenceMap","currentSegmentationImageId","segmentationImage","getImage","performStackLabelmapUpdate","Labelmap","getToolGroupIdsWithSegmentation","getSegmentationRepresentations","triggerSegmentationRepresentationModified","perToolGroupManualTriggers","_imageChangeEventListener","eventData","getToolGroupForViewport","segmentationRepresentations","LABELMAP","labelmapData","representationList","actors","getActors","includes","uid","segmentationActor","derivedImageId","segmentationImageData","setDerivedImage","scalarArray","numberOfComponents","Uint8Array","getNumberOfPoints","getPointData","setScalars","setInputData","derivedImage","dimensions","spacing","direction","getImageDataMetadata","currentImage","imageId","origin","currentOrigin","originToUse","setOrigin","removeActors","addImages","actorUID","callback","imageActor","getPixelData","setDimensions","setSpacing","setDirection","render","BaseVolumeViewport","STACK_NEW_IMAGE","annotationCompletedListener","contourSegmentationCompleted","removed","getRenderingEngines","viewportIds","getViewports","vp","getRenderingEngine","annotationRemovedListener","removeContourSegmentationAnnotation","annotationVisibilityListener","concat","lastHidden","lastVisible","csToolsInitialized","init","defaultConfiguration","_removeCornerstoneEventListeners","elementEnabledEvent","ELEMENT_ENABLED","elementDisabledEvent","ELEMENT_DISABLED","_addCornerstoneEventListeners","_removeCornerstoneToolsEventListeners","ANNOTATION_VISIBILITY_CHANGE","ANNOTATION_SELECTION_CHANGE","SEGMENTATION_MODIFIED","SEGMENTATION_DATA_MODIFIED","SEGMENTATION_REPRESENTATION_MODIFIED","SEGMENTATION_REPRESENTATION_REMOVED","destroy","annotationManager","getAnnotationManager","segmentationStateManager","getDefaultSegmentationStateManager","restoreAnnotations","resetState","AnnotationGroup","annotationUIDs","_isVisible","visibleFilter","unboundVisibleFilter","setVisible","baseEvent","getAnnotation","eventDetail","triggerEvent","findNearby","uids","index","indexOf","add","remove","clear","FrameOfReferenceSpecificAnnotationManager","getGroupKey","annotationGroupSelector","FrameOfReferenceUID","_imageVolumeModifiedHandler","frameOfReferenceSpecificAnnotations","annotations","getFramesOfReference","getAnnotations","groupKey","frameOfReferenceUID","frameOfReferenceAnnotations","toolSpecificAnnotations","getNumberOfAnnotations","total","checkAndDefineIsLockedProperty","checkAndDefineIsVisibleProperty","groupAnnotations","toolAnnotations","findIndex","splice","removeAnnotations","removedAnnotations","annotationsForTool","saveAnnotations","state","flat","getNumberOfAllAnnotations","count","removeAllAnnotations","IMAGE_VOLUME_MODIFIED","defaultFrameOfReferenceSpecificAnnotationManager","globalLockedAnnotationsSet","setAnnotationLocked","locked","makeEventDetail","lockedAnnotationsSet","added","lock","unlock","publish","unlockAllAnnotations","clearLockedAnnotationsSet","getAnnotationsLocked","isAnnotationLocked","getAnnotationsLockedCount","size","getOwnPropertyDescriptor","configurable","setIsLocked","getIsLocked","isExtensible","shouldDefineIsLockedProperty","enumerable","freeze","item","ANNOTATION_LOCK_CHANGE","selectedAnnotationUIDs","setAnnotationSelected","selected","preserveSelected","clearSelectionSet","selectAnnotation","deselectAnnotation","getAnnotationsSelected","getAnnotationsSelectedByToolName","isAnnotationSelected","getAnnotationsSelectedCount","selection","selectionSet","defaultManager","setAnnotationManager","resetAnnotationManager","manager","childUID","parentAnnotationUID","parentAnnotation","childUIDIndex","childAnnotationUIDs","childAnnotation","parentUID","getParentAnnotation","childAnnotationUID","HTMLDivElement","annotationManagerUID","invalidateAnnotation","currAnnotation","globalHiddenAnnotationUIDsSet","setAnnotationVisibility","visible","show","annotationUIDsSet","hide","showAllAnnotations","isAnnotationVisible","setIsVisible","getIsVisible","shouldDefineIsVisibleProperty","hidden","_initializeConfig","colorHighlighted","colorSelected","colorLocked","textBoxVisibility","textBoxFontFamily","textBoxFontSize","textBoxColor","textBoxColorHighlighted","textBoxColorSelected","textBoxColorLocked","textBoxBackground","textBoxLinkLineWidth","textBoxLinkLineDash","textBoxShadow","getAnnotationToolStyles","config","getViewportToolStyles","getToolGroupToolStyles","toolGroups","getDefaultToolStyles","default","setAnnotationStyles","styles","annotationSpecificStyles","setViewportToolStyles","viewportSpecificStyles","setToolGroupToolStyles","toolGroupSpecificStyles","setDefaultToolStyles","toolStyle","specifications","_getToolStyle","property","annotationToolStyles","viewportToolStyles","global","toolGroupToolStyles","globalStyles","toolStyles","styleSpecifier","mode","Selected","Locked","autoGenerated","AutoGenerated","Default","alternatives","list","getHierarchalPropertyStyles","triggerAnnotationAddedForElement","eventType","ANNOTATION_ADDED","triggerAnnotationAddedForFOR","getToolGroupsWithToolName","viewportsToRender","viewportInfo","triggerAnnotationRemoved","triggerAnnotationModified","changeType","HandlesUpdated","triggerAnnotationCompleted","_triggerAnnotationCompleted","triggerContourAnnotationCompleted","getActiveSegmentationRepresentation","active","getActiveSegmentation","activeRepresentation","getSegmentation","setActiveSegmentationRepresentation","setSegmentationVisibility","visibility","segmentsHidden","indices","getUniqueSegmentIndices","getSegmentationVisibility","indicesSet","segmentIndex","setSegmentsVisibility","segmentIndices","segRepresentation","setSegmentVisibility","getSegmentVisibility","workerManager","getWebWorkerManager","polyDataCache","surfacesAABBCache","triggerWorkerProgress","progress","WEB_WORKER_PROGRESS","WorkerTypes","SURFACE_CLIPPING","clipAndCacheSurfacesForViewport","surfacesInfo","planesInfo","getSlicesClippingPlanes","currentSliceIndex","getSliceIndex","sort","a","b","sliceIndex","surfacesWithoutAABB","surface","surfacesAABB","executeTask","callbacks","aabb","updateSurfacesAABBCache","camera","getCamera","polyDataResults","polyDataResult","surfaceId","cacheId","viewPlaneNormal","pointToString","generateCacheId","lines","numberOfCells","actorCache","updatePolyDataCache","catch","error","getSurfaceActorUID","segmentationRepresentationUIDs","immediate","toolGroupSegRepresentations","toolGroupSegRepresentationUIDs","segRepresentationUIDsToRemove","invalidSegRepresentationUIDs","segRepresentationUID","JSON","stringify","segmentationDataUID","segmentationRepresentation","getSegmentationRepresentationByUID","removeSegmentationRepresentation","Contour","_removeSegmentation","segmentationInputArray","segmentationInput","segInput","addSegmentation","getGlobalConfig","setGlobalConfig","segmentationConfig","getGlobalRepresentationConfig","representationType","representations","setGlobalRepresentationConfig","globalConfig","getToolGroupSpecificConfig","setToolGroupSpecificConfig","segmentationRepresentationConfig","getSegmentationRepresentationSpecificConfig","setSegmentationRepresentationSpecificConfig","getSegmentSpecificConfig","setSegmentSpecificConfig","getRepresentationSpecificConfig","representationInput","addSegmentationRepresentation","toolGroupSpecificConfig","colorLUTIndexToUse","colorLUTOrIndexInput","colorLUTOrIndex","nextIndex","getNextColorLUTIndex","colorLUTToAdd","addColorLUT","getColorLUTIndex","toolGroupSpecificRepresentation","colorLUTIndex","segmentationRepresentationSpecificConfig","segmentSpecificConfig","polySeg","currentToolGroupConfig","mergedConfig","renderInactiveSegmentations","representationInputArray","toolGroupSpecificRepresentationConfig","promises","all","Surface","computeVolumeSegmentationFromStack","segmentationImageIds","additionalDetails","volumeLoader","convertStackToVolumeSegmentation","removeOriginal","removeImageLoadObject","addEventListenerOnce","SEGMENTATION_RENDERED","triggerSegmentationDataModified","updateSegmentationState","computeStackSegmentationFromVolume","isAllImagesCached","imageCacheOffsetMap","imageIds","every","volumeUsedInOtherViewports","getVolumeViewports","hasVolumeId","decache","referencedImageIds","startsWith","createImageIdReferenceMap","reverse","referencedVolumeId","referencedVolume","segmentationImageIdsToUse","convertToImageSlicesAndCache","_getImageIdReferenceMapForStackSegmentation","convertVolumeToStackSegmentation","removeVolumeLoadObject","updateStackSegmentationState","isSegmentIndexLocked","segmentsLocked","setSegmentIndexLocked","triggerSegmentationModified","getLockedSegments","colorLUT","unshift","setColorLUT","getColorForSegmentIndex","colorValue","setColorForSegmentIndex","colorReference","computedRepresentations","computeAndAddRepresentation","computeFunction","updateFunction","registerPolySegWorker","debouncedUpdateFunction","event","_debouncedSegmentationModified","_debouncedUpdateFunction","subscribeToSegmentationChanges","debounce","POLYSEG_CONTOUR_TO_SURFACE","createAndCacheSurfacesFromRaw","rawSurfacesData","findSegmentationRepresentationByUID","geometryIds","rawSurfaceData","slice","closedSurface","polys","geometryId","geometryLoader","SURFACE","geometryData","POLYSEG_LABELMAP_TO_SURFACE","computeSurfaceData","CONTOUR","contourRepresentationData","annotationUIDsMap","polylines","numPointsArray","results","convertContourToSurface","computeSurfaceFromContourSegmentation","computeSurfaceFromLabelmapSegmentation","isVolume","volume","scalarData","getScalarData","convertLabelmapToSurface","surfaces","allSettled","errors","p","status","Boolean","computeAndAddSurfaceRepresentation","surfacesObj","getGeometry","setPoints","setPolys","geometry","updateSurfaceData","POLYSEG_CONTOUR_TO_LABELMAP","convertContourToVolumeLabelmap","segmentationVolumeId","volumeProps","annotationUIDsInSegmentMap","_getAnnotationMapFromSegmentation","newScalarData","getScalars","setData","convertContourToStackLabelmap","getImageIds","getImageLoadObject","imageLoader","segmentationsInfo","segImageId","segImage","imagePlaneModule","metaData","IMAGE_PLANE","columnCosines","rowCosines","rowPixelSpacing","columnPixelSpacing","imagePositionPatient","rowCosineVec","colCosineVec","scanAxisNormal","newSegmentationsScalarData","referencedImageId","segmentationInfo","imageFrame","pixelData","annotationMap","annotationUIDsInSegment","hasChildAnnotations","holesPolyline","POLYSEG_SURFACE_TO_LABELMAP","computeLabelmapData","rawLabelmapData","convertFunction","result","computeLabelmapFromContourSegmentation","segmentsGeometryIds","defaultActor","getDefaultActor","surfaceRepresentationData","segmentsInfo","getPoints","getPolys","convertSurfaceToVolumeLabelmap","computeLabelmapFromSurfaceSegmentation","computeAndAddLabelmapRepresentation","extractContourData","segmentIndexMap","rawResults","intersectionInfo","split","_","_extractLineSegments","contourData","lineSegments","linesNumberOfPoints","pointsInLine","computeContourData","rawContourData","segmentIndexToSurfaceId","surfaceIdToSegmentIndex","computeContourFromSurfaceSegmentation","pointsAndPolys","toString","computeContourFromLabelmapSegmentation","contoursData","line","pointIndex","contourSegmentationAnnotation","getViewReference","currentSet","createAndAddContourSegmentationsFromClippedSurfaces","fillAlpha","computeAndAddContourRepresentation","conversionPaths","canComputeRequestedRepresentation","representationInfo","enabled","existingRepresentationTypes","supportedTypes","representationTypeData","validateFn","getExistingRepresentationTypes","some","existingRepresentationType","fromRepresentationType","toRepresentationType","canConvertFromTo","registered","registerWorker","Worker","maxWorkerInstances","autoTerminateOnIdle","idleTimeThreshold","setActiveSegmentIndex","activeSegmentIndex","invalidateBrushCursor","getActiveSegmentIndex","defaultLabelmapConfig","defaultContourConfig","defaultSurfaceConfig","initialDefaultState","segmentations","defaultSegmentationStateManager","getState","getToolGroups","getColorLUT","lutIndex","toolGroupSegRepresentationsWithConfig","getAllSegmentationRepresentations","toolGroupSegReps","entries","_handleActiveSegmentation","segmentationData","removeSegmentation","segData","removedSegmentationRepresentation","toolGroupSegmentations","toolGroupStateWithConfig","setSegmentationRepresentationConfig","removeColorLUT","recentlyAddedOrRemovedSegmentationRepresentation","isContourRepresentation","segmentLabels","label","getSegmentations","suppressEvents","getSegmentationIdRepresentations","allRepresentations","foundRepresentations","foundRepresentation","allToolGroupRepresentations","foundToolGroupIds","getSegmentSpecificRepresentationConfig","setSegmentSpecificRepresentationConfig","getToolGroupIdFromSegmentationRepresentationUID","triggerSegmentationRemoved","triggerSegmentationRepresentationRemoved","removeSegmentationRepresentations","SEGMENTATION_REMOVED","segmentationIds","_getViewportIndex","arr","ar","_containsViewport","synchronizerId","eventName","eventHandler","_viewportOptions","_onEvent","_ignoreFiredEvents","_targetViewports","currentTarget","_sourceViewports","s","fireEvent","_enabled","_eventName","_eventHandler","_options","_auxiliaryEventNames","auxiliaryEventNames","isDisabled","_hasSourceElements","setOptions","setEnabled","getOptions","addTarget","addSource","_updateDisableHandlers","getSourceViewports","getTargetViewports","removeSource","t","removeTarget","_getViewportElement","hasSourceViewport","hasTargetViewport","sourceViewport","sourceEvent","targetViewport","ex","then","vp1","vp2","unique","vps","u","_getUniqueViewports","_remove","disableHandler","vUid","synchronizersFilteredByIds","synchronizers","synchronizer","notDisabled","sync","Synchronizer","pop","synchronizerIndex","re","toolGroupFilteredByIds","tg","addTool","ToolClass","toolAlreadyAdded","tools","toolClass","removeTool","addEnabledElement","svgLayer","svgLayerId","classList","pointerEvents","defs","feOffset","feColorMatrix","feBlend","_createSvgAnnotationLayer","viewportUid","renderingEngineUid","dataset","elementHash","svgNodeCache","_setSvgNodeCache","addViewportElement","enabledElements","VIEWPORT_ELEMENT","_removeViewportFromSynchronizers","getSynchronizersForViewport","_removeViewportFromToolGroup","removeViewports","_removeEnabledElement","foundElementIndex","el","elementDisabledEvt","_resetSvgNodeCache","internalViewportNode","_removeSvgNode","removeViewportElement","cancelActiveManipulations","toolsWithData","cancel","defaultState","isInteractingWithTool","isMultiPartToolActive","resetCornerstoneToolsState","resetSvgNodeCache","cameraSyncCallback","synchronizerInstance","cameraModifiedEvent","tViewport","setCamera","createCameraPositionSynchronizer","synchronizerName","createSynchronizer","presentationViewSyncCallback","_synchronizerInstance","_sourceEvent","presentationView","getViewPresentation","setViewPresentation","createPresentationViewSynchronizer","voiSyncCallback","modifiedEvent","range","invertStateChanged","invert","colormap","tProperties","voiRange","syncInvertState","syncColormap","_actors","setProperties","StackViewport","createVOISynchronizer","VOI_MODIFIED","COLORMAP_MODIFIED","zoomPanSyncCallback","sViewport","syncZoom","srcZoom","getZoom","setZoom","syncPan","srcPan","getPan","setPan","createZoomPanSynchronizer","getSpatialRegistration","targetId","sourceId","imageSliceSyncCallback","disabled","imageId1","sourceImagePositionPatient","targetImageIds","viewport1","viewport2","viewPlaneNormal1","viewPlaneNormal2","dotProducts","areViewportsCoplanar","registrationMatrixMat4","getFrameOfReferenceUID","useInitialPosition","targetImagePositionPatientWithRegistrationMatrix","closestImageIdIndex2","targetPoint","reduce","closestImageIdIndex","distance","Infinity","imageIndexToSet","getCurrentImageIdIndex","jumpToSlice","imageIndex","VOLUME_NEW_IMAGE","createImageSliceSynchronizer","slabThicknessSyncCallback","slabThickness","getSlabThickness","setSlabThickness","createStackImageSynchronizer","AdvancedMagnifyToolActions","AdvancedMagnifyTool","Actions","toolProps","defaultToolProps","supportedInteractionTypes","configuration","magnifyingGlass","zoomFactor","zoomFactorList","autoPan","actions","showZoomFactorsList","method","bindings","mouseButton","Secondary","modifierKey","Shift","addNewAnnotation","currentPoints","worldPos","world","canvasPos","canvas","canvasHandlePoints","_getCanvasHandlePoints","viewUp","getReferencedImageId","magnifyViewportId","getToolName","sourceViewportId","isCanvasAnnotation","activeHandleIndex","magnifyViewportManager","createViewport","sourceEnabledElement","annotationPoints","canvasDelta","delta","len","preventDefault","onSetToolDisabled","dispose","isPointNearTool","canvasCoords","proximity","canvasTop","canvasBottom","canvasLeft","radiusPoint","toolSelectedCallback","editData","_activateModify","handleSelectedCallback","handleIndex","_endCallback","_deactivateModify","isDrawing","_dragDrawCallback","deltaPoints","hasMoved","_dragModifyCallback","_dragHandle","canvasCenter","currentCanvasPoints","newRadius","newCanvasHandlePoints","renderAnnotation","renderStatus","filteredAnnotations","filterInteractableAnnotationsForElement","getStyle","activeHandleCanvasCoords","drawHandles","drawCircle","magnifyViewport","update","canvasCenterPos","canvasRadius","getInstance","canvasPoint","viewportElement","currentZoomFactor","dropdown","_getZoomFactorsListDropdown","newZoomFactor","parentElement","focus","onChangeCallback","createElement","stopPropagation","keyCode","which","toLowerCase","option","title","defaultSelected","AnnotationEraserTool","preMouseDownCallback","_deleteNearbyAnnotations","preTouchStartCallback","interactionType","_toolInstances","annotationsToRemove","toolInstance","interactableAnnotations","RENDERING_DEFAULTS","CONSTANTS","defaultReferenceLineColor","defaultReferenceLineControllable","defaultReferenceLineDraggableRotatable","defaultReferenceLineSlabThicknessControlsOn","OPERATION","CrosshairsTool","viewportIndicators","viewportIndicatorsConfig","panSize","referenceLinesCenterGapRadius","filterActorUIDsToSetSlabThickness","slabThicknessBlendMode","MAXIMUM_INTENSITY_BLEND","mobile","toolCenter","initializeViewport","focalPoint","_getAnnotations","cameraPosition","cameraFocalPoint","rotationPoints","slabThicknessPoints","activeOperation","activeViewportIds","normal","clientWidth","clientHeight","_getViewportsInfo","resetCrosshairs","resetCamera","resetSlabThickness","computeToolCenter","firstViewport","secondViewport","thirdViewport","normal1","point1","normal2","point2","normal3","point3","firstPlane","secondPlane","thirdPlane","jumpWorld","_jump","viewportIdArray","otherViewport","viewportControllable","_getReferenceLineControllable","viewportDraggableRotatable","_getReferenceLineDraggableRotatable","_pointNearTool","viewportAnnotation","currentCamera","oldCameraPosition","deltaCameraPosition","oldCameraFocalPoint","deltaCameraFocalPoint","isRotation","cameraModifiedInPlane","getViewportIds","_autoPanViewportIfNecessary","mouseMoveCallback","filteredToolAnnotations","imageNeedsUpdate","previousActiveOperation","previousActiveViewportIds","near","getHandleNearImagePoint","_areViewportIdArraysEqual","canvasDiagonalLength","sqrt","canvasMinDimensionLength","crosshairCenterCanvas","otherViewportAnnotations","_filterAnnotationsByUniqueViewportOrientations","referenceLines","canvasBox","otherCamera","otherViewportControllable","otherViewportDraggableRotatable","otherViewportSlabThicknessControlsOn","_getReferenceLineSlabThicknessControlsOn","otherCanvasDiagonalLength","otherCanvasCenter","otherViewportCenterWorld","pointWorld0","pointWorld1","pointCanvas0","otherViewportCenterCanvas","canvasUnitVectorFromCenter","canvasVectorFromCenterLong","canvasVectorFromCenterMid","canvasVectorFromCenterShort","canvasVectorFromCenterStart","centerGap","refLinePointOne","refLinePointTwo","refLinePointThree","refLinePointFour","refLinesCenter","rotHandleOne","rotHandleTwo","stHandlesCenterCanvas","stHandlesCenterWorld","worldUnitVectorFromCenter","matrix","buildFromDegree","rotate","worldUnitOrthoVectorFromCenter","slabThicknessValue","worldOrthoVectorFromCenter","worldVerticalRefPoint","canvasVerticalRefPoint","canvasOrthoVectorFromCenter","stLinePointOne","stLinePointTwo","stLinePointThree","stLinePointFour","stHandleOne","stHandleTwo","stHandleThree","stHandleFour","newRtpoints","newStpoints","viewportColor","_getReferenceLineColor","lineIndex","viewportSlabThicknessControlsOn","selectedViewportId","lineActive","rotHandlesActive","rotationHandles","rotHandleWorldOne","rotHandleWorldTwo","slabThicknessHandlesActive","slabThicknessHandles","slabThicknessHandleWorldOne","slabThicknessHandleWorldTwo","slabThicknessHandleWorldThree","slabThicknessHandleWorldFour","handleUID","referenceColorCoordinates","xOffset","yOffset","circleRadius","_onNewVolume","e","viewportIdArrayOne","viewportIdArrayTwo","itemFound","_getAnnotationsForViewportsWithDifferentCameras","viewportsWithDifferentCameras","cameraOfTarget","_filterViewportWithSameOrientation","referenceAnnotation","linkedViewportAnnotations","otherViewPlaneNormal","otherLinkedViewportAnnotationsFromSameScene","otherViewportsAnnotationsWithUniqueCameras","cameraFound","jj","cameraOfStocked","otherNonLinkedViewportAnnotationsFromSameScene","_checkIfViewportsRenderingSameScene","otherViewportActors","sameScene","viewportsAnnotationsToUpdate","_applyDeltaShiftToSelectedViewportCameras","_dragCallback","dir1","dir2","centerCanvas","finalPointCanvas","originalPointCanvas","_isClockWise","round","rotationAxis","buildFromRadian","translate","otherViewportsIds","renderViewports","referenceAnnotations","viewportsIds","dotProd","projectedDelta","mod","currentPoint","lastPoints","currentCenter","otherViewportRotationPoints","dotProdDirection","projectedDirection","normalizedProjectedDirection","normalizedProjectedDelta","MINIMUM_SLAB_THICKNESS","_pointNearReferenceLine","getToolInstance","lineViewport","lineSegment1","distanceToPoint1","lineSegment2","distanceToPoint2","getReferenceLineColor","getReferenceLineControllable","getReferenceLineDraggableRotatable","getReferenceLineSlabThicknessControlsOn","onSetToolActive","_unsubscribeToViewportNewVolumeSet","_subscribeToViewportNewVolumeSet","onSetToolPassive","onSetToolEnabled","_getRotationHandleNearImagePoint","_getSlabThicknessHandleNearImagePoint","VOLUME_VIEWPORT_NEW_VOLUME","toolCenterCanvas","pan","visiblePointCanvas","visiblePointWorld","deltaPointsWorld","updatedPosition","updatedFocalPoint","actorUIDs","blendModeToUse","COMPOSITE","setBlendMode","c","_applyDeltaShiftToViewportCamera","newFocalPoint","newPosition","annotationCanvasCoordinate","stPointLineCanvas1","stPointLineCanvas2","stPointLineCanvas1Start","stPointLineCanvas2Start","MIPJumpToClickTool","targetViewportIds","mouseClickCallback","getTargetId","maxIntensity","brightestPoint","getPointInLineOfSightWithCriteria","intensity","foundToolGroup","MAGNIFY_VIEWPORT_ID","MagnifyTool","magnifySize","magnifyWidth","magnifyHeight","_hasBeenRemoved","_getReferencedImageId","_createMagnificationViewport","_activateDraw","viewportProperties","getProperties","magnifyToolElement","magnifyElement","display","viewportInput","STACK","enableElement","setStack","parallelScale","pow","_dragEndCallback","disableElement","_deactivateDraw","OverlayMarkerType","ANNOTATED_CUBE","AXES","CUSTOM","OrientationMarkerTool","CUBE","AXIS","VTPFILE","OVERLAY_MARKER_TYPES","orientationWidget","viewportCorner","Corners","BOTTOM_RIGHT","viewportSize","minPixelSize","maxPixelSize","overlayMarkerType","overlayConfiguration","faceProperties","xPlus","faceColor","faceRotation","xMinus","yPlus","fontColor","yMinus","zPlus","zMinus","defaultStyle","fontStyle","fontSizeScale","res","edgeThickness","edgeColor","resolution","polyDataURL","_resizeObservers","initViewports","_subscribeToViewportEvents","cleanUpData","resize","orientationMarker","orientationMarkers","updateViewport","unsubscribe","unobserve","TOOLGROUP_VIEWPORT_ADDED","subscribeToElementResize","resizeObserver","ResizeObserver","setTimeout","observe","offscreenMultiRenderWindow","getRenderWindow","filterViewportsWithToolEnabled","getWidget","addAxisActorInViewport","getRenderer","removeActor","createAnnotationCube","createCustomActor","renderer","renderWindow","interactor","getInteractor","parentRenderer","setViewportCorner","setViewportSize","setMinPixelSize","setMaxPixelSize","updateMarkerOrientation","addWidget","response","fetch","arrayBuffer","vtpReader","parseAsArrayBuffer","polyData","shallowCopy","getOutputData","setActiveScalars","mapper","setColorModeToDirectScalars","setMapper","rotateZ","setDefaultStyle","setXPlusFaceProperty","setXMinusFaceProperty","setYPlusFaceProperty","setYMinusFaceProperty","setZPlusFaceProperty","setZMinusFaceProperty","createAnnotatedCubeActor","axes","annotatedCube","methodName","charAt","toUpperCase","EPSILON","OverlayGridTool","sourceImageIds","_init","pointSets","calculateImageIdPointSets","viewportData","rows","columns","pointSet1","pointSet2","imageIdNormal","getImageIdNormal","isParallel","targetViewportPlane","targetData","initializeViewportData","pointSetsToUse","pointSetToUse","topBottomVec","isPerpendicular","lineStartsWorld","lineEndsWorld","lineStartWorld","lineEndWorld","vec1","vec2","dot","imageOrientationPatient","PanTool","touchDragCallback","mouseDragCallback","PlanarRotateTool","startPoints","currentPointWorld","startPointWorld","centerWorld","v1","v2","cross","rotAngle","rotMat","Float32Array","rotatedViewUp","rotation","ReferenceCursors","preventHandleOutsideImage","displayThreshold","positionSync","disableCursor","isHandleOutsideImage","_elementWithCursor","_currentCursorWorldPosition","_currentCanvasPosition","_disableCursorEnabled","getActiveAnnotation","createInitialAnnotation","updateAnnotationPosition","worldPosition","worldBoundingBox","previousCamera","oldFocalPoint","cameraNormal","dotProduct","newWorldPos","isElementWithCursor","updateViewportImage","lineWidthBase","crosshairUIDs","upper","lower","centerSpace","lineLength","plane","currentMousePosition","closestIndex","setImageIdIndex","currentDistance","normalizedViewPlane","scaledPlaneNormal","renderViewport","ReferenceLines","showFullDimension","getImageData","sourceViewportCanvasCornersInWorld","onSetToolConfiguration","getEnabledElementByViewportId","sourceViewPlaneNormal","topRightVec","newNormal","handleFullDimension","targetImage","getTargetIdImage","topLeftImageCoord","topRightImageCoord","bottomRightImageCoord","bottomLeftImageCoord","indexToWorld","lineStartImageCoord","lineEndImageCoord","intersectInfiniteLines","isInBound","err","line1Start","line1End","line2Start","line2End","x3","y3","x4","y4","a1","b1","c1","a2","b2","c2","viewportsWithAnnotations","ScaleOverlayTool","scaleLocation","viewportCanvasCornersInWorld","thisAnnotation","computeScaleSize","worldWidthViewport","worldHeightViewport","location","scaleSizes","currentScaleSize","scaleSize","computeEndScaleTicks","locationTickOffset","endTick1","endTick2","computeInnerScaleTicks","leftTick","rightTick","canvasScaleSize","tickIds","tickUIDs","tickCoordinates","numberSmallTicks","tickSpacing","locationOffset","computeWorldScaleCoordinates","pointSet","worldCoordinates","midpointLocation","midpoint","offset","computeCanvasScaleCoordinates","canvasSize","vscaleBounds","hscaleBounds","scaleCanvasCoordinates","worldDistanceOnCanvas","computeScaleBounds","horizontalReduction","verticalReduction","hReduction","vReduction","locationBounds","canvasBounds","devicePixelRatio","scaleTicks","scaleId","leftTickId","rightTickId","locationTextOffest","textCanvasCoordinates","textBoxLines","_getTextLines","drawTextBox","scaleSizeDisplayValue","scaleSizeUnits","SculptorTool","minSpacing","referencedToolNames","toolShape","referencedToolName","registeredShapes","isActive","commonData","activeAnnotationUID","isEditingOpenContour","canvasLocation","configureToolSize","selectFreehandTool","activateModify","updateCursor","endCallback","deactivateModify","activeAnnotation","filterSculptableAnnotationsForElement","calculateStats","dragCallback","sculpt","registerShapes","shapeName","setToolShape","shapeClass","shape","cursorShape","selectedShape","sculptData","mouseCanvasPoint","maxSpacing","getMaxSpacing","pushedHandles","pushHandles","first","insertNewHandles","interpolatePointsWithinMaxSpacing","indicesToInsertAfter","nextHandleIndex","contourIndex","currentCanvasPoint","nextCanvasPoint","updateToolSize","sculptableAnnotations","findNewHandleIndices","newIndexModifier","insertIndex","insertHandleRadially","last","previousIndex","handleData","getInsertPosition","closestAnnotationUID","getClosestFreehandToolOnElement","canvasPoints","closest","toolIndex","distanceFromTool","renderShape","SegmentationIntersectionTool","actorsWorldPointsMap","calculateSurfaceSegmentationIntersectionsForViewport","calculateSurfaceSegmentationIntersections","actorEntries","getCacheId","clippingFilter","actorWorldPointMap","polyLineIdx","worldPointsSet","polyLineUID","actorWorldPointsMap","polyDataUtils","colorArray","colorComponentToString","component","componentString","floor","colorToString","getProperty","getColor","StackScrollTool","debounceIfNotLoaded","loop","deltaY","deltaPointY","pixelsPerImage","_getPixelPerImage","imageIdIndexOffset","scroll","debounceLoading","numberOfSlices","getNumberOfSlices","offsetHeight","StackScrollMouseWheelTool","scrollSlabs","mouseWheelCallback","wheel","TrackballRotateTool","rotateIncrementDegrees","_hasResolutionChanged","originalSampleDistance","getSampleDistance","setSampleDistance","cleanUp","once","_viewportAddedListener","disconnect","rotateCamera","axis","vtkCamera","getVtkActiveCamera","getViewUp","getFocalPoint","getPosition","newViewUp","currentPointsCanvas","lastPointsCanvas","normalizedPosition","normalizedPreviousPosition","radsq","op","oe","opsq","oesq","lop","loe","nop","noe","angleX","acos","sign","upVec","atV","rightV","forwardV","angleY","DIRECTIONS","VolumeRotateMouseWheelTool","cz","ax","ay","az","WindowLevelRegionTool","minWindowWidth","applyWindowLevelRegion","bottomLeftCanvas","topRightCanvas","bottomRightCanvas","topLeftCanvas","bottomRightWorld","topLeftWorld","getAnnotationStyle","windowLevel","startCanvas","endCanvas","clip","pixelLuminanceData","minMaxMean","minPixelValue","maxPixelValue","windowWidth","windowCenter","mean","WindowLevelTool","_getImageDynamicRangeFromMiddleSlice","middleSliceIndex","frameLength","bytesPerVoxel","TypedArrayConstructor","Uint16Array","Int16Array","frame","buffer","_getMinMax","modality","newRange","viewportsContainingVolumeUID","isPreScaled","properties","Modality","scaling","preScale","scaled","scalingParameters","suvbw","getPTScaledNewRange","deltaPointsCanvas","getNewRange","multiplier","_getMultiplierFromDynamicRange","wwDelta","wcDelta","imageDynamicRange","imageVolume","calculatedDynamicRange","BitsStored","metadataDynamicRange","_getImageDynamicRangeFromViewport","ratio","getRange","imageDataRange","getData","voxel","ZoomTool","zoomToCenter","minZoomScale","maxZoomScale","pinchToZoom","initialMousePosWorld","dirVec","_dragParallelProjection","pinch","deltaDistance","k","parallelScaleToSet","focalPointToSet","positionToSet","distanceToCanvasCenter","scale","cappedParallelScale","thresholdExceeded","_dragPerspectiveProjection","zoomScale","directionOfProjection","tmp","_pinchCallback","currentPointsList","parallelProjection","_panCallback","AngleTool","getTextLines","defaultGetTextLines","angleStartedNotYetCompleted","movingTextBox","canvasPoint1","canvasPoint2","line1","canvasPoint3","line2","worldPosDelta","_throttledCalculateCachedStats","_calculateCachedStats","getLinkedTextBoxStyle","canvasTextBoxCoords","drawLinkedTextBox","trailing","worldPos1","worldPos2","worldPos3","targetIds","cachedVolumeStats","roundNumber","String","fromCharCode","AnnotationMode","ArrowAnnotateTool","getTextCallback","changeTextCallback","arrowFirst","removeArrowAnnotation","addNewAnnotationWithMode","creation","MOVABLE_POINTS","dentascan","DENTASCAN","handmade","_manageClickCallback","_prolongateCallback","touchTapCallback","taps","doubleClickCallback","clickedAnnotation","_doneChangingTextCallback","stopImmediatePropagation","updatedText","_isInsideVolume","index1","index2","doneChangingTextCallback","prompt","transformWorldToIndex","BidirectionalTool","distanceToPoint","firstLineSegmentLength","longAxis","shortAxisPoint0","shortAxisPoint1","longAxisVector","counterClockWisePerpendicularToLongAxis","currentShortAxisVector","shortAxis","canvasCoordPoints","shortAxisDistFromCenter","dx","dy","vectorX","vectorY","xMid","yMid","startX","startY","endX","endY","_dragModifyHandle","movingHandleIndex","canvasCoordHandlesCurrent","firstLineSegment","secondLineSegment","proposedPoint","proposedCanvasCoord","fixedHandleCanvasCoord","fixedHandleToProposedCoordVec","fixedHandleToOldCoordVec","proposedFirstLineSegment","_movingLongAxisWouldPutItThroughShortAxis","centerOfRotation","_getSignedAngle","firstPointX","firstPointY","secondPointX","secondPointY","rotatedFirstPoint","rotatedFirstPointY","rotatedSecondPoint","rotatedSecondPointY","newFirstPoint","newSecondPoint","translateHandleIndex","canvasCoordsCurrent","longLineSegment","shortLineSegment","longLineSegmentVec","longLineSegmentVecNormalized","proposedToCurrentVec","movementLength","movementAlongLineSegmentLength","newTranslatedPoint","unit","dataId1","dataId2","secondLineUID","getTextBoxCoordsCanvas","vectorInSecondLineDirection","extendedSecondLineSegment","worldPos4","image","index3","index4","handles1","handles2","scale1","units","units1","scale2","units2","dist1","_calculateLength","dist2","lengthUnit","widthUnit","vector1","vector2","pos1","pos2","dz","CircleROITool","centerPointRadius","statsCalculator","BasicStatsCalculator","dXCanvas","dYCanvas","canvasEnd","canvasCorners","areaUnit","getStackViewports","referencedImageURI","hasImageURI","currentImageURI","area","stdDev","radiusUnit","perimeter","hasPixelSpacing","pos1Index","pos2Index","boundsIJK","ellipseObj","xRadius","yRadius","zRadius","worldWidth","worldHeight","isEmptyArea","areaUnits","getCalibratedLengthUnitsAndScale","aspect","modalityUnitOptions","isSuvScaled","modalityUnit","pointsInShape","pointInShapeCallback","pointLPS","pointInEllipse","fast","statsCallback","stats","getStatistics","statsArray","array","radiusLine","areaLine","CobbAngleTool","showArcLines","distanceToLines","isNearFirstLine","isNearSecondLine","_mouseUpCallback","_mouseDownCallback","_mouseDragCallback","arc1Angle","arc2Angle","arc1Start","arc1End","arc2Start","arc2End","mid1","mid2","arc1TextBoxUID","arc1TextLine","arch1TextPosCanvas","arc2TextBoxUID","arc2TextLine","arch2TextPosCanvas","point4","canvasPoint4","getArcsStartEndPoints","linkLine","arc1Side","arc2Side","midLinkLine","linkLineLength","midFirstLine","midSecondLine","directionVectorStartArc1","magnitudeStartArc1","normalizedDirectionStartArc1","directionVectorEndArc1","magnitudeEndArc1","normalizedDirectionEndArc1","directionVectorStartArc2","magnitudeStartArc2","normalizedDirectionStartArc2","directionVectorEndArc2","magnitudeEndArc2","normalizedDirectionEndArc2","seg1","seg2","minDist","MAX_VALUE","dist","DragProbeTool","postMouseDownCallback","postTouchStartCallback","EllipticalROITool","initialRotation","getRotation","getCanvasEllipseCorners","minorEllipse","majorEllipse","pointInMinorEllipse","_pointInEllipseCanvas","canvasWidth","canvasHeight","originalHandleCanvas","pointsCanvas","dX","dY","bottomCanvas","topCanvas","leftCanvas","rightCanvas","newHalfCanvasWidth","canvasRight","newHalfCanvasHeight","centerPoint","_getCanvasEllipseCenter","post2Index","ellipse","normalized","ellipseCanvasPoints","KeyImageTool","canvasPosition","createAnnotation","it","LengthTool","LivewireContourSegmentationTool","updateInterpolatedAnnotation","interpolationSources","originalPolyline","queueMicrotask","setupBaseEditData","scissors","nearestEdge","repeatInterpolation","interpolation","originalPoints","worldToSlice","sliceToWorld","handleSmoothing","lastPoint","hIndex","testPoint","startSearch","findPathToPoint","minPoint","findMinNearby","acceptedPath","path","addPoints","updateAnnotation","scissorsNext","InterpolationUpdated","renderAnnotationInstance","renderContext","showInterpolationPolyline","rendered","polylineCanvasPoints","isContourSegmentationTool","LivewireContourTool","contourHoleAdditionModifierKey","snapHandleNearby","decimate","epsilon","undo","proximitySquared","clearAnnotation","clearEditData","Completed","triggerChangeEvent","StatsUpdated","doubleClick","worldPosOriginal","controlPoints","currentPath","getControlPoints","closestHandlePoint","distSquared","worldControlPoint","canvasControlPoint","snapPoint","pathPoints","prependPath","confirmedPath","getLastPoint","addControlPoint","_mouseMoveCallback","lastCanvasPoint","imgWidth","imgHeight","slicePoint","editHandle","nextPos","viewportImageData","vtkImageData","sliceImageData","sliceToIndexMatrix","indexToSliceMatrix","ijkPoint","startPos","createInstanceFromRawPixelData","currentPathNext","addPoint","confirmedPathNext","numHandles","previousHandle","nextHandle","slicePos","pathPointsLeft","pathPointsRight","appendPath","annotationStyle","canvasHandles","livewirePath","pointArray","imagePoints","updateContourPolyline","allowOpenContours","renderResult","ProbeTool","eventDispatchDetail","samplesPerPixel","yMultiple","zMultiple","baseIndex","imageURI","calibratedResults","hasEnhancedRegionValues","RectangleROITool","rect","_getRectangleImageCoordinates","bottomLeftWorld","topRightWorld","point0","SplineContourSegmentationTool","DEFAULT_SPLINE_CONFIG","controlPointAdditionDistance","controlPointDeletionDistance","showControlPointsConnectors","controlPointAdditionEnabled","controlPointDeletionEnabled","SplineTypesEnum","SplineToolActions","SplineROITool","SplineTypes","Cardinal","Class","CatmullRom","Linear","BSpline","drawPreviewEnabled","lastControlPointDeletionKeys","AddControlPoint","Primary","DeleteControlPoint","Ctrl","fireChangeOnUpdate","instance","isPointNearCurve","_keyDownCallback","controlPointIndex","_deleteControlPointByIndex","worldPoint","closeContour","addNewPoint","closestControlPoint","getClosestControlPointWithinDistance","moveAnnotation","_renderStats","textboxStyle","addControlPointCallback","splineType","splineConfig","_getSplineConfig","maxDist","closestPointInfo","getClosestPoint","addControlPointAtU","uValue","deleteControlPointCallback","originalWorldPoint","deltaXPoint","deltaYPoint","deltaInX","deltaInY","maxX","canvasMaxX","maxY","canvasMaxY","minX","canvasMinX","minY","canvasMinY","topLeftBBWorld","topLeftBBIndex","bottomRightBBWorld","throttle","cancelAnnotation","annotationLocked","childAnnotations","join","_isSplineROIAnnotation","splinePolylineCanvas","_updateSplineInstance","getPolylinePoints","numControlPoints","previewPolylinePoints","getPreviewPolylinePoints","controlPointsConnectors","textbox","createInterpolatedSplineControl","increment","contourAnnotation","createSpline","onInterpolationComplete","splineConfigs","setControlPoints","fixedResolution","fixedScale","UltrasoundDirectionalTool","displayBothAxesDistances","startedDrawing","xValues","yValues","isHorizontal","isUnitless","drawHandle","canvasDeltaY","canvasDeltaX","projectedPointCanvas","imageIndex1","imageIndex2","values1","values2","VideoRedactionTool","toolConfiguration","viewportUIDsToRender","toolDataCanvasCoordinate","viewportUID","renderingEngineUID","sceneUID","targetUIDs","targetUID","_getImageVolumeFromTargetUID","worldPos1Index","worldPos2Index","worldToIndexVec3","iMin","iMax","jMin","jMax","kMin","kMax","valueMinusMean","_getTargetVolumeUID","scene","volumeUID","volumeActors","getVolumeActors","coloneIndex","substring","_getTargetStackUID","AnnotationDisplayTool","frameOfReference","getReferencedImageIds","VideoViewport","BaseTool","initialProps","strategies","defaultStrategy","activeStrategy","strategyOptions","Disabled","applyActiveStrategy","operationData","call","applyActiveStrategyCallback","callbackType","setConfiguration","newConfiguration","strategySpecificConfiguration","THRESHOLD_INSIDE_CIRCLE","threshold","setActiveStrategy","strategyName","getTargetVolumeId","getClassName","getReferenceId","MAX_NUMBER_COLORS","labelMapConfigCache","getRepresentationRenderingConfig","cfun","ofun","polySegConversionInProgress","_getLabelmapConfig","toolGroupLabelmapConfig","segmentationRepresentationLabelmapConfig","isActiveLabelmap","segmentsLabelmapConfig","configToUse","fillAlphaInactive","outlineWidth","outlineWidthActive","outlineWidthInactive","renderFill","renderFillInactive","renderOutline","outlineOpacity","outlineOpacityInactive","_needsTransferFunctionUpdate","segmentColor","cacheUID","oldConfig","forceOpacityUpdate","forceColorUpdate","oldFillAlpha","oldRenderFill","oldRenderOutline","oldOutlineWidth","oldSegmentColor","oldSegmentsHidden","_addLabelmapToViewport","toolGroupConfig","renderingConfig","labelmapUID","defaultActorUID","isSameFrameOfReference","numColors","segmentSpecificLabelmapConfig","addRGBPoint","segmentOpacity","removePoint","addPointLong","setRGBTransferFunction","setClamping","setScalarOpacity","setInterpolationTypeToNearest","setUseLabelOutline","setLabelOutlineOpacity","outlineWidths","activeSegmentOutlineWidthDelta","setLabelOutlineThickness","setVisibility","_setLabelmapColorAndOpacity","renderImmediate","_removeLabelmapFromToolGroupViewports","RectangleROIThresholdTool","RectangleROIStartEndThresholdTool","numSlicesToPropagate","computePointsInsideVolume","startIndex","spacingInNormal","endIndex","_getEndSliceIndex","startSlice","endSlice","pointsInVolume","projectionPoints","projectionPointsImageIds","_computeProjectionPoints","calculatePointsInsideVolume","_computePointsInsideVolume","firstOrLastSlice","lineDashToUse","_calculateCachedStatsTool","startIJK","endIJK","startWorld","indexToWorldVec3","endWorld","newProjectionPoints","newPoint","RectanglePoints","pointsInsideVolume","projectionPoint","worldProjectionPointIndex","endPos","halfSpacingInNormalDirection","imageIdIndex","dir","BrushTool","FILL_INSIDE_CIRCLE","FILL_INSIDE_SPHERE","THRESHOLD_INSIDE_SPHERE","ERASE_INSIDE_CIRCLE","ERASE_INSIDE_SPHERE","REPLACE_INSIDE_CIRCLE","REPLACE_INSIDE_SPHERE","THRESHOLD","REPLACE","targetSegmentIndex","thresholdVolumeId","brushSize","eraseFocusIndex","preview","previewColors","previewTimeMs","previewMoveDistance","dragMoveDistance","dragTimeMs","AcceptPreview","RejectPreview","_previewData","timerStart","timer","NaN","isDrag","_editData","createEditData","Date","now","hoverData","_hoverData","createHoverData","getOperationData","OnInteractionStart","time","clearTimeout","rejectPreview","previewCallback","Preview","OnInteractionEnd","acceptPreview","activeSegmentationRepresentation","activeSegmentation","segmentLocking","CustomEvent","ERROR_EVENT","message","cancelable","dispatchEvent","volumes","referenceId","referencedVolumeIdToThreshold","centerCursorInWorld","getActiveSegmentationData","brushCursor","_calculateCursor","viewRight","bottomCursorInWorld","topCursorInWorld","leftCursorInWorld","rightCursorInWorld","strategy","computeInnerCircleRadius","toolMetadata","brushCursorUID","dynamicRadiusInCanvas","circleUID1","CircleROIStartEndThresholdTool","newStartIndex","_getStartSliceIndex","isMiddleSlice","lineWidthToUse","worldCenterIndex","numSlicesToPropagateFromStart","_getImageIdIndex","pos","CircleScissorsTool","FILL_INSIDE","ERASE_INSIDE","isEqual","PaintFillTool","getDirection","fixedDimension","getFixedDimension","floodFillGetter","getLabelValue","getScalarDataPositionFromPlane","inPlaneSeedPoint","fixedDimensionValue","generateHelpers","clickedLabelValue","floodFillResult","flooded","scalarDataPosition","framesModified","getFramesModified","boundaries","minJ","maxJ","seedIndex3D","getScalarDataPosition","z","generateFloodFillGetter","generateGetScalarDataPositionFromPlane","xDirection","yDirection","zDirection","absoluteOfViewPlaneNormal","absoluteOfXDirection","absoluteOfYDirection","absoluteOfZDirection","RectangleScissorsTool","SegmentSelectTool","SelectMode","Inside","Border","hoverTimeout","searchRadius","hoverTimer","_setActiveSegment","activeSegmentationReps","_setActiveSegmentForType","hoveredSegmentIndex","getSegmentAtWorldPoint","getSegmentAtLabelmapBorder","getHoveredContourSegmentationAnnotation","v","SphereScissorsTool","UndoTool","FILL_REPLACE","applyReplaceCallback","oldScalarData","currentElement","ContourWindingDirection","getViewportsForAnnotation","getEnabledElements","sourcePoints","minDistance","MAX_SAFE_INTEGER","sourcePoint","p1","p2","_distanceBetween","segmentIndicesCache","setSegmentationDirty","cached","isDirty","cachedResult","getCachedSegmentIndices","keySet","addVolumeSegmentIndices","segmentationImageId","addImageSegmentIndices","handleLabelmapSegmentation","getSegmentIndex","handleContourSegmentation","handleSurfaceSegmentation","segmentationRenderingEngine","_needsRender","_animationFrameSet","_animationFrameHandle","_renderFlaggedToolGroups","_throwIfDestroyed","_triggerRender","removeToolGroup","_reset","renderToolGroupSegmentations","_setToolGroupSegmentationToBeRenderedNextFrame","hasBeenDestroyed","_render","segmentationDisplayToolInstance","onSegmentationRender","renderSegmentation","cancelAnimationFrame","annotationRenderingEngine","_renderFlaggedViewports","elements","_viewportElements","_setViewportsToBeRenderedNextFrame","_setAllViewportsToBeRenderedNextFrame","elementsEnabled","enabledTools","draw","anyRendered","ANNOTATION_RENDERED"],"sourceRoot":""}