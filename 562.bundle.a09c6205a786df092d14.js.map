{"version":3,"file":"562.bundle.a09c6205a786df092d14.js","mappings":"gGAAA,SAASA,EAAQC,GAGf,OAAOD,EAAU,mBAAqBE,QAAU,iBAAmBA,OAAOC,SAAW,SAAUF,GAC7F,cAAcA,CAChB,EAAI,SAAUA,GACZ,OAAOA,GAAO,mBAAqBC,QAAUD,EAAIG,cAAgBF,QAAUD,IAAQC,OAAOG,UAAY,gBAAkBJ,CAC1H,EAAGD,EAAQC,EACb,CAMA,SAASK,EAAkBC,EAAQC,GACjC,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CACrC,IAAIE,EAAaH,EAAMC,GACvBE,EAAWC,WAAaD,EAAWC,aAAc,EACjDD,EAAWE,cAAe,EACtB,UAAWF,IAAYA,EAAWG,UAAW,GACjDC,OAAOC,eAAeT,GA8CFU,EA9CyBN,EAAWO,IA+CtDA,SACkB,iBADlBA,EAXN,SAAsBC,EAAOC,GAC3B,GAAqB,iBAAVD,GAAgC,OAAVA,EAAgB,OAAOA,EACxD,IAAIE,EAAOF,EAAMjB,OAAOoB,aACxB,QAAaC,IAATF,EAAoB,CACtB,IAAIG,EAAMH,EAAKI,KAAKN,EAAOC,GAAQ,WACnC,GAAmB,iBAARI,EAAkB,OAAOA,EACpC,MAAM,IAAIE,UAAU,+CACtB,CACA,OAAiB,WAATN,EAAoBO,OAASC,QAAQT,EAC/C,CAEYU,CAAaZ,EAAK,WACKC,EAAMS,OAAOT,IAhDkBP,EAChE,CA6CF,IAAwBM,EAClBC,CA7CN,CASA,SAASY,EAAmBC,GAC1B,OAEF,SAA4BA,GAC1B,GAAIC,MAAMC,QAAQF,GAAM,OAAOG,EAAkBH,EACnD,CAJSI,CAAmBJ,IAK5B,SAA0BK,GACxB,GAAsB,oBAAXlC,QAAmD,MAAzBkC,EAAKlC,OAAOC,WAA2C,MAAtBiC,EAAK,cAAuB,OAAOJ,MAAMK,KAAKD,EACtH,CAPoCE,CAAiBP,IAQrD,SAAqCQ,EAAGC,GACtC,IAAKD,EAAG,OACR,GAAiB,iBAANA,EAAgB,OAAOL,EAAkBK,EAAGC,GACvD,IAAIC,EAAI1B,OAAOV,UAAUqC,SAASjB,KAAKc,GAAGI,MAAM,GAAI,GAC1C,WAANF,GAAkBF,EAAEnC,cAAaqC,EAAIF,EAAEnC,YAAYwC,MACvD,GAAU,QAANH,GAAqB,QAANA,EAAa,OAAOT,MAAMK,KAAKE,GAClD,GAAU,cAANE,GAAqB,2CAA2CI,KAAKJ,GAAI,OAAOP,EAAkBK,EAAGC,EAC3G,CAf6DM,CAA4Bf,IAqBzF,WACE,MAAM,IAAIL,UAAU,uIACtB,CAvBiGqB,EACjG,CAeA,SAASb,EAAkBH,EAAKiB,IACnB,MAAPA,GAAeA,EAAMjB,EAAIrB,UAAQsC,EAAMjB,EAAIrB,QAC/C,IAAK,IAAID,EAAI,EAAGwC,EAAO,IAAIjB,MAAMgB,GAAMvC,EAAIuC,EAAKvC,IAAKwC,EAAKxC,GAAKsB,EAAItB,GACnE,OAAOwC,CACT,CA4CA,SAASC,EAAmBC,GAE1B,IADA,IAAIpB,EAAM,IAAIqB,WAAWD,EAAIzC,QACpBD,EAAI,EAAG4C,EAAIF,EAAIzC,OAAQD,EAAI4C,EAAG5C,IACrCsB,EAAItB,GAAK0C,EAAIG,WAAW7C,GAE1B,OAAOsB,CACT,CAwBA,SAASwB,EAAcC,EAASC,GAC9B,IAAIC,EAASC,UAAUjD,OAAS,QAAsBa,IAAjBoC,UAAU,GAAmBA,UAAU,GAAK,EACjF,GAAID,EAASD,EAAM/C,OAAS8C,EAAQ9C,OAClC,OAAO,EAGT,IADA,IAAIkD,EAAQF,EACHjD,EAAI,EAAGA,EAAIgD,EAAM/C,OAAQD,IAAK,CACrC,GAAIgD,EAAMhD,KAAO+C,EAAQI,GACvB,OAAO,EAETA,GAAS,CACX,CACA,OAAO,CACT,CASA,SAASC,EAAUL,EAASC,GAC1B,IAAIC,EAASC,UAAUjD,OAAS,QAAsBa,IAAjBoC,UAAU,GAAmBA,UAAU,GAAK,EAC7EG,EAAkBH,UAAUjD,OAAS,EAAIiD,UAAU,QAAKpC,EACxDwC,EAAeP,EAAQ9C,OACvBoD,IACFC,EAAeC,KAAKC,IAAIP,EAASI,EAAiBN,EAAQ9C,SAE5D,IAAK,IAAID,EAAIiD,EAAQjD,EAAIsD,EAActD,IAIrC,GAAI+C,EAAQ/C,KAAOgD,EAAM,IACnBF,EAAcC,EAASC,EAAOhD,GAChC,OAAOA,EAIb,OAAQ,CACV,CAiCA,SAASyD,EAAgBC,GACvB,IAAIC,EAAWT,UAAUjD,OAAS,QAAsBa,IAAjBoC,UAAU,GAAmBA,UAAU,GA3BhF,WACE,SAASU,IACP,OAAOL,KAAKM,MAA4B,OAArB,EAAIN,KAAKO,WAAqB7B,SAAS,IAAI8B,UAAU,EAC1E,CACA,MAAO,GAAGC,OAAOJ,IAAOA,IAAM,KAAKI,OAAOJ,IAAM,KAAKI,OAAOJ,IAAM,KAAKI,OAAOJ,IAAM,KAAKI,OAAOJ,KAAMI,OAAOJ,KAAMI,OAAOJ,IAC5H,CAsBqFK,GAE/EC,EAAoB,iBAAiBF,OADvBd,UAAUjD,OAAS,QAAsBa,IAAjBoC,UAAU,GAAmBA,UAAU,GAAK,qBAElFiB,EAAS,SAASH,OAAOL,EAAU,QAAQK,OAAOE,EAAmB,YACrEE,EAAS,SAASJ,OAAOL,EAAU,MACnCU,EAAc5B,EAAmB0B,GACjCG,EAAc7B,EAAmB2B,GACjCG,EAAeF,EAAYpE,OAC3BuE,EAAeF,EAAYrE,OAC3BA,EAAS,EAGTwE,EAAgBf,EAASgB,KAAI,SAAUC,GACzC,IAAIC,EAAe,IAAIjC,WAAWgC,GAC9BE,EAAgBD,EAAa3E,OAEjC,OADAA,GAAUsE,EAAeM,EAAgBL,EAClCI,CACT,IAGIE,EAAiB,IAAInC,WAAW1C,GAGpC6E,EAAeC,IAAIV,EAAa,GAGhC,IAAIW,EAAW,EAOf,OANAP,EAAcQ,SAAQ,SAAUL,GAC9BE,EAAeC,IAAIV,EAAaW,GAChCF,EAAeC,IAAIH,EAAcI,EAAWT,GAC5CS,GAAYT,EAAeK,EAAa3E,MAC1C,IACA6E,EAAeC,IAAIT,EAAaU,GACzB,CACLE,KAAMJ,EAAeK,OACrBxB,SAAUA,EAEd,CAQA,SAASyB,EAAgBC,GAEvB,IAAItC,EAAUuC,YAAYC,OAAOF,GAAYA,EAAW,IAAI1C,WAAW0C,GAQnEG,EAAY/C,EAAmB,YAC/BgD,EAAcrC,EAAUL,EAASyC,EAAW,EAJ1B,KAKtB,IAAqB,IAAjBC,EACF,MAAM,IAAIC,MAAM,iDAElB,IAAIvB,EApLN,SAA4B7C,GAK1B,IAJA,IAAI2B,EAASC,UAAUjD,OAAS,QAAsBa,IAAjBoC,UAAU,GAAmBA,UAAU,GAAK,EAE7EyC,GADQzC,UAAUjD,OAAS,EAAIiD,UAAU,QAAKpC,IACzBQ,EAAIrB,OAASgD,EAClCP,EAAM,GACD1C,EAAIiD,EAAQjD,EAAIiD,EAAS0C,EAAW3F,IAC3C0C,GAAOxB,OAAO0E,aAAatE,EAAItB,IAEjC,OAAO0C,CACT,CA2KemD,CAAmB9C,EAAS,EAAG0C,GACxCK,EAxJN,SAA0B3B,GAExB,IADA,IAAI4B,EAAQ5B,EAAO6B,MAAM,QAChBhG,EAAI,EAAGA,EAAI+F,EAAM9F,OAAQD,IAChC,GAA8B,OAA1B+F,EAAM/F,GAAGiG,OAAO,EAAG,GACrB,OAAOF,EAAM/F,GAGjB,OAAO,IACT,CAgJuBkG,CAAiB/B,GACtC,IAAK2B,EACH,MAAM,IAAIJ,MAAM,wDASlB,IAPA,IAMIS,EANAxC,EAAWlB,EAAmBqD,GAC9BM,EAAiBzC,EAAS1D,OAC1BoG,EAAa,GACbpD,EAASmD,GAIa,IAAnBD,IAMkB,KAHvBA,EAAgB/C,EAAUL,EAASY,EAAUV,KAHlB,CAS3B,IAAIqD,EAAmBlD,EAAUL,EAASyC,EAAWvC,EA7BjC,KA8BpB,IAA0B,IAAtBqD,EACF,MAAM,IAAIZ,MAAM,4CAElBzC,EAASqD,EAAmBd,EAAUvF,OAGtC,IACIiF,EAAOG,EAASnD,MAAMe,EAAQkD,EADd,GAIpBE,EAAWE,KAAKrB,GAIhBjC,EAASkD,EAAgBC,CAC3B,CACA,OAAOC,CACT,CAEA,SAASG,EAAShH,GAChB,MAAwB,WAAjBD,EAAQC,IAA6B,OAARA,CACtC,CACA,SAASiH,EAAcjH,GACrB,OAAmC,IAA5Bc,OAAOoG,KAAKlH,GAAKS,QAAgBT,EAAIG,cAAgBW,MAC9D,C,kBAUA,IAAIqG,EAAiB,SAAwBC,GAC3C,OAAOA,EAAO,EAChB,EACIC,EAAa,CACfC,MAAO,oBACPC,WAAY,yBACZC,aAAc,2BACdC,IAAK,kBACLC,KAAM,aACNC,IAAK,aAOHC,EAAW,WAAqB,EAsjDpC,IAEIC,EAAM,CACRC,eAviDgC,WAiBhC,SAASA,EAAeC,IAtW1B,SAAyBC,EAAUC,GACjC,KAAMD,aAAoBC,GACxB,MAAM,IAAIxG,UAAU,oCAExB,CAmWIyG,CAAgBC,KAAML,GACtBK,KAAKC,QAAUL,EAAQM,IAClBF,KAAKC,SACRE,QAAQC,MAAM,sEAEZ,aAAcR,IAChBI,KAAKK,SAAWT,EAAQS,SAClB,aAAcT,GAClBO,QAAQC,MAAM,8DAEhBJ,KAAKM,SAAWV,EAAQU,UAEtB,kBAAmBV,GACrBH,EAAS,+BAA+BpD,OAAOuD,EAAQW,gBACvDP,KAAKQ,QAAU,GAAGnE,OAAO2D,KAAKC,QAAS,KAAK5D,OAAOuD,EAAQW,gBAE3DP,KAAKQ,QAAUR,KAAKC,QAElB,kBAAmBL,GACrBH,EAAS,+BAA+BpD,OAAOuD,EAAQa,gBACvDT,KAAKU,QAAU,GAAGrE,OAAO2D,KAAKC,QAAS,KAAK5D,OAAOuD,EAAQa,gBAE3DT,KAAKU,QAAUV,KAAKC,QAElB,kBAAmBL,GACrBH,EAAS,+BAA+BpD,OAAOuD,EAAQe,gBACvDX,KAAKY,QAAU,GAAGvE,OAAO2D,KAAKC,QAAS,KAAK5D,OAAOuD,EAAQe,gBAE3DX,KAAKY,QAAUZ,KAAKC,QAElBL,EAAQiB,YACVpB,EAAS,iBAAkBG,EAAQiB,YACnCb,KAAKa,YAAoC,IAAvBjB,EAAQiB,WAAsB,uBAAyBjB,EAAQiB,YAEjFb,KAAKa,WAAa,GAEhB,iBAAkBjB,IACpBI,KAAKc,aAAelB,EAAQkB,cAI9Bd,KAAKe,QAAUnB,EAAQmB,SAAW,CAAC,EAGnCf,KAAKgB,iBAAmBpB,EAAQoB,kBAAoB,WAEpD,EAGAhB,KAAKiB,SAA8B,IAApBrB,EAAQqB,QACvBjB,KAAKkB,SAAStB,EAAQuB,MACxB,CA5YF,IAAsBrB,EAAasB,EAAYC,EA8yD7C,OA9yDoBvB,EAqZPH,EArZoByB,EAqZJ,CAAC,CAC5BtI,IAAK,WACLwI,MAAO,WACL,IAAIC,EAAahG,UAAUjD,OAAS,QAAsBa,IAAjBoC,UAAU,IAAmBA,UAAU,GAC5EiG,EAAmBjG,UAAUjD,OAAS,QAAsBa,IAAjBoC,UAAU,GAAmBA,UAAU,GAAK,KAC3FyE,KAAKuB,aAAeA,EACpB9B,EAAW+B,GAAoBD,EAAapB,QAAQsB,IAAM,WAAa,CACzE,GAMC,CACD3I,IAAK,WACLwI,MAAO,WACL,OAAOtB,KAAKuB,UACd,GAMC,CACDzI,IAAK,aACLwI,MAAO,SAAoBL,GACzBjB,KAAKiB,QAAUA,CACjB,GAMC,CACDnI,IAAK,aACLwI,MAAO,WACL,OAAOtB,KAAKiB,OACd,GACC,CACDnI,IAAK,eAaLwI,MAAO,SAAsBpB,EAAKwB,GAChC,IAAIC,EAAQ3B,KACRe,EAAUxF,UAAUjD,OAAS,QAAsBa,IAAjBoC,UAAU,GAAmBA,UAAU,GAAK,CAAC,EAC/EqE,EAAUrE,UAAUjD,OAAS,QAAsBa,IAAjBoC,UAAU,GAAmBA,UAAU,GAAK,CAAC,EAC/EyF,EAAmBhB,KAAKgB,iBAC1BF,EAAed,KAAKc,aACtB,OAAO,IAAIc,SAAQ,SAAUC,EAASC,GACpC,IAAIC,EAAUnC,EAAQmC,QAAUnC,EAAQmC,QAAU,IAAIC,eACtDD,EAAQE,KAAKP,EAAQxB,GAAK,GACtB,iBAAkBN,IACpBmC,EAAQG,aAAetC,EAAQsC,cAER,WAArBtK,EAAQmJ,IACVpI,OAAOoG,KAAKgC,GAASzD,SAAQ,SAAUxE,GACrCiJ,EAAQI,iBAAiBrJ,EAAKiI,EAAQjI,GACxC,IAKF,IAoEmDsJ,EApE/CC,EAAcV,EAAMZ,QA6DxB,GA5DApI,OAAOoG,KAAKsD,GAAa/E,SAAQ,SAAUxE,GACzCiJ,EAAQI,iBAAiBrJ,EAAKuJ,EAAYvJ,GAC5C,IAGAiJ,EAAQO,YAAc,WACpB7C,EAAS,mBAAoBS,EAC/B,EAGA6B,EAAQQ,UAAY,WAClB9C,EAAS,kBACX,EAGAsC,EAAQS,mBAAqB,WAC3B,GAA2B,IAAvBT,EAAQU,WACV,GAAuB,MAAnBV,EAAQW,OAAgB,CAC1B,IAAIC,EAAcZ,EAAQa,kBAAkB,gBAGxCD,IAAqD,IAAtCA,EAAYE,QAAQ,aACrChB,EAAQpE,EAAgBsE,EAAQrE,WACE,gBAAzBqE,EAAQG,aACjBL,EAAQ,CAACE,EAAQrE,WAEjBmE,EAAQE,EAAQrE,SAEpB,MAAO,GAAuB,MAAnBqE,EAAQW,OACbf,EAAMV,SACRd,QAAQ2C,KAAK,mCAAoCf,GAEnDF,EAAQE,EAAQrE,eACX,GAAuB,MAAnBqE,EAAQW,OACbf,EAAMV,SACRd,QAAQ2C,KAAK,+BAAgCf,GAE/CF,EAAQ,QACH,CACL,IAAIzB,EAAQ,IAAIrC,MAAM,kBACtBqC,EAAM2B,QAAUA,EAChB3B,EAAM1C,SAAWqE,EAAQrE,SACzB0C,EAAMsC,OAASX,EAAQW,OACnBf,EAAMV,UACRd,QAAQC,MAAM,mBAAoB2B,GAClC5B,QAAQC,MAAMA,GACdD,QAAQC,MAAMA,EAAM1C,WAEtBsD,EAAiBZ,GACjB0B,EAAO1B,EACT,CAEJ,EAGI,qBAAsBR,GACgB,mBAA7BA,EAAQmD,mBACjBhB,EAAQiB,WAAapD,EAAQmD,kBAG7BjC,GA9PZ,SAA8BA,GAC5B,IAAImC,EAAUrJ,MAAMC,QAAQiH,IAAiBA,EAAaoC,OAAM,SAAUC,GACxE,MAA8B,mBAAhBA,GAAqD,IAAvBA,EAAY7K,MAC1D,IAIA,OAHK2K,GACH9C,QAAQ2C,KAAK,kHAERG,CACT,CAsP4BG,CAAqBtC,GAAe,CACtD,IAAIuC,EAAkB1K,OAAO2K,OAAO,CAAC,EAAGvC,EAASY,EAAMZ,SACnDwC,EAAW,CACb7B,OAAQA,EACRxB,IAAKA,EACLa,QAASsC,GASPG,GAP6CpB,EAObtB,EAN3B,SAAU2C,GACf,OAAOrB,EAAUsB,QAAO,SAAUtL,EAAOuL,GACvC,OAAOA,EAAGvL,EAAOmL,EACnB,GAAGE,EACL,GAGF1B,EAAUyB,EAAazB,EACzB,CAGI,oBAAqBnC,GACnBA,EAAQgE,kBACV7B,EAAQ6B,iBAAkB,GAG1B,SAAUhE,EACZmC,EAAQ8B,KAAKjE,EAAQrC,MAErBwE,EAAQ8B,MAEZ,GACF,GAWC,CACD/K,IAAK,WACLwI,MAAO,SAAkBpB,EAAKa,EAASmB,EAAca,EAAkBa,GACrE,OAAO5D,KAAK8D,aAAa5D,EAAK,MAAOa,EAAS,CAC5CmB,aAAcA,EACda,iBAAkBA,EAClBa,gBAAiBA,GAErB,GAWC,CACD9K,IAAK,0BACLwI,MAAO,SAAiCpB,GACtC,IAAI6D,EAASxI,UAAUjD,OAAS,QAAsBa,IAAjBoC,UAAU,GAAmBA,UAAU,GAAK,CAAC,EAC9EwH,EAAmBxH,UAAUjD,OAAS,EAAIiD,UAAU,QAAKpC,EACzDyK,EAAkBrI,UAAUjD,OAAS,EAAIiD,UAAU,QAAKpC,EACxD6K,EAAqB9D,EACD,WAApBtI,EAAQmM,KACLjF,EAAciF,KACjBC,GAAsBrE,EAAesE,sBAAsBF,KAG/D,IAAIhD,EAAU,CACZmD,OAAQhF,EAAWE,YAGrB,OAAOY,KAAKmE,SAASH,EAAoBjD,EADtB,OAC6CgC,EAAkBa,EACpF,GAWC,CACD9K,IAAK,yBACLwI,MAAO,SAAgCpB,GACrC,IAAI6D,EAASxI,UAAUjD,OAAS,QAAsBa,IAAjBoC,UAAU,GAAmBA,UAAU,GAAK,CAAC,EAC9EwH,EAAmBxH,UAAUjD,OAAS,EAAIiD,UAAU,QAAKpC,EACzDyK,EAAkBrI,UAAUjD,OAAS,EAAIiD,UAAU,QAAKpC,EACxD6K,EAAqB9D,EACD,WAApBtI,EAAQmM,KACLjF,EAAciF,KACjBC,GAAsBrE,EAAesE,sBAAsBF,KAG/D,IAAIhD,EAAU,CACZmD,OAAQhF,EAAWI,KAGrB,OAAOU,KAAKmE,SAASH,EAAoBjD,EADtB,OAC6CgC,EAAkBa,EACpF,GAYC,CACD9K,IAAK,gBACLwI,MAAO,SAAuBpB,EAAKkE,GACjC,IAAIL,EAASxI,UAAUjD,OAAS,QAAsBa,IAAjBoC,UAAU,GAAmBA,UAAU,GAAK,CAAC,EAC9EwH,EAAmBxH,UAAUjD,OAAS,EAAIiD,UAAU,QAAKpC,EACzDyK,EAAkBrI,UAAUjD,OAAS,EAAIiD,UAAU,QAAKpC,EACxD6K,EAAqB9D,EACD,WAApBtI,EAAQmM,KACLjF,EAAciF,KACjBC,GAAsBrE,EAAesE,sBAAsBF,KAG/D,IAEIhD,EAAU,CACZmD,OAF2BvE,EAAe0E,6BAA6BD,EAD/C,CAAC,SAAU,UAAW,aAAc,YAAa,YAAa,eAMxF,OAAOpE,KAAKmE,SAASH,EAAoBjD,EADtB,cAC6CgC,EAAkBa,EACpF,GAYC,CACD9K,IAAK,eACLwI,MAAO,SAAsBpB,EAAKkE,GAChC,IAAIL,EAASxI,UAAUjD,OAAS,QAAsBa,IAAjBoC,UAAU,GAAmBA,UAAU,GAAK,CAAC,EAC9EwH,EAAmBxH,UAAUjD,OAAS,EAAIiD,UAAU,QAAKpC,EACzDyK,EAAkBrI,UAAUjD,OAAS,EAAIiD,UAAU,QAAKpC,EACxD6K,EAAqB9D,EACD,WAApBtI,EAAQmM,KACLjF,EAAciF,KACjBC,GAAsBrE,EAAesE,sBAAsBF,KAG/D,IAEIhD,EAAU,CACZmD,OAF2BvE,EAAe0E,6BAA6BD,EAD/C,CAAC,QAAS,SAAU,YAAa,aAAc,WAAY,cAMrF,OAAOpE,KAAKmE,SAASH,EAAoBjD,EADtB,cAC6CgC,EAAkBa,EACpF,GAYC,CACD9K,IAAK,gBACLwI,MAAO,SAAuBpB,EAAKkE,GACjC,IAAIL,EAASxI,UAAUjD,OAAS,QAAsBa,IAAjBoC,UAAU,GAAmBA,UAAU,GAAK,CAAC,EAC9EwH,EAAmBxH,UAAUjD,OAAS,EAAIiD,UAAU,QAAKpC,EACzDyK,EAAkBrI,UAAUjD,OAAS,EAAIiD,UAAU,QAAKpC,EACxD6K,EAAqB9D,EACD,WAApBtI,EAAQmM,KACLjF,EAAciF,KACjBC,GAAsBrE,EAAesE,sBAAsBF,KAG/D,IAEIhD,EAAU,CACZmD,OAF2BvE,EAAe0E,6BAA6BD,EAD/C,CAAC,SAAU,UAAW,aAAc,YAAa,gBAM3E,OAAOpE,KAAKmE,SAASH,EAAoBjD,EADtB,cAC6CgC,EAAkBa,EACpF,GAMC,CACD9K,IAAK,yBAcLwI,MAAO,SAAgCpB,EAAKkE,EAAYE,EAAWP,GACjE,IAIIQ,EAHAxB,EAAmBxH,UAAUjD,OAAS,EAAIiD,UAAU,QAAKpC,EACzDyK,EAAkBrI,UAAUjD,OAAS,EAAIiD,UAAU,QAAKpC,EACxD4H,EAAU,CAAC,EAuBf,OA1BexF,UAAUjD,OAAS,QAAsBa,IAAjBoC,UAAU,IAAmBA,UAAU,GAM5EgJ,EAAsB,CAAC,aAAc,YAAa,YAAa,cAE/DA,EAAsB,CACpB,sBAAuB,CAAC,qBACxB,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAAe,aAC1C,yBAA0B,CAAC,cAAe,aAC1C,yBAA0B,CAAC,aAC3B,yBAA0B,CAAC,aAC3B,yBAA0B,CAAC,aAC3B,yBAA0B,CAAC,cAEzBD,IACFvD,EAAQyD,MAAQ7E,EAAe8E,4BAA4BH,KAG/DvD,EAAQmD,OAASvE,EAAe+E,sCAAsCN,EAAYG,GAC3EvE,KAAKmE,SAASjE,EAAKa,EAAS,cAAegC,EAAkBa,EACtE,GAcC,CACD9K,IAAK,yBACLwI,MAAO,SAAgCpB,EAAKkE,EAAYE,EAAWP,GACjE,IAIIQ,EAHAxB,EAAmBxH,UAAUjD,OAAS,EAAIiD,UAAU,QAAKpC,EACzDyK,EAAkBrI,UAAUjD,OAAS,EAAIiD,UAAU,QAAKpC,EACxD4H,EAAU,CAAC,EAmBf,OAtBexF,UAAUjD,OAAS,QAAsBa,IAAjBoC,UAAU,IAAmBA,UAAU,GAM5EgJ,EAAsB,CAAC,SAAU,UAAW,cAAe,YAAa,eAExEA,EAAsB,CACpB,0BAA2B,CAAC,eAC5B,0BAA2B,CAAC,eAC5B,0BAA2B,CAAC,aAC5B,0BAA2B,CAAC,aAC5B,0BAA2B,CAAC,aAC5B,0BAA2B,CAAC,aAC5B,0BAA2B,CAAC,cAE1BD,IACFvD,EAAQyD,MAAQ7E,EAAe8E,4BAA4BH,KAG/DvD,EAAQmD,OAASvE,EAAe+E,sCAAsCN,EAAYG,GAC3EvE,KAAKmE,SAASjE,EAAKa,EAAS,cAAegC,EAAkBa,EACtE,GAaC,CACD9K,IAAK,oCACLwI,MAAO,SAA2CpB,EAAKkE,EAAYL,EAAQhB,EAAkBa,GAC3F,IAAI7C,EAAU,CAAC,EACX4D,EAAmB,oBACnBJ,EAAsB,CACxB,sBAAuB,CAACI,GACxB,sBAAuB,CAACA,GACxB,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,yBAA0B,CAACA,GAC3B,0BAA2B,CAACA,GAC5B,0BAA2B,CAACA,GAC5B,0BAA2B,CAACA,GAC5B,0BAA2B,CAACA,GAC5B,0BAA2B,CAACA,GAC5B,0BAA2B,CAACA,GAC5B,0BAA2B,CAACA,IAE1BC,EAAuBR,EAO3B,OANKA,IACHQ,EAAuB,CAAC,CACtBC,UAAWF,KAGf5D,EAAQmD,OAASvE,EAAe+E,sCAAsCE,EAAsBL,GACrFvE,KAAKmE,SAASjE,EAAKa,EAAS,cAAegC,EAAkBa,EACtE,GAeC,CACD9K,IAAK,0CACLwI,MAAO,SAAiDpB,EAAKkE,EAAYE,EAAWP,EAAQhB,EAAkBa,GAC5G,IAAI7C,EAAU,CAAC,EAEXwD,EAAsB,CACxB,sBAAuB7K,EAAmBf,OAAOmM,OAAO5F,KAEtD0F,EAAuBR,EAU3B,OATKA,IACHQ,EAAuB,CAAC,CACtBC,UAPmB,8BAUnBP,IACFvD,EAAQyD,MAAQ7E,EAAe8E,4BAA4BH,IAE7DvD,EAAQmD,OAASvE,EAAe+E,sCAAsCE,EAAsBL,GACrFvE,KAAKmE,SAASjE,EAAKa,EAAS,cAAegC,EAAkBa,EACtE,GAaC,CACD9K,IAAK,YACLwI,MAAO,SAAmBpB,EAAKa,EAASxD,EAAMwF,EAAkBa,EAAiB7B,GAC/E,OAAO/B,KAAK8D,aAAa5D,EAAK,OAAQa,EAAS,CAC7CxD,KAAMA,EACNwF,iBAAkBA,EAClBa,gBAAiBA,EACjB7B,QAASA,GAEb,GAWC,CACDjJ,IAAK,2BACLwI,MAAO,SAAkCpB,EAAK3C,EAAMwF,EAAkBa,GACpE,IAAI7C,EAAU,CACZ,eAAgB7B,EAAWE,YAE7B,OAAOY,KAAK+E,UAAU7E,EAAKa,EAASxD,EAAMwF,EAAkBa,EAC9D,GAQC,CACD9K,IAAK,mBAQLwI,MAAO,WACL,IAAI1B,EAAUrE,UAAUjD,OAAS,QAAsBa,IAAjBoC,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACnFkE,EAAS,sBACT,IAAImE,GAAkB,EAClB1D,EAAM,GAAG7D,OAAO2D,KAAKQ,QAAS,YASlC,MARI,gBAAiBZ,IACnBM,GAAOP,EAAesE,sBAAsBrE,EAAQoF,cAElD,oBAAqBpF,GACnBA,EAAQgE,kBACVA,EAAkBhE,EAAQgE,iBAGvB5D,KAAKiF,wBAAwB/E,EAAK,CAAC,GAAG,EAAO0D,EACtD,GASC,CACD9K,IAAK,wBACLwI,MAAO,SAA+B1B,GACpC,KAAM,qBAAsBA,GAC1B,MAAM,IAAI7B,MAAM,kEAElB0B,EAAS,8BAA8BpD,OAAOuD,EAAQsF,mBACtD,IAAIhF,EAAM,GAAG7D,OAAO2D,KAAKU,QAAS,aAAarE,OAAOuD,EAAQsF,iBAAkB,aAC5EtB,GAAkB,EAMtB,MALI,oBAAqBhE,GACnBA,EAAQgE,kBACVA,EAAkBhE,EAAQgE,iBAGvB5D,KAAKiF,wBAAwB/E,EAAK,CAAC,GAAG,EAAO0D,EACtD,GASC,CACD9K,IAAK,kBACLwI,MAAO,WACL,IAAI1B,EAAUrE,UAAUjD,OAAS,QAAsBa,IAAjBoC,UAAU,GAAmBA,UAAU,GAAK,CAAC,EAC/E2E,EAAMF,KAAKQ,QACX,qBAAsBZ,IACxBH,EAAS,0BAA0BpD,OAAOuD,EAAQsF,mBAClDhF,GAAO,YAAY7D,OAAOuD,EAAQsF,mBAEpChF,GAAO,UACH,gBAAiBN,IACnBM,GAAOP,EAAesE,sBAAsBrE,EAAQoF,cAEtD,IAAIpB,GAAkB,EAMtB,MALI,oBAAqBhE,GACnBA,EAAQgE,kBACVA,EAAkBhE,EAAQgE,iBAGvB5D,KAAKiF,wBAAwB/E,EAAK,CAAC,GAAG,EAAO0D,EACtD,GAUC,CACD9K,IAAK,yBACLwI,MAAO,SAAgC1B,GACrC,KAAM,qBAAsBA,GAC1B,MAAM,IAAI7B,MAAM,mEAElB,KAAM,sBAAuB6B,GAC3B,MAAM,IAAI7B,MAAM,oEAElB0B,EAAS,+BAA+BpD,OAAOuD,EAAQuF,oBACvD,IAAIjF,EAAM,GAAG7D,OAAO2D,KAAKU,QAAS,aAAarE,OAAOuD,EAAQsF,iBAAkB,YAAY7I,OAAOuD,EAAQuF,kBAAmB,aAC1HvB,GAAkB,EAMtB,MALI,oBAAqBhE,GACnBA,EAAQgE,kBACVA,EAAkBhE,EAAQgE,iBAGvB5D,KAAKiF,wBAAwB/E,EAAK,CAAC,GAAG,EAAO0D,EACtD,GAUC,CACD9K,IAAK,qBACLwI,MAAO,WACL,IAAI1B,EAAUrE,UAAUjD,OAAS,QAAsBa,IAAjBoC,UAAU,GAAmBA,UAAU,GAAK,CAAC,EAC/E2E,EAAMF,KAAKQ,QACXoD,GAAkB,EAqBtB,MApBI,qBAAsBhE,GACxBM,GAAO,YAAY7D,OAAOuD,EAAQsF,kBAC9B,sBAAuBtF,GACzBH,EAAS,kCAAkCpD,OAAOuD,EAAQuF,oBAC1DjF,GAAO,WAAW7D,OAAOuD,EAAQuF,oBAEjC1F,EAAS,iCAAiCpD,OAAOuD,EAAQsF,oBAG3DzF,EAAS,wBAEXS,GAAO,aACH,gBAAiBN,IACnBM,GAAOP,EAAesE,sBAAsBrE,EAAQoF,cAElD,oBAAqBpF,GACnBA,EAAQgE,kBACVA,EAAkBhE,EAAQgE,iBAGvB5D,KAAKiF,wBAAwB/E,EAAK,CAAC,GAAG,EAAO0D,EACtD,GASC,CACD9K,IAAK,0BACLwI,MAAO,SAAiC1B,GACtC,KAAM,qBAAsBA,GAC1B,MAAM,IAAI7B,MAAM,mCAElB,KAAM,sBAAuB6B,GAC3B,MAAM,IAAI7B,MAAM,oCAElB,KAAM,mBAAoB6B,GACxB,MAAM,IAAI7B,MAAM,iCAElB,IAAI4E,EAAc/C,EAAQ+C,aAAezD,EAAWC,MAChDiG,EAAiBxF,EAAQwF,gBAAkB,IAC3CrB,EAAS,GACbA,EAAOnF,KAAK,oBACZmF,EAAOnF,KAAK,YAAYvC,OAAOuD,EAAQsF,mBACvCnB,EAAOnF,KAAK,aAAavC,OAAOuD,EAAQuF,oBACxCpB,EAAOnF,KAAK,aAAavC,OAAOuD,EAAQyF,iBACxCtB,EAAOnF,KAAK,eAAevC,OAAOsG,IAClCoB,EAAOnF,KAAK,kBAAkBvC,OAAO+I,IACrC,IAAIE,EAAcvB,EAAOwB,KAAK,KAC9B,MAAO,GAAGlJ,OAAO2D,KAAKU,QAAS,KAAKrE,OAAOiJ,EAC7C,GAUC,CACDxM,IAAK,2BACLwI,MAAO,SAAkC1B,GACvC,KAAM,qBAAsBA,GAC1B,MAAM,IAAI7B,MAAM,qEAElB,KAAM,sBAAuB6B,GAC3B,MAAM,IAAI7B,MAAM,sEAElB,KAAM,mBAAoB6B,GACxB,MAAM,IAAI7B,MAAM,mEAElB0B,EAAS,iCAAiCpD,OAAOuD,EAAQyF,iBACzD,IAAInF,EAAM,GAAG7D,OAAO2D,KAAKU,QAAS,aAAarE,OAAOuD,EAAQsF,iBAAkB,YAAY7I,OAAOuD,EAAQuF,kBAAmB,eAAe9I,OAAOuD,EAAQyF,eAAgB,aACxKzB,GAAkB,EAMtB,MALI,oBAAqBhE,GACnBA,EAAQgE,kBACVA,EAAkBhE,EAAQgE,iBAGvB5D,KAAKiF,wBAAwB/E,EAAK,CAAC,GAAG,EAAO0D,EACtD,GAUC,CACD9K,IAAK,yBACLwI,MAAO,SAAgC1B,GACrC,KAAM,qBAAsBA,GAC1B,MAAM,IAAI7B,MAAM,mEAElB,KAAM,sBAAuB6B,GAC3B,MAAM,IAAI7B,MAAM,oEAElB,KAAM,mBAAoB6B,GACxB,MAAM,IAAI7B,MAAM,iEAElB,KAAM,iBAAkB6B,GACtB,MAAM,IAAI7B,MAAM,+DAElB0B,EAAS,mBAAmBpD,OAAOuD,EAAQ4F,aAAalL,WAAY,iBAAiB+B,OAAOuD,EAAQyF,iBACpG,IAAInF,EAAM,GAAG7D,OAAO2D,KAAKU,QAAS,aAAarE,OAAOuD,EAAQsF,iBAAkB,YAAY7I,OAAOuD,EAAQuF,kBAAmB,eAAe9I,OAAOuD,EAAQyF,eAAgB,YAAYhJ,OAAOuD,EAAQ4F,aAAalL,YAChN8J,EAAaxE,EAAQwE,WACrBR,GAAkB,EAClB,oBAAqBhE,GACnBA,EAAQgE,kBACVA,EAAkBhE,EAAQgE,iBAG9B,IAAIb,GAAmB,EAIvB,GAHI,qBAAsBnD,IACxBmD,EAAmBnD,EAAQmD,mBAExBqB,EACH,OAAOpE,KAAKyF,wCAAwCvF,GAAK,GAAO,GAAO,EAAO6C,EAAkBa,GAGlG,GADuBjE,EAAe+F,qBAAqBtB,GACtC9L,OAAS,EAAG,CAM/B,IAgBIyI,EAAU,CACZmD,OAAQvE,EAAe+E,sCAAsCN,EAjBrC,CACxB,sBAAuB,CAAC,4BACxB,sBAAuB,CAAC,qBACxB,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAC3B,yBAA0B,CAAC,cAAe,aAC1C,yBAA0B,CAAC,cAAe,aAC1C,yBAA0B,CAAC,aAC3B,yBAA0B,CAAC,aAC3B,yBAA0B,CAAC,aAC3B,yBAA0B,CAAC,aAC3B,0BAA2B,CAAC,aAC5B,0BAA2B,CAAC,gBAK9B,OAAOpE,KAAKmE,SAASjE,EAAKa,EAAS,cAAegC,EAAkBa,EACtE,CACA,IAAI+B,EAAkBhG,EAAeiG,oBAAoBxB,GACzD,GAAIuB,EAAgBE,WAAW,eAC7B,OAAO7F,KAAKyF,wCAAwCvF,EAAKkE,GAAY,GAAO,EAAOrB,EAAkBa,GAEvG,GAAI+B,EAAgBE,WAAW,SAC7B,OAAO7F,KAAK8F,uBAAuB5F,EAAKkE,GAAY,GAAO,GAAO,EAAOrB,EAAkBa,GAE7F,GAAI+B,EAAgBE,WAAW,SAC7B,OAAO7F,KAAK+F,uBAAuB7F,EAAKkE,GAAY,GAAO,GAAO,EAAOrB,EAAkBa,GAE7F,MAAM,IAAI7F,MAAM,cAAc1B,OAAOsJ,EAAiB,8CACxD,GAiBC,CACD7M,IAAK,2BACLwI,MAAO,SAAkC1B,GACvC,KAAM,qBAAsBA,GAC1B,MAAM,IAAI7B,MAAM,qEAElB,KAAM,sBAAuB6B,GAC3B,MAAM,IAAI7B,MAAM,sEAElB,KAAM,mBAAoB6B,GACxB,MAAM,IAAI7B,MAAM,mEAElB,IAAImC,EAAM,GAAG7D,OAAO2D,KAAKU,QAAS,aAAarE,OAAOuD,EAAQsF,iBAAkB,YAAY7I,OAAOuD,EAAQuF,kBAAmB,eAAe9I,OAAOuD,EAAQyF,eAAgB,aACxKjB,EAAaxE,EAAQwE,WACvBY,EAAcpF,EAAQoF,YAEpBpB,GAAkB,EAClB,oBAAqBhE,GACnBA,EAAQgE,kBACVA,EAAkBhE,EAAQgE,iBAG9B,IAAIb,GAAmB,EAIvB,GAHI,qBAAsBnD,IACxBmD,EAAmBnD,EAAQmD,mBAExBqB,EAKH,OAHIY,IACF9E,GAAOP,EAAesE,sBAAsBe,IAEvChF,KAAKmE,SAASjE,EAhBT,CAAC,EAYM,cAI8B6C,EAAkBa,GAErE,IAAI+B,EAAkBhG,EAAeiG,oBAAoBxB,GACzD,GAAIuB,EAAgBE,WAAW,SAC7B,OAAO7F,KAAKgG,cAAc9F,EAAKkE,EAAYY,EAAajC,EAAkBa,GAE5E,GAAI+B,EAAgBE,WAAW,SAC7B,OAAO7F,KAAKiG,cAAc/F,EAAKkE,EAAYY,EAAajC,EAAkBa,GAE5E,GAAI+B,EAAgBE,WAAW,QAC7B,OAAO7F,KAAKkG,aAAahG,EAAKkE,EAAYY,EAAajC,EAAkBa,GAE3E,GAAI+B,IAAoBzG,EAAWI,IACjC,OAAOU,KAAKmG,uBAAuBjG,EAAK8E,EAAajC,EAAkBa,GAEzE,MAAM,IAAI7F,MAAM,cAAc1B,OAAOsJ,EAAiB,sBAAwB,sCAChF,GAYC,CACD7M,IAAK,4BACLwI,MAAO,SAAmC1B,GACxC,KAAM,qBAAsBA,GAC1B,MAAM,IAAI7B,MAAM,qEAElB,KAAM,sBAAuB6B,GAC3B,MAAM,IAAI7B,MAAM,sEAElB,KAAM,mBAAoB6B,GACxB,MAAM,IAAI7B,MAAM,mEAElB,IAAImC,EAAM,GAAG7D,OAAO2D,KAAKU,QAAS,aAAarE,OAAOuD,EAAQsF,iBAAkB,YAAY7I,OAAOuD,EAAQuF,kBAAmB,eAAe9I,OAAOuD,EAAQyF,eAAgB,cACxKjB,EAAaxE,EAAQwE,WACvBY,EAAcpF,EAAQoF,YAEpBpB,GAAkB,EAClB,oBAAqBhE,GACnBA,EAAQgE,kBACVA,EAAkBhE,EAAQgE,iBAG9B,IAAIb,GAAmB,EAIvB,GAHI,qBAAsBnD,IACxBmD,EAAmBnD,EAAQmD,mBAExBqB,EAKH,OAHIY,IACF9E,GAAOP,EAAesE,sBAAsBe,IAEvChF,KAAKmE,SAASjE,EAhBT,CAAC,EAYM,cAI8B6C,EAAkBa,GAErE,IAAI+B,EAAkBhG,EAAeiG,oBAAoBxB,GACzD,GAAIuB,EAAgBE,WAAW,SAC7B,OAAO7F,KAAKgG,cAAc9F,EAAKkE,EAAYY,EAAajC,EAAkBa,GAE5E,MAAM,IAAI7F,MAAM,cAAc1B,OAAOsJ,EAAiB,sBAAwB,sCAChF,GAaC,CACD7M,IAAK,iCACLwI,MAAO,SAAwC1B,GAC7C,KAAM,qBAAsBA,GAC1B,MAAM,IAAI7B,MAAM,4EAElB,KAAM,sBAAuB6B,GAC3B,MAAM,IAAI7B,MAAM,6EAElB,KAAM,mBAAoB6B,GACxB,MAAM,IAAI7B,MAAM,0EAElB,KAAM,iBAAkB6B,GACtB,MAAM,IAAI7B,MAAM,wEAElB0B,EAAS,4BAA4BpD,OAAOuD,EAAQ4F,aAAalL,WAAY,iBAAiB+B,OAAOuD,EAAQyF,iBAC7G,IAAInF,EAAM,GAAG7D,OAAO2D,KAAKU,QAAS,aAAarE,OAAOuD,EAAQsF,iBAAkB,YAAY7I,OAAOuD,EAAQuF,kBAAmB,eAAe9I,OAAOuD,EAAQyF,eAAgB,YAAYhJ,OAAOuD,EAAQ4F,aAAalL,WAAY,aAC5N8J,EAAaxE,EAAQwE,WACvBY,EAAcpF,EAAQoF,YAEpBpB,GAAkB,EAClB,oBAAqBhE,GACnBA,EAAQgE,kBACVA,EAAkBhE,EAAQgE,iBAG9B,IAAIb,GAAmB,EAIvB,GAHI,qBAAsBnD,IACxBmD,EAAmBnD,EAAQmD,mBAExBqB,EAKH,OAHIY,IACF9E,GAAOP,EAAesE,sBAAsBe,IAEvChF,KAAKmE,SAASjE,EAhBT,CAAC,EAYM,eAI8B,EAAO0D,GAE1D,IAAI+B,EAAkBhG,EAAeiG,oBAAoBxB,GACzD,GAAIuB,EAAgBE,WAAW,SAC7B,OAAO7F,KAAKgG,cAAc9F,EAAKkE,EAAYY,EAAajC,EAAkBa,GAE5E,GAAI+B,EAAgBE,WAAW,SAC7B,OAAO7F,KAAKiG,cAAc/F,EAAKkE,EAAYY,EAAajC,EAAkBa,GAE5E,MAAM,IAAI7F,MAAM,cAAc1B,OAAOsJ,EAAiB,sBAAwB,mCAChF,GAYC,CACD7M,IAAK,kCACLwI,MAAO,SAAyC1B,GAC9C,KAAM,qBAAsBA,GAC1B,MAAM,IAAI7B,MAAM,4EAElB,KAAM,sBAAuB6B,GAC3B,MAAM,IAAI7B,MAAM,6EAElB,KAAM,mBAAoB6B,GACxB,MAAM,IAAI7B,MAAM,0EAElB,KAAM,iBAAkB6B,GACtB,MAAM,IAAI7B,MAAM,wEAElBoC,QAAQgB,MAAM,4BAA4B9E,OAAOuD,EAAQ4F,aAAalL,WAAY,iBAAiB+B,OAAOuD,EAAQyF,iBAClH,IAAInF,EAAM,GAAG7D,OAAO2D,KAAKU,QAAS,aAAarE,OAAOuD,EAAQsF,iBAAkB,YAAY7I,OAAOuD,EAAQuF,kBAAmB,eAAe9I,OAAOuD,EAAQyF,eAAgB,YAAYhJ,OAAOuD,EAAQ4F,aAAalL,WAAY,cAC5N8J,EAAaxE,EAAQwE,WACvBY,EAAcpF,EAAQoF,YAEpBpB,GAAkB,EAClB,oBAAqBhE,GACnBA,EAAQgE,kBACVA,EAAkBhE,EAAQgE,iBAG9B,IAAIb,GAAmB,EAIvB,GAHI,qBAAsBnD,IACxBmD,EAAmBnD,EAAQmD,mBAExBqB,EAKH,OAHIY,IACF9E,GAAOP,EAAesE,sBAAsBe,IAEvChF,KAAKmE,SAASjE,EAhBT,CAAC,EAYM,cAI8B6C,EAAkBa,GAErE,IAAI+B,EAAkBhG,EAAeiG,oBAAoBxB,GACzD,GAAIuB,EAAgBE,WAAW,SAC7B,OAAO7F,KAAKgG,cAAc9F,EAAKkE,EAAYY,EAAajC,EAAkBa,GAE5E,MAAM,IAAI7F,MAAM,cAAc1B,OAAOsJ,EAAiB,sBAAwB,mCAChF,GAUC,CACD7M,IAAK,mBACLwI,MAAO,SAA0B1B,GAC/B,KAAM,qBAAsBA,GAC1B,MAAM,IAAI7B,MAAM,kCAElB,KAAM,sBAAuB6B,GAC3B,MAAM,IAAI7B,MAAM,mCAElB,KAAM,mBAAoB6B,GACxB,MAAM,IAAI7B,MAAM,gCAElB,IAAImC,EAAM,GAAG7D,OAAO2D,KAAKU,QAAS,aAAarE,OAAOuD,EAAQsF,iBAAkB,YAAY7I,OAAOuD,EAAQuF,kBAAmB,eAAe9I,OAAOuD,EAAQyF,gBACxJjB,EAAaxE,EAAQwE,WACrBgC,EAAwBxG,EAAQgE,gBAClCA,OAA4C,IAA1BwC,GAA2CA,EAC3DC,EAAwBzG,EAAQmD,iBAClCA,OAA6C,IAA1BsD,GAA2CA,EAChE,IAAKjC,EACH,OAAOpE,KAAKsG,kCAAkCpG,GAAK,GAAO,EAAO6C,EAAkBa,GAAiB2C,KAAKvH,GAE3G,IAAI2G,EAAkBhG,EAAeiG,oBAAoBxB,GACzD,GAAIuB,IAAoBzG,EAAWC,MACjC,OAAOa,KAAKsG,kCAAkCpG,EAAKkE,GAAY,EAAOrB,EAAkBa,GAAiB2C,KAAKvH,GAEhH,MAAM,IAAIjB,MAAM,cAAc1B,OAAOsJ,EAAiB,gDACxD,GAUC,CACD7M,IAAK,iBACLwI,MAAO,SAAwB1B,GAC7B,KAAM,qBAAsBA,GAC1B,MAAM,IAAI7B,MAAM,kCAElB,KAAM,sBAAuB6B,GAC3B,MAAM,IAAI7B,MAAM,mCAElB,IAAImC,EAAM,GAAG7D,OAAO2D,KAAKU,QAAS,aAAarE,OAAOuD,EAAQsF,iBAAkB,YAAY7I,OAAOuD,EAAQuF,mBACvGf,EAAaxE,EAAQwE,WACrBR,GAAkB,EAClB,oBAAqBhE,GACnBA,EAAQgE,kBACVA,EAAkBhE,EAAQgE,iBAG9B,IAAIb,GAAmB,EAIvB,GAHI,qBAAsBnD,IACxBmD,EAAmBnD,EAAQmD,mBAExBqB,EACH,OAAOpE,KAAKsG,kCAAkCpG,GAAK,GAAO,EAAO6C,EAAkBa,GAErF,IAAI+B,EAAkBhG,EAAeiG,oBAAoBxB,GACzD,GAAIuB,IAAoBzG,EAAWC,MACjC,OAAOa,KAAKsG,kCAAkCpG,EAAKkE,GAAY,EAAOrB,EAAkBa,GAE1F,MAAM,IAAI7F,MAAM,cAAc1B,OAAOsJ,EAAiB,8CACxD,GAQC,CACD7M,IAAK,gBACLwI,MAAO,SAAuB1B,GAC5B,KAAM,qBAAsBA,GAC1B,MAAM,IAAI7B,MAAM,kCAElB,IAAImC,EAAM,GAAG7D,OAAO2D,KAAKU,QAAS,aAAarE,OAAOuD,EAAQsF,kBAC1Dd,EAAaxE,EAAQwE,WACrBoC,EAAyB5G,EAAQgE,gBACnCA,OAA6C,IAA3B4C,GAA4CA,EAC5DC,EAAyB7G,EAAQmD,iBACnCA,OAA8C,IAA3B0D,GAA4CA,EACjE,IAAKrC,EACH,OAAOpE,KAAKsG,kCAAkCpG,GAAK,GAAO,EAAO6C,EAAkBa,GAErF,IAAI+B,EAAkBhG,EAAeiG,oBAAoBxB,GACzD,GAAIuB,IAAoBzG,EAAWC,MACjC,OAAOa,KAAKsG,kCAAkCpG,EAAKkE,GAAY,EAAOrB,EAAkBa,GAE1F,MAAM,IAAI7F,MAAM,cAAc1B,OAAOsJ,EAAiB,6CACxD,GAcC,CACD7M,IAAK,mBACLwI,MAAO,SAA0B1B,GAC/B,KAAM,gBAAiBA,GACrB,MAAM,IAAI7B,MAAM,4BAElB,IAAImC,EAAMN,EAAQ8G,YACdtC,EAAaxE,EAAQwE,WACvBE,EAAY1E,EAAQ0E,UAClBqC,EAAyB/G,EAAQgE,gBACnCA,OAA6C,IAA3B+C,GAA4CA,EAC5DC,EAAyBhH,EAAQmD,iBACnCA,OAA8C,IAA3B6D,GAA4CA,EACjE,IAA6C,IAAzC5G,KAAKa,WAAWgC,QAAQ,YAC1B,OAAO7C,KAAKmE,SAASjE,EAAKN,EAAQmB,QAAS,cAAe,KAAM6C,GAElE,GAAIQ,EACF,IAEE,GAAwB,WADFzE,EAAeiG,oBAAoBxB,GAEvD,OAAOpE,KAAK8F,uBAAuB5F,EAAKkE,EAAYE,GAAW,GAAO,EAAOvB,EAAkBa,EAEnG,CAAE,MAAOiD,GAET,CAIF,OAAO7G,KAAKyF,wCAAwCvF,EAAKkE,EAAYE,GAAW,EAAOvB,EAAkBa,EAC3G,GAUC,CACD9K,IAAK,iBACLwI,MAAO,SAAwB1B,GAC7B,KAAM,aAAcA,GAClB,MAAM,IAAI7B,MAAM,qCAElB,IAAImC,EAAM,GAAG7D,OAAO2D,KAAKY,QAAS,YAC9B,qBAAsBhB,IACxBM,GAAO,IAAI7D,OAAOuD,EAAQsF,mBAE5B,IAAI4B,EAAmBhL,EAAgB8D,EAAQ7D,UAC7CwB,EAAOuJ,EAAiBvJ,KACxBvB,EAAW8K,EAAiB9K,SAC1B+E,EAAU,CACZ,eAAgB,0DAA6D1E,OAAOL,EAAU,MAE5F+K,EAAyBnH,EAAQgE,gBACnCA,OAA6C,IAA3BmD,GAA4CA,EAChE,OAAO/G,KAAK+E,UAAU7E,EAAKa,EAASxD,EAAMqC,EAAQmD,iBAAkBa,EAAiBhE,EAAQmC,QAC/F,IAvmD2CV,EAwmDzC,CAAC,CACHvI,IAAK,wBACLwI,MAAO,WACL,IAAIyC,EAASxI,UAAUjD,OAAS,QAAsBa,IAAjBoC,UAAU,GAAmBA,UAAU,GAAK,CAAC,EAC9EyL,EAAc,IAOlB,OANArO,OAAOoG,KAAKgF,GAAQzG,SAAQ,SAAUxE,EAAK0C,GAC3B,IAAVA,IACFwL,GAAe,KAEjBA,GAAe,GAAG3K,OAAOvD,EAAK,KAAKuD,OAAO4K,mBAAmBlD,EAAOjL,IACtE,IACOkO,CACT,GACC,CACDlO,IAAK,0BACLwI,MAAO,SAAiCuD,GACtC,IAAKA,EACH,MAAM,IAAI9G,MAAM,2BAA2B1B,OAAOwI,IAEpD,IAAIqC,EAAWrC,EAAUhC,QAAQ,KACjC,IAAkB,IAAdqE,EACF,MAAM,IAAInJ,MAAM,2BAA2B1B,OAAOwI,IAEpD,IAAIsC,EAAgBtC,EAAUtK,MAAM,EAAG2M,GAEvC,IADY,CAAC,cAAe,QAAS,OAAQ,SAClCE,SAASD,GAClB,MAAM,IAAIpJ,MAAM,2BAA2B1B,OAAOwI,IAEpD,GAAIA,EAAUtK,MAAM2M,EAAW,GAAGE,SAAS,KACzC,MAAM,IAAIrJ,MAAM,2BAA2B1B,OAAOwI,GAEtD,GACC,CACD/L,IAAK,kBACLwI,MAAO,SAAyBuD,GAE9B,OADAlF,EAAe0H,wBAAwBxC,GAChCA,EAAUxG,MAAM,IACzB,GASC,CACDvF,IAAK,+BACLwI,MAAO,SAAsC8C,EAAYG,GACvD,IAAK3K,MAAMC,QAAQuK,GACjB,MAAM,IAAIrG,MAAM,uDAUlB,OARsBqG,EAAWrH,KAAI,SAAUuK,GAC7C,IAAIzC,EAAYyC,EAAKzC,UAErB,GADAlF,EAAe0H,wBAAwBxC,IAClCN,EAAoB6C,SAASvC,GAChC,MAAM,IAAI9G,MAAM,cAAc1B,OAAOwI,EAAW,6CAElD,OAAOA,CACT,IACuBU,KAAK,KAC9B,GAYC,CACDzM,IAAK,wCACLwI,MAAO,SAA+C8C,EAAYG,GAChE,IAAIgD,EAASvH,KACb,IAAKpG,MAAMC,QAAQuK,GACjB,MAAM,IAAIrG,MAAM,uDAElB,IAAKnE,MAAMC,QAAQ0K,KAAyB1F,EAAS0F,GACnD,MAAM,IAAIxG,MAAM,mEAElB,IAAIyJ,EAAkB,GA2CtB,GA1CApD,EAAW9G,SAAQ,SAAUgK,GAC3B,IAAIG,EAAoBH,EAAKG,kBAC3B5C,EAAYyC,EAAKzC,UACnBlF,EAAe0H,wBAAwBxC,GACvC,IAAI6C,EAAa,4BAA6BrL,OAAOwI,EAAW,KAChE,GAAIhG,EAAS0F,GAAsB,CAGjC,KAAK5L,OAAOmM,OAAOP,GAAqBoD,KAAK,GAAGP,SAASvC,IAClDA,EAAU+C,SAAS,OAAU/C,EAAU+C,SAAS,MAEnD,YADAnI,EAAS,cAAcpD,OAAOwI,EAAW,6CAI7C,GAAI4C,EAAmB,CACrB,GAA0B,MAAtBA,EAA2B,CAC7B,IAAK9O,OAAOoG,KAAKwF,GAAqB6C,SAASK,GAC7C,MAAM,IAAI1J,MAAM,mBAAmB1B,OAAOoL,EAAmB,6CAE/D,IAAII,EAAqBtD,EAAoBkD,GAC7C,IAAKI,EAAmBT,SAASvC,GAAY,CAC3C,IAAIiD,EAAanI,EAAeoI,gBAAgBlD,GAAW,GAC3DgD,EAAmB9K,KAAI,SAAUiL,GAC/B,IAAIC,EAAetI,EAAeoI,gBAAgBC,GAAmB,GAErE,GADmBF,IAAeG,IACbpD,EAAU+C,SAAS,QAAS/C,EAAU+C,SAAS,KAGpE,MAAM,IAAI7J,MAAM,mBAAmB1B,OAAOoL,EAAmB,4CAC/D,GACF,CACF,CACAC,GAAc,qBAAqBrL,OAAOoL,EAC5C,CACF,MAAO,GAAI7N,MAAMC,QAAQ0K,KAAyBA,EAAoB6C,SAASvC,GAI7E,YAHI0C,EAAOtG,SACTd,QAAQ2C,KAAK,cAAczG,OAAOwI,EAAW,8CAIjD2C,EAAgB5I,KAAK8I,EACvB,KACKF,EAAgBlP,OACnB,MAAM,IAAIyF,MAAM,yCAAyC1B,OAAO6L,KAAKC,UAAU/D,KAEjF,OAAOoD,EAAgBjC,KAAK,KAC9B,GAQC,CACDzM,IAAK,8BACLwI,MAAO,WACL,IAAIgD,EAAY/I,UAAUjD,OAAS,QAAsBa,IAAjBoC,UAAU,GAAmBA,UAAU,GAAK,GACpF,OAAyB,IAArB+I,EAAUhM,OACL,SAAS+D,OAAOiI,EAAU,GAAI,KAEd,IAArBA,EAAUhM,OACL,SAAS+D,OAAOiI,EAAU,GAAI,KAAKjI,OAAOiI,EAAU,IAEtD,UACT,GASC,CACDxL,IAAK,uBACLwI,MAAO,SAA8B8C,GACnC,IAAIgE,EAAQ,IAAIC,IAChB,OAAKjE,GAAeA,EAAW9L,QAG/B8L,EAAW9G,SAAQ,SAAUgK,GAC3B,IAAIzC,EAAYyC,EAAKzC,UACjByD,EAAO3I,EAAeoI,gBAAgBlD,GAAW,GACrDuD,EAAMG,IAAI,GAAGlM,OAAOiM,EAAM,KAC5B,IACO1O,MAAMK,KAAKmO,IAPTA,CAQX,GAYC,CACDtP,IAAK,sBACLwI,MAAO,SAA6B8C,GAClC,IAAKA,IAAeA,EAAW9L,OAC7B,MAAM,IAAIyF,MAAM,sCAElB,IAAIyK,EAAmB7I,EAAe+F,qBAAqBtB,GAC3D,GAAgC,IAA5BoE,EAAiBlQ,OACnB,MAAM,IAAIyF,MAAM,wDACX,GAAIyK,EAAiBlQ,OAAS,EACnC,MAAM,IAAIyF,MAAM,mDAElB,OAAOyK,EAAiB,EAC1B,IA3yDEpH,GAAYlJ,EAAkB4H,EAAY7H,UAAWmJ,GACrDC,GAAanJ,EAAkB4H,EAAauB,GAChD1I,OAAOC,eAAekH,EAAa,YAAa,CAC9CpH,UAAU,IA0yDLiH,CACT,CAx+CkC,G","sources":["webpack:///../../../node_modules/dicomweb-client/build/dicomweb-client.es.js"],"sourcesContent":["function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\n/**\n * Converts a Uint8Array to a String.\n * @param {Uint8Array} array that should be converted\n * @param {Number} offset array offset in case only subset of array items should\n                   be extracted (default: 0)\n * @param {Number} limit maximum number of array items that should be extracted\n                   (defaults to length of array)\n * @returns {String}\n */\nfunction uint8ArrayToString(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var limit = arguments.length > 2 ? arguments[2] : undefined;\n  var itemLimit = limit || arr.length - offset;\n  var str = '';\n  for (var i = offset; i < offset + itemLimit; i++) {\n    str += String.fromCharCode(arr[i]);\n  }\n  return str;\n}\n\n/**\n * Converts a String to a Uint8Array.\n * @param {String} str string that should be converted\n * @returns {Uint8Array}\n */\nfunction stringToUint8Array(str) {\n  var arr = new Uint8Array(str.length);\n  for (var i = 0, j = str.length; i < j; i++) {\n    arr[i] = str.charCodeAt(i);\n  }\n  return arr;\n}\n\n/**\n * Identifies the boundary in a multipart/related message header.\n * @param {String} header message header\n * @returns {String} boundary\n */\nfunction identifyBoundary(header) {\n  var parts = header.split('\\r\\n');\n  for (var i = 0; i < parts.length; i++) {\n    if (parts[i].substr(0, 2) === '--') {\n      return parts[i];\n    }\n  }\n  return null;\n}\n\n/**\n * Checks whether a given token is contained by a message at a given offset.\n * @param {Uint8Array} message message content\n * @param {Uint8Array} token substring that should be present\n * @param {Number} offset offset in message content from where search should start\n * @returns {Boolean} whether message contains token at offset\n */\nfunction containsToken(message, token) {\n  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  if (offset + token.length > message.length) {\n    return false;\n  }\n  var index = offset;\n  for (var i = 0; i < token.length; i++) {\n    if (token[i] !== message[index]) {\n      return false;\n    }\n    index += 1;\n  }\n  return true;\n}\n\n/**\n * Finds a given token in a message at a given offset.\n * @param {Uint8Array} message message content\n * @param {Uint8Array} token substring that should be found\n * @param {String} offset message body offset from where search should start\n * @returns {Boolean} whether message has a part at given offset or not\n */\nfunction findToken(message, token) {\n  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var maxSearchLength = arguments.length > 3 ? arguments[3] : undefined;\n  var searchLength = message.length;\n  if (maxSearchLength) {\n    searchLength = Math.min(offset + maxSearchLength, message.length);\n  }\n  for (var i = offset; i < searchLength; i++) {\n    // If the first value of the message matches\n    // the first value of the token, check if\n    // this is the full token.\n    if (message[i] === token[0]) {\n      if (containsToken(message, token, i)) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n\n/**\n * Create a random GUID\n *\n * @return {string}\n */\nfunction guid() {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n  }\n  return \"\".concat(s4() + s4(), \"-\").concat(s4(), \"-\").concat(s4(), \"-\").concat(s4(), \"-\").concat(s4()).concat(s4()).concat(s4());\n}\n\n/**\n * @typedef {Object} MultipartEncodedData\n * @property {ArrayBuffer} data The encoded Multipart Data\n * @property {String} boundary The boundary used to divide pieces of the encoded data\n */\n\n/**\n * Encode one or more DICOM datasets into a single body so it can be\n * sent using the Multipart Content-Type.\n *\n * @param {ArrayBuffer[]} datasets Array containing each file to be encoded in the\n                          multipart body, passed as ArrayBuffers.\n * @param {String} [boundary] Optional string to define a boundary between each part\n                              of the multipart body. If this is not specified, a random\n                              GUID will be generated.\n * @return {MultipartEncodedData} The Multipart encoded data returned as an Object. This\n                                  contains both the data itself, and the boundary string\n                                  used to divide it.\n */\nfunction multipartEncode(datasets) {\n  var boundary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : guid();\n  var contentType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'application/dicom';\n  var contentTypeString = \"Content-Type: \".concat(contentType);\n  var header = \"\\r\\n--\".concat(boundary, \"\\r\\n\").concat(contentTypeString, \"\\r\\n\\r\\n\");\n  var footer = \"\\r\\n--\".concat(boundary, \"--\");\n  var headerArray = stringToUint8Array(header);\n  var footerArray = stringToUint8Array(footer);\n  var headerLength = headerArray.length;\n  var footerLength = footerArray.length;\n  var length = 0;\n\n  // Calculate the total length for the final array\n  var contentArrays = datasets.map(function (datasetBuffer) {\n    var contentArray = new Uint8Array(datasetBuffer);\n    var contentLength = contentArray.length;\n    length += headerLength + contentLength + footerLength;\n    return contentArray;\n  });\n\n  // Allocate the array\n  var multipartArray = new Uint8Array(length);\n\n  // Set the initial header\n  multipartArray.set(headerArray, 0);\n\n  // Write each dataset into the multipart array\n  var position = 0;\n  contentArrays.forEach(function (contentArray) {\n    multipartArray.set(headerArray, position);\n    multipartArray.set(contentArray, position + headerLength);\n    position += headerLength + contentArray.length;\n  });\n  multipartArray.set(footerArray, position);\n  return {\n    data: multipartArray.buffer,\n    boundary: boundary\n  };\n}\n\n/**\n * Decode a Multipart encoded ArrayBuffer and return the components as an Array.\n *\n * @param {ArrayBuffer} response Data encoded as a 'multipart/related' message\n * @returns {Array} The content\n */\nfunction multipartDecode(response) {\n  // Use the raw data if it is provided in an appropriate format\n  var message = ArrayBuffer.isView(response) ? response : new Uint8Array(response);\n\n  /* Set a maximum length to search for the header boundaries, otherwise\n       findToken can run for a long time\n    */\n  var maxSearchLength = 1000;\n\n  // First look for the multipart mime header\n  var separator = stringToUint8Array('\\r\\n\\r\\n');\n  var headerIndex = findToken(message, separator, 0, maxSearchLength);\n  if (headerIndex === -1) {\n    throw new Error('Response message has no multipart mime header');\n  }\n  var header = uint8ArrayToString(message, 0, headerIndex);\n  var boundaryString = identifyBoundary(header);\n  if (!boundaryString) {\n    throw new Error('Header of response message does not specify boundary');\n  }\n  var boundary = stringToUint8Array(boundaryString);\n  var boundaryLength = boundary.length;\n  var components = [];\n  var offset = boundaryLength;\n\n  // Loop until we cannot find any more boundaries\n  var boundaryIndex;\n  while (boundaryIndex !== -1) {\n    // Search for the next boundary in the message, starting\n    // from the current offset position\n    boundaryIndex = findToken(message, boundary, offset);\n\n    // If no further boundaries are found, stop here.\n    if (boundaryIndex === -1) {\n      break;\n    }\n    var headerTokenIndex = findToken(message, separator, offset, maxSearchLength);\n    if (headerTokenIndex === -1) {\n      throw new Error('Response message part has no mime header');\n    }\n    offset = headerTokenIndex + separator.length;\n\n    // Extract data from response message, excluding \"\\r\\n\"\n    var spacingLength = 2;\n    var data = response.slice(offset, boundaryIndex - spacingLength);\n\n    // Add the data to the array of results\n    components.push(data);\n\n    // Move the offset to the end of the current section,\n    // plus the identified boundary\n    offset = boundaryIndex + boundaryLength;\n  }\n  return components;\n}\n\nfunction isObject(obj) {\n  return _typeof(obj) === 'object' && obj !== null;\n}\nfunction isEmptyObject(obj) {\n  return Object.keys(obj).length === 0 && obj.constructor === Object;\n}\nfunction areValidRequestHooks(requestHooks) {\n  var isValid = Array.isArray(requestHooks) && requestHooks.every(function (requestHook) {\n    return typeof requestHook === 'function' && requestHook.length === 2;\n  });\n  if (!isValid) {\n    console.warn('Request hooks should have the following signature: ' + 'function requestHook(request, metadata) { return request; }');\n  }\n  return isValid;\n}\nvar getFirstResult = function getFirstResult(result) {\n  return result[0];\n};\nvar MEDIATYPES = {\n  DICOM: 'application/dicom',\n  DICOM_JSON: 'application/dicom+json',\n  OCTET_STREAM: 'application/octet-stream',\n  PDF: 'application/pdf',\n  JPEG: 'image/jpeg',\n  PNG: 'image/png'\n};\n\n/**\n * debugLog is a function that can be called with console.log arguments, and will\n * be conditionally displayed, only when debug logging is enabled.\n */\nvar debugLog = function debugLog() {};\n\n/**\n * @typedef { import(\"../types/types\").InstanceMetadata } InstanceMetadata\n */\n\n/**\n * A callback with the request instance and metadata information\n * of the currently request being executed that should necessarily\n * return the given request optionally modified.\n * @typedef {function} RequestHook\n * @param {XMLHttpRequest} request - The original XMLHttpRequest instance.\n * @param {object} metadata - The metadata used by the request.\n */\n\n/**\n * Class for interacting with DICOMweb RESTful services.\n */\nvar DICOMwebClient = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {Object} options\n   * @param {String} options.url - URL of the DICOMweb RESTful Service endpoint\n   * @param {String=} options.qidoURLPrefix - URL path prefix for QIDO-RS\n   * @param {String=} options.wadoURLPrefix - URL path prefix for WADO-RS\n   * @param {String=} options.stowURLPrefix - URL path prefix for STOW-RS\n   * @param {String=} options.username - Username\n   * @param {String=} options.password - Password\n   * @param {Object=} options.headers - HTTP headers\n   * @param {Array.<RequestHook>=} options.requestHooks - Request hooks.\n   * @param {Object=} options.verbose - print to console request warnings and errors, default true\n   * @param {Object=} options.debug - print to the console debug level information/status updates.\n   * @param {boolean|String} options.singlepart - retrieve singlepart for the named types.\n   * The available types are:  bulkdata, video, image.  true means all.\n   */\n  function DICOMwebClient(options) {\n    _classCallCheck(this, DICOMwebClient);\n    this.baseURL = options.url;\n    if (!this.baseURL) {\n      console.error('no DICOMweb base url provided - calls that require a URL will fail');\n    }\n    if ('username' in options) {\n      this.username = options.username;\n      if (!('password' in options)) {\n        console.error('no password provided to authenticate with DICOMweb service');\n      }\n      this.password = options.password;\n    }\n    if ('qidoURLPrefix' in options) {\n      debugLog(\"use URL prefix for QIDO-RS: \".concat(options.qidoURLPrefix));\n      this.qidoURL = \"\".concat(this.baseURL, \"/\").concat(options.qidoURLPrefix);\n    } else {\n      this.qidoURL = this.baseURL;\n    }\n    if ('wadoURLPrefix' in options) {\n      debugLog(\"use URL prefix for WADO-RS: \".concat(options.wadoURLPrefix));\n      this.wadoURL = \"\".concat(this.baseURL, \"/\").concat(options.wadoURLPrefix);\n    } else {\n      this.wadoURL = this.baseURL;\n    }\n    if ('stowURLPrefix' in options) {\n      debugLog(\"use URL prefix for STOW-RS: \".concat(options.stowURLPrefix));\n      this.stowURL = \"\".concat(this.baseURL, \"/\").concat(options.stowURLPrefix);\n    } else {\n      this.stowURL = this.baseURL;\n    }\n    if (options.singlepart) {\n      debugLog('use singlepart', options.singlepart);\n      this.singlepart = options.singlepart === true ? 'bulkdata,video,image' : options.singlepart;\n    } else {\n      this.singlepart = '';\n    }\n    if ('requestHooks' in options) {\n      this.requestHooks = options.requestHooks;\n    }\n\n    // Headers to pass to requests.\n    this.headers = options.headers || {};\n\n    // Optional error interceptor callback to handle any failed request.\n    this.errorInterceptor = options.errorInterceptor || function () {\n      return undefined;\n    };\n\n    // Verbose - print to console request warnings and errors, default true\n    this.verbose = options.verbose !== false;\n    this.setDebug(options.debug);\n  }\n\n  /**\n   * Allows setting the debug log information. \n   * Note this is different from verbose in that verbose is whether to include warning/error information, defaulting to true\n   * \n   * @param {boolean} debugLevel \n   * @param {function} debugLogFunction to call with the debug output arguments. \n   */\n  _createClass(DICOMwebClient, [{\n    key: \"setDebug\",\n    value: function setDebug() {\n      var debugLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var debugLogFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      this.debugLevel = !!debugLevel;\n      debugLog = debugLogFunction || debugLevel ? console.log : function () {};\n    }\n    /**\n     * Gets debug flag\n     * \n     * @returns true if debug logging is enabled\n     */\n  }, {\n    key: \"getDebug\",\n    value: function getDebug() {\n      return this.debugLevel;\n    }\n    /**\n     * Sets verbose flag.\n     *\n     * @param {Boolean} verbose\n     */\n  }, {\n    key: \"setVerbose\",\n    value: function setVerbose(verbose) {\n      this.verbose = verbose;\n    }\n    /**\n     * Gets verbose flag.\n     *\n     * @return {Boolean} verbose\n     */\n  }, {\n    key: \"getVerbose\",\n    value: function getVerbose() {\n      return this.verbose;\n    }\n  }, {\n    key: \"_httpRequest\",\n    /**\n     * Performs an HTTP request.\n     *\n     * @param {String} url\n     * @param {String} method\n     * @param {Object} headers\n     * @param {Object} options\n     * @param {Array.<RequestHook>} options.requestHooks - Request hooks.\n     * @param {XMLHttpRequest} [options.request] - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n     * @return {*}\n     * @private\n     */\n    value: function _httpRequest(url, method) {\n      var _this = this;\n      var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var errorInterceptor = this.errorInterceptor,\n        requestHooks = this.requestHooks;\n      return new Promise(function (resolve, reject) {\n        var request = options.request ? options.request : new XMLHttpRequest();\n        request.open(method, url, true);\n        if ('responseType' in options) {\n          request.responseType = options.responseType;\n        }\n        if (_typeof(headers) === 'object') {\n          Object.keys(headers).forEach(function (key) {\n            request.setRequestHeader(key, headers[key]);\n          });\n        }\n\n        // now add custom headers from the user\n        // (e.g. access tokens)\n        var userHeaders = _this.headers;\n        Object.keys(userHeaders).forEach(function (key) {\n          request.setRequestHeader(key, userHeaders[key]);\n        });\n\n        // Event triggered when upload starts\n        request.onloadstart = function onloadstart() {\n          debugLog('upload started: ', url);\n        };\n\n        // Event triggered when upload ends\n        request.onloadend = function onloadend() {\n          debugLog('upload finished');\n        };\n\n        // Handle response message\n        request.onreadystatechange = function () {\n          if (request.readyState === 4) {\n            if (request.status === 200) {\n              var contentType = request.getResponseHeader('Content-Type');\n              // Automatically distinguishes between multipart and singlepart in an array buffer, and\n              // converts them into a consistent type.\n              if (contentType && contentType.indexOf('multipart') !== -1) {\n                resolve(multipartDecode(request.response));\n              } else if (request.responseType === 'arraybuffer') {\n                resolve([request.response]);\n              } else {\n                resolve(request.response);\n              }\n            } else if (request.status === 202) {\n              if (_this.verbose) {\n                console.warn('some resources already existed: ', request);\n              }\n              resolve(request.response);\n            } else if (request.status === 204) {\n              if (_this.verbose) {\n                console.warn('empty response for request: ', request);\n              }\n              resolve([]);\n            } else {\n              var error = new Error('request failed');\n              error.request = request;\n              error.response = request.response;\n              error.status = request.status;\n              if (_this.verbose) {\n                console.error('request failed: ', request);\n                console.error(error);\n                console.error(error.response);\n              }\n              errorInterceptor(error);\n              reject(error);\n            }\n          }\n        };\n\n        // Event triggered while download progresses\n        if ('progressCallback' in options) {\n          if (typeof options.progressCallback === 'function') {\n            request.onprogress = options.progressCallback;\n          }\n        }\n        if (requestHooks && areValidRequestHooks(requestHooks)) {\n          var combinedHeaders = Object.assign({}, headers, _this.headers);\n          var metadata = {\n            method: method,\n            url: url,\n            headers: combinedHeaders\n          };\n          var pipeRequestHooks = function pipeRequestHooks(functions) {\n            return function (args) {\n              return functions.reduce(function (props, fn) {\n                return fn(props, metadata);\n              }, args);\n            };\n          };\n          var pipedRequest = pipeRequestHooks(requestHooks);\n          request = pipedRequest(request);\n        }\n\n        // Add withCredentials to request if needed\n        if ('withCredentials' in options) {\n          if (options.withCredentials) {\n            request.withCredentials = true;\n          }\n        }\n        if ('data' in options) {\n          request.send(options.data);\n        } else {\n          request.send();\n        }\n      });\n    }\n    /**\n     * Performs an HTTP GET request.\n     *\n     * @param {String} url\n     * @param {Object} headers\n     * @param {Object} responseType\n     * @param {Function} progressCallback\n     * @return {*}\n     * @private\n     */\n  }, {\n    key: \"_httpGet\",\n    value: function _httpGet(url, headers, responseType, progressCallback, withCredentials) {\n      return this._httpRequest(url, 'get', headers, {\n        responseType: responseType,\n        progressCallback: progressCallback,\n        withCredentials: withCredentials\n      });\n    }\n    /**\n     * Performs an HTTP GET request that accepts a message with application/json\n     * media type.\n     *\n     * @param {String} url\n     * @param {Object} params\n     * @param {Function} progressCallback\n     * @return {*}\n     * @private\n     */\n  }, {\n    key: \"_httpGetApplicationJson\",\n    value: function _httpGetApplicationJson(url) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var progressCallback = arguments.length > 2 ? arguments[2] : undefined;\n      var withCredentials = arguments.length > 3 ? arguments[3] : undefined;\n      var urlWithQueryParams = url;\n      if (_typeof(params) === 'object') {\n        if (!isEmptyObject(params)) {\n          urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n        }\n      }\n      var headers = {\n        Accept: MEDIATYPES.DICOM_JSON\n      };\n      var responseType = 'json';\n      return this._httpGet(urlWithQueryParams, headers, responseType, progressCallback, withCredentials);\n    }\n    /**\n     * Performs an HTTP GET request that accepts a message with application/pdf\n     * media type.\n     *\n     * @param {String} url\n     * @param {Object} params\n     * @param {Function} progressCallback\n     * @return {*}\n     * @private\n     */\n  }, {\n    key: \"_httpGetApplicationPdf\",\n    value: function _httpGetApplicationPdf(url) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var progressCallback = arguments.length > 2 ? arguments[2] : undefined;\n      var withCredentials = arguments.length > 3 ? arguments[3] : undefined;\n      var urlWithQueryParams = url;\n      if (_typeof(params) === 'object') {\n        if (!isEmptyObject(params)) {\n          urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n        }\n      }\n      var headers = {\n        Accept: MEDIATYPES.PDF\n      };\n      var responseType = 'json';\n      return this._httpGet(urlWithQueryParams, headers, responseType, progressCallback, withCredentials);\n    }\n    /**\n     * Performs an HTTP GET request that accepts a message with an image\n     media type.\n     *\n     * @param {String} url\n     * @param {Object[]} mediaTypes\n     * @param {Object} params\n     * @param {Function} progressCallback\n     * @return {*}\n     * @private\n     */\n  }, {\n    key: \"_httpGetImage\",\n    value: function _httpGetImage(url, mediaTypes) {\n      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var progressCallback = arguments.length > 3 ? arguments[3] : undefined;\n      var withCredentials = arguments.length > 4 ? arguments[4] : undefined;\n      var urlWithQueryParams = url;\n      if (_typeof(params) === 'object') {\n        if (!isEmptyObject(params)) {\n          urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n        }\n      }\n      var supportedMediaTypes = ['image/', 'image/*', 'image/jpeg', 'image/jp2', 'image/gif', 'image/png'];\n      var acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes);\n      var headers = {\n        Accept: acceptHeaderFieldValue\n      };\n      var responseType = 'arraybuffer';\n      return this._httpGet(urlWithQueryParams, headers, responseType, progressCallback, withCredentials);\n    }\n    /**\n     * Performs an HTTP GET request that accepts a message with a text\n     media type.\n     *\n     * @param {String} url\n     * @param {Object[]} mediaTypes\n     * @param {Object} params\n     * @param {Function} progressCallback\n     * @return {*}\n     * @private\n     */\n  }, {\n    key: \"_httpGetText\",\n    value: function _httpGetText(url, mediaTypes) {\n      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var progressCallback = arguments.length > 3 ? arguments[3] : undefined;\n      var withCredentials = arguments.length > 4 ? arguments[4] : undefined;\n      var urlWithQueryParams = url;\n      if (_typeof(params) === 'object') {\n        if (!isEmptyObject(params)) {\n          urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n        }\n      }\n      var supportedMediaTypes = ['text/', 'text/*', 'text/html', 'text/plain', 'text/rtf', 'text/xml'];\n      var acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes);\n      var headers = {\n        Accept: acceptHeaderFieldValue\n      };\n      var responseType = 'arraybuffer';\n      return this._httpGet(urlWithQueryParams, headers, responseType, progressCallback, withCredentials);\n    }\n    /**\n     * Performs an HTTP GET request that accepts a message with a video\n     media type.\n     *\n     * @param {String} url\n     * @param {Object[]} mediaTypes\n     * @param {Object} params\n     * @param {Function} progressCallback\n     * @return {*}\n     * @private\n     */\n  }, {\n    key: \"_httpGetVideo\",\n    value: function _httpGetVideo(url, mediaTypes) {\n      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var progressCallback = arguments.length > 3 ? arguments[3] : undefined;\n      var withCredentials = arguments.length > 4 ? arguments[4] : undefined;\n      var urlWithQueryParams = url;\n      if (_typeof(params) === 'object') {\n        if (!isEmptyObject(params)) {\n          urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n        }\n      }\n      var supportedMediaTypes = ['video/', 'video/*', 'video/mpeg', 'video/mp4', 'video/H265'];\n      var acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes);\n      var headers = {\n        Accept: acceptHeaderFieldValue\n      };\n      var responseType = 'arraybuffer';\n      return this._httpGet(urlWithQueryParams, headers, responseType, progressCallback, withCredentials);\n    }\n    /**\n     * Asserts that a given media type is valid.\n     *\n     * @params {String} mediaType media type\n     */\n  }, {\n    key: \"_httpGetMultipartImage\",\n    /**\n     * Performs an HTTP GET request that accepts a multipart message with an image media type.\n     *\n     * @param {String} url - Unique resource locator\n     * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n     corresponding transfer syntaxes\n     * @param {Array} byteRange - Start and end of byte range\n     * @param {Object} params - Additional HTTP GET query parameters\n     * @param {Boolean} rendered - Whether resource should be requested using rendered media types\n     * @param {Function} progressCallback\n     * @private\n     * @returns {Promise<Array>} Content of HTTP message body parts\n     */\n    value: function _httpGetMultipartImage(url, mediaTypes, byteRange, params) {\n      var rendered = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var progressCallback = arguments.length > 5 ? arguments[5] : undefined;\n      var withCredentials = arguments.length > 6 ? arguments[6] : undefined;\n      var headers = {};\n      var supportedMediaTypes;\n      if (rendered) {\n        supportedMediaTypes = ['image/jpeg', 'image/gif', 'image/png', 'image/jp2'];\n      } else {\n        supportedMediaTypes = {\n          '1.2.840.10008.1.2.5': ['image/x-dicom-rle'],\n          '1.2.840.10008.1.2.4.50': ['image/jpeg'],\n          '1.2.840.10008.1.2.4.51': ['image/jpeg'],\n          '1.2.840.10008.1.2.4.57': ['image/jpeg'],\n          '1.2.840.10008.1.2.4.70': ['image/jpeg'],\n          '1.2.840.10008.1.2.4.80': ['image/x-jls', 'image/jls'],\n          '1.2.840.10008.1.2.4.81': ['image/x-jls', 'image/jls'],\n          '1.2.840.10008.1.2.4.90': ['image/jp2'],\n          '1.2.840.10008.1.2.4.91': ['image/jp2'],\n          '1.2.840.10008.1.2.4.92': ['image/jpx'],\n          '1.2.840.10008.1.2.4.93': ['image/jpx']\n        };\n        if (byteRange) {\n          headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n        }\n      }\n      headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes);\n      return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n    }\n    /**\n     * Performs an HTTP GET request that accepts a multipart message with a video media type.\n     *\n     * @param {String} url - Unique resource locator\n     * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n     corresponding transfer syntaxes\n     * @param {Array} byteRange - Start and end of byte range\n     * @param {Object} params - Additional HTTP GET query parameters\n     * @param {Boolean} rendered - Whether resource should be requested using rendered media types\n     * @param {Function} progressCallback\n     * @private\n     * @returns {Promise<Array>} Content of HTTP message body parts\n     */\n  }, {\n    key: \"_httpGetMultipartVideo\",\n    value: function _httpGetMultipartVideo(url, mediaTypes, byteRange, params) {\n      var rendered = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var progressCallback = arguments.length > 5 ? arguments[5] : undefined;\n      var withCredentials = arguments.length > 6 ? arguments[6] : undefined;\n      var headers = {};\n      var supportedMediaTypes;\n      if (rendered) {\n        supportedMediaTypes = ['video/', 'video/*', 'video/mpeg2', 'video/mp4', 'video/H265'];\n      } else {\n        supportedMediaTypes = {\n          '1.2.840.10008.1.2.4.100': ['video/mpeg2'],\n          '1.2.840.10008.1.2.4.101': ['video/mpeg2'],\n          '1.2.840.10008.1.2.4.102': ['video/mp4'],\n          '1.2.840.10008.1.2.4.103': ['video/mp4'],\n          '1.2.840.10008.1.2.4.104': ['video/mp4'],\n          '1.2.840.10008.1.2.4.105': ['video/mp4'],\n          '1.2.840.10008.1.2.4.106': ['video/mp4']\n        };\n        if (byteRange) {\n          headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n        }\n      }\n      headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes);\n      return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n    }\n    /**\n     * Performs an HTTP GET request that accepts a multipart message\n     * with a application/dicom media type.\n     *\n     * @param {String} url - Unique resource locator\n     * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n     corresponding transfer syntaxes\n     * @param {Object} params - Additional HTTP GET query parameters\n     * @param {Function} progressCallback\n     * @private\n     * @returns {Promise<Array>} Content of HTTP message body parts\n     */\n  }, {\n    key: \"_httpGetMultipartApplicationDicom\",\n    value: function _httpGetMultipartApplicationDicom(url, mediaTypes, params, progressCallback, withCredentials) {\n      var headers = {};\n      var defaultMediaType = 'application/dicom';\n      var supportedMediaTypes = {\n        '1.2.840.10008.1.2.1': [defaultMediaType],\n        '1.2.840.10008.1.2.5': [defaultMediaType],\n        '1.2.840.10008.1.2.4.50': [defaultMediaType],\n        '1.2.840.10008.1.2.4.51': [defaultMediaType],\n        '1.2.840.10008.1.2.4.57': [defaultMediaType],\n        '1.2.840.10008.1.2.4.70': [defaultMediaType],\n        '1.2.840.10008.1.2.4.80': [defaultMediaType],\n        '1.2.840.10008.1.2.4.81': [defaultMediaType],\n        '1.2.840.10008.1.2.4.90': [defaultMediaType],\n        '1.2.840.10008.1.2.4.91': [defaultMediaType],\n        '1.2.840.10008.1.2.4.92': [defaultMediaType],\n        '1.2.840.10008.1.2.4.93': [defaultMediaType],\n        '1.2.840.10008.1.2.4.100': [defaultMediaType],\n        '1.2.840.10008.1.2.4.101': [defaultMediaType],\n        '1.2.840.10008.1.2.4.102': [defaultMediaType],\n        '1.2.840.10008.1.2.4.103': [defaultMediaType],\n        '1.2.840.10008.1.2.4.104': [defaultMediaType],\n        '1.2.840.10008.1.2.4.105': [defaultMediaType],\n        '1.2.840.10008.1.2.4.106': [defaultMediaType]\n      };\n      var acceptableMediaTypes = mediaTypes;\n      if (!mediaTypes) {\n        acceptableMediaTypes = [{\n          mediaType: defaultMediaType\n        }];\n      }\n      headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(acceptableMediaTypes, supportedMediaTypes);\n      return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n    }\n    /**\n     * Performs an HTTP GET request that accepts a multipart message\n     * with a application/octet-stream, OR any of the equivalencies for that (eg\n     * application/pdf etc)\n     *\n     * @param {String} url - Unique resource locator\n     * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n     corresponding transfer syntaxes\n     * @param {Array} byteRange start and end of byte range\n     * @param {Object} params - Additional HTTP GET query parameters\n     * @param {Function} progressCallback\n     * @private\n     * @returns {Promise<Array>} Content of HTTP message body parts\n     */\n  }, {\n    key: \"_httpGetMultipartApplicationOctetStream\",\n    value: function _httpGetMultipartApplicationOctetStream(url, mediaTypes, byteRange, params, progressCallback, withCredentials) {\n      var headers = {};\n      var defaultMediaType = 'application/octet-stream';\n      var supportedMediaTypes = {\n        '1.2.840.10008.1.2.1': _toConsumableArray(Object.values(MEDIATYPES))\n      };\n      var acceptableMediaTypes = mediaTypes;\n      if (!mediaTypes) {\n        acceptableMediaTypes = [{\n          mediaType: defaultMediaType\n        }];\n      }\n      if (byteRange) {\n        headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n      }\n      headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(acceptableMediaTypes, supportedMediaTypes);\n      return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n    }\n    /**\n     * Performs an HTTP POST request.\n     *\n     * @param {String} url - Unique resource locator\n     * @param {Object} headers - HTTP header fields\n     * @param {Array} data - Data that should be stored\n     * @param {Function} progressCallback\n     * @param {Function} progressCallback\n     * @param {XMLHttpRequest} request - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n     * @private\n     * @returns {Promise} Response\n     */\n  }, {\n    key: \"_httpPost\",\n    value: function _httpPost(url, headers, data, progressCallback, withCredentials, request) {\n      return this._httpRequest(url, 'post', headers, {\n        data: data,\n        progressCallback: progressCallback,\n        withCredentials: withCredentials,\n        request: request\n      });\n    }\n    /**\n     * Performs an HTTP POST request with content-type application/dicom+json.\n     *\n     * @param {String} url - Unique resource locator\n     * @param {Object} headers - HTTP header fields\n     * @param {Array} data - Data that should be stored\n     * @param {Function} progressCallback\n     * @private\n     * @returns {Promise} Response\n     */\n  }, {\n    key: \"_httpPostApplicationJson\",\n    value: function _httpPostApplicationJson(url, data, progressCallback, withCredentials) {\n      var headers = {\n        'Content-Type': MEDIATYPES.DICOM_JSON\n      };\n      return this._httpPost(url, headers, data, progressCallback, withCredentials);\n    }\n    /**\n     * Parses media type and extracts its type and subtype.\n     *\n     * @param {String} mediaType - HTTP media type (e.g. image/jpeg)\n     * @private\n     * @returns {String[]} Media type and subtype\n     */\n  }, {\n    key: \"searchForStudies\",\n    /**\n     * Searches for DICOM studies.\n     *\n     * @param {Object} options\n     * @param {Object} [options.queryParams] - HTTP query parameters\n     * @return {Object[]} Study representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2)\n     */\n    value: function searchForStudies() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      debugLog('search for studies');\n      var withCredentials = false;\n      var url = \"\".concat(this.qidoURL, \"/studies\");\n      if ('queryParams' in options) {\n        url += DICOMwebClient._parseQueryParameters(options.queryParams);\n      }\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      return this._httpGetApplicationJson(url, {}, false, withCredentials);\n    }\n    /**\n     * Retrieves metadata for a DICOM study.\n     *\n     * @param {Object} options\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @returns {Promise<InstanceMetadata[]>} Metadata elements in DICOM JSON format for each instance\n                        belonging to the study\n     */\n  }, {\n    key: \"retrieveStudyMetadata\",\n    value: function retrieveStudyMetadata(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required for retrieval of study metadata');\n      }\n      debugLog(\"retrieve metadata of study \".concat(options.studyInstanceUID));\n      var url = \"\".concat(this.wadoURL, \"/studies/\").concat(options.studyInstanceUID, \"/metadata\");\n      var withCredentials = false;\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      return this._httpGetApplicationJson(url, {}, false, withCredentials);\n    }\n    /**\n     * Searches for DICOM series.\n     *\n     * @param {Object} options\n     * @param {Object} [options.studyInstanceUID] - Study Instance UID\n     * @param {Object} [options.queryParams] - HTTP query parameters\n     * @returns {Object[]} Series representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2a)\n     */\n  }, {\n    key: \"searchForSeries\",\n    value: function searchForSeries() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var url = this.qidoURL;\n      if ('studyInstanceUID' in options) {\n        debugLog(\"search series of study \".concat(options.studyInstanceUID));\n        url += \"/studies/\".concat(options.studyInstanceUID);\n      }\n      url += '/series';\n      if ('queryParams' in options) {\n        url += DICOMwebClient._parseQueryParameters(options.queryParams);\n      }\n      var withCredentials = false;\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      return this._httpGetApplicationJson(url, {}, false, withCredentials);\n    }\n    /**\n     * Retrieves metadata for a DICOM series.\n     *\n     * @param {Object} options\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @param {String} options.seriesInstanceUID - Series Instance UID\n     * @returns {Promise<InstanceMetadata[]>} Metadata elements in DICOM JSON format for each instance\n                        belonging to the series\n     */\n  }, {\n    key: \"retrieveSeriesMetadata\",\n    value: function retrieveSeriesMetadata(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required for retrieval of series metadata');\n      }\n      if (!('seriesInstanceUID' in options)) {\n        throw new Error('Series Instance UID is required for retrieval of series metadata');\n      }\n      debugLog(\"retrieve metadata of series \".concat(options.seriesInstanceUID));\n      var url = \"\".concat(this.wadoURL, \"/studies/\").concat(options.studyInstanceUID, \"/series/\").concat(options.seriesInstanceUID, \"/metadata\");\n      var withCredentials = false;\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      return this._httpGetApplicationJson(url, {}, false, withCredentials);\n    }\n    /**\n     * Searches for DICOM Instances.\n     *\n     * @param {Object} options\n     * @param {String} [options.studyInstanceUID] - Study Instance UID\n     * @param {String} [options.seriesInstanceUID] - Series Instance UID\n     * @param {Object} [options.queryParams] - HTTP query parameters\n     * @returns {Object[]} Instance representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2b)\n     */\n  }, {\n    key: \"searchForInstances\",\n    value: function searchForInstances() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var url = this.qidoURL;\n      var withCredentials = false;\n      if ('studyInstanceUID' in options) {\n        url += \"/studies/\".concat(options.studyInstanceUID);\n        if ('seriesInstanceUID' in options) {\n          debugLog(\"search for instances of series \".concat(options.seriesInstanceUID));\n          url += \"/series/\".concat(options.seriesInstanceUID);\n        } else {\n          debugLog(\"search for instances of study \".concat(options.studyInstanceUID));\n        }\n      } else {\n        debugLog('search for instances');\n      }\n      url += '/instances';\n      if ('queryParams' in options) {\n        url += DICOMwebClient._parseQueryParameters(options.queryParams);\n      }\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      return this._httpGetApplicationJson(url, {}, false, withCredentials);\n    }\n    /** Returns a WADO-URI URL for an instance\n     *\n     * @param {Object} options\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @param {String} options.seriesInstanceUID - Series Instance UID\n     * @param {String} options.sopInstanceUID - SOP Instance UID\n     * @returns {String} WADO-URI URL\n     */\n  }, {\n    key: \"buildInstanceWadoURIUrl\",\n    value: function buildInstanceWadoURIUrl(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required.');\n      }\n      if (!('seriesInstanceUID' in options)) {\n        throw new Error('Series Instance UID is required.');\n      }\n      if (!('sopInstanceUID' in options)) {\n        throw new Error('SOP Instance UID is required.');\n      }\n      var contentType = options.contentType || MEDIATYPES.DICOM;\n      var transferSyntax = options.transferSyntax || '*';\n      var params = [];\n      params.push('requestType=WADO');\n      params.push(\"studyUID=\".concat(options.studyInstanceUID));\n      params.push(\"seriesUID=\".concat(options.seriesInstanceUID));\n      params.push(\"objectUID=\".concat(options.sopInstanceUID));\n      params.push(\"contentType=\".concat(contentType));\n      params.push(\"transferSyntax=\".concat(transferSyntax));\n      var paramString = params.join('&');\n      return \"\".concat(this.wadoURL, \"?\").concat(paramString);\n    }\n    /**\n     * Retrieves metadata for a DICOM Instance.\n     *\n     * @param {Object} options object\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @param {String} options.seriesInstanceUID - Series Instance UID\n     * @param {String} options.sopInstanceUID - SOP Instance UID\n     * @returns {Promise<InstanceMetadata>} metadata elements in DICOM JSON format\n     */\n  }, {\n    key: \"retrieveInstanceMetadata\",\n    value: function retrieveInstanceMetadata(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required for retrieval of instance metadata');\n      }\n      if (!('seriesInstanceUID' in options)) {\n        throw new Error('Series Instance UID is required for retrieval of instance metadata');\n      }\n      if (!('sopInstanceUID' in options)) {\n        throw new Error('SOP Instance UID is required for retrieval of instance metadata');\n      }\n      debugLog(\"retrieve metadata of instance \".concat(options.sopInstanceUID));\n      var url = \"\".concat(this.wadoURL, \"/studies/\").concat(options.studyInstanceUID, \"/series/\").concat(options.seriesInstanceUID, \"/instances/\").concat(options.sopInstanceUID, \"/metadata\");\n      var withCredentials = false;\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      return this._httpGetApplicationJson(url, {}, false, withCredentials);\n    }\n    /**\n     * Retrieves frames for a DICOM Instance.\n     * @param {Object} options options object\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @param {String} options.seriesInstanceUID - Series Instance UID\n     * @param {String} options.sopInstanceUID - SOP Instance UID\n     * @param {String} options.frameNumbers - One-based indices of Frame Items\n     * @returns {Array} frame items as byte arrays of the pixel data element\n     */\n  }, {\n    key: \"retrieveInstanceFrames\",\n    value: function retrieveInstanceFrames(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required for retrieval of instance frames');\n      }\n      if (!('seriesInstanceUID' in options)) {\n        throw new Error('Series Instance UID is required for retrieval of instance frames');\n      }\n      if (!('sopInstanceUID' in options)) {\n        throw new Error('SOP Instance UID is required for retrieval of instance frames');\n      }\n      if (!('frameNumbers' in options)) {\n        throw new Error('frame numbers are required for retrieval of instance frames');\n      }\n      debugLog(\"retrieve frames \".concat(options.frameNumbers.toString(), \" of instance \").concat(options.sopInstanceUID));\n      var url = \"\".concat(this.wadoURL, \"/studies/\").concat(options.studyInstanceUID, \"/series/\").concat(options.seriesInstanceUID, \"/instances/\").concat(options.sopInstanceUID, \"/frames/\").concat(options.frameNumbers.toString());\n      var mediaTypes = options.mediaTypes;\n      var withCredentials = false;\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      var progressCallback = false;\n      if ('progressCallback' in options) {\n        progressCallback = options.progressCallback;\n      }\n      if (!mediaTypes) {\n        return this._httpGetMultipartApplicationOctetStream(url, false, false, false, progressCallback, withCredentials);\n      }\n      var sharedMediaTypes = DICOMwebClient._getSharedMediaTypes(mediaTypes);\n      if (sharedMediaTypes.length > 1) {\n        /**\n         * Enable request of frames that are stored either compressed\n         * (image/* media type) or uncompressed (application/octet-stream\n         * media type).\n         */\n        var supportedMediaTypes = {\n          '1.2.840.10008.1.2.1': ['application/octet-stream'],\n          '1.2.840.10008.1.2.5': ['image/x-dicom-rle'],\n          '1.2.840.10008.1.2.4.50': ['image/jpeg'],\n          '1.2.840.10008.1.2.4.51': ['image/jpeg'],\n          '1.2.840.10008.1.2.4.57': ['image/jpeg'],\n          '1.2.840.10008.1.2.4.70': ['image/jpeg'],\n          '1.2.840.10008.1.2.4.80': ['image/x-jls', 'image/jls'],\n          '1.2.840.10008.1.2.4.81': ['image/x-jls', 'image/jls'],\n          '1.2.840.10008.1.2.4.90': ['image/jp2'],\n          '1.2.840.10008.1.2.4.91': ['image/jp2'],\n          '1.2.840.10008.1.2.4.92': ['image/jpx'],\n          '1.2.840.10008.1.2.4.93': ['image/jpx'],\n          '1.2.840.10008.1.2.4.201': ['image/jhc'],\n          '1.2.840.10008.1.2.4.202': ['image/jhc']\n        };\n        var headers = {\n          Accept: DICOMwebClient._buildMultipartAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes)\n        };\n        return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n      }\n      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n      if (commonMediaType.startsWith('application')) {\n        return this._httpGetMultipartApplicationOctetStream(url, mediaTypes, false, false, progressCallback, withCredentials);\n      }\n      if (commonMediaType.startsWith('image')) {\n        return this._httpGetMultipartImage(url, mediaTypes, false, false, false, progressCallback, withCredentials);\n      }\n      if (commonMediaType.startsWith('video')) {\n        return this._httpGetMultipartVideo(url, mediaTypes, false, false, false, progressCallback, withCredentials);\n      }\n      throw new Error(\"Media type \".concat(commonMediaType, \" is not supported for retrieval of frames.\"));\n    }\n    /**\n    * Element in mediaTypes parameter\n    * @typedef {Object} MediaType\n    * @param {String} [MediaType.mediaType] - ie 'image/jpeg', 'image/png'...\n    */\n    /**\n     * Retrieves an individual, server-side rendered DICOM Instance.\n     *\n     * @param {Object} options\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @param {String} options.seriesInstanceUID - Series Instance UID\n     * @param {String} options.sopInstanceUID - SOP Instance UID\n     * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n     * @param {Object} [options.queryParams] - HTTP query parameters\n     * @returns {Promise<ArrayBuffer>} Rendered DICOM Instance\n     */\n  }, {\n    key: \"retrieveInstanceRendered\",\n    value: function retrieveInstanceRendered(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required for retrieval of rendered instance');\n      }\n      if (!('seriesInstanceUID' in options)) {\n        throw new Error('Series Instance UID is required for retrieval of rendered instance');\n      }\n      if (!('sopInstanceUID' in options)) {\n        throw new Error('SOP Instance UID is required for retrieval of rendered instance');\n      }\n      var url = \"\".concat(this.wadoURL, \"/studies/\").concat(options.studyInstanceUID, \"/series/\").concat(options.seriesInstanceUID, \"/instances/\").concat(options.sopInstanceUID, \"/rendered\");\n      var mediaTypes = options.mediaTypes,\n        queryParams = options.queryParams;\n      var headers = {};\n      var withCredentials = false;\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      var progressCallback = false;\n      if ('progressCallback' in options) {\n        progressCallback = options.progressCallback;\n      }\n      if (!mediaTypes) {\n        var responseType = 'arraybuffer';\n        if (queryParams) {\n          url += DICOMwebClient._parseQueryParameters(queryParams);\n        }\n        return this._httpGet(url, headers, responseType, progressCallback, withCredentials);\n      }\n      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n      if (commonMediaType.startsWith('image')) {\n        return this._httpGetImage(url, mediaTypes, queryParams, progressCallback, withCredentials);\n      }\n      if (commonMediaType.startsWith('video')) {\n        return this._httpGetVideo(url, mediaTypes, queryParams, progressCallback, withCredentials);\n      }\n      if (commonMediaType.startsWith('text')) {\n        return this._httpGetText(url, mediaTypes, queryParams, progressCallback, withCredentials);\n      }\n      if (commonMediaType === MEDIATYPES.PDF) {\n        return this._httpGetApplicationPdf(url, queryParams, progressCallback, withCredentials);\n      }\n      throw new Error(\"Media type \".concat(commonMediaType, \" is not supported \") + 'for retrieval of rendered instance.');\n    }\n    /**\n     * Retrieves a thumbnail of an DICOM Instance.\n     *\n     * @param {Object} options\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @param {String} options.seriesInstanceUID - Series Instance UID\n     * @param {String} options.sopInstanceUID - SOP Instance UID\n     * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n     * @param {Object} [options.queryParams] - HTTP query parameters\n     * @returns {ArrayBuffer} Thumbnail\n     */\n  }, {\n    key: \"retrieveInstanceThumbnail\",\n    value: function retrieveInstanceThumbnail(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required for retrieval of rendered instance');\n      }\n      if (!('seriesInstanceUID' in options)) {\n        throw new Error('Series Instance UID is required for retrieval of rendered instance');\n      }\n      if (!('sopInstanceUID' in options)) {\n        throw new Error('SOP Instance UID is required for retrieval of rendered instance');\n      }\n      var url = \"\".concat(this.wadoURL, \"/studies/\").concat(options.studyInstanceUID, \"/series/\").concat(options.seriesInstanceUID, \"/instances/\").concat(options.sopInstanceUID, \"/thumbnail\");\n      var mediaTypes = options.mediaTypes,\n        queryParams = options.queryParams;\n      var headers = {};\n      var withCredentials = false;\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      var progressCallback = false;\n      if ('progressCallback' in options) {\n        progressCallback = options.progressCallback;\n      }\n      if (!mediaTypes) {\n        var responseType = 'arraybuffer';\n        if (queryParams) {\n          url += DICOMwebClient._parseQueryParameters(queryParams);\n        }\n        return this._httpGet(url, headers, responseType, progressCallback, withCredentials);\n      }\n      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n      if (commonMediaType.startsWith('image')) {\n        return this._httpGetImage(url, mediaTypes, queryParams, progressCallback, withCredentials);\n      }\n      throw new Error(\"Media type \".concat(commonMediaType, \" is not supported \") + 'for retrieval of rendered instance.');\n    }\n    /**\n     * Retrieves rendered frames for a DICOM Instance.\n     *\n     * @param {Object} options\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @param {String} options.seriesInstanceUID - Series Instance UID\n     * @param {String} options.sopInstanceUID - SOP Instance UID\n     * @param {String} options.frameNumbers - One-based indices of Frame Items\n     * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n     * @param {Object} [options.queryParams] - HTTP query parameters\n     * @returns {ArrayBuffer[]} Rendered Frame Items as byte arrays\n     */\n  }, {\n    key: \"retrieveInstanceFramesRendered\",\n    value: function retrieveInstanceFramesRendered(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required for retrieval of rendered instance frames');\n      }\n      if (!('seriesInstanceUID' in options)) {\n        throw new Error('Series Instance UID is required for retrieval of rendered instance frames');\n      }\n      if (!('sopInstanceUID' in options)) {\n        throw new Error('SOP Instance UID is required for retrieval of rendered instance frames');\n      }\n      if (!('frameNumbers' in options)) {\n        throw new Error('frame numbers are required for retrieval of rendered instance frames');\n      }\n      debugLog(\"retrieve rendered frames \".concat(options.frameNumbers.toString(), \" of instance \").concat(options.sopInstanceUID));\n      var url = \"\".concat(this.wadoURL, \"/studies/\").concat(options.studyInstanceUID, \"/series/\").concat(options.seriesInstanceUID, \"/instances/\").concat(options.sopInstanceUID, \"/frames/\").concat(options.frameNumbers.toString(), \"/rendered\");\n      var mediaTypes = options.mediaTypes,\n        queryParams = options.queryParams;\n      var headers = {};\n      var withCredentials = false;\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      var progressCallback = false;\n      if ('progressCallback' in options) {\n        progressCallback = options.progressCallback;\n      }\n      if (!mediaTypes) {\n        var responseType = 'arraybuffer';\n        if (queryParams) {\n          url += DICOMwebClient._parseQueryParameters(queryParams);\n        }\n        return this._httpGet(url, headers, responseType, false, withCredentials);\n      }\n      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n      if (commonMediaType.startsWith('image')) {\n        return this._httpGetImage(url, mediaTypes, queryParams, progressCallback, withCredentials);\n      }\n      if (commonMediaType.startsWith('video')) {\n        return this._httpGetVideo(url, mediaTypes, queryParams, progressCallback, withCredentials);\n      }\n      throw new Error(\"Media type \".concat(commonMediaType, \" is not supported \") + 'for retrieval of rendered frame.');\n    }\n    /**\n     * Retrieves thumbnail of frames for a DICOM Instance.\n     *\n     * @param {Object} options\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @param {String} options.seriesInstanceUID - Series Instance UID\n     * @param {String} options.sopInstanceUID - SOP Instance UID\n     * @param {String} options.frameNumbers - One-based indices of Frame Items\n     * @param {Object} [options.queryParams] - HTTP query parameters\n     * @returns {ArrayBuffer[]} Rendered Frame Items as byte arrays\n     */\n  }, {\n    key: \"retrieveInstanceFramesThumbnail\",\n    value: function retrieveInstanceFramesThumbnail(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required for retrieval of rendered instance frames');\n      }\n      if (!('seriesInstanceUID' in options)) {\n        throw new Error('Series Instance UID is required for retrieval of rendered instance frames');\n      }\n      if (!('sopInstanceUID' in options)) {\n        throw new Error('SOP Instance UID is required for retrieval of rendered instance frames');\n      }\n      if (!('frameNumbers' in options)) {\n        throw new Error('frame numbers are required for retrieval of rendered instance frames');\n      }\n      console.debug(\"retrieve rendered frames \".concat(options.frameNumbers.toString(), \" of instance \").concat(options.sopInstanceUID));\n      var url = \"\".concat(this.wadoURL, \"/studies/\").concat(options.studyInstanceUID, \"/series/\").concat(options.seriesInstanceUID, \"/instances/\").concat(options.sopInstanceUID, \"/frames/\").concat(options.frameNumbers.toString(), \"/thumbnail\");\n      var mediaTypes = options.mediaTypes,\n        queryParams = options.queryParams;\n      var headers = {};\n      var withCredentials = false;\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      var progressCallback = false;\n      if ('progressCallback' in options) {\n        progressCallback = options.progressCallback;\n      }\n      if (!mediaTypes) {\n        var responseType = 'arraybuffer';\n        if (queryParams) {\n          url += DICOMwebClient._parseQueryParameters(queryParams);\n        }\n        return this._httpGet(url, headers, responseType, progressCallback, withCredentials);\n      }\n      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n      if (commonMediaType.startsWith('image')) {\n        return this._httpGetImage(url, mediaTypes, queryParams, progressCallback, withCredentials);\n      }\n      throw new Error(\"Media type \".concat(commonMediaType, \" is not supported \") + 'for retrieval of rendered frame.');\n    }\n    /**\n     * Retrieves a DICOM Instance.\n     *\n     * @param {Object} options\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @param {String} options.seriesInstanceUID - Series Instance UID\n     * @param {String} options.sopInstanceUID - SOP Instance UID\n     * @returns {Promise<ArrayBuffer>} DICOM Part 10 file as Arraybuffer\n     */\n  }, {\n    key: \"retrieveInstance\",\n    value: function retrieveInstance(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required');\n      }\n      if (!('seriesInstanceUID' in options)) {\n        throw new Error('Series Instance UID is required');\n      }\n      if (!('sopInstanceUID' in options)) {\n        throw new Error('SOP Instance UID is required');\n      }\n      var url = \"\".concat(this.wadoURL, \"/studies/\").concat(options.studyInstanceUID, \"/series/\").concat(options.seriesInstanceUID, \"/instances/\").concat(options.sopInstanceUID);\n      var mediaTypes = options.mediaTypes;\n      var _options$withCredenti = options.withCredentials,\n        withCredentials = _options$withCredenti === void 0 ? false : _options$withCredenti;\n      var _options$progressCall = options.progressCallback,\n        progressCallback = _options$progressCall === void 0 ? false : _options$progressCall;\n      if (!mediaTypes) {\n        return this._httpGetMultipartApplicationDicom(url, false, false, progressCallback, withCredentials).then(getFirstResult);\n      }\n      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n      if (commonMediaType === MEDIATYPES.DICOM) {\n        return this._httpGetMultipartApplicationDicom(url, mediaTypes, false, progressCallback, withCredentials).then(getFirstResult);\n      }\n      throw new Error(\"Media type \".concat(commonMediaType, \" is not supported for retrieval of instance.\"));\n    }\n    /**\n     * Retrieves all DICOM Instances of a Series.\n     *\n     * @param {Object} options\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @param {String} options.seriesInstanceUID - Series Instance UID\n     * @param {Function} options.progressCallback\n     * @returns {Promise<ArrayBuffer[]>} DICOM Instances\n     */\n  }, {\n    key: \"retrieveSeries\",\n    value: function retrieveSeries(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required');\n      }\n      if (!('seriesInstanceUID' in options)) {\n        throw new Error('Series Instance UID is required');\n      }\n      var url = \"\".concat(this.wadoURL, \"/studies/\").concat(options.studyInstanceUID, \"/series/\").concat(options.seriesInstanceUID);\n      var mediaTypes = options.mediaTypes;\n      var withCredentials = false;\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      var progressCallback = false;\n      if ('progressCallback' in options) {\n        progressCallback = options.progressCallback;\n      }\n      if (!mediaTypes) {\n        return this._httpGetMultipartApplicationDicom(url, false, false, progressCallback, withCredentials);\n      }\n      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n      if (commonMediaType === MEDIATYPES.DICOM) {\n        return this._httpGetMultipartApplicationDicom(url, mediaTypes, false, progressCallback, withCredentials);\n      }\n      throw new Error(\"Media type \".concat(commonMediaType, \" is not supported for retrieval of series.\"));\n    }\n    /**\n     * Retrieves all DICOM Instances of a Study.\n     *\n     * @param {Object} options\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @returns {ArrayBuffer[]} DICOM Instances\n     */\n  }, {\n    key: \"retrieveStudy\",\n    value: function retrieveStudy(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required');\n      }\n      var url = \"\".concat(this.wadoURL, \"/studies/\").concat(options.studyInstanceUID);\n      var mediaTypes = options.mediaTypes;\n      var _options$withCredenti2 = options.withCredentials,\n        withCredentials = _options$withCredenti2 === void 0 ? false : _options$withCredenti2;\n      var _options$progressCall2 = options.progressCallback,\n        progressCallback = _options$progressCall2 === void 0 ? false : _options$progressCall2;\n      if (!mediaTypes) {\n        return this._httpGetMultipartApplicationDicom(url, false, false, progressCallback, withCredentials);\n      }\n      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n      if (commonMediaType === MEDIATYPES.DICOM) {\n        return this._httpGetMultipartApplicationDicom(url, mediaTypes, false, progressCallback, withCredentials);\n      }\n      throw new Error(\"Media type \".concat(commonMediaType, \" is not supported for retrieval of study.\"));\n    }\n    /**\n     * Retrieves and parses BulkData from a BulkDataURI location.\n     * Decodes the multipart encoded data and returns the resulting data\n     * as an ArrayBuffer.\n     *\n     * See http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.5.5.html\n     *\n     * @param {Object} options\n     * @param {string} options.BulkDataURI to retrieve\n     * @param {Array}  options.mediaTypes to use to fetch the URI\n     * @param {string} options.byteRange to request a sub-range (only valid on single part)\n     * @returns {Promise<Array>} Bulkdata parts\n     */\n  }, {\n    key: \"retrieveBulkData\",\n    value: function retrieveBulkData(options) {\n      if (!('BulkDataURI' in options)) {\n        throw new Error('BulkDataURI is required.');\n      }\n      var url = options.BulkDataURI;\n      var mediaTypes = options.mediaTypes,\n        byteRange = options.byteRange;\n      var _options$withCredenti3 = options.withCredentials,\n        withCredentials = _options$withCredenti3 === void 0 ? false : _options$withCredenti3;\n      var _options$progressCall3 = options.progressCallback,\n        progressCallback = _options$progressCall3 === void 0 ? false : _options$progressCall3;\n      if (this.singlepart.indexOf('bulkdata') !== -1) {\n        return this._httpGet(url, options.headers, 'arraybuffer', null, withCredentials);\n      }\n      if (mediaTypes) {\n        try {\n          var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n          if (commonMediaType === 'image/') {\n            return this._httpGetMultipartImage(url, mediaTypes, byteRange, false, false, progressCallback, withCredentials);\n          }\n        } catch (e) {\n          // No-op - this happens sometimes if trying to fetch the specific desired type but want to fallback to octet-stream\n        }\n      }\n\n      // Just use the media types provided\n      return this._httpGetMultipartApplicationOctetStream(url, mediaTypes, byteRange, false, progressCallback, withCredentials);\n    }\n    /**\n     * Stores DICOM Instances.\n     *\n     * @param {Object} options\n     * @param {ArrayBuffer[]} options.datasets - DICOM Instances in PS3.10 format\n     * @param {String} [options.studyInstanceUID] - Study Instance UID\n     * @param {XMLHttpRequest} [options.request] - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n     * @returns {Promise} Response message\n     */\n  }, {\n    key: \"storeInstances\",\n    value: function storeInstances(options) {\n      if (!('datasets' in options)) {\n        throw new Error('datasets are required for storing');\n      }\n      var url = \"\".concat(this.stowURL, \"/studies\");\n      if ('studyInstanceUID' in options) {\n        url += \"/\".concat(options.studyInstanceUID);\n      }\n      var _multipartEncode = multipartEncode(options.datasets),\n        data = _multipartEncode.data,\n        boundary = _multipartEncode.boundary;\n      var headers = {\n        'Content-Type': \"multipart/related; type=\\\"application/dicom\\\"; boundary=\\\"\".concat(boundary, \"\\\"\")\n      };\n      var _options$withCredenti4 = options.withCredentials,\n        withCredentials = _options$withCredenti4 === void 0 ? false : _options$withCredenti4;\n      return this._httpPost(url, headers, data, options.progressCallback, withCredentials, options.request);\n    }\n  }], [{\n    key: \"_parseQueryParameters\",\n    value: function _parseQueryParameters() {\n      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var queryString = '?';\n      Object.keys(params).forEach(function (key, index) {\n        if (index !== 0) {\n          queryString += '&';\n        }\n        queryString += \"\".concat(key, \"=\").concat(encodeURIComponent(params[key]));\n      });\n      return queryString;\n    }\n  }, {\n    key: \"_assertMediaTypeIsValid\",\n    value: function _assertMediaTypeIsValid(mediaType) {\n      if (!mediaType) {\n        throw new Error(\"Not a valid media type: \".concat(mediaType));\n      }\n      var sepIndex = mediaType.indexOf('/');\n      if (sepIndex === -1) {\n        throw new Error(\"Not a valid media type: \".concat(mediaType));\n      }\n      var mediaTypeType = mediaType.slice(0, sepIndex);\n      var types = ['application', 'image', 'text', 'video'];\n      if (!types.includes(mediaTypeType)) {\n        throw new Error(\"Not a valid media type: \".concat(mediaType));\n      }\n      if (mediaType.slice(sepIndex + 1).includes('/')) {\n        throw new Error(\"Not a valid media type: \".concat(mediaType));\n      }\n    }\n  }, {\n    key: \"_parseMediaType\",\n    value: function _parseMediaType(mediaType) {\n      DICOMwebClient._assertMediaTypeIsValid(mediaType);\n      return mediaType.split('/');\n    }\n    /**\n     * Builds an accept header field value for HTTP GET request messages.\n     *\n     * @param {Object[]} mediaTypes - Acceptable media types\n     * @param {Object[]} supportedMediaTypes - Supported media types\n     * @return {*}\n     * @private\n     */\n  }, {\n    key: \"_buildAcceptHeaderFieldValue\",\n    value: function _buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes) {\n      if (!Array.isArray(mediaTypes)) {\n        throw new Error('Acceptable media types must be provided as an Array');\n      }\n      var fieldValueParts = mediaTypes.map(function (item) {\n        var mediaType = item.mediaType;\n        DICOMwebClient._assertMediaTypeIsValid(mediaType);\n        if (!supportedMediaTypes.includes(mediaType)) {\n          throw new Error(\"Media type \".concat(mediaType, \" is not supported for requested resource\"));\n        }\n        return mediaType;\n      });\n      return fieldValueParts.join(', ');\n    }\n    /**\n     * Builds an accept header field value for HTTP GET multipart request\n     * messages.  Will throw an exception if no media types are found which are acceptable,\n     * but will only log a verbose level message when types are specified which are\n     * not acceptable.  This allows requesting several types with having to know\n     * whether they are all acceptable or not.\n     *\n     * @param {Object[]} mediaTypes - Acceptable media types\n     * @param {Object[]} supportedMediaTypes - Supported media types\n     * @private\n     */\n  }, {\n    key: \"_buildMultipartAcceptHeaderFieldValue\",\n    value: function _buildMultipartAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes) {\n      var _this2 = this;\n      if (!Array.isArray(mediaTypes)) {\n        throw new Error('Acceptable media types must be provided as an Array');\n      }\n      if (!Array.isArray(supportedMediaTypes) && !isObject(supportedMediaTypes)) {\n        throw new Error('Supported media types must be provided as an Array or an Object');\n      }\n      var fieldValueParts = [];\n      mediaTypes.forEach(function (item) {\n        var transferSyntaxUID = item.transferSyntaxUID,\n          mediaType = item.mediaType;\n        DICOMwebClient._assertMediaTypeIsValid(mediaType);\n        var fieldValue = \"multipart/related; type=\\\"\".concat(mediaType, \"\\\"\");\n        if (isObject(supportedMediaTypes)) {\n          // SupportedMediaTypes is a lookup table that maps Transfer Syntax UID\n          // to one or more Media Types\n          if (!Object.values(supportedMediaTypes).flat(1).includes(mediaType)) {\n            if (!mediaType.endsWith('/*') || !mediaType.endsWith('/')) {\n              debugLog(\"Media type \".concat(mediaType, \" is not supported for requested resource\"));\n              return;\n            }\n          }\n          if (transferSyntaxUID) {\n            if (transferSyntaxUID !== '*') {\n              if (!Object.keys(supportedMediaTypes).includes(transferSyntaxUID)) {\n                throw new Error(\"Transfer syntax \".concat(transferSyntaxUID, \" is not supported for requested resource\"));\n              }\n              var expectedMediaTypes = supportedMediaTypes[transferSyntaxUID];\n              if (!expectedMediaTypes.includes(mediaType)) {\n                var actualType = DICOMwebClient._parseMediaType(mediaType)[0];\n                expectedMediaTypes.map(function (expectedMediaType) {\n                  var expectedType = DICOMwebClient._parseMediaType(expectedMediaType)[0];\n                  var haveSameType = actualType === expectedType;\n                  if (haveSameType && (mediaType.endsWith('/*') || mediaType.endsWith('/'))) {\n                    return;\n                  }\n                  throw new Error(\"Transfer syntax \".concat(transferSyntaxUID, \" is not supported for requested resource\"));\n                });\n              }\n            }\n            fieldValue += \"; transfer-syntax=\".concat(transferSyntaxUID);\n          }\n        } else if (Array.isArray(supportedMediaTypes) && !supportedMediaTypes.includes(mediaType)) {\n          if (_this2.verbose) {\n            console.warn(\"Media type \".concat(mediaType, \" is not supported for requested resource\"));\n          }\n          return;\n        }\n        fieldValueParts.push(fieldValue);\n      });\n      if (!fieldValueParts.length) {\n        throw new Error(\"No acceptable media types found among \".concat(JSON.stringify(mediaTypes)));\n      }\n      return fieldValueParts.join(', ');\n    }\n    /**\n     * Builds a range header field value for HTTP GET request messages.\n     *\n     * @param {Array} byteRange - Start and end of byte range\n     * @returns {String} Range header field value\n     * @private\n     */\n  }, {\n    key: \"_buildRangeHeaderFieldValue\",\n    value: function _buildRangeHeaderFieldValue() {\n      var byteRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      if (byteRange.length === 1) {\n        return \"bytes=\".concat(byteRange[0], \"-\");\n      }\n      if (byteRange.length === 2) {\n        return \"bytes=\".concat(byteRange[0], \"-\").concat(byteRange[1]);\n      }\n      return 'bytes=0-';\n    }\n    /**\n     * Gets types that are shared among acceptable media types.\n     *\n     * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n     corresponding transfer syntaxes\n     * @private\n     * @returns {String[]} Types that are shared among acceptable media types\n     */\n  }, {\n    key: \"_getSharedMediaTypes\",\n    value: function _getSharedMediaTypes(mediaTypes) {\n      var types = new Set();\n      if (!mediaTypes || !mediaTypes.length) {\n        return types;\n      }\n      mediaTypes.forEach(function (item) {\n        var mediaType = item.mediaType;\n        var type = DICOMwebClient._parseMediaType(mediaType)[0];\n        types.add(\"\".concat(type, \"/\"));\n      });\n      return Array.from(types);\n    }\n    /**\n     * Gets common base type of acceptable media types and asserts that only\n     one type is specified. For example, ``(\"image/jpeg\", \"image/jp2\")``\n     will pass, but ``(\"image/jpeg\", \"video/mpeg2\")`` will raise an\n     exception.\n     *\n     * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n     corresponding transfer syntaxes\n     * @private\n     * @returns {String[]} Common media type, eg `image/` for the above example.\n     */\n  }, {\n    key: \"_getCommonMediaType\",\n    value: function _getCommonMediaType(mediaTypes) {\n      if (!mediaTypes || !mediaTypes.length) {\n        throw new Error('No acceptable media types provided');\n      }\n      var sharedMediaTypes = DICOMwebClient._getSharedMediaTypes(mediaTypes);\n      if (sharedMediaTypes.length === 0) {\n        throw new Error('No common acceptable media type could be identified.');\n      } else if (sharedMediaTypes.length > 1) {\n        throw new Error('Acceptable media types must have the same type.');\n      }\n      return sharedMediaTypes[0];\n    }\n  }]);\n  return DICOMwebClient;\n}();\n\nfunction findSubstring(str, before, after) {\n  var beforeIndex = str.lastIndexOf(before) + before.length;\n  if (beforeIndex < before.length) {\n    return null;\n  }\n  if (after !== undefined) {\n    var afterIndex = str.lastIndexOf(after);\n    if (afterIndex < 0) {\n      return null;\n    }\n    return str.substring(beforeIndex, afterIndex);\n  }\n  return str.substring(beforeIndex);\n}\nfunction getStudyInstanceUIDFromUri(uri) {\n  var uid = findSubstring(uri, 'studies/', '/series');\n  if (!uid) {\n    uid = findSubstring(uri, 'studies/');\n  }\n  if (!uid) {\n    console.debug(\"Study Instance UID could not be dertermined from URI \\\"\".concat(uri, \"\\\"\"));\n  }\n  return uid;\n}\nfunction getSeriesInstanceUIDFromUri(uri) {\n  var uid = findSubstring(uri, 'series/', '/instances');\n  if (!uid) {\n    uid = findSubstring(uri, 'series/');\n  }\n  if (!uid) {\n    console.debug(\"Series Instance UID could not be dertermined from URI \\\"\".concat(uri, \"\\\"\"));\n  }\n  return uid;\n}\nfunction getSOPInstanceUIDFromUri(uri) {\n  var uid = findSubstring(uri, '/instances/', '/frames');\n  if (!uid) {\n    uid = findSubstring(uri, '/instances/', '/metadata');\n  }\n  if (!uid) {\n    uid = findSubstring(uri, '/instances/');\n  }\n  if (!uid) {\n    console.debug(\"SOP Instance UID could not be dertermined from URI\\\"\".concat(uri, \"\\\"\"));\n  }\n  return uid;\n}\nfunction getFrameNumbersFromUri(uri) {\n  var numbers = findSubstring(uri, '/frames/', '/rendered');\n  if (!numbers) {\n    numbers = findSubstring(uri, '/frames/');\n  }\n  if (numbers === undefined) {\n    console.debug(\"Frame Numbers could not be dertermined from URI\\\"\".concat(uri, \"\\\"\"));\n  }\n  return numbers.split(',');\n}\n\nvar version = '0.5.2';\n\nvar api = {\n  DICOMwebClient: DICOMwebClient\n};\nvar utils = {\n  getStudyInstanceUIDFromUri: getStudyInstanceUIDFromUri,\n  getSeriesInstanceUIDFromUri: getSeriesInstanceUIDFromUri,\n  getSOPInstanceUIDFromUri: getSOPInstanceUIDFromUri,\n  getFrameNumbersFromUri: getFrameNumbersFromUri\n};\n\nexport { api, utils, version };\n//# sourceMappingURL=dicomweb-client.es.js.map\n"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","arg","key","input","hint","prim","toPrimitive","undefined","res","call","TypeError","String","Number","_toPrimitive","_toConsumableArray","arr","Array","isArray","_arrayLikeToArray","_arrayWithoutHoles","iter","from","_iterableToArray","o","minLen","n","toString","slice","name","test","_unsupportedIterableToArray","_nonIterableSpread","len","arr2","stringToUint8Array","str","Uint8Array","j","charCodeAt","containsToken","message","token","offset","arguments","index","findToken","maxSearchLength","searchLength","Math","min","multipartEncode","datasets","boundary","s4","floor","random","substring","concat","guid","contentTypeString","header","footer","headerArray","footerArray","headerLength","footerLength","contentArrays","map","datasetBuffer","contentArray","contentLength","multipartArray","set","position","forEach","data","buffer","multipartDecode","response","ArrayBuffer","isView","separator","headerIndex","Error","itemLimit","fromCharCode","uint8ArrayToString","boundaryString","parts","split","substr","identifyBoundary","boundaryIndex","boundaryLength","components","headerTokenIndex","push","isObject","isEmptyObject","keys","getFirstResult","result","MEDIATYPES","DICOM","DICOM_JSON","OCTET_STREAM","PDF","JPEG","PNG","debugLog","api","DICOMwebClient","options","instance","Constructor","_classCallCheck","this","baseURL","url","console","error","username","password","qidoURLPrefix","qidoURL","wadoURLPrefix","wadoURL","stowURLPrefix","stowURL","singlepart","requestHooks","headers","errorInterceptor","verbose","setDebug","debug","protoProps","staticProps","value","debugLevel","debugLogFunction","log","method","_this","Promise","resolve","reject","request","XMLHttpRequest","open","responseType","setRequestHeader","functions","userHeaders","onloadstart","onloadend","onreadystatechange","readyState","status","contentType","getResponseHeader","indexOf","warn","progressCallback","onprogress","isValid","every","requestHook","areValidRequestHooks","combinedHeaders","assign","metadata","pipedRequest","args","reduce","fn","withCredentials","send","_httpRequest","params","urlWithQueryParams","_parseQueryParameters","Accept","_httpGet","mediaTypes","_buildAcceptHeaderFieldValue","byteRange","supportedMediaTypes","Range","_buildRangeHeaderFieldValue","_buildMultipartAcceptHeaderFieldValue","defaultMediaType","acceptableMediaTypes","mediaType","values","_httpPost","queryParams","_httpGetApplicationJson","studyInstanceUID","seriesInstanceUID","transferSyntax","sopInstanceUID","paramString","join","frameNumbers","_httpGetMultipartApplicationOctetStream","_getSharedMediaTypes","commonMediaType","_getCommonMediaType","startsWith","_httpGetMultipartImage","_httpGetMultipartVideo","_httpGetImage","_httpGetVideo","_httpGetText","_httpGetApplicationPdf","_options$withCredenti","_options$progressCall","_httpGetMultipartApplicationDicom","then","_options$withCredenti2","_options$progressCall2","BulkDataURI","_options$withCredenti3","_options$progressCall3","e","_multipartEncode","_options$withCredenti4","queryString","encodeURIComponent","sepIndex","mediaTypeType","includes","_assertMediaTypeIsValid","item","_this2","fieldValueParts","transferSyntaxUID","fieldValue","flat","endsWith","expectedMediaTypes","actualType","_parseMediaType","expectedMediaType","expectedType","JSON","stringify","types","Set","type","add","sharedMediaTypes"],"sourceRoot":""}