{"version":3,"file":"507.bundle.27dc79d90215b38f09b4.js","mappings":"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","sources":["webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/base/AnnotationTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/displayTools/Labelmap/labelmapConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/annotationFrameRange.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/annotationHydration.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/boundingBox/extend2DBoundingBoxInViewAxis.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/boundingBox/getBoundingBoxAroundShape.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/calibrateImageSpacing.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/cine/events.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/cine/state.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/cine/playClip.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/clip.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/addContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/areSameSegment.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/isContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/removeContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/calculatePerimeter.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/findHandlePolylineIndex.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/areCoplanarContours.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/contourFinder.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/getDeduplicatedVTKPolyDataPoints.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/detectContourHoles.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/generateContourSetsFromLabelmap.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/AnnotationToPointData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/getContourHolesDataWorld.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/getContourHolesDataCanvas.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/interpolation/acceptAutogeneratedInterpolations.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/updateContourPolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/debounce.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/drawing/getTextBoxCoordsCanvas.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/dynamicVolume/getDataInTime.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/dynamicVolume/generateImageFromTimeData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getAnnotationNearPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getCalibratedUnits.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getSphereBoundsInfo.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getViewportForAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/isObject.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/aabb/intersectAABB.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/aabb/distanceToPointSquared.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/aabb/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/basic/Calculator.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/basic/BasicStatsCalculator.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/ellipse/pointInEllipse.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/ellipse/getCanvasEllipseCorners.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/distanceToPointSquaredInfo.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/distanceToPointSquared.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/intersectLine.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/isPointOnLineSegment.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/point/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/point/distanceToPointSquared.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/point/mirror.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/isClosed.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/containsPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/containsPoints.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getArea.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getSignedArea.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getWindingDirection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getNormal3.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getNormal2.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/areLineSegmentsIntersecting.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getLineSegmentIntersectionsIndexes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getLinesIntersection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/combinePolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getFirstLineSegmentIntersectionIndexes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/intersectPolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/decimate.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getLineSegmentIntersectionsCoordinates.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getClosestLineSegmentIntersection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getSubPixelSpacingAndXYDirections.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/pointsAreWithinCloseContourProximity.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/addCanvasPointsToArray.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/pointCanProjectOnLine.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/projectTo2D.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/isPointInsidePolyline3D.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/rectangle/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/sphere/pointInSphere.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/vec2/liangBarksyClip.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/orientation/getOrientationStringLPS.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/orientation/invertOrientationStringLPS.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/planar/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/planarFreehandROITool/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/pointInShapeCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/pointInSurroundingSphereCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/pointToString.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/polyData/utils.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/rectangleROITool/getBoundsIJKFromRectangleAnnotations.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/rectangleROITool/isAxisAlignedRectangle.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/scroll.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/InterpolationManager/InterpolationManager.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/brushReplaceForToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/brushSizeForToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/brushThresholdForToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/isLineInSegment.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/findLargestBidirectional.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/contourAndFindLargestBidirectional.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/createBidirectionalToolData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/createImageIdReferenceMap.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/createLabelmapVolumeForViewport.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/createMergedLabelmapForIndex.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/floodFill.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getDefaultRepresentationConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getHoveredContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getSegmentAtLabelmapBorder.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getSegmentAtWorldPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/invalidateBrushCursor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/isValidRepresentationConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/rectangleROIThresholdVolumeByRange.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/segmentContourAction.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/thresholdSegmentationByRange.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/thresholdVolumeByRange.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/utilities.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/stackPrefetch/stackPrefetch.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/stackPrefetch/stackContextPrefetch.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/throttle.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/touch/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/triggerAnnotationRenderForToolGroupIds.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewport/isViewportPreScaled.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewport/jumpToSlice.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewport/jumpToWorld.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/filterViewportsWithFrameOfReferenceUID.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/filterViewportsWithToolEnabled.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/filterViewportsWithParallelNormals.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/getViewportIdsWithToolToRender.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/common/isRangeValid.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/common/isColorbarSizeValid.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/common/areColorbarRangesEqual.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/common/areColorbarSizesEqual.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/vec3/interpolateVec3.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/ColorbarCanvas.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/ColorbarTicks.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/widgets/Widget.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/Colorbar.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/common/isRangeTextPositionValid.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/ViewportColorbar.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getVOIMultipliers.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/windowlevel/getLuminanceFromRegion.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/windowlevel/calculateMinMaxMean.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/windowlevel/extractWindowLevelRegionToolData.ts","webpack:///../../../node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares.js"],"sourcesContent":["import {\n  BaseVolumeViewport,\n  cache,\n  getEnabledElement,\n  metaData,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec2 } from 'gl-matrix';\n\nimport AnnotationDisplayTool from './AnnotationDisplayTool';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  Annotation,\n  Annotations,\n  EventTypes,\n  ToolHandle,\n  InteractionTypes,\n  ToolProps,\n  PublicToolProps,\n} from '../../types';\nimport { addAnnotation } from '../../stateManagement/annotation/annotationState';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\n\n/**\n * Abstract class for tools which create and display annotations on the\n * cornerstone3D canvas. In addition, it provides a base class for segmentation\n * tools that require drawing an annotation before running the segmentation strategy\n * for instance threshold segmentation based on an area and a threshold.\n * Annotation tools make use of drawing utilities to draw SVG elements on the viewport.\n *\n * To create a new annotation tool, derive from this class and implement the\n * abstract methods.\n */\nabstract class AnnotationTool extends AnnotationDisplayTool {\n  /**\n   * Creates a base annotation object, adding in any annotation base data provided\n   */\n  public static createAnnotation(...annotationBaseData): Annotation {\n    let annotation: Annotation = {\n      annotationUID: null as string,\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.toolName,\n      },\n      data: {\n        text: '',\n        handles: {\n          points: new Array<Types.Point3>(),\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n      },\n    } as unknown as Annotation;\n    for (const baseData of annotationBaseData) {\n      annotation = csUtils.deepMerge(annotation, baseData);\n    }\n    return annotation;\n  }\n\n  /**\n   * Creates a new annotation for the given viewport.  This just adds the\n   * viewport reference data to the metadata, and otherwise returns the\n   * static class createAnnotation data.\n   */\n  public static createAnnotationForViewport(viewport, ...annotationBaseData) {\n    return this.createAnnotation(\n      { metadata: viewport.getViewReference() },\n      ...annotationBaseData\n    );\n  }\n\n  /**\n   * Creates and adds an annotation of the given type, firing the annotation\n   * modified event on the new annotation.\n   * This implicitly uses the static class when you call it on the correct\n   * base class.  For example, you can call the KeyImageTool.createAnnotation\n   * method on KeyImageTool.toolName by calling KeyImageTool.createAndAddAnnotation\n   *\n   */\n  public static createAndAddAnnotation(viewport, ...annotationBaseData) {\n    const annotation = this.createAnnotationForViewport(\n      viewport,\n      ...annotationBaseData\n    );\n    addAnnotation(annotation, viewport.element);\n    triggerAnnotationModified(annotation, viewport.element);\n  }\n\n  static toolName;\n  // ===================================================================\n  // Abstract Methods - Must be implemented.\n  // ===================================================================\n\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\n    super(toolProps, defaultToolProps);\n\n    if (toolProps.configuration?.getTextLines) {\n      this.configuration.getTextLines = toolProps.configuration.getTextLines;\n    }\n\n    if (toolProps.configuration?.statsCalculator) {\n      this.configuration.statsCalculator =\n        toolProps.configuration.statsCalculator;\n    }\n  }\n\n  /**\n   * @abstract addNewAnnotation Creates a new annotation based on the clicked mouse position\n   *\n   * @param evt - The normalized mouse event\n   * @param interactionType -  The interaction type used to add the annotation.\n   */\n  abstract addNewAnnotation(\n    evt: EventTypes.InteractionEventType,\n    interactionType: InteractionTypes\n  ): Annotation;\n\n  /**\n   * @abstract cancel Used to cancel the ongoing tool drawing and manipulation\n   *\n   */\n  abstract cancel(element: HTMLDivElement);\n\n  /**\n   * handleSelectedCallback Custom callback for when a handle is selected.\n   *\n   * @param evt - The normalized mouse event\n   * @param annotation - The annotation selected.\n   * @param handle - The selected handle (either Types.Point3 in space for annotations, or TextBoxHandle object for text boxes).\n   * @param interactionType - The interaction type the handle was selected with.\n   */\n  abstract handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    handle: ToolHandle,\n    interactionType: InteractionTypes\n  ): void;\n\n  /**\n   * Custom callback for when an annotation is selected\n   *\n   * @param evt - The normalized mouse event\n   * @param annotation - The `Annotation` to check.\n   * @param interactionType - The interaction type used to select the tool.\n   */\n  abstract toolSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    interactionType: InteractionTypes,\n    canvasCoords?: Types.Point2\n  ): void;\n\n  /**\n   * Returns true if the provided canvas coordinate tool is near the annotation\n   *\n   * @param element - The HTML element\n   * @param annotation - The annotation to check\n   * @param canvasCoords - The canvas coordinate to check\n   * @param proximity - The minimum proximity to consider the point near\n   * @param interactionType - The interaction type used to select the tool.\n   *\n   * @returns boolean if the point is near.\n   */\n  abstract isPointNearTool(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number,\n    interactionType: string\n  ): boolean;\n\n  /**\n   * @virtual Event handler for Cornerstone MOUSE_MOVE event.\n   *\n   *\n   * @param evt - The normalized mouse event\n   * @param filteredAnnotations - The annotations to check for hover interactions\n   * @returns True if the annotation needs to be re-drawn by the annotationRenderingEngine.\n   */\n  public mouseMoveCallback = (\n    evt: EventTypes.MouseMoveEventType,\n    filteredAnnotations?: Annotations\n  ): boolean => {\n    if (!filteredAnnotations) {\n      return false;\n    }\n\n    const { element, currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n    let annotationsNeedToBeRedrawn = false;\n\n    for (const annotation of filteredAnnotations) {\n      // Do not do anything if the annotation is locked or hidden.\n      if (\n        isAnnotationLocked(annotation) ||\n        !isAnnotationVisible(annotation.annotationUID)\n      ) {\n        continue;\n      }\n\n      const { data } = annotation;\n      const activateHandleIndex = data.handles\n        ? data.handles.activeHandleIndex\n        : undefined;\n\n      // Perform tool specific imagePointNearToolOrHandle to determine if the mouse\n      // is near the tool or its handles or its textBox.\n      const near = this._imagePointNearToolOrHandle(\n        element,\n        annotation,\n        canvasCoords,\n        6 // Todo: This should come from the state\n      );\n\n      const nearToolAndNotMarkedActive = near && !annotation.highlighted;\n      const notNearToolAndMarkedActive = !near && annotation.highlighted;\n      if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n        annotation.highlighted = !annotation.highlighted;\n        annotationsNeedToBeRedrawn = true;\n      } else if (\n        data.handles &&\n        data.handles.activeHandleIndex !== activateHandleIndex\n      ) {\n        // Active handle index has changed, re-render.\n        annotationsNeedToBeRedrawn = true;\n      }\n    }\n\n    return annotationsNeedToBeRedrawn;\n  };\n\n  /**\n   * It checks if the mouse click is near TextBoxHandle or AnnotationHandle itself, and\n   * return either it. It prioritize TextBoxHandle over AnnotationHandle. If\n   * the mouse click is not near any of the handles, it does not return anything.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { isCanvasAnnotation } = data;\n    const { points, textBox } = data.handles;\n\n    if (textBox) {\n      const { worldBoundingBox } = textBox;\n      if (worldBoundingBox) {\n        const canvasBoundingBox = {\n          topLeft: viewport.worldToCanvas(worldBoundingBox.topLeft),\n          topRight: viewport.worldToCanvas(worldBoundingBox.topRight),\n          bottomLeft: viewport.worldToCanvas(worldBoundingBox.bottomLeft),\n          bottomRight: viewport.worldToCanvas(worldBoundingBox.bottomRight),\n        };\n\n        if (\n          canvasCoords[0] >= canvasBoundingBox.topLeft[0] &&\n          canvasCoords[0] <= canvasBoundingBox.bottomRight[0] &&\n          canvasCoords[1] >= canvasBoundingBox.topLeft[1] &&\n          canvasCoords[1] <= canvasBoundingBox.bottomRight[1]\n        ) {\n          data.handles.activeHandleIndex = null;\n          return textBox as ToolHandle;\n        }\n      }\n    }\n\n    for (let i = 0; i < points?.length; i++) {\n      const point = points[i];\n      const annotationCanvasCoordinate = isCanvasAnnotation\n        ? point.slice(0, 2)\n        : viewport.worldToCanvas(point);\n\n      const near =\n        vec2.distance(\n          canvasCoords,\n          annotationCanvasCoordinate as Types.Point2\n        ) < proximity;\n\n      if (near === true) {\n        data.handles.activeHandleIndex = i;\n        return point;\n      }\n    }\n\n    data.handles.activeHandleIndex = null;\n  }\n\n  /**\n   * It returns the style for the text box\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met (hierarchy is checked from most specific to least specific which is\n   * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n   * @param annotation - The annotation for the tool that is\n   * currently active.\n   * @returns An object of the style settings for the text box.\n   */\n  public getLinkedTextBoxStyle(\n    specifications: StyleSpecifier,\n    annotation?: Annotation\n  ): Record<string, unknown> {\n    // Todo: this function can be used to set different styles for different toolMode\n    // for the textBox.\n\n    return {\n      visibility: this.getStyle(\n        'textBoxVisibility',\n        specifications,\n        annotation\n      ),\n      fontFamily: this.getStyle(\n        'textBoxFontFamily',\n        specifications,\n        annotation\n      ),\n      fontSize: this.getStyle('textBoxFontSize', specifications, annotation),\n      color: this.getStyle('textBoxColor', specifications, annotation),\n      shadow: this.getStyle('textBoxShadow', specifications, annotation),\n      background: this.getStyle(\n        'textBoxBackground',\n        specifications,\n        annotation\n      ),\n      lineWidth: this.getStyle(\n        'textBoxLinkLineWidth',\n        specifications,\n        annotation\n      ),\n      lineDash: this.getStyle(\n        'textBoxLinkLineDash',\n        specifications,\n        annotation\n      ),\n    };\n  }\n\n  /**\n   * Returns true if the viewport is scaled to SUV units\n   * @param viewport - The viewport\n   * @param targetId - The annotation targetId\n   * @param imageId - The annotation imageId\n   * @returns\n   */\n  isSuvScaled(\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    targetId: string,\n    imageId?: string\n  ): boolean {\n    if (viewport instanceof BaseVolumeViewport) {\n      const volumeId = csUtils.getVolumeId(targetId);\n      const volume = cache.getVolume(volumeId);\n      return volume?.scaling?.PT !== undefined;\n    }\n    const scalingModule: Types.ScalingParameters | undefined =\n      imageId && metaData.get('scalingModule', imageId);\n    return typeof scalingModule?.suvbw === 'number';\n  }\n\n  /**\n   * Get the style that will be applied to all annotations such as length, cobb\n   * angle, arrow annotate, etc. when rendered on a canvas or svg layer\n   */\n  protected getAnnotationStyle(context: {\n    annotation: Annotation;\n    styleSpecifier: StyleSpecifier;\n  }) {\n    const { annotation, styleSpecifier } = context;\n    const getStyle = (property) =>\n      this.getStyle(property, styleSpecifier, annotation);\n    const { annotationUID } = annotation;\n    const visibility = isAnnotationVisible(annotationUID);\n    const locked = isAnnotationLocked(annotation);\n\n    const lineWidth = getStyle('lineWidth') as number;\n    const lineDash = getStyle('lineDash') as string;\n    const color = getStyle('color') as string;\n    const shadow = getStyle('shadow') as boolean;\n    const textboxStyle = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n\n    return {\n      visibility,\n      locked,\n      color,\n      lineWidth,\n      lineDash,\n      lineOpacity: 1,\n      fillColor: color,\n      fillOpacity: 0,\n      shadow,\n      textbox: textboxStyle,\n    };\n  }\n\n  /**\n   * Returns true if the `canvasCoords` are near a handle or selectable part of the tool\n   *\n   * @param element - The HTML element\n   * @param annotation - The annotation to check\n   * @param canvasCoords - The canvas coordinates to check\n   * @param proximity - The proximity to consider\n   *\n   * @returns If the point is near.\n   */\n  private _imagePointNearToolOrHandle(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean {\n    // Based on the tool instance type, check if the point is near the tool handles\n    const handleNearImagePoint = this.getHandleNearImagePoint(\n      element,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (handleNearImagePoint) {\n      return true;\n    }\n\n    // If the point is not near the handles, check if the point is near the tool\n    const toolNewImagePoint = this.isPointNearTool(\n      element,\n      annotation,\n      canvasCoords,\n      proximity,\n      'mouse'\n    );\n\n    if (toolNewImagePoint) {\n      return true;\n    }\n  }\n}\n\nAnnotationTool.toolName = 'AnnotationTool';\nexport default AnnotationTool;\n","import { LabelmapConfig } from '../../../types/LabelmapTypes';\n\nconst defaultLabelmapConfig: LabelmapConfig = {\n  renderOutline: true,\n  outlineWidthActive: 3,\n  outlineWidthInactive: 2,\n  activeSegmentOutlineWidthDelta: 0,\n  renderFill: true,\n  renderFillInactive: true,\n  fillAlpha: 0.7,\n  fillAlphaInactive: 0.65,\n  outlineOpacity: 1,\n  outlineOpacityInactive: 0.85,\n};\n\nfunction getDefaultLabelmapConfig(): LabelmapConfig {\n  return defaultLabelmapConfig;\n}\n\n// Checks if the labelmap config is valid, which means\n// if all the required fields are present and have the correct type\nfunction isValidLabelmapConfig(config): boolean {\n  return (\n    config &&\n    typeof config.renderOutline === 'boolean' &&\n    typeof config.outlineWidthActive === 'number' &&\n    typeof config.outlineWidthInactive === 'number' &&\n    typeof config.activeSegmentOutlineWidthDelta === 'number' &&\n    typeof config.renderFill === 'boolean' &&\n    typeof config.renderFillInactive === 'boolean' &&\n    typeof config.fillAlpha === 'number' &&\n    typeof config.fillAlphaInactive === 'number' &&\n    typeof config.outlineOpacity === 'number' &&\n    typeof config.outlineOpacityInactive === 'number'\n  );\n}\n\nexport default getDefaultLabelmapConfig;\nexport { isValidLabelmapConfig };\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport Events from '../enums/Events';\nimport { Annotation } from '../types';\n\nexport type FramesRange = [number, number] | number;\n\n/**\n * This class handles the annotation frame range values for multiframes.\n * Mostly used for the Video viewport, it allows references to\n * a range of frame values.\n */\nexport default class AnnotationFrameRange {\n  protected static frameRangeExtractor =\n    /(\\/frames\\/|[&?]frameNumber=)([^/&?]*)/i;\n\n  protected static imageIdToFrames(imageId: string): FramesRange {\n    const match = imageId.match(this.frameRangeExtractor);\n    if (!match || !match[2]) {\n      return null;\n    }\n    const range = match[2].split('-').map((it) => Number(it));\n    if (range.length === 1) {\n      return range[0];\n    }\n    return range as FramesRange;\n  }\n\n  public static framesToString(range) {\n    if (Array.isArray(range)) {\n      return `${range[0]}-${range[1]}`;\n    }\n    return String(range);\n  }\n\n  protected static framesToImageId(\n    imageId: string,\n    range: FramesRange | string\n  ): string {\n    const match = imageId.match(this.frameRangeExtractor);\n    if (!match || !match[2]) {\n      return null;\n    }\n    const newRangeString = this.framesToString(range);\n    return imageId.replace(\n      this.frameRangeExtractor,\n      `${match[1]}${newRangeString}`\n    );\n  }\n\n  /**\n   * Sets the range of frames to associate with the given annotation.\n   * The range can be a single frame number (1 based according to DICOM),\n   * or a range of values in the format `min-max` where min, max are inclusive\n   * Modifies the referencedImageID to specify the updated URL.\n   */\n  public static setFrameRange(\n    annotation: Annotation,\n    range: FramesRange | string,\n    eventBase?: { viewportId; renderingEngineId }\n  ) {\n    const { referencedImageId } = annotation.metadata;\n    annotation.metadata.referencedImageId = this.framesToImageId(\n      referencedImageId,\n      range\n    );\n    const eventDetail = {\n      ...eventBase,\n      annotation,\n    };\n    triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);\n  }\n\n  public static getFrameRange(\n    annotation: Annotation\n  ): number | [number, number] {\n    return this.imageIdToFrames(annotation.metadata.referencedImageId);\n  }\n}\n","import {\n  Types,\n  utilities,\n  BaseVolumeViewport,\n  StackViewport,\n  cache,\n  metaData,\n} from '@cornerstonejs/core';\nimport { Annotation } from '../types';\nimport { addAnnotation } from '../stateManagement';\nimport { vec3 } from 'gl-matrix';\n\nfunction annotationHydration(\n  viewport: Types.IViewport,\n  toolName: string,\n  worldPoints: Types.Point3[],\n  options?: {\n    FrameOfReferenceUID?: string;\n    annotationUID?: string;\n  }\n): Annotation {\n  const viewReference = viewport.getViewReference();\n  const { viewPlaneNormal, FrameOfReferenceUID } = viewReference;\n  const annotation = {\n    annotationUID: options?.annotationUID || utilities.uuidv4(),\n    data: {\n      handles: {\n        points: worldPoints,\n      },\n    },\n    highlighted: false,\n    autoGenerated: false,\n    invalidated: false,\n    isLocked: false,\n    isVisible: true,\n    metadata: {\n      toolName,\n      viewPlaneNormal,\n      FrameOfReferenceUID,\n      referencedImageId: getReferencedImageId(\n        viewport,\n        worldPoints[0],\n        viewPlaneNormal\n      ),\n      ...options,\n    },\n  };\n  addAnnotation(annotation, viewport.element);\n  return annotation;\n}\n\nfunction getReferencedImageId(\n  viewport: Types.IViewport,\n  worldPos: Types.Point3,\n  viewPlaneNormal: Types.Point3\n): string {\n  let referencedImageId;\n\n  if (viewport instanceof StackViewport) {\n    referencedImageId = getClosestImageIdForStackViewport(\n      viewport,\n      worldPos,\n      viewPlaneNormal\n    );\n  } else if (viewport instanceof BaseVolumeViewport) {\n    const targetId = getTargetId(viewport);\n    const volumeId = utilities.getVolumeId(targetId);\n    const imageVolume = cache.getVolume(volumeId);\n\n    referencedImageId = utilities.getClosestImageId(\n      imageVolume,\n      worldPos,\n      viewPlaneNormal\n    );\n  } else {\n    throw new Error(\n      'getReferencedImageId: viewport must be a StackViewport or BaseVolumeViewport'\n    );\n  }\n\n  return referencedImageId;\n}\n\nfunction getTargetId(viewport: Types.IViewport): string | undefined {\n  const targetId = viewport.getReferenceId?.();\n  if (targetId) {\n    return targetId;\n  }\n  if (viewport instanceof BaseVolumeViewport) {\n    return `volumeId:${getTargetVolumeId(viewport)}`;\n  }\n  throw new Error('getTargetId: viewport must have a getTargetId method');\n}\n\nfunction getTargetVolumeId(viewport: Types.IViewport): string | undefined {\n  const actorEntries = viewport.getActors();\n\n  if (!actorEntries) {\n    return;\n  }\n  return actorEntries.find(\n    (actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume'\n  )?.uid;\n}\n\nfunction getClosestImageIdForStackViewport(\n  viewport: StackViewport,\n  worldPos: Types.Point3,\n  viewPlaneNormal: Types.Point3\n): string {\n  const imageIds = viewport.getImageIds();\n  if (!imageIds || !imageIds.length) {\n    return;\n  }\n\n  const distanceImagePairs = imageIds.map((imageId) => {\n    const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n    const distance = calculateDistanceToImage(\n      worldPos,\n      imagePositionPatient,\n      viewPlaneNormal\n    );\n    return { imageId, distance };\n  });\n\n  distanceImagePairs.sort((a, b) => a.distance - b.distance);\n\n  return distanceImagePairs[0].imageId;\n}\n\nfunction calculateDistanceToImage(\n  worldPos: Types.Point3,\n  ImagePositionPatient: Types.Point3,\n  viewPlaneNormal: Types.Point3\n): number {\n  const dir = vec3.create();\n  vec3.sub(dir, worldPos, ImagePositionPatient);\n\n  const dot = vec3.dot(dir, viewPlaneNormal);\n\n  return Math.abs(dot);\n}\nexport { annotationHydration, getClosestImageIdForStackViewport };\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Uses the current bounds of the 2D rectangle and extends it in the view axis by numSlices\n * It compares min and max of each IJK to find the view axis (for axial, zMin === zMax) and\n * then calculates the extended range. It will assume the slice is relative to the\n * current slice and will add the given slices to the current max of the boundingBox.\n * @param boundsIJK - [[iMin, iMax], [jMin, jMax], [kMin, kMax]]\n * @param slices - number of slices to project before and after\n * @returns extended bounds\n */\nfunction extend2DBoundingBoxInViewAxis(\n  boundsIJK: [Types.Point2, Types.Point2, Types.Point2],\n  numSlicesToProject: number\n): [Types.Point2, Types.Point2, Types.Point2] {\n  // find which index in boundsIJK has the same first and last value\n  const sliceNormalIndex = boundsIJK.findIndex(([min, max]) => min === max);\n\n  if (sliceNormalIndex === -1) {\n    throw new Error('3D bounding boxes not supported in an oblique plane');\n  }\n\n  // get the index and subtract slices from the min and add to the max\n  boundsIJK[sliceNormalIndex][0] -= numSlicesToProject;\n  boundsIJK[sliceNormalIndex][1] += numSlicesToProject;\n  return boundsIJK;\n}\n\nexport default extend2DBoundingBoxInViewAxis;\n","import type { Types } from '@cornerstonejs/core';\nimport { CONSTANTS } from '@cornerstonejs/core';\n\nconst { EPSILON } = CONSTANTS;\n\n/** Bounding box type */\ntype BoundingBox =\n  | [Types.Point2, Types.Point2, null]\n  | [Types.Point2, Types.Point2, Types.Point2];\n\nfunction calculateBoundingBox(\n  points,\n  dimensions,\n  isWorld = false\n): BoundingBox {\n  let xMin = Infinity;\n  let xMax = isWorld ? -Infinity : 0;\n  let yMin = Infinity;\n  let yMax = isWorld ? -Infinity : 0;\n  let zMin = Infinity;\n  let zMax = isWorld ? -Infinity : 0;\n\n  const is3D = points[0]?.length === 3;\n\n  // use for loop for performance\n  for (let i = 0; i < points.length; i++) {\n    const p = points[i];\n    xMin = Math.min(p[0], xMin);\n    xMax = Math.max(p[0], xMax);\n    yMin = Math.min(p[1], yMin);\n    yMax = Math.max(p[1], yMax);\n\n    if (is3D) {\n      zMin = Math.min(p[2] ?? zMin, zMin);\n      zMax = Math.max(p[2] ?? zMax, zMax);\n    }\n  }\n\n  if (dimensions) {\n    xMin = Math.max(isWorld ? dimensions[0] + EPSILON : 0, xMin);\n    xMax = Math.min(\n      isWorld ? dimensions[0] - EPSILON : dimensions[0] - 1,\n      xMax\n    );\n    yMin = Math.max(isWorld ? dimensions[1] + EPSILON : 0, yMin);\n    yMax = Math.min(\n      isWorld ? dimensions[1] - EPSILON : dimensions[1] - 1,\n      yMax\n    );\n\n    if (is3D && dimensions.length === 3) {\n      zMin = Math.max(isWorld ? dimensions[2] + EPSILON : 0, zMin);\n      zMax = Math.min(\n        isWorld ? dimensions[2] - EPSILON : dimensions[2] - 1,\n        zMax\n      );\n    }\n  } else if (!isWorld) {\n    // still need to bound to 0 and Infinity if no dimensions are provided for ijk\n    xMin = Math.max(0, xMin);\n    xMax = Math.min(Infinity, xMax);\n    yMin = Math.max(0, yMin);\n    yMax = Math.min(Infinity, yMax);\n\n    if (is3D) {\n      zMin = Math.max(0, zMin);\n      zMax = Math.min(Infinity, zMax);\n    }\n  }\n\n  return is3D\n    ? [\n        [xMin, xMax],\n        [yMin, yMax],\n        [zMin, zMax],\n      ]\n    : [[xMin, xMax], [yMin, yMax], null];\n}\n\n/**\n * With a given vertices (points) coordinates in 2D or 3D in IJK, it calculates the minimum and maximum\n * coordinate in each axis, and returns them. If clipBounds are provided it also\n * clip the min, max to the provided width, height and depth\n *\n * @param points - shape corner points coordinates either in IJK (image coordinate)\n * @param dimensions - bounds to clip the min, max\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\n */\nexport function getBoundingBoxAroundShapeIJK(\n  points: Types.Point2[] | Types.Point3[],\n  dimensions?: Types.Point2 | Types.Point3\n): BoundingBox {\n  return calculateBoundingBox(points, dimensions, false);\n}\n\n/**\n * With a given vertices (points) coordinates in 2D or 3D in World Coordinates, it calculates the minimum and maximum\n * coordinate in each axis, and returns them. If clipBounds are provided it also\n * clip the min, max to the provided width, height and depth\n *\n * @param points - shape corner points coordinates either in IJK (image coordinate)\n * @param clipBounds - bounds to clip the min, max\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\n */\nexport function getBoundingBoxAroundShapeWorld(\n  points: Types.Point2[] | Types.Point3[],\n  clipBounds?: Types.Point2 | Types.Point3\n): BoundingBox {\n  return calculateBoundingBox(points, clipBounds, true);\n}\n","import { utilities, Enums } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nconst { calibratedPixelSpacingMetadataProvider } = utilities;\n\n/**\n * It adds the provided spacing to the Cornerstone internal calibratedPixelSpacing\n * metadata provider, then it invalidates all the tools that have the imageId as\n * their reference imageIds. Finally, it triggers a re-render for invalidated annotations.\n * @param imageId - ImageId for the calibrated image\n * @param rowPixelSpacing - Spacing in row direction\n * @param calibrationOrScale - either the calibration object or a scale value\n */\nexport default function calibrateImageSpacing(\n  imageId: string,\n  renderingEngine: Types.IRenderingEngine,\n  calibrationOrScale: Types.IImageCalibration | number\n): void {\n  // Handle simple parameter version\n  if (typeof calibrationOrScale === 'number') {\n    calibrationOrScale = {\n      type: Enums.CalibrationTypes.USER,\n      scale: calibrationOrScale,\n    };\n  }\n  // 1. Add the calibratedPixelSpacing metadata to the metadata\n  calibratedPixelSpacingMetadataProvider.add(imageId, calibrationOrScale);\n\n  // 2. Update the actor for stackViewports\n  const viewports = renderingEngine.getStackViewports();\n\n  // 2.1 If imageId is already being used in a stackViewport -> update actor\n  viewports.forEach((viewport) => {\n    const imageIds = viewport.getImageIds();\n    if (imageIds.includes(imageId)) {\n      viewport.calibrateSpacing(imageId);\n    }\n  });\n\n  // 2.2 If imageId is cached but not being displayed in a viewport, stackViewport\n  // will handle using the calibratedPixelSpacing since it has been added\n  // to the provider\n}\n","/**\n * CINE Tool Events\n */\nenum Events {\n  CLIP_STOPPED = 'CORNERSTONE_CINE_TOOL_STOPPED',\n  CLIP_STARTED = 'CORNERSTONE_CINE_TOOL_STARTED',\n}\n\nexport default Events;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { CINETypes } from '../../types';\n\nconst state: Record<string, CINETypes.ToolData> = {};\n\nfunction addToolState(element: HTMLDivElement, data: CINETypes.ToolData): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  state[viewportId] = data;\n}\n\nfunction getToolState(element: HTMLDivElement): CINETypes.ToolData | undefined {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  return state[viewportId];\n}\n\nfunction getToolStateByViewportId(\n  viewportId: string\n): CINETypes.ToolData | undefined {\n  return state[viewportId];\n}\n\nexport { addToolState, getToolState, getToolStateByViewportId };\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport {\n  utilities as csUtils,\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  cache,\n  BaseVolumeViewport,\n  Enums,\n} from '@cornerstonejs/core';\n\nimport { Types } from '@cornerstonejs/core';\nimport CINE_EVENTS from './events';\nimport { addToolState, getToolState, getToolStateByViewportId } from './state';\nimport { CINETypes } from '../../types';\nimport scroll from '../scroll';\n\nconst { ViewportStatus } = Enums;\nconst { triggerEvent } = csUtils;\n\nconst debounced = true;\nconst dynamicVolumesPlayingMap = new Map();\n\n/**\n * Starts playing a clip or adjusts the frame rate of an already playing clip.  framesPerSecond is\n * optional and defaults to 30 if not specified.  A negative framesPerSecond will play the clip in reverse.\n * The element must be a stack of images\n * @param element - HTML Element\n * @param framesPerSecond - Number of frames per second\n */\nfunction playClip(\n  element: HTMLDivElement,\n  playClipOptions: CINETypes.PlayClipOptions\n): void {\n  let playClipTimeouts;\n  let playClipIsTimeVarying;\n\n  if (element === undefined) {\n    throw new Error('playClip: element must not be undefined');\n  }\n\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    throw new Error(\n      'playClip: element must be a valid Cornerstone enabled element'\n    );\n  }\n\n  if (!playClipOptions) {\n    playClipOptions = {};\n  }\n\n  // 4D Cine is enabled by default\n  playClipOptions.dynamicCineEnabled =\n    playClipOptions.dynamicCineEnabled ?? true;\n\n  const { viewport } = enabledElement;\n  const volume = _getVolumeFromViewport(viewport);\n  const playClipContext = _createCinePlayContext(viewport, playClipOptions);\n  let playClipData = getToolState(element);\n\n  const isDynamicCinePlaying =\n    playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume();\n\n  // If user is trying to play CINE for a 4D volume it first needs\n  // to stop CINE that has may be playing for any other viewport.\n  if (isDynamicCinePlaying) {\n    _stopDynamicVolumeCine(element);\n  }\n\n  if (!playClipData) {\n    playClipData = {\n      intervalId: undefined,\n      framesPerSecond: 30,\n      lastFrameTimeStamp: undefined,\n      ignoreFrameTimeVector: false,\n      usingFrameTimeVector: false,\n      frameTimeVector: playClipOptions.frameTimeVector ?? undefined,\n      speed: playClipOptions.frameTimeVectorSpeedMultiplier ?? 1,\n      reverse: playClipOptions.reverse ?? false,\n      loop: playClipOptions.loop ?? true,\n    };\n    addToolState(element, playClipData);\n  } else {\n    // Make sure the specified clip is not running before any property update.\n    // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\n    // prevent stopping a 4D CINE in case it is playing on another viewport.\n    _stopClip(element, {\n      stopDynamicCine: !isDynamicCinePlaying,\n      viewportId: viewport.id,\n    });\n  }\n\n  playClipData.dynamicCineEnabled = playClipOptions.dynamicCineEnabled;\n\n  // If a framesPerSecond is specified and is valid, update the playClipData now\n  if (\n    playClipOptions.framesPerSecond < 0 ||\n    playClipOptions.framesPerSecond > 0\n  ) {\n    playClipData.framesPerSecond = Number(playClipOptions.framesPerSecond);\n    playClipData.reverse = playClipData.framesPerSecond < 0;\n    // If framesPerSecond is given, frameTimeVector will be ignored...\n    playClipData.ignoreFrameTimeVector = true;\n  }\n\n  // Determine if frame time vector should be used instead of a fixed frame rate...\n  if (\n    playClipData.ignoreFrameTimeVector !== true &&\n    playClipData.frameTimeVector &&\n    playClipData.frameTimeVector.length === playClipContext.numScrollSteps &&\n    playClipContext.frameTimeVectorEnabled\n  ) {\n    const { timeouts, isTimeVarying } = _getPlayClipTimeouts(\n      playClipData.frameTimeVector,\n      playClipData.speed\n    );\n\n    playClipTimeouts = timeouts;\n    playClipIsTimeVarying = isTimeVarying;\n  }\n\n  // This function encapsulates the frame rendering logic...\n  const playClipAction = () => {\n    const { numScrollSteps, currentStepIndex } = playClipContext;\n    let newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);\n    const newStepIndexOutOfRange =\n      newStepIndex < 0 || newStepIndex >= numScrollSteps;\n\n    if (!playClipData.loop && newStepIndexOutOfRange) {\n      // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\n      // prevent stopping a 4D CINE in case it is playing on another viewport.\n      _stopClip(element, {\n        stopDynamicCine: !isDynamicCinePlaying,\n        viewportId: viewport.id,\n      });\n\n      const eventDetail = { element };\n\n      triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, eventDetail);\n      return;\n    }\n\n    // Loop around if newStepIndex is out of range\n    if (newStepIndex >= numScrollSteps) {\n      newStepIndex = 0;\n    } else if (newStepIndex < 0) {\n      newStepIndex = numScrollSteps - 1;\n    }\n\n    const delta = newStepIndex - currentStepIndex;\n\n    if (delta) {\n      playClipContext.scroll(delta);\n    }\n  };\n\n  if (isDynamicCinePlaying) {\n    dynamicVolumesPlayingMap.set(volume.volumeId, element);\n  }\n\n  // If playClipTimeouts array is available, not empty and its elements are NOT uniform ...\n  // ... (at least one timeout is different from the others), use alternate setTimeout implementation\n  if (\n    playClipTimeouts &&\n    playClipTimeouts.length > 0 &&\n    playClipIsTimeVarying\n  ) {\n    playClipData.usingFrameTimeVector = true;\n    playClipData.intervalId = window.setTimeout(\n      function playClipTimeoutHandler() {\n        playClipData.intervalId = window.setTimeout(\n          playClipTimeoutHandler,\n          playClipTimeouts[playClipContext.currentStepIndex]\n        );\n        playClipAction();\n      },\n      0\n    );\n  } else {\n    // ... otherwise user setInterval implementation which is much more efficient.\n    playClipData.usingFrameTimeVector = false;\n    playClipData.intervalId = window.setInterval(\n      playClipAction,\n      1000 / Math.abs(playClipData.framesPerSecond)\n    );\n  }\n\n  const eventDetail = {\n    element,\n  };\n\n  triggerEvent(element, CINE_EVENTS.CLIP_STARTED, eventDetail);\n}\n\n/**\n * Stops an already playing clip.\n * @param element - HTML Element\n */\nfunction stopClip(element: HTMLDivElement, options = {} as any): void {\n  _stopClip(element, {\n    stopDynamicCine: true,\n    ...options,\n  });\n}\n\nfunction _stopClip(\n  element: HTMLDivElement,\n  options = { stopDynamicCine: true, viewportId: undefined }\n) {\n  const { stopDynamicCine, viewportId } = options;\n  const enabledElement = getEnabledElement(element);\n\n  let toolState;\n  if (!enabledElement) {\n    if (viewportId) {\n      toolState = getToolStateByViewportId(viewportId);\n    } else {\n      return;\n    }\n  } else {\n    const { viewport } = enabledElement;\n    toolState = getToolState(viewport.element);\n  }\n\n  if (toolState) {\n    _stopClipWithData(toolState);\n  }\n\n  if (\n    stopDynamicCine &&\n    enabledElement?.viewport instanceof BaseVolumeViewport\n  ) {\n    _stopDynamicVolumeCine(element);\n  }\n}\n\n/**\n * [private] Stops any CINE playing for the dynamic volume loaded on this viewport\n * @param element - HTML Element\n */\nfunction _stopDynamicVolumeCine(element) {\n  const { viewport } = getEnabledElement(element);\n  const volume = _getVolumeFromViewport(viewport);\n\n  // If the current viewport has a 4D volume loaded it may be playing\n  // if it is also loaded on another viewport and user has started CINE\n  // for that one. This guarantees the other viewport will also be stopped.\n  if (volume?.isDynamicVolume()) {\n    const dynamicCineElement = dynamicVolumesPlayingMap.get(volume.volumeId);\n\n    dynamicVolumesPlayingMap.delete(volume.volumeId);\n\n    if (dynamicCineElement && dynamicCineElement !== element) {\n      stopClip(<HTMLDivElement>dynamicCineElement);\n    }\n  }\n}\n\n/**\n * [private] Turns a Frame Time Vector (0018,1065) array into a normalized array of timeouts. Each element\n * ... of the resulting array represents the amount of time each frame will remain on the screen.\n * @param vector - A Frame Time Vector (0018,1065) as specified in section C.7.6.5.1.2 of DICOM standard.\n * @param speed - A speed factor which will be applied to each element of the resulting array.\n * @returns An array with timeouts for each animation frame.\n */\nfunction _getPlayClipTimeouts(vector: number[], speed: number) {\n  let i;\n  let sample;\n  let delay;\n  let sum = 0;\n  const limit = vector.length;\n  const timeouts = [];\n\n  // Initialize time varying to false\n  let isTimeVarying = false;\n\n  if (typeof speed !== 'number' || speed <= 0) {\n    speed = 1;\n  }\n\n  // First element of a frame time vector must be discarded\n  for (i = 1; i < limit; i++) {\n    // eslint-disable-next-line no-bitwise\n    delay = (Number(vector[i]) / speed) | 0; // Integral part only\n    timeouts.push(delay);\n    if (i === 1) {\n      // Use first item as a sample for comparison\n      sample = delay;\n    } else if (delay !== sample) {\n      isTimeVarying = true;\n    }\n\n    sum += delay;\n  }\n\n  if (timeouts.length > 0) {\n    if (isTimeVarying) {\n      // If it's a time varying vector, make the last item an average...\n      // eslint-disable-next-line no-bitwise\n      delay = (sum / timeouts.length) | 0;\n    } else {\n      delay = timeouts[0];\n    }\n\n    timeouts.push(delay);\n  }\n\n  return { timeouts, isTimeVarying };\n}\n\n/**\n * [private] Performs the heavy lifting of stopping an ongoing animation.\n * @param element - HTML Element\n * @param playClipData - The data from playClip that needs to be stopped.\n */\nfunction _stopClipWithData(playClipData) {\n  const id = playClipData.intervalId;\n\n  if (typeof id !== 'undefined') {\n    playClipData.intervalId = undefined;\n    if (playClipData.usingFrameTimeVector) {\n      clearTimeout(id);\n    } else {\n      clearInterval(id);\n    }\n  }\n}\n\nfunction _getVolumesFromViewport(viewport): Types.IImageVolume[] {\n  return viewport\n    .getActors()\n    .map((actor) => cache.getVolume(actor.uid))\n    .filter((volume) => !!volume);\n}\n\nfunction _getVolumeFromViewport(viewport): Types.IImageVolume {\n  const volumes = _getVolumesFromViewport(viewport);\n  const dynamicVolume = volumes.find((volume) => volume.isDynamicVolume());\n\n  return dynamicVolume ?? volumes[0];\n}\n\nfunction _createStackViewportCinePlayContext(\n  viewport: StackViewport,\n  waitForRendered: number\n): CINETypes.CinePlayContext {\n  const imageIds = viewport.getImageIds();\n\n  return {\n    get numScrollSteps(): number {\n      return imageIds.length;\n    },\n    get currentStepIndex(): number {\n      return viewport.getTargetImageIdIndex();\n    },\n    get frameTimeVectorEnabled(): boolean {\n      // It is always in acquired orientation\n      return true;\n    },\n    waitForRenderedCount: 0,\n    scroll(delta: number): void {\n      if (\n        this.waitForRenderedCount <= waitForRendered &&\n        viewport.viewportStatus !== ViewportStatus.RENDERED\n      ) {\n        this.waitForRenderedCount++;\n        return;\n      }\n      this.waitForRenderedCount = 0;\n      scroll(viewport, { delta, debounceLoading: debounced });\n    },\n  };\n}\n\nfunction _createVolumeViewportCinePlayContext(\n  viewport: VolumeViewport,\n  volume: Types.IImageVolume\n): CINETypes.CinePlayContext {\n  const { volumeId } = volume;\n  const cachedScrollInfo = {\n    viewPlaneNormal: vec3.create(),\n    scrollInfo: null,\n  };\n\n  const getScrollInfo = () => {\n    const camera = viewport.getCamera();\n    const updateCache =\n      !cachedScrollInfo.scrollInfo ||\n      !vec3.equals(camera.viewPlaneNormal, cachedScrollInfo.viewPlaneNormal);\n\n    // Number of steps would change only after rotating the volume so it\n    // caches the result and recomputes only when necessary. Until it is\n    // rotated the current frame is updated locally\n    if (updateCache) {\n      const scrollInfo = csUtils.getVolumeViewportScrollInfo(\n        viewport,\n        volumeId\n      );\n\n      cachedScrollInfo.viewPlaneNormal = camera.viewPlaneNormal;\n      cachedScrollInfo.scrollInfo = scrollInfo;\n    }\n\n    return cachedScrollInfo.scrollInfo;\n  };\n\n  return {\n    get numScrollSteps(): number {\n      return getScrollInfo().numScrollSteps;\n    },\n    get currentStepIndex(): number {\n      return getScrollInfo().currentStepIndex;\n    },\n    get frameTimeVectorEnabled(): boolean {\n      const camera = viewport.getCamera();\n      const volumeViewPlaneNormal = volume.direction\n        .slice(6, 9)\n        .map((x) => -x) as Types.Point3;\n      const dot = vec3.dot(volumeViewPlaneNormal, camera.viewPlaneNormal);\n\n      // Check if the volume is in acquired orientation\n      // it may be flipped or rotated in plane\n      return glMatrix.equals(dot, 1);\n    },\n    scroll(delta: number): void {\n      getScrollInfo().currentStepIndex += delta;\n      scroll(viewport, { delta });\n    },\n  };\n}\n\nfunction _createDynamicVolumeViewportCinePlayContext(\n  volume: Types.IDynamicImageVolume\n): CINETypes.CinePlayContext {\n  return {\n    get numScrollSteps(): number {\n      return volume.numTimePoints;\n    },\n    get currentStepIndex(): number {\n      return volume.timePointIndex;\n    },\n    get frameTimeVectorEnabled(): boolean {\n      // Looping throught time does not uses frameTimeVector\n      return false;\n    },\n    scroll(delta: number): void {\n      // Updating this property (setter) makes it move to the desired time point\n      volume.timePointIndex += delta;\n    },\n  };\n}\n\nfunction _createCinePlayContext(\n  viewport,\n  playClipOptions: CINETypes.PlayClipOptions\n): CINETypes.CinePlayContext {\n  if (viewport instanceof StackViewport) {\n    return _createStackViewportCinePlayContext(\n      viewport,\n      playClipOptions.waitForRendered ?? 30\n    );\n  }\n\n  if (viewport instanceof VolumeViewport) {\n    const volume = _getVolumeFromViewport(viewport);\n\n    if (playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume()) {\n      return _createDynamicVolumeViewportCinePlayContext(\n        <Types.IDynamicImageVolume>volume\n      );\n    }\n\n    return _createVolumeViewportCinePlayContext(viewport, volume);\n  }\n\n  throw new Error('Unknown viewport type');\n}\n\nexport { playClip, stopClip };\n","/**\n * Clips a value to an upper and lower bound.\n * @export @public @method\n * @name clip\n *\n * @param  {number} val  The value to clip.\n * @param  {number} low  The lower bound.\n * @param  {number} high The upper bound.\n * @returns {number}      The clipped value.\n */\nexport function clip(val, low, high) {\n  return Math.min(Math.max(low, val), high);\n}\n\n/**\n * Clips a value within a box.\n * @export @public @method\n * @name clipToBox\n *\n * @param  {Object} point The point to clip\n * @param  {Object} box   The bounding box to clip to.\n * @returns {Object}       The clipped point.\n */\nexport function clipToBox(point, box) {\n  // Clip an {x, y} point to a box of size {width, height}\n  point.x = clip(point.x, 0, box.width);\n  point.y = clip(point.y, 0, box.height);\n}\n\nexport default clip;\n","import { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { ContourSegmentationAnnotation } from '../../types';\n\n/**\n * Adds a contour segmentation annotation to the specified segmentation.\n * @param annotation - The contour segmentation annotation to add.\n */\nexport function addContourSegmentationAnnotation(\n  annotation: ContourSegmentationAnnotation\n) {\n  if (annotation.parentAnnotationUID) {\n    // Don't add it for parent annotations - this happens during interpolation\n    return;\n  }\n  if (!annotation.data.segmentation) {\n    throw new Error(\n      'addContourSegmentationAnnotation: annotation does not have a segmentation data'\n    );\n  }\n\n  const { segmentationId, segmentIndex } = annotation.data.segmentation;\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation.representationData.CONTOUR) {\n    segmentation.representationData.CONTOUR = { annotationUIDsMap: new Map() };\n  }\n\n  const { annotationUIDsMap } = segmentation.representationData.CONTOUR;\n\n  let annotationsUIDsSet = annotationUIDsMap.get(segmentIndex);\n\n  if (!annotationsUIDsSet) {\n    annotationsUIDsSet = new Set();\n    annotationUIDsMap.set(segmentIndex, annotationsUIDsSet);\n  }\n\n  annotationUIDsMap.set(\n    segmentIndex,\n    annotationsUIDsSet.add(annotation.annotationUID)\n  );\n}\n","import { ContourSegmentationAnnotation } from '../../types/ContourSegmentationAnnotation';\n\n/**\n * Check if two contour segmentations are from same segmentId,\n * segmentationRepresentationUID and segmentIndex.\n * @param firstAnnotation - First annotation\n * @param secondAnnotation - Second annotation\n * @returns True if they are from same segmentId, segmentationRepresentationUID\n * and segmentIndex or false otherwise.\n */\nexport default function areSameSegment(\n  firstAnnotation: ContourSegmentationAnnotation,\n  secondAnnotation: ContourSegmentationAnnotation\n) {\n  const { segmentation: firstSegmentation } = firstAnnotation.data;\n  const { segmentation: secondSegmentation } = secondAnnotation.data;\n\n  return (\n    firstSegmentation.segmentationId === secondSegmentation.segmentationId &&\n    firstSegmentation.segmentIndex === secondSegmentation.segmentIndex\n  );\n}\n","import { Annotation } from '../../types';\nimport { ContourSegmentationAnnotation } from '../../types/ContourSegmentationAnnotation';\n\nexport default function isContourSegmentationAnnotation(\n  annotation: Annotation\n): annotation is ContourSegmentationAnnotation {\n  return !!(<ContourSegmentationAnnotation>annotation).data?.segmentation;\n}\n","import { state } from '../../stateManagement/segmentation';\nimport { ContourSegmentationAnnotation } from '../../types';\n\n/**\n * Removes a contour segmentation annotation from the given annotation.\n * If the annotation does not have a segmentation data, this method returns\n * quietly.  This can occur for interpolated segmentations that have not yet\n * been converted to real segmentations or other in-process segmentations.\n * @param annotation - The contour segmentation annotation to remove.\n */\nexport function removeContourSegmentationAnnotation(\n  annotation: ContourSegmentationAnnotation\n) {\n  if (!annotation.data.segmentation) {\n    throw new Error(\n      'removeContourSegmentationAnnotation: annotation does not have a segmentation data'\n    );\n  }\n\n  const { segmentationId, segmentIndex } = annotation.data.segmentation;\n  const segmentation = state.getSegmentation(segmentationId);\n  const { annotationUIDsMap } = segmentation?.representationData.CONTOUR || {};\n  const annotationsUIDsSet = annotationUIDsMap?.get(segmentIndex);\n\n  if (!annotationsUIDsSet) {\n    return;\n  }\n\n  annotationsUIDsSet.delete(annotation.annotationUID);\n\n  // Delete segmentIndex Set if there is no more annotations\n  if (!annotationsUIDsSet.size) {\n    annotationUIDsMap.delete(segmentIndex);\n  }\n}\n","/**\n * Calculates the perimeter of a polyline.\n *\n * @param polyline - The polyline represented as an array of points.\n * @param closed - Indicates whether the polyline is closed or not.\n * @returns The perimeter of the polyline.\n */\nfunction calculatePerimeter(polyline: number[][], closed: boolean): number {\n  let perimeter = 0;\n\n  for (let i = 0; i < polyline.length - 1; i++) {\n    const point1 = polyline[i];\n    const point2 = polyline[i + 1];\n    perimeter += Math.sqrt(\n      Math.pow(point2[0] - point1[0], 2) + Math.pow(point2[1] - point1[1], 2)\n    );\n  }\n\n  if (closed) {\n    const firstPoint = polyline[0];\n    const lastPoint = polyline[polyline.length - 1];\n    perimeter += Math.sqrt(\n      Math.pow(lastPoint[0] - firstPoint[0], 2) +\n        Math.pow(lastPoint[1] - firstPoint[1], 2)\n    );\n  }\n\n  return perimeter;\n}\n\nexport default calculatePerimeter;\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nimport { ContourAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nconst { isEqual } = csUtils;\n\n/**\n * Finds the index in the polyline of the specified handle.  If the handle\n * doesn't match a polyline point, then finds the closest polyline point.\n *\n * Assumes polyline is in the same orientation as the handles.\n *\n * @param annotation - to find the polyline and handles in\n * @param handleIndex - the index of hte handle to look for.\n *     Negative values are treated relative to the end of the handle index.\n * @returns Index in polyline of the closest handle\n *     * 0 for handleIndex 0\n *     * length for `handleIndex===handles length`\n */\nexport default function findHandlePolylineIndex(\n  annotation: ContourAnnotation,\n  handleIndex: number\n): number {\n  const { polyline } = annotation.data.contour;\n  const { points } = annotation.data.handles;\n  const { length } = points;\n  if (handleIndex === length) {\n    return polyline.length;\n  }\n  if (handleIndex < 0) {\n    handleIndex = (handleIndex + length) % length;\n  }\n  if (handleIndex === 0) {\n    return 0;\n  }\n  const handle = points[handleIndex];\n  const index = polyline.findIndex((point) => isEqual(handle, point));\n  if (index !== -1) {\n    return index;\n  }\n  // Need to find nearest\n  let closestDistance = Infinity;\n  return polyline.reduce((closestIndex, point, testIndex) => {\n    const distance = vec3.squaredDistance(point, handle);\n    if (distance < closestDistance) {\n      closestDistance = distance;\n      return testIndex;\n    }\n    return closestIndex;\n  }, -1);\n}\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport { ContourAnnotation } from '../../types/ContourAnnotation';\n\n/**\n * Check if two contour segmentation annotations are coplanar.\n *\n * A plane may be represented by a normal and a distance then to know if they\n * are coplanar we need to:\n *   - check if the normals of the two annotations are pointing to the same\n *   direction or to opposite directions (dot product equal to 1 or -1\n *   respectively)\n *   - Get one point from each polyline and project it onto the normal to get\n *   the distance from the origin (0, 0, 0).\n */\nexport default function areCoplanarContours(\n  firstAnnotation: ContourAnnotation,\n  secondAnnotation: ContourAnnotation\n) {\n  const { viewPlaneNormal: firstViewPlaneNormal } = firstAnnotation.metadata;\n  const { viewPlaneNormal: secondViewPlaneNormal } = secondAnnotation.metadata;\n  const dot = vec3.dot(firstViewPlaneNormal, secondViewPlaneNormal);\n  const parallelPlanes = glMatrix.equals(1, Math.abs(dot));\n\n  if (!parallelPlanes) {\n    return false;\n  }\n\n  const { polyline: firstPolyline } = firstAnnotation.data.contour;\n  const { polyline: secondPolyline } = secondAnnotation.data.contour;\n\n  // Choose one of the normals and calculate the distance of a point from each\n  // polyline along that normal. Both normal cannot be used with absolute dot\n  // product values because one of the view planes may be flipped or one of the\n  // points may be at the same distance but in the opposite direction\n  const firstDistance = vec3.dot(firstViewPlaneNormal, firstPolyline[0]);\n  const secondDistance = vec3.dot(firstViewPlaneNormal, secondPolyline[0]);\n\n  return glMatrix.equals(firstDistance, secondDistance);\n}\n","function findNextLink(line, lines, contourPoints) {\n  let index = -1;\n  lines.forEach((cell, i) => {\n    if (index >= 0) {\n      return;\n    }\n\n    if (cell.a == line.b) {\n      index = i;\n    }\n  });\n\n  if (index >= 0) {\n    const nextLine = lines[index];\n    lines.splice(index, 1);\n\n    contourPoints.push(nextLine.b);\n\n    if (contourPoints[0] == nextLine.b) {\n      return {\n        remainingLines: lines,\n        contourPoints,\n        type: 'CLOSED_PLANAR',\n        //type: 'CLOSEDPLANAR_XOR',\n      };\n    }\n\n    return findNextLink(nextLine, lines, contourPoints);\n  }\n\n  return {\n    remainingLines: lines,\n    contourPoints,\n    type: 'OPEN_PLANAR',\n  };\n}\n\n/**\n *\n * @param {*} lines\n */\nexport function findContours(lines) {\n  if (lines.length == 0) {\n    return [];\n  }\n\n  const contourPoints = [];\n\n  const firstCell = lines.shift();\n  contourPoints.push(firstCell.a);\n  contourPoints.push(firstCell.b);\n  const result = findNextLink(firstCell, lines, contourPoints);\n\n  if (result.remainingLines.length == 0) {\n    return [\n      {\n        type: result.type,\n        contourPoints: result.contourPoints,\n      },\n    ];\n  } else {\n    const extraContours = findContours(result.remainingLines);\n    extraContours.push({\n      type: result.type,\n      contourPoints: result.contourPoints,\n    });\n    return extraContours;\n  }\n}\n\nexport function findContoursFromReducedSet(lines) {\n  return findContours(lines);\n}\n\nexport default {\n  findContours,\n  findContoursFromReducedSet,\n};\n","/**\n * Iterate through polyData from vtkjs and merge any points that are the same\n * then update merged point references within lines array\n * @param polyData - vtkPolyData\n * @param bypass - bypass the duplicate point removal\n * @returns the updated polyData\n */\nexport function getDeduplicatedVTKPolyDataPoints(polyData, bypass = false) {\n  const points = polyData.getPoints();\n  const lines = polyData.getLines();\n\n  // Todo: This is cloning which is not ideal, we should move to use the PointsArrayManager\n  // that will get merged soon\n  const pointsArray = new Array(points.getNumberOfPoints())\n    .fill(0)\n    .map((_, i) => points.getPoint(i).slice());\n\n  const linesArray = new Array(lines.getNumberOfCells()).fill(0).map((_, i) => {\n    const cell = lines.getCell(i * 3).slice();\n    return { a: cell[0], b: cell[1] };\n  });\n\n  if (bypass) {\n    return { points: pointsArray, lines: linesArray };\n  }\n\n  const newPoints = [];\n  for (const [i, pt] of pointsArray.entries()) {\n    // Todo: This is an n^2 algorithm - consider using a Map<string,Point3>.\n    // Generates a reasonable amount of garbage, but I think the performance\n    //  of that is better than doing repeated compares across the entire array.\n    const index = newPoints.findIndex(\n      (point) => point[0] === pt[0] && point[1] === pt[1] && point[2] === pt[2]\n    );\n\n    if (index >= 0) {\n      linesArray.map((line) => {\n        if (line.a === i) {\n          line.a = index;\n        }\n        if (line.b === i) {\n          line.b = index;\n        }\n        return line;\n      });\n    } else {\n      const newIndex = newPoints.length;\n      newPoints.push(pt);\n      linesArray.map((line) => {\n        if (line.a === i) {\n          line.a = newIndex;\n        }\n        if (line.b === i) {\n          line.b = newIndex;\n        }\n        return line;\n      });\n    }\n  }\n\n  const newLines = linesArray.filter((line) => line.a !== line.b);\n\n  return { points: newPoints, lines: newLines };\n}\n\nexport default { getDeduplicatedVTKPolyDataPoints };\n","/**\n * Functions for detecting and dealing with holes within contours.\n * Expected Contour format:\n * {\n *   type,\n *   contourPoints\n * }\n */\n\n/**\n * Checks if point is inside polygon defined by vertices array\n * Code from\n * https://stackoverflow.com/questions/22521982/check-if-point-is-inside-a-polygon\n * most original version based on:\n * https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html/pnpoly.html\n * @param {*} point\n * @param {*} vertices\n * @returns\n */\nconst getIsPointInsidePolygon = (point, vertices) => {\n  // Todo: this is a duplicated logic we should merge it with the other one\n  // which is containsPoint in the utilities\n  const x = point[0];\n  const y = point[1];\n\n  let inside = false;\n  for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {\n    const xi = vertices[i][0],\n      yi = vertices[i][1];\n    const xj = vertices[j][0],\n      yj = vertices[j][1];\n\n    const intersect =\n      yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\n    if (intersect) {\n      inside = !inside;\n    }\n  }\n\n  return inside;\n};\n\n/**\n * Check if inner contour is completely surrounded by outer contour.\n * @param {*} outerContour\n * @param {*} innerContour\n * @returns\n */\nfunction checkEnclosed(outerContour, innerContour, points) {\n  const vertices = [];\n  outerContour.contourPoints.forEach((point) => {\n    vertices.push([points[point][0], points[point][1]]);\n  });\n\n  let pointsNotEnclosed = 0;\n  innerContour.contourPoints.forEach((point) => {\n    const result = getIsPointInsidePolygon(\n      [points[point][0], points[point][1]],\n      vertices\n    );\n    //console.log(result);\n\n    if (!result) {\n      pointsNotEnclosed++;\n    }\n  });\n\n  return pointsNotEnclosed === 0;\n}\n\n/**\n * Check if contours have holes, if so update contour accordingly\n * @param {*} polyData\n * @param {*} bypass\n */\nexport function processContourHoles(contours, points, useXOR = true) {\n  //console.log(points);\n\n  // Add non-closed planars to contour list\n  const retContours = contours.filter(\n    (contour) => contour.type !== 'CLOSED_PLANAR'\n  );\n\n  // Find closed planar contours\n  const closedContours = contours.filter(\n    (contour) => contour.type === 'CLOSED_PLANAR'\n  );\n\n  // Iterate through each contour in list check for contours that have holes\n  const contourWithHoles = [];\n  let contourWithoutHoles = [];\n  closedContours.forEach((contour, index) => {\n    const holes = [];\n\n    // Check if any other contour is a hole surrounded by current contour\n    closedContours.forEach((hContour, hIndex) => {\n      if (index != hIndex) {\n        // Check if inner loop contour is a hole of outer loop contour\n        if (checkEnclosed(contour, hContour, points)) {\n          holes.push(hIndex);\n        }\n      }\n    });\n\n    // Check if holes were found\n    if (holes.length > 0) {\n      // Note current contour and reference of its holes\n      contourWithHoles.push({\n        contour,\n        holes,\n      });\n    } else {\n      // Note contour index without holes\n      contourWithoutHoles.push(index);\n    }\n  });\n\n  if (useXOR) {\n    // XOR method\n    contourWithHoles.forEach((contourHoleSet) => {\n      // Modify contour with hole to type CLOSEDPLANAR_XOR\n      contourHoleSet.contour.type = 'CLOSEDPLANAR_XOR';\n      retContours.push(contourHoleSet.contour);\n\n      contourHoleSet.holes.forEach((holeIndex) => {\n        // Modify hole type to CLOSEDPLANAR_XOR\n        // and add to contour list to be returned\n        closedContours[holeIndex].type = 'CLOSEDPLANAR_XOR';\n        retContours.push(closedContours[holeIndex]);\n\n        // Remove hole from list of contours without holes\n        contourWithoutHoles = contourWithoutHoles.filter((contourIndex) => {\n          return contourIndex !== holeIndex;\n        });\n      });\n    });\n\n    // Add remaining contours to list (neither hole nor have holes)\n    contourWithoutHoles.forEach((contourIndex) => {\n      retContours.push(closedContours[contourIndex]);\n    });\n  } else {\n    // Keyhole method, not implemented\n  }\n\n  return retContours;\n}\n\nexport default { processContourHoles };\n","import { cache as cornerstoneCache } from '@cornerstonejs/core';\nimport vtkImageMarchingSquares from '@kitware/vtk.js/Filters/General/ImageMarchingSquares';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\n\nimport { getDeduplicatedVTKPolyDataPoints } from '../contours';\nimport { findContoursFromReducedSet } from './contourFinder';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\n\nconst { Labelmap } = SegmentationRepresentations;\n\nfunction generateContourSetsFromLabelmap({ segmentations }) {\n  const { representationData, segments = [0, 1] } = segmentations;\n  const { volumeId: segVolumeId } = representationData[Labelmap];\n\n  // Get segmentation volume\n  const vol = cornerstoneCache.getVolume(segVolumeId);\n  if (!vol) {\n    console.warn(`No volume found for ${segVolumeId}`);\n    return;\n  }\n\n  const numSlices = vol.dimensions[2];\n\n  // NOTE: Workaround for marching squares not finding closed contours at\n  // boundary of image volume, clear pixels along x-y border of volume\n  const segData = vol.imageData.getPointData().getScalars().getData();\n  const pixelsPerSlice = vol.dimensions[0] * vol.dimensions[1];\n\n  for (let z = 0; z < numSlices; z++) {\n    for (let y = 0; y < vol.dimensions[1]; y++) {\n      const index = y * vol.dimensions[0] + z * pixelsPerSlice;\n      segData[index] = 0;\n      segData[index + vol.dimensions[0] - 1] = 0;\n    }\n  }\n\n  // end workaround\n  //\n  //\n  const ContourSets = [];\n\n  const { FrameOfReferenceUID } = vol.metadata;\n  // Iterate through all segments in current segmentation set\n  const numSegments = segments.length;\n  for (let segIndex = 0; segIndex < numSegments; segIndex++) {\n    const segment = segments[segIndex];\n\n    // Skip empty segments\n    if (!segment) {\n      continue;\n    }\n\n    const sliceContours = [];\n    const scalars = vtkDataArray.newInstance({\n      name: 'Scalars',\n      numberOfComponents: 1,\n      size: pixelsPerSlice * numSlices,\n      dataType: 'Uint8Array',\n    });\n    const { containedSegmentIndices } = segment;\n    for (let sliceIndex = 0; sliceIndex < numSlices; sliceIndex++) {\n      // Check if the slice is empty before running marching cube\n      if (\n        isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex)\n      ) {\n        continue;\n      }\n      const frameStart = sliceIndex * pixelsPerSlice;\n\n      try {\n        // Modify segData for this specific segment directly\n        for (let i = 0; i < pixelsPerSlice; i++) {\n          const value = segData[i + frameStart];\n          if (value === segIndex || containedSegmentIndices?.has(value)) {\n            (scalars as any).setValue(i + frameStart, 1);\n          } else {\n            (scalars as any).setValue(i, 0);\n          }\n        }\n\n        const mSquares = vtkImageMarchingSquares.newInstance({\n          slice: sliceIndex,\n        });\n\n        // filter out the scalar data so that only it has background and\n        // the current segment index\n        const imageDataCopy = vtkImageData.newInstance();\n\n        imageDataCopy.shallowCopy(vol.imageData);\n        imageDataCopy.getPointData().setScalars(scalars);\n\n        // Connect pipeline\n        mSquares.setInputData(imageDataCopy);\n        const cValues = [1];\n        mSquares.setContourValues(cValues);\n        mSquares.setMergePoints(false);\n\n        // Perform marching squares\n        const msOutput = mSquares.getOutputData();\n\n        // Clean up output from marching squares\n        const reducedSet = getDeduplicatedVTKPolyDataPoints(msOutput);\n        if (reducedSet.points?.length) {\n          const contours = findContoursFromReducedSet(reducedSet.lines);\n\n          sliceContours.push({\n            contours,\n            polyData: reducedSet,\n            FrameNumber: sliceIndex + 1,\n            sliceIndex,\n            FrameOfReferenceUID,\n          });\n        }\n      } catch (e) {\n        console.warn(sliceIndex);\n        console.warn(e);\n      }\n    }\n\n    const metadata = {\n      FrameOfReferenceUID,\n    };\n\n    const ContourSet = {\n      label: segment.label,\n      color: segment.color,\n      metadata,\n      sliceContours,\n    };\n\n    ContourSets.push(ContourSet);\n  }\n\n  return ContourSets;\n}\n\nfunction isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex) {\n  const startIdx = sliceIndex * pixelsPerSlice;\n  const endIdx = startIdx + pixelsPerSlice;\n\n  for (let i = startIdx; i < endIdx; i++) {\n    if (segData[i] === segIndex) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport { generateContourSetsFromLabelmap };\n","import RectangleROIStartEndThreshold from './RectangleROIStartEndThreshold';\n\nfunction validateAnnotation(annotation) {\n  if (!annotation?.data) {\n    throw new Error('Tool data is empty');\n  }\n\n  if (!annotation.metadata || annotation.metadata.referenceImageId) {\n    throw new Error('Tool data is not associated with any imageId');\n  }\n}\n\nclass AnnotationToPointData {\n  static TOOL_NAMES: Record<string, any> = {};\n\n  constructor() {\n    // empty\n  }\n\n  static convert(annotation, index, metadataProvider) {\n    validateAnnotation(annotation);\n\n    const { toolName } = annotation.metadata;\n    const toolClass = AnnotationToPointData.TOOL_NAMES[toolName];\n\n    if (!toolClass) {\n      throw new Error(\n        `Unknown tool type: ${toolName}, cannot convert to RTSSReport`\n      );\n    }\n\n    // Each toolData should become a list of contours, ContourSequence\n    // contains a list of contours with their pointData, their geometry\n    // type and their length.\n    const ContourSequence = toolClass.getContourSequence(\n      annotation,\n      metadataProvider\n    );\n\n    // Todo: random rgb color for now, options should be passed in\n    const color = [\n      Math.floor(Math.random() * 255),\n      Math.floor(Math.random() * 255),\n      Math.floor(Math.random() * 255),\n    ];\n\n    return {\n      ReferencedROINumber: index + 1,\n      ROIDisplayColor: color,\n      ContourSequence,\n    };\n  }\n\n  static register(toolClass) {\n    AnnotationToPointData.TOOL_NAMES[toolClass.toolName] = toolClass;\n  }\n}\n\nAnnotationToPointData.register(RectangleROIStartEndThreshold);\n\nexport default AnnotationToPointData;\n","import type { Types } from '@cornerstonejs/core';\nimport type { Annotation, ContourAnnotation } from '../../types';\nimport { getAnnotation } from '../../stateManagement';\n\n/**\n * Get child polylines data in world space for contour annotations that represent the holes\n * @param annotation - Annotation\n * @param viewport - Viewport used to convert the points from world to canvas space\n * @returns An array that contains all child polylines (holes) in world space\n */\nexport default function getContourHolesDataWorld(\n  annotation: Annotation\n): Types.Point3[][] {\n  const childAnnotationUIDs = annotation.childAnnotationUIDs ?? [];\n\n  return childAnnotationUIDs.map(\n    (uid) => (getAnnotation(uid) as ContourAnnotation).data.contour.polyline\n  );\n}\n","import type { Types } from '@cornerstonejs/core';\nimport type { Annotation } from '../../types';\nimport getContourHolesDataWorld from './getContourHolesDataWorld';\n\n/**\n * Get the polylines for the child annotations (holes)\n * @param annotation - Annotation\n * @param viewport - Viewport used to convert the points from world to canvas space\n * @returns An array that contains all child polylines\n */\nexport default function getContourHolesDataCanvas(\n  annotation: Annotation,\n  viewport: Types.IViewport\n): Types.Point2[][] {\n  const worldHoleContours = getContourHolesDataWorld(annotation);\n  const canvasHoleContours = [];\n\n  worldHoleContours.forEach((worldHoleContour) => {\n    const numPoints = worldHoleContour.length;\n\n    // Pre-allocated arrays are 3-4x faster than multiple \"push()\" calls\n    const canvasHoleContour: Types.Point2[] = new Array(numPoints);\n\n    // Using FOR loop instead of map() for better performance when processing large arrays\n    for (let i = 0; i < numPoints; i++) {\n      canvasHoleContour[i] = viewport.worldToCanvas(worldHoleContour[i]);\n    }\n\n    canvasHoleContours.push(canvasHoleContour);\n  });\n\n  return canvasHoleContours;\n}\n","import InterpolationManager from '../../segmentation/InterpolationManager/InterpolationManager';\nimport type { AcceptInterpolationSelector } from '../../../types/InterpolationTypes';\nimport type AnnotationGroupSelector from '../../../types/AnnotationGroupSelector';\n\n/**\n * Accepts interpolated annotations, marking them as autoGenerated false.\n *\n * @param annotationGroupSelector - viewport or FOR to select annotations on\n * @param selector - nested selection criteria\n */\nexport default function acceptAutogeneratedInterpolations(\n  annotationGroupSelector: AnnotationGroupSelector,\n  selector: AcceptInterpolationSelector\n) {\n  InterpolationManager.acceptAutoGenerated(annotationGroupSelector, selector);\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { Types } from '@cornerstonejs/core';\nimport type { ContourAnnotation } from '../../types';\nimport type { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport * as math from '../math';\nimport {\n  getParentAnnotation,\n  invalidateAnnotation,\n} from '../../stateManagement';\n\n/**\n * Update the contour polyline data\n * @param annotation - Contour annotation\n * @param viewport - Viewport\n * @param polylineData - Polyline data (points, winding direction and closed)\n * @param transforms - Methods to convert points to/from canvas and world spaces\n * @param options - Options\n *   - decimate: allow to set some parameters to decimate the polyline reducing\n *   the amount of points stored which also affects how fast it will draw the\n *   annotation in a viewport, compute the winding direction, append/remove\n *   contours and create holes. A higher `epsilon` value results in a polyline\n *   with less points.\n */\nexport default function updateContourPolyline(\n  annotation: ContourAnnotation,\n  polylineData: {\n    points: Types.Point2[];\n    closed?: boolean;\n    targetWindingDirection?: ContourWindingDirection;\n  },\n  transforms: {\n    canvasToWorld: (point: Types.Point2) => Types.Point3;\n    worldToCanvas: (point: Types.Point3) => Types.Point2;\n  },\n  options?: {\n    decimate?: {\n      enabled?: boolean;\n      epsilon?: number;\n    };\n  }\n) {\n  const { canvasToWorld, worldToCanvas } = transforms;\n  const { data } = annotation;\n  const { targetWindingDirection } = polylineData;\n  let { points: polyline } = polylineData;\n\n  // Decimate the polyline to reduce tha amount of points\n  if (options?.decimate?.enabled) {\n    polyline = math.polyline.decimate(\n      polylineData.points,\n      options?.decimate?.epsilon\n    );\n  }\n\n  let { closed } = polylineData;\n  const numPoints = polyline.length;\n  const polylineWorldPoints = new Array(numPoints);\n  const currentPolylineWindingDirection =\n    math.polyline.getWindingDirection(polyline);\n  const parentAnnotation = getParentAnnotation(annotation) as ContourAnnotation;\n\n  if (closed === undefined) {\n    let currentClosedState = false;\n\n    // With two points it is just a line and do not make sense to consider it closed\n    if (polyline.length > 3) {\n      const lastToFirstDist = math.point.distanceToPointSquared(\n        polyline[0],\n        polyline[numPoints - 1]\n      );\n\n      currentClosedState = csUtils.isEqual(0, lastToFirstDist);\n    }\n\n    closed = currentClosedState;\n  }\n\n  // It must be in the opposite direction if it is a child annotation (hole)\n  let windingDirection = parentAnnotation\n    ? parentAnnotation.data.contour.windingDirection * -1\n    : targetWindingDirection;\n\n  if (windingDirection === undefined) {\n    windingDirection = currentPolylineWindingDirection;\n  }\n\n  if (windingDirection !== currentPolylineWindingDirection) {\n    polyline.reverse();\n  }\n\n  const handlePoints = data.handles.points.map((p) => worldToCanvas(p));\n\n  if (handlePoints.length > 2) {\n    const currentHandlesWindingDirection =\n      math.polyline.getWindingDirection(handlePoints);\n\n    if (currentHandlesWindingDirection !== windingDirection) {\n      data.handles.points.reverse();\n    }\n  }\n\n  for (let i = 0; i < numPoints; i++) {\n    polylineWorldPoints[i] = canvasToWorld(polyline[i]);\n  }\n\n  data.contour.polyline = polylineWorldPoints;\n  data.contour.closed = closed;\n  data.contour.windingDirection = windingDirection;\n\n  invalidateAnnotation(annotation);\n}\n","import isObject from './isObject';\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked, or until the next browser frame is drawn. The debounced function\n * comes with a `cancel` method to cancel delayed `func` invocations and a\n * `flush` method to immediately invoke them. Provide `options` to indicate\n * whether `func` should be invoked on the leading and/or trailing edge of the\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\n * debounced function. Subsequent calls to the debounced function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `debounce` and `throttle`.\n *\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0]\n *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is\n *  used (if available).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', debounce(calculateLayout, 150))\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }))\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * const debounced = debounce(batchLog, 250, { 'maxWait': 1000 })\n * const source = new EventSource('/stream')\n * jQuery(source).on('message', debounced)\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel)\n *\n * // Check for pending invocations.\n * const status = debounced.pending() ? \"Pending...\" : \"Ready\"\n */\nfunction debounce(func, wait, options) {\n  let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\n\n  let lastInvokeTime = 0;\n  let leading = false;\n  let maxing = false;\n  let trailing = true;\n\n  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n  const useRAF =\n    !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  wait = Number(wait) || 0;\n  if (isObject(options)) {\n    leading = Boolean(options.leading);\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n\n  function invokeFunc(time) {\n    const args = lastArgs;\n    const thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n\n    return result;\n  }\n\n  function startTimer(pendingFunc, wait) {\n    if (useRAF) {\n      return window.requestAnimationFrame(pendingFunc);\n    }\n\n    return setTimeout(pendingFunc, wait);\n  }\n\n  function cancelTimer(id) {\n    if (useRAF) {\n      return window.cancelAnimationFrame(id);\n    }\n    clearTimeout(id);\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = startTimer(timerExpired, wait);\n\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n    const timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (\n      lastCallTime === undefined ||\n      timeSinceLastCall >= wait ||\n      timeSinceLastCall < 0 ||\n      (maxing && timeSinceLastInvoke >= maxWait)\n    );\n  }\n\n  function timerExpired() {\n    const time = Date.now();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = startTimer(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      cancelTimer(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(Date.now());\n  }\n\n  function pending() {\n    return timerId !== undefined;\n  }\n\n  function debounced(...args) {\n    const time = Date.now();\n    const isInvoking = shouldInvoke(time);\n\n    lastArgs = args;\n    lastThis = this; // eslint-disable-line consistent-this\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = startTimer(timerExpired, wait);\n\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = startTimer(timerExpired, wait);\n    }\n\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  debounced.pending = pending;\n\n  return debounced;\n}\n\nexport default debounce;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Determine the coordinates that will place the textbox to the right of the\n * annotation.\n *\n * @param annotationCanvasPoints - The canvas points of the annotation's handles.\n * @returns - The coordinates for default placement of the textbox.\n */\nexport default function getTextBoxCoordsCanvas(\n  annotationCanvasPoints: Array<Types.Point2>\n): Types.Point2 {\n  const corners = _determineCorners(annotationCanvasPoints);\n  const centerY = (corners.top[1] + corners.bottom[1]) / 2;\n  const textBoxCanvas = <Types.Point2>[corners.right[0], centerY];\n\n  return textBoxCanvas;\n}\n\n/**\n * Determine the handles that have the min/max x and y values.\n *\n * @param canvasPoints - The canvas points of the annotation's handles.\n * @returns - The top, left, bottom, and right handles.\n */\nfunction _determineCorners(canvasPoints: Array<Types.Point2>) {\n  const handlesLeftToRight = [canvasPoints[0], canvasPoints[1]].sort(_compareX);\n  const handlesTopToBottom = [canvasPoints[0], canvasPoints[1]].sort(_compareY);\n  const right = handlesLeftToRight[handlesLeftToRight.length - 1];\n  const top = handlesTopToBottom[0];\n  const bottom = handlesTopToBottom[handlesTopToBottom.length - 1];\n\n  return {\n    top,\n    bottom,\n    right,\n  };\n\n  function _compareX(a, b) {\n    return a[0] < b[0] ? -1 : 1;\n  }\n  function _compareY(a, b) {\n    return a[1] < b[1] ? -1 : 1;\n  }\n}\n","import { utilities, cache, Types } from '@cornerstonejs/core';\nimport { getVoxelOverlap } from '../segmentation/utilities';\nimport pointInShapeCallback from '../pointInShapeCallback';\n\n/**\n * Gets the scalar data for a series of time points for either a single\n * coordinate or a segmentation mask, it will return the an array of scalar\n * data for a single coordinate or an array of arrays for a segmentation.\n *\n * @param dynamicVolume - 4D volume to compute time point data from\n * @param options - frameNumbers: which frames to use as timepoints, if left\n * blank, gets data timepoints over all frames\n * maskVolumeId: segmentationId to get timepoint data of\n * imageCoordinate: world coordinate to get timepoint data of\n * @returns\n */\nfunction getDataInTime(\n  dynamicVolume: Types.IDynamicImageVolume,\n  options: {\n    frameNumbers?;\n    maskVolumeId?;\n    imageCoordinate?;\n  }\n): number[] | number[][] {\n  let dataInTime;\n\n  // if frameNumbers is not provided, all frames are selected\n  const frames = options.frameNumbers || [\n    ...Array(dynamicVolume.numTimePoints).keys(),\n  ];\n\n  // You only need to provide either maskVolumeId OR imageCoordinate.\n  // Throws error if neither maskVolumeId or imageCoordinate is given,\n  // throws error if BOTH maskVolumeId and imageCoordinate is given\n  if (!options.maskVolumeId && !options.imageCoordinate) {\n    throw new Error(\n      'You should provide either maskVolumeId or imageCoordinate'\n    );\n  }\n\n  if (options.maskVolumeId && options.imageCoordinate) {\n    throw new Error('You can only use one of maskVolumeId or imageCoordinate');\n  }\n\n  if (options.maskVolumeId) {\n    const segmentationVolume = cache.getVolume(options.maskVolumeId);\n\n    const [dataInTime, ijkCoords] = _getTimePointDataMask(\n      frames,\n      dynamicVolume,\n      segmentationVolume\n    );\n\n    return [dataInTime, ijkCoords];\n  }\n\n  if (options.imageCoordinate) {\n    const dataInTime = _getTimePointDataCoordinate(\n      frames,\n      options.imageCoordinate,\n      dynamicVolume\n    );\n\n    return dataInTime;\n  }\n\n  return dataInTime;\n}\n\nfunction _getTimePointDataCoordinate(frames, coordinate, volume) {\n  const { dimensions, imageData } = volume;\n  const index = imageData.worldToIndex(coordinate);\n\n  index[0] = Math.floor(index[0]);\n  index[1] = Math.floor(index[1]);\n  index[2] = Math.floor(index[2]);\n\n  if (!utilities.indexWithinDimensions(index, dimensions)) {\n    throw new Error('outside bounds');\n  }\n\n  // calculate offset for index\n  const yMultiple = dimensions[0];\n  const zMultiple = dimensions[0] * dimensions[1];\n  const allScalarData = volume.getScalarDataArrays();\n  const value = [];\n\n  frames.forEach((frame) => {\n    const activeScalarData = allScalarData[frame];\n    const scalarIndex = index[2] * zMultiple + index[1] * yMultiple + index[0];\n    value.push(activeScalarData[scalarIndex]);\n  });\n\n  return value;\n}\n\nfunction _getTimePointDataMask(frames, dynamicVolume, segmentationVolume) {\n  const { imageData: maskImageData } = segmentationVolume;\n  const segScalarData = segmentationVolume.getScalarData();\n\n  const len = segScalarData.length;\n\n  // Pre-allocate memory for array\n  const nonZeroVoxelIndices = [];\n  nonZeroVoxelIndices.length = len;\n  const ijkCoords = [];\n\n  const dimensions = segmentationVolume.dimensions;\n\n  // Get the index of every non-zero voxel in mask\n  let actualLen = 0;\n  for (let i = 0, len = segScalarData.length; i < len; i++) {\n    if (segScalarData[i] !== 0) {\n      ijkCoords.push([\n        i % dimensions[0],\n        Math.floor((i / dimensions[0]) % dimensions[1]),\n        Math.floor(i / (dimensions[0] * dimensions[1])),\n      ]);\n      nonZeroVoxelIndices[actualLen++] = i;\n    }\n  }\n\n  // Trim the array to actual size\n  nonZeroVoxelIndices.length = actualLen;\n\n  const dynamicVolumeScalarDataArray = dynamicVolume.getScalarDataArrays();\n  const values = [];\n  const isSameVolume =\n    dynamicVolumeScalarDataArray[0].length === len &&\n    JSON.stringify(dynamicVolume.spacing) ===\n      JSON.stringify(segmentationVolume.spacing);\n\n  // if the segmentation mask is the same size as the dynamic volume (one frame)\n  // means we can just return the scalar data for the non-zero voxels\n  if (isSameVolume) {\n    for (let i = 0; i < nonZeroVoxelIndices.length; i++) {\n      const indexValues = [];\n      frames.forEach((frame) => {\n        const activeScalarData = dynamicVolumeScalarDataArray[frame];\n        indexValues.push(activeScalarData[nonZeroVoxelIndices[i]]);\n      });\n      values.push(indexValues);\n    }\n\n    return [values, ijkCoords];\n  }\n\n  // In case that the segmentation mask is not the same size as the dynamic volume (one frame)\n  // then we need to consider each voxel in the segmentation mask and check if it\n  // overlaps with the other volume, and if so we need to average the values of the\n  // overlapping voxels.\n  const callback = ({\n    pointLPS: segPointLPS,\n    value: segValue,\n    pointIJK: segPointIJK,\n  }) => {\n    // see if the value is non-zero\n    if (segValue === 0) {\n      // not interested\n      return;\n    }\n\n    // Then for each non-zero voxel in the segmentation mask, we should\n    // again perform the pointInShapeCallback to run the averaging callback\n    // function to get the average value of the overlapping voxels.\n    const overlapIJKMinMax = getVoxelOverlap(\n      dynamicVolume.imageData,\n      dynamicVolume.dimensions,\n      dynamicVolume.spacing,\n      segPointLPS\n    );\n\n    // count represents the number of voxels of the dynamic volume that represents\n    // one voxel of the segmentation mask\n    let count = 0;\n    const perFrameSum = new Map();\n\n    // Pre-initialize the Map\n    frames.forEach((frame) => perFrameSum.set(frame, 0));\n\n    const averageCallback = ({ index }) => {\n      for (let i = 0; i < frames.length; i++) {\n        const value = dynamicVolumeScalarDataArray[i][index];\n        const frame = frames[i];\n        perFrameSum.set(frame, perFrameSum.get(frame) + value);\n      }\n      count++;\n    };\n\n    pointInShapeCallback(\n      dynamicVolume.imageData,\n      () => true,\n      averageCallback,\n      overlapIJKMinMax\n    );\n\n    // average the values\n    const averageValues = [];\n    perFrameSum.forEach((sum) => {\n      averageValues.push(sum / count);\n    });\n\n    ijkCoords.push(segPointIJK);\n    values.push(averageValues);\n  };\n\n  // Since we have the non-zero voxel indices of the segmentation mask,\n  // we theoretically can use them, however, we kind of need to compute the\n  // pointLPS for each of the non-zero voxel indices, which is a bit of a pain.\n  // Todo: consider using the nonZeroVoxelIndices to compute the pointLPS\n  pointInShapeCallback(maskImageData, () => true, callback);\n\n  return [values, ijkCoords];\n}\n\nexport default getDataInTime;\n","import { Enums, Types } from '@cornerstonejs/core';\n\n/**\n * Gets the scalar data for a series of time frames from a 4D volume, returns an\n * array of scalar data after performing AVERAGE, SUM or SUBTRACT to be used to\n * create a 3D volume\n *\n * @param dynamicVolume4D - volume to compute time frame data from\n * @param operation - operation to perform on time frame data, operations include\n * SUM, AVERAGE, and SUBTRACT (can only be used with 2 time frames provided)\n * @param frameNumbers - an array of frame indices to perform the operation on, if\n * left empty, all frames will be used\n * @returns\n */\nfunction generateImageFromTimeData(\n  dynamicVolume: Types.IDynamicImageVolume,\n  operation: string,\n  frameNumbers?: number[]\n) {\n  // If no time frames provided, use all time frames\n  const frames = frameNumbers || [...Array(dynamicVolume.numTimePoints).keys()];\n  const numFrames = frames.length;\n\n  if (frames.length <= 1) {\n    throw new Error('Please provide two or more time points');\n  }\n\n  // Gets scalar data for all time frames\n  const typedArrays = dynamicVolume.getScalarDataArrays();\n\n  const arrayLength = typedArrays[0].length;\n  const finalArray = new Float32Array(arrayLength);\n\n  if (operation === Enums.DynamicOperatorType.SUM) {\n    for (let i = 0; i < numFrames; i++) {\n      const currentArray = typedArrays[frames[i]];\n      for (let j = 0; j < arrayLength; j++) {\n        finalArray[j] += currentArray[j];\n      }\n    }\n    return finalArray;\n  }\n\n  if (operation === Enums.DynamicOperatorType.SUBTRACT) {\n    if (frames.length > 2) {\n      throw new Error('Please provide only 2 time points for subtraction.');\n    }\n    for (let j = 0; j < arrayLength; j++) {\n      finalArray[j] += typedArrays[frames[0]][j] - typedArrays[frames[1]][j];\n    }\n    return finalArray;\n  }\n\n  if (operation === Enums.DynamicOperatorType.AVERAGE) {\n    for (let i = 0; i < numFrames; i++) {\n      const currentArray = typedArrays[frames[i]];\n      for (let j = 0; j < arrayLength; j++) {\n        finalArray[j] += currentArray[j];\n      }\n    }\n    for (let k = 0; k < arrayLength; k++) {\n      finalArray[k] = finalArray[k] / numFrames;\n    }\n    return finalArray;\n  }\n}\n\nexport default generateImageFromTimeData;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool, BaseTool } from '../tools';\nimport { Annotation } from '../types';\nimport { getAnnotations } from '../stateManagement/annotation/annotationState';\nimport * as ToolGroupManager from '../store/ToolGroupManager';\n\n/**\n * Get the annotation that is close to the provided canvas point, it will return\n * the first annotation that is found.\n *\n * @param element - The element to search for an annotation on.\n * @param canvasPoint - The canvasPoint on the page where the user clicked.\n * @param proximity - The distance from the canvasPoint to the annotation.\n * @returns The annotation for the element\n */\nfunction getAnnotationNearPoint(\n  element: HTMLDivElement,\n  canvasPoint: Types.Point2,\n  proximity = 5\n): Annotation | null {\n  // Todo: this function should return closest annotation, BUT, we are not using\n  // the function anywhere.\n  const enabledElement = getEnabledElement(element);\n  if (!enabledElement) {\n    throw new Error('getAnnotationNearPoint: enabledElement not found');\n  }\n\n  return getAnnotationNearPointOnEnabledElement(\n    enabledElement,\n    canvasPoint,\n    proximity\n  );\n}\n\n/**\n * \"Find the annotation near the point on the enabled element.\" it will return the\n * first annotation that is found.\n *\n * @param enabledElement - The element that is currently active.\n * @param point - The point to search near.\n * @param proximity - The distance from the point that the annotation must\n * be within.\n * @returns A Annotation object.\n */\nfunction getAnnotationNearPointOnEnabledElement(\n  enabledElement: Types.IEnabledElement,\n  point: Types.Point2,\n  proximity: number\n): Annotation | null {\n  // Todo: this function should return closest annotation, BUT, we are not using\n  // the function anywhere.\n  const { renderingEngineId, viewportId } = enabledElement;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const { _toolInstances: tools } = toolGroup;\n  for (const name in tools) {\n    const found = findAnnotationNearPointByTool(\n      tools[name],\n      enabledElement,\n      point,\n      proximity\n    );\n    if (found) {\n      return found;\n    }\n  }\n\n  return null;\n}\n\n/**\n * For the provided toolClass, it will find the annotation that is near the point,\n * it will return the first annotation that is found.\n *\n * @param tool - AnnotationTool\n * @param enabledElement - The element that is currently active.\n * @param point - The point in the image where the user clicked.\n * @param proximity - The distance from the point that the tool must be\n * within to be considered \"near\" the point.\n * @returns The annotation object that is being returned is the annotation object that\n * is being used in the tool.\n */\nfunction findAnnotationNearPointByTool(\n  tool: AnnotationTool,\n  enabledElement: Types.IEnabledElement,\n  point: Types.Point2,\n  proximity: number\n): Annotation | null {\n  // Todo: this function does not return closest annotation. It just returns\n  // the first annotation that is found in the proximity. BUT, we are not using\n  // the function anywhere.\n  const { viewport } = enabledElement;\n\n  const annotations = getAnnotations(\n    (tool.constructor as typeof BaseTool).toolName,\n    viewport?.element\n  );\n  const currentId = viewport?.getCurrentImageId?.();\n  if (annotations?.length) {\n    const { element } = enabledElement.viewport;\n    for (const annotation of annotations) {\n      const referencedImageId = annotation.metadata?.referencedImageId;\n      if (\n        (currentId && referencedImageId && currentId !== referencedImageId) ||\n        !tool.isPointNearTool\n      ) {\n        continue;\n      }\n\n      if (\n        tool.isPointNearTool(element, annotation, point, proximity, '') ||\n        tool.getHandleNearImagePoint(element, annotation, point, proximity)\n      ) {\n        return annotation;\n      }\n    }\n  }\n  return null;\n}\n\nexport { getAnnotationNearPoint, getAnnotationNearPointOnEnabledElement };\n","import { Enums, utilities } from '@cornerstonejs/core';\n\nconst { CalibrationTypes } = Enums;\nconst PIXEL_UNITS = 'px';\n\nconst SUPPORTED_REGION_DATA_TYPES = [\n  1, // Tissue\n];\n\nconst SUPPORTED_LENGTH_VARIANT = [\n  '3,3', // x: cm  &  y:cm\n];\n\nconst SUPPORTED_PROBE_VARIANT = [\n  '4,3', // x: seconds  &  y : cm\n];\n\nconst UNIT_MAPPING = {\n  3: 'cm',\n  4: 'seconds',\n};\n\nconst EPS = 1e-3;\nconst SQUARE = '\\xb2';\n/**\n * Extracts the calibrated length units, area units, and the scale\n * for converting from internal spacing to image spacing.\n *\n * @param handles - to detect if spacing information is different between points\n * @param image - to extract the calibration from\n * @returns Object containing the units, area units, and scale\n */\nconst getCalibratedLengthUnitsAndScale = (image, handles) => {\n  const { calibration, hasPixelSpacing } = image;\n  let units = hasPixelSpacing ? 'mm' : PIXEL_UNITS;\n  let areaUnits = units + SQUARE;\n  let scale = 1;\n  let calibrationType = '';\n\n  if (\n    !calibration ||\n    (!calibration.type && !calibration.sequenceOfUltrasoundRegions)\n  ) {\n    return { units, areaUnits, scale };\n  }\n\n  if (calibration.type === CalibrationTypes.UNCALIBRATED) {\n    return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\n  }\n\n  if (calibration.sequenceOfUltrasoundRegions) {\n    let imageIndex1, imageIndex2;\n    if (Array.isArray(handles) && handles.length === 2) {\n      [imageIndex1, imageIndex2] = handles;\n    } else if (typeof handles === 'function') {\n      const points = handles();\n      imageIndex1 = points[0];\n      imageIndex2 = points[1];\n    }\n\n    let regions = calibration.sequenceOfUltrasoundRegions.filter(\n      (region) =>\n        imageIndex1[0] >= region.regionLocationMinX0 &&\n        imageIndex1[0] <= region.regionLocationMaxX1 &&\n        imageIndex1[1] >= region.regionLocationMinY0 &&\n        imageIndex1[1] <= region.regionLocationMaxY1 &&\n        imageIndex2[0] >= region.regionLocationMinX0 &&\n        imageIndex2[0] <= region.regionLocationMaxX1 &&\n        imageIndex2[1] >= region.regionLocationMinY0 &&\n        imageIndex2[1] <= region.regionLocationMaxY1\n    );\n\n    // If we are not in a region at all we should show the underlying calibration\n    // which might be the mm spacing for the image\n    if (!regions?.length) {\n      return { units, areaUnits, scale };\n    }\n\n    // if we are in a region then it is the question of whether we support it\n    // or not. If we do not support it we should show px\n\n    regions = regions.filter(\n      (region) =>\n        SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n        SUPPORTED_LENGTH_VARIANT.includes(\n          `${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`\n        )\n    );\n\n    if (!regions.length) {\n      return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\n    }\n\n    // Todo: expand on this logic\n    const region = regions[0];\n\n    const physicalDeltaX = Math.abs(region.physicalDeltaX);\n    const physicalDeltaY = Math.abs(region.physicalDeltaY);\n\n    // if we are in a supported region then we should check if the\n    // physicalDeltaX and physicalDeltaY are the same. If they are not\n    // then we should show px again, but if they are the same then we should\n    // show the units\n    const isSamePhysicalDelta = utilities.isEqual(\n      physicalDeltaX,\n      physicalDeltaY,\n      EPS\n    );\n\n    if (isSamePhysicalDelta) {\n      // 1 to 1 aspect ratio, we use just one of them\n      scale = 1 / (physicalDeltaX * 10);\n      calibrationType = 'US Region';\n      units = 'mm';\n      areaUnits = 'mm' + SQUARE;\n    } else {\n      // here we are showing at the aspect ratio of the physical delta\n      // if they are not the same, then we should show px, but the correct solution\n      // is to grab each point separately and scale them individually\n      // Todo: implement this\n      return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\n    }\n  } else if (calibration.scale) {\n    scale = calibration.scale;\n  }\n\n  // everything except REGION/Uncalibrated\n  const types = [\n    CalibrationTypes.ERMF,\n    CalibrationTypes.USER,\n    CalibrationTypes.ERROR,\n    CalibrationTypes.PROJECTION,\n  ];\n\n  if (types.includes(calibration?.type)) {\n    calibrationType = calibration.type;\n  }\n\n  return {\n    units: units + (calibrationType ? ` ${calibrationType}` : ''),\n    areaUnits: areaUnits + (calibrationType ? ` ${calibrationType}` : ''),\n    scale,\n  };\n};\n\nconst getCalibratedProbeUnitsAndValue = (image, handles) => {\n  const [imageIndex] = handles;\n  const { calibration } = image;\n  let units = ['raw'];\n  let values = [null];\n  let calibrationType = '';\n\n  if (\n    !calibration ||\n    (!calibration.type && !calibration.sequenceOfUltrasoundRegions)\n  ) {\n    return { units, values };\n    // Todo: add support for other scenarios\n  }\n\n  if (calibration.sequenceOfUltrasoundRegions) {\n    // for Probe tool\n    const supportedRegionsMetadata =\n      calibration.sequenceOfUltrasoundRegions.filter(\n        (region) =>\n          SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n          SUPPORTED_PROBE_VARIANT.includes(\n            `${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`\n          )\n      );\n\n    if (!supportedRegionsMetadata?.length) {\n      return { units, values };\n    }\n\n    const region = supportedRegionsMetadata.find(\n      (region) =>\n        imageIndex[0] >= region.regionLocationMinX0 &&\n        imageIndex[0] <= region.regionLocationMaxX1 &&\n        imageIndex[1] >= region.regionLocationMinY0 &&\n        imageIndex[1] <= region.regionLocationMaxY1\n    );\n\n    if (!region) {\n      return { units, values };\n    }\n\n    // Todo: I think this is a ok assumption for now that if the referencePixelX0 and referencePixelY0\n    // are not defined, then we can assume 0 for them\n    const { referencePixelX0 = 0, referencePixelY0 = 0 } = region;\n    const { physicalDeltaX, physicalDeltaY } = region;\n\n    const yValue =\n      (imageIndex[1] - region.regionLocationMinY0 - referencePixelY0) *\n      physicalDeltaY;\n\n    const xValue =\n      (imageIndex[0] - region.regionLocationMinX0 - referencePixelX0) *\n      physicalDeltaX;\n\n    calibrationType = 'US Region';\n    values = [xValue, yValue];\n    units = [\n      UNIT_MAPPING[region.physicalUnitsXDirection],\n      UNIT_MAPPING[region.physicalUnitsYDirection],\n    ];\n  }\n\n  return {\n    units,\n    values,\n    calibrationType,\n  };\n};\n\n/** Gets the aspect ratio of the screen display relative to the image\n * display in order to square up measurement values.\n * That is, suppose the spacing on the image is 1, 0.5 (x,y spacing)\n * This is displayed at 1, 1 spacing on screen, then the\n * aspect value will be 1/0.5 = 2\n */\nconst getCalibratedAspect = (image) => image.calibration?.aspect || 1;\n\nexport {\n  getCalibratedLengthUnitsAndScale,\n  getCalibratedAspect,\n  getCalibratedProbeUnitsAndValue,\n};\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { vec3 } from 'gl-matrix';\nimport { BoundsIJK } from '../types';\nimport { getBoundingBoxAroundShapeIJK } from './boundingBox';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * Given an imageData, and the great circle top and bottom points of a sphere,\n * this function will run the callback for each point of the imageData that is\n * within the sphere defined by the great circle points. If the viewport\n * is provided, region of interest will be an accurate approximation of the\n * sphere (using viewport camera), and the resulting performance will be\n * better.\n *\n * @privateRemarks great circle also known as orthodrome is the intersection of\n * the sphere and the plane that passes through the center of the sphere\n *\n * @param imageData - The volume imageData\n * @param circlePoints - bottom and top points of the great circle in world coordinates\n * @param callback - A callback function that will be called for each point in the shape.\n */\nfunction getSphereBoundsInfo(\n  circlePoints: [Types.Point3, Types.Point3],\n  imageData: vtkImageData,\n  viewport\n): {\n  boundsIJK: BoundsIJK;\n  centerWorld: Types.Point3;\n  radiusWorld: number;\n  topLeftWorld: Types.Point3;\n  bottomRightWorld: Types.Point3;\n} {\n  const [bottom, top] = circlePoints;\n\n  // Sphere center in world\n  const centerWorld = vec3.fromValues(\n    (bottom[0] + top[0]) / 2,\n    (bottom[1] + top[1]) / 2,\n    (bottom[2] + top[2]) / 2\n  );\n\n  // sphere radius in world\n  const radiusWorld = vec3.distance(bottom, top) / 2;\n\n  if (!viewport) {\n    throw new Error(\n      'viewport is required in order to calculate the sphere bounds'\n    );\n  }\n\n  const { boundsIJK, topLeftWorld, bottomRightWorld } =\n    _computeBoundsIJKWithCamera(\n      imageData,\n      viewport,\n      circlePoints,\n      centerWorld,\n      radiusWorld\n    );\n\n  return {\n    boundsIJK,\n    centerWorld: centerWorld as Types.Point3,\n    radiusWorld,\n    topLeftWorld: topLeftWorld as Types.Point3,\n    bottomRightWorld: bottomRightWorld as Types.Point3,\n  };\n}\n\nfunction _computeBoundsIJKWithCamera(\n  imageData,\n  viewport,\n  circlePoints,\n  centerWorld,\n  radiusWorld\n) {\n  const [bottom, top] = circlePoints;\n\n  const dimensions = imageData.getDimensions() as Types.Point3;\n\n  const camera = viewport.getCamera();\n\n  // Calculate viewRight from the camera, this will get used in order to\n  // calculate circles topLeft and bottomRight on different planes of intersection\n  // between sphere and viewPlane\n  const viewUp = vec3.fromValues(\n    camera.viewUp[0],\n    camera.viewUp[1],\n    camera.viewUp[2]\n  );\n  const viewPlaneNormal = vec3.fromValues(\n    camera.viewPlaneNormal[0],\n    camera.viewPlaneNormal[1],\n    camera.viewPlaneNormal[2]\n  );\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n  // we need to find the bounding box of the sphere in the image, e.g., the\n  // topLeftWorld and bottomRightWorld points of the bounding box.\n  // We go from the sphereCenter in the normal direction of amount radius, and\n  // we go left to find the topLeftWorld point of the bounding box. Next we go\n  // in the opposite direction and go right to find the bottomRightWorld point\n  // of the bounding box.\n  const topLeftWorld = vec3.create();\n  const bottomRightWorld = vec3.create();\n\n  vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\n\n  // go in the direction of viewRight with the value of radius\n  vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\n\n  // In order to correctly come up with the boundsIJK, we need to consider\n  // all the points IJK to get the bounds, since the viewport might have\n  // rotate views and we cannot guarantee that the topLeft and bottomRight in the\n  // world, are the ones that will define the bounds in IJK\n  const topLeftIJK = transformWorldToIndex(\n    imageData,\n    topLeftWorld as Types.Point3\n  );\n  const bottomRightIJK = transformWorldToIndex(\n    imageData,\n    bottomRightWorld as Types.Point3\n  );\n\n  const pointsIJK = circlePoints.map((p) =>\n    transformWorldToIndex(imageData, p)\n  );\n\n  // get the bounding box of the sphere in the image\n  const boundsIJK = getBoundingBoxAroundShapeIJK(\n    [topLeftIJK, bottomRightIJK, ...pointsIJK],\n    dimensions\n  );\n\n  return { boundsIJK, topLeftWorld, bottomRightWorld };\n}\n\nexport { getSphereBoundsInfo };\n","import type { Annotation } from '../types';\nimport type { Types } from '@cornerstonejs/core';\nimport getViewportsForAnnotation from './getViewportsForAnnotation';\n\n/**\n * Finds a matching viewport in terms of the orientation of the annotation data\n * and the frame of reference.  This doesn't mean the annotation IS being displayed\n * in the viewport, just that it could be by navigating the slice, and/or pan/zoom,\n * without changing the orientation.\n *\n * @param annotation - to find a viewport that it could display in\n * @returns The viewport to display in\n */\nexport default function getViewportForAnnotation(\n  annotation: Annotation\n): Types.IStackViewport | Types.IVolumeViewport | undefined {\n  const viewports = getViewportsForAnnotation(annotation);\n\n  return viewports.length ? viewports[0] : undefined;\n}\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @since 0.1.0\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * isObject({})\n * // => true\n *\n * isObject([1, 2, 3])\n * // => true\n *\n * isObject(Function)\n * // => true\n *\n * isObject(null)\n * // => false\n */\nfunction isObject(value) {\n  const type = typeof value;\n\n  return value !== null && (type === 'object' || type === 'function');\n}\n\nexport default isObject;\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Check if two axis-aligned bounding boxes intersect\n * @param aabb1 - First AABB\n * @param aabb2 - Second AABB\n * @returns True if they intersect or false otherwise\n */\nexport default function intersectAABB(\n  aabb1: Types.AABB2,\n  aabb2: Types.AABB2\n): boolean {\n  return (\n    aabb1.minX <= aabb2.maxX &&\n    aabb1.maxX >= aabb2.minX &&\n    aabb1.minY <= aabb2.maxY &&\n    aabb1.maxY >= aabb2.minY\n  );\n}\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the distance of a point to an AABB using 2D Box SDF (Signed Distance Field)\n *\n * The SDF of a Box\n * https://www.youtube.com/watch?v=62-pRVZuS5c\n *\n * @param aabb - Axis-aligned bound box\n * @param point - 2D point\n * @returns The closest distance between the 2D point and the AABB\n */\nexport default function distanceToPointSquared(\n  aabb: Types.AABB2,\n  point: Types.Point2\n): number {\n  const aabbWidth = aabb.maxX - aabb.minX;\n  const aabbHeight = aabb.maxY - aabb.minY;\n  const aabbSize = [aabbWidth, aabbHeight];\n  const aabbCenter: Types.Point2 = [\n    aabb.minX + aabbWidth / 2,\n    aabb.minY + aabbHeight / 2,\n  ];\n\n  // Translates the point as the center of the AABB is the new origin.\n  // THe point is also mirroed to the first quadrant to simplify the math.\n  const translatedPoint = [\n    Math.abs(point[0] - aabbCenter[0]),\n    Math.abs(point[1] - aabbCenter[1]),\n  ];\n\n  // Calculate the distance from the point to the vertical and horizontal AABB borders\n  const dx = translatedPoint[0] - aabbSize[0] * 0.5;\n  const dy = translatedPoint[1] - aabbSize[1] * 0.5;\n\n  // dx >  0 && dy >  0: diagonal line connecting the point to AABB's corner\n  // dx >  0 && dy <= 0: a line parallel to x-axis connecting the point to AABB's right side\n  // dx <= 0 && dy >  0: a line parallel to y-axis connecting the point to AABB's top side\n  // dx <= 0 && dy <= 0: the point is inside the AABB\n  if (dx > 0 && dy > 0) {\n    return dx * dx + dy * dy;\n  }\n\n  const dist = Math.max(dx, 0) + Math.max(dy, 0);\n\n  return dist * dist;\n}\n","import { Types } from '@cornerstonejs/core';\nimport distanceToPointSquared from './distanceToPointSquared';\n\n/**\n * Calculates the squared distance of a point to an AABB using\n * 2D Box SDF (Signed Distance Field)\n *\n * The SDF of a Box\n * https://www.youtube.com/watch?v=62-pRVZuS5c\n *\n * @param aabb - Axis-aligned bound box (minX, minY, maxX and maxY)\n * @param point - 2D point\n * @returns The squared distance between the 2D point and the AABB\n */\nexport default function distanceToPoint(\n  aabb: Types.AABB2,\n  point: Types.Point2\n): number {\n  return Math.sqrt(distanceToPointSquared(aabb, point));\n}\n","import { NamedStatistics } from '../../../types';\n\nabstract class Calculator {\n  static run: ({ value }) => void;\n  /**\n   * Gets the statistics as both an array of values, as well as the named values.\n   */\n  static getStatistics: () => NamedStatistics;\n}\n\nexport default Calculator;\n","import { utilities } from '@cornerstonejs/core';\nimport { NamedStatistics } from '../../../types';\nimport Calculator from './Calculator';\n\nconst { PointsManager } = utilities;\n\nexport default class BasicStatsCalculator extends Calculator {\n  private static max = [-Infinity];\n  private static min = [Infinity];\n  private static sum = [0];\n  private static count = 0;\n\n  // private static sumSquares = [0];\n  // Values for Welford's algorithm\n  private static runMean = [0];\n  private static m2 = [0];\n\n  // Collect the points to be returned\n  private static pointsInShape = PointsManager.create3(1024);\n\n  public static statsInit(options: { noPointsCollection: boolean }) {\n    if (options.noPointsCollection) {\n      BasicStatsCalculator.pointsInShape = null;\n    }\n  }\n\n  /**\n   * This callback is used when we verify if the point is in the annotation drawn\n   * so we can get every point in the shape to calculate the statistics\n   */\n  static statsCallback = ({ value: newValue, pointLPS = null }): void => {\n    if (\n      Array.isArray(newValue) &&\n      newValue.length > 1 &&\n      this.max.length === 1\n    ) {\n      this.max.push(this.max[0], this.max[0]);\n      this.min.push(this.min[0], this.min[0]);\n      this.sum.push(this.sum[0], this.sum[0]);\n      this.runMean.push(0, 0);\n      // this.sumSquares.push(this.sumSquares[0], this.sumSquares[0]);\n      this.m2.push(this.m2[0], this.m2[0]);\n    }\n\n    this.pointsInShape?.push(pointLPS);\n    const newArray = Array.isArray(newValue) ? newValue : [newValue];\n\n    this.count += 1;\n    this.max.map((it, idx) => {\n      const value = newArray[idx];\n\n      const delta = value - this.runMean[idx];\n      this.sum[idx] += value;\n      this.runMean[idx] += delta / this.count;\n      const delta2 = value - this.runMean[idx];\n      this.m2[idx] += delta * delta2;\n      // this.sumSquares[idx] += value * value;\n\n      this.min[idx] = Math.min(this.min[idx], value);\n      this.max[idx] = Math.max(it, value);\n    });\n  };\n\n  /**\n   * Basic function that calculates statistics for a given array of points.\n   * @returns An object that contains :\n   * max : The maximum value of the array\n   * mean : mean of the array\n   * stdDev : standard deviation of the array\n   * array : An array of hte above values, in order.\n   */\n\n  static getStatistics = (options?: { unit: string }): NamedStatistics => {\n    const mean = this.sum.map((sum) => sum / this.count);\n    const stdDev = this.m2.map((squaredDiffSum) =>\n      Math.sqrt(squaredDiffSum / this.count)\n    );\n    // const stdDevWithSumSquare = this.sumSquares.map((it, idx) =>\n    //   Math.sqrt(this.sumSquares[idx] / this.count - mean[idx] ** 2)\n    // );\n\n    const unit = options?.unit || null;\n\n    const named: NamedStatistics = {\n      max: {\n        name: 'max',\n        label: 'Max Pixel',\n        value: singleArrayAsNumber(this.max),\n        unit,\n      },\n      min: {\n        name: 'min',\n        label: 'Min Pixel',\n        value: singleArrayAsNumber(this.min),\n        unit,\n      },\n      mean: {\n        name: 'mean',\n        label: 'Mean Pixel',\n        value: singleArrayAsNumber(mean),\n        unit,\n      },\n      stdDev: {\n        name: 'stdDev',\n        label: 'Standard Deviation',\n        value: singleArrayAsNumber(stdDev),\n        unit,\n      },\n      // stdDevWithSumSquare: {\n      //   name: 'stdDevWithSumSquare',\n      //   value: singleArrayAsNumber(stdDevWithSumSquare),\n      //   unit,\n      // },\n      count: {\n        name: 'count',\n        label: 'Pixel Count',\n        value: this.count,\n        unit: null,\n      },\n      pointsInShape: this.pointsInShape,\n      array: [],\n    };\n    named.array.push(\n      named.max,\n      named.mean,\n      named.stdDev,\n      // Use the stdDev twice to preserve old ordering - this is updated to be\n      // correct value with Welford's algorithm now.\n      named.stdDev,\n      named.count\n    );\n\n    this.max = [-Infinity];\n    this.min = [Infinity];\n    this.sum = [0];\n    // this.sumSquares = [0];\n    this.m2 = [0];\n    this.runMean = [0];\n    this.count = 0;\n    this.pointsInShape = PointsManager.create3(1024);\n\n    return named;\n  };\n}\n\nfunction singleArrayAsNumber(val: number[]) {\n  return val.length === 1 ? val[0] : val;\n}\n","import type { Types } from '@cornerstonejs/core';\ninterface Inverts {\n  invXRadiusSq?: number;\n  invYRadiusSq?: number;\n  invZRadiusSq?: number;\n  fast?: boolean;\n  /**\n   * If you call the pointInEllipse.precalculateInverts first, then you\n   * can call precalculated directly instead of having the extra time for\n   * the if conditions.\n   */\n  precalculated?: (pointLPS: Types.Point3) => boolean;\n}\n\n/**\n * Given an ellipse and a point, return true if the point is inside the ellipse\n * @param ellipse - The ellipse object to check against.\n * @param pointLPS - The point in LPS space to test.\n * @param inverts - An object to cache the inverted radius squared values, if you\n * are testing multiple points against the same ellipse then it is recommended to\n * pass in the same object to cache the values. However, there is a simpler way\n * to do this by passing in the fast flag as true, then on the first iteration\n * the values will be cached and on subsequent iterations the cached values will\n * be used.\n *\n * @returns A boolean value.\n */\nexport default function pointInEllipse(\n  ellipse,\n  pointLPS,\n  inverts: Inverts = {}\n) {\n  if (!inverts.precalculated) {\n    precalculatePointInEllipse(ellipse, inverts);\n  }\n  return inverts.precalculated(pointLPS);\n}\n\n/**\n * This will perform some precalculations to make things faster.\n * Ideally, use the 'precalculated' function inside inverts to call the\n * test function.  This minimizes re-reading of variables and only needs the\n * LPS passed each time.\n * That is:\n *\n * ```\n *    const inverts = precalculatePointInEllipse(ellipse);\n *    if( inverts.precalculated(pointLPS) ) ...\n * ```\n */\nconst precalculatePointInEllipse = (ellipse, inverts: Inverts = {}) => {\n  const { xRadius, yRadius, zRadius } = ellipse;\n\n  // This will run only once since we are caching the values in the same\n  // object that is passed in.\n  if (\n    inverts.invXRadiusSq === undefined ||\n    inverts.invYRadiusSq === undefined ||\n    inverts.invZRadiusSq === undefined\n  ) {\n    inverts.invXRadiusSq = xRadius !== 0 ? 1 / xRadius ** 2 : 0;\n    inverts.invYRadiusSq = yRadius !== 0 ? 1 / yRadius ** 2 : 0;\n    inverts.invZRadiusSq = zRadius !== 0 ? 1 / zRadius ** 2 : 0;\n  }\n\n  const { invXRadiusSq, invYRadiusSq, invZRadiusSq } = inverts;\n  const { center } = ellipse;\n  const [centerL, centerP, centerS] = center;\n\n  inverts.precalculated = (pointLPS) => {\n    // Calculate the sum of normalized squared distances\n    const dx = pointLPS[0] - centerL;\n    let inside = dx * dx * invXRadiusSq;\n    if (inside > 1) {\n      return false;\n    }\n\n    const dy = pointLPS[1] - centerP;\n    inside += dy * dy * invYRadiusSq;\n    if (inside > 1) {\n      return false;\n    }\n\n    const dz = pointLPS[2] - centerS;\n    inside += dz * dz * invZRadiusSq;\n\n    // Check if the point is inside the ellipse\n    return inside <= 1;\n  };\n\n  return inverts;\n};\n\nexport { precalculatePointInEllipse };\n","import type { Types } from '@cornerstonejs/core';\n\nexport type CanvasCoordinates = [\n  Types.Point2, // bottom\n  Types.Point2, // top\n  Types.Point2, // left\n  Types.Point2 // right\n];\n\n/**\n * It takes the canvas coordinates of the ellipse corners and returns the top left and bottom right\n * corners of it\n *\n * @param ellipseCanvasPoints - The coordinates of the ellipse in the canvas.\n * @returns An array of two points.\n */\nexport default function getCanvasEllipseCorners(\n  ellipseCanvasPoints: CanvasCoordinates\n): Array<Types.Point2> {\n  const [bottom, top, left, right] = ellipseCanvasPoints;\n\n  const topLeft = <Types.Point2>[left[0], top[1]];\n  const bottomRight = <Types.Point2>[right[0], bottom[1]];\n\n  return [topLeft, bottomRight];\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as math from '../';\n\n/**\n * Calculate the closest point and the squared distance between a reference point and a line segment.\n *\n * It projects the reference point onto the line segment but it shall be bounded by the\n * start/end points since this is a line segment and not a line which could be extended.\n *\n * @param lineStart - Start point of the line segment\n * @param lineEnd - End point of the line segment\n * @param point - Reference point\n * @returns Closest point and the squared distance between a `point` and a line\n *   segment defined by `lineStart` and `lineEnd` points\n */\nexport default function distanceToPointSquaredInfo(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): {\n  point: Types.Point2;\n  distanceSquared: number;\n} {\n  let closestPoint: Types.Point2;\n  const distanceSquared = math.point.distanceToPointSquared(lineStart, lineEnd);\n\n  // Check if lineStart equal to the lineEnd which means the closest point\n  // is any of these two points\n  if (lineStart[0] === lineEnd[0] && lineStart[1] === lineEnd[1]) {\n    closestPoint = lineStart;\n  }\n\n  if (!closestPoint) {\n    const dotProduct =\n      ((point[0] - lineStart[0]) * (lineEnd[0] - lineStart[0]) +\n        (point[1] - lineStart[1]) * (lineEnd[1] - lineStart[1])) /\n      distanceSquared;\n\n    if (dotProduct < 0) {\n      closestPoint = lineStart;\n    } else if (dotProduct > 1) {\n      closestPoint = lineEnd;\n    } else {\n      closestPoint = [\n        lineStart[0] + dotProduct * (lineEnd[0] - lineStart[0]),\n        lineStart[1] + dotProduct * (lineEnd[1] - lineStart[1]),\n      ];\n    }\n  }\n\n  return {\n    point: [...closestPoint],\n    distanceSquared: math.point.distanceToPointSquared(point, closestPoint),\n  };\n}\n","import { Types } from '@cornerstonejs/core';\nimport distanceToPointSquaredInfo from './distanceToPointSquaredInfo';\n\n/**\n * Calculates the distance-squared of a point to a line segment\n *\n * @param lineStart - x,y coordinates of the start of the line\n * @param lineEnd - x,y coordinates of the end of the line\n * @param point - x,y of the point\n * @returns distance-squared\n */\nexport default function distanceToPointSquared(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): number {\n  return distanceToPointSquaredInfo(lineStart, lineEnd, point).distanceSquared;\n}\n","import distanceToPointSquared from './distanceToPointSquared';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the distance of a point to a line\n *\n * @param lineStart - x,y coordinates of the start of the line\n * @param lineEnd - x,y coordinates of the end of the line\n * @param point - x,y of the point\n * @returns distance\n */\nexport default function distanceToPoint(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): number {\n  if (lineStart.length !== 2 || lineEnd.length !== 2 || point.length !== 2) {\n    throw Error(\n      'lineStart, lineEnd, and point should have 2 elements of [x, y]'\n    );\n  }\n\n  return Math.sqrt(distanceToPointSquared(lineStart, lineEnd, point));\n}\n","import type { Types } from '@cornerstonejs/core';\n\n// Returns sign of number\nfunction sign(x: any) {\n  return typeof x === 'number'\n    ? x\n      ? x < 0\n        ? -1\n        : 1\n      : x === x\n      ? 0\n      : NaN\n    : NaN;\n}\n\n/**\n * Calculates the intersection point between two lines in the 2D plane\n *\n * @param line1Start - x,y coordinates of the start of the first line\n * @param line1End - x,y coordinates of the end of the first line\n * @param line2Start - x,y coordinates of the start of the second line\n * @param line2End - x,y coordinates of the end of the second line\n * @returns [x,y] - point x,y of the point\n */\n\nexport default function intersectLine(\n  line1Start: Types.Point2,\n  line1End: Types.Point2,\n  line2Start: Types.Point2,\n  line2End: Types.Point2\n): number[] {\n  const [x1, y1] = line1Start;\n  const [x2, y2] = line1End;\n  const [x3, y3] = line2Start;\n  const [x4, y4] = line2End;\n\n  // Compute a1, b1, c1, where line joining points 1 and 2 is \"a1 x  +  b1 y  +  c1  =  0\"\n  const a1 = y2 - y1;\n  const b1 = x1 - x2;\n  const c1 = x2 * y1 - x1 * y2;\n\n  // Compute r3 and r4\n  const r3 = a1 * x3 + b1 * y3 + c1;\n  const r4 = a1 * x4 + b1 * y4 + c1;\n\n  /* Check signs of r3 and r4.  If both point 3 and point 4 lie on\n   * same side of line 1, the line segments do not intersect.\n   */\n\n  if (r3 !== 0 && r4 !== 0 && sign(r3) === sign(r4)) {\n    return;\n  }\n\n  // Compute a2, b2, c2\n  const a2 = y4 - y3;\n  const b2 = x3 - x4;\n  const c2 = x4 * y3 - x3 * y4;\n\n  // Compute r1 and r2\n  const r1 = a2 * x1 + b2 * y1 + c2;\n  const r2 = a2 * x2 + b2 * y2 + c2;\n\n  /* Check signs of r1 and r2.  If both point 1 and point 2 lie\n   * on same side of second line segment, the line segments do\n   * not intersect.\n   */\n\n  if (r1 !== 0 && r2 !== 0 && sign(r1) === sign(r2)) {\n    return;\n  }\n\n  /* Line segments intersect: compute intersection point.\n   */\n\n  const denom = a1 * b2 - a2 * b1;\n  let num;\n\n  /* The denom/2 is to get rounding instead of truncating.  It\n   * is added or subtracted to the numerator, depending upon the\n   * sign of the numerator.\n   */\n\n  num = b1 * c2 - b2 * c1;\n  const x = num / denom;\n\n  num = a2 * c1 - a1 * c2;\n  const y = num / denom;\n\n  const intersectionPoint = [x, y];\n\n  return intersectionPoint;\n}\n","import type { Types } from '@cornerstonejs/core';\n\nconst ORIENTATION_TOLERANCE = 1e-2;\n\n/**\n * Test if a point is on a line segment\n * @param lineStart - Line segment start point\n * @param lineEnd - Line segment end point\n * @param point - Point to test\n * @returns True if the point lies on the line segment or false otherwise\n */\nexport default function isPointOnLineSegment(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): boolean {\n  // The code below runs ~4x faster than calling `line.distanceToPointSquared()` (155 vs 598 ms)\n\n  // No Math.min/max call for better performance when testing thousands of points\n  const minX = lineStart[0] <= lineEnd[0] ? lineStart[0] : lineEnd[0];\n  const maxX = lineStart[0] >= lineEnd[0] ? lineStart[0] : lineEnd[0];\n  const minY = lineStart[1] <= lineEnd[1] ? lineStart[1] : lineEnd[1];\n  const maxY = lineStart[1] >= lineEnd[1] ? lineStart[1] : lineEnd[1];\n\n  // Checks if the point lies inside the AABB\n  const aabbContainsPoint =\n    point[0] >= minX - ORIENTATION_TOLERANCE &&\n    point[0] <= maxX + ORIENTATION_TOLERANCE &&\n    point[1] >= minY - ORIENTATION_TOLERANCE &&\n    point[1] <= maxY + ORIENTATION_TOLERANCE;\n\n  if (!aabbContainsPoint) {\n    return false;\n  }\n\n  // Now that we know the point is inside the AABB we check if it lies on the line segment\n  const orientation =\n    (lineEnd[1] - lineStart[1]) * (point[0] - lineEnd[0]) -\n    (lineEnd[0] - lineStart[0]) * (point[1] - lineEnd[1]);\n  const absOrientation = orientation >= 0 ? orientation : -orientation;\n\n  // The orientation must be zero for points that lies on the same line\n  return absOrientation <= ORIENTATION_TOLERANCE;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport distanceToPointSquared from './distanceToPointSquared';\n\ntype Point = Types.Point2 | Types.Point3;\n\n/**\n * Calculates the distance of a point to another point\n *\n * @param p1 - x,y or x,y,z of the point\n * @param p2 - x,y or x,y,z of the point\n * @returns distance\n */\nexport default function distanceToPoint(p1: Point, p2: Point): number {\n  return Math.sqrt(distanceToPointSquared(p1, p2));\n}\n","import type { Types } from '@cornerstonejs/core';\n\ntype Point = Types.Point2 | Types.Point3;\n\n/**\n * Calculates the distance squared of a point to another point\n *\n * @param p1 - x,y or x,y,z of the point\n * @param p2 - x,y or x,y,z of the point\n * @returns distance\n */\nexport default function distanceToPointSquared(p1: Point, p2: Point): number {\n  if (p1.length !== p2.length) {\n    throw Error('Both points should have the same dimensionality');\n  }\n\n  const [x1, y1, z1 = 0] = p1;\n  const [x2, y2, z2 = 0] = p2;\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const dz = z2 - z1;\n\n  // Time to square 10M numbers:\n  //   (n * n) = 161ms | (n ** 2) = 199ms | Math.pow(n, 2) = 29529ms\n  return dx * dx + dy * dy + dz * dz;\n}\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Get a mirrored point along the line created by two points where one of them\n * is the static (\"anchor\") point and the other one is the point to be mirroed.\n * @param mirrorPoint - 2D Point to be mirroed\n * @param staticPoint - Static 2D point\n * @returns Mirroed 2D point\n */\nexport default function mirror(\n  mirrorPoint: Types.Point2,\n  staticPoint: Types.Point2\n): Types.Point2 {\n  const [x1, y1] = mirrorPoint;\n  const [x2, y2] = staticPoint;\n\n  const newX = 2 * x2 - x1;\n  const newY = 2 * y2 - y1;\n\n  return [newX, newY];\n}\n","import { glMatrix } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport * as math from '..';\n\n/**\n * A polyline is considered closed if the start and end points are at the same position\n *\n * @param polyline - Polyline points (2D)\n * @returns True if the polyline is already closed or false otherwise\n */\nexport default function isClosed(polyline: Types.Point2[]): boolean {\n  if (polyline.length < 3) {\n    return false;\n  }\n\n  const numPolylinePoints = polyline.length;\n\n  const firstPoint = polyline[0];\n  const lastPoint = polyline[numPolylinePoints - 1];\n  const distFirstToLastPoints = math.point.distanceToPointSquared(\n    firstPoint,\n    lastPoint\n  );\n\n  return glMatrix.equals(0, distFirstToLastPoints);\n}\n","import type { Types } from '@cornerstonejs/core';\nimport isClosed from './isClosed';\n\n/**\n * Checks if a 2D point is inside the polyline.\n *\n * A point is inside a curve/polygon if the number of intersections between the horizontal\n * ray emanating from the given point and to the right and the line segments is odd.\n * https://www.eecs.umich.edu/courses/eecs380/HANDOUTS/PROJ2/InsidePoly.html\n *\n * Note that a point on the polyline is considered inside.\n *\n * @param polyline - Polyline points (2D)\n * @param point - 2D Point\n * @returns True if the point is inside the polyline or false otherwise\n */\nexport default function containsPoint(\n  polyline: Types.Point2[],\n  point: Types.Point2,\n  options: {\n    closed?: boolean;\n    holes?: Types.Point2[][];\n  } = {\n    closed: undefined,\n  }\n): boolean {\n  if (polyline.length < 3) {\n    return false;\n  }\n\n  const numPolylinePoints = polyline.length;\n  let numIntersections = 0;\n\n  const { closed, holes } = options;\n\n  if (holes?.length) {\n    for (const hole of holes) {\n      if (containsPoint(hole, point)) {\n        return false;\n      }\n    }\n  }\n\n  // Test intersection against [end, start] line segment if it should be closed\n  const shouldClose = !(closed === undefined ? isClosed(polyline) : closed);\n  const maxSegmentIndex = polyline.length - (shouldClose ? 1 : 2);\n\n  for (let i = 0; i <= maxSegmentIndex; i++) {\n    const p1 = polyline[i];\n\n    // Calculating the next point index without using % (mod) operator like in\n    // `(i + 1) % numPolylinePoints` to make it 20% faster\n    const p2Index = i === numPolylinePoints - 1 ? 0 : i + 1;\n    const p2 = polyline[p2Index];\n\n    // Calculating min/max without using Math.min/max to make it ~3% faster\n    const maxX = p1[0] >= p2[0] ? p1[0] : p2[0];\n    const maxY = p1[1] >= p2[1] ? p1[1] : p2[1];\n    const minY = p1[1] <= p2[1] ? p1[1] : p2[1];\n\n    const mayIntersectLineSegment =\n      point[0] <= maxX && point[1] >= minY && point[1] < maxY;\n\n    if (mayIntersectLineSegment) {\n      const isVerticalLine = p1[0] === p2[0];\n      let intersects = isVerticalLine;\n\n      if (!intersects) {\n        const xIntersection =\n          ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];\n\n        intersects = point[0] <= xIntersection;\n      }\n\n      numIntersections += intersects ? 1 : 0;\n    }\n  }\n\n  return !!(numIntersections % 2);\n}\n","import type { Types } from '@cornerstonejs/core';\nimport containsPoint from './containsPoint';\n\n/**\n * Checks if a polyline contains a set of points.\n *\n * @param polyline - Polyline points (2D)\n * @param points - 2D points to verify\n * @returns True if all points are inside the polyline or false otherwise\n */\nexport default function containsPoints(\n  polyline: Types.Point2[],\n  points: Types.Point2[]\n): boolean {\n  for (let i = 0, numPoint = points.length; i < numPoint; i++) {\n    if (!containsPoint(polyline, points[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the area of an array of `Point2` points using the shoelace algorithm.\n *\n * The units of the area are in the same units as the points are in. E.g. if\n * the points are in canvas, then the result is in canvas pixels ^2; If they are\n * in mm, then the result is in mm^2; etc.\n */\nexport default function getArea(points: Types.Point2[]): number {\n  // Shoelace algorithm.\n  const n = points.length;\n  let area = 0.0;\n  let j = n - 1;\n\n  for (let i = 0; i < n; i++) {\n    area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);\n    j = i; // j is previous vertex to i\n  }\n\n  // Return absolute value of half the sum (half as summing up traingles).\n  return Math.abs(area / 2.0);\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the area with signal of a 2D polyline\n * https://www.youtube.com/watch?v=GpsKrAipXm8&t=1900s\n *\n * This functions has a runtime very close to `getArea` and it is recommended to\n * be called only if you need the area signal (eg: calculate polygon normal or\n * winding direction). If you do not need the area signal you should always call\n * `getArea`.\n *\n * @param polyline - Polyline points (2D)\n * @returns Area of the polyline (with signal)\n */\nexport default function getSignedArea(polyline: Types.Point2[]): number {\n  if (polyline.length < 3) {\n    return 0;\n  }\n\n  // Reference point can be any point on the same plane\n  const refPoint = polyline[0];\n  let area = 0;\n\n  // Takes three points (reference point and two other points from each line\n  // segment) and calculate the area with cross product. The magnitude of the\n  // vector returned by a cross product is equal to the area of the parallelogram\n  // that the vectors span which is two times the area of the triangle.\n  //\n  // Not calling vec3 mathods makes the function run much faster since polylines\n  // may have thousands of points when using freehand ROI tool and that would\n  // increase considerably the number of function calls.\n  for (let i = 0, len = polyline.length; i < len; i++) {\n    const p1 = polyline[i];\n    // Using ternary instead of % (mod) operator to make it faster\n    const p2Index = i === len - 1 ? 0 : i + 1;\n    const p2 = polyline[p2Index];\n    const aX = p1[0] - refPoint[0];\n    const aY = p1[1] - refPoint[1];\n    const bX = p2[0] - refPoint[0];\n    const bY = p2[1] - refPoint[1];\n\n    // Cross product between vectors \"a\" and \"b\" which returns (0, 0, crossProd)\n    // for 2D vectors.\n    area += aX * bY - aY * bX;\n  }\n\n  // Divide by two because cross product returns two times the area for each triangle\n  area *= 0.5;\n\n  return area;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport getSignedArea from './getSignedArea';\n\n/**\n * Calculate the winding direction (CW or CCW) of a polyline\n * @param polyline - Polyline (2D)\n * @returns 1 for CW or -1 for CCW polylines\n */\nexport default function getWindingDirection(polyline: Types.Point2[]): number {\n  const signedArea = getSignedArea(polyline);\n\n  // Return 1 or -1 which is also possible to convert into ContourOrientation\n  return signedArea >= 0 ? 1 : -1;\n}\n","import { vec3 } from 'gl-matrix';\nimport { Types } from '@cornerstonejs/core';\n\nfunction _getAreaVector(polyline: Types.Point3[]): Types.Point3 {\n  const vecArea = vec3.create();\n\n  // Reference point can be any point on the same plane\n  const refPoint = polyline[0];\n\n  // Takes three points, reference point and two other points from each line\n  // segment, and calculate the area with cross product. The magnitude of the\n  // vector returned by a cross product is equal to the area of the parallelogram\n  // that the vectors span which is two times the area of the triangle.\n  //\n  // Not calling vec3 mathods makes the function run much faster since polylines\n  // may have thousands of points when using freehand ROI tool and that would\n  // increase considerably the number of function calls.\n  for (let i = 0, len = polyline.length; i < len; i++) {\n    const p1 = polyline[i];\n    // Using ternary instead of % (mod) operator to make it faster\n    const p2Index = i === len - 1 ? 0 : i + 1;\n    const p2 = polyline[p2Index];\n\n    const aX = p1[0] - refPoint[0];\n    const aY = p1[1] - refPoint[1];\n    const aZ = p1[2] - refPoint[2];\n    const bX = p2[0] - refPoint[0];\n    const bY = p2[1] - refPoint[1];\n    const bZ = p2[2] - refPoint[2];\n\n    // Cross product without calling vec3.cross() for better performance\n    vecArea[0] += aY * bZ - aZ * bY;\n    vecArea[1] += aZ * bX - aX * bZ;\n    vecArea[2] += aX * bY - aY * bX;\n  }\n\n  // Divide by two because cross product returns two times the area for each triangle\n  vec3.scale(vecArea, vecArea, 0.5);\n\n  // The magnitude of the vector is the area of the polyline\n  return <Types.Point3>vecArea;\n}\n\n/**\n * Calculate the normal of a 3D planar polyline\n * @param polyline - Planar polyline in 3D space\n * @returns Normal of the 3D planar polyline\n */\nexport default function getNormal3(polyline: Types.Point3[]): Types.Point3 {\n  const vecArea = _getAreaVector(polyline);\n\n  return vec3.normalize(vecArea, vecArea) as Types.Point3;\n}\n","import { Types } from '@cornerstonejs/core';\nimport getSignedArea from './getSignedArea';\n\n/**\n * Calculate the normal of a 2D polyline\n * https://www.youtube.com/watch?v=GpsKrAipXm8&t=1982s\n *\n * @param polyline - Planar polyline in 2D space\n * @returns Normal of the 2D planar polyline\n */\nexport default function getNormal2(polyline: Types.Point2[]): Types.Point3 {\n  const area = getSignedArea(polyline);\n\n  // The normal of a 2D polyline is (0, 0, 1) or (0, 0, -1) depending if it\n  // is CW or CCW polyline\n  return [0, 0, area / Math.abs(area)] as Types.Point3;\n}\n","import type { Types } from '@cornerstonejs/core';\n\n// ATTENTION: this is an internal function and it should not be added to \"polyline\"\n// namespace.\n//\n// TODO: there is a similar function in math.lineSegment.intersectLine but we\n// need to investigate why it is 6x slower than this one when thousands of\n// intersections are calculated. Also that one may return [NaN, NaN] for\n// collinear points.\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects the line (`p2`,`q2`) via an\n * orientation algorithm.\n *\n * Credit and details: geeksforgeeks.org/check-if-two-given-line-segments-intersect/\n *\n * @param p1 - Start point of line segment 1\n * @param q1 - End point of line segment 1\n * @param p2 - Start point of line segment 2\n * @param q2 - End point of line segment 2\n * @returns True if the line segments intersect or false otherwise\n */\nexport default function areLineSegmentsIntersecting(\n  p1: Types.Point2,\n  q1: Types.Point2,\n  p2: Types.Point2,\n  q2: Types.Point2\n): boolean {\n  let result = false;\n\n  // Line 1 AABB\n  const line1MinX = p1[0] < q1[0] ? p1[0] : q1[0];\n  const line1MinY = p1[1] < q1[1] ? p1[1] : q1[1];\n  const line1MaxX = p1[0] > q1[0] ? p1[0] : q1[0];\n  const line1MaxY = p1[1] > q1[1] ? p1[1] : q1[1];\n\n  // Line 2 AABB\n  const line2MinX = p2[0] < q2[0] ? p2[0] : q2[0];\n  const line2MinY = p2[1] < q2[1] ? p2[1] : q2[1];\n  const line2MaxX = p2[0] > q2[0] ? p2[0] : q2[0];\n  const line2MaxY = p2[1] > q2[1] ? p2[1] : q2[1];\n\n  // If AABBs do not intersect it is impossible for the lines to intersect.\n  // Checking AABB before doing any math makes it run ~12% faster.\n  if (\n    line1MinX > line2MaxX ||\n    line1MaxX < line2MinX ||\n    line1MinY > line2MaxY ||\n    line1MaxY < line2MinY\n  ) {\n    return false;\n  }\n\n  const orient = [\n    orientation(p1, q1, p2),\n    orientation(p1, q1, q2),\n    orientation(p2, q2, p1),\n    orientation(p2, q2, q1),\n  ];\n\n  // General Case\n  if (orient[0] !== orient[1] && orient[2] !== orient[3]) {\n    return true;\n  }\n\n  // Special Cases\n  if (orient[0] === 0 && onSegment(p1, p2, q1)) {\n    // If p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    result = true;\n  } else if (orient[1] === 0 && onSegment(p1, q2, q1)) {\n    // If p1, q1 and p2 are colinear and q2 lies on segment p1q1\n    result = true;\n  } else if (orient[2] === 0 && onSegment(p2, p1, q2)) {\n    // If p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    result = true;\n  } else if (orient[3] === 0 && onSegment(p2, q1, q2)) {\n    // If p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    result = true;\n  }\n\n  return result;\n}\n\n/**\n * Checks the orientation of 3 points, returns a 0, 1 or 2 based on\n * the orientation of the points.\n */\nfunction orientation(\n  p: Types.Point2,\n  q: Types.Point2,\n  r: Types.Point2\n): number {\n  // Take the cross product between vectors PQ and QR\n  const orientationValue =\n    (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n\n  if (orientationValue === 0) {\n    return 0; // Colinear\n  }\n\n  return orientationValue > 0 ? 1 : 2;\n}\n\n/**\n * Checks if point `q` lies on the segment (`p`,`r`).\n */\nfunction onSegment(p: Types.Point2, q: Types.Point2, r: Types.Point2): boolean {\n  if (\n    q[0] <= Math.max(p[0], r[0]) &&\n    q[0] >= Math.min(p[0], r[0]) &&\n    q[1] <= Math.max(p[1], r[1]) &&\n    q[1] >= Math.min(p[1], r[1])\n  ) {\n    return true;\n  }\n\n  return false;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\n\n/**\n * Get all intersections between a polyline and a line segment.\n * @param polyline - Polyline points\n * @param p1 - Start point of line segment\n * @param q1 - End point of line segment\n * @param closed - Test the intersection against the line segment that connects\n * the last to the first point when set to true\n * @returns Start/end point indexes of all line segments that intersect (p1, q1)\n */\nexport default function getLineSegmentIntersectionsIndexes(\n  polyline: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2[] {\n  const intersections: Types.Point2[] = [];\n  const numPoints = polyline.length;\n  const maxI = numPoints - (closed ? 1 : 2);\n\n  for (let i = 0; i <= maxI; i++) {\n    const p2 = polyline[i];\n    // Do not use % operator for better performance\n    const j = i === numPoints - 1 ? 0 : i + 1;\n    const q2 = polyline[j];\n\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n      intersections.push([i, j]);\n    }\n  }\n\n  return intersections;\n}\n","import { Types } from '@cornerstonejs/core';\nimport * as mathLine from '../line';\n\n// ATTENTION: this is an internal function and it should not be added to \"polyline\" namespace\n\n// Tested with +1M random overlapping line segments and any tolerance below this\n// one may return invalid results.\nconst PARALLEL_LINES_TOLERANCE = 1e-2;\n\n/**\n * It returns the intersection between two lines (not line segments) or a midpoint\n * when the line segments overlap. This function calculates the intersection between\n * lines because it considers that getFirstLineSegmentIntersectionIndexes,\n * getLineSegmentIntersectionsCoordinates or getLineSegmentIntersectionsIndexes\n * has already been called first which guarantees.\n *\n * @param p1 - Line segment 1 start\n * @param q1 - Line segment 1 end\n * @param p2 - Line segment 2 start\n * @param q2 - Line segment 21 end\n * @returns The intersection between two lines or a midpoint when they overlap\n */\nexport default function getLinesIntersection(\n  p1: Types.Point2,\n  q1: Types.Point2,\n  p2: Types.Point2,\n  q2: Types.Point2\n) {\n  const diffQ1P1 = [q1[0] - p1[0], q1[1] - p1[1]];\n  const diffQ2P2 = [q2[0] - p2[0], q2[1] - p2[1]];\n  const denominator = diffQ2P2[1] * diffQ1P1[0] - diffQ2P2[0] * diffQ1P1[1];\n  const absDenominator = denominator >= 0 ? denominator : -denominator;\n\n  if (absDenominator < PARALLEL_LINES_TOLERANCE) {\n    // No Math.min/max calls for better performance.\n    const line1AABB = [\n      p1[0] < q1[0] ? p1[0] : q1[0], // 0: minX\n      p1[0] > q1[0] ? p1[0] : q1[0], // 1: maxX\n      p1[1] < q1[1] ? p1[1] : q1[1], // 2: minY\n      p1[1] > q1[1] ? p1[1] : q1[1], // 3: maxY\n    ];\n\n    // No Math.min/max calls for better performance.\n    const line2AABB = [\n      p2[0] < q2[0] ? p2[0] : q2[0], // 0: minX\n      p2[0] > q2[0] ? p2[0] : q2[0], // 1: maxX\n      p2[1] < q2[1] ? p2[1] : q2[1], // 2: minY\n      p2[1] > q2[1] ? p2[1] : q2[1], // 3: maxY\n    ];\n\n    const aabbIntersects =\n      line1AABB[0] <= line2AABB[1] && // minX1 <= maxX2\n      line1AABB[1] >= line2AABB[0] && // maxX1 >= minX2\n      line1AABB[2] <= line2AABB[3] && // minY1 <= maxY2\n      line1AABB[3] >= line2AABB[2]; // maxY1 >= minY2\n\n    if (!aabbIntersects) {\n      return;\n    }\n\n    // Three tests are enough to know if the lines overlap\n    const overlap =\n      mathLine.isPointOnLineSegment(p1, q1, p2) ||\n      mathLine.isPointOnLineSegment(p1, q1, q2) ||\n      mathLine.isPointOnLineSegment(p2, q2, p1);\n\n    if (!overlap) {\n      return;\n    }\n\n    // min/max seems to be inverted but that is correct because it is looking\n    // for the intersection range. No Math.min/max calls for better performance.\n    const minX = line1AABB[0] > line2AABB[0] ? line1AABB[0] : line2AABB[0];\n    const maxX = line1AABB[1] < line2AABB[1] ? line1AABB[1] : line2AABB[1];\n    const minY = line1AABB[2] > line2AABB[2] ? line1AABB[2] : line2AABB[2];\n    const maxY = line1AABB[3] < line2AABB[3] ? line1AABB[3] : line2AABB[3];\n    const midX = (minX + maxX) * 0.5;\n    const midY = (minY + maxY) * 0.5;\n\n    return [midX, midY];\n  }\n\n  let a = p1[1] - p2[1];\n  let b = p1[0] - p2[0];\n  const numerator1 = diffQ2P2[0] * a - diffQ2P2[1] * b;\n  const numerator2 = diffQ1P1[0] * a - diffQ1P1[1] * b;\n  a = numerator1 / denominator;\n  b = numerator2 / denominator;\n\n  const resultX = p1[0] + a * diffQ1P1[0];\n  const resultY = p1[1] + a * diffQ1P1[1];\n\n  return [resultX, resultY];\n}\n","import { Types } from '@cornerstonejs/core';\nimport * as mathPoint from '../point';\nimport getLineSegmentIntersectionsIndexes from './getLineSegmentIntersectionsIndexes';\nimport containsPoint from './containsPoint';\nimport getNormal2 from './getNormal2';\nimport { glMatrix, vec3 } from 'gl-matrix';\nimport getLinesIntersection from './getLinesIntersection';\n\nenum PolylinePointType {\n  Vertex,\n  Intersection,\n}\n\n// Position of the point related to the intersection region\nenum PolylinePointPosition {\n  Outside = -1,\n  Edge = 0,\n  Inside = 1,\n}\n\n// Direction from last point to the intersection point to know if it is entering\n// or exiting the intersection region\nenum PolylinePointDirection {\n  Exiting = -1,\n  Unknown = 0,\n  Entering = 1,\n}\n\ntype PolylinePoint = {\n  type: PolylinePointType;\n  coordinates: Types.Point2;\n  position?: PolylinePointPosition;\n  visited: boolean;\n  next: PolylinePoint;\n};\n\ntype PolylineIntersectionPoint = PolylinePoint & {\n  direction: PolylinePointDirection;\n  cloned?: boolean;\n};\n\n/**\n * Ensure all polyline point objects are pointing to the next object in case\n * it is still not point to anyone.\n * @param polylinePoints - Array that contains all polyline points (vertices and intersections)\n */\nfunction ensuresNextPointers(polylinePoints: PolylinePoint[]) {\n  // Make sure all nodes point to a valid node\n  for (let i = 0, len = polylinePoints.length; i < len; i++) {\n    const currentPoint = polylinePoints[i];\n\n    if (!currentPoint.next) {\n      currentPoint.next = polylinePoints[i === len - 1 ? 0 : i + 1];\n    }\n  }\n}\n\n/**\n * Creates one linked list per polyline that contains all vertices and intersections\n * found while walking along the edges.\n *\n * @param targetPolyline - Target polyline\n * @param sourcePolyline - Source polyline\n * @returns Two linked lists with all vertices and intersections.\n */\nfunction getSourceAndTargetPointsList(\n  targetPolyline: Types.Point2[],\n  sourcePolyline: Types.Point2[]\n) {\n  const targetPolylinePoints: PolylinePoint[] = [];\n  const sourcePolylinePoints: PolylinePoint[] = [];\n  const sourceIntersectionsCache = new Map<\n    number,\n    PolylineIntersectionPoint[]\n  >();\n\n  const isFirstPointInside = containsPoint(sourcePolyline, targetPolyline[0]);\n\n  let intersectionPointDirection = isFirstPointInside\n    ? PolylinePointDirection.Exiting\n    : PolylinePointDirection.Entering;\n\n  // Store all vertices and intersection for target contour\n  for (let i = 0, len = targetPolyline.length; i < len; i++) {\n    const p1 = targetPolyline[i];\n    const pointInside = containsPoint(sourcePolyline, p1);\n    const vertexPoint: PolylinePoint = {\n      type: PolylinePointType.Vertex,\n      coordinates: p1,\n      position: pointInside\n        ? PolylinePointPosition.Inside\n        : PolylinePointPosition.Outside,\n      visited: false,\n      next: null,\n    };\n\n    targetPolylinePoints.push(vertexPoint);\n\n    const q1 = targetPolyline[i === len - 1 ? 0 : i + 1];\n    const intersectionsInfo = getLineSegmentIntersectionsIndexes(\n      sourcePolyline,\n      p1,\n      q1\n    ).map((intersectedLineSegment) => {\n      const sourceLineSegmentId: number = intersectedLineSegment[0];\n      const p2 = sourcePolyline[intersectedLineSegment[0]];\n      const q2 = sourcePolyline[intersectedLineSegment[1]];\n\n      // lineSegment.intersectLine returns the midpoint of the four points\n      // when the lines are parallel or co-incident.  Otherwise it will return\n      // an extension of the line.\n      const intersectionCoordinate = getLinesIntersection(\n        p1,\n        q1,\n        p2,\n        q2\n      ) as Types.Point2;\n\n      const targetStartPointDistSquared = mathPoint.distanceToPointSquared(\n        p1,\n        intersectionCoordinate\n      );\n\n      return {\n        sourceLineSegmentId,\n        coordinate: intersectionCoordinate,\n        targetStartPointDistSquared,\n      };\n    });\n\n    intersectionsInfo.sort(\n      (left, right) =>\n        left.targetStartPointDistSquared - right.targetStartPointDistSquared\n    );\n\n    intersectionsInfo.forEach((intersectionInfo) => {\n      const { sourceLineSegmentId, coordinate: intersectionCoordinate } =\n        intersectionInfo;\n\n      // Intersection point to be added to the target polyline list\n      const targetEdgePoint: PolylineIntersectionPoint = {\n        type: PolylinePointType.Intersection,\n        coordinates: intersectionCoordinate,\n        position: PolylinePointPosition.Edge,\n        direction: intersectionPointDirection,\n        visited: false,\n        next: null,\n      };\n\n      // Intersection point to be added to the source polyline list.\n      // At this point there is no way to know if the point is entering or\n      // exiting the intersection region but that is not going to be used\n      // hence it is set to \"unknown\".\n      const sourceEdgePoint: PolylineIntersectionPoint = {\n        ...targetEdgePoint,\n        direction: PolylinePointDirection.Unknown,\n        cloned: true,\n      };\n\n      if (intersectionPointDirection === PolylinePointDirection.Entering) {\n        targetEdgePoint.next = sourceEdgePoint;\n      } else {\n        sourceEdgePoint.next = targetEdgePoint;\n      }\n\n      let sourceIntersectionPoints =\n        sourceIntersectionsCache.get(sourceLineSegmentId);\n\n      if (!sourceIntersectionPoints) {\n        sourceIntersectionPoints = [];\n        sourceIntersectionsCache.set(\n          sourceLineSegmentId,\n          sourceIntersectionPoints\n        );\n      }\n\n      targetPolylinePoints.push(targetEdgePoint);\n      sourceIntersectionPoints.push(sourceEdgePoint);\n\n      // Switches from \"exiting\" to \"entering\" and vice-versa\n      intersectionPointDirection *= -1;\n    });\n  }\n\n  // Store all vertices and intersections for source contour\n  for (let i = 0, len = sourcePolyline.length; i < len; i++) {\n    const lineSegmentId: number = i;\n    const p1 = sourcePolyline[i];\n    const vertexPoint: PolylinePoint = {\n      type: PolylinePointType.Vertex,\n      coordinates: p1,\n      visited: false,\n      next: null,\n    };\n\n    sourcePolylinePoints.push(vertexPoint);\n\n    const sourceIntersectionPoints =\n      sourceIntersectionsCache.get(lineSegmentId);\n\n    if (!sourceIntersectionPoints?.length) {\n      continue;\n    }\n\n    // Calculate the distance between each intersection point to the start point\n    // of the line segment, sort them by distance and return a sorted array that\n    // contains all intersection points.\n    sourceIntersectionPoints\n      .map((intersectionPoint) => ({\n        intersectionPoint,\n        lineSegStartDistSquared: mathPoint.distanceToPointSquared(\n          p1,\n          intersectionPoint.coordinates\n        ),\n      }))\n      .sort(\n        (left, right) =>\n          left.lineSegStartDistSquared - right.lineSegStartDistSquared\n      )\n      .map(({ intersectionPoint }) => intersectionPoint)\n      .forEach((intersectionPoint) =>\n        sourcePolylinePoints.push(intersectionPoint)\n      );\n  }\n\n  ensuresNextPointers(targetPolylinePoints);\n  ensuresNextPointers(sourcePolylinePoints);\n\n  return { targetPolylinePoints, sourcePolylinePoints };\n}\n\n/**\n * Get the next unvisited polyline points that is outside the intersection region.\n * @param polylinePoints - All polyline points (vertices and intersections)\n * @returns Any unvisited point that is outside the intersection region if it\n * exists or `undefined` otherwise\n */\nfunction getUnvisitedOutsidePoint(polylinePoints: PolylinePoint[]) {\n  for (let i = 0, len = polylinePoints.length; i < len; i++) {\n    const point = polylinePoints[i];\n\n    if (!point.visited && point.position === PolylinePointPosition.Outside) {\n      return point;\n    }\n  }\n}\n\n/**\n * Merge two planar polylines (2D)\n */\nfunction mergePolylines(\n  targetPolyline: Types.Point2[],\n  sourcePolyline: Types.Point2[]\n) {\n  const targetNormal = getNormal2(targetPolyline);\n  const sourceNormal = getNormal2(sourcePolyline);\n  const dotNormals = vec3.dot(sourceNormal, targetNormal);\n\n  // Both polylines need to be CW or CCW to be merged and one of them needs to\n  // be reversed if theirs orientation are not the same\n  if (!glMatrix.equals(1, dotNormals)) {\n    sourcePolyline = sourcePolyline.slice().reverse();\n  }\n\n  const { targetPolylinePoints } = getSourceAndTargetPointsList(\n    targetPolyline,\n    sourcePolyline\n  );\n  const startPoint: PolylinePoint =\n    getUnvisitedOutsidePoint(targetPolylinePoints);\n\n  // Source polyline contains target polyline\n  if (!startPoint) {\n    return targetPolyline.slice();\n  }\n\n  const mergedPolyline = [startPoint.coordinates];\n  let currentPoint = startPoint.next;\n\n  while (currentPoint !== startPoint) {\n    if (\n      currentPoint.type === PolylinePointType.Intersection &&\n      (<PolylineIntersectionPoint>currentPoint).cloned\n    ) {\n      currentPoint = currentPoint.next;\n      continue;\n    }\n\n    mergedPolyline.push(currentPoint.coordinates);\n    currentPoint = currentPoint.next;\n  }\n\n  return mergedPolyline;\n}\n\n/**\n * Subtract two planar polylines (2D)\n */\nfunction subtractPolylines(\n  targetPolyline: Types.Point2[],\n  sourcePolyline: Types.Point2[]\n): Types.Point2[][] {\n  const targetNormal = getNormal2(targetPolyline);\n  const sourceNormal = getNormal2(sourcePolyline);\n  const dotNormals = vec3.dot(sourceNormal, targetNormal);\n\n  // The polylines need to have different orientation (CW+CCW or CCW+CW) to be\n  // subtracted and one of them needs to be reversed if theirs orientation are\n  // the same\n  if (!glMatrix.equals(-1, dotNormals)) {\n    sourcePolyline = sourcePolyline.slice().reverse();\n  }\n\n  const { targetPolylinePoints } = getSourceAndTargetPointsList(\n    targetPolyline,\n    sourcePolyline\n  );\n  let startPoint: PolylinePoint = null;\n  const subtractedPolylines = [];\n\n  while ((startPoint = getUnvisitedOutsidePoint(targetPolylinePoints))) {\n    const subtractedPolyline = [startPoint.coordinates];\n    let currentPoint = startPoint.next;\n\n    startPoint.visited = true;\n\n    while (currentPoint !== startPoint) {\n      currentPoint.visited = true;\n\n      if (\n        currentPoint.type === PolylinePointType.Intersection &&\n        (<PolylineIntersectionPoint>currentPoint).cloned\n      ) {\n        currentPoint = currentPoint.next;\n        continue;\n      }\n\n      subtractedPolyline.push(currentPoint.coordinates);\n      currentPoint = currentPoint.next;\n    }\n\n    subtractedPolylines.push(subtractedPolyline);\n  }\n\n  return subtractedPolylines;\n}\n\nexport { mergePolylines, subtractPolylines };\n","import type { Types } from '@cornerstonejs/core';\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\n * `points`, and returns the first value.\n *\n * @param points - Polyline points\n * @param p1 - First point of the line segment that is being tested\n * @param q1 - Second point of the line segment that is being tested\n * @param closed - Test the intersection with the line segment that connects\n *   the last and first points of the polyline\n * @returns Indexes of the line segment points from the polyline that intersects [p1, q1]\n */\nexport default function getFirstLineSegmentIntersectionIndexes(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2 | undefined {\n  let initialI;\n  let j;\n\n  if (closed) {\n    j = points.length - 1;\n    initialI = 0;\n  } else {\n    j = 0;\n    initialI = 1;\n  }\n\n  for (let i = initialI; i < points.length; i++) {\n    const p2 = points[j];\n    const q2 = points[i];\n\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n      return [j, i];\n    }\n\n    j = i;\n  }\n}\n","import { Types } from '@cornerstonejs/core';\nimport getFirstLineSegmentIntersectionIndexes from './getFirstLineSegmentIntersectionIndexes';\n\n/**\n * Check if two polylines intersect comparing line segment by line segment.\n * @param sourcePolyline - Source polyline\n * @param targetPolyline - Target polyline\n * @returns True if the polylines intersect or false otherwise\n */\nexport default function intersectPolyline(\n  sourcePolyline: Types.Point2[],\n  targetPolyline: Types.Point2[]\n): boolean {\n  // Naive way to detect intersection between polylines in O(n^2).\n  // TODO: Implement Bentley Ottmann sweep line algorithm or maybe some\n  // algorithm that uses r-tree may make it run faster\n  for (let i = 0, sourceLen = sourcePolyline.length; i < sourceLen; i++) {\n    const sourceP1 = sourcePolyline[i];\n    const sourceP2Index = i === sourceLen - 1 ? 0 : i + 1;\n    const sourceP2 = sourcePolyline[sourceP2Index];\n\n    const intersectionPointIndexes = getFirstLineSegmentIntersectionIndexes(\n      targetPolyline,\n      sourceP1,\n      sourceP2\n    );\n\n    if (intersectionPointIndexes?.length === 2) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as mathLine from '../line';\n\nconst DEFAULT_EPSILON = 0.1;\n\n/**\n * RamerDouglasPeucker algorithm implementation to decimate a polyline\n * to a similar polyline with fewer points\n *\n * https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\n * https://rosettacode.org/wiki/Ramer-Douglas-Peucker_line_simplification\n * https://karthaus.nl/rdp/\n *\n * @param polyline - Polyline to decimate\n * @param epsilon - A maximum given distance 'epsilon' to decide if a point\n * should or shouldn't be added the decimated polyline version. In each\n * iteration the polyline is split into two polylines and the distance of each\n * point from those new polylines are checked against the line that connects\n * the first and last points.\n * @returns Decimated polyline\n */\nexport default function decimate(\n  polyline: Types.Point2[],\n  epsilon = DEFAULT_EPSILON\n) {\n  const numPoints = polyline.length;\n\n  // The polyline must have at least a start and end points\n  if (numPoints < 3) {\n    return polyline;\n  }\n\n  const epsilonSquared = epsilon * epsilon;\n  const partitionQueue = [[0, numPoints - 1]];\n\n  // Used a boolean array to set each point that will be in the decimated polyline\n  // because pre-allocated arrays are 3-4x faster than thousands of push() calls\n  // to add all points to a new array.\n  const polylinePointFlags = new Array(numPoints).fill(false);\n\n  // Start and end points are always added to the decimated polyline\n  let numDecimatedPoints = 2;\n\n  // Add start and end points to the decimated polyline\n  polylinePointFlags[0] = true;\n  polylinePointFlags[numPoints - 1] = true;\n\n  // Iterative approach using a queue instead of recursion to reduce the number\n  // of function calls (performance)\n  while (partitionQueue.length) {\n    const [startIndex, endIndex] = partitionQueue.pop();\n\n    // Return if there is no point between the start and end points\n    if (endIndex - startIndex === 1) {\n      continue;\n    }\n\n    const startPoint = polyline[startIndex];\n    const endPoint = polyline[endIndex];\n    let maxDistSquared = -Infinity;\n    let maxDistIndex = -1;\n\n    // Search for the furthest point\n    for (let i = startIndex + 1; i < endIndex; i++) {\n      const currentPoint = polyline[i];\n      const distSquared = mathLine.distanceToPointSquared(\n        startPoint,\n        endPoint,\n        currentPoint\n      );\n\n      if (distSquared > maxDistSquared) {\n        maxDistSquared = distSquared;\n        maxDistIndex = i;\n      }\n    }\n\n    // Do not add any of the points because the fursthest one is very close to\n    // the line based on the epsilon value\n    if (maxDistSquared < epsilonSquared) {\n      continue;\n    }\n\n    // Update the flag for the furthest point because it will be added to the\n    // decimated polyline\n    polylinePointFlags[maxDistIndex] = true;\n    numDecimatedPoints++;\n\n    // Partition the points into two parts using maxDistIndex as the pivot point\n    // and process both sides\n    partitionQueue.push([maxDistIndex, endIndex]);\n    partitionQueue.push([startIndex, maxDistIndex]);\n  }\n\n  // A pre-allocated array is 3-4x faster then multiple push() calls\n  const decimatedPolyline: Types.Point2[] = new Array(numDecimatedPoints);\n\n  for (let srcIndex = 0, dstIndex = 0; srcIndex < numPoints; srcIndex++) {\n    if (polylinePointFlags[srcIndex]) {\n      decimatedPolyline[dstIndex++] = polyline[srcIndex];\n    }\n  }\n\n  return decimatedPolyline;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport getLineSegmentIntersectionsIndexes from './getLineSegmentIntersectionsIndexes';\nimport getLinesIntersection from './getLinesIntersection';\n\n/**\n * Returns all intersections points between a line segment and a polyline\n */\nexport default function getLineSegmentIntersectionsCoordinates(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2[] {\n  const result = [];\n  const polylineIndexes = getLineSegmentIntersectionsIndexes(\n    points,\n    p1,\n    q1,\n    closed\n  );\n\n  for (let i = 0; i < polylineIndexes.length; i++) {\n    const p2 = points[polylineIndexes[i][0]];\n    const q2 = points[polylineIndexes[i][1]];\n    const intersection = getLinesIntersection(p1, q1, p2, q2);\n    result.push(intersection);\n  }\n\n  return result;\n}\n","import { vec2 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\n * `points`, and returns the closest value.\n * @param points - Polyline points\n * @param p1 - Start point of the line segment\n * @param q1 - End point of the line segment\n * @param closed - Test the intersection against the line that connects the first to the last when closed\n * @returns The closest line segment from polyline that intersects the line segment [p1, q1]\n */\nexport default function getClosestLineSegmentIntersection(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): { segment: Types.Point2; distance: number } | undefined {\n  let initialQ2Index;\n  let p2Index;\n\n  if (closed) {\n    p2Index = points.length - 1;\n    initialQ2Index = 0;\n  } else {\n    p2Index = 0;\n    initialQ2Index = 1;\n  }\n\n  const intersections = [];\n\n  for (let q2Index = initialQ2Index; q2Index < points.length; q2Index++) {\n    const p2 = points[p2Index];\n    const q2 = points[q2Index];\n\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n      intersections.push([p2Index, q2Index]);\n    }\n\n    p2Index = q2Index;\n  }\n\n  if (intersections.length === 0) {\n    return;\n  }\n\n  // Find intersection closest to the start point\n  const distances = [];\n\n  intersections.forEach((intersection) => {\n    const intersectionPoints = [\n      points[intersection[0]],\n      points[intersection[1]],\n    ];\n\n    const midpoint = [\n      (intersectionPoints[0][0] + intersectionPoints[1][0]) / 2,\n      (intersectionPoints[0][1] + intersectionPoints[1][1]) / 2,\n    ];\n\n    distances.push(vec2.distance(<vec2>midpoint, p1));\n  });\n\n  const minDistance = Math.min(...distances);\n  const indexOfMinDistance = distances.indexOf(minDistance);\n\n  return {\n    segment: intersections[indexOfMinDistance],\n    distance: minDistance,\n  };\n}\n","import { StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nconst EPSILON = 1e-3;\n\n/**\n * Gets the desired spacing for points in the polyline for the\n * `PlanarFreehandROITool` in the x and y canvas directions, as well as\n * returning these canvas directions in world space.\n *\n * @param viewport - The Cornerstone3D `StackViewport` or `VolumeViewport`.\n * @param subPixelResolution - The number to divide the image pixel spacing by\n * to get the sub pixel spacing. E.g. `10` will return spacings 10x smaller than\n * the native image spacing.\n * @returns The spacings of the X and Y directions, and the 3D directions of the\n * x and y directions.\n */\nconst getSubPixelSpacingAndXYDirections = (\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  subPixelResolution: number\n): { spacing: Types.Point2; xDir: Types.Point3; yDir: Types.Point3 } => {\n  let spacing;\n  let xDir;\n  let yDir;\n\n  if (viewport instanceof StackViewport) {\n    // Check XY directions\n    const imageData = viewport.getImageData();\n\n    xDir = imageData.direction.slice(0, 3);\n    yDir = imageData.direction.slice(3, 6);\n\n    spacing = imageData.spacing;\n  } else {\n    // Check volume directions\n    const imageData = viewport.getImageData();\n    const { direction, spacing: volumeSpacing } = imageData;\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    // Calculate size of spacing vector in normal direction\n    const iVector = direction.slice(0, 3) as Types.Point3;\n    const jVector = direction.slice(3, 6) as Types.Point3;\n    const kVector = direction.slice(6, 9) as Types.Point3;\n\n    const viewRight = vec3.create(); // Get the X direction of the viewport\n\n    vec3.cross(viewRight, <vec3>viewUp, <vec3>viewPlaneNormal);\n\n    const absViewRightDotI = Math.abs(vec3.dot(viewRight, iVector));\n    const absViewRightDotJ = Math.abs(vec3.dot(viewRight, jVector));\n    const absViewRightDotK = Math.abs(vec3.dot(viewRight, kVector));\n\n    // Get X spacing\n    let xSpacing;\n    if (Math.abs(1 - absViewRightDotI) < EPSILON) {\n      xSpacing = volumeSpacing[0];\n      xDir = iVector;\n    } else if (Math.abs(1 - absViewRightDotJ) < EPSILON) {\n      xSpacing = volumeSpacing[1];\n      xDir = jVector;\n    } else if (Math.abs(1 - absViewRightDotK) < EPSILON) {\n      xSpacing = volumeSpacing[2];\n      xDir = kVector;\n    } else {\n      throw new Error('No support yet for oblique plane planar contours');\n    }\n\n    const absViewUpDotI = Math.abs(vec3.dot(viewUp, iVector));\n    const absViewUpDotJ = Math.abs(vec3.dot(viewUp, jVector));\n    const absViewUpDotK = Math.abs(vec3.dot(viewUp, kVector));\n\n    // Get Y spacing\n    let ySpacing;\n    if (Math.abs(1 - absViewUpDotI) < EPSILON) {\n      ySpacing = volumeSpacing[0];\n      yDir = iVector;\n    } else if (Math.abs(1 - absViewUpDotJ) < EPSILON) {\n      ySpacing = volumeSpacing[1];\n      yDir = jVector;\n    } else if (Math.abs(1 - absViewUpDotK) < EPSILON) {\n      ySpacing = volumeSpacing[2];\n      yDir = kVector;\n    } else {\n      throw new Error('No support yet for oblique plane planar contours');\n    }\n\n    spacing = [xSpacing, ySpacing];\n  }\n\n  const subPixelSpacing: Types.Point2 = [\n    spacing[0] / subPixelResolution,\n    spacing[1] / subPixelResolution,\n  ];\n\n  return { spacing: subPixelSpacing, xDir, yDir };\n};\n\nexport default getSubPixelSpacingAndXYDirections;\n","import { vec2 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Returns true if points `p1` and `p2` are within `closeContourProximity`.\n */\nconst pointsAreWithinCloseContourProximity = (\n  p1: Types.Point2,\n  p2: Types.Point2,\n  closeContourProximity: number\n): boolean => {\n  return vec2.dist(p1, p2) < closeContourProximity;\n};\n\nexport default pointsAreWithinCloseContourProximity;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec2, vec3 } from 'gl-matrix';\nimport { PlanarFreehandROICommonData } from './planarFreehandROIInternalTypes';\n\n/**\n * Adds one or more points to the array at a resolution defined by the underlying image.\n */\nconst addCanvasPointsToArray = (\n  element: HTMLDivElement,\n  canvasPoints: Types.Point2[],\n  newCanvasPoint: Types.Point2,\n  commonData: PlanarFreehandROICommonData\n): number => {\n  const { xDir, yDir, spacing } = commonData;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  if (!canvasPoints.length) {\n    canvasPoints.push(newCanvasPoint);\n    console.log('>>>>> !canvasPoints. :: RETURN');\n    return 1;\n  }\n\n  const lastWorldPos = viewport.canvasToWorld(\n    canvasPoints[canvasPoints.length - 1]\n  );\n  const newWorldPos = viewport.canvasToWorld(newCanvasPoint);\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, newWorldPos, lastWorldPos);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  const numPointsToAdd = Math.max(\n    Math.floor(xDist / spacing[0]),\n    Math.floor(yDist / spacing[0])\n  );\n\n  if (numPointsToAdd > 1) {\n    const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n\n    const canvasDist = vec2.dist(lastCanvasPoint, newCanvasPoint);\n\n    const canvasDir = vec2.create();\n\n    vec2.subtract(canvasDir, newCanvasPoint, lastCanvasPoint);\n\n    vec2.set(canvasDir, canvasDir[0] / canvasDist, canvasDir[1] / canvasDist);\n\n    const distPerPoint = canvasDist / numPointsToAdd;\n\n    for (let i = 1; i <= numPointsToAdd; i++) {\n      canvasPoints.push([\n        lastCanvasPoint[0] + distPerPoint * canvasDir[0] * i,\n        lastCanvasPoint[1] + distPerPoint * canvasDir[1] * i,\n      ]);\n    }\n  } else {\n    canvasPoints.push(newCanvasPoint);\n  }\n\n  return numPointsToAdd;\n};\n\nexport default addCanvasPointsToArray;\n","import type { Types } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\n\n/**\n * Returns `true` if the point `p` can project onto point (`p1`, `p2`), and if\n * this projected point is less than `proximity` units away.\n */\nconst pointCanProjectOnLine = (\n  p: Types.Point2,\n  p1: Types.Point2,\n  p2: Types.Point2,\n  proximity: number\n): boolean => {\n  // Perfom checks in order of computational complexity.\n  const p1p = [p[0] - p1[0], p[1] - p1[1]];\n  const p1p2 = [p2[0] - p1[0], p2[1] - p1[1]];\n\n  const dot = p1p[0] * p1p2[0] + p1p[1] * p1p2[1];\n\n  // Dot product needs to be positive to be a candidate for projection onto line segment.\n  if (dot < 0) {\n    return false;\n  }\n\n  const p1p2Mag = Math.sqrt(p1p2[0] * p1p2[0] + p1p2[1] * p1p2[1]);\n\n  if (p1p2Mag === 0) {\n    return false;\n  }\n\n  const projectionVectorMag = dot / p1p2Mag;\n  const p1p2UnitVector = [p1p2[0] / p1p2Mag, p1p2[1] / p1p2Mag];\n  const projectionVector = [\n    p1p2UnitVector[0] * projectionVectorMag,\n    p1p2UnitVector[1] * projectionVectorMag,\n  ];\n  const projectionPoint = <Types.Point2>[\n    p1[0] + projectionVector[0],\n    p1[1] + projectionVector[1],\n  ];\n\n  const distance = vec2.distance(p, projectionPoint);\n\n  if (distance > proximity) {\n    // point is too far away.\n    return false;\n  }\n\n  // Check projects onto line segment.\n  if (vec2.distance(p1, projectionPoint) > vec2.distance(p1, p2)) {\n    return false;\n  }\n\n  return true;\n};\n\nexport default pointCanProjectOnLine;\n","import { utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nconst epsilon = 1e-6;\n\n/**\n * Projects a polyline from 3D to 2D by reducing one dimension.\n *\n * @param polyline - The polyline to be projected.\n * @returns An object containing the shared dimension index and the projected polyline in 2D.\n * @throws Error if a shared dimension index cannot be found for the polyline.\n */\nexport function projectTo2D(polyline: Types.Point3[]) {\n  // We need to reduce one dimension to 2D, so basically\n  // we need to find the dimension index that is shared by all points\n  // Use the first three points, two is enough but three is more robust\n  let sharedDimensionIndex;\n\n  const testPoints = utilities.getRandomSampleFromArray(polyline, 50);\n\n  for (let i = 0; i < 3; i++) {\n    if (\n      testPoints.every(\n        (point, index, array) => Math.abs(point[i] - array[0][i]) < epsilon\n      )\n    ) {\n      sharedDimensionIndex = i;\n      break;\n    }\n  }\n\n  if (sharedDimensionIndex === undefined) {\n    throw new Error(\n      'Cannot find a shared dimension index for polyline, probably oblique plane'\n    );\n  }\n\n  // convert polyline list and point to 2D\n  const points2D = [] as Types.Point2[];\n\n  const firstDim = (sharedDimensionIndex + 1) % 3;\n  const secondDim = (sharedDimensionIndex + 2) % 3;\n\n  for (let i = 0; i < polyline.length; i++) {\n    points2D.push([polyline[i][firstDim], polyline[i][secondDim]]);\n  }\n\n  return {\n    sharedDimensionIndex,\n    projectedPolyline: points2D,\n  };\n}\n","import type { Types } from '@cornerstonejs/core';\nimport containsPoint from './containsPoint';\nimport { projectTo2D } from './projectTo2D';\n\n/**\n * Determines whether a 3D point is inside a polyline in 3D space.\n *\n * The algorithm works by reducing the polyline and point to 2D space, and then\n * using the 2D algorithm to determine whether the point is inside the polyline.\n *\n * @param point - The 3D point to test.\n * @param polyline - The polyline represented as an array of 3D points.\n * @param options.holesPolyline - An array of polylines representing each hole, so it\n * is an array of arrays of 3D points.\n * @returns A boolean indicating whether the point is inside the polyline.\n * @throws An error if a shared dimension index cannot be found for the polyline points.\n */\nexport function isPointInsidePolyline3D(\n  point: Types.Point3,\n  polyline: Types.Point3[],\n  options: { holes?: Types.Point3[][] } = {}\n) {\n  const { sharedDimensionIndex, projectedPolyline } = projectTo2D(polyline);\n\n  const { holes } = options;\n  const projectedHoles = [] as Types.Point2[][];\n\n  if (holes) {\n    for (let i = 0; i < holes.length; i++) {\n      const hole = holes[i];\n      const hole2D = [] as Types.Point2[];\n\n      for (let j = 0; j < hole.length; j++) {\n        hole2D.push([\n          hole[j][(sharedDimensionIndex + 1) % 3],\n          hole[j][(sharedDimensionIndex + 2) % 3],\n        ]);\n      }\n\n      projectedHoles.push(hole2D);\n    }\n  }\n\n  const point2D = [\n    point[(sharedDimensionIndex + 1) % 3],\n    point[(sharedDimensionIndex + 2) % 3],\n  ] as Types.Point2;\n\n  return containsPoint(projectedPolyline, point2D, { holes: projectedHoles });\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as lineSegment from '../line';\n\ntype rectLineSegments = {\n  top: Types.Point2[];\n  right: Types.Point2[];\n  bottom: Types.Point2[];\n  left: Types.Point2[];\n};\n\n/**\n * Given a rectangle left, top, width and height, return an object containing the\n * line segments that make up the rectangle's four sides\n * @param left - The x-coordinate of the left edge of the rectangle.\n * @param top - The y-coordinate of the top edge of the rectangle.\n * @param width - The width of the rectangle.\n * @param height - The height of the rectangle.\n * @returns An object with four keys, each of which contains an array of two\n * points.\n */\nfunction rectToLineSegments(\n  left: number,\n  top: number,\n  width: number,\n  height: number\n): rectLineSegments {\n  const topLineStart: Types.Point2 = [left, top];\n  const topLineEnd: Types.Point2 = [left + width, top];\n\n  const rightLineStart: Types.Point2 = [left + width, top];\n  const rightLineEnd: Types.Point2 = [left + width, top + height];\n\n  const bottomLineStart: Types.Point2 = [left + width, top + height];\n  const bottomLineEnd: Types.Point2 = [left, top + height];\n\n  const leftLineStart: Types.Point2 = [left, top + height];\n  const leftLineEnd: Types.Point2 = [left, top];\n\n  const lineSegments = {\n    top: [topLineStart, topLineEnd],\n    right: [rightLineStart, rightLineEnd],\n    bottom: [bottomLineStart, bottomLineEnd],\n    left: [leftLineStart, leftLineEnd],\n  };\n\n  return lineSegments;\n}\n\n/**\n * Calculates distance of the point to the rectangle. It calculates the minimum\n * distance between the point and each line segment of the rectangle.\n *\n * @param rect - coordinates of the rectangle [left, top, width, height]\n * @param point - [x,y] coordinates of a point\n * @returns\n */\nexport default function distanceToPoint(\n  rect: number[],\n  point: Types.Point2\n): number {\n  if (rect.length !== 4 || point.length !== 2) {\n    throw Error(\n      'rectangle:[left, top, width, height] or point: [x,y] not defined correctly'\n    );\n  }\n\n  const [left, top, width, height] = rect;\n\n  let minDistance = 655535;\n  const lineSegments = rectToLineSegments(left, top, width, height);\n\n  Object.keys(lineSegments).forEach((segment) => {\n    const [lineStart, lineEnd] = lineSegments[segment];\n    const distance = lineSegment.distanceToPoint(lineStart, lineEnd, point);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n    }\n  });\n\n  return minDistance;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\ntype Sphere = {\n  center: Types.Point3 | vec3;\n  radius: number;\n  // Square of the radius\n  radius2?: number;\n};\n\n/**\n * Checks if a point is inside a sphere. Note: this is similar to the\n * `pointInEllipse` function, but since we don't need checks for the\n * ellipse's rotation in different views, we can use a simpler equation\n * which would be faster (no if statements).\n *\n * This is safe to call for point in circle as long as you don't call it with\n * anything off-plane - that is, a circle is a degenerate sphere that is\n * intersected with the primary plane.\n *\n * @param sphere - Sphere object with center and radius and radius squared\n *     as radius2 if you are calling this a huge number of times.\n * @param pointLPS - the point to check in world coordinates\n * @returns boolean\n */\nexport default function pointInSphere(sphere: Sphere, pointLPS: vec3): boolean {\n  const { center, radius } = sphere;\n  const radius2 = sphere.radius2 || radius * radius;\n\n  return (\n    (pointLPS[0] - center[0]) * (pointLPS[0] - center[0]) +\n      (pointLPS[1] - center[1]) * (pointLPS[1] - center[1]) +\n      (pointLPS[2] - center[2]) * (pointLPS[2] - center[2]) <=\n    radius2\n  );\n}\n","// Pulled from source: https://github.com/w8r/liang-barsky\n// MIT Licensed.\n\n/**\n * Fast, destructive implementation of Liang-Barsky line clipping algorithm.\n * It clips a 2D segment by a rectangle.\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n */\n\nconst EPSILON = 1e-6;\nconst INSIDE = 1;\nconst OUTSIDE = 0;\n\nfunction clipT(num, denom, c) {\n  const [tE, tL] = c;\n  if (Math.abs(denom) < EPSILON) {\n    return num < 0;\n  }\n  const t = num / denom;\n\n  if (denom > 0) {\n    if (t > tL) {\n      return 0;\n    }\n    if (t > tE) {\n      c[0] = t;\n    }\n  } else {\n    if (t < tE) {\n      return 0;\n    }\n    if (t < tL) {\n      c[1] = t;\n    }\n  }\n  return 1;\n}\n\n/**\n * @param  {Point} a\n * @param  {Point} b\n * @param  {BoundingBox} box [xmin, ymin, xmax, ymax]\n * @param  {Point?} [da]\n * @param  {Point?} [db]\n * @return {number}\n */\nexport default function clip(a, b, box, da?, db?) {\n  const [x1, y1] = a;\n  const [x2, y2] = b;\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n\n  if (da === undefined || db === undefined) {\n    da = a;\n    db = b;\n  } else {\n    da[0] = a[0];\n    da[1] = a[1];\n    db[0] = b[0];\n    db[1] = b[1];\n  }\n\n  if (\n    Math.abs(dx) < EPSILON &&\n    Math.abs(dy) < EPSILON &&\n    x1 >= box[0] &&\n    x1 <= box[2] &&\n    y1 >= box[1] &&\n    y1 <= box[3]\n  ) {\n    return INSIDE;\n  }\n\n  const c = [0, 1];\n  if (\n    clipT(box[0] - x1, dx, c) &&\n    clipT(x1 - box[2], -dx, c) &&\n    clipT(box[1] - y1, dy, c) &&\n    clipT(y1 - box[3], -dy, c)\n  ) {\n    const [tE, tL] = c;\n    if (tL < 1) {\n      db[0] = x1 + tL * dx;\n      db[1] = y1 + tL * dy;\n    }\n    if (tE > 0) {\n      da[0] += tE * dx;\n      da[1] += tE * dy;\n    }\n    return INSIDE;\n  }\n  return OUTSIDE;\n}\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the orientation of the vector in the patient coordinate system.\n * @public\n *\n * @param vector - Input array\n * @returns The orientation in the patient coordinate system.\n */\nexport default function getOrientationStringLPS(vector: Types.Point3): string {\n  // Thanks to David Clunie\n  // https://sites.google.com/site/dicomnotes/\n\n  let orientation = '';\n  const orientationX = vector[0] < 0 ? 'R' : 'L';\n  const orientationY = vector[1] < 0 ? 'A' : 'P';\n  const orientationZ = vector[2] < 0 ? 'F' : 'H';\n\n  // Should probably make this a function vector3.abs\n  const abs = [Math.abs(vector[0]), Math.abs(vector[1]), Math.abs(vector[2])];\n\n  const MIN = 0.0001;\n\n  for (let i = 0; i < 3; i++) {\n    if (abs[0] > MIN && abs[0] > abs[1] && abs[0] > abs[2]) {\n      orientation += orientationX;\n      abs[0] = 0;\n    } else if (abs[1] > MIN && abs[1] > abs[0] && abs[1] > abs[2]) {\n      orientation += orientationY;\n      abs[1] = 0;\n    } else if (abs[2] > MIN && abs[2] > abs[0] && abs[2] > abs[1]) {\n      orientation += orientationZ;\n      abs[2] = 0;\n    } else if (abs[0] > MIN && abs[1] > MIN && abs[0] === abs[1]) {\n      orientation += orientationX + orientationY;\n      abs[0] = 0;\n      abs[1] = 0;\n    } else if (abs[0] > MIN && abs[2] > MIN && abs[0] === abs[2]) {\n      orientation += orientationX + orientationZ;\n      abs[0] = 0;\n      abs[2] = 0;\n    } else if (abs[1] > MIN && abs[2] > MIN && abs[1] === abs[2]) {\n      orientation += orientationY + orientationZ;\n      abs[1] = 0;\n      abs[2] = 0;\n    } else {\n      break;\n    }\n  }\n\n  return orientation;\n}\n","/**\n * Inverts an orientation string.\n * @public\n *\n * @param orientationString - The orientation.\n * @returns The inverted orientationString.\n */\nexport default function invertOrientationStringLPS(\n  orientationString: string\n): string {\n  let inverted = orientationString.replace('H', 'f');\n\n  inverted = inverted.replace('F', 'h');\n  inverted = inverted.replace('R', 'l');\n  inverted = inverted.replace('L', 'r');\n  inverted = inverted.replace('A', 'p');\n  inverted = inverted.replace('P', 'a');\n  inverted = inverted.toUpperCase();\n\n  return inverted;\n}\n","import filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nimport getWorldWidthAndHeightFromCorners from './getWorldWidthAndHeightFromCorners';\nimport filterAnnotationsForDisplay from './filterAnnotationsForDisplay';\nimport getPointInLineOfSightWithCriteria from './getPointInLineOfSightWithCriteria';\nimport { isPlaneIntersectingAABB } from './isPlaneIntersectingAABB';\n\nexport default {\n  filterAnnotationsWithinSlice,\n  getWorldWidthAndHeightFromCorners,\n  filterAnnotationsForDisplay,\n  getPointInLineOfSightWithCriteria,\n  isPlaneIntersectingAABB,\n};\n\nexport {\n  filterAnnotationsWithinSlice,\n  getWorldWidthAndHeightFromCorners,\n  filterAnnotationsForDisplay,\n  getPointInLineOfSightWithCriteria,\n  isPlaneIntersectingAABB,\n};\n","import smoothAnnotation from './smoothAnnotation';\n\nexport default {\n  smoothAnnotation,\n};\n\nexport { smoothAnnotation };\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport BoundsIJK from '../types/BoundsIJK';\n\nexport type PointInShape = {\n  value: number;\n  index: number;\n  pointIJK: vec3;\n  pointLPS: vec3 | number[];\n};\n\nexport type PointInShapeCallback = ({\n  value,\n  index,\n  pointIJK,\n  pointLPS,\n}: {\n  value: number;\n  index: number;\n  pointIJK: vec3;\n  pointLPS: vec3;\n}) => void;\n\nexport type ShapeFnCriteria = (pointLPS: vec3, pointIJK: vec3) => boolean;\n\n/**\n * For each point in the image (If boundsIJK is not provided, otherwise, for each\n * point in the provided bounding box), It runs the provided callback IF the point\n * passes the provided criteria to be inside the shape (which is defined by the\n * provided pointInShapeFn)\n *\n * @param imageData - The image data object.\n * @param dimensions - The dimensions of the image.\n * @param pointInShapeFn - A function that takes a point in LPS space and returns\n * true if the point is in the shape and false if it is not.\n * @param callback - A function that will be called for\n * every point in the shape.\n * @param boundsIJK - The bounds of the volume in IJK coordinates.\n */\nexport default function pointInShapeCallback(\n  imageData: vtkImageData | Types.CPUImageData,\n  pointInShapeFn: ShapeFnCriteria,\n  callback?: PointInShapeCallback,\n  boundsIJK?: BoundsIJK\n): Array<PointInShape> {\n  let iMin, iMax, jMin, jMax, kMin, kMax;\n\n  let scalarData;\n  const { numComps } = imageData as any;\n\n  // if getScalarData is a method on imageData\n  if ((imageData as Types.CPUImageData).getScalarData) {\n    scalarData = (imageData as Types.CPUImageData).getScalarData();\n  } else {\n    scalarData = (imageData as vtkImageData)\n      .getPointData()\n      .getScalars()\n      .getData();\n  }\n\n  if (!scalarData) {\n    console.warn('No scalar data found for imageData', imageData);\n    return;\n  }\n\n  const dimensions = imageData.getDimensions();\n\n  if (!boundsIJK) {\n    iMin = 0;\n    iMax = dimensions[0];\n    jMin = 0;\n    jMax = dimensions[1];\n    kMin = 0;\n    kMax = dimensions[2];\n  } else {\n    [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = boundsIJK;\n  }\n\n  const start = vec3.fromValues(iMin, jMin, kMin);\n\n  const direction = imageData.getDirection();\n  const rowCosines = direction.slice(0, 3);\n  const columnCosines = direction.slice(3, 6);\n  const scanAxisNormal = direction.slice(6, 9);\n\n  const spacing = imageData.getSpacing();\n  const [rowSpacing, columnSpacing, scanAxisSpacing] = spacing;\n\n  // @ts-ignore will be fixed in vtk-master\n  const worldPosStart = imageData.indexToWorld(start);\n\n  const rowStep = vec3.fromValues(\n    rowCosines[0] * rowSpacing,\n    rowCosines[1] * rowSpacing,\n    rowCosines[2] * rowSpacing\n  );\n\n  const columnStep = vec3.fromValues(\n    columnCosines[0] * columnSpacing,\n    columnCosines[1] * columnSpacing,\n    columnCosines[2] * columnSpacing\n  );\n\n  const scanAxisStep = vec3.fromValues(\n    scanAxisNormal[0] * scanAxisSpacing,\n    scanAxisNormal[1] * scanAxisSpacing,\n    scanAxisNormal[2] * scanAxisSpacing\n  );\n\n  const xMultiple =\n    numComps ||\n    scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];\n  const yMultiple = dimensions[0] * xMultiple;\n  const zMultiple = dimensions[1] * yMultiple;\n\n  const pointsInShape: Array<PointInShape> = [];\n\n  const currentPos = vec3.clone(worldPosStart);\n\n  for (let k = kMin; k <= kMax; k++) {\n    const startPosJ = vec3.clone(currentPos);\n\n    for (let j = jMin; j <= jMax; j++) {\n      const startPosI = vec3.clone(currentPos);\n\n      for (let i = iMin; i <= iMax; i++) {\n        const pointIJK: Types.Point3 = [i, j, k];\n\n        // The current world position (pointLPS) is now in currentPos\n        if (pointInShapeFn(currentPos as Types.Point3, pointIJK)) {\n          const index = k * zMultiple + j * yMultiple + i * xMultiple;\n          let value;\n          if (xMultiple > 2) {\n            value = [\n              scalarData[index],\n              scalarData[index + 1],\n              scalarData[index + 2],\n            ];\n          } else {\n            value = scalarData[index];\n          }\n\n          pointsInShape.push({\n            value,\n            index,\n            pointIJK,\n            pointLPS: currentPos.slice(),\n          });\n          if (callback) {\n            callback({ value, index, pointIJK, pointLPS: currentPos });\n          }\n        }\n\n        // Increment currentPos by rowStep for the next iteration\n        vec3.add(currentPos, currentPos, rowStep);\n      }\n\n      // Reset currentPos to the start of the next J line and increment by columnStep\n      vec3.copy(currentPos, startPosI);\n      vec3.add(currentPos, currentPos, columnStep);\n    }\n\n    // Reset currentPos to the start of the next K slice and increment by scanAxisStep\n    vec3.copy(currentPos, startPosJ);\n    vec3.add(currentPos, currentPos, scanAxisStep);\n  }\n\n  return pointsInShape;\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { vec3 } from 'gl-matrix';\nimport { pointInSphere } from './math/sphere';\nimport pointInShapeCallback, {\n  PointInShapeCallback,\n} from './pointInShapeCallback';\nimport { BoundsIJK } from '../types';\nimport { getBoundingBoxAroundShape } from './boundingBox';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * Given an imageData, and the great circle top and bottom points of a sphere,\n * this function will run the callback for each point of the imageData that is\n * within the sphere defined by the great circle points. If the viewport\n * is provided, region of interest will be an accurate approximation of the\n * sphere (using viewport camera), and the resulting performance will be\n * better.\n *\n * @privateRemarks great circle also known as orthodrome is the intersection of\n * the sphere and the plane that passes through the center of the sphere\n *\n * @param imageData - The volume imageData\n * @param circlePoints - bottom and top points of the great circle in world coordinates\n * @param callback - A callback function that will be called for each point in the shape.\n */\nexport default function pointInSurroundingSphereCallback(\n  imageData: vtkImageData,\n  circlePoints: [Types.Point3, Types.Point3],\n  callback: PointInShapeCallback,\n  viewport?: Types.IVolumeViewport\n): void {\n  // We can run the sphere equation to determine if a point is inside\n  // the sphere; however, since the imageData dimensions can be quite large, we\n  // can narrow down the search by estimating the bounds of the sphere in index\n  // space.\n  const { boundsIJK, centerWorld, radiusWorld } = _getBounds(\n    circlePoints,\n    imageData,\n    viewport\n  );\n\n  const sphereObj = {\n    center: centerWorld,\n    radius: radiusWorld,\n  };\n\n  pointInShapeCallback(\n    imageData,\n    (pointLPS) => pointInSphere(sphereObj, pointLPS),\n    callback,\n    boundsIJK\n  );\n}\n\nfunction _getBounds(\n  circlePoints: [Types.Point3, Types.Point3],\n  imageData: vtkImageData,\n  viewport\n): {\n  boundsIJK: BoundsIJK;\n  centerWorld: Types.Point3;\n  radiusWorld: number;\n} {\n  const [bottom, top] = circlePoints;\n\n  // Sphere center in world\n  const centerWorld = vec3.fromValues(\n    (bottom[0] + top[0]) / 2,\n    (bottom[1] + top[1]) / 2,\n    (bottom[2] + top[2]) / 2\n  );\n\n  // sphere radius in world\n  const radiusWorld = vec3.distance(bottom, top) / 2;\n\n  let boundsIJK;\n\n  if (!viewport) {\n    // If no viewport is provide (no camera), we can estimate the bounding box\n    // of the sphere in index space.\n    // This is done by calculating the maximum value for radius in the index\n    // space (since the radius is in world space, we need to convert it to index, and\n    // each dimensions can have a different scale factor). Therefore, by finding\n    // the minimum spacing value in the imageData, we can calculate the maximum\n    // radius in index space and use that to calculate the bounds of the sphere\n    // This will not be accurate, but it is a good first approximation.\n    // sphere center in index\n    const centerIJK = transformWorldToIndex(\n      imageData,\n      centerWorld as Types.Point3\n    );\n\n    const spacings = imageData.getSpacing();\n    const minSpacing = Math.min(...spacings);\n\n    const maxRadiusIJK = Math.ceil(radiusWorld / minSpacing);\n\n    boundsIJK = [\n      [centerIJK[0] - maxRadiusIJK, centerIJK[0] + maxRadiusIJK],\n      [centerIJK[1] - maxRadiusIJK, centerIJK[1] + maxRadiusIJK],\n      [centerIJK[2] - maxRadiusIJK, centerIJK[2] + maxRadiusIJK],\n    ];\n\n    return {\n      boundsIJK,\n      centerWorld: centerWorld as Types.Point3,\n      radiusWorld,\n    };\n  }\n\n  boundsIJK = _computeBoundsIJKWithCamera(\n    imageData,\n    viewport,\n    circlePoints,\n    centerWorld,\n    radiusWorld\n  );\n\n  return {\n    boundsIJK,\n    centerWorld: centerWorld as Types.Point3,\n    radiusWorld,\n  };\n}\n\nfunction _computeBoundsIJKWithCamera(\n  imageData,\n  viewport,\n  circlePoints,\n  centerWorld,\n  radiusWorld\n) {\n  const [bottom, top] = circlePoints;\n\n  const dimensions = imageData.getDimensions() as Types.Point3;\n  const camera = viewport.getCamera();\n\n  // Calculate viewRight from the camera, this will get used in order to\n  // calculate circles topLeft and bottomRight on different planes of intersection\n  // between sphere and viewPlane\n  const viewUp = vec3.fromValues(\n    camera.viewUp[0],\n    camera.viewUp[1],\n    camera.viewUp[2]\n  );\n  const viewPlaneNormal = vec3.fromValues(\n    camera.viewPlaneNormal[0],\n    camera.viewPlaneNormal[1],\n    camera.viewPlaneNormal[2]\n  );\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n  // we need to find the bounding box of the sphere in the image, e.g., the\n  // topLeftWorld and bottomRightWorld points of the bounding box.\n  // We go from the sphereCenter in the normal direction of amount radius, and\n  // we go left to find the topLeftWorld point of the bounding box. Next we go\n  // in the opposite direction and go right to find the bottomRightWorld point\n  // of the bounding box.\n  const topLeftWorld = vec3.create();\n  const bottomRightWorld = vec3.create();\n\n  vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\n\n  // go in the direction of viewRight with the value of radius\n  vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\n\n  // convert the world coordinates to index coordinates\n\n  const sphereCornersIJK = [\n    <Types.Point3>transformWorldToIndex(imageData, <Types.Point3>topLeftWorld),\n    <Types.Point3>(\n      transformWorldToIndex(imageData, <Types.Point3>bottomRightWorld)\n    ),\n  ];\n\n  // get the bounding box of the sphere in the image\n  const boundsIJK = getBoundingBoxAroundShape(sphereCornersIJK, dimensions);\n\n  return boundsIJK;\n}\n","export function pointToString(point, decimals = 5) {\n  return (\n    parseFloat(point[0]).toFixed(decimals) +\n    ',' +\n    parseFloat(point[1]).toFixed(decimals) +\n    ',' +\n    parseFloat(point[2]).toFixed(decimals) +\n    ','\n  );\n}\n","import vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\n/**\n * Gets a point from an array of numbers given its index\n * @param points - array of number, each point defined by three consecutive numbers\n * @param idx - index of the point to retrieve\n * @returns\n */\nexport function getPoint(points, idx): Types.Point3 {\n  const idx3 = idx * 3;\n  if (idx3 < points.length) {\n    return vec3.fromValues(\n      points[idx3],\n      points[idx3 + 1],\n      points[idx3 + 2]\n    ) as Types.Point3;\n  }\n}\n\n/**\n * Extract contour point sets from the outline of a poly data actor\n * @param polyData - vtk polyData\n * @returns\n */\nexport function getPolyDataPointIndexes(polyData: vtkPolyData) {\n  const linesData = polyData.getLines().getData();\n  let idx = 0;\n  const lineSegments = new Map<number, number[]>();\n\n  // Populate lineSegments map\n  while (idx < linesData.length) {\n    const segmentSize = linesData[idx++];\n    const segment = [];\n    for (let i = 0; i < segmentSize; i++) {\n      segment.push(linesData[idx + i]);\n    }\n    lineSegments.set(segment[0], segment);\n    idx += segmentSize;\n  }\n\n  const contours = [];\n\n  // Function to find an available starting point\n  const findStartingPoint = (map) => {\n    for (const [key, value] of map.entries()) {\n      if (value !== undefined) {\n        return key;\n      }\n    }\n    return -1;\n  };\n\n  // Build contours\n  let startPoint = findStartingPoint(lineSegments);\n  while (startPoint !== -1) {\n    const contour = [startPoint];\n    while (lineSegments.has(startPoint)) {\n      const nextPoint = lineSegments.get(startPoint)[1];\n      if (lineSegments.has(nextPoint)) {\n        contour.push(nextPoint);\n      }\n      lineSegments.delete(startPoint);\n      startPoint = nextPoint;\n    }\n    contours.push(contour);\n    startPoint = findStartingPoint(lineSegments);\n  }\n\n  return contours.length ? contours : undefined;\n}\n\n/**\n * Extract contour points from a poly data object\n * @param polyData - vtk polyData\n * @returns\n */\nexport function getPolyDataPoints(polyData: vtkPolyData) {\n  const contoursIndexes = getPolyDataPointIndexes(polyData);\n  if (!contoursIndexes) {\n    return;\n  }\n\n  const rawPointsData = polyData.getPoints().getData();\n  return contoursIndexes.map((contourIndexes) =>\n    contourIndexes.map((index) => getPoint(rawPointsData, index))\n  );\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\nimport extend2DBoundingBoxInViewAxis from '../boundingBox/extend2DBoundingBoxInViewAxis';\n\ntype Options = {\n  numSlicesToProject?: number;\n};\n\nfunction getBoundsIJKFromRectangleAnnotations(\n  annotations,\n  referenceVolume,\n  options = {} as Options\n) {\n  const AllBoundsIJK = [];\n  annotations.forEach((annotation) => {\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const { imageData, dimensions } = referenceVolume;\n\n    let pointsToUse = points;\n    // If the tool is a 2D tool but has projection points, use them\n    if (data.cachedStats?.projectionPoints) {\n      const { projectionPoints } = data.cachedStats;\n      pointsToUse = [].concat(...projectionPoints); // cannot use flat() because of typescript compiler right now\n    }\n\n    const rectangleCornersIJK = pointsToUse.map(\n      (world) => csUtils.transformWorldToIndex(imageData, world) as Types.Point3\n    );\n    let boundsIJK = getBoundingBoxAroundShapeIJK(\n      rectangleCornersIJK,\n      dimensions\n    );\n\n    // If the tool is 2D but it is configured to project to X amount of slices\n    // Don't project the slices if projectionPoints have been used to define the extents\n    if (options.numSlicesToProject && !data.cachedStats?.projectionPoints) {\n      boundsIJK = extend2DBoundingBoxInViewAxis(\n        boundsIJK,\n        options.numSlicesToProject\n      );\n    }\n\n    AllBoundsIJK.push(boundsIJK);\n  });\n\n  if (AllBoundsIJK.length === 1) {\n    return AllBoundsIJK[0];\n  }\n\n  // Get the intersection of all the bounding boxes\n  // This is the bounding box that contains all the ROIs\n  const boundsIJK = AllBoundsIJK.reduce(\n    (accumulator, currentValue) => {\n      return {\n        iMin: Math.min(accumulator.iMin, currentValue.iMin),\n        jMin: Math.min(accumulator.jMin, currentValue.jMin),\n        kMin: Math.min(accumulator.kMin, currentValue.kMin),\n        iMax: Math.max(accumulator.iMax, currentValue.iMax),\n        jMax: Math.max(accumulator.jMax, currentValue.jMax),\n        kMax: Math.max(accumulator.kMax, currentValue.kMax),\n      };\n    },\n    {\n      iMin: Infinity,\n      jMin: Infinity,\n      kMin: Infinity,\n      iMax: -Infinity,\n      jMax: -Infinity,\n      kMax: -Infinity,\n    }\n  );\n\n  return boundsIJK;\n}\n\nexport default getBoundsIJKFromRectangleAnnotations;\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\n\nconst { isEqual } = csUtils;\n\nconst iAxis = vec3.fromValues(1, 0, 0);\nconst jAxis = vec3.fromValues(0, 1, 0);\nconst kAxis = vec3.fromValues(0, 0, 1);\n\nconst axisList = [iAxis, jAxis, kAxis];\n\n/**\n * Determines whether a given rectangle in a 3D space (defined by its corner\n * points in IJK coordinates) is aligned with the IJK axes.\n * @param rectangleCornersIJK - The corner points of the rectangle in IJK coordinates\n * @returns True if the rectangle is aligned with the IJK axes, false otherwise\n */\nfunction isAxisAlignedRectangle(rectangleCornersIJK) {\n  const rectangleVec1 = vec3.subtract(\n    vec3.create(),\n    rectangleCornersIJK[0],\n    rectangleCornersIJK[1]\n  );\n\n  const rectangleVec2 = vec3.subtract(\n    vec3.create(),\n    rectangleCornersIJK[0],\n    rectangleCornersIJK[2]\n  );\n\n  // Calculate the angles with IJK axes for both vectors\n  const anglesVec1 = calculateAnglesWithAxes(rectangleVec1, axisList);\n  const anglesVec2 = calculateAnglesWithAxes(rectangleVec2, axisList);\n\n  // Check if all angles are aligned (0, 90, 180, or 270 degrees)\n  // we could do csUtils.isEqual(angle % 90, 0) but this is more explicit for reading\n  const isAligned = [...anglesVec1, ...anglesVec2].every(\n    (angle) =>\n      isEqual(angle, 0) ||\n      isEqual(angle, 90) ||\n      isEqual(angle, 180) ||\n      isEqual(angle, 270)\n  );\n\n  return isAligned;\n}\n\n// Function to calculate angle with IJK axes\nfunction calculateAnglesWithAxes(vec, axes) {\n  return axes.map((axis) => (vec3.angle(vec, axis) * 180) / Math.PI);\n}\n\nexport { isAxisAlignedRectangle };\n","import {\n  StackViewport,\n  Types,\n  VolumeViewport,\n  eventTarget,\n  EVENTS,\n  utilities as csUtils,\n  getEnabledElement,\n} from '@cornerstonejs/core';\nimport { ScrollOptions, EventTypes } from '../types';\n\n/**\n * It scrolls one slice in the Stack or Volume Viewport, it uses the options provided\n * to determine the slice to scroll to. For Stack Viewport, it scrolls in the 1 or -1\n * direction, for Volume Viewport, it uses the camera and focal point to determine the\n * slice to scroll to based on the spacings.\n * @param viewport - The viewport in which to scroll\n * @param options - Options to use for scrolling, including direction, invert, and volumeId\n * @returns\n */\nexport default function scroll(\n  viewport: Types.IViewport,\n  options: ScrollOptions\n): void {\n  // check if viewport is disabled then throw error\n  const enabledElement = getEnabledElement(viewport.element);\n\n  if (!enabledElement) {\n    throw new Error('Scroll::Viewport is not enabled (it might be disabled)');\n  }\n\n  if (\n    viewport instanceof StackViewport &&\n    viewport.getImageIds().length === 0\n  ) {\n    throw new Error('Scroll::Stack Viewport has no images');\n  }\n\n  const { volumeId, delta, scrollSlabs } = options;\n\n  if (viewport instanceof VolumeViewport) {\n    scrollVolume(viewport, volumeId, delta, scrollSlabs);\n  } else {\n    (viewport as Types.IStackViewport).scroll(\n      delta,\n      options.debounceLoading,\n      options.loop\n    );\n  }\n}\n\nexport function scrollVolume(\n  viewport: VolumeViewport,\n  volumeId: string,\n  delta: number,\n  scrollSlabs = false\n) {\n  const useSlabThickness = scrollSlabs;\n\n  const { numScrollSteps, currentStepIndex, sliceRangeInfo } =\n    csUtils.getVolumeViewportScrollInfo(viewport, volumeId, useSlabThickness);\n\n  if (!sliceRangeInfo) {\n    return;\n  }\n\n  const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;\n  const { focalPoint, viewPlaneNormal, position } = camera;\n\n  const { newFocalPoint, newPosition } = csUtils.snapFocalPointToSlice(\n    focalPoint,\n    position,\n    sliceRange,\n    viewPlaneNormal,\n    spacingInNormalDirection,\n    delta\n  );\n\n  viewport.setCamera({\n    focalPoint: newFocalPoint,\n    position: newPosition,\n  });\n  viewport.render();\n\n  const desiredStepIndex = currentStepIndex + delta;\n\n  const VolumeScrollEventDetail: EventTypes.VolumeScrollOutOfBoundsEventDetail =\n    {\n      volumeId,\n      viewport,\n      delta,\n      desiredStepIndex,\n      currentStepIndex,\n      numScrollSteps,\n      currentImageId: viewport.getCurrentImageId(),\n    };\n\n  if (\n    (desiredStepIndex > numScrollSteps || desiredStepIndex < 0) &&\n    viewport.getCurrentImageId() // Check that we are in the plane of acquistion\n  ) {\n    // One common use case of this trigger might be to load the next\n    // volume in a time series or the next segment of a partially loaded volume.\n\n    csUtils.triggerEvent(\n      eventTarget,\n      EVENTS.VOLUME_SCROLL_OUT_OF_BOUNDS,\n      VolumeScrollEventDetail\n    );\n  } else {\n    csUtils.triggerEvent(\n      eventTarget,\n      EVENTS.VOLUME_VIEWPORT_SCROLL,\n      VolumeScrollEventDetail\n    );\n  }\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  AnnotationCompletedEventType,\n  AnnotationModifiedEventType,\n  AnnotationRemovedEventType,\n} from '../../../types/EventTypes';\nimport { state as annotationState } from '../../../stateManagement/annotation';\nimport type AnnotationGroupSelector from '../../../types/AnnotationGroupSelector';\nimport getInterpolationDataCollection from '../../contours/interpolation/getInterpolationDataCollection';\nimport type {\n  InterpolationViewportData,\n  AcceptInterpolationSelector,\n} from '../../../types/InterpolationTypes';\nimport interpolate from '../../contours/interpolation/interpolate';\nimport deleteRelatedAnnotations from './deleteRelatedAnnotations';\nimport { InterpolationROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport ChangeTypes from '../../../enums/ChangeTypes';\nimport getViewportForAnnotation from '../../getViewportForAnnotation';\nimport { addContourSegmentationAnnotation } from '../../contourSegmentation/addContourSegmentationAnnotation';\n\nconst { uuidv4 } = csUtils;\n\nconst ChangeTypesForInterpolation = [\n  ChangeTypes.HandlesUpdated,\n  ChangeTypes.InterpolationUpdated,\n];\n\nexport default class InterpolationManager {\n  static toolNames = [];\n\n  static addTool(toolName: string) {\n    if (!this.toolNames.includes(toolName)) {\n      this.toolNames.push(toolName);\n    }\n  }\n\n  /**\n   * Accepts the autogenerated interpolations, marking them as non-autogenerated.\n   * Can provide a selector to choose which ones to accept.\n   *\n   * Rules for which items to select:\n   * 1. Only choose annotations having the same segment index and segmentationID\n   * 2. Exclude all contours having the same interpolation UID as any other contours\n   *    on the same slice.\n   * 3. Exclude autogenerated annotations\n   * 4. Exclude any reset interpolationUIDs (this is a manual operation to allow\n   *    creating a new interpolation)\n   * 5. Find the set of interpolationUID's remaining\n   *    a. If the set is of size 0, assign a new interpolationUID\n   *    b. If the set is of size 1, assign that interpolationUID\n   *    c. Otherwise (optional, otherwise do b for size>1 randomly),\n   *       for every remaining annotation, find the one whose center\n   *       point is closest to the center point of the new annotation.\n   *       Choose that interpolationUID\n   *\n   * To allow creating new interpolated groups, the idea is to just use a new\n   * segment index, then have an operation to update the segment index of an\n   * interpolation set.  That way the user can easily draw/see the difference,\n   * and then merge them as required.\n   * However, the base rules allow creating two contours on a single image to\n   * create a separate set.\n   */\n  static acceptAutoGenerated(\n    annotationGroupSelector: AnnotationGroupSelector,\n    selector: AcceptInterpolationSelector = {}\n  ) {\n    const { toolNames, segmentationId, segmentIndex, sliceIndex } = selector;\n    for (const toolName of toolNames || InterpolationManager.toolNames) {\n      const annotations = annotationState.getAnnotations(\n        toolName,\n        annotationGroupSelector\n      ) as InterpolationROIAnnotation[];\n      if (!annotations?.length) {\n        continue;\n      }\n      for (const annotation of annotations) {\n        const { interpolationUID, data, autoGenerated, metadata } = annotation;\n        if (interpolationUID) {\n          annotation.interpolationCompleted = true;\n        }\n        if (!autoGenerated) {\n          continue;\n        }\n        if (segmentIndex && segmentIndex !== data.segmentation.segmentIndex) {\n          continue;\n        }\n        if (\n          sliceIndex !== undefined &&\n          metadata &&\n          sliceIndex !== metadata.sliceIndex\n        ) {\n          continue;\n        }\n        if (\n          segmentationId &&\n          segmentationId !== data.segmentation.segmentationId\n        ) {\n          continue;\n        }\n        addContourSegmentationAnnotation(annotation);\n        annotation.autoGenerated = false;\n      }\n    }\n  }\n\n  /**\n   * When an annotation is completed, if the configuration includes interpolation,\n   * then find matching interpolations and interpolation between this segmentation\n   * and the other segmentations of the same type.\n   */\n  static handleAnnotationCompleted = (evt: AnnotationCompletedEventType) => {\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\n    if (!annotation?.metadata) {\n      return;\n    }\n    const { toolName, originalToolName } = annotation.metadata;\n\n    if (\n      !this.toolNames.includes(toolName) &&\n      !this.toolNames.includes(originalToolName)\n    ) {\n      return;\n    }\n\n    const viewport = getViewportForAnnotation(annotation);\n    if (!viewport) {\n      console.warn('Unable to find viewport for', annotation);\n      return;\n    }\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\n    const viewportData: InterpolationViewportData = {\n      viewport,\n      sliceData,\n      annotation,\n      interpolationUID: annotation.interpolationUID,\n    };\n    const hasInterpolationUID = !!annotation.interpolationUID;\n    // If any update, triggered on an annotation, then it will be treated as non-autogenerated.\n    annotation.autoGenerated = false;\n    if (hasInterpolationUID) {\n      // This has already been configured with matching details, so just run\n      //  the interpolation again.\n      deleteRelatedAnnotations(viewportData);\n      interpolate(viewportData);\n      return;\n    }\n    const filterData = [\n      {\n        key: 'segmentIndex',\n        value: annotation.data.segmentation.segmentIndex,\n        parentKey: (annotation) => annotation.data.segmentation,\n      },\n      {\n        key: 'viewPlaneNormal',\n        value: annotation.metadata.viewPlaneNormal,\n        parentKey: (annotation) => annotation.metadata,\n      },\n      {\n        key: 'viewUp',\n        value: annotation.metadata.viewUp,\n        parentKey: (annotation) => annotation.metadata,\n      },\n    ];\n    let interpolationAnnotations = getInterpolationDataCollection(\n      viewportData,\n      filterData\n    );\n    // Skip other type of annotation interpolationUID's that are co-located\n    const { sliceIndex } = annotation.metadata;\n    const skipUIDs = new Set<string>();\n    interpolationAnnotations.forEach((interpolationAnnotation) => {\n      if (\n        interpolationAnnotation.interpolationCompleted ||\n        interpolationAnnotation.metadata.sliceIndex === sliceIndex\n      ) {\n        const { interpolationUID } = interpolationAnnotation;\n        skipUIDs.add(interpolationUID);\n      }\n    });\n    interpolationAnnotations = interpolationAnnotations.filter(\n      (interpolationAnnotation) =>\n        !skipUIDs.has(interpolationAnnotation.interpolationUID)\n    );\n\n    // Assign a new interpolationUID (this is checked above, so will be empty initially)\n    annotation.interpolationUID =\n      interpolationAnnotations[0]?.interpolationUID || uuidv4();\n    viewportData.interpolationUID = annotation.interpolationUID;\n    interpolate(viewportData);\n  };\n\n  /**\n   * This method gets called when an annotation changes.  It will then trigger\n   * related already interpolated annotations to be updated with the modified data.\n   */\n  static handleAnnotationUpdate = (evt: AnnotationModifiedEventType) => {\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\n    const { changeType = ChangeTypes.HandlesUpdated } = evt.detail;\n    if (!annotation?.metadata) {\n      return;\n    }\n    const { toolName, originalToolName } = annotation.metadata;\n\n    if (\n      (!this.toolNames.includes(toolName) &&\n        !this.toolNames.includes(originalToolName)) ||\n      !ChangeTypesForInterpolation.includes(changeType)\n    ) {\n      return;\n    }\n    const viewport = getViewportForAnnotation(annotation);\n    if (!viewport) {\n      console.warn(\n        'Unable to find matching viewport for annotation interpolation',\n        annotation\n      );\n      return;\n    }\n    if (annotation.autoGenerated) {\n      // Dont fire the annotation changed events here, as that leads to recursion,\n      // although this is in fact completing the event, so trigger the segmentation add\n      addContourSegmentationAnnotation(annotation);\n      annotation.autoGenerated = false;\n    }\n\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\n    const viewportData: InterpolationViewportData = {\n      viewport,\n      sliceData,\n      annotation,\n      interpolationUID: annotation.interpolationUID,\n      isInterpolationUpdate: changeType === ChangeTypes.InterpolationUpdated,\n    };\n    interpolate(viewportData);\n  };\n\n  /**\n   * Delete interpolated annotations when their endpoints are deleted.\n   */\n  static handleAnnotationDelete = (evt: AnnotationRemovedEventType) => {\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\n    if (!annotation?.metadata) {\n      return;\n    }\n    const { toolName } = annotation.metadata;\n\n    if (!this.toolNames.includes(toolName) || annotation.autoGenerated) {\n      return;\n    }\n    const viewport = getViewportForAnnotation(annotation);\n\n    if (!viewport) {\n      console.warn(\n        \"No viewport, can't delete interpolated results\",\n        annotation\n      );\n      return;\n    }\n\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\n    const viewportData: InterpolationViewportData = {\n      viewport,\n      sliceData,\n      annotation,\n      interpolationUID: annotation.interpolationUID,\n    };\n    // If any update, triggered on an annotation, then it will be treated as non-interpolated.\n    annotation.autoGenerated = false;\n    deleteRelatedAnnotations(viewportData);\n  };\n}\n\nfunction getSliceData(viewport): Types.ImageSliceData {\n  const sliceData: Types.ImageSliceData = {\n    numberOfSlices: viewport.getNumberOfSlices(),\n    imageIndex: viewport.getCurrentImageIdIndex(),\n  };\n  return sliceData;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport { getBrushToolInstances } from './utilities';\n\nexport function setBrushReplaceForToolGroup(\n  toolGroupId: string,\n  targetSegmentIndex: string\n) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n\n  brushBasedToolInstances.forEach((tool) => {\n    tool.configuration.strategySpecificConfiguration.REPLACE.targetSegmentIndex =\n      targetSegmentIndex;\n  });\n}\n\nexport function getBrushReplaceForToolGroup(toolGroupId: string) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n  const brushToolInstance = brushBasedToolInstances[0];\n\n  if (!brushToolInstance) {\n    return;\n  }\n\n  return brushToolInstance.configuration.strategySpecificConfiguration.REPLACE\n    .targetSegmentIndex;\n}\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport { getBrushToolInstances } from './utilities';\n\n/**\n * Sets the brush size for all brush-based tools in a given tool group.\n * @param toolGroupId - The ID of the tool group to set the brush size for.\n * @param brushSize - The new brush size to set.\n * @param toolName - The name of the specific tool to set the brush size for (optional)\n * If not provided, all brush-based tools in the tool group will be affected.\n */\nexport function setBrushSizeForToolGroup(\n  toolGroupId: string,\n  brushSize: number,\n  toolName?: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\n\n  brushBasedToolInstances.forEach((tool: BrushTool) => {\n    tool.configuration.brushSize = brushSize;\n\n    // Invalidate the brush being rendered so it can update.\n    tool.invalidateBrushCursor();\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  const viewportsInfoArray = Object.keys(viewportsInfo).map(\n    (key) => viewportsInfo[key]\n  );\n\n  if (!viewportsInfoArray.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfoArray[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n\n/**\n * Gets the brush size for the first brush-based tool instance in a given tool group.\n * @param toolGroupId - The ID of the tool group to get the brush size for.\n * @param toolName - The name of the specific tool to get the brush size for (Optional)\n * If not provided, the first brush-based tool instance in the tool group will be used.\n * @returns The brush size of the selected tool instance, or undefined if no brush-based tool instance is found.\n */\nexport function getBrushSizeForToolGroup(\n  toolGroupId: string,\n  toolName?: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\n\n  // one is enough as they share the same brush size\n  const brushToolInstance = brushBasedToolInstances[0];\n\n  if (!brushToolInstance) {\n    return;\n  }\n\n  // TODO -> Assumes the brush sizes are the same and set via these helpers.\n  return brushToolInstance.configuration.brushSize;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport { getBrushToolInstances } from './utilities';\n\nexport function setBrushThresholdForToolGroup(\n  toolGroupId: string,\n  threshold: Types.Point2,\n  otherArgs: Record<string, unknown> = { isDynamic: false }\n) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n  const configuration = {\n    ...otherArgs,\n    ...(threshold !== undefined && { threshold }),\n  };\n\n  brushBasedToolInstances.forEach((tool) => {\n    tool.configuration.strategySpecificConfiguration.THRESHOLD = {\n      ...tool.configuration.strategySpecificConfiguration.THRESHOLD,\n      ...configuration,\n    };\n  });\n}\n\nexport function getBrushThresholdForToolGroup(toolGroupId: string) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n  const brushToolInstance = brushBasedToolInstances[0];\n\n  if (!brushToolInstance) {\n    return;\n  }\n\n  return brushToolInstance.configuration.strategySpecificConfiguration.THRESHOLD\n    .threshold;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { cache } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\n/**\n * Determines if there is a point between point1 and point2 which is not\n * contained in the segmentation\n */\nexport default function isLineInSegment(\n  point1: Types.Point3,\n  point2: Types.Point3,\n  isInSegment\n) {\n  const ijk1 = isInSegment.toIJK(point1);\n  const ijk2 = isInSegment.toIJK(point2);\n  const testPoint = vec3.create();\n  const { testIJK } = isInSegment;\n  const delta = vec3.sub(vec3.create(), ijk1, ijk2);\n\n  // Test once for index value between the two points, so the max of the\n  // difference in IJK values\n  const testSize = Math.round(Math.max(...delta.map(Math.abs)));\n  if (testSize < 2) {\n    // No need to test when there are only two points\n    return true;\n  }\n  const unitDelta = vec3.scale(vec3.create(), delta, 1 / testSize);\n\n  for (let i = 1; i < testSize; i++) {\n    vec3.scaleAndAdd(testPoint, ijk2, unitDelta, i);\n    if (!testIJK(testPoint)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Creates a function that tests to see if the provided line segment, specified\n * in LPS space (as endpoints) is contained in the segment\n */\nfunction createIsInSegment(\n  segVolumeId: string,\n  segmentIndex: number,\n  containedSegmentIndices?: Set<number>\n) {\n  // Get segmentation volume\n  const vol = cache.getVolume(segVolumeId);\n  if (!vol) {\n    console.warn(`No volume found for ${segVolumeId}`);\n    return;\n  }\n\n  const segData = vol.imageData.getPointData().getScalars().getData();\n  const width = vol.dimensions[0];\n  const pixelsPerSlice = width * vol.dimensions[1];\n\n  return {\n    /**\n     * Find the center point between point1 and point2, convert it to IJK space\n     * and test if the value at that location is in the segment\n     */\n    testCenter: (point1, point2) => {\n      const point = vec3.add(vec3.create(), point1, point2).map((it) => it / 2);\n      const ijk = vol.imageData.worldToIndex(point as vec3).map(Math.round);\n      const [i, j, k] = ijk;\n      const index = i + j * width + k * pixelsPerSlice;\n      const value = segData[index];\n      return value === segmentIndex || containedSegmentIndices?.has(value);\n    },\n\n    toIJK: (point) => vol.imageData.worldToIndex(point as vec3),\n\n    testIJK: (ijk) => {\n      const [i, j, k] = ijk;\n      const index =\n        Math.round(i) + Math.round(j) * width + Math.round(k) * pixelsPerSlice;\n      const value = segData[index];\n      return value === segmentIndex || containedSegmentIndices?.has(value);\n    },\n  };\n}\n\nexport { createIsInSegment, isLineInSegment };\n","import { vec3 } from 'gl-matrix';\n\nimport { createIsInSegment, isLineInSegment } from './isLineInSegment';\nimport type { BidirectionalData } from './createBidirectionalToolData';\n\nconst EPSILON = 1e-2;\n\n/**\n * Search in the contours for the given segment to find the largest bidirectional\n * that will fit entirely within the slice contours inside the contours object.\n * Assumptions/implementation details:\n *\n *   1. The major and minor bidirectional lines must not cross the contour\n *   2. The center point for both major and minor bidirectional lines must be\n *      within the segment, or the contained segment index.\n *   3. The major/minor axis must be orthogonal\n *\n * Note this does NOT test that the major/minor axis intersect.  Normally they will, but\n * it isn't a hard requirement.\n *\n * The way that islands within the contours are handled is to allow the island to be\n * coloured with something that is contained - that way both open and closed islands\n * can be handled correctly for finding the bidirectional  (an open island is a section\n * inside the segment that is open to the outside - this can happen at bone endpoints or when\n * one region flows into another)\n */\nexport default function findLargestBidirectional(\n  contours,\n  segVolumeId: string,\n  segment\n) {\n  const { sliceContours } = contours;\n  const { segmentIndex, containedSegmentIndices } = segment;\n  let maxBidirectional;\n  const isInSegment = createIsInSegment(\n    segVolumeId,\n    segmentIndex,\n    containedSegmentIndices\n  );\n  for (const sliceContour of sliceContours) {\n    const bidirectional = createBidirectionalForSlice(\n      sliceContour,\n      isInSegment,\n      maxBidirectional\n    );\n    if (!bidirectional) {\n      continue;\n    }\n    maxBidirectional = bidirectional;\n  }\n  if (maxBidirectional) {\n    Object.assign(maxBidirectional, segment);\n  }\n  return maxBidirectional;\n}\n\n/**\n * This function creates a bidirectional data object for the given slice and\n * slice contour, only when the major distance is larger than currentMax, or\n * equal to current max and the minor is larger than currentMax's minor.\n * It does this by looking at every pair of distances in sliceCountour to find\n * those larger than the currentMax, and then finds the minor distance for those\n * major distances.\n *\n */\nfunction createBidirectionalForSlice(\n  sliceContour,\n  isInSegment,\n  currentMax = { maxMajor: 0, maxMinor: 0 }\n) {\n  const { points } = sliceContour.polyData;\n  const { maxMinor: currentMaxMinor, maxMajor: currentMaxMajor } = currentMax;\n  let maxMajor = currentMaxMajor * currentMaxMajor;\n  let maxMinor = currentMaxMinor * currentMaxMinor;\n  let maxMajorPoints;\n  for (let index1 = 0; index1 < points.length; index1++) {\n    for (let index2 = index1 + 1; index2 < points.length; index2++) {\n      const point1 = points[index1];\n      const point2 = points[index2];\n      const distance2 = vec3.sqrDist(point1, point2);\n      if (distance2 < maxMajor) {\n        continue;\n      }\n      if (distance2 - EPSILON < maxMajor + EPSILON && maxMajorPoints) {\n        // Consider adding to the set of points rather than continuing here\n        // so that all minor axis can be tested\n        continue;\n      }\n      if (!isInSegment.testCenter(point1, point2)) {\n        // Center between the two points has to be in the segment, otherwise\n        // this is out of bounds.\n        continue;\n      }\n      if (!isLineInSegment(point1, point2, isInSegment)) {\n        // If the line intersects the segment boundary, then skip it\n        continue;\n      }\n      maxMajor = distance2 - EPSILON;\n      maxMajorPoints = [index1, index2];\n      maxMinor = 0;\n    }\n  }\n  if (!maxMajorPoints) {\n    return;\n  }\n\n  maxMajor = Math.sqrt(maxMajor + EPSILON);\n  const handle0 = points[maxMajorPoints[0]];\n  const handle1 = points[maxMajorPoints[1]];\n  const unitMajor = vec3.sub(vec3.create(), handle0, handle1);\n  vec3.scale(unitMajor, unitMajor, 1 / maxMajor);\n\n  let maxMinorPoints;\n\n  for (let index1 = 0; index1 < points.length; index1++) {\n    for (let index2 = index1 + 1; index2 < points.length; index2++) {\n      const point1 = points[index1];\n      const point2 = points[index2];\n      const distance2 = vec3.sqrDist(point1, point2);\n      if (distance2 <= maxMinor) {\n        continue;\n      }\n      const delta = vec3.sub(vec3.create(), point1, point2);\n\n      const dot = Math.abs(vec3.dot(delta, unitMajor)) / Math.sqrt(distance2);\n      if (dot > EPSILON) {\n        continue;\n      }\n\n      if (!isInSegment.testCenter(point1, point2)) {\n        // Center between the two points has to be in the segment, otherwise\n        // this is out of bounds.\n        continue;\n      }\n      if (!isLineInSegment(point1, point2, isInSegment)) {\n        continue;\n      }\n      maxMinor = distance2;\n      maxMinorPoints = [index1, index2];\n    }\n  }\n\n  if (!maxMinorPoints) {\n    // Didn't find a larger minor distance\n    return;\n  }\n  maxMinor = Math.sqrt(maxMinor);\n  const handle2 = points[maxMinorPoints[0]];\n  const handle3 = points[maxMinorPoints[1]];\n\n  const bidirectional = {\n    majorAxis: [handle0, handle1],\n    minorAxis: [handle2, handle3],\n    maxMajor,\n    maxMinor,\n    ...sliceContour,\n  } as BidirectionalData;\n  return bidirectional;\n}\n","import { generateContourSetsFromLabelmap } from '../contours';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport findLargestBidirectional from './findLargestBidirectional';\n\nconst { Labelmap } = SegmentationRepresentations;\n\n/**\n * Generates a contour object over the segment, and then uses the contouring to\n * find the largest bidirectional object that can be applied within the acquisition\n * plane that is within the segment index, or the contained segment indices.\n *\n * @param segmentation.segments - a list of segments to apply the contour to.\n * @param segmentation.segments.containedSegmentIndices - a set of segment indexes equivalent to the primary segment\n * @param segmentation.segments.label - the label for the segment\n * @param segmentation.segments.color - the color to use for the segment label\n */\nexport default function contourAndFindLargestBidirectional(segmentation) {\n  const contours = generateContourSetsFromLabelmap({\n    segmentations: segmentation,\n  });\n\n  if (!contours?.length || !contours[0].sliceContours.length) {\n    return;\n  }\n\n  const {\n    representationData,\n    segments = [\n      null,\n      { label: 'Unspecified', color: null, containedSegmentIndices: null },\n    ],\n  } = segmentation;\n  const { volumeId: segVolumeId } = representationData[Labelmap];\n\n  const segmentIndex = segments.findIndex((it) => !!it);\n  if (segmentIndex === -1) {\n    return;\n  }\n  segments[segmentIndex].segmentIndex = segmentIndex;\n  return findLargestBidirectional(\n    contours[0],\n    segVolumeId,\n    segments[segmentIndex]\n  );\n}\n","import type { Types } from '@cornerstonejs/core';\nimport type { Annotation } from '../../types/AnnotationTypes';\n\nexport type BidirectionalData = {\n  majorAxis: [Types.Point3, Types.Point3];\n  minorAxis: [Types.Point3, Types.Point3];\n  maxMajor: number;\n  maxMinor: number;\n  segmentIndex: number;\n  label?: string;\n  color?: string | number[];\n  referencedImageId: string;\n  sliceIndex: number;\n};\n\n/**\n * Creates data suitable for the BidirectionalTool from the basic bidirectional\n * data object.\n */\nexport default function createBidirectionalToolData(\n  bidirectionalData: BidirectionalData,\n  viewport\n): Annotation {\n  const { majorAxis, minorAxis, label = '', sliceIndex } = bidirectionalData;\n  const [major0, major1] = majorAxis;\n  const [minor0, minor1] = minorAxis;\n\n  const points = [major0, major1, minor0, minor1];\n  const bidirectionalToolData = {\n    highlighted: true,\n    invalidated: true,\n    metadata: {\n      toolName: 'Bidirectional',\n      // Get a view reference for the slice this applies to, not the currently\n      // displayed slice.  This will fill in the remaining data for that slice\n      ...viewport.getViewReference({ sliceIndex }),\n    },\n    data: {\n      handles: {\n        points,\n        textBox: {\n          hasMoved: false,\n          worldPosition: [0, 0, 0] as Types.Point3,\n          worldBoundingBox: {\n            topLeft: [0, 0, 0] as Types.Point3,\n            topRight: [0, 0, 0] as Types.Point3,\n            bottomLeft: [0, 0, 0] as Types.Point3,\n            bottomRight: [0, 0, 0] as Types.Point3,\n          },\n        },\n        activeHandleIndex: null,\n      },\n      label,\n      cachedStats: {},\n    },\n    isLocked: false,\n    isVisible: true,\n  };\n  return bidirectionalToolData;\n}\n","/**\n * Creates a map that associates each imageId with a set of segmentation imageIds.\n * Note that this function assumes that the imageIds and segmentationImageIds arrays\n * are the same length and same order.\n *\n * @param imageIdsArray - An array of imageIds.\n * @param segmentationImageIds - An array of segmentation imageIds.\n * @returns A map that maps each imageId to a set of segmentation imageIds.\n */\nfunction createImageIdReferenceMap(\n  imageIdsArray: string[],\n  segmentationImageIds: string[]\n): Map<string, string> {\n  const imageIdReferenceMap = new Map<string, string>(\n    imageIdsArray.map((imageId, index) => {\n      return [imageId, segmentationImageIds[index]];\n    })\n  );\n\n  return imageIdReferenceMap;\n}\n\nexport { createImageIdReferenceMap };\n","import cloneDeep from 'lodash.clonedeep';\nimport {\n  getEnabledElementByIds,\n  volumeLoader,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Create a new 3D segmentation volume from the default imageData presented in\n * the first actor of the viewport. It looks at the metadata of the imageData\n * to determine the volume dimensions and spacing if particular options are not provided.\n *\n * @param viewportId - The Id of the viewport from which to derive the volume from.\n * @param renderingEngineId - The Id of the rendering engine the viewport belongs to.\n * @param [segmentationId] - The Id to name the generated segmentation. Autogenerated if not given.\n * @param [options] - LabelmapOptions\n * @returns A promise that resolves to the Id of the new labelmap volume.\n */\nexport default async function createLabelmapVolumeForViewport(input: {\n  viewportId: string;\n  renderingEngineId: string;\n  segmentationId?: string;\n  options?: {\n    volumeId: string;\n    scalarData: Float32Array | Uint8Array | Uint16Array | Int16Array;\n    targetBuffer: {\n      type: 'Float32Array' | 'Uint8Array' | 'Uint16Array' | 'Int8Array';\n    };\n    metadata: Types.Metadata;\n    dimensions: Types.Point3;\n    spacing: Types.Point3;\n    origin: Types.Point3;\n    direction: Types.Mat3;\n  };\n}): Promise<string> {\n  const { viewportId, renderingEngineId, options } = input;\n  let { segmentationId } = input;\n  const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n\n  if (!enabledElement) {\n    throw new Error('element disabled');\n  }\n\n  const { viewport } = enabledElement;\n  if (!(viewport instanceof VolumeViewport)) {\n    throw new Error('Segmentation only supports VolumeViewport');\n  }\n\n  const { uid } = viewport.getDefaultActor();\n\n  if (segmentationId === undefined) {\n    // Name the segmentation volume with the viewport Id\n    segmentationId = `${uid}-based-segmentation-${\n      options?.volumeId ?? csUtils.uuidv4().slice(0, 8)\n    }`;\n  }\n\n  if (options) {\n    // create a new labelmap with its own properties\n    // This allows creation of a higher resolution labelmap vs reference volume\n    const properties = cloneDeep(options);\n    await volumeLoader.createLocalVolume(properties, segmentationId);\n  } else {\n    // create a labelmap from a reference volume\n    const { uid: volumeId } = viewport.getDefaultActor();\n    await volumeLoader.createAndCacheDerivedSegmentationVolume(volumeId, {\n      volumeId: segmentationId,\n    });\n  }\n\n  return segmentationId;\n}\n","import { Types } from '@cornerstonejs/core';\nimport { volumeLoader, utilities as csUtils } from '@cornerstonejs/core';\n\n/**\n * Given a list of labelmaps (with the possibility of overlapping regions), and\n * a segmentIndex it creates a new labelmap with the same dimensions as the input labelmaps,\n * but merges them into a single labelmap for the segmentIndex. It wipes out\n * all other segment Indices. This is useful for calculating statistics regarding\n * a specific segment when there are overlapping regions between labelmap (e.g. TMTV)\n *\n * @param labelmaps - Array of labelmaps\n * @param segmentIndex - The segment index to merge\n * @returns Merged labelmap\n */\nfunction createMergedLabelmapForIndex(\n  labelmaps: Array<Types.IImageVolume>,\n  segmentIndex = 1,\n  volumeId = 'mergedLabelmap'\n): Types.IImageVolume {\n  labelmaps.forEach(({ direction, dimensions, origin, spacing }) => {\n    if (\n      !csUtils.isEqual(dimensions, labelmaps[0].dimensions) ||\n      !csUtils.isEqual(direction, labelmaps[0].direction) ||\n      !csUtils.isEqual(spacing, labelmaps[0].spacing) ||\n      !csUtils.isEqual(origin, labelmaps[0].origin)\n    ) {\n      throw new Error('labelmaps must have the same size and shape');\n    }\n  });\n\n  const labelmap = labelmaps[0];\n\n  const arrayType = (labelmap.getScalarData() as any).constructor;\n  const outputData = new arrayType(labelmap.getScalarData().length);\n\n  labelmaps.forEach((labelmap) => {\n    const scalarData = labelmap.getScalarData();\n    for (let i = 0; i < scalarData.length; i++) {\n      if (scalarData[i] === segmentIndex) {\n        outputData[i] = segmentIndex;\n      }\n    }\n  });\n\n  const options = {\n    scalarData: outputData,\n    metadata: labelmap.metadata,\n    spacing: labelmap.spacing,\n    origin: labelmap.origin,\n    direction: labelmap.direction,\n    dimensions: labelmap.dimensions,\n  };\n\n  const preventCache = true;\n  // Todo: following should be async\n  const mergedVolume = volumeLoader.createLocalVolume(\n    options,\n    volumeId,\n    preventCache\n  );\n\n  return mergedVolume;\n}\n\nexport default createMergedLabelmapForIndex;\n","import type {\n  FloodFillResult,\n  FloodFillGetter,\n  FloodFillOptions,\n} from '../../types';\nimport { Types } from '@cornerstonejs/core';\n\n/**\n * floodFill.js - Taken from MIT OSS lib - https://github.com/tuzz/n-dimensional-flood-fill\n * Refactored to ES6.  Fixed the bounds/visits checks to use integer keys, restricting the\n * total search spacing to +/- 32k in each dimension, but resulting in about a hundred time\n * performance gain for larger regions since JavaScript does not have a hash map to allow the\n * map to work on keys.\n *\n * @param getter The getter to the elements of your data structure,\n *                          e.g. getter(x,y) for a 2D interprettation of your structure.\n * @param seed The seed for your fill. The dimensionality is infered\n *                        by the number of dimensions of the seed.\n * @param options.onFlood - An optional callback to execute when each pixel is flooded.\n *                             e.g. onFlood(x,y).\n * @param options.onBoundary - An optional callback to execute whenever a boundary is reached.\n *                                a boundary could be another segmentIndex, or the edge of your\n *                                data structure (i.e. when your getter returns undefined).\n * @param options.equals - An optional equality method for your datastructure.\n *                            Default is simply value1 = value2.\n * @param options.diagonals - Whether you allow flooding through diagonals. Defaults to false.\n *\n * @returns Flood fill results\n */\nfunction floodFill(\n  getter: FloodFillGetter,\n  seed: Types.Point2 | Types.Point3,\n  options: FloodFillOptions = {}\n): FloodFillResult {\n  const onFlood = options.onFlood;\n  const onBoundary = options.onBoundary;\n  const equals = options.equals;\n  const diagonals = options.diagonals || false;\n  const startNode = get(seed);\n  const permutations = prunedPermutations();\n  const stack = [];\n  const flooded = [];\n  const visits = new Set();\n  const bounds = new Map();\n\n  stack.push({ currentArgs: seed });\n\n  while (stack.length > 0) {\n    flood(stack.pop());\n  }\n\n  return {\n    flooded,\n    boundaries: boundaries(),\n  };\n\n  function flood(job) {\n    const getArgs = job.currentArgs;\n    const prevArgs = job.previousArgs;\n\n    if (visited(getArgs)) {\n      return;\n    }\n    markAsVisited(getArgs);\n\n    if (member(getArgs)) {\n      markAsFlooded(getArgs);\n      pushAdjacent(getArgs);\n    } else {\n      markAsBoundary(prevArgs);\n    }\n  }\n\n  /**\n   * Indicates if the key has been visited.\n   * @param key is a 2 or 3 element vector with values -32768...32767\n   */\n  function visited(key) {\n    const [x, y, z = 0] = key;\n    // Use an integer key value for checking visited, since JavaScript does not\n    // provide a generic hash key indexed hash map.\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n    return visits.has(iKey);\n  }\n\n  function markAsVisited(key) {\n    const [x, y, z = 0] = key;\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n    visits.add(iKey);\n  }\n\n  function member(getArgs) {\n    const node = get(getArgs);\n\n    return equals ? equals(node, startNode) : node === startNode;\n  }\n\n  function markAsFlooded(getArgs) {\n    flooded.push(getArgs);\n    if (onFlood) {\n      //@ts-ignore\n      onFlood(...getArgs);\n    }\n  }\n\n  function markAsBoundary(prevArgs) {\n    const [x, y, z = 0] = prevArgs;\n    // Use an integer key value for checking visited, since JavaScript does not\n    // provide a generic hash key indexed hash map.\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n    bounds.set(iKey, prevArgs);\n    if (onBoundary) {\n      //@ts-ignore\n      onBoundary(...prevArgs);\n    }\n  }\n\n  function pushAdjacent(getArgs) {\n    for (let i = 0; i < permutations.length; i += 1) {\n      const perm = permutations[i];\n      const nextArgs = getArgs.slice(0);\n\n      for (let j = 0; j < getArgs.length; j += 1) {\n        nextArgs[j] += perm[j];\n      }\n\n      stack.push({\n        currentArgs: nextArgs,\n        previousArgs: getArgs,\n      });\n    }\n  }\n\n  function get(getArgs) {\n    //@ts-ignore\n    return getter(...getArgs);\n  }\n\n  // This is a significant performance hit - should be done as a wrapper\n  // only when needed.\n  // function safely(f, args) {\n  //   try {\n  //     return f(...args);\n  //   } catch (error) {\n  //     return;\n  //   }\n  // }\n\n  function prunedPermutations() {\n    const permutations = permute(seed.length);\n\n    return permutations.filter(function (perm) {\n      const count = countNonZeroes(perm);\n\n      return count !== 0 && (count === 1 || diagonals);\n    });\n  }\n\n  function permute(length) {\n    const perms = [];\n\n    const permutation = function (string) {\n      return string.split('').map(function (c) {\n        return parseInt(c, 10) - 1;\n      });\n    };\n\n    for (let i = 0; i < Math.pow(3, length); i += 1) {\n      const string = lpad(i.toString(3), '0', length);\n\n      perms.push(permutation(string));\n    }\n\n    return perms;\n  }\n\n  function boundaries() {\n    const array = Array.from(bounds.values());\n    array.reverse();\n    return array;\n  }\n}\n\nfunction defaultEquals(a, b) {\n  return a === b;\n}\n\nfunction countNonZeroes(array) {\n  let count = 0;\n\n  for (let i = 0; i < array.length; i += 1) {\n    if (array[i] !== 0) {\n      count += 1;\n    }\n  }\n\n  return count;\n}\n\nfunction lpad(string, character, length) {\n  const array = new Array(length + 1);\n  const pad = array.join(character);\n\n  return (pad + string).slice(-length);\n}\n\nexport default floodFill;\n","import getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport SegmentationRepresentation from '../../enums/SegmentationRepresentations';\nimport { Segmentation } from '../../types/SegmentationStateTypes';\n\n/**\n * It returns a configuration object for the given representation type.\n * @param representationType - The type of segmentation representation\n * @returns A representation configuration object.\n */\nexport default function getDefaultRepresentationConfig(\n  segmentation: Segmentation\n) {\n  const { type: representationType } = segmentation;\n  switch (representationType) {\n    case SegmentationRepresentation.Labelmap:\n      return getDefaultLabelmapConfig();\n    default:\n      throw new Error(`Unknown representation type: ${representationType}`);\n  }\n}\n","import { getAnnotation } from '../../stateManagement';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\n\n/**\n * Retrieves the index of the hovered contour segmentation annotation for a given segmentation ID.\n *\n * @param segmentationId - The ID of the segmentation.\n * @returns The index of the hovered contour segmentation annotation, or undefined if none is found.\n */\nexport function getHoveredContourSegmentationAnnotation(segmentationId) {\n  const segmentation = getSegmentation(segmentationId);\n  const { annotationUIDsMap } = segmentation.representationData.CONTOUR;\n\n  for (const [segmentIndex, annotationUIDs] of annotationUIDsMap.entries()) {\n    const highlightedAnnotationUID = Array.from(annotationUIDs).find(\n      (annotationUID) => getAnnotation(annotationUID).highlighted\n    );\n\n    if (highlightedAnnotationUID) {\n      return segmentIndex;\n    }\n  }\n\n  return undefined;\n}\n","import { cache, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  getSegmentation,\n  getSegmentationIdRepresentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\n\ntype Options = {\n  viewport?: Types.IViewport;\n  searchRadius?: number;\n};\n\n/**\n * Retrieves the segment index at the border of a labelmap in a segmentation.\n *\n * @param segmentationId - The ID of the segmentation.\n * @param worldPoint - The world coordinates of the point.\n * @param options - Additional options.\n * @param options.viewport - The viewport to use.\n * @param options.searchRadius - The search radius to use.\n * @returns The segment index at the labelmap border, or undefined if not found.\n */\nexport function getSegmentAtLabelmapBorder(\n  segmentationId: string,\n  worldPoint: Types.Point3,\n  { viewport, searchRadius }: Options\n): number {\n  const segmentation = getSegmentation(segmentationId);\n\n  const labelmapData = segmentation.representationData.LABELMAP;\n\n  if (isVolumeSegmentation(labelmapData)) {\n    const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n    const segmentationVolume = cache.getVolume(volumeId);\n\n    if (!segmentationVolume) {\n      return;\n    }\n\n    const imageData = segmentationVolume.imageData;\n\n    const segmentIndex = imageData.getScalarValueFromWorld(worldPoint);\n\n    const canvasPoint = viewport.worldToCanvas(worldPoint);\n\n    const onEdge = isSegmentOnEdgeCanvas(\n      canvasPoint as Types.Point2,\n      segmentIndex,\n      viewport,\n      imageData,\n      searchRadius\n    );\n\n    return onEdge ? segmentIndex : undefined;\n  }\n\n  // stack segmentation case\n  const { imageIdReferenceMap } = labelmapData as LabelmapSegmentationDataStack;\n\n  const currentImageId = (viewport as Types.IStackViewport).getCurrentImageId();\n\n  const segmentationImageId = imageIdReferenceMap.get(currentImageId);\n  const image = cache.getImage(segmentationImageId);\n\n  if (!image) {\n    return;\n  }\n\n  // find the first segmentationRepresentationUID for the segmentationId, since\n  // that is what we use as actorUID in the viewport\n\n  const segmentationRepresentations = getSegmentationIdRepresentations(\n    segmentation.segmentationId\n  );\n\n  const { segmentationRepresentationUID } = segmentationRepresentations[0];\n  const segmentationActor = viewport.getActor(segmentationRepresentationUID);\n  const imageData = segmentationActor?.actor.getMapper().getInputData();\n  const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n\n  const dimensions = imageData.getDimensions();\n  const voxelManager = (imageData.voxelManager ||\n    utilities.VoxelManager.createVolumeVoxelManager(\n      dimensions,\n      imageData.getPointData().getScalars().getData()\n    )) as utilities.VoxelManager<number>;\n\n  const segmentIndex = voxelManager.getAtIJKPoint(indexIJK as Types.Point3);\n\n  const onEdge = isSegmentOnEdgeIJK(\n    indexIJK as Types.Point3,\n    dimensions,\n    voxelManager,\n    segmentIndex\n  );\n\n  return onEdge ? segmentIndex : undefined;\n}\n\n/**\n * Checks if a segment is on the edge of a labelmap.\n * @param getNeighborIndex - A function that returns the neighbor index given the delta values.\n * @param segmentIndex - The index of the segment to check.\n * @param searchRadius - The radius within which to search for neighboring segments. Default is 1.\n * @returns A boolean indicating whether the segment is on the edge.\n */\nfunction isSegmentOnEdge(\n  getNeighborIndex: (\n    deltaI: number,\n    deltaJ: number,\n    deltaK: number\n  ) => number | undefined,\n  segmentIndex: number,\n  searchRadius = 1 // Default search radius\n): boolean {\n  const neighborRange = Array.from(\n    { length: 2 * searchRadius + 1 },\n    (_, i) => i - searchRadius\n  );\n\n  for (const deltaI of neighborRange) {\n    for (const deltaJ of neighborRange) {\n      for (const deltaK of neighborRange) {\n        if (deltaI === 0 && deltaJ === 0 && deltaK === 0) {\n          continue; // Skipping the central point\n        }\n\n        const neighborIndex = getNeighborIndex(deltaI, deltaJ, deltaK);\n\n        if (neighborIndex !== undefined && segmentIndex !== neighborIndex) {\n          return true; // On the edge\n        }\n      }\n    }\n  }\n\n  return false; // No edge neighbors found\n}\n\nfunction isSegmentOnEdgeIJK(\n  indexIJK: Types.Point3,\n  dimensions: Types.Point3,\n  voxelManager: any,\n  segmentIndex: number,\n  searchRadius?: number\n): boolean {\n  const getNeighborIndex = (deltaI: number, deltaJ: number, deltaK: number) => {\n    const neighborIJK = [\n      indexIJK[0] + deltaI,\n      indexIJK[1] + deltaJ,\n      indexIJK[2] + deltaK,\n    ];\n\n    return voxelManager.getAtIJK(...neighborIJK);\n  };\n\n  return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\n}\n\nfunction isSegmentOnEdgeCanvas(\n  canvasPoint: Types.Point2,\n  segmentIndex: number,\n  viewport: Types.IViewport,\n  imageData: any,\n  searchRadius?: number\n): boolean {\n  const getNeighborIndex = (deltaI: number, deltaJ: number) => {\n    const neighborCanvas = [canvasPoint[0] + deltaI, canvasPoint[1] + deltaJ];\n\n    const worldPoint = viewport.canvasToWorld(neighborCanvas as Types.Point2);\n    return imageData.getScalarValueFromWorld(worldPoint);\n  };\n\n  return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\n}\n","import { cache, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport {\n  getSegmentation,\n  getSegmentationIdRepresentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\nimport { ContourSegmentationAnnotation, Segmentation } from '../../types';\nimport { getAnnotation } from '../../stateManagement';\nimport { isPointInsidePolyline3D } from '../math/polyline';\n\ntype Options = {\n  representationType?: SegmentationRepresentations;\n  viewport?: Types.IViewport;\n};\n\n/**\n * Get the segment at the specified world point in the viewport.\n * @param segmentationId - The ID of the segmentation to get the segment for.\n * @param worldPoint - The world point to get the segment for.\n *\n * @returns The index of the segment at the world point, or undefined if not found.\n */\nexport function getSegmentAtWorldPoint(\n  segmentationId: string,\n  worldPoint: Types.Point3,\n  options = {} as Options\n): number {\n  const segmentation = getSegmentation(segmentationId);\n\n  const representationData = segmentation.representationData;\n\n  // if representationType is not provided, we will use the first representation\n  const desiredRepresentation =\n    options?.representationType ?? Object.keys(representationData)[0];\n\n  if (!desiredRepresentation) {\n    throw new Error(\n      `Segmentation ${segmentationId} does not have any representations`\n    );\n  }\n\n  switch (desiredRepresentation) {\n    case SegmentationRepresentations.Labelmap:\n      return getSegmentAtWorldForLabelmap(segmentation, worldPoint, options);\n    case SegmentationRepresentations.Contour:\n      return getSegmentAtWorldForContour(segmentation, worldPoint, options);\n    default:\n      return;\n  }\n}\n\n/**\n * Retrieves the segment index at a given world point for a labelmap.\n *\n * @param labelmapData - The labelmap segmentation data.\n * @param worldPoint - The world point to retrieve the segment at.\n *\n * @returns The segment index at the given world point, or undefined if not found.\n */\nexport function getSegmentAtWorldForLabelmap(\n  segmentation: Segmentation,\n  worldPoint: Types.Point3,\n  { viewport }: Options\n): number | undefined {\n  const labelmapData = segmentation.representationData.LABELMAP;\n\n  if (isVolumeSegmentation(labelmapData)) {\n    const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n    const segmentationVolume = cache.getVolume(volumeId);\n\n    if (!segmentationVolume) {\n      return;\n    }\n\n    const segmentIndex =\n      segmentationVolume.imageData.getScalarValueFromWorld(worldPoint);\n\n    return segmentIndex;\n  }\n\n  // stack segmentation case\n  const { imageIdReferenceMap } = labelmapData as LabelmapSegmentationDataStack;\n\n  const currentImageId = (viewport as Types.IStackViewport).getCurrentImageId();\n\n  const segmentationImageId = imageIdReferenceMap.get(currentImageId);\n  const image = cache.getImage(segmentationImageId);\n\n  if (!image) {\n    return;\n  }\n\n  // find the first segmentationRepresentationUID for the segmentationId, since\n  // that is what we use as actorUID in the viewport\n\n  const segmentationRepresentations = getSegmentationIdRepresentations(\n    segmentation.segmentationId\n  );\n\n  const { segmentationRepresentationUID } = segmentationRepresentations[0];\n\n  const segmentationActor = viewport.getActor(segmentationRepresentationUID);\n  const imageData = segmentationActor?.actor.getMapper().getInputData();\n  const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n\n  const dimensions = imageData.getDimensions();\n  const voxelManager = (imageData.voxelManager ||\n    utilities.VoxelManager.createVolumeVoxelManager(\n      dimensions,\n      imageData.getPointData().getScalars().getData()\n    )) as utilities.VoxelManager<number>;\n\n  const segmentIndex = voxelManager.getAtIJKPoint(indexIJK as Types.Point3);\n\n  return segmentIndex;\n}\n\n/**\n * Retrieves the segment index at a given world point for contour segmentation.\n *\n * @param segmentation - The segmentation data.\n * @param worldPoint - The world point to check.\n * @param options - The options for segmentation.\n * @returns The segment index at the given world point, or undefined if not found.\n */\nexport function getSegmentAtWorldForContour(\n  segmentation: Segmentation,\n  worldPoint: Types.Point3,\n  { viewport }: Options\n): number {\n  const contourData = segmentation.representationData.CONTOUR;\n\n  const segmentIndices = Array.from(contourData.annotationUIDsMap.keys());\n  const { viewPlaneNormal } = viewport.getCamera();\n\n  for (const segmentIndex of segmentIndices) {\n    const annotationsSet = contourData.annotationUIDsMap.get(segmentIndex);\n\n    if (!annotationsSet) {\n      continue;\n    }\n\n    for (const annotationUID of annotationsSet) {\n      const annotation = getAnnotation(\n        annotationUID\n      ) as ContourSegmentationAnnotation;\n\n      if (!annotation) {\n        continue;\n      }\n\n      const { polyline } = annotation.data.contour;\n\n      if (\n        !utilities.isEqual(viewPlaneNormal, annotation.metadata.viewPlaneNormal)\n      ) {\n        continue;\n      }\n\n      // This function checks whether we are inside the contour. It does not\n      // check if we are exactly on the contour, which is highly unlikely given\n      // the canvas pixel resolution of 1 decimal place we have by design.\n      if (isPointInsidePolyline3D(worldPoint, polyline)) {\n        return Number(segmentIndex);\n      }\n    }\n  }\n}\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport { getBrushToolInstances } from './utilities';\n\n/**\n * Invalidates the brush cursor for a specific tool group.\n * This function triggers the update of the brush being rendered.\n * It also triggers an annotation render for any viewports on the tool group.\n *\n * @param toolGroupId - The ID of the tool group.\n */\nexport function invalidateBrushCursor(toolGroupId: string): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n\n  brushBasedToolInstances.forEach((tool: BrushTool) => {\n    // Invalidate the brush being rendered so it can update.\n    tool.invalidateBrushCursor();\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  const viewportsInfoArray = Object.keys(viewportsInfo).map(\n    (key) => viewportsInfo[key]\n  );\n\n  if (!viewportsInfoArray.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfoArray[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n","import { isValidLabelmapConfig } from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport SegmentationRepresentation from '../../enums/SegmentationRepresentations';\nimport { RepresentationConfig } from '../../types/SegmentationStateTypes';\n\n/**\n * Given a representation type and a configuration, return true if the\n * configuration is valid for that representation type\n * @param representationType - The type of segmentation representation\n * @param config - RepresentationConfig\n * @returns A boolean value.\n */\nexport default function isValidRepresentationConfig(\n  representationType: string,\n  config: RepresentationConfig\n): boolean {\n  switch (representationType) {\n    case SegmentationRepresentation.Labelmap:\n      return isValidLabelmapConfig(config);\n    default:\n      throw new Error(`Unknown representation type: ${representationType}`);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { state } from '../../stateManagement/annotation';\nimport {\n  RectangleROIStartEndThresholdTool,\n  RectangleROIThresholdTool,\n} from '../../tools';\n\nimport thresholdVolumeByRange from './thresholdVolumeByRange';\nimport getBoundsIJKFromRectangleAnnotations from '../rectangleROITool/getBoundsIJKFromRectangleAnnotations';\nimport { ThresholdInformation } from './utilities';\n\nexport type ThresholdOptions = {\n  numSlicesToProject?: number; // number of slices to project before and after current slice\n  overwrite: boolean;\n  overlapType?: number; // type of the voxel overlap\n  segmentIndex?: number; // segment index to threshold\n};\n\nexport type AnnotationForThresholding = {\n  data: {\n    handles: {\n      points: Types.Point3[];\n    };\n    cachedStats?: {\n      projectionPoints?: Types.Point3[][];\n    };\n  };\n};\n\n/**\n * It uses the provided rectangleROI annotations (either RectangleROIThreshold, or\n * RectangleROIStartEndThreshold) to compute an ROI that is the intersection of\n * all the annotations. Then it uses the rectangleROIThreshold utility to threshold\n * the volume.\n * @param annotationUIDs - rectangleROI annotationsUIDs to use for ROI\n * @param segmentationVolume - the segmentation volume\n * @param thresholdVolumeInformation - object array containing the volume data and range threshold values\n * @param options - options for thresholding\n * @returns\n */\nfunction rectangleROIThresholdVolumeByRange(\n  annotationUIDs: string[],\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[],\n  options: ThresholdOptions\n): Types.IImageVolume {\n  const annotations = annotationUIDs.map((annotationUID) => {\n    return state.getAnnotation(annotationUID);\n  });\n\n  _validateAnnotations(annotations);\n\n  let boundsIJK;\n  for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n    // make sure that the boundsIJK are generated by the correct volume\n    const volumeSize =\n      thresholdVolumeInformation[i].volume.getScalarData().length;\n    if (volumeSize === segmentationVolume.getScalarData().length || i === 0) {\n      boundsIJK = getBoundsIJKFromRectangleAnnotations(\n        annotations,\n        thresholdVolumeInformation[i].volume,\n        options\n      );\n    }\n  }\n\n  const outputSegmentationVolume = thresholdVolumeByRange(\n    segmentationVolume,\n    thresholdVolumeInformation,\n    { ...options, boundsIJK }\n  );\n\n  outputSegmentationVolume.modified();\n\n  return outputSegmentationVolume;\n}\n\nfunction _validateAnnotations(annotations) {\n  const validToolNames = [\n    RectangleROIThresholdTool.toolName,\n    RectangleROIStartEndThresholdTool.toolName,\n  ];\n\n  for (const annotation of annotations) {\n    const name = annotation.metadata.toolName;\n    if (!validToolNames.includes(name)) {\n      throw new Error(\n        'rectangleROIThresholdVolumeByRange only supports RectangleROIThreshold and RectangleROIStartEndThreshold annotations'\n      );\n    }\n  }\n}\n\nexport default rectangleROIThresholdVolumeByRange;\n","import { getEnabledElement, type Types } from '@cornerstonejs/core';\n\nimport type { Annotation } from '../../types/AnnotationTypes';\nimport * as segmentation from '../../stateManagement/segmentation';\nimport {\n  state as annotationState,\n  config as annotationConfig,\n} from '../../stateManagement/annotation';\nimport { jumpToSlice } from '../viewport';\nimport contourAndFindLargestBidirectional from './contourAndFindLargestBidirectional';\nimport createBidirectionalToolData from './createBidirectionalToolData';\nimport BidirectionalTool from '../../tools/annotation/BidirectionalTool';\n\nexport type Segment = {\n  segmentationId: string;\n  segmentIndex: number;\n  label: string;\n\n  style?: any;\n  containedSegmentIndices?: (number) => boolean;\n};\n\nexport type SegmentContourActionConfiguration = {\n  getSegment?: (\n    enabledElement: Types.IEnabledElement,\n    configuration: SegmentContourActionConfiguration\n  ) => Segment;\n\n  /**\n   * Optional map for data about each segment\n   */\n  segmentationId?: string;\n  segmentIndex?: number;\n  segmentData?: Map<number, Segment>;\n  toolGroupId?: string;\n};\n\nexport default function segmentContourAction(\n  element: HTMLDivElement,\n  configuration\n) {\n  const { data: configurationData } = configuration;\n  const enabledElement = getEnabledElement(element);\n  const segment = (configurationData.getSegment || defaultGetSegment)(\n    enabledElement,\n    configurationData\n  );\n  if (!segment) {\n    return;\n  }\n  const FrameOfReferenceUID = enabledElement.viewport.getFrameOfReferenceUID();\n  const segmentationsList = segmentation.state.getSegmentations();\n  const { segmentIndex, segmentationId } = segment;\n  const bidirectionals = annotationState.getAnnotations(\n    this.toolName || BidirectionalTool.toolName,\n    FrameOfReferenceUID\n  );\n  let hasExistingActiveSegment = false;\n  const existingLargestBidirectionals = bidirectionals.filter(\n    (existingBidirectionalItem) => {\n      const { segment } = existingBidirectionalItem.data;\n      if (!segment) {\n        return;\n      }\n      if (\n        segment.segmentationId === segmentationId &&\n        segment.segmentIndex === segmentIndex\n      ) {\n        hasExistingActiveSegment = true;\n        existingBidirectionalItem.data.segment = segment;\n      }\n      return !!segment;\n    }\n  );\n  if (!hasExistingActiveSegment) {\n    // Just create a dummy annotation object containing just enough information\n    // to create a real one.\n    existingLargestBidirectionals.push({\n      data: { segment },\n    } as unknown as Annotation);\n  }\n\n  let newBidirectional;\n  existingLargestBidirectionals.forEach((existingLargestBidirectional) => {\n    const segments = [];\n    const { segment: updateSegment } = existingLargestBidirectional.data;\n    const { segmentIndex, segmentationId } = updateSegment;\n    segments[segmentIndex] = updateSegment;\n    annotationState.removeAnnotation(\n      existingLargestBidirectional.annotationUID\n    );\n    const bidirectionalData = contourAndFindLargestBidirectional({\n      ...segmentationsList.find(\n        (segmentation) => segmentation.segmentationId === segmentationId\n      ),\n      segments,\n    });\n\n    if (!bidirectionalData) {\n      return;\n    }\n    const bidirectionalToolData = createBidirectionalToolData(\n      bidirectionalData,\n      enabledElement.viewport\n    );\n    bidirectionalToolData.annotationUID =\n      existingLargestBidirectional.annotationUID;\n    bidirectionalToolData.data.segment = updateSegment;\n\n    const annotationUID = annotationState.addAnnotation(\n      bidirectionalToolData,\n      FrameOfReferenceUID\n    );\n\n    if (\n      updateSegment.segmentIndex === segment.segmentIndex &&\n      updateSegment.segmentationId === segment.segmentationId\n    ) {\n      newBidirectional = bidirectionalData;\n      const { style } = segment;\n      if (style) {\n        annotationConfig.style.setAnnotationStyles(annotationUID, style);\n      }\n    }\n  });\n\n  if (newBidirectional) {\n    const { sliceIndex } = newBidirectional;\n    const imageIds = enabledElement.viewport.getImageIds();\n\n    // TODO - figure out why this is reversed\n    jumpToSlice(element, {\n      imageIndex: imageIds.length - 1 - sliceIndex,\n    });\n    enabledElement.viewport.render();\n  } else {\n    console.warn('No bidirectional found');\n  }\n\n  return newBidirectional;\n}\n\nexport function defaultGetSegment(\n  enabledElement: Types.IEnabledElement,\n  configuration: SegmentContourActionConfiguration\n): Segment {\n  const segmentationsList = segmentation.state.getSegmentations();\n  if (!segmentationsList.length) {\n    return;\n  }\n  const segmentationId =\n    configuration.segmentationId || segmentationsList[0].segmentationId;\n  const segmentIndex =\n    configuration.segmentIndex ??\n    segmentation.segmentIndex.getActiveSegmentIndex(segmentationId);\n  if (!segmentIndex) {\n    return;\n  }\n  const segmentData = configuration.segmentData?.get(segmentIndex);\n  return {\n    label: `Segment ${segmentIndex}`,\n    segmentIndex,\n    segmentationId,\n    ...segmentData,\n  };\n}\n","import { Types } from '@cornerstonejs/core';\nimport { pointInShapeCallback } from '../../utilities';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport {\n  getVoxelOverlap,\n  processVolumes,\n  ThresholdInformation,\n} from './utilities';\n\n/**\n * It thresholds a segmentation volume based on a set of threshold values with\n * respect to a list of volumes and respective threshold ranges.\n * @param segmentationVolume - the segmentation volume to be modified\n * @param segmentationIndex - the index of the segmentation to modify\n * @param thresholdVolumeInformation - array of objects containing volume data\n * and a range (lower and upper values) to threshold\n * @param overlapType - indicates if the user requires all voxels pass\n * (overlapType = 1) or any voxel pass (overlapType = 0)\n * @returns\n */\nfunction thresholdSegmentationByRange(\n  segmentationVolume: Types.IImageVolume,\n  segmentationIndex: number,\n  thresholdVolumeInformation: ThresholdInformation[],\n  overlapType: number\n): Types.IImageVolume {\n  const scalarData = segmentationVolume.getScalarData();\n\n  // prepare a list of volume information objects for callback functions\n  const { baseVolumeIdx, volumeInfoList } = processVolumes(\n    segmentationVolume,\n    thresholdVolumeInformation\n  );\n\n  /**\n   * This function will test all overlaps between a voxel in base volume\n   * (the reference for segmentation volume creation) and voxels in other\n   * volumes.\n   * If the segmentation volume and the image volume are the same size,\n   * checks if the scalar data at each point is within the threshold values.\n   * If the segmentation volume and the image volume are different sizes,\n   * checks the voxel overlap\n   */\n  volumeInfoList.forEach((volumeInfo) => {\n    const { volumeSize } = volumeInfo;\n\n    if (volumeSize === scalarData.length) {\n      _handleSameSizeVolume(scalarData, segmentationIndex, volumeInfo);\n    } else {\n      _handleDifferentSizeVolume(\n        scalarData,\n        segmentationIndex,\n        volumeInfo,\n        volumeInfoList,\n        baseVolumeIdx,\n        overlapType\n      );\n    }\n  });\n\n  triggerSegmentationDataModified(segmentationVolume.volumeId);\n\n  return segmentationVolume;\n}\n\nfunction _handleDifferentSizeVolume(\n  scalarData: Types.PixelDataTypedArray,\n  segmentationIndex: number,\n  volumeInfo: any,\n  volumeInfoList: any,\n  baseVolumeIdx: number,\n  overlapType: number\n) {\n  const { imageData, lower, upper, dimensions } = volumeInfo;\n\n  let total, overlaps, range;\n\n  for (let i = 0; i < scalarData.length; i++) {\n    if (scalarData[i] === segmentationIndex) {\n      const overlapBounds = getVoxelOverlap(\n        imageData,\n        dimensions,\n        volumeInfoList[baseVolumeIdx].spacing,\n        volumeInfoList[baseVolumeIdx].imageData.getPoint(i)\n      );\n\n      const callbackOverlap = ({ value }) => {\n        total = total + 1;\n        if (value >= range.lower && value <= range.upper) {\n          overlaps = overlaps + 1;\n        }\n      };\n\n      total = 0;\n      overlaps = 0;\n      range = { lower, upper };\n      let overlapTest = false;\n\n      // check all voxel overlaps\n      pointInShapeCallback(\n        imageData,\n        () => true,\n        callbackOverlap,\n        overlapBounds\n      );\n\n      overlapTest = overlapType === 0 ? overlaps > 0 : overlaps === total;\n      scalarData[i] = overlapTest ? segmentationIndex : 0;\n    }\n  }\n  return { total, range, overlaps };\n}\n\nfunction _handleSameSizeVolume(\n  scalarData: Types.PixelDataTypedArray,\n  segmentationIndex: number,\n  volumeInfo: any\n) {\n  const { referenceValues, lower, upper } = volumeInfo;\n\n  for (let i = 0; i < scalarData.length; i++) {\n    if (scalarData[i] === segmentationIndex) {\n      const value = referenceValues[i];\n      scalarData[i] = value >= lower && value <= upper ? segmentationIndex : 0;\n    }\n  }\n}\n\nexport default thresholdSegmentationByRange;\n","import { Types } from '@cornerstonejs/core';\nimport { pointInShapeCallback } from '../../utilities';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { BoundsIJK } from '../../types';\nimport {\n  getVoxelOverlap,\n  processVolumes,\n  ThresholdInformation,\n} from './utilities';\n\nexport type ThresholdRangeOptions = {\n  overwrite: boolean;\n  boundsIJK: BoundsIJK;\n  overlapType?: number;\n  segmentIndex?: number;\n};\n\n/**\n * It thresholds a segmentation volume based on a set of threshold values with\n * respect to a list of volumes and respective threshold ranges.\n * @param segmentationVolume - the segmentation volume to be modified\n * @param thresholdVolumeInformation - array of objects containing volume data\n * and a range (lower and upper values) to threshold\n * @param options - the options for thresholding\n * As there is a chance the volumes might have different dimensions and spacing,\n * could be the case of no 1 to 1 mapping. So we need to work with the idea of\n * voxel overlaps (1 to many mappings). We consider all intersections valid, to\n * avoid the complexity to calculate a minimum voxel intersection percentage.\n * This function, given a voxel center and spacing, calculates the overlap of\n * the voxel with another volume and range check the voxels in the overlap.\n * Three situations can occur: all voxels pass the range check, some voxels pass\n * or none voxels pass. The overlapType parameter indicates if the user requires\n * all voxels pass (overlapType = 1) or any voxel pass (overlapType = 0)\n *\n * @returns segmented volume\n */\nfunction thresholdVolumeByRange(\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[],\n  options: ThresholdRangeOptions,\n): Types.IImageVolume {\n  const { imageData: segmentationImageData } = segmentationVolume;\n  const scalarData = segmentationVolume.getScalarData();\n\n  const { overwrite, boundsIJK } = options;\n  const overlapType = options?.overlapType || 0;\n\n  // set the segmentation to all zeros\n  if (overwrite) {\n    for (let i = 0; i < scalarData.length; i++) {\n      scalarData[i] = 0;\n    }\n  }\n\n  const { baseVolumeIdx, volumeInfoList } = processVolumes(\n    segmentationVolume,\n    thresholdVolumeInformation\n  );\n\n  // global variables used in callbackOverlap function\n  let overlaps, total, range;\n\n  const testOverlapRange = (volumeInfo, voxelSpacing, voxelCenter) => {\n    /**\n     * This callback function will test all overlaps between a voxel in base\n     * volume (the reference for segmentation volume creation) and voxels in other\n     * volumes.\n     */\n    const callbackOverlap = ({ value }) => {\n      total = total + 1;\n      if (value >= range.lower && value <= range.upper) {\n        overlaps = overlaps + 1;\n      }\n    };\n\n    const { imageData, dimensions, lower, upper } = volumeInfo;\n\n    const overlapBounds = getVoxelOverlap(\n      imageData,\n      dimensions,\n      voxelSpacing,\n      voxelCenter\n    );\n\n    // reset global variables and setting the range check\n    total = 0;\n    overlaps = 0;\n    range = { lower, upper };\n\n    let overlapTest = false;\n\n    // check all voxel overlaps\n    pointInShapeCallback(imageData, () => true, callbackOverlap, overlapBounds);\n\n    if (overlapType === 0) {\n      overlapTest = overlaps > 0; // any voxel overlap is accepted\n    } else if (overlapType == 1) {\n      overlapTest = overlaps === total; // require all voxel overlaps\n    }\n    return overlapTest;\n  };\n\n  // range checks a voxel in a volume with same dimension as the segmentation\n  const testRange = (volumeInfo, pointIJK) => {\n    const { imageData, referenceValues, lower, upper } = volumeInfo;\n    const offset = imageData.computeOffsetIndex(pointIJK);\n\n    const value = referenceValues[offset];\n    // console.log('VALUE', value, lower, upper)\n    if (value <= lower || value >= upper) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n\n  /**\n   * This callback function will test all overlaps between a voxel in base\n   * volume (the reference for segmentation volume creation) and voxels in other\n   * volumes.\n   */\n  const callback = ({ index, pointIJK, pointLPS }) => {\n    let insert = volumeInfoList.length > 0;\n    for (let i = 0; i < volumeInfoList.length; i++) {\n      // if volume has the same size as segmentation volume, just range check\n      if (volumeInfoList[i].volumeSize === scalarData.length) {\n        insert = testRange(volumeInfoList[i], pointIJK);\n      } else {\n        // if not, need to calculate overlaps\n        insert = testOverlapRange(\n          volumeInfoList[i],\n          volumeInfoList[baseVolumeIdx].spacing,\n          pointLPS\n        );\n      }\n      if (!insert) {\n        break;\n      }\n    }\n\n    if (insert) {\n      scalarData[index] = options.segmentIndex || 1;\n    }\n  };\n\n  pointInShapeCallback(segmentationImageData, () => true, callback, boundsIJK);\n\n  triggerSegmentationDataModified(segmentationVolume.volumeId);\n\n  return segmentationVolume;\n}\n\nexport default thresholdVolumeByRange;\n","import { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\n\nexport type ThresholdInformation = {\n  volume: Types.IImageVolume;\n  lower: number;\n  upper: number;\n};\n\nexport function getBrushToolInstances(toolGroupId: string, toolName?: string) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  if (toolName && toolInstances[toolName]) {\n    return [toolInstances[toolName]];\n  }\n\n  // For each tool that has BrushTool as base class, set the brush size.\n  const brushBasedToolInstances = Object.values(toolInstances).filter(\n    (toolInstance) => toolInstance instanceof BrushTool\n  ) as BrushTool[];\n\n  return brushBasedToolInstances;\n}\n\nconst equalsCheck = (a, b) => {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\n/**\n * Given the center of a voxel in world coordinates, calculate the voxel\n * corners in world coords to calculate the voxel overlap in another volume\n */\nexport function getVoxelOverlap(\n  imageData,\n  dimensions,\n  voxelSpacing,\n  voxelCenter\n) {\n  const voxelCornersWorld = [];\n  for (let i = 0; i < 2; i++) {\n    for (let j = 0; j < 2; j++) {\n      for (let k = 0; k < 2; k++) {\n        const point = [...voxelCenter]; // Create a new point from voxelCenter\n        point[0] = point[0] + ((i * 2 - 1) * voxelSpacing[0]) / 2;\n        point[1] = point[1] + ((j * 2 - 1) * voxelSpacing[1]) / 2;\n        point[2] = point[2] + ((k * 2 - 1) * voxelSpacing[2]) / 2;\n        voxelCornersWorld.push(point);\n      }\n    }\n  }\n  const voxelCornersIJK = voxelCornersWorld.map(\n    (world) => csUtils.transformWorldToIndex(imageData, world) as Types.Point3\n  );\n  const overlapBounds = getBoundingBoxAroundShapeIJK(\n    voxelCornersIJK,\n    dimensions\n  );\n\n  return overlapBounds;\n}\n\n/**\n * Prepare a list of volume information objects for callback functions\n */\nexport function processVolumes(\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[]\n) {\n  const { spacing: segmentationSpacing } = segmentationVolume;\n  const scalarData = segmentationVolume.getScalarData();\n\n  // prepare a list of volume information objects for callback functions\n  const volumeInfoList = [];\n  let baseVolumeIdx = 0;\n  for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n    const { imageData, spacing, dimensions } =\n      thresholdVolumeInformation[i].volume;\n\n    const volumeSize =\n      thresholdVolumeInformation[i].volume.getScalarData().length;\n    // discover the index of the volume the segmentation data is based on\n    if (\n      volumeSize === scalarData.length &&\n      equalsCheck(spacing, segmentationSpacing)\n    ) {\n      baseVolumeIdx = i;\n    }\n\n    // prepare information used in callback functions\n    const referenceValues = imageData.getPointData().getScalars().getData();\n    const lower = thresholdVolumeInformation[i].lower;\n    const upper = thresholdVolumeInformation[i].upper;\n\n    volumeInfoList.push({\n      imageData,\n      referenceValues,\n      lower,\n      upper,\n      spacing,\n      dimensions,\n      volumeSize,\n    });\n  }\n\n  return {\n    volumeInfoList,\n    baseVolumeIdx,\n  };\n}\n","import {\n  imageLoader,\n  Enums,\n  eventTarget,\n  imageLoadPoolManager,\n  cache,\n  getConfiguration as getCoreConfiguration,\n} from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport {\n  getStackData,\n  requestType,\n  priority,\n  getPromiseRemovedHandler,\n  nearestIndex,\n  range,\n} from './stackPrefetchUtils';\n\nlet configuration = {\n  maxImagesToPrefetch: Infinity,\n  // Preserving the existing pool should be the default behaviour, as there might\n  // be a volume of the same series already being loaded in the pool, and we don't want\n  // to cancel it middle of the way when the other stack viewport mounts. Worst case scenario\n  // there will be a few extra images in the pool but by the time that their turn comes\n  // we will have already loaded the volume and it will get read from the CACHE,\n  // so who cares\n  preserveExistingPool: true,\n};\n\nlet resetPrefetchTimeout;\nconst resetPrefetchDelay = 10;\n\nfunction prefetch(element) {\n  // Get the stackPrefetch tool data\n  const stackPrefetchData = getToolState(element);\n\n  if (!stackPrefetchData) {\n    return;\n  }\n\n  const stackPrefetch = stackPrefetchData || {};\n  const stack = getStackData(element);\n\n  if (!stack?.imageIds?.length) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  const { currentImageIdIndex } = stack;\n\n  // If all the requests are complete, disable the stackPrefetch tool\n  stackPrefetch.enabled &&= stackPrefetch.indicesToRequest?.length;\n\n  // Make sure the tool is still enabled\n  if (stackPrefetch.enabled === false) {\n    return;\n  }\n\n  // Remove an imageIdIndex from the list of indices to request\n  // This fires when the individual image loading deferred is resolved\n  function removeFromList(imageIdIndex) {\n    const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n\n    if (index > -1) {\n      // Don't remove last element if imageIdIndex not found\n      stackPrefetch.indicesToRequest.splice(index, 1);\n    }\n  }\n\n  // Remove all already cached images from the\n  // IndicesToRequest array\n  stackPrefetchData.indicesToRequest.sort((a, b) => a - b);\n  const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n\n  indicesToRequestCopy.forEach(function (imageIdIndex) {\n    const imageId = stack.imageIds[imageIdIndex];\n\n    if (!imageId) {\n      return;\n    }\n\n    const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n    // For nearby objects, ensure the last accessed time is updated\n    // by using getImageLoadObject.\n    // For more distant objects, just check if available, but dont\n    // change the access time.\n    // This allows throwing data that hasn't been accessed and is not\n    // nearby.\n    const imageCached =\n      distance < 6\n        ? cache.getImageLoadObject(imageId)\n        : cache.isLoaded(imageId);\n\n    if (imageCached) {\n      // Already in cache\n      removeFromList(imageIdIndex);\n    }\n  });\n\n  // Stop here if there are no images left to request\n  // After those in the cache have been removed\n  if (!stackPrefetch.indicesToRequest.length) {\n    return;\n  }\n\n  // Clear the requestPool of prefetch requests, if needed.\n  if (!configuration.preserveExistingPool) {\n    imageLoadPoolManager.clearRequestStack(requestType);\n  }\n\n  // Identify the nearest imageIdIndex to the currentImageIdIndex\n  const nearest = nearestIndex(\n    stackPrefetch.indicesToRequest,\n    stack.currentImageIdIndex\n  );\n\n  let imageId;\n  let nextImageIdIndex;\n  const preventCache = false;\n\n  function doneCallback(image) {\n    console.log('prefetch done: %s', image.imageId);\n    const imageIdIndex = stack.imageIds.indexOf(image.imageId);\n\n    removeFromList(imageIdIndex);\n  }\n\n  // Prefetch images around the current image (before and after)\n  let lowerIndex = nearest.low;\n  let higherIndex = nearest.high;\n  const imageIdsToPrefetch = [];\n\n  while (\n    lowerIndex >= 0 ||\n    higherIndex < stackPrefetch.indicesToRequest.length\n  ) {\n    const currentIndex = stack.currentImageIdIndex;\n    const shouldSkipLower =\n      currentIndex - stackPrefetch.indicesToRequest[lowerIndex] >\n      configuration.maxImagesToPrefetch;\n    const shouldSkipHigher =\n      stackPrefetch.indicesToRequest[higherIndex] - currentIndex >\n      configuration.maxImagesToPrefetch;\n\n    const shouldLoadLower = !shouldSkipLower && lowerIndex >= 0;\n    const shouldLoadHigher =\n      !shouldSkipHigher && higherIndex < stackPrefetch.indicesToRequest.length;\n\n    if (!shouldLoadHigher && !shouldLoadLower) {\n      break;\n    }\n\n    if (shouldLoadLower) {\n      nextImageIdIndex = stackPrefetch.indicesToRequest[lowerIndex--];\n      imageId = stack.imageIds[nextImageIdIndex];\n      imageIdsToPrefetch.push(imageId);\n    }\n\n    if (shouldLoadHigher) {\n      nextImageIdIndex = stackPrefetch.indicesToRequest[higherIndex++];\n      imageId = stack.imageIds[nextImageIdIndex];\n      imageIdsToPrefetch.push(imageId);\n    }\n  }\n\n  const requestFn = (imageId, options) =>\n    imageLoader.loadAndCacheImage(imageId, options);\n\n  const { useNorm16Texture, preferSizeOverAccuracy } =\n    getCoreConfiguration().rendering;\n\n  const useNativeDataType = useNorm16Texture || preferSizeOverAccuracy;\n\n  imageIdsToPrefetch.forEach((imageId) => {\n    // IMPORTANT: Request type should be passed if not the 'interaction'\n    // highest priority will be used for the request type in the imageRetrievalPool\n    const options = {\n      targetBuffer: {\n        type: useNativeDataType ? undefined : 'Float32Array',\n      },\n      preScale: {\n        enabled: true,\n      },\n      useNativeDataType,\n      requestType,\n    };\n\n    imageLoadPoolManager.addRequest(\n      requestFn.bind(null, imageId, options),\n      requestType,\n      // Additional details\n      {\n        imageId,\n      },\n      priority\n      // addToBeginning\n    );\n  });\n}\n\nfunction onImageUpdated(e) {\n  // Start prefetching again (after a delay)\n  // When the user has scrolled to a new image\n  clearTimeout(resetPrefetchTimeout);\n  resetPrefetchTimeout = setTimeout(function () {\n    const element = e.target;\n\n    // If playClip is enabled and the user loads a different series in the viewport\n    // An exception will be thrown because the element will not be enabled anymore\n    try {\n      prefetch(element);\n    } catch (error) {\n      return;\n    }\n  }, resetPrefetchDelay);\n}\n\nfunction enable(element) {\n  const stack = getStackData(element);\n\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  // Use the currentImageIdIndex from the stack as the initialImageIdIndex\n  const stackPrefetchData = {\n    indicesToRequest: range(0, stack.imageIds.length - 1),\n    enabled: true,\n    direction: 1,\n  };\n\n  // Remove the currentImageIdIndex from the list to request\n  const indexOfCurrentImage = stackPrefetchData.indicesToRequest.indexOf(\n    stack.currentImageIdIndex\n  );\n\n  stackPrefetchData.indicesToRequest.splice(indexOfCurrentImage, 1);\n\n  addToolState(element, stackPrefetchData);\n\n  prefetch(element);\n\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n  element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n  eventTarget.addEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n}\n\nfunction disable(element) {\n  clearTimeout(resetPrefetchTimeout);\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n\n  const stackPrefetchData = getToolState(element);\n  // If there is actually something to disable, disable it\n\n  if (stackPrefetchData && stackPrefetchData.indicesToRequest.length) {\n    stackPrefetchData.enabled = false;\n\n    // Clear current prefetch requests from the requestPool\n    imageLoadPoolManager.clearRequestStack(requestType);\n  }\n}\n\nfunction getConfiguration() {\n  return configuration;\n}\n\nfunction setConfiguration(config) {\n  configuration = config;\n}\n\nconst stackPrefetch = { enable, disable, getConfiguration, setConfiguration };\n\nexport default stackPrefetch;\n","import {\n  imageLoader,\n  Enums,\n  eventTarget,\n  imageLoadPoolManager,\n  cache,\n  getConfiguration as getCoreConfiguration,\n} from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport {\n  getStackData,\n  requestType,\n  priority,\n  clearFromImageIds,\n  getPromiseRemovedHandler,\n} from './stackPrefetchUtils';\nimport { roundNumber } from '../../utilities';\n\nlet configuration = {\n  maxImagesToPrefetch: Infinity,\n  // Fetch up to 2 image before and after\n  minBefore: 2,\n  maxAfter: 2,\n  // Increment the cache size by 10 images\n  directionExtraImages: 10,\n  preserveExistingPool: false,\n};\n\nlet resetPrefetchTimeout;\n// Starting the prefetch quickly isn't an issue as the main image is already being\n// loaded, so a 5 ms prefetch delay is fine\nconst resetPrefetchDelay = 5;\n\n/**\n * Call this to enable stack context sensitive prefetch.  Should be called\n * before stack data is set in order to start prefetch after load first image.\n * This will add a STACK_NEW_IMAGE to detect when a new image is displayed, and then\n * update the prefetch stack.  The context sensitive prefetch reacts to the\n * initial display, or significant moves, the already loaded images, the\n * cache size and the direction of navigation.  The behaviour is:\n *\n * 1. On navigating to a new image initially, or one that is at a different position:\n *  * Fetch the next/previous 2 images\n * 2. If the user is navigating forward/backward by less than 5 images, then\n *  * Prefetch additional images in the direction of navigation, up to 100\n * 3. If all the images in a given prefetch have completed, then:\n *  * Use the last prefetched image size as an image size for the stack\n *  * Fetch up to 1/4 of the cache size images near the current image\n *\n * This is designed to:\n *   * Get nearby images immediately so that they are available for navigation\n *     * Under the assumption that users might click and view an image, then\n *       navigate to next/previous image to see the exact image they want\n *   * Not interfere with loading other viewports if they are still loading\n *     * Load priority is prefetch, and minimal images are requested initially\n *   * Load an entire series if it will fit in memory\n *     * Allows navigating to other parts of the series and display images immediately\n *   * Have images available for CINE/navigation in one direction even when\n *     there is more image data than will fit in memory.\n *     * Up to 100 images in the direction of travel will be prefetched\n *\n * @param element - to prefetch on\n */\nconst enable = (element): void => {\n  const stack = getStackData(element);\n\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  updateToolState(element);\n\n  prefetch(element);\n\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n  element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n  eventTarget.addEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n};\n\nfunction prefetch(element) {\n  const stack = getStackData(element);\n  if (!stack?.imageIds?.length) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  // Get the stackPrefetch tool data\n  const stackPrefetchData = getToolState(element);\n\n  if (!stackPrefetchData) {\n    return;\n  }\n\n  const stackPrefetch = stackPrefetchData || {};\n\n  // If all the requests are complete, disable the stackPrefetch tool\n  stackPrefetch.enabled &&= stackPrefetch.indicesToRequest?.length;\n\n  // Make sure the tool is still enabled\n  if (stackPrefetch.enabled === false) {\n    return;\n  }\n\n  // Remove an imageIdIndex from the list of indices to request\n  // This fires when the individual image loading deferred is resolved\n  function removeFromList(imageIdIndex) {\n    const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n\n    if (index > -1) {\n      // Don't remove last element if imageIdIndex not found\n      stackPrefetch.indicesToRequest.splice(index, 1);\n    }\n  }\n\n  // Remove all already cached images from the\n  // IndicesToRequest array.\n  const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n  const { currentImageIdIndex } = stack;\n\n  indicesToRequestCopy.forEach((imageIdIndex) => {\n    const imageId = stack.imageIds[imageIdIndex];\n\n    if (!imageId) {\n      return;\n    }\n\n    const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n    // For nearby objects, ensure the last accessed time is updated\n    // by using getImageLoadObject.\n    // For more distant objects, just check if available, but dont\n    // change the access time.\n    // This allows throwing data that hasn't been accessed and is not\n    // nearby.\n    const imageCached =\n      distance < 6\n        ? cache.getImageLoadObject(imageId)\n        : cache.isLoaded(imageId);\n\n    if (imageCached) {\n      // Already in cache\n      removeFromList(imageIdIndex);\n    }\n  });\n\n  // Stop here if there are no images left to request\n  // After those in the cache have been removed\n  if (!stackPrefetch.indicesToRequest.length) {\n    return;\n  }\n\n  // Clear the requestPool of prefetch requests, if needed.\n  if (!configuration.preserveExistingPool) {\n    imageLoadPoolManager.filterRequests(clearFromImageIds(stack));\n  }\n\n  function doneCallback(imageId: string) {\n    const imageIdIndex = stack.imageIds.indexOf(imageId);\n\n    removeFromList(imageIdIndex);\n    const image = cache.getCachedImageBasedOnImageURI(imageId);\n    const { stats } = stackPrefetch;\n    const decodeTimeInMS = image?.image?.decodeTimeInMS || 0;\n    if (decodeTimeInMS) {\n      stats.imageIds.set(imageId, decodeTimeInMS);\n      stats.decodeTimeInMS += decodeTimeInMS;\n      const loadTimeInMS = image?.image?.loadTimeInMS || 0;\n      stats.loadTimeInMS += loadTimeInMS;\n    }\n\n    if (!stackPrefetch.indicesToRequest.length) {\n      if (image?.sizeInBytes) {\n        const { sizeInBytes } = image;\n        const usage = cache.getMaxCacheSize() / 4 / sizeInBytes;\n        if (!stackPrefetch.cacheFill) {\n          stats.initialTime = Date.now() - stats.start;\n          stats.initialSize = stats.imageIds.size;\n          updateToolState(element, usage);\n          prefetch(element);\n        } else if (stats.imageIds.size) {\n          stats.fillTime = Date.now() - stats.start;\n          const { size } = stats.imageIds;\n          stats.fillSize = size;\n          console.log(\n            'Done cache fill',\n            stats.fillTime,\n            'ms',\n            size,\n            'items',\n            'average total time',\n            roundNumber(stats.fillTime / size),\n            'ms',\n            'average load',\n            roundNumber(stats.loadTimeInMS / size),\n            'ms',\n            'average decode',\n            roundNumber(stats.decodeTimeInMS / size),\n            'ms'\n          );\n        }\n      }\n    }\n  }\n\n  const requestFn = (imageId, options) =>\n    imageLoader\n      .loadAndCacheImage(imageId, options)\n      .then(() => doneCallback(imageId));\n\n  const { useNorm16Texture, preferSizeOverAccuracy } =\n    getCoreConfiguration().rendering;\n\n  const useNativeDataType = useNorm16Texture || preferSizeOverAccuracy;\n\n  stackPrefetch.indicesToRequest.forEach((imageIdIndex) => {\n    const imageId = stack.imageIds[imageIdIndex];\n    // IMPORTANT: Request type should be passed if not the 'interaction'\n    // highest priority will be used for the request type in the imageRetrievalPool\n    const options = {\n      targetBuffer: {\n        type: useNativeDataType ? undefined : 'Float32Array',\n      },\n      preScale: {\n        enabled: true,\n      },\n      useNativeDataType,\n      requestType,\n    };\n\n    imageLoadPoolManager.addRequest(\n      requestFn.bind(null, imageId, options),\n      requestType,\n      // Additional details\n      {\n        imageId,\n      },\n      priority\n      // addToBeginning\n    );\n  });\n}\n\nfunction onImageUpdated(e) {\n  // Start prefetching again (after a delay)\n  // When the user has scrolled to a new image\n  clearTimeout(resetPrefetchTimeout);\n  resetPrefetchTimeout = setTimeout(function () {\n    const element = e.target;\n\n    // If playClip is enabled and the user loads a different series in the viewport\n    // An exception will be thrown because the element will not be enabled anymore\n    try {\n      updateToolState(element);\n      prefetch(element);\n    } catch (error) {\n      return;\n    }\n  }, resetPrefetchDelay);\n}\n\n// Not a full signum, but good enough for direction.\nconst signum = (x) => (x < 0 ? -1 : 1);\n\nconst updateToolState = (element, usage?: number) => {\n  const stack = getStackData(element);\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  const { currentImageIdIndex } = stack;\n  let { maxAfter = 2, minBefore = 2 } = configuration;\n  const { directionExtraImages = 10 } = configuration;\n  // Use the currentImageIdIndex from the stack as the initialImageIdIndex\n  const stackPrefetchData = getToolState(element) || {\n    indicesToRequest: [],\n    currentImageIdIndex,\n    stackCount: 0,\n    enabled: true,\n    direction: 1,\n    stats: {\n      start: Date.now(),\n      imageIds: new Map(),\n      decodeTimeInMS: 0,\n      loadTimeInMS: 0,\n      totalBytes: 0,\n    },\n  };\n  const delta = currentImageIdIndex - stackPrefetchData.currentImageIdIndex;\n  stackPrefetchData.direction = signum(delta);\n  stackPrefetchData.currentImageIdIndex = currentImageIdIndex;\n  stackPrefetchData.enabled = true;\n\n  if (stackPrefetchData.stackCount < 100) {\n    stackPrefetchData.stackCount += directionExtraImages;\n  }\n\n  if (Math.abs(delta) > maxAfter || !delta) {\n    // Not incrementing by 1, so stop increasing the data size\n    // TODO - consider reversing the CINE playback\n    stackPrefetchData.stackCount = 0;\n    if (usage) {\n      // The usage of the cache that this stack can use\n      const positionFraction = currentImageIdIndex / stack.imageIds.length;\n      minBefore = Math.ceil(usage * positionFraction);\n      maxAfter = Math.ceil(usage * (1 - positionFraction));\n      stackPrefetchData.cacheFill = true;\n    } else {\n      stackPrefetchData.cacheFill = false;\n    }\n  } else if (delta < 0) {\n    minBefore += stackPrefetchData.stackCount;\n    maxAfter = 0;\n  } else {\n    maxAfter += stackPrefetchData.stackCount;\n    minBefore = 0;\n  }\n\n  const minIndex = Math.max(0, currentImageIdIndex - minBefore);\n\n  const maxIndex = Math.min(\n    stack.imageIds.length - 1,\n    currentImageIdIndex + maxAfter\n  );\n\n  // Order these correctly initially\n  const indicesToRequest = [];\n  for (let i = currentImageIdIndex + 1; i <= maxIndex; i++) {\n    indicesToRequest.push(i);\n  }\n  for (let i = currentImageIdIndex - 1; i >= minIndex; i--) {\n    indicesToRequest.push(i);\n  }\n  stackPrefetchData.indicesToRequest = indicesToRequest;\n\n  addToolState(element, stackPrefetchData);\n};\n\nfunction disable(element) {\n  clearTimeout(resetPrefetchTimeout);\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n\n  const stackPrefetchData = getToolState(element);\n  // If there is actually something to disable, disable it\n\n  if (stackPrefetchData) {\n    stackPrefetchData.enabled = false;\n    // Don't worry about clearing the requests - there aren't that many too be bothersome\n  }\n}\n\nfunction getConfiguration() {\n  return configuration;\n}\n\nfunction setConfiguration(config) {\n  configuration = config;\n}\n\nconst stackContextPrefetch = {\n  enable,\n  disable,\n  getConfiguration,\n  setConfiguration,\n};\n\nexport default stackContextPrefetch;\n","import debounce from './debounce';\nimport isObject from './isObject';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds (or once per browser frame). The throttled function\n * comes with a `cancel` method to cancel delayed `func` invocations and a\n * `flush` method to immediately invoke them. Provide `options` to indicate\n * whether `func` should be invoked on the leading and/or trailing edge of the\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `throttle` and `debounce`.\n *\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0]\n *  The number of milliseconds to throttle invocations to; if omitted,\n *  `requestAnimationFrame` is used (if available).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', throttle(updatePosition, 100))\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * const throttled = throttle(renewToken, 300000, { 'trailing': false })\n * jQuery(element).on('click', throttled)\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel)\n */\nfunction throttle(func, wait, options) {\n  let leading = true;\n  let trailing = true;\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? Boolean(options.leading) : leading;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n\n  return debounce(func, wait, {\n    leading,\n    trailing,\n    maxWait: wait,\n  });\n}\n\nexport default throttle;\n","import { IDistance, IPoints, ITouchPoints } from '../../types';\nimport { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the difference between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The difference in IPoints format\n */\nfunction getDeltaPoints(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IPoints {\n  const curr = getMeanPoints(currentPoints);\n  const last = getMeanPoints(lastPoints);\n  return {\n    page: _subtractPoints2D(curr.page, last.page),\n    client: _subtractPoints2D(curr.client, last.client),\n    canvas: _subtractPoints2D(curr.canvas, last.canvas),\n    world: _subtractPoints3D(curr.world, last.world),\n  };\n}\n\n/**\n * Returns the distance between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The distance difference in IDistance format\n */\nfunction getDeltaDistance(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IDistance {\n  const curr = getMeanPoints(currentPoints);\n  const last = getMeanPoints(lastPoints);\n  return {\n    page: _getDistance2D(curr.page, last.page),\n    client: _getDistance2D(curr.client, last.client),\n    canvas: _getDistance2D(curr.canvas, last.canvas),\n    world: _getDistance3D(curr.world, last.world),\n  };\n}\n\nfunction getDeltaRotation(\n  currentPoints: ITouchPoints[],\n  lastPoints: ITouchPoints[]\n) {\n  // TODO\n}\n\n/**\n * Returns the distance difference between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints -- The last points.\n *\n * @returns The difference in IPoints format\n */\nfunction getDeltaDistanceBetweenIPoints(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IDistance {\n  const currentDistance = _getMeanDistanceBetweenAllIPoints(currentPoints);\n  const lastDistance = _getMeanDistanceBetweenAllIPoints(lastPoints);\n  const deltaDistance = {\n    page: currentDistance.page - lastDistance.page,\n    client: currentDistance.client - lastDistance.client,\n    canvas: currentDistance.canvas - lastDistance.canvas,\n    world: currentDistance.world - lastDistance.world,\n  };\n  return deltaDistance;\n}\n\n/**\n * Copies a set of points.\n * @param points - The `IPoints` instance to copy.\n *\n * @returns A copy of the points.\n */\nfunction copyPointsList(points: ITouchPoints[]): ITouchPoints[] {\n  return JSON.parse(JSON.stringify(points));\n}\n\nfunction copyPoints(points: ITouchPoints): ITouchPoints {\n  return JSON.parse(JSON.stringify(points));\n}\n\nfunction getMeanPoints(points: IPoints[]): IPoints {\n  return points.reduce(\n    (prev, curr) => {\n      return {\n        page: [\n          prev.page[0] + curr.page[0] / points.length,\n          prev.page[1] + curr.page[1] / points.length,\n        ],\n        client: [\n          prev.client[0] + curr.client[0] / points.length,\n          prev.client[1] + curr.client[1] / points.length,\n        ],\n        canvas: [\n          prev.canvas[0] + curr.canvas[0] / points.length,\n          prev.canvas[1] + curr.canvas[1] / points.length,\n        ],\n        world: [\n          prev.world[0] + curr.world[0] / points.length,\n          prev.world[1] + curr.world[1] / points.length,\n          prev.world[2] + curr.world[2] / points.length,\n        ],\n      };\n    },\n    {\n      page: [0, 0],\n      client: [0, 0],\n      canvas: [0, 0],\n      world: [0, 0, 0],\n    }\n  );\n}\n\nfunction getMeanTouchPoints(points: ITouchPoints[]): ITouchPoints {\n  return points.reduce(\n    (prev, curr) => {\n      return {\n        page: [\n          prev.page[0] + curr.page[0] / points.length,\n          prev.page[1] + curr.page[1] / points.length,\n        ],\n        client: [\n          prev.client[0] + curr.client[0] / points.length,\n          prev.client[1] + curr.client[1] / points.length,\n        ],\n        canvas: [\n          prev.canvas[0] + curr.canvas[0] / points.length,\n          prev.canvas[1] + curr.canvas[1] / points.length,\n        ],\n        world: [\n          prev.world[0] + curr.world[0] / points.length,\n          prev.world[1] + curr.world[1] / points.length,\n          prev.world[2] + curr.world[2] / points.length,\n        ],\n        touch: {\n          identifier: null,\n          radiusX: prev.touch.radiusX + curr.touch.radiusX / points.length,\n          radiusY: prev.touch.radiusY + curr.touch.radiusY / points.length,\n          force: prev.touch.force + curr.touch.force / points.length,\n          rotationAngle:\n            prev.touch.rotationAngle + curr.touch.rotationAngle / points.length,\n        },\n      };\n    },\n    {\n      page: [0, 0],\n      client: [0, 0],\n      canvas: [0, 0],\n      world: [0, 0, 0],\n      touch: {\n        identifier: null,\n        radiusX: 0,\n        radiusY: 0,\n        force: 0,\n        rotationAngle: 0,\n      },\n    }\n  );\n}\n/**\n * _subtractPoints - Subtracts `point1` from `point0`.\n * @param point0 - The first point.\n * @param point1 - The second point to subtract from the first.\n *\n * @returns The difference.\n */\nfunction _subtractPoints2D(\n  point0: Types.Point2,\n  point1: Types.Point2\n): Types.Point2 {\n  return [point0[0] - point1[0], point0[1] - point1[1]];\n}\n\nfunction _subtractPoints3D(\n  point0: Types.Point3,\n  point1: Types.Point3\n): Types.Point3 {\n  return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\n\nfunction _getMeanDistanceBetweenAllIPoints(points: IPoints[]): IDistance {\n  // get mean distance between all unordered pairs of points\n  const pairedDistance: IDistance[] = [];\n  for (let i = 0; i < points.length; i++) {\n    for (let j = 0; j < points.length; j++) {\n      if (i < j) {\n        pairedDistance.push({\n          page: _getDistance2D(points[i].page, points[j].page),\n          client: _getDistance2D(points[i].client, points[j].client),\n          canvas: _getDistance2D(points[i].canvas, points[j].canvas),\n          world: _getDistance3D(points[i].world, points[j].world),\n        });\n      }\n    }\n  }\n\n  // take the average distance\n  return pairedDistance.reduce(\n    (prev, curr) => {\n      return {\n        page: prev.page + curr.page / pairedDistance.length,\n        client: prev.client + curr.client / pairedDistance.length,\n        canvas: prev.canvas + curr.canvas / pairedDistance.length,\n        world: prev.world + curr.world / pairedDistance.length,\n      };\n    },\n    {\n      page: 0,\n      client: 0,\n      canvas: 0,\n      world: 0,\n    }\n  );\n}\n\nfunction _getDistance2D(point0: Types.Point2, point1: Types.Point2): number {\n  return Math.sqrt(\n    Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2)\n  );\n}\n\nfunction _getDistance3D(point0: Types.Point3, point1: Types.Point3): number {\n  return Math.sqrt(\n    Math.pow(point0[0] - point1[0], 2) +\n      Math.pow(point0[1] - point1[1], 2) +\n      Math.pow(point0[2] - point1[2], 2)\n  );\n}\n\nexport {\n  getMeanPoints,\n  getMeanTouchPoints,\n  copyPoints,\n  copyPointsList,\n  getDeltaDistanceBetweenIPoints,\n  getDeltaPoints,\n  getDeltaDistance,\n  getDeltaRotation,\n};\n","import { getRenderingEngine, type Types } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport { getToolGroup } from '../store/ToolGroupManager';\n\n/**\n * Triggers annotation rendering for the specified tool group IDs.\n *\n * @param toolGroupIds - An array of tool group IDs.\n */\nexport function triggerAnnotationRenderForToolGroupIds(\n  toolGroupIds: string[]\n): void {\n  toolGroupIds.forEach((toolGroupId) => {\n    const toolGroup = getToolGroup(toolGroupId);\n\n    if (!toolGroup) {\n      console.warn(`ToolGroup not available for ${toolGroupId}`);\n      return;\n    }\n\n    const viewportsInfo = toolGroup.getViewportsInfo();\n\n    viewportsInfo.forEach((viewportInfo) => {\n      const { renderingEngineId, viewportId } = viewportInfo;\n\n      const renderingEngine = getRenderingEngine(renderingEngineId);\n      if (!renderingEngine) {\n        console.warn(`RenderingEngine not available for ${renderingEngineId}`);\n        return;\n      }\n\n      const viewport = renderingEngine.getViewport(viewportId);\n      triggerAnnotationRender(viewport.element);\n    });\n  });\n}\n\nexport default triggerAnnotationRenderForToolGroupIds;\n","import {\n  cache,\n  StackViewport,\n  Types,\n  BaseVolumeViewport,\n} from '@cornerstonejs/core';\n\nfunction isViewportPreScaled(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  targetId: string\n): boolean {\n  if (viewport instanceof BaseVolumeViewport) {\n    const targetIdTokens = targetId.split('volumeId:');\n    const volumeId =\n      targetIdTokens.length > 1\n        ? targetIdTokens[1].split('?')[0]\n        : targetIdTokens[0];\n    const volume = cache.getVolume(volumeId);\n    return !!volume?.scaling && Object.keys(volume.scaling).length > 0;\n  } else if (viewport instanceof StackViewport) {\n    const { preScale } = viewport.getImageData() || {};\n    return !!preScale?.scaled;\n  } else {\n    return false;\n  }\n}\n\nexport { isViewportPreScaled };\n","import {\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  utilities as csUtils,\n  Types,\n} from '@cornerstonejs/core';\nimport JumpToSliceOptions from '../../types/JumpToSliceOptions';\nimport clip from '../clip';\nimport scroll from '../scroll';\n\n/**\n * It uses the imageIndex in the Options to scroll to the slice that is intended.\n * It works for both Stack and Volume viewports. In VolumeViewports, the imageIndex\n * should be given with respect to the index in the 3D image in the view direction\n * (i.e. the index of the slice in Axial, Sagittal, Coronal, or Oblique).\n *\n * @param element - the HTML Div element scrolling inside\n * @param options - the options used for jumping to a slice\n * @returns Promise that resolves to ImageIdIndex\n */\nasync function jumpToSlice(\n  element: HTMLDivElement,\n  options = {} as JumpToSliceOptions\n): Promise<void> {\n  const { imageIndex, debounceLoading, volumeId } = options;\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    throw new Error('Element has been disabled');\n  }\n\n  const { viewport } = enabledElement;\n\n  const { imageIndex: currentImageIndex, numberOfSlices } = _getImageSliceData(\n    viewport,\n    debounceLoading\n  );\n\n  const imageIndexToJump = _getImageIndexToJump(numberOfSlices, imageIndex);\n  const delta = imageIndexToJump - currentImageIndex;\n\n  scroll(viewport, { delta, debounceLoading, volumeId });\n}\n\nfunction _getImageSliceData(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  debounceLoading?: boolean\n): Types.ImageSliceData {\n  if (viewport instanceof StackViewport) {\n    return {\n      numberOfSlices: viewport.getImageIds().length,\n      imageIndex: debounceLoading\n        ? viewport.getTargetImageIdIndex()\n        : viewport.getCurrentImageIdIndex(),\n    };\n  } else if (viewport instanceof VolumeViewport) {\n    return csUtils.getImageSliceDataForVolumeViewport(viewport);\n  } else {\n    throw new Error('Unsupported viewport type');\n  }\n}\n\nfunction _getImageIndexToJump(\n  numberOfSlices: number,\n  imageIndex: number\n): number {\n  const lastSliceIndex = numberOfSlices - 1;\n\n  return clip(imageIndex, 0, lastSliceIndex);\n}\n\nexport default jumpToSlice;\n","import { VolumeViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec3 } from 'gl-matrix';\n\n// Todo: merge this utility functionality with Crosshair _jump\n/**\n * Uses the viewport's current camera to jump to a specific world coordinate\n * @param enabledElement - enabled element\n * @param jumpWorld - location in the world to jump to\n * @returns True if successful\n */\nexport default function jumpToWorld(\n  viewport: Types.IVolumeViewport,\n  jumpWorld: Types.Point3\n): true | undefined {\n  // if not instance of volumeViewport, return\n  if (!(viewport instanceof VolumeViewport)) {\n    return;\n  }\n\n  const { focalPoint } = viewport.getCamera();\n\n  const delta: Types.Point3 = [0, 0, 0];\n  vec3.sub(delta, jumpWorld, focalPoint);\n\n  _applyShift(viewport, delta);\n\n  return true;\n}\n\nfunction _applyShift(viewport, delta) {\n  const camera = viewport.getCamera();\n  const normal = camera.viewPlaneNormal;\n\n  const dotProd = vec3.dot(delta, normal);\n  const projectedDelta = vec3.fromValues(normal[0], normal[1], normal[2]);\n\n  vec3.scale(projectedDelta, projectedDelta, dotProd);\n\n  if (\n    Math.abs(projectedDelta[0]) > 1e-3 ||\n    Math.abs(projectedDelta[1]) > 1e-3 ||\n    Math.abs(projectedDelta[2]) > 1e-3\n  ) {\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newPosition: Types.Point3 = [0, 0, 0];\n\n    vec3.add(newFocalPoint, camera.focalPoint, projectedDelta);\n    vec3.add(newPosition, camera.position, projectedDelta);\n\n    viewport.setCamera({\n      focalPoint: newFocalPoint,\n      position: newPosition,\n    });\n    viewport.render();\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Given an array of viewports, returns a list of viewports that are viewing a\n * world space with the given `FrameOfReferenceUID`.\n *\n * @param viewports - An array of viewports.\n * @param FrameOfReferenceUID - The UID defining a particular world space/Frame Of Reference.\n *\n * @returns A filtered array of viewports.\n */\nexport default function filterViewportsWithFrameOfReferenceUID(\n  viewports: Array<Types.IViewport>,\n  FrameOfReferenceUID: string\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\n  const numViewports = viewports.length;\n  const viewportsWithFrameOfReferenceUID = [];\n\n  for (let vp = 0; vp < numViewports; vp++) {\n    const viewport = viewports[vp];\n\n    console.log(`VIEWPORT ${vp} WITH FORUID ${viewport.getFrameOfReferenceUID()}`)\n    if (viewport.getFrameOfReferenceUID() === FrameOfReferenceUID) {\n      viewportsWithFrameOfReferenceUID.push(viewport);\n    }\n  }\n\n  return viewportsWithFrameOfReferenceUID;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport type { IToolGroup } from '../../types';\nimport { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * Given an array of viewports, returns a list of viewports that have the the specified tool enabled.\n *\n * @param viewports - An array of viewports.\n * @param toolName - The name of the tool to filter on.\n *\n * @returns A filtered array of viewports.\n */\nexport default function filterViewportsWithToolEnabled(\n  viewports: Array<Types.IViewport>,\n  toolName: string\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\n  const numViewports = viewports.length;\n\n  const viewportsWithToolEnabled = [];\n\n  for (let vp = 0; vp < numViewports; vp++) {\n    const viewport = viewports[vp];\n\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\n      viewport.id,\n      viewport.renderingEngineId\n    );\n\n    if (!toolGroup) {\n      continue;\n    }\n\n    const hasTool = _toolGroupHasActiveEnabledOrPassiveTool(\n      toolGroup,\n      toolName\n    );\n\n    if (hasTool) {\n      viewportsWithToolEnabled.push(viewport);\n    }\n  }\n\n  return viewportsWithToolEnabled;\n}\n\n/**\n * Given a toolGroup, return true if it contains the tool with the given `toolName` and it is\n * active, passive or enabled.\n *\n * @param toolGroup - The `toolGroup` to check.\n * @param toolName - The name of the tool.\n *\n * @returns True if the tool is enabled, passive or active in the `toolGroup`.\n */\nfunction _toolGroupHasActiveEnabledOrPassiveTool(\n  toolGroup: IToolGroup,\n  toolName: string\n) {\n  const { toolOptions } = toolGroup;\n  const tool = toolOptions[toolName];\n\n  if (!tool) {\n    return false;\n  }\n\n  const toolMode = tool.mode;\n\n  return toolMode === Active || toolMode === Passive || toolMode === Enabled;\n}\n","import { vec3 } from 'gl-matrix';\n\n/**\n * It filters the viewports that are looking in the same view as the camera\n * It basically checks if the viewPlaneNormal is parallel to the camera viewPlaneNormal\n * @param viewports - Array of viewports to filter\n * @param camera - Camera to compare against\n * @returns - Array of viewports with the same view\n */\nexport function filterViewportsWithParallelNormals(\n  viewports,\n  camera,\n  EPS = 0.999\n) {\n  return viewports.filter((viewport) => {\n    const vpCamera = viewport.getCamera();\n\n    const isParallel =\n      Math.abs(vec3.dot(vpCamera.viewPlaneNormal, camera.viewPlaneNormal)) >\n      EPS;\n\n    return isParallel;\n  });\n}\n\nexport default filterViewportsWithParallelNormals;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport filterViewportsWithFrameOfReferenceUID from './filterViewportsWithFrameOfReferenceUID';\nimport filterViewportsWithToolEnabled from './filterViewportsWithToolEnabled';\nimport filterViewportsWithParallelNormals from './filterViewportsWithParallelNormals';\n\n/**\n * Given a cornerstone3D enabled `element`, and a `toolName`, find all viewportIds\n * looking at the same Frame Of Reference that have the tool with the given `toolName`\n * active, passive or enabled.\n *\n * @param element - The target cornerstone3D enabled element.\n * @param toolName - The string toolName.\n * @param requireParallelNormals - If true, only return viewports that have parallel normals.\n *\n * @returns An array of viewportIds.\n */\nexport default function getViewportIdsWithToolToRender(\n  element: HTMLDivElement,\n  toolName: string,\n  requireParallelNormals = true\n): string[] {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, FrameOfReferenceUID } = enabledElement;\n  // console.log('FORUID TO MATCH : ', FrameOfReferenceUID)\n\n  let viewports = renderingEngine.getViewports();\n\n  viewports = filterViewportsWithFrameOfReferenceUID(\n    viewports,\n    FrameOfReferenceUID\n  );\n  viewports = filterViewportsWithToolEnabled(viewports, toolName);\n\n  const viewport = renderingEngine.getViewport(enabledElement.viewportId);\n\n  if (requireParallelNormals) {\n    viewports = filterViewportsWithParallelNormals(\n      viewports,\n      viewport.getCamera()\n    );\n  }\n\n  const viewportIds = viewports.map((vp) => vp.id);\n\n  return viewportIds;\n}\n","import type { ColorbarImageRange } from '../types/ColorbarImageRange';\n\nconst isRangeValid = (range: ColorbarImageRange) => {\n  return range && range.upper > range.lower;\n};\n\nexport { isRangeValid as default, isRangeValid };\n","import type { ColorbarSize } from '../types/ColorbarSize';\n\nconst isColorbarSizeValid = (size: ColorbarSize) => {\n  return !!size && size.width > 0 && size.height > 0;\n};\n\nexport { isColorbarSizeValid as default, isColorbarSizeValid };\n","import type { ColorbarImageRange } from '../types/ColorbarImageRange';\n\nconst areColorbarRangesEqual = (\n  a: ColorbarImageRange,\n  b: ColorbarImageRange\n) => {\n  return !!a && !!b && a.lower === b.lower && a.upper === b.upper;\n};\n\nexport { areColorbarRangesEqual as default, areColorbarRangesEqual };\n","import type { ColorbarSize } from '../types/ColorbarSize';\n\nconst areColorbarSizesEqual = (a: ColorbarSize, b: ColorbarSize) => {\n  return !!a && !!b && a.width === b.width && a.height === b.height;\n};\n\nexport { areColorbarSizesEqual as default, areColorbarSizesEqual };\n","/**\n * Linear interpolation between two vec3.\n * Can be used, for example, to interpolate between two RGB colors.\n * @param a - First vec3\n * @param b - Second vec3\n * @param t - Time \"t\".\n *   - Vector A is returned for values smaller than or equel to 0.\n *   - Vector B is returned for values greater than or equal to 1.\n *   - An interpolation between vectors A and B is returned otherwise.\n * @returns\n */\nconst interpolateVec3 = (a, b, t) => {\n  return [\n    a[0] * (1 - t) + b[0] * t,\n    a[1] * (1 - t) + b[1] * t,\n    a[2] * (1 - t) + b[2] * t,\n  ];\n};\n\nexport { interpolateVec3 as default, interpolateVec3 };\n","import { IColorMapPreset } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\nimport { utilities } from '@cornerstonejs/core';\nimport interpolateVec3 from '../../math/vec3/interpolateVec3';\nimport { ColorbarCanvasProps } from './types/ColorbarCanvasProps';\nimport type { ColorbarImageRange, ColorbarVOIRange } from './types';\nimport type { ColorbarSize } from './types/ColorbarSize';\nimport {\n  isRangeValid,\n  areColorbarRangesEqual,\n  isColorbarSizeValid,\n  areColorbarSizesEqual,\n} from './common';\n\nconst { clamp } = utilities;\n\n/**\n * Canvas referenced by the color bar where the colormap is rendered. It may\n * show the full image range or only the VOI range.\n */\nclass ColorbarCanvas {\n  private _canvas: HTMLCanvasElement;\n  private _imageRange: ColorbarImageRange;\n  private _voiRange: ColorbarVOIRange;\n  private _colormap: IColorMapPreset;\n  private _showFullImageRange: boolean;\n\n  constructor(props: ColorbarCanvasProps) {\n    ColorbarCanvas.validateProps(props);\n\n    const {\n      colormap,\n      size = { width: 20, height: 100 },\n      imageRange = { lower: 0, upper: 1 },\n      voiRange = { lower: 0, upper: 1 },\n      container,\n      showFullPixelValueRange = false,\n    } = props;\n\n    this._colormap = colormap;\n    this._imageRange = imageRange;\n    this._voiRange = voiRange;\n    this._showFullImageRange = showFullPixelValueRange;\n    this._canvas = this._createRootElement(size);\n\n    if (container) {\n      this.appendTo(container);\n    }\n  }\n\n  public get colormap(): IColorMapPreset {\n    return this._colormap;\n  }\n\n  public set colormap(colormap: IColorMapPreset) {\n    this._colormap = colormap;\n    this.render();\n  }\n\n  public get size(): ColorbarSize {\n    const { width, height } = this._canvas;\n    return { width, height };\n  }\n\n  public set size(size: ColorbarSize) {\n    const { _canvas: canvas } = this;\n\n    if (!isColorbarSizeValid(size) || areColorbarSizesEqual(canvas, size)) {\n      return;\n    }\n\n    this._setCanvasSize(canvas, size);\n    this.render();\n  }\n\n  public get imageRange(): ColorbarImageRange {\n    return { ...this._imageRange };\n  }\n\n  public set imageRange(imageRange: ColorbarImageRange) {\n    if (\n      !isRangeValid(imageRange) ||\n      areColorbarRangesEqual(imageRange, this._imageRange)\n    ) {\n      return;\n    }\n\n    this._imageRange = imageRange;\n    this.render();\n  }\n\n  public get voiRange(): ColorbarVOIRange {\n    return { ...this._voiRange };\n  }\n\n  public set voiRange(voiRange: ColorbarVOIRange) {\n    if (\n      !isRangeValid(voiRange) ||\n      areColorbarRangesEqual(voiRange, this._voiRange)\n    ) {\n      return;\n    }\n\n    this._voiRange = voiRange;\n    this.render();\n  }\n\n  public get showFullImageRange(): boolean {\n    return this._showFullImageRange;\n  }\n\n  public set showFullImageRange(showFullImageRange: boolean) {\n    if (showFullImageRange === this._showFullImageRange) {\n      return;\n    }\n\n    this._showFullImageRange = showFullImageRange;\n    this.render();\n  }\n\n  public appendTo(container: HTMLElement) {\n    container.appendChild(this._canvas);\n    this.render();\n  }\n\n  public dispose() {\n    const { _canvas: canvas } = this;\n    const { parentElement } = canvas;\n\n    parentElement?.removeChild(canvas);\n  }\n\n  private static validateProps(props: ColorbarCanvasProps) {\n    const { size, imageRange, voiRange } = props;\n\n    if (size && !isColorbarSizeValid(size)) {\n      throw new Error('Invalid \"size\"');\n    }\n\n    if (imageRange && !isRangeValid(imageRange)) {\n      throw new Error('Invalid \"imageRange\"');\n    }\n\n    if (voiRange && !isRangeValid(voiRange)) {\n      throw new Error('Invalid \"voiRange\"');\n    }\n  }\n\n  private _setCanvasSize(canvas: HTMLCanvasElement, size: ColorbarSize) {\n    const { width, height } = size;\n\n    canvas.width = width;\n    canvas.height = height;\n\n    Object.assign(canvas.style, {\n      width: `${width}px`,\n      height: `${height}px`,\n    });\n  }\n\n  private _createRootElement(size: ColorbarSize) {\n    const canvas = document.createElement('canvas');\n\n    Object.assign(canvas.style, {\n      position: 'absolute',\n      top: '0',\n      left: '0',\n      pointerEvents: 'none',\n      boxSizing: 'border-box',\n    });\n\n    this._setCanvasSize(canvas, size);\n\n    return canvas;\n  }\n\n  private render(): void {\n    if (!this._canvas.isConnected) {\n      return;\n    }\n\n    const { _colormap: colormap } = this;\n    const { RGBPoints: rgbPoints } = colormap;\n    const colorsCount = rgbPoints.length / 4;\n\n    // Returns a color point from rgbPoints. Each point has position, red,\n    // green and blue components which means each point has an offset equal\n    // to `4 * index`\n    const getColorPoint = (index) => {\n      const offset = 4 * index;\n\n      // It can get out of bounds when `voiRange.upper` is smaller than\n      // `imageRange.upper`. It's also checking if is smaller than zero\n      // for safety only because that should never happens.\n      if (index < 0 || index >= colorsCount) {\n        return;\n      }\n\n      return {\n        index,\n        position: rgbPoints[offset],\n        color: [\n          rgbPoints[offset + 1],\n          rgbPoints[offset + 2],\n          rgbPoints[offset + 3],\n        ],\n      };\n    };\n\n    const { width, height } = this._canvas;\n    const canvasContext = this._canvas.getContext('2d');\n    const isHorizontal = width > height;\n    const maxValue = isHorizontal ? width : height;\n    const { _voiRange: voiRange } = this;\n    const range = this._showFullImageRange ? this._imageRange : { ...voiRange };\n\n    const { windowWidth } = utilities.windowLevel.toWindowLevel(\n      voiRange.lower,\n      voiRange.upper\n    );\n\n    let previousColorPoint = undefined;\n    let currentColorPoint = getColorPoint(0);\n\n    // Starts from `range.lower` incrementing by incRawPixelValue on each iteration\n    const incRawPixelValue = (range.upper - range.lower) / (maxValue - 1);\n    let rawPixelValue = range.lower;\n\n    for (let i = 0; i < maxValue; i++) {\n      const tVoiRange = (rawPixelValue - voiRange.lower) / windowWidth;\n\n      // Find the color in a linear way (O(n) complexity).\n      // currentColorPoint shall move to the next color until tVoiRange is smaller\n      // than or equal to next color position.\n      if (currentColorPoint) {\n        for (let i = currentColorPoint.index; i < colorsCount; i++) {\n          if (tVoiRange <= currentColorPoint.position) {\n            break;\n          }\n\n          previousColorPoint = currentColorPoint;\n          currentColorPoint = getColorPoint(i + 1);\n        }\n      }\n\n      let normColor;\n\n      // For:\n      //   - firstColorPoint = getColorPoint(0)\n      //   - secondColorPoint = getColorPoint(1)\n      //   - lastColorPoint = getColorPoint(colorsCount - 1)\n      // Then\n      //   - previousColorPoint shall be undefined when tVoiRange < firstColorPoint.position\n      //   - currentColorPoint shall be undefined when tVoiRange > lastColorPoint.position\n      //   - previousColorPoint and currentColorPoint will be defined when\n      //     currentColorPoint.position is between secondColorPoint.position and\n      //     lastColorPoint.position.\n      if (!previousColorPoint) {\n        normColor = [...currentColorPoint.color];\n      } else if (!currentColorPoint) {\n        normColor = [...previousColorPoint.color];\n      } else {\n        const tColorRange =\n          (tVoiRange - previousColorPoint.position) /\n          (currentColorPoint.position - previousColorPoint.position);\n\n        normColor = interpolateVec3(\n          previousColorPoint.color,\n          currentColorPoint.color,\n          tColorRange\n        );\n      }\n\n      const color = normColor.map((color) =>\n        clamp(Math.round(color * 255), 0, 255)\n      );\n\n      canvasContext.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;\n\n      if (isHorizontal) {\n        canvasContext.fillRect(i, 0, 1, height);\n      } else {\n        canvasContext.fillRect(0, height - i - 1, width, 1);\n      }\n\n      rawPixelValue += incRawPixelValue;\n    }\n  }\n}\n\nexport { ColorbarCanvas as default, ColorbarCanvas };\n","import type {\n  ColorbarImageRange,\n  ColorbarVOIRange,\n  ColorbarSize,\n  ColorbarTicksProps,\n} from './types';\nimport {\n  isColorbarSizeValid,\n  isRangeValid,\n  areColorbarRangesEqual,\n  areColorbarSizesEqual,\n} from './common';\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\n\nconst DEFAULTS = {\n  FONT: '10px Arial',\n  COLOR: 'white',\n  TICK_SIZE: 5,\n  TICK_WIDTH: 1,\n  TICK_LABEL_MARGIN: 3,\n  MAX_NUM_TICKS: 8,\n\n  // Must start with 1 and end with 10\n  TICKS_STEPS: [1, 2.5, 5, 10],\n};\n\nclass ColorbarTicks {\n  private _canvas: HTMLCanvasElement;\n  private _imageRange: ColorbarImageRange;\n  private _voiRange: ColorbarVOIRange;\n  private _color: string;\n  private _tickSize: number;\n  private _tickWidth: number;\n  private _labelMargin: number;\n  private _maxNumTicks: number;\n  private _rangeTextPosition: ColorbarRangeTextPosition;\n  private _showFullPixelValueRange: boolean;\n  private _font: string;\n\n  constructor(props: ColorbarTicksProps) {\n    ColorbarTicks.validateProps(props);\n\n    const {\n      top = 0,\n      left = 0,\n      size = { width: 20, height: 100 },\n      imageRange = { lower: 0, upper: 1 },\n      voiRange = { lower: 0, upper: 1 },\n      ticks: ticksProps,\n      container,\n      showFullPixelValueRange = false,\n    } = props;\n\n    const { style: ticksStyle, position: rangeTextPosition } = ticksProps ?? {};\n\n    this._imageRange = imageRange;\n    this._voiRange = voiRange;\n    this._font = ticksStyle?.font ?? DEFAULTS.FONT;\n    this._color = ticksStyle?.color ?? DEFAULTS.COLOR;\n    this._tickSize = ticksStyle?.tickSize ?? DEFAULTS.TICK_SIZE;\n    this._tickWidth = ticksStyle?.tickWidth ?? DEFAULTS.TICK_WIDTH;\n    this._labelMargin = ticksStyle?.labelMargin ?? DEFAULTS.TICK_LABEL_MARGIN;\n    this._maxNumTicks = ticksStyle?.maxNumTicks ?? DEFAULTS.MAX_NUM_TICKS;\n    this._rangeTextPosition =\n      rangeTextPosition ?? ColorbarRangeTextPosition.Right;\n    this._showFullPixelValueRange = showFullPixelValueRange;\n    this._canvas = this._createCanvasElement(size, top, left);\n\n    if (container) {\n      this.appendTo(container);\n    }\n  }\n\n  public get size(): ColorbarSize {\n    const { width, height } = this._canvas;\n    return { width, height };\n  }\n\n  public set size(size: ColorbarSize) {\n    const { _canvas: canvas } = this;\n\n    if (!isColorbarSizeValid(size) || areColorbarSizesEqual(canvas, size)) {\n      return;\n    }\n\n    this._setCanvasSize(canvas, size);\n    this.render();\n  }\n\n  /**\n   * Canvas top position (pixels)\n   */\n  public get top(): number {\n    return Number.parseInt(this._canvas.style.top);\n  }\n\n  /**\n   * Change the canvas top position (pixels)\n   */\n  public set top(top: number) {\n    const { _canvas: canvas } = this;\n    const currentTop = this.top;\n\n    if (top === currentTop) {\n      return;\n    }\n\n    canvas.style.top = `${top}px`;\n    this.render();\n  }\n\n  /**\n   * Canvas left position (pixels)\n   */\n  public get left(): number {\n    return Number.parseInt(this._canvas.style.left);\n  }\n\n  /**\n   * Change the canvas left position (pixels)\n   */\n  public set left(left: number) {\n    const { _canvas: canvas } = this;\n    const currentLeft = this.left;\n\n    if (left === currentLeft) {\n      return;\n    }\n\n    canvas.style.left = `${left}px`;\n    this.render();\n  }\n\n  /**\n   * Image range\n   */\n  public get imageRange() {\n    return { ...this._imageRange };\n  }\n\n  /**\n   * Set the image range that should goes from minPixelValue to maxPixelValue\n   */\n  public set imageRange(imageRange: ColorbarVOIRange) {\n    if (\n      !isRangeValid(imageRange) ||\n      areColorbarRangesEqual(imageRange, this._imageRange)\n    ) {\n      return;\n    }\n\n    this._imageRange = imageRange;\n    this.render();\n  }\n\n  /**\n   * VOI range\n   * (lower: wc - ww / 2, upper: wc + ww / 2)\n   */\n  public get voiRange() {\n    return { ...this._voiRange };\n  }\n\n  /**\n   * Set the VOI Range\n   * (lower: wc - ww / 2, upper: wc + ww / 2)\n   */\n  public set voiRange(voiRange: ColorbarVOIRange) {\n    if (\n      !isRangeValid(voiRange) ||\n      areColorbarRangesEqual(voiRange, this._voiRange)\n    ) {\n      return;\n    }\n\n    this._voiRange = voiRange;\n    this.render();\n  }\n\n  /**\n   * Tick size (pixels)\n   */\n  public get tickSize(): number {\n    return this._tickSize;\n  }\n\n  /**\n   * Set the tick size\n   */\n  public set tickSize(tickSize: number) {\n    if (tickSize === this._tickSize) {\n      return;\n    }\n\n    this._tickSize = tickSize;\n    this.render();\n  }\n\n  /**\n   * Tick width (pixels)\n   */\n  public get tickWidth(): number {\n    return this._tickWidth;\n  }\n\n  /**\n   * Set the tick width. This width is used as `lineWidth` by CanvasRenderingContext2D.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineWidth\n   */\n  public set tickWidth(tickWidth: number) {\n    if (tickWidth === this._tickWidth) {\n      return;\n    }\n\n    this._tickWidth = tickWidth;\n    this.render();\n  }\n\n  /**\n   * Color used for ticks and labels.\n   */\n  public get color(): string {\n    return this._color;\n  }\n\n  /**\n   * Set the color used for ticks and labels. This color is used as `strokeStyle`\n   * and `fillStyle` by CanvasRenderingContext2D.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle\n   */\n  public set color(color: string) {\n    if (color === this._color) {\n      return;\n    }\n\n    this._color = color;\n    this.render();\n  }\n\n  /**\n   * Return `true` when the ticks displayed are in the range from `imageRange.lower`\n   * to `imageRange.upper` or `false` when they are in the range from `voiRange.lower`\n   * to `voiRange.upper`\n   */\n  public get showFullPixelValueRange(): boolean {\n    return this._showFullPixelValueRange;\n  }\n\n  /**\n   * Change which range should be used when rendering the ticks. Set it to `true`\n   * to show from `imageRange.lower` to `imageRange.upper` or `false` show from\n   * `voiRange.lower` to `voiRange.upper`.\n   */\n  public set showFullPixelValueRange(showFullRange: boolean) {\n    if (showFullRange === this._showFullPixelValueRange) {\n      return;\n    }\n\n    this._showFullPixelValueRange = showFullRange;\n    this.render();\n  }\n\n  /**\n   * Ticks visibility\n   */\n  public get visible() {\n    return this._canvas.style.display === 'block';\n  }\n\n  /**\n   * Show/Hide the ticks\n   */\n  public set visible(visible) {\n    if (visible === this.visible) {\n      return;\n    }\n\n    this._canvas.style.display = visible ? 'block' : 'none';\n\n    if (visible) {\n      this.render();\n    }\n  }\n\n  /**\n   * Append the canvas to its parent element\n   * @param container - HTML element where the canvas should be added to\n   */\n  public appendTo(container: HTMLElement) {\n    container.appendChild(this._canvas);\n    this.render();\n  }\n\n  private static validateProps(props: ColorbarTicksProps) {\n    const { size, imageRange, voiRange } = props;\n\n    if (size && !isColorbarSizeValid(size)) {\n      throw new Error('Invalid \"size\"');\n    }\n\n    if (imageRange && !isRangeValid(imageRange)) {\n      throw new Error('Invalid \"imageRange\"');\n    }\n\n    if (voiRange && !isRangeValid(voiRange)) {\n      throw new Error('Invalid \"voiRange\"');\n    }\n  }\n\n  private _setCanvasSize(canvas: HTMLCanvasElement, size: ColorbarSize) {\n    const { width, height } = size;\n\n    canvas.width = width;\n    canvas.height = height;\n\n    Object.assign(canvas.style, {\n      width: `${width}px`,\n      height: `${height}px`,\n    });\n  }\n\n  private _createCanvasElement(\n    size: ColorbarSize,\n    top: number,\n    left: number\n  ): HTMLCanvasElement {\n    const canvas = document.createElement('canvas');\n\n    Object.assign(canvas.style, {\n      display: 'none',\n      position: 'absolute',\n      boxSizing: 'border-box',\n      top: `${top}px`,\n      left: `${left}px`,\n    });\n\n    this._setCanvasSize(canvas, size);\n\n    return canvas;\n  }\n\n  /**\n   * Calculate how many ticks can be displayed on the screen based on the\n   * pre-defined steps (`TICKS_STEPS`) as follow:\n   *   1. Calculate what should be the step (`roughStep`) based on the range and\n   *   the number of desired steps (`maxNumTicks`).\n   *   2. Find a number power of 10 (eg: 0.1, 1, 10, 100, etc.) that can be used\n   *   to multiply `roughStep` and return a number between 1 and 10 which is\n   *   called `roughtStepNormalized`.\n   *   3. Find in the TICKS_STEPS array a number that is bigger than or equal to\n   *   the `roughtStepNormalized` value (`normalizedStep`).\n   *   4. Multiply the `normalizedStep` to move it to the real range.\n   *\n   * @param range - Range with \"lower\" and \"upper\" values\n   */\n  private _getTicks(range) {\n    const { lower, upper } = range;\n    const rangeValue = upper - lower;\n\n    // First approximation based on the max number of ticks\n    const roughStep = rangeValue / (this._maxNumTicks - 1);\n\n    // Normalize rough step to find the normalized one that fits best\n    const stepPower = Math.pow(\n      10,\n      -Math.floor(Math.log10(Math.abs(roughStep)))\n    );\n\n    // Get a number between 1 and 10\n    const roughtStepNormalized = roughStep * stepPower;\n\n    // Find a normalize step that is greater than or equal to `roughtStepNormalized`\n    const normalizedStep = DEFAULTS.TICKS_STEPS.find(\n      (n) => n >= roughtStepNormalized\n    );\n\n    // Move `normalizedStep` to the real range\n    const step = normalizedStep / stepPower;\n\n    // Determine the scale limits based on the chosen step.\n    const scaleMax = Math.ceil(upper / step) * step;\n    const scaleMin = Math.floor(lower / step) * step;\n\n    // Find a possible tick values for the `step` computed\n    const ticksCount = Math.round((scaleMax - scaleMin) / step) + 1;\n    const ticks = [];\n\n    for (let i = 0; i < ticksCount; i++) {\n      ticks.push(scaleMin + i * step);\n    }\n\n    return { scaleMin, scaleMax, step, ticks };\n  }\n\n  private _getLeftTickInfo({ position, labelMeasure }) {\n    const { width } = this._canvas;\n    const labelX =\n      width - this.tickSize - labelMeasure.width - this._labelMargin;\n    const labelPoint = [labelX, position];\n    const tickPoints = {\n      start: [width - this._tickSize, position],\n      end: [width, position],\n    };\n\n    return { labelPoint, tickPoints };\n  }\n\n  private _getRightTickInfo({ position }) {\n    const labelPoint = [this._tickSize + this._labelMargin, position];\n    const tickPoints = {\n      start: [0, position],\n      end: [this._tickSize, position],\n    };\n\n    return { labelPoint, tickPoints };\n  }\n\n  private _getTopTickInfo({ position, labelMeasure }) {\n    throw new Error('Not implemented');\n  }\n\n  private _getBottomTickInfo({ position, labelMeasure }) {\n    throw new Error('Not implemented');\n  }\n\n  private render() {\n    const { _canvas: canvas } = this;\n\n    if (!canvas.isConnected || !this.visible) {\n      return;\n    }\n\n    const { width, height } = canvas;\n    const isHorizontal = width >= height;\n    const maxCanvasPixelValue = isHorizontal ? width : height;\n    const canvasContext = canvas.getContext('2d');\n    const { _voiRange: voiRange } = this;\n    const range = this._showFullPixelValueRange\n      ? this._imageRange\n      : { ...voiRange };\n    const rangeWidth = range.upper - range.lower;\n    const { ticks } = this._getTicks(range);\n\n    canvasContext.clearRect(0, 0, width, height);\n    canvasContext.font = this._font;\n    canvasContext.textBaseline = 'middle';\n    canvasContext.fillStyle = this._color;\n    canvasContext.strokeStyle = this._color;\n    canvasContext.lineWidth = this.tickWidth;\n\n    ticks.forEach((tick) => {\n      let position = Math.round(\n        maxCanvasPixelValue * ((tick - range.lower) / rangeWidth)\n      );\n\n      // Zero at the bottom and max at the top on vertical colorbars\n      if (!isHorizontal) {\n        position = height - position;\n      }\n\n      if (position < 0 || position > maxCanvasPixelValue) {\n        return;\n      }\n\n      const label = tick.toString();\n      const labelMeasure = canvasContext.measureText(label);\n      let tickInfo;\n\n      if (isHorizontal) {\n        if (this._rangeTextPosition === ColorbarRangeTextPosition.Top) {\n          tickInfo = this._getTopTickInfo({ position, labelMeasure });\n        } else {\n          tickInfo = this._getBottomTickInfo({ position, labelMeasure });\n        }\n      } else {\n        if (this._rangeTextPosition === ColorbarRangeTextPosition.Left) {\n          tickInfo = this._getLeftTickInfo({ position, labelMeasure });\n        } else {\n          tickInfo = this._getRightTickInfo({ position });\n        }\n      }\n\n      const { labelPoint, tickPoints } = tickInfo;\n      const { start: tickStart, end: tickEnd } = tickPoints;\n\n      canvasContext.beginPath();\n      canvasContext.moveTo(tickStart[0], tickStart[1]);\n      canvasContext.lineTo(tickEnd[0], tickEnd[1]);\n      canvasContext.fillText(label, labelPoint[0], labelPoint[1]);\n      canvasContext.stroke();\n\n      return position;\n    });\n  }\n}\n\nexport { ColorbarTicks as default, ColorbarTicks };\n","import type { WidgetProps, WidgetSize } from './types';\n\n/**\n * Base class for any widget that can be added to cornerstone. Currently it is\n * responsible only for holding the `rootElement`, contains a method that allows\n * adding it to the DOM and it also listens to container's size changes when the\n * widget is already added to the DOM. `dispose` must be called to destroy the\n * widget because it removes the widget from the DOM and stop listening to\n * container changes.\n *\n * You can apply some styles to widgets using the widget id or the `widget` class.\n *\n * Example:\n *   type ColorPickerProps = WidgetProps & {\n *     selectedColor: string;\n *   }\n *\n *   class ColorPicker extends Widget {\n *     constructor(props: ColorPickerProps) {\n *       super(props);\n *       // [code]\n *     }\n *\n *     public show() {\n *       console.log('Show color picker');\n *     }\n *\n *     protected containerResized() {\n *       console.log('New container size: ', this.containerSize);\n *     }\n *   }\n *\n *   const colorPicker = new ColorPicker({\n *     container: document.body,\n *     selectedColor: '#000';\n *   });\n *\n *   // another way to add the color picker to the DOM\n *   colorPicker.appendTo(document.body)\n *\n *   // Show color picker\n *   colorPicker.show();\n */\nabstract class Widget {\n  private _id: string;\n  private _rootElement: HTMLElement;\n  private _containerSize: WidgetSize;\n  private _containerResizeObserver: ResizeObserver;\n\n  constructor({ id, container }: WidgetProps) {\n    this._id = id;\n    this._containerSize = { width: 0, height: 0 };\n    this._rootElement = this.createRootElement(id);\n    this._containerResizeObserver = new ResizeObserver(\n      this._containerResizeCallback\n    );\n\n    if (container) {\n      this.appendTo(container);\n    }\n  }\n\n  /**\n   * Widget id\n   */\n  public get id() {\n    return this._id;\n  }\n\n  /**\n   * Widget's root element\n   */\n  public get rootElement(): HTMLElement {\n    return this._rootElement;\n  }\n\n  /**\n   * Append the widget to a parent element\n   * @param container - HTML element where the widget should be added to\n   */\n  public appendTo(container: HTMLElement) {\n    const {\n      _rootElement: rootElement,\n      _containerResizeObserver: resizeObserver,\n    } = this;\n    const { parentElement: currentContainer } = rootElement;\n\n    if (!container || container === currentContainer) {\n      return;\n    }\n\n    if (currentContainer) {\n      resizeObserver.unobserve(currentContainer);\n    }\n\n    container.appendChild(rootElement);\n    resizeObserver.observe(container);\n  }\n\n  /**\n   * Removes the widget from the DOM and stop listening to DOM events\n   */\n  public destroy() {\n    const {\n      _rootElement: rootElement,\n      _containerResizeObserver: resizeObserver,\n    } = this;\n    const { parentElement } = rootElement;\n\n    parentElement?.removeChild(rootElement);\n    resizeObserver.disconnect();\n  }\n\n  protected get containerSize(): WidgetSize {\n    // Returns a copy to prevent any external change\n    return { ...this._containerSize };\n  }\n\n  /**\n   * Creates the root element which is a div by default\n   * @param id - Root element id\n   * @returns A new HTML element where all other elements should be added to\n   */\n  protected createRootElement(id: string): HTMLElement {\n    const rootElement = document.createElement('div');\n\n    rootElement.id = id;\n    rootElement.classList.add('widget');\n\n    Object.assign(rootElement.style, {\n      width: '100%',\n      height: '100%',\n    });\n\n    return rootElement;\n  }\n\n  /**\n   * Method called every time widget's container is resize giving the\n   * opportunity to children classes to act when that happens.\n   */\n  protected onContainerResize() {\n    // no-op\n  }\n\n  private _containerResizeCallback = (entries: ResizeObserverEntry[]): void => {\n    let width;\n    let height;\n\n    const { contentRect, contentBoxSize } = entries[0];\n\n    // `contentRect` is better supported than `borderBoxSize` or `contentBoxSize`,\n    // but it is left over from an earlier implementation of the Resize Observer API\n    // and may be deprecated in future versions.\n    // https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry/contentRect\n    if (contentRect) {\n      width = contentRect.width;\n      height = contentRect.height;\n    } else if (contentBoxSize?.length) {\n      width = contentBoxSize[0].inlineSize;\n      height = contentBoxSize[0].blockSize;\n    }\n\n    this._containerSize = { width, height };\n    this.onContainerResize();\n  };\n}\n\nexport { Widget as default, Widget };\n","import { IColorMapPreset } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\nimport { vec2 } from 'gl-matrix';\nimport { utilities as csUtils, Types } from '@cornerstonejs/core';\nimport type { ColorbarProps, ColorbarVOIRange } from './types';\nimport { isRangeValid, areColorbarRangesEqual } from './common';\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\nimport { ColorbarCanvas } from './ColorbarCanvas';\nimport { ColorbarTicks } from './ColorbarTicks';\nimport isRangeTextPositionValid from './common/isRangeTextPositionValid';\nimport Widget from '../../../widgets/Widget';\n\nconst DEFAULTS = {\n  MULTIPLIER: 1,\n  RANGE_TEXT_POSITION: ColorbarRangeTextPosition.Right,\n  TICKS_BAR_SIZE: 50,\n};\n\ntype ColorbarPoints = {\n  page: Types.Point2;\n  client: Types.Point2;\n  local: Types.Point2;\n};\n\n/**\n * A base colorbar class that is not associated with any viewport. It is\n * possible to click and drag to change the VOI range, shows the ticks during\n * interaction and it can show full image range or VOI range.\n */\nclass Colorbar extends Widget {\n  private _colormaps: Map<string, IColorMapPreset>;\n  private _activeColormapName: string;\n  private _eventListenersManager: csUtils.eventListener.MultiTargetEventListenerManager;\n  private _canvas: ColorbarCanvas;\n  private _ticksBar: ColorbarTicks;\n  private _rangeTextPosition: ColorbarRangeTextPosition;\n\n  private _isMouseOver = false;\n  private _isInteracting = false;\n\n  constructor(props: ColorbarProps) {\n    super(props);\n\n    this._eventListenersManager =\n      new csUtils.eventListener.MultiTargetEventListenerManager();\n    this._colormaps = Colorbar.getColormapsMap(props);\n    this._activeColormapName = Colorbar.getInitialColormapName(props);\n    this._canvas = this._createCanvas(props);\n    this._ticksBar = this._createTicksBar(props);\n    this._rangeTextPosition =\n      props.ticks?.position ?? DEFAULTS.RANGE_TEXT_POSITION;\n\n    this._canvas.appendTo(this.rootElement);\n    this._ticksBar.appendTo(this.rootElement);\n\n    this._addRootElementEventListeners();\n  }\n\n  /**\n   * Returns the active LUT name\n   */\n  public get activeColormapName() {\n    return this._activeColormapName;\n  }\n\n  /**\n   * Set the current active LUT name and re-renders the color bar\n   */\n  public set activeColormapName(colormapName: string) {\n    if (colormapName === this._activeColormapName) {\n      return;\n    }\n\n    const colormap = this._colormaps.get(colormapName);\n\n    if (!colormap) {\n      console.warn(`Invalid colormap name (${colormapName})`);\n      return;\n    }\n\n    this._activeColormapName = colormapName;\n    this._canvas.colormap = colormap;\n  }\n\n  public get imageRange() {\n    return this._canvas.imageRange;\n  }\n\n  public set imageRange(imageRange: ColorbarVOIRange) {\n    this._canvas.imageRange = imageRange;\n    this._ticksBar.imageRange = imageRange;\n  }\n\n  public get voiRange() {\n    return this._canvas.voiRange;\n  }\n\n  public set voiRange(voiRange: ColorbarVOIRange) {\n    const { voiRange: currentVoiRange } = this._canvas;\n\n    if (\n      !isRangeValid(voiRange) ||\n      areColorbarRangesEqual(voiRange, currentVoiRange)\n    ) {\n      return;\n    }\n\n    this._canvas.voiRange = voiRange;\n    this._ticksBar.voiRange = voiRange;\n    this.onVoiChange(voiRange);\n  }\n\n  public get showFullImageRange() {\n    return this._canvas.showFullImageRange;\n  }\n\n  public set showFullImageRange(value: boolean) {\n    this._canvas.showFullImageRange = value;\n    this._ticksBar.showFullPixelValueRange = value;\n  }\n\n  public destroy() {\n    super.destroy();\n    this._eventListenersManager.reset();\n  }\n\n  protected createRootElement(): HTMLElement {\n    const rootElement = document.createElement('div');\n\n    Object.assign(rootElement.style, {\n      position: 'relative',\n      fontSize: '0',\n      width: '100%',\n      height: '100%',\n    });\n\n    return rootElement;\n  }\n\n  protected onContainerResize() {\n    super.onContainerResize();\n    this.updateTicksBar();\n    this._canvas.size = this.containerSize;\n  }\n\n  protected getVOIMultipliers(): [number, number] {\n    return [DEFAULTS.MULTIPLIER, DEFAULTS.MULTIPLIER];\n  }\n\n  protected onVoiChange(voiRange: ColorbarVOIRange) {\n    // no-op\n  }\n\n  protected showTicks() {\n    this.updateTicksBar();\n    this._ticksBar.visible = true;\n  }\n\n  protected hideTicks() {\n    if (this._isInteracting || this._isMouseOver) {\n      return;\n    }\n\n    this._ticksBar.visible = false;\n  }\n\n  private static getColormapsMap(props: ColorbarProps) {\n    const { colormaps } = props;\n\n    return colormaps.reduce(\n      (items, item) => items.set(item.Name, item),\n      new Map<string, IColorMapPreset>()\n    );\n  }\n\n  private static getInitialColormapName(props: ColorbarProps) {\n    const { activeColormapName, colormaps } = props;\n    const colormapExists =\n      !!activeColormapName &&\n      colormaps.some((cm) => cm.Name === activeColormapName);\n\n    return colormapExists ? activeColormapName : colormaps[0].Name;\n  }\n\n  private _createCanvas(props: ColorbarProps) {\n    const { imageRange, voiRange, showFullPixelValueRange } = props;\n    const colormap = this._colormaps.get(this._activeColormapName);\n\n    return new ColorbarCanvas({\n      colormap,\n      imageRange,\n      voiRange: voiRange,\n      showFullPixelValueRange,\n    });\n  }\n\n  public _createTicksBar(props: ColorbarProps): ColorbarTicks {\n    const ticksProps = props.ticks;\n\n    return new ColorbarTicks({\n      imageRange: props.imageRange,\n      voiRange: props.voiRange,\n      ticks: ticksProps,\n      showFullPixelValueRange: props.showFullPixelValueRange,\n    });\n  }\n\n  private _getPointsFromMouseEvent(evt: MouseEvent): ColorbarPoints {\n    const { rootElement: element } = this;\n    const clientPoint: Types.Point2 = [evt.clientX, evt.clientY];\n    const pagePoint: Types.Point2 = [evt.pageX, evt.pageY];\n    const rect = element.getBoundingClientRect();\n    const localPoints: Types.Point2 = [\n      pagePoint[0] - rect.left - window.pageXOffset,\n      pagePoint[1] - rect.top - window.pageYOffset,\n    ];\n\n    return { client: clientPoint, page: pagePoint, local: localPoints };\n  }\n\n  private updateTicksBar() {\n    const { width: containerWidth, height: containerHeight } =\n      this.containerSize;\n\n    // ResizeObserver have not triggered any event when this happen\n    if (containerWidth === 0 && containerHeight === 0) {\n      return;\n    }\n\n    const { _ticksBar: ticksBar, _rangeTextPosition: rangeTextPosition } = this;\n    const isHorizontal = containerWidth >= containerHeight;\n    const width = isHorizontal ? containerWidth : DEFAULTS.TICKS_BAR_SIZE;\n    const height = isHorizontal ? DEFAULTS.TICKS_BAR_SIZE : containerHeight;\n\n    if (\n      !isRangeTextPositionValid(\n        containerWidth,\n        containerHeight,\n        rangeTextPosition\n      )\n    ) {\n      throw new Error(\n        'Invalid rangeTextPosition value for the current colobar orientation'\n      );\n    }\n\n    let ticksBarTop;\n    let ticksBarLeft;\n\n    ticksBar.size = { width, height };\n\n    if (isHorizontal) {\n      ticksBarLeft = 0;\n      ticksBarTop =\n        rangeTextPosition === ColorbarRangeTextPosition.Top\n          ? -height\n          : containerHeight;\n    } else {\n      ticksBarTop = 0;\n      ticksBarLeft =\n        rangeTextPosition === ColorbarRangeTextPosition.Left\n          ? -width\n          : containerWidth;\n    }\n\n    ticksBar.top = ticksBarTop;\n    ticksBar.left = ticksBarLeft;\n  }\n\n  private _mouseOverCallback = (evt) => {\n    this._isMouseOver = true;\n    this.showTicks();\n    evt.stopPropagation();\n  };\n\n  private _mouseOutCallback = (evt) => {\n    this._isMouseOver = false;\n    this.hideTicks();\n    evt.stopPropagation();\n  };\n\n  private _mouseDownCallback = (evt: MouseEvent) => {\n    this._isInteracting = true;\n    this.showTicks();\n    this._addVOIEventListeners(evt);\n    evt.stopPropagation();\n  };\n\n  private _mouseDragCallback = (evt, initialState) => {\n    const multipliers = this.getVOIMultipliers();\n    const currentPoints = this._getPointsFromMouseEvent(evt);\n    const { points: startPoints, voiRange: startVOIRange } = initialState;\n    const canvasDelta = vec2.sub(\n      vec2.create(),\n      currentPoints.local,\n      startPoints.local\n    );\n\n    const wwDelta = canvasDelta[0] * multipliers[0];\n    const wcDelta = canvasDelta[1] * multipliers[1];\n\n    if (!wwDelta && !wcDelta) {\n      return;\n    }\n\n    const { lower: voiLower, upper: voiUpper } = startVOIRange;\n    let { windowWidth, windowCenter } = csUtils.windowLevel.toWindowLevel(\n      voiLower,\n      voiUpper\n    );\n\n    windowWidth = Math.max(windowWidth + wwDelta, 1);\n    windowCenter += wcDelta;\n\n    const newVoiRange = csUtils.windowLevel.toLowHighRange(\n      windowWidth,\n      windowCenter\n    );\n\n    this.voiRange = newVoiRange;\n    evt.stopPropagation();\n    evt.preventDefault();\n  };\n\n  private _mouseUpCallback = (evt) => {\n    this._isInteracting = false;\n    this.hideTicks();\n    this._removeVOIEventListeners();\n    evt.stopPropagation();\n  };\n\n  private _addRootElementEventListeners() {\n    const { _eventListenersManager: manager } = this;\n    const { rootElement: element } = this;\n\n    manager.addEventListener(element, 'mouseover', this._mouseOverCallback);\n    manager.addEventListener(element, 'mouseout', this._mouseOutCallback);\n    manager.addEventListener(\n      element,\n      'mousedown',\n      this._mouseDownCallback as EventListener\n    );\n  }\n\n  private _addVOIEventListeners(evt: MouseEvent) {\n    const { _eventListenersManager: manager } = this;\n    const points = this._getPointsFromMouseEvent(evt);\n    const voiRange = { ...this._canvas.voiRange };\n    const initialDragState = { points, voiRange };\n\n    this._removeVOIEventListeners();\n\n    manager.addEventListener(document, 'voi.mouseup', this._mouseUpCallback);\n    manager.addEventListener(document, 'voi.mousemove', (evt) =>\n      this._mouseDragCallback(evt, initialDragState)\n    );\n  }\n\n  private _removeVOIEventListeners() {\n    const { _eventListenersManager: manager } = this;\n\n    manager.removeEventListener(document, 'voi.mouseup');\n    manager.removeEventListener(document, 'voi.mousemove');\n  }\n}\n\nexport { Colorbar as default, Colorbar };\n","import { ColorbarRangeTextPosition } from '../enums';\n\nfunction isRangeTextPositionValid(\n  colorbarWidth: number,\n  colorbarHeight: number,\n  rangeTextPosition: ColorbarRangeTextPosition\n) {\n  const isHorizontal = colorbarWidth >= colorbarHeight;\n  const validRangeTextPositions = isHorizontal\n    ? [ColorbarRangeTextPosition.Top, ColorbarRangeTextPosition.Bottom]\n    : [ColorbarRangeTextPosition.Left, ColorbarRangeTextPosition.Right];\n\n  return validRangeTextPositions.includes(rangeTextPosition);\n}\n\nexport { isRangeTextPositionValid as default, isRangeTextPositionValid };\n","import {\n  eventTarget,\n  VolumeViewport,\n  StackViewport,\n  Types,\n  Enums,\n  utilities,\n  getEnabledElement,\n} from '@cornerstonejs/core';\nimport { Colorbar } from './Colorbar';\nimport type { ViewportColorbarProps, ColorbarVOIRange } from './types';\nimport { getVOIMultipliers } from '../../getVOIMultipliers';\n\nconst { Events } = Enums;\nconst defaultImageRange = { lower: -1000, upper: 1000 };\n/**\n * A colorbar associated with a viewport that updates automatically when the\n * viewport VOI changes or when the stack/volume are updated..\n */\nclass ViewportColorbar extends Colorbar {\n  private _element: HTMLDivElement;\n  private _volumeId: string;\n\n  private _hideTicksTime: number;\n  private _hideTicksTimeoutId: number;\n\n  constructor(props: ViewportColorbarProps) {\n    const { element, volumeId } = props;\n    const imageRange = ViewportColorbar._getImageRange(element, volumeId);\n    const voiRange = ViewportColorbar._getVOIRange(element, volumeId);\n\n    super({ ...props, imageRange, voiRange });\n\n    this._element = element;\n    this._volumeId = volumeId;\n\n    this._addCornerstoneEventListener();\n  }\n\n  public get element() {\n    return this._element;\n  }\n\n  public get enabledElement() {\n    return getEnabledElement(this._element);\n  }\n\n  protected getVOIMultipliers(): [number, number] {\n    const { viewport } = this.enabledElement;\n    return getVOIMultipliers(viewport, this._volumeId);\n  }\n\n  protected onVoiChange(voiRange: ColorbarVOIRange) {\n    super.onVoiChange(voiRange);\n\n    const { viewport } = this.enabledElement;\n\n    if (viewport instanceof StackViewport) {\n      viewport.setProperties({\n        voiRange: voiRange,\n      });\n      viewport.render();\n    } else if (viewport instanceof VolumeViewport) {\n      const { _volumeId: volumeId } = this;\n      const viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(\n        volumeId,\n        viewport.renderingEngineId\n      );\n\n      viewport.setProperties({ voiRange }, volumeId);\n      viewportsContainingVolumeUID.forEach((vp) => vp.render());\n    }\n  }\n\n  private static _getImageRange(element, volumeId?) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const actor = volumeId\n      ? viewport.getActor(volumeId)\n      : viewport.getDefaultActor();\n\n    if (!actor) {\n      return defaultImageRange;\n    }\n\n    const imageData = actor.actor.getMapper().getInputData();\n    const imageRange = imageData.getPointData().getScalars().getRange();\n\n    return imageRange[0] === 0 && imageRange[1] === 0\n      ? defaultImageRange\n      : { lower: imageRange[0], upper: imageRange[1] };\n  }\n\n  private static _getVOIRange(element, volumeId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const volumeActor = volumeId\n      ? viewport.getActor(volumeId)\n      : viewport.getDefaultActor();\n\n    if (!volumeActor || !utilities.isImageActor(volumeActor)) {\n      return defaultImageRange;\n    }\n\n    const voiRange = (volumeActor.actor as Types.ImageActor)\n      .getProperty()\n      .getRGBTransferFunction(0)\n      .getRange();\n\n    return voiRange[0] === 0 && voiRange[1] === 0\n      ? defaultImageRange\n      : { lower: voiRange[0], upper: voiRange[1] };\n  }\n\n  private autoHideTicks = () => {\n    // Avoiding calling setTimeout multiple times when manipulating the VOI\n    // via WindowLevel tool for better performance\n    if (this._hideTicksTimeoutId) {\n      return;\n    }\n\n    const timeLeft = this._hideTicksTime - Date.now();\n\n    if (timeLeft <= 0) {\n      this.hideTicks();\n    } else {\n      this._hideTicksTimeoutId = window.setTimeout(() => {\n        // Recursive call until there is no more time left\n        this._hideTicksTimeoutId = 0;\n        this.autoHideTicks();\n      }, timeLeft);\n    }\n  };\n\n  private showAndAutoHideTicks(interval = 1000) {\n    this._hideTicksTime = Date.now() + interval;\n    this.showTicks();\n    this.autoHideTicks();\n  }\n\n  private _stackNewImageCallback = () => {\n    this.imageRange = ViewportColorbar._getImageRange(this._element);\n  };\n\n  private _imageVolumeModifiedCallback = (\n    evt: Types.EventTypes.ImageVolumeModifiedEvent\n  ) => {\n    const { volumeId } = evt.detail.imageVolume;\n\n    if (volumeId !== this._volumeId) {\n      return;\n    }\n\n    const { _element: element } = this;\n    this.imageRange = ViewportColorbar._getImageRange(element, volumeId);\n  };\n\n  private _viewportVOIModifiedCallback = (\n    evt: Types.EventTypes.VoiModifiedEvent\n  ) => {\n    const { viewportId, volumeId, range: voiRange, colormap } = evt.detail;\n    const { viewport } = this.enabledElement;\n    if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n      return;\n    }\n\n    this.voiRange = voiRange;\n\n    if (colormap) {\n      this.activeColormapName = colormap.name;\n    }\n    this.showAndAutoHideTicks();\n  };\n\n  private _viewportColormapModifiedCallback = (\n    evt: Types.EventTypes.ColormapModifiedEvent\n  ) => {\n    const { viewportId, colormap, volumeId } = evt.detail;\n    const { viewport } = this.enabledElement;\n\n    if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n      return;\n    }\n\n    this.activeColormapName = colormap.name;\n  };\n\n  private _addCornerstoneEventListener() {\n    const { _element: element } = this;\n\n    eventTarget.addEventListener(\n      Events.IMAGE_VOLUME_MODIFIED,\n      this._imageVolumeModifiedCallback\n    );\n\n    element.addEventListener(\n      Events.STACK_NEW_IMAGE,\n      this._stackNewImageCallback\n    );\n\n    element.addEventListener(\n      Events.VOI_MODIFIED,\n      this._viewportVOIModifiedCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.COLORMAP_MODIFIED,\n      this._viewportColormapModifiedCallback as EventListener\n    );\n  }\n}\n\nexport { ViewportColorbar as default, ViewportColorbar };\n","import { Types, utilities as csUtils } from '@cornerstonejs/core';\nimport { isViewportPreScaled } from './viewport';\n\nconst DEFAULT_MULTIPLIER = 4;\n\nfunction getVOIMultipliers(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  volumeId?: string,\n  options?: {\n    fixedPTWindowWidth?: boolean;\n  }\n): [number, number] {\n  const modality = csUtils.getViewportModality(viewport, volumeId);\n\n  if (modality === 'PT') {\n    const { clientWidth, clientHeight } = viewport.element;\n    const ptMultiplier = 5 / Math.max(clientWidth, clientHeight);\n    const isPreScaled = isViewportPreScaled(viewport, volumeId);\n    const { fixedPTWindowWidth = true } = options ?? {};\n\n    // Set the \"X\" multiplier equal to zero in order to do not allow\n    // any change to the window width (0 * cursorDeltaX = 0)\n    const xMultiplier = fixedPTWindowWidth ? 0 : ptMultiplier;\n\n    return isPreScaled\n      ? [xMultiplier, ptMultiplier]\n      : [xMultiplier, DEFAULT_MULTIPLIER];\n  }\n\n  return [DEFAULT_MULTIPLIER, DEFAULT_MULTIPLIER];\n}\n\nexport { getVOIMultipliers as default, getVOIMultipliers };\n","/**\n * Specify the position of the text/ticks.\n * Left/Right are the valid options for a vertical colorbars and Top/Bottom\n * for the horizontal ones.\n */\nexport enum ColorbarRangeTextPosition {\n  Top = 'top',\n  Left = 'left',\n  Bottom = 'bottom',\n  Right = 'right',\n}\n","/**\n * Extracts the luminance values from a specified region of an image.\n *\n * @param {Object} imageData - The image data object containing pixel information.\n * @param {Uint8Array} imageData.scalarData - The pixel data array.\n * @param {boolean} imageData.color - A flag indicating if the image is in color (true) or grayscale (false).\n * @param {number} imageData.columns - The number of columns (width) in the image.\n * @param {number} x - The x-coordinate of the top-left corner of the region.\n * @param {number} y - The y-coordinate of the top-left corner of the region.\n * @param {number} width - The width of the region.\n * @param {number} height - The height of the region.\n * @returns {number[]} An array containing the luminance values of the specified region.\n */\nfunction getLuminanceFromRegion(imageData, x, y, width, height) {\n  const luminance = [];\n  let index = 0;\n  const pixelData = imageData.scalarData;\n  let spIndex, row, column;\n\n  if (imageData.color) {\n    for (row = 0; row < height; row++) {\n      for (column = 0; column < width; column++) {\n        spIndex = ((row + y) * imageData.columns + (column + x)) * 4;\n        const red = pixelData[spIndex];\n        const green = pixelData[spIndex + 1];\n        const blue = pixelData[spIndex + 2];\n\n        luminance[index++] = 0.2126 * red + 0.7152 * green + 0.0722 * blue;\n      }\n    }\n  } else {\n    for (row = 0; row < height; row++) {\n      for (column = 0; column < width; column++) {\n        spIndex = (row + y) * imageData.columns + (column + x);\n        luminance[index++] = pixelData[spIndex];\n      }\n    }\n  }\n\n  return luminance;\n}\n\nexport { getLuminanceFromRegion };\n","function calculateMinMaxMean(pixelLuminance, globalMin, globalMax) {\n  const numPixels = pixelLuminance.length;\n  let min = globalMax;\n  let max = globalMin;\n  let sum = 0;\n\n  if (numPixels < 2) {\n    return {\n      min,\n      max,\n      mean: (globalMin + globalMax) / 2,\n    };\n  }\n\n  for (let index = 0; index < numPixels; index++) {\n    const spv = pixelLuminance[index];\n\n    min = Math.min(min, spv);\n    max = Math.max(max, spv);\n    sum += spv;\n  }\n\n  return {\n    min,\n    max,\n    mean: sum / numPixels,\n  };\n}\n\nexport { calculateMinMaxMean };\n","import {\n  VolumeViewport,\n  utilities as csUtils,\n  cache,\n  StackViewport,\n} from '@cornerstonejs/core';\n\nfunction extractWindowLevelRegionToolData(viewport) {\n  if (viewport instanceof VolumeViewport) {\n    return extractImageDataVolume(viewport);\n  }\n  if (viewport instanceof StackViewport) {\n    return extractImageDataStack(viewport);\n  }\n\n  throw new Error('Viewport not supported');\n}\n\nfunction extractImageDataVolume(viewport) {\n  const { scalarData, width, height } =\n    csUtils.getCurrentVolumeViewportSlice(viewport);\n  const { min: minPixelValue, max: maxPixelValue } =\n    csUtils.getMinMax(scalarData);\n  const volumeId = viewport.getVolumeId();\n  const volume = cache.getVolume(volumeId);\n  // @ts-ignore\n  const { metadata, cornerstoneImageMetaData } = volume;\n  const { Rows: rows, Columns: columns } = metadata;\n  const { color } = cornerstoneImageMetaData;\n  return {\n    scalarData,\n    width,\n    height,\n    minPixelValue,\n    maxPixelValue,\n    rows,\n    columns,\n    color,\n  };\n}\n\nfunction extractImageDataStack(viewport) {\n  const imageData = viewport.getImageData();\n  const { scalarData } = imageData;\n  const { min: minPixelValue, max: maxPixelValue } =\n    csUtils.getMinMax(scalarData);\n  const width = imageData.dimensions[0];\n  const height = imageData.dimensions[1];\n  const { rows, columns, color } = viewport.getCornerstoneImage();\n\n  return {\n    scalarData,\n    width,\n    height,\n    minPixelValue,\n    maxPixelValue,\n    rows,\n    columns,\n    color,\n  };\n}\n\nexport { extractWindowLevelRegionToolData };\n","import { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport vtkCaseTable from './ImageMarchingSquares/caseTable.js';\n\nconst {\n  vtkErrorMacro,\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageMarchingSquares methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMarchingSquares(publicAPI, model) {\n  /**\n   * Get the X,Y kernels based on the set slicing mode.\n   * @returns {[number, number]}\n   */\n  function getKernels() {\n    let kernelX = 0; // default K slicing mode\n    let kernelY = 1;\n    if (model.slicingMode === 1) {\n      kernelX = 0;\n      kernelY = 2;\n    } else if (model.slicingMode === 0) {\n      kernelX = 1;\n      kernelY = 2;\n    }\n    return [kernelX, kernelY];\n  }\n\n  // Set our className\n  model.classHierarchy.push('vtkImageMarchingSquares');\n\n  /**\n   * Get the list of contour values.\n   * @returns {number[]}\n   */\n  publicAPI.getContourValues = () => model.contourValues;\n\n  /**\n   * Set the list contour values.\n   * @param {number[]} cValues\n   */\n  publicAPI.setContourValues = cValues => {\n    model.contourValues = cValues;\n    publicAPI.modified();\n  };\n  const ids = [];\n  const pixelScalars = [];\n  const pixelPts = [];\n  const edgeLocator = vtkEdgeLocator.newInstance();\n\n  /**\n   * Retrieve scalars and pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelScalars = (ijk, dims, scalars, increments, kernelX, kernelY) => {\n    const [i, j, k] = ijk;\n\n    // First get the indices for the pixel\n    ids[0] = k * dims[1] * dims[0] + j * dims[0] + i; // i, j, k\n    ids[1] = ids[0] + increments[kernelX]; // i+1, j, k\n    ids[2] = ids[0] + increments[kernelY]; // i, j+1, k\n    ids[3] = ids[2] + increments[kernelX]; // i+1, j+1, k\n\n    // Now retrieve the scalars\n    for (let ii = 0; ii < 4; ++ii) {\n      pixelScalars[ii] = scalars[ids[ii]];\n    }\n  };\n\n  /**\n   * Retrieve pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing spacing of the image\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelPoints = (ijk, origin, spacing, kernelX, kernelY) => {\n    const i = ijk[kernelX];\n    const j = ijk[kernelY];\n\n    // (i,i+1),(j,j+1),(k,k+1) - i varies fastest; then j; then k\n    pixelPts[0] = origin[kernelX] + i * spacing[kernelX]; // 0\n    pixelPts[1] = origin[kernelY] + j * spacing[kernelY];\n    pixelPts[2] = pixelPts[0] + spacing[kernelX]; // 1\n    pixelPts[3] = pixelPts[1];\n    pixelPts[4] = pixelPts[0]; // 2\n    pixelPts[5] = pixelPts[1] + spacing[kernelY];\n    pixelPts[6] = pixelPts[2]; // 3\n    pixelPts[7] = pixelPts[5];\n  };\n\n  /**\n   * Produce points and lines for the polydata.\n   * @param {number[]} cVal list of contour values\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing sapcing of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {number[]} points list of points\n   * @param {number[]} lines list of lines\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.produceLines = (cVal, ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY) => {\n    const k = ijk[model.slicingMode];\n    const CASE_MASK = [1, 2, 8, 4]; // case table is actually for quad\n    const xyz = [];\n    let pId;\n    publicAPI.getPixelScalars(ijk, dims, scalars, increments, kernelX, kernelY);\n    let index = 0;\n    for (let idx = 0; idx < 4; idx++) {\n      if (pixelScalars[idx] >= cVal) {\n        index |= CASE_MASK[idx]; // eslint-disable-line no-bitwise\n      }\n    }\n\n    const pixelLines = vtkCaseTable.getCase(index);\n    if (pixelLines[0] < 0) {\n      return; // don't get the pixel coordinates, nothing to do\n    }\n\n    publicAPI.getPixelPoints(ijk, origin, spacing, kernelX, kernelY);\n    const z = origin[model.slicingMode] + k * spacing[model.slicingMode];\n    for (let idx = 0; pixelLines[idx] >= 0; idx += 2) {\n      lines.push(2);\n      for (let eid = 0; eid < 2; eid++) {\n        const edgeVerts = vtkCaseTable.getEdge(pixelLines[idx + eid]);\n        pId = undefined;\n        if (model.mergePoints) {\n          pId = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])?.value;\n        }\n        if (pId === undefined) {\n          const t = (cVal - pixelScalars[edgeVerts[0]]) / (pixelScalars[edgeVerts[1]] - pixelScalars[edgeVerts[0]]);\n          const x0 = pixelPts.slice(edgeVerts[0] * 2, (edgeVerts[0] + 1) * 2);\n          const x1 = pixelPts.slice(edgeVerts[1] * 2, (edgeVerts[1] + 1) * 2);\n          xyz[kernelX] = x0[0] + t * (x1[0] - x0[0]);\n          xyz[kernelY] = x0[1] + t * (x1[1] - x0[1]);\n          xyz[model.slicingMode] = z;\n          pId = points.length / 3;\n          points.push(xyz[0], xyz[1], xyz[2]);\n          if (model.mergePoints) {\n            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);\n          }\n        }\n        lines.push(pId);\n      }\n    }\n  };\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    if (model.slicingMode == null || model.slicingMode < 0 || model.slicingMode > 2) {\n      vtkErrorMacro('Invalid or missing slicing mode');\n      return;\n    }\n    console.time('msquares');\n\n    // Retrieve output and volume data\n    const origin = input.getOrigin();\n    const spacing = input.getSpacing();\n    const dims = input.getDimensions();\n    const extent = input.getExtent();\n    const increments = input.computeIncrements(extent);\n    const scalars = input.getPointData().getScalars().getData();\n    const [kernelX, kernelY] = getKernels();\n\n    // Points - dynamic array\n    const points = [];\n\n    // Cells - dynamic array\n    const lines = [];\n\n    // Ensure slice is valid\n    let k = Math.round(model.slice);\n    if (k >= dims[model.slicingMode]) {\n      k = 0;\n    }\n\n    // Loop over all contour values, and then pixels, determine case and process\n    const ijk = [0, 0, 0];\n    ijk[model.slicingMode] = k;\n    for (let cv = 0; cv < model.contourValues.length; ++cv) {\n      for (let j = 0; j < dims[kernelY] - 1; ++j) {\n        ijk[kernelY] = j;\n        for (let i = 0; i < dims[kernelX] - 1; ++i) {\n          ijk[kernelX] = i;\n          publicAPI.produceLines(model.contourValues[cv], ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY);\n        }\n      }\n      edgeLocator.initialize();\n    }\n\n    // Update output\n    const polydata = vtkPolyData.newInstance();\n    polydata.getPoints().setData(new Float32Array(points), 3);\n    polydata.getLines().setData(new Uint32Array(lines));\n    outData[0] = polydata;\n    vtkDebugMacro('Produced output');\n    console.timeEnd('msquares');\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  contourValues: [],\n  slicingMode: 2,\n  slice: 0,\n  mergePoints: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['slicingMode', 'slice', 'mergePoints']);\n\n  // Object specific methods\n  macro.algo(publicAPI, model, 1, 1);\n  vtkImageMarchingSquares(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageMarchingSquares');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageMarchingSquares$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageMarchingSquares$1 as default, extend, newInstance };\n"],"names":["AnnotationTool","constructor","toolProps","defaultToolProps","super","mouseMoveCallback","evt","filteredAnnotations","element","currentPoints","detail","canvasCoords","canvas","annotationsNeedToBeRedrawn","annotation","isAnnotationLocked","isAnnotationVisible","annotationUID","data","activateHandleIndex","handles","activeHandleIndex","undefined","near","this","_imagePointNearToolOrHandle","nearToolAndNotMarkedActive","highlighted","notNearToolAndMarkedActive","configuration","getTextLines","statsCalculator","createAnnotation","annotationBaseData","invalidated","metadata","toolName","text","points","Array","textBox","hasMoved","worldPosition","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","label","baseData","createAnnotationForViewport","viewport","getViewReference","createAndAddAnnotation","addAnnotation","getHandleNearImagePoint","proximity","enabledElement","getEnabledElement","isCanvasAnnotation","canvasBoundingBox","worldToCanvas","i","length","point","annotationCanvasCoordinate","slice","getLinkedTextBoxStyle","specifications","visibility","getStyle","fontFamily","fontSize","color","shadow","background","lineWidth","lineDash","isSuvScaled","targetId","imageId","BaseVolumeViewport","volumeId","volume","cache","getVolume","scaling","PT","scalingModule","metaData","suvbw","getAnnotationStyle","context","styleSpecifier","property","locked","lineOpacity","fillColor","fillOpacity","textbox","isPointNearTool","defaultLabelmapConfig","renderOutline","outlineWidthActive","outlineWidthInactive","activeSegmentOutlineWidthDelta","renderFill","renderFillInactive","fillAlpha","fillAlphaInactive","outlineOpacity","outlineOpacityInactive","isValidLabelmapConfig","config","AnnotationFrameRange","frameRangeExtractor","imageIdToFrames","match","range","split","map","it","Number","framesToString","isArray","String","framesToImageId","newRangeString","replace","setFrameRange","eventBase","referencedImageId","eventDetail","triggerEvent","eventTarget","ANNOTATION_MODIFIED","getFrameRange","annotationHydration","worldPoints","options","viewReference","viewPlaneNormal","FrameOfReferenceUID","utilities","autoGenerated","isLocked","isVisible","getReferencedImageId","worldPos","StackViewport","getClosestImageIdForStackViewport","Error","getReferenceId","actorEntries","getActors","find","actorEntry","actor","getClassName","uid","getTargetVolumeId","getTargetId","imageVolume","imageIds","getImageIds","distanceImagePairs","imagePositionPatient","distance","ImagePositionPatient","dir","dot","Math","abs","calculateDistanceToImage","sort","a","b","boundsIJK","numSlicesToProject","sliceNormalIndex","findIndex","min","max","EPSILON","CONSTANTS","calculateBoundingBox","dimensions","isWorld","xMin","Infinity","xMax","yMin","yMax","zMin","zMax","is3D","p","getBoundingBoxAroundShapeIJK","getBoundingBoxAroundShapeWorld","clipBounds","calibratedPixelSpacingMetadataProvider","calibrateImageSpacing","renderingEngine","calibrationOrScale","type","Enums","USER","scale","add","getStackViewports","forEach","includes","calibrateSpacing","Events","state","addToolState","viewportId","getToolState","ViewportStatus","debounced","dynamicVolumesPlayingMap","Map","playClip","playClipOptions","playClipTimeouts","playClipIsTimeVarying","dynamicCineEnabled","_getVolumeFromViewport","playClipContext","waitForRendered","numScrollSteps","currentStepIndex","getTargetImageIdIndex","frameTimeVectorEnabled","waitForRenderedCount","scroll","delta","viewportStatus","RENDERED","debounceLoading","_createStackViewportCinePlayContext","VolumeViewport","isDynamicVolume","numTimePoints","timePointIndex","_createDynamicVolumeViewportCinePlayContext","cachedScrollInfo","scrollInfo","getScrollInfo","camera","getCamera","volumeViewPlaneNormal","direction","x","_createVolumeViewportCinePlayContext","_createCinePlayContext","playClipData","isDynamicCinePlaying","_stopDynamicVolumeCine","_stopClip","stopDynamicCine","id","intervalId","framesPerSecond","lastFrameTimeStamp","ignoreFrameTimeVector","usingFrameTimeVector","frameTimeVector","speed","frameTimeVectorSpeedMultiplier","reverse","loop","timeouts","isTimeVarying","vector","sample","delay","sum","limit","push","_getPlayClipTimeouts","playClipAction","newStepIndex","newStepIndexOutOfRange","CLIP_STOPPED","set","window","setTimeout","playClipTimeoutHandler","setInterval","CLIP_STARTED","stopClip","toolState","getToolStateByViewportId","clearTimeout","clearInterval","_stopClipWithData","dynamicCineElement","get","delete","volumes","filter","_getVolumesFromViewport","clip","val","low","high","addContourSegmentationAnnotation","parentAnnotationUID","segmentation","segmentationId","segmentIndex","getSegmentation","representationData","CONTOUR","annotationUIDsMap","annotationsUIDsSet","Set","areSameSegment","firstAnnotation","secondAnnotation","firstSegmentation","secondSegmentation","isContourSegmentationAnnotation","removeContourSegmentationAnnotation","size","polyline","closed","perimeter","point1","point2","sqrt","pow","firstPoint","lastPoint","isEqual","findHandlePolylineIndex","handleIndex","contour","handle","index","closestDistance","reduce","closestIndex","testIndex","areCoplanarContours","firstViewPlaneNormal","secondViewPlaneNormal","firstPolyline","secondPolyline","firstDistance","secondDistance","findNextLink","line","lines","contourPoints","cell","nextLine","splice","remainingLines","findContours","firstCell","shift","result","extraContours","findContoursFromReducedSet","getDeduplicatedVTKPolyDataPoints","polyData","bypass","getPoints","getLines","pointsArray","getNumberOfPoints","fill","_","getPoint","linesArray","getNumberOfCells","getCell","newPoints","pt","entries","newIndex","processContourHoles","contours","useXOR","retContours","closedContours","contourWithHoles","contourWithoutHoles","holes","hContour","hIndex","outerContour","innerContour","vertices","pointsNotEnclosed","y","inside","j","xi","yi","xj","yj","getIsPointInsidePolygon","checkEnclosed","contourHoleSet","holeIndex","contourIndex","Labelmap","SegmentationRepresentations","generateContourSetsFromLabelmap","segmentations","segments","segVolumeId","vol","console","warn","numSlices","segData","imageData","getPointData","getScalars","getData","pixelsPerSlice","z","ContourSets","numSegments","segIndex","segment","sliceContours","scalars","name","numberOfComponents","dataType","containedSegmentIndices","sliceIndex","isSliceEmptyForSegment","frameStart","value","has","setValue","mSquares","imageDataCopy","shallowCopy","setScalars","setInputData","cValues","setContourValues","setMergePoints","reducedSet","getOutputData","FrameNumber","e","ContourSet","startIdx","endIdx","AnnotationToPointData","TOOL_NAMES","convert","metadataProvider","referenceImageId","validateAnnotation","toolClass","ContourSequence","getContourSequence","ReferencedROINumber","ROIDisplayColor","floor","random","register","RectangleROIStartEndThreshold","getContourHolesDataWorld","childAnnotationUIDs","getContourHolesDataCanvas","worldHoleContours","canvasHoleContours","worldHoleContour","numPoints","canvasHoleContour","acceptAutogeneratedInterpolations","annotationGroupSelector","selector","InterpolationManager","acceptAutoGenerated","updateContourPolyline","polylineData","transforms","canvasToWorld","targetWindingDirection","decimate","enabled","epsilon","polylineWorldPoints","currentPolylineWindingDirection","parentAnnotation","currentClosedState","lastToFirstDist","windingDirection","handlePoints","func","wait","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","useRAF","requestAnimationFrame","TypeError","invokeFunc","time","args","thisArg","apply","startTimer","pendingFunc","shouldInvoke","timeSinceLastCall","timerExpired","Date","now","trailingEdge","timeSinceLastInvoke","timeWaiting","remainingWait","isInvoking","leadingEdge","Boolean","cancel","cancelAnimationFrame","cancelTimer","flush","pending","getTextBoxCoordsCanvas","annotationCanvasPoints","corners","canvasPoints","handlesLeftToRight","_compareX","handlesTopToBottom","_compareY","right","top","bottom","_determineCorners","centerY","dynamicVolume","frames","frameNumbers","keys","maskVolumeId","imageCoordinate","segmentationVolume","dataInTime","ijkCoords","maskImageData","segScalarData","getScalarData","len","nonZeroVoxelIndices","actualLen","dynamicVolumeScalarDataArray","getScalarDataArrays","values","isSameVolume","JSON","stringify","spacing","indexValues","frame","activeScalarData","callback","pointLPS","segPointLPS","segValue","pointIJK","segPointIJK","overlapIJKMinMax","count","perFrameSum","averageCallback","pointInShapeCallback","averageValues","_getTimePointDataMask","coordinate","worldToIndex","yMultiple","zMultiple","allScalarData","scalarIndex","_getTimePointDataCoordinate","operation","numFrames","typedArrays","arrayLength","finalArray","Float32Array","SUM","currentArray","SUBTRACT","AVERAGE","k","getAnnotationNearPoint","canvasPoint","getAnnotationNearPointOnEnabledElement","renderingEngineId","toolGroup","_toolInstances","tools","found","findAnnotationNearPointByTool","tool","annotations","getAnnotations","currentId","getCurrentImageId","CalibrationTypes","PIXEL_UNITS","SUPPORTED_REGION_DATA_TYPES","SUPPORTED_LENGTH_VARIANT","SUPPORTED_PROBE_VARIANT","UNIT_MAPPING","SQUARE","getCalibratedLengthUnitsAndScale","image","calibration","hasPixelSpacing","units","areaUnits","calibrationType","sequenceOfUltrasoundRegions","UNCALIBRATED","imageIndex1","imageIndex2","regions","region","regionLocationMinX0","regionLocationMaxX1","regionLocationMinY0","regionLocationMaxY1","regionDataType","physicalUnitsXDirection","physicalUnitsYDirection","physicalDeltaX","physicalDeltaY","ERMF","ERROR","PROJECTION","getCalibratedProbeUnitsAndValue","imageIndex","supportedRegionsMetadata","referencePixelX0","referencePixelY0","yValue","getCalibratedAspect","aspect","transformWorldToIndex","getSphereBoundsInfo","circlePoints","centerWorld","radiusWorld","topLeftWorld","bottomRightWorld","getDimensions","viewUp","viewRight","topLeftIJK","bottomRightIJK","pointsIJK","_computeBoundsIJKWithCamera","getViewportForAnnotation","viewports","intersectAABB","aabb1","aabb2","minX","maxX","minY","maxY","distanceToPointSquared","aabb","aabbWidth","aabbHeight","aabbSize","aabbCenter","translatedPoint","dx","dy","dist","distanceToPoint","PointsManager","BasicStatsCalculator","runMean","m2","pointsInShape","create3","statsInit","noPointsCollection","statsCallback","newValue","newArray","idx","delta2","getStatistics","mean","stdDev","squaredDiffSum","unit","named","singleArrayAsNumber","array","pointInEllipse","ellipse","inverts","precalculated","precalculatePointInEllipse","xRadius","yRadius","zRadius","invXRadiusSq","invYRadiusSq","invZRadiusSq","center","centerL","centerP","centerS","dz","getCanvasEllipseCorners","ellipseCanvasPoints","left","distanceToPointSquaredInfo","lineStart","lineEnd","closestPoint","distanceSquared","math","dotProduct","sign","NaN","intersectLine","line1Start","line1End","line2Start","line2End","x1","y1","x2","y2","x3","y3","x4","y4","a1","b1","c1","r3","r4","a2","b2","c2","r1","r2","denom","num","ORIENTATION_TOLERANCE","isPointOnLineSegment","orientation","p1","p2","z1","z2","mirror","mirrorPoint","staticPoint","isClosed","numPolylinePoints","distFirstToLastPoints","containsPoint","numIntersections","hole","shouldClose","maxSegmentIndex","intersects","xIntersection","containsPoints","numPoint","getArea","n","area","getSignedArea","refPoint","aX","aY","bX","getWindingDirection","getNormal3","vecArea","aZ","bY","bZ","_getAreaVector","getNormal2","areLineSegmentsIntersecting","q1","q2","line1MinX","line1MinY","line1MaxX","line1MaxY","line2MinX","line2MinY","line2MaxX","line2MaxY","orient","onSegment","q","r","orientationValue","getLineSegmentIntersectionsIndexes","intersections","maxI","PARALLEL_LINES_TOLERANCE","getLinesIntersection","diffQ1P1","diffQ2P2","denominator","line1AABB","line2AABB","numerator2","PolylinePointType","PolylinePointPosition","PolylinePointDirection","ensuresNextPointers","polylinePoints","currentPoint","next","getSourceAndTargetPointsList","targetPolyline","sourcePolyline","targetPolylinePoints","sourcePolylinePoints","sourceIntersectionsCache","intersectionPointDirection","Exiting","Entering","pointInside","vertexPoint","Vertex","coordinates","position","Inside","Outside","visited","intersectionsInfo","intersectedLineSegment","sourceLineSegmentId","intersectionCoordinate","targetStartPointDistSquared","intersectionInfo","targetEdgePoint","Intersection","Edge","sourceEdgePoint","Unknown","cloned","sourceIntersectionPoints","lineSegmentId","intersectionPoint","lineSegStartDistSquared","getUnvisitedOutsidePoint","mergePolylines","targetNormal","sourceNormal","dotNormals","startPoint","mergedPolyline","subtractPolylines","subtractedPolylines","subtractedPolyline","getFirstLineSegmentIntersectionIndexes","initialI","intersectPolyline","sourceLen","intersectionPointIndexes","DEFAULT_EPSILON","epsilonSquared","partitionQueue","polylinePointFlags","numDecimatedPoints","startIndex","endIndex","pop","endPoint","maxDistSquared","maxDistIndex","distSquared","decimatedPolyline","srcIndex","dstIndex","getLineSegmentIntersectionsCoordinates","polylineIndexes","intersection","getClosestLineSegmentIntersection","initialQ2Index","p2Index","q2Index","distances","intersectionPoints","midpoint","minDistance","indexOf","subPixelResolution","xDir","yDir","getImageData","volumeSpacing","iVector","jVector","kVector","absViewRightDotI","absViewRightDotJ","absViewRightDotK","xSpacing","absViewUpDotI","absViewUpDotJ","absViewUpDotK","ySpacing","closeContourProximity","newCanvasPoint","commonData","log","lastWorldPos","newWorldPos","worldPosDiff","xDist","yDist","numPointsToAdd","lastCanvasPoint","canvasDist","canvasDir","distPerPoint","p1p","p1p2","p1p2Mag","projectionVectorMag","p1p2UnitVector","projectionVector","projectionPoint","projectTo2D","sharedDimensionIndex","testPoints","every","points2D","firstDim","secondDim","projectedPolyline","isPointInsidePolyline3D","projectedHoles","hole2D","rect","width","height","lineSegments","rectToLineSegments","Object","pointInSphere","sphere","radius","radius2","INSIDE","OUTSIDE","clipT","c","tE","tL","t","box","da","db","getOrientationStringLPS","orientationX","orientationY","orientationZ","MIN","invertOrientationStringLPS","orientationString","inverted","toUpperCase","filterAnnotationsWithinSlice","getWorldWidthAndHeightFromCorners","filterAnnotationsForDisplay","getPointInLineOfSightWithCriteria","isPlaneIntersectingAABB","smoothAnnotation","pointInShapeFn","iMin","iMax","jMin","jMax","kMin","kMax","scalarData","numComps","start","getDirection","rowCosines","columnCosines","scanAxisNormal","getSpacing","rowSpacing","columnSpacing","scanAxisSpacing","worldPosStart","indexToWorld","rowStep","columnStep","scanAxisStep","xMultiple","currentPos","startPosJ","startPosI","pointInSurroundingSphereCallback","centerIJK","spacings","minSpacing","maxRadiusIJK","ceil","sphereCornersIJK","getBoundingBoxAroundShape","_getBounds","sphereObj","pointToString","decimals","parseFloat","toFixed","idx3","getPolyDataPointIndexes","linesData","segmentSize","findStartingPoint","key","nextPoint","getPolyDataPoints","contoursIndexes","rawPointsData","contourIndexes","referenceVolume","AllBoundsIJK","pointsToUse","cachedStats","projectionPoints","concat","rectangleCornersIJK","world","g","accumulator","currentValue","axisList","isAxisAlignedRectangle","rectangleVec1","rectangleVec2","calculateAnglesWithAxes","angle","vec","axes","axis","PI","scrollSlabs","useSlabThickness","sliceRangeInfo","sliceRange","spacingInNormalDirection","focalPoint","newFocalPoint","newPosition","setCamera","render","desiredStepIndex","VolumeScrollEventDetail","currentImageId","EVENTS","VOLUME_SCROLL_OUT_OF_BOUNDS","VOLUME_VIEWPORT_SCROLL","scrollVolume","uuidv4","ChangeTypesForInterpolation","HandlesUpdated","InterpolationUpdated","toolNames","addTool","interpolationUID","interpolationCompleted","handleAnnotationCompleted","originalToolName","viewportData","sliceData","getSliceData","hasInterpolationUID","filterData","parentKey","interpolationAnnotations","skipUIDs","interpolationAnnotation","handleAnnotationUpdate","changeType","isInterpolationUpdate","handleAnnotationDelete","numberOfSlices","getNumberOfSlices","getCurrentImageIdIndex","setBrushReplaceForToolGroup","toolGroupId","targetSegmentIndex","getToolGroup","strategySpecificConfiguration","REPLACE","getBrushReplaceForToolGroup","toolInstances","brushToolInstance","setBrushSizeForToolGroup","brushSize","invalidateBrushCursor","viewportsInfo","getViewportsInfo","viewportsInfoArray","viewportIds","getViewportIds","getRenderingEngine","getBrushSizeForToolGroup","setBrushThresholdForToolGroup","threshold","otherArgs","isDynamic","brushBasedToolInstances","THRESHOLD","getBrushThresholdForToolGroup","isLineInSegment","isInSegment","ijk1","toIJK","ijk2","testPoint","testIJK","testSize","round","unitDelta","findLargestBidirectional","maxBidirectional","testCenter","ijk","createIsInSegment","sliceContour","bidirectional","createBidirectionalForSlice","assign","currentMax","maxMajor","maxMinor","currentMaxMinor","currentMaxMajor","maxMajorPoints","index1","index2","distance2","handle0","handle1","unitMajor","maxMinorPoints","majorAxis","minorAxis","contourAndFindLargestBidirectional","createBidirectionalToolData","bidirectionalData","major0","major1","minor0","minor1","createImageIdReferenceMap","imageIdsArray","segmentationImageIds","async","createLabelmapVolumeForViewport","input","getEnabledElementByIds","getDefaultActor","properties","volumeLoader","labelmaps","origin","labelmap","outputData","arrayType","lpad","string","character","join","getter","seed","onFlood","onBoundary","equals","diagonals","startNode","permutations","perms","permutation","parseInt","toString","permute","perm","countNonZeroes","prunedPermutations","stack","flooded","visits","bounds","currentArgs","flood","boundaries","from","job","getArgs","prevArgs","previousArgs","iKey","markAsVisited","node","member","markAsFlooded","nextArgs","pushAdjacent","markAsBoundary","getDefaultRepresentationConfig","representationType","getHoveredContourSegmentationAnnotation","annotationUIDs","getSegmentAtLabelmapBorder","worldPoint","searchRadius","labelmapData","LABELMAP","getScalarValueFromWorld","onEdge","getNeighborIndex","deltaI","deltaJ","neighborCanvas","isSegmentOnEdge","isSegmentOnEdgeCanvas","imageIdReferenceMap","segmentationImageId","getImage","segmentationRepresentations","getSegmentationIdRepresentations","segmentationRepresentationUID","segmentationActor","getActor","getMapper","getInputData","indexIJK","voxelManager","createVolumeVoxelManager","getAtIJKPoint","deltaK","neighborIJK","getAtIJK","isSegmentOnEdgeIJK","neighborRange","neighborIndex","getSegmentAtWorldPoint","desiredRepresentation","getSegmentAtWorldForLabelmap","Contour","contourData","segmentIndices","annotationsSet","getSegmentAtWorldForContour","isValidRepresentationConfig","thresholdVolumeInformation","validToolNames","_validateAnnotations","outputSegmentationVolume","modified","segmentContourAction","configurationData","getSegment","defaultGetSegment","getFrameOfReferenceUID","segmentationsList","bidirectionals","hasExistingActiveSegment","existingLargestBidirectionals","existingBidirectionalItem","newBidirectional","existingLargestBidirectional","updateSegment","bidirectionalToolData","style","setAnnotationStyles","jumpToSlice","segmentData","segmentationIndex","overlapType","baseVolumeIdx","volumeInfoList","volumeInfo","volumeSize","referenceValues","lower","upper","_handleSameSizeVolume","total","overlaps","overlapBounds","callbackOverlap","overlapTest","_handleDifferentSizeVolume","triggerSegmentationDataModified","segmentationImageData","overwrite","testOverlapRange","voxelSpacing","voxelCenter","testRange","computeOffsetIndex","insert","getBrushToolInstances","toolInstance","equalsCheck","getVoxelOverlap","voxelCornersWorld","voxelCornersIJK","processVolumes","segmentationSpacing","resetPrefetchTimeout","maxImagesToPrefetch","preserveExistingPool","prefetch","stackPrefetchData","stackPrefetch","currentImageIdIndex","indicesToRequest","removeFromList","imageIdIndex","getImageLoadObject","isLoaded","imageLoadPoolManager","clearRequestStack","nearest","nextImageIdIndex","lowerIndex","higherIndex","imageIdsToPrefetch","currentIndex","shouldLoadLower","shouldLoadHigher","requestFn","imageLoader","useNorm16Texture","preferSizeOverAccuracy","rendering","useNativeDataType","targetBuffer","preScale","requestType","addRequest","bind","onImageUpdated","target","error","enable","indexOfCurrentImage","removeEventListener","STACK_NEW_IMAGE","addEventListener","promiseRemovedHandler","IMAGE_CACHE_IMAGE_REMOVED","disable","getConfiguration","setConfiguration","minBefore","maxAfter","directionExtraImages","indicesToRequestCopy","filterRequests","then","getCachedImageBasedOnImageURI","stats","decodeTimeInMS","loadTimeInMS","sizeInBytes","usage","getMaxCacheSize","cacheFill","fillTime","fillSize","roundNumber","initialTime","initialSize","updateToolState","doneCallback","stackCount","totalBytes","positionFraction","minIndex","maxIndex","getDeltaPoints","lastPoints","curr","getMeanPoints","last","page","_subtractPoints2D","client","point0","getDeltaDistance","_getDistance2D","_getDistance3D","getDeltaRotation","getDeltaDistanceBetweenIPoints","currentDistance","_getMeanDistanceBetweenAllIPoints","lastDistance","copyPointsList","parse","copyPoints","prev","getMeanTouchPoints","touch","identifier","radiusX","radiusY","force","rotationAngle","pairedDistance","toolGroupIds","viewportInfo","getViewport","isViewportPreScaled","targetIdTokens","scaled","currentImageIndex","_getImageSliceData","lastSliceIndex","_getImageIndexToJump","jumpToWorld","jumpWorld","normal","dotProd","projectedDelta","_applyShift","filterViewportsWithFrameOfReferenceUID","numViewports","viewportsWithFrameOfReferenceUID","vp","Active","Passive","Enabled","ToolModes","filterViewportsWithToolEnabled","viewportsWithToolEnabled","_toolGroupHasActiveEnabledOrPassiveTool","toolOptions","toolMode","mode","EPS","vpCamera","getViewportIdsWithToolToRender","requireParallelNormals","getViewports","isRangeValid","isColorbarSizeValid","areColorbarRangesEqual","areColorbarSizesEqual","clamp","ColorbarCanvas","props","validateProps","colormap","imageRange","voiRange","container","showFullPixelValueRange","_colormap","_imageRange","_voiRange","_showFullImageRange","_canvas","_createRootElement","appendTo","_setCanvasSize","showFullImageRange","appendChild","dispose","parentElement","removeChild","document","createElement","pointerEvents","boxSizing","isConnected","RGBPoints","rgbPoints","colorsCount","getColorPoint","offset","canvasContext","getContext","isHorizontal","maxValue","windowWidth","previousColorPoint","currentColorPoint","incRawPixelValue","rawPixelValue","tVoiRange","normColor","tColorRange","fillStyle","fillRect","DEFAULTS","FONT","COLOR","TICK_SIZE","TICK_WIDTH","TICK_LABEL_MARGIN","MAX_NUM_TICKS","TICKS_STEPS","ColorbarTicks","ticks","ticksProps","ticksStyle","rangeTextPosition","_font","font","_color","_tickSize","tickSize","_tickWidth","tickWidth","_labelMargin","labelMargin","_maxNumTicks","maxNumTicks","_rangeTextPosition","ColorbarRangeTextPosition","Right","_showFullPixelValueRange","_createCanvasElement","showFullRange","visible","display","_getTicks","roughStep","stepPower","log10","roughtStepNormalized","step","scaleMax","scaleMin","ticksCount","_getLeftTickInfo","labelMeasure","labelPoint","tickPoints","end","_getRightTickInfo","_getTopTickInfo","_getBottomTickInfo","maxCanvasPixelValue","rangeWidth","clearRect","textBaseline","strokeStyle","tick","measureText","tickInfo","Top","Left","tickStart","tickEnd","beginPath","moveTo","lineTo","fillText","stroke","Widget","_containerResizeCallback","contentRect","contentBoxSize","inlineSize","blockSize","_containerSize","onContainerResize","_id","_rootElement","createRootElement","_containerResizeObserver","ResizeObserver","rootElement","resizeObserver","currentContainer","unobserve","observe","destroy","disconnect","containerSize","classList","MULTIPLIER","RANGE_TEXT_POSITION","TICKS_BAR_SIZE","Colorbar","_isMouseOver","_isInteracting","_mouseOverCallback","showTicks","stopPropagation","_mouseOutCallback","hideTicks","_mouseDownCallback","_addVOIEventListeners","_mouseDragCallback","initialState","multipliers","getVOIMultipliers","_getPointsFromMouseEvent","startPoints","startVOIRange","canvasDelta","local","wwDelta","wcDelta","voiLower","voiUpper","windowCenter","newVoiRange","preventDefault","_mouseUpCallback","_removeVOIEventListeners","_eventListenersManager","_colormaps","getColormapsMap","_activeColormapName","getInitialColormapName","_createCanvas","_ticksBar","_createTicksBar","_addRootElementEventListeners","activeColormapName","colormapName","currentVoiRange","onVoiChange","reset","updateTicksBar","colormaps","items","item","Name","some","cm","clientPoint","clientX","clientY","pagePoint","pageX","pageY","getBoundingClientRect","pageXOffset","pageYOffset","containerWidth","containerHeight","ticksBar","colorbarWidth","colorbarHeight","Bottom","isRangeTextPositionValid","ticksBarTop","ticksBarLeft","manager","initialDragState","defaultImageRange","ViewportColorbar","_getImageRange","_getVOIRange","autoHideTicks","_hideTicksTimeoutId","timeLeft","_hideTicksTime","_stackNewImageCallback","_element","_imageVolumeModifiedCallback","_volumeId","_viewportVOIModifiedCallback","showAndAutoHideTicks","_viewportColormapModifiedCallback","_addCornerstoneEventListener","clientWidth","clientHeight","ptMultiplier","isPreScaled","fixedPTWindowWidth","xMultiplier","setProperties","viewportsContainingVolumeUID","getRange","volumeActor","getProperty","getRGBTransferFunction","interval","IMAGE_VOLUME_MODIFIED","VOI_MODIFIED","COLORMAP_MODIFIED","getLuminanceFromRegion","luminance","pixelData","spIndex","row","column","columns","red","green","blue","calculateMinMaxMean","pixelLuminance","globalMin","globalMax","numPixels","spv","extractWindowLevelRegionToolData","minPixelValue","maxPixelValue","getVolumeId","cornerstoneImageMetaData","Rows","rows","Columns","extractImageDataVolume","getCornerstoneImage","extractImageDataStack","vtkErrorMacro","vtkDebugMacro","m","vtkImageMarchingSquares","publicAPI","model","classHierarchy","getContourValues","contourValues","ids","pixelScalars","pixelPts","edgeLocator","newInstance","getPixelScalars","dims","increments","kernelX","kernelY","ii","getPixelPoints","produceLines","cVal","slicingMode","CASE_MASK","xyz","pId","pixelLines","getCase","eid","edgeVerts","getEdge","mergePoints","isInsertedEdge","x0","insertEdge","requestData","inData","outData","getOrigin","extent","getExtent","computeIncrements","getKernels","cv","initialize","polydata","setData","Uint32Array","timeEnd","DEFAULT_VALUES","extend","initialValues","arguments","obj","algo","setGet","vtkImageMarchingSquares$1"],"sourceRoot":""}