{"version":3,"file":"797.bundle.dbc0334ff8531f288260.js","mappings":"sLAqCA,MAAeA,UAAuB,IAI7B,uBAAOC,IAAoBC,GAChC,IAAIC,EAAyB,CAC3BC,cAAe,KACfC,aAAa,EACbC,aAAa,EACbC,SAAU,CACRC,SAAUC,KAAKD,UAEjBE,KAAM,CACJC,KAAM,GACNC,QAAS,CACPC,OAAQ,IAAIC,MACZC,QAAS,CACPC,UAAU,EACVC,cAA6B,CAAC,EAAG,EAAG,GACpCC,iBAAkB,CAChBC,QAAuB,CAAC,EAAG,EAAG,GAC9BC,SAAwB,CAAC,EAAG,EAAG,GAC/BC,WAA0B,CAAC,EAAG,EAAG,GACjCC,YAA2B,CAAC,EAAG,EAAG,MAIxCC,MAAO,KAGX,IAAK,MAAMC,KAAYtB,EACrBC,EAAa,sBAAkBA,EAAYqB,GAE7C,OAAOrB,CACT,CAOO,kCAAOsB,CAA4BC,KAAaxB,GACrD,OAAOO,KAAKR,iBACV,CAAEM,SAAUmB,EAASC,uBAClBzB,EAEP,CAUO,6BAAO0B,CAAuBF,KAAaxB,GAChD,MAAMC,EAAaM,KAAKgB,4BACtBC,KACGxB,IAEL,IAAA2B,eAAc1B,EAAYuB,EAASI,UACnC,QAA0B3B,EAAYuB,EAASI,QACjD,CAOA,WAAAC,CAAYC,EAA4BC,GACtCC,MAAMF,EAAWC,GAqFZ,KAAAE,kBAAoB,CACzBC,EACAC,KAEA,IAAKA,EACH,OAAO,EAGT,MAAM,QAAEP,EAAO,cAAEQ,GAAkBF,EAAIG,OACjCC,EAAeF,EAAcG,OACnC,IAAIC,GAA6B,EAEjC,IAAK,MAAMvC,KAAckC,EAAqB,CAE5C,IACE,IAAAM,oBAAmBxC,MAClB,IAAAyC,qBAAoBzC,EAAWC,eAEhC,SAGF,MAAM,KAAEM,GAASP,EACX0C,EAAsBnC,EAAKE,QAC7BF,EAAKE,QAAQkC,uBACbC,EAIEC,EAAOvC,KAAKwC,4BAChBnB,EACA3B,EACAqC,EACA,GAGIU,EAA6BF,IAAS7C,EAAWE,YACjD8C,GAA8BH,GAAQ7C,EAAWE,YACnD6C,GAA8BC,GAChChD,EAAWE,aAAeF,EAAWE,YACrCqC,GAA6B,GAE7BhC,EAAKE,SACLF,EAAKE,QAAQkC,oBAAsBD,IAGnCH,GAA6B,EAEjC,CAEA,OAAOA,CAA0B,EApI7BV,EAAUoB,eAAeC,eAC3B5C,KAAK2C,cAAcC,aAAerB,EAAUoB,cAAcC,cAGxDrB,EAAUoB,eAAeE,kBAC3B7C,KAAK2C,cAAcE,gBACjBtB,EAAUoB,cAAcE,gBAE9B,CA4IA,uBAAAC,CACEzB,EACA3B,EACAqC,EACAgB,GAEA,MAAMC,GAAiB,IAAAC,mBAAkB5B,IACnC,SAAEJ,GAAa+B,GAEf,KAAE/C,GAASP,GACX,mBAAEwD,GAAuBjD,GACzB,OAAEG,EAAM,QAAEE,GAAYL,EAAKE,QAEjC,GAAIG,EAAS,CACX,MAAM,iBAAEG,GAAqBH,EAC7B,GAAIG,EAAkB,CACpB,MAAM0C,EAAoB,CACxBzC,QAASO,EAASmC,cAAc3C,EAAiBC,SACjDC,SAAUM,EAASmC,cAAc3C,EAAiBE,UAClDC,WAAYK,EAASmC,cAAc3C,EAAiBG,YACpDC,YAAaI,EAASmC,cAAc3C,EAAiBI,cAGvD,GACEkB,EAAa,IAAMoB,EAAkBzC,QAAQ,IAC7CqB,EAAa,IAAMoB,EAAkBtC,YAAY,IACjDkB,EAAa,IAAMoB,EAAkBzC,QAAQ,IAC7CqB,EAAa,IAAMoB,EAAkBtC,YAAY,GAGjD,OADAZ,EAAKE,QAAQkC,kBAAoB,KAC1B/B,CAEX,CACF,CAEA,IAAK,IAAI+C,EAAI,EAAGA,EAAIjD,GAAQkD,OAAQD,IAAK,CACvC,MAAME,EAAQnD,EAAOiD,GACfG,EAA6BN,EAC/BK,EAAME,MAAM,EAAG,GACfxC,EAASmC,cAAcG,GAQ3B,IAAa,IALX,cACExB,EACAyB,GACET,EAIJ,OADA9C,EAAKE,QAAQkC,kBAAoBgB,EAC1BE,CAEX,CAEAtD,EAAKE,QAAQkC,kBAAoB,IACnC,CAYO,qBAAAqB,CACLC,EACAjE,GAKA,MAAO,CACLkE,WAAY5D,KAAK6D,SACf,oBACAF,EACAjE,GAEFoE,WAAY9D,KAAK6D,SACf,oBACAF,EACAjE,GAEFqE,SAAU/D,KAAK6D,SAAS,kBAAmBF,EAAgBjE,GAC3DsE,MAAOhE,KAAK6D,SAAS,eAAgBF,EAAgBjE,GACrDuE,OAAQjE,KAAK6D,SAAS,gBAAiBF,EAAgBjE,GACvDwE,WAAYlE,KAAK6D,SACf,oBACAF,EACAjE,GAEFyE,UAAWnE,KAAK6D,SACd,uBACAF,EACAjE,GAEF0E,SAAUpE,KAAK6D,SACb,sBACAF,EACAjE,GAGN,CASA,WAAA2E,CACEpD,EACAqD,EACAC,GAEA,GAAItD,aAAoB,EAAAuD,mBAAoB,CAC1C,MAAMC,EAAW,wBAAoBH,GAC/BI,EAAS,EAAAC,MAAMC,UAAUH,GAC/B,YAA+BnC,IAAxBoC,GAAQG,SAASC,EAC1B,CACA,MAAMC,EACJR,GAAW,EAAAS,SAAA,IAAa,gBAAiBT,GAC3C,MAAuC,iBAAzBQ,GAAeE,KAC/B,CAMU,kBAAAC,CAAmBC,GAI3B,MAAM,WAAEzF,EAAU,eAAE0F,GAAmBD,EACjCtB,EAAYwB,GAChBrF,KAAK6D,SAASwB,EAAUD,EAAgB1F,IACpC,cAAEC,GAAkBD,EACpBkE,GAAa,IAAAzB,qBAAoBxC,GACjC2F,GAAS,IAAApD,oBAAmBxC,GAE5ByE,EAAYN,EAAS,aACrBO,EAAWP,EAAS,YACpBG,EAAQH,EAAS,SAIvB,MAAO,CACLD,aACA0B,SACAtB,QACAG,YACAC,WACAmB,YAAa,EACbC,UAAWxB,EACXyB,YAAa,EACbxB,OAZaJ,EAAS,UAatB6B,QAZmB1F,KAAK0D,sBAAsB0B,EAAgB1F,GAclE,CAYQ,2BAAA8C,CACNnB,EACA3B,EACAqC,EACAgB,GAUA,GAP6B/C,KAAK8C,wBAChCzB,EACA3B,EACAqC,EACAgB,GAIA,OAAO,EAYT,QAR0B/C,KAAK2F,gBAC7BtE,EACA3B,EACAqC,EACAgB,EACA,eAGF,CAGF,EAGFxD,EAAeQ,SAAW,iBAC1B,S,2CC9cA,MAAM6F,EAAwC,CAC5CC,eAAe,EACfC,mBAAoB,EACpBC,qBAAsB,EACtBC,+BAAgC,EAChCC,YAAY,EACZC,oBAAoB,EACpBC,UAAW,GACXC,kBAAmB,IACnBC,eAAgB,EAChBC,uBAAwB,KAS1B,SAASC,EAAsBC,GAC7B,OACEA,GACgC,kBAAzBA,EAAOX,eACuB,iBAA9BW,EAAOV,oBACyB,iBAAhCU,EAAOT,sBACmC,iBAA1CS,EAAOR,gCACe,kBAAtBQ,EAAOP,YACuB,kBAA9BO,EAAON,oBACc,iBAArBM,EAAOL,WACsB,iBAA7BK,EAAOJ,mBACmB,iBAA1BI,EAAOH,gBAC2B,iBAAlCG,EAAOF,sBAElB,CAEA,QAtBA,WACE,OAAOV,CACT,C,6DCNe,MAAMa,SACF,KAAAC,oBACf,yCAA0C,CAElC,sBAAOC,CAAgBpC,GAC/B,MAAMqC,EAAQrC,EAAQqC,MAAM5G,KAAK0G,qBACjC,IAAKE,IAAUA,EAAM,GACnB,OAAO,KAET,MAAMC,EAAQD,EAAM,GAAGE,MAAM,KAAKC,KAAKC,GAAOC,OAAOD,KACrD,OAAqB,IAAjBH,EAAMvD,OACDuD,EAAM,GAERA,CACT,CAEO,qBAAOK,CAAeL,GAC3B,OAAIxG,MAAM8G,QAAQN,GACT,GAAGA,EAAM,MAAMA,EAAM,KAEvBO,OAAOP,EAChB,CAEU,sBAAOQ,CACf9C,EACAsC,GAEA,MAAMD,EAAQrC,EAAQqC,MAAM5G,KAAK0G,qBACjC,IAAKE,IAAUA,EAAM,GACnB,OAAO,KAET,MAAMU,EAAiBtH,KAAKkH,eAAeL,GAC3C,OAAOtC,EAAQgD,QACbvH,KAAK0G,oBACL,GAAGE,EAAM,KAAKU,IAElB,CAQO,oBAAOE,CACZ9H,EACAmH,EACAY,GAEA,MAAM,kBAAEC,GAAsBhI,EAAWI,SACzCJ,EAAWI,SAAS4H,kBAAoB1H,KAAKqH,gBAC3CK,EACAb,GAEF,MAAMc,EAAc,IACfF,EACH/H,eAEF,IAAAkI,cAAa,EAAAC,YAAa,UAAOC,oBAAqBH,EACxD,CAEO,oBAAOI,CACZrI,GAEA,OAAOM,KAAK2G,gBAAgBjH,EAAWI,SAAS4H,kBAClD,E,gFChEF,SAASM,EACP/G,EACAlB,EACAkI,EACAC,GAKA,MAAMC,EAAgBlH,EAASC,oBACzB,gBAAEkH,EAAe,oBAAEC,GAAwBF,EAC3CzI,EAAa,CACjBC,cAAeuI,GAASvI,eAAiB,EAAA2I,UAAA,SACzCrI,KAAM,CACJE,QAAS,CACPC,OAAQ6H,IAGZrI,aAAa,EACb2I,eAAe,EACf1I,aAAa,EACb2I,UAAU,EACVC,WAAW,EACX3I,SAAU,CACRC,WACAqI,kBACAC,sBACAX,kBAAmBgB,EACjBzH,EACAgH,EAAY,GACZG,MAECF,IAIP,OADA,QAAcxI,EAAYuB,EAASI,SAC5B3B,CACT,CAEA,SAASgJ,EACPzH,EACA0H,EACAP,GAEA,IAAIV,EAEJ,GAAIzG,aAAoB,EAAA2H,cACtBlB,EAAoBmB,EAClB5H,EACA0H,EACAP,OAEG,MAAInH,aAAoB,EAAAuD,oBAW7B,MAAM,IAAIsE,MACR,gFAZ+C,CACjD,MAAMxE,EAkBV,SAAqBrD,GACnB,MAAMqD,EAAWrD,EAAS8H,mBAC1B,GAAIzE,EACF,OAAOA,EAET,GAAIrD,aAAoB,EAAAuD,mBACtB,MAAO,YAKX,SAA2BvD,GACzB,MAAM+H,EAAe/H,EAASgI,YAE9B,IAAKD,EACH,OAEF,OAAOA,EAAaE,MACjBC,GAAmD,cAApCA,EAAWC,MAAMC,kBAChCC,GACL,CAduBC,CAAkBtI,KAEvC,MAAM,IAAI6H,MAAM,uDAClB,CA3BqBU,CAAYvI,GACvBwD,EAAW,EAAA6D,UAAA,YAAsBhE,GACjCmF,EAAc,EAAA9E,MAAMC,UAAUH,GAEpCiD,EAAoB,EAAAY,UAAA,kBAClBmB,EACAd,EACAP,EAEJ,CAIA,CAEA,OAAOV,CACT,CAwBA,SAASmB,EACP5H,EACA0H,EACAP,GAEA,MAAMsB,EAAWzI,EAAS0I,cAC1B,IAAKD,IAAaA,EAASpG,OACzB,OAGF,MAAMsG,EAAqBF,EAAS3C,KAAKxC,IACvC,MAAM,qBAAEsF,GAAyB,EAAA7E,SAAA,IAAa,mBAAoBT,GAC5DuF,EAaV,SACEnB,EACAoB,EACA3B,GAEA,MAAM4B,EAAM,cACZ,SAASA,EAAKrB,EAAUoB,GAExB,MAAME,EAAM,SAASD,EAAK5B,GAE1B,OAAO8B,KAAKC,IAAIF,EAClB,CAxBqBG,CACfzB,EACAkB,EACAzB,GAEF,MAAO,CAAE7D,UAASuF,WAAU,IAK9B,OAFAF,EAAmBS,MAAK,CAACC,EAAGC,IAAMD,EAAER,SAAWS,EAAET,WAE1CF,EAAmB,GAAGrF,OAC/B,C,mCCpGA,QAjBA,SACEiG,EACAC,GAGA,MAAMC,EAAmBF,EAAUG,WAAU,EAAEC,EAAKC,KAASD,IAAQC,IAErE,IAA0B,IAAtBH,EACF,MAAM,IAAI5B,MAAM,uDAMlB,OAFA0B,EAAUE,GAAkB,IAAMD,EAClCD,EAAUE,GAAkB,IAAMD,EAC3BD,CACT,C,0DCvBA,MAAM,QAAEM,GAAY,EAAAC,UAOpB,SAASC,EACP5K,EACA6K,EACAC,GAAU,GAEV,IAAIC,EAAOC,IACPC,EAAOH,GAAWE,IAAW,EAC7BE,EAAOF,IACPG,EAAOL,GAAWE,IAAW,EAC7BI,EAAOJ,IACPK,EAAOP,GAAWE,IAAW,EAEjC,MAAMM,EAA6B,IAAtBtL,EAAO,IAAIkD,OAGxB,IAAK,IAAID,EAAI,EAAGA,EAAIjD,EAAOkD,OAAQD,IAAK,CACtC,MAAMsI,EAAIvL,EAAOiD,GACjB8H,EAAOjB,KAAKU,IAAIe,EAAE,GAAIR,GACtBE,EAAOnB,KAAKW,IAAIc,EAAE,GAAIN,GACtBC,EAAOpB,KAAKU,IAAIe,EAAE,GAAIL,GACtBC,EAAOrB,KAAKW,IAAIc,EAAE,GAAIJ,GAElBG,IACFF,EAAOtB,KAAKU,IAAIe,EAAE,IAAMH,EAAMA,GAC9BC,EAAOvB,KAAKW,IAAIc,EAAE,IAAMF,EAAMA,GAElC,CAkCA,OAhCIR,GACFE,EAAOjB,KAAKW,IAAIK,EAAUD,EAAW,GAAKH,EAAU,EAAGK,GACvDE,EAAOnB,KAAKU,IACVM,EAAUD,EAAW,GAAKH,EAAUG,EAAW,GAAK,EACpDI,GAEFC,EAAOpB,KAAKW,IAAIK,EAAUD,EAAW,GAAKH,EAAU,EAAGQ,GACvDC,EAAOrB,KAAKU,IACVM,EAAUD,EAAW,GAAKH,EAAUG,EAAW,GAAK,EACpDM,GAGEG,GAA8B,IAAtBT,EAAW3H,SACrBkI,EAAOtB,KAAKW,IAAIK,EAAUD,EAAW,GAAKH,EAAU,EAAGU,GACvDC,EAAOvB,KAAKU,IACVM,EAAUD,EAAW,GAAKH,EAAUG,EAAW,GAAK,EACpDQ,KAGMP,IAEVC,EAAOjB,KAAKW,IAAI,EAAGM,GACnBE,EAAOnB,KAAKU,IAAIQ,IAAUC,GAC1BC,EAAOpB,KAAKW,IAAI,EAAGS,GACnBC,EAAOrB,KAAKU,IAAIQ,IAAUG,GAEtBG,IACFF,EAAOtB,KAAKW,IAAI,EAAGW,GACnBC,EAAOvB,KAAKU,IAAIQ,IAAUK,KAIvBC,EACH,CACE,CAACP,EAAME,GACP,CAACC,EAAMC,GACP,CAACC,EAAMC,IAET,CAAC,CAACN,EAAME,GAAO,CAACC,EAAMC,GAAO,KACnC,CAWO,SAASK,EACdxL,EACA6K,GAEA,OAAOD,EAAqB5K,EAAQ6K,GAAY,EAClD,CAWO,SAASY,EACdzL,EACA0L,GAEA,OAAOd,EAAqB5K,EAAQ0L,GAAY,EAClD,C,iQC1GA,MAAM,uCAAEC,GAA2C,EAAAzD,UAUpC,SAAS0D,EACtBzH,EACA0H,EACAC,GAGkC,iBAAvBA,IACTA,EAAqB,CACnBC,KAAM,EAAAC,MAAA,iBAAuBC,KAC7BC,MAAOJ,IAIXH,EAAuCQ,IAAIhI,EAAS2H,GAGlCD,EAAgBO,oBAGxBC,SAASxL,IACAA,EAAS0I,cACb+C,SAASnI,IACpBtD,EAAS0L,iBAAiBpI,EAC5B,GAMJ,C,uHCvCKqI,E,uBAAL,SAAKA,GACH,+CACA,8CACD,CAHD,CAAKA,IAAAA,EAAM,KAKX,UCLMC,EAA4C,CAAC,EAEnD,SAASC,EAAazL,EAAyBpB,GAC7C,MAAM+C,GAAiB,IAAAC,mBAAkB5B,IACnC,WAAE0L,GAAe/J,EACvB6J,EAAME,GAAc9M,CACtB,CAEA,SAAS+M,EAAa3L,GACpB,MAAM2B,GAAiB,IAAAC,mBAAkB5B,IACnC,WAAE0L,GAAe/J,EACvB,OAAO6J,EAAME,EACf,C,eCEA,MAAM,eAAEE,GAAmB,EAAAb,OACrB,aAAExE,GAAiB,YAEnBsF,GAAY,EACZC,EAA2B,IAAIC,IASrC,SAASC,EACPhM,EACAiM,GAEA,IAAIC,EACAC,EAEJ,QAAgBlL,IAAZjB,EACF,MAAM,IAAIyH,MAAM,2CAGlB,MAAM9F,GAAiB,IAAAC,mBAAkB5B,GAEzC,IAAK2B,EACH,MAAM,IAAI8F,MACR,iEAICwE,IACHA,EAAkB,CAAC,GAIrBA,EAAgBG,mBACdH,EAAgBG,qBAAsB,EAExC,MAAM,SAAExM,GAAa+B,EACf0B,EAASgJ,EAAuBzM,GAChC0M,EA2YR,SACE1M,EACAqM,GAEA,GAAIrM,aAAoB,EAAA2H,cACtB,OAnHJ,SACE3H,EACA2M,GAEA,MAAMlE,EAAWzI,EAAS0I,cAE1B,MAAO,CACL,kBAAIkE,GACF,OAAOnE,EAASpG,MAClB,EACA,oBAAIwK,GACF,OAAO7M,EAAS8M,uBAClB,EACA,0BAAIC,GAEF,OAAO,CACT,EACAC,qBAAsB,EACtB,MAAAC,CAAOC,GAEHnO,KAAKiO,sBAAwBL,GAC7B3M,EAASmN,iBAAmBnB,EAAeoB,SAE3CrO,KAAKiO,wBAGPjO,KAAKiO,qBAAuB,GAC5B,OAAOhN,EAAU,CAAEkN,QAAOG,gBAAiBpB,IAC7C,EAEJ,CAqFWqB,CACLtN,EACAqM,EAAgBM,iBAAmB,IAIvC,GAAI3M,aAAoB,EAAAuN,eAAgB,CACtC,MAAM9J,EAASgJ,EAAuBzM,GAEtC,OAAIqM,EAAgBG,oBAAsB/I,GAAQ+J,kBAnCtD,SACE/J,GAEA,MAAO,CACL,kBAAImJ,GACF,OAAOnJ,EAAOgK,aAChB,EACA,oBAAIZ,GACF,OAAOpJ,EAAOiK,cAChB,EACA,0BAAIX,GAEF,OAAO,CACT,EACA,MAAAE,CAAOC,GAELzJ,EAAOiK,gBAAkBR,CAC3B,EAEJ,CAiBaS,CACsBlK,GA9FnC,SACEzD,EACAyD,GAEA,MAAM,SAAED,GAAaC,EACfmK,EAAmB,CACvBzG,gBAAiB,cACjB0G,WAAY,MAGRC,EAAgB,KACpB,MAAMC,EAAS/N,EAASgO,YAQxB,IANGJ,EAAiBC,aACjB,YAAYE,EAAO5G,gBAAiByG,EAAiBzG,iBAKvC,CACf,MAAM0G,EAAa,wCACjB7N,EACAwD,GAGFoK,EAAiBzG,gBAAkB4G,EAAO5G,gBAC1CyG,EAAiBC,WAAaA,CAChC,CAEA,OAAOD,EAAiBC,UAAU,EAGpC,MAAO,CACL,kBAAIjB,GACF,OAAOkB,IAAgBlB,cACzB,EACA,oBAAIC,GACF,OAAOiB,IAAgBjB,gBACzB,EACA,0BAAIE,GACF,MAAMgB,EAAS/N,EAASgO,YAClBC,EAAwBxK,EAAOyK,UAClC1L,MAAM,EAAG,GACTsD,KAAKqI,IAAOA,IACTnF,EAAM,SAASiF,EAAuBF,EAAO5G,iBAInD,OAAO,YAAgB6B,EAAK,EAC9B,EACA,MAAAiE,CAAOC,GACLY,IAAgBjB,kBAAoBK,GACpC,OAAOlN,EAAU,CAAEkN,SACrB,EAEJ,CA2CWkB,CAAqCpO,EAAUyD,EACxD,CAEA,MAAM,IAAIoE,MAAM,wBAClB,CAna0BwG,CAAuBrO,EAAUqM,GACzD,IAAIiC,EAAevC,EAAa3L,GAEhC,MAAMmO,EACJlC,EAAgBG,oBAAsB/I,GAAQ+J,kBA6ChD,GAzCIe,GACFC,EAAuBpO,GAGpBkO,EAiBHG,EAAUrO,EAAS,CACjBsO,iBAAkBH,EAClBzC,WAAY9L,EAAS2O,MAlBvBL,EAAe,CACbM,gBAAYvN,EACZwN,gBAAiB,GACjBC,wBAAoBzN,EACpB0N,uBAAuB,EACvBC,sBAAsB,EACtBC,gBAAiB5C,EAAgB4C,sBAAmB5N,EACpD6N,MAAO7C,EAAgB8C,gCAAkC,EACzDC,QAAS/C,EAAgB+C,UAAW,EACpCC,KAAMhD,EAAgBgD,OAAQ,GAEhCxD,EAAazL,EAASkO,IAWxBA,EAAa9B,mBAAqBH,EAAgBG,oBAIhDH,EAAgBwC,gBAAkB,GAClCxC,EAAgBwC,gBAAkB,KAElCP,EAAaO,gBAAkB7I,OAAOqG,EAAgBwC,iBACtDP,EAAac,QAAUd,EAAaO,gBAAkB,EAEtDP,EAAaS,uBAAwB,IAKE,IAAvCT,EAAaS,uBACbT,EAAaW,iBACbX,EAAaW,gBAAgB5M,SAAWqK,EAAgBE,gBACxDF,EAAgBK,uBAChB,CACA,MAAM,SAAEuC,EAAQ,cAAEC,GAyJtB,SAA8BC,EAAkBN,GAC9C,IAAI9M,EACAqN,EACAC,EACAC,EAAM,EACV,MAAMC,EAAQJ,EAAOnN,OACfiN,EAAW,GAGjB,IAAIC,GAAgB,GAEC,iBAAVL,GAAsBA,GAAS,KACxCA,EAAQ,GAIV,IAAK9M,EAAI,EAAGA,EAAIwN,EAAOxN,IAErBsN,EAAS1J,OAAOwJ,EAAOpN,IAAM8M,EAAS,EACtCI,EAASO,KAAKH,GACJ,IAANtN,EAEFqN,EAASC,EACAA,IAAUD,IACnBF,GAAgB,GAGlBI,GAAOD,EAGLJ,EAASjN,OAAS,IAIlBqN,EAHEH,EAGOI,EAAML,EAASjN,OAAU,EAE1BiN,EAAS,GAGnBA,EAASO,KAAKH,IAGhB,MAAO,CAAEJ,WAAUC,gBACrB,CApMwCO,CAClCxB,EAAaW,gBACbX,EAAaY,OAGf5C,EAAmBgD,EACnB/C,EAAwBgD,CAC1B,CAGA,MAAMQ,EAAiB,KACrB,MAAM,eAAEnD,EAAc,iBAAEC,GAAqBH,EAC7C,IAAIsD,EAAenD,GAAoByB,EAAac,SAAW,EAAI,GACnE,MAAMa,EACJD,EAAe,GAAKA,GAAgBpD,EAEtC,IAAK0B,EAAae,MAAQY,EAAwB,CAGhDxB,EAAUrO,EAAS,CACjBsO,iBAAkBH,EAClBzC,WAAY9L,EAAS2O,KAGvB,MAAMjI,EAAc,CAAEtG,WAGtB,YADAuG,EAAavG,EAAS,EAAY8P,aAAcxJ,EAElD,CAGIsJ,GAAgBpD,EAClBoD,EAAe,EACNA,EAAe,IACxBA,EAAepD,EAAiB,GAGlC,MAAMM,EAAQ8C,EAAenD,EAEzBK,GACFR,EAAgBO,OAAOC,EACzB,EAGEqB,GACFrC,EAAyBiE,IAAI1M,EAAOD,SAAUpD,GAM9CkM,GACAA,EAAiBjK,OAAS,GAC1BkK,GAEA+B,EAAaU,sBAAuB,EACpCV,EAAaM,WAAawB,OAAOC,YAC/B,SAASC,IACPhC,EAAaM,WAAawB,OAAOC,WAC/BC,EACAhE,EAAiBI,EAAgBG,mBAEnCkD,GACF,GACA,KAIFzB,EAAaU,sBAAuB,EACpCV,EAAaM,WAAawB,OAAOG,YAC/BR,EACA,IAAO9G,KAAKC,IAAIoF,EAAaO,mBAIjC,MAAMnI,EAAc,CAClBtG,WAGFuG,EAAavG,EAAS,EAAYoQ,aAAc9J,EAClD,CAMA,SAAS+J,EAASrQ,EAAyB6G,EAAU,CAAC,GACpDwH,EAAUrO,EAAS,CACjBsO,iBAAiB,KACdzH,GAEP,CAEA,SAASwH,EACPrO,EACA6G,EAAU,CAAEyH,iBAAiB,EAAM5C,gBAAYzK,IAE/C,MAAM,gBAAEqN,EAAe,WAAE5C,GAAe7E,EAClClF,GAAiB,IAAAC,mBAAkB5B,GAEzC,IAAIsQ,EACJ,GAAK3O,EAME,CACL,MAAM,SAAE/B,GAAa+B,EACrB2O,EAAY3E,EAAa/L,EAASI,QACpC,KATqB,CACnB,IAAI0L,EAGF,OAFA4E,EDxMN,SACE5E,GAEA,OAAOF,EAAME,EACf,CCoMkB6E,CAAyB7E,EAIzC,CAKI4E,GA2FN,SAA2BpC,GACzB,MAAMK,EAAKL,EAAaM,gBAEN,IAAPD,IACTL,EAAaM,gBAAavN,EACtBiN,EAAaU,qBACf4B,aAAajC,GAEbkC,cAAclC,GAGpB,CArGImC,CAAkBJ,GAIlBhC,GACA3M,GAAgB/B,oBAAoB,EAAAuD,oBAEpCiL,EAAuBpO,EAE3B,CAMA,SAASoO,EAAuBpO,GAC9B,MAAM,SAAEJ,IAAa,IAAAgC,mBAAkB5B,GACjCqD,EAASgJ,EAAuBzM,GAKtC,GAAIyD,GAAQ+J,kBAAmB,CAC7B,MAAMuD,EAAqB7E,EAAyB8E,IAAIvN,EAAOD,UAE/D0I,EAAyB+E,OAAOxN,EAAOD,UAEnCuN,GAAsBA,IAAuB3Q,GAC/CqQ,EAAyBM,EAE7B,CACF,CA+EA,SAAStE,EAAuBzM,GAC9B,MAAMkR,EARR,SAAiClR,GAC/B,OAAOA,EACJgI,YACAlC,KAAKqC,GAAU,EAAAzE,MAAMC,UAAUwE,EAAME,OACrC8I,QAAQ1N,KAAaA,GAC1B,CAGkB2N,CAAwBpR,GAGxC,OAFsBkR,EAAQjJ,MAAMxE,GAAWA,EAAO+J,qBAE9B0D,EAAQ,EAClC,C,kBC5UO,SAASG,EAAKC,EAAKC,EAAKC,GAC7B,OAAOvI,KAAKU,IAAIV,KAAKW,IAAI2H,EAAKD,GAAME,EACtC,C,kBAiBA,S,kDCtBO,SAASC,EACdhT,GAEA,GAAIA,EAAWiT,oBAEb,OAEF,IAAKjT,EAAWO,KAAK2S,aACnB,MAAM,IAAI9J,MACR,kFAIJ,MAAM,eAAE+J,EAAc,aAAEC,GAAiBpT,EAAWO,KAAK2S,aACnDA,GAAe,IAAAG,iBAAgBF,GAEhCD,EAAaI,mBAAmBC,UACnCL,EAAaI,mBAAmBC,QAAU,CAAEC,kBAAmB,IAAI9F,MAGrE,MAAM,kBAAE8F,GAAsBN,EAAaI,mBAAmBC,QAE9D,IAAIE,EAAqBD,EAAkBjB,IAAIa,GAE1CK,IACHA,EAAqB,IAAIC,IACzBF,EAAkB9B,IAAI0B,EAAcK,IAGtCD,EAAkB9B,IAChB0B,EACAK,EAAmB5G,IAAI7M,EAAWC,eAEtC,C,kBC9Be,SAAS0T,EACtBC,EACAC,GAEA,MAAQX,aAAcY,GAAsBF,EAAgBrT,MACpD2S,aAAca,GAAuBF,EAAiBtT,KAE9D,OACEuT,EAAkBX,iBAAmBY,EAAmBZ,gBACxDW,EAAkBV,eAAiBW,EAAmBX,YAE1D,C,kCClBe,SAASY,EACtBhU,GAEA,QAAyCA,EAAYO,MAAM2S,YAC7D,C,kECGO,SAASe,EACdjU,GAEA,IAAKA,EAAWO,KAAK2S,aACnB,MAAM,IAAI9J,MACR,qFAIJ,MAAM,eAAE+J,EAAc,aAAEC,GAAiBpT,EAAWO,KAAK2S,aACnDA,EAAe,EAAA/F,MAAA,gBAAsBgG,IACrC,kBAAEK,GAAsBN,GAAcI,mBAAmBC,SAAW,CAAC,EACrEE,EAAqBD,GAAmBjB,IAAIa,GAE7CK,IAILA,EAAmBjB,OAAOxS,EAAWC,eAGhCwT,EAAmBS,MACtBV,EAAkBhB,OAAOY,GAE7B,C,kCCJA,QAvBA,SAA4Be,EAAsBC,GAChD,IAAIC,EAAY,EAEhB,IAAK,IAAI1Q,EAAI,EAAGA,EAAIwQ,EAASvQ,OAAS,EAAGD,IAAK,CAC5C,MAAM2Q,EAASH,EAASxQ,GAClB4Q,EAASJ,EAASxQ,EAAI,GAC5B0Q,GAAa7J,KAAKgK,KAChBhK,KAAKiK,IAAIF,EAAO,GAAKD,EAAO,GAAI,GAAK9J,KAAKiK,IAAIF,EAAO,GAAKD,EAAO,GAAI,GAEzE,CAEA,GAAIF,EAAQ,CACV,MAAMM,EAAaP,EAAS,GACtBQ,EAAYR,EAASA,EAASvQ,OAAS,GAC7CyQ,GAAa7J,KAAKgK,KAChBhK,KAAKiK,IAAIE,EAAU,GAAKD,EAAW,GAAI,GACrClK,KAAKiK,IAAIE,EAAU,GAAKD,EAAW,GAAI,GAE7C,CAEA,OAAOL,CACT,C,6DCvBA,MAAM,QAAEO,GAAY,YAeL,SAASC,EACtB7U,EACA8U,GAEA,MAAM,SAAEX,GAAanU,EAAWO,KAAKwU,SAC/B,OAAErU,GAAWV,EAAWO,KAAKE,SAC7B,OAAEmD,GAAWlD,EACnB,GAAIoU,IAAgBlR,EAClB,OAAOuQ,EAASvQ,OAKlB,GAHIkR,EAAc,IAChBA,GAAeA,EAAclR,GAAUA,GAErB,IAAhBkR,EACF,OAAO,EAET,MAAME,EAAStU,EAAOoU,GAChBG,EAAQd,EAASlJ,WAAWpH,GAAU+Q,EAAQI,EAAQnR,KAC5D,IAAe,IAAXoR,EACF,OAAOA,EAGT,IAAIC,EAAkBxJ,IACtB,OAAOyI,EAASgB,QAAO,CAACC,EAAcvR,EAAOwR,KAC3C,MAAMjL,EAAW,qBAAqBvG,EAAOmR,GAC7C,OAAI5K,EAAW8K,GACbA,EAAkB9K,EACXiL,GAEFD,CAAY,IACjB,EACN,C,qbCrCe,SAASE,EACtB1B,EACAC,GAEA,MAAQnL,gBAAiB6M,GAAyB3B,EAAgBxT,UAC1DsI,gBAAiB8M,GAA0B3B,EAAiBzT,SAC9DmK,EAAM,SAASgL,EAAsBC,GAG3C,IAFuB,YAAgB,EAAGhL,KAAKC,IAAIF,IAGjD,OAAO,EAGT,MAAQ4J,SAAUsB,GAAkB7B,EAAgBrT,KAAKwU,SACjDZ,SAAUuB,GAAmB7B,EAAiBtT,KAAKwU,QAMrDY,EAAgB,SAASJ,EAAsBE,EAAc,IAC7DG,EAAiB,SAASL,EAAsBG,EAAe,IAErE,OAAO,YAAgBC,EAAeC,EACxC,CCtCA,SAASC,EAAaC,EAAMC,EAAOC,GACjC,IAAIf,GAAS,EAWb,GAVAc,EAAMhJ,SAAQ,CAACkJ,EAAMtS,KACfsR,GAAS,GAITgB,EAAKrL,GAAKkL,EAAKjL,IACjBoK,EAAQtR,EACV,IAGEsR,GAAS,EAAG,CACd,MAAMiB,EAAWH,EAAMd,GAKvB,OAJAc,EAAMI,OAAOlB,EAAO,GAEpBe,EAAc5E,KAAK8E,EAASrL,GAExBmL,EAAc,IAAME,EAASrL,EACxB,CACLuL,eAAgBL,EAChBC,gBACAvJ,KAAM,iBAKHoJ,EAAaK,EAAUH,EAAOC,EACvC,CAEA,MAAO,CACLI,eAAgBL,EAChBC,gBACAvJ,KAAM,cAEV,CAMO,SAAS4J,EAAaN,GAC3B,GAAoB,GAAhBA,EAAMnS,OACR,MAAO,GAGT,MAAMoS,EAAgB,GAEhBM,EAAYP,EAAMQ,QACxBP,EAAc5E,KAAKkF,EAAU1L,GAC7BoL,EAAc5E,KAAKkF,EAAUzL,GAC7B,MAAM2L,EAASX,EAAaS,EAAWP,EAAOC,GAE9C,GAAoC,GAAhCQ,EAAOJ,eAAexS,OACxB,MAAO,CACL,CACE6I,KAAM+J,EAAO/J,KACbuJ,cAAeQ,EAAOR,gBAGrB,CACL,MAAMS,EAAgBJ,EAAaG,EAAOJ,gBAK1C,OAJAK,EAAcrF,KAAK,CACjB3E,KAAM+J,EAAO/J,KACbuJ,cAAeQ,EAAOR,gBAEjBS,CACT,CACF,CAEO,SAASC,EAA2BX,GACzC,OAAOM,EAAaN,EACtB,CAEA,SACEM,eACAK,8BCrEK,SAASC,EAAiCC,EAAUC,GAAS,GAClE,MAAMnW,EAASkW,EAASE,YAClBf,EAAQa,EAASG,WAIjBC,EAAc,IAAIrW,MAAMD,EAAOuW,qBAClCC,KAAK,GACL7P,KAAI,CAAC8P,EAAGxT,IAAMjD,EAAO0W,SAASzT,GAAGI,UAE9BsT,EAAa,IAAI1W,MAAMoV,EAAMuB,oBAAoBJ,KAAK,GAAG7P,KAAI,CAAC8P,EAAGxT,KACrE,MAAMsS,EAAOF,EAAMwB,QAAY,EAAJ5T,GAAOI,QAClC,MAAO,CAAE6G,EAAGqL,EAAK,GAAIpL,EAAGoL,EAAK,GAAI,IAGnC,GAAIY,EACF,MAAO,CAAEnW,OAAQsW,EAAajB,MAAOsB,GAGvC,MAAMG,EAAY,GAClB,IAAK,MAAO7T,EAAG8T,KAAOT,EAAYU,UAAW,CAI3C,MAAMzC,EAAQuC,EAAUvM,WACrBpH,GAAUA,EAAM,KAAO4T,EAAG,IAAM5T,EAAM,KAAO4T,EAAG,IAAM5T,EAAM,KAAO4T,EAAG,KAGzE,GAAIxC,GAAS,EACXoC,EAAWhQ,KAAKyO,IACVA,EAAKlL,IAAMjH,IACbmS,EAAKlL,EAAIqK,GAEPa,EAAKjL,IAAMlH,IACbmS,EAAKjL,EAAIoK,GAEJa,SAEJ,CACL,MAAM6B,EAAWH,EAAU5T,OAC3B4T,EAAUpG,KAAKqG,GACfJ,EAAWhQ,KAAKyO,IACVA,EAAKlL,IAAMjH,IACbmS,EAAKlL,EAAI+M,GAEP7B,EAAKjL,IAAMlH,IACbmS,EAAKjL,EAAI8M,GAEJ7B,IAEX,CACF,CAIA,MAAO,CAAEpV,OAAQ8W,EAAWzB,MAFXsB,EAAW3E,QAAQoD,GAASA,EAAKlL,IAAMkL,EAAKjL,IAG/D,CCqFA,SAAiB+M,oBAzEV,SAA6BC,EAAUnX,EAAQoX,GAAS,GAI7D,MAAMC,EAAcF,EAASnF,QAC1BqC,GAA6B,kBAAjBA,EAAQtI,OAIjBuL,EAAiBH,EAASnF,QAC7BqC,GAA6B,kBAAjBA,EAAQtI,OAIjBwL,EAAmB,GACzB,IAAIC,EAAsB,GAuD1B,OAtDAF,EAAejL,SAAQ,CAACgI,EAASE,KAC/B,MAAMkD,EAAQ,GAGdH,EAAejL,SAAQ,CAACqL,EAAUC,KAC5BpD,GAASoD,GAhDnB,SAAuBC,EAAcC,EAAc7X,GACjD,MAAM8X,EAAW,GACjBF,EAAatC,cAAcjJ,SAASlJ,IAClC2U,EAASpH,KAAK,CAAC1Q,EAAOmD,GAAO,GAAInD,EAAOmD,GAAO,IAAI,IAGrD,IAAI4U,EAAoB,EAaxB,OAZAF,EAAavC,cAAcjJ,SAASlJ,IAClC,MAAM2S,EArCsB,EAAC3S,EAAO2U,KAGtC,MAAM9I,EAAI7L,EAAM,GACV6U,EAAI7U,EAAM,GAEhB,IAAI8U,GAAS,EACb,IAAK,IAAIhV,EAAI,EAAGiV,EAAIJ,EAAS5U,OAAS,EAAGD,EAAI6U,EAAS5U,OAAQgV,EAAIjV,IAAK,CACrE,MAAMkV,EAAKL,EAAS7U,GAAG,GACrBmV,EAAKN,EAAS7U,GAAG,GACboV,EAAKP,EAASI,GAAG,GACrBI,EAAKR,EAASI,GAAG,GAGjBE,EAAKJ,GAAKM,EAAKN,GAAKhJ,GAAMqJ,EAAKF,IAAOH,EAAII,IAAQE,EAAKF,GAAMD,IAE7DF,GAAUA,EAEd,CAEA,OAAOA,CAAM,EAiBIM,CACb,CAACvY,EAAOmD,GAAO,GAAInD,EAAOmD,GAAO,IACjC2U,GAIGhC,GACHiC,GACF,IAG2B,IAAtBA,CACT,CA8BYS,CAAcnE,EAASqD,EAAU1X,IACnCyX,EAAM/G,KAAKiH,EAEf,IAIEF,EAAMvU,OAAS,EAEjBqU,EAAiB7G,KAAK,CACpB2D,UACAoD,UAIFD,EAAoB9G,KAAK6D,EAC3B,IAGE6C,IAEFG,EAAiBlL,SAASoM,IAExBA,EAAepE,QAAQtI,KAAO,mBAC9BsL,EAAY3G,KAAK+H,EAAepE,SAEhCoE,EAAehB,MAAMpL,SAASqM,IAG5BpB,EAAeoB,GAAW3M,KAAO,mBACjCsL,EAAY3G,KAAK4G,EAAeoB,IAGhClB,EAAsBA,EAAoBxF,QAAQ2G,GACzCA,IAAiBD,GACxB,GACF,IAIJlB,EAAoBnL,SAASsM,IAC3BtB,EAAY3G,KAAK4G,EAAeqB,GAAc,KAM3CtB,CACT,G,0DCzIA,MAAM,SAAEuB,GAAaC,EAAA,QAErB,SAASC,GAAgC,cAAEC,IACzC,MAAM,mBAAEnG,EAAkB,SAAEoG,EAAW,CAAC,EAAG,IAAOD,GAC1C1U,SAAU4U,GAAgBrG,EAAmBgG,GAG/CM,EAAM,QAAiB1U,UAAUyU,GACvC,IAAKC,EAEH,YADAC,QAAQC,KAAK,uBAAuBH,KAItC,MAAMI,EAAYH,EAAIrO,WAAW,GAI3ByO,EAAUJ,EAAIK,UAAUC,eAAeC,aAAaC,UACpDC,EAAiBT,EAAIrO,WAAW,GAAKqO,EAAIrO,WAAW,GAE1D,IAAK,IAAI+O,EAAI,EAAGA,EAAIP,EAAWO,IAC7B,IAAK,IAAI5B,EAAI,EAAGA,EAAIkB,EAAIrO,WAAW,GAAImN,IAAK,CAC1C,MAAMzD,EAAQyD,EAAIkB,EAAIrO,WAAW,GAAK+O,EAAID,EAC1CL,EAAQ/E,GAAS,EACjB+E,EAAQ/E,EAAQ2E,EAAIrO,WAAW,GAAK,GAAK,CAC3C,CAMF,MAAMgP,EAAc,IAEd,oBAAE5R,GAAwBiR,EAAIxZ,SAE9Boa,EAAcd,EAAS9V,OAC7B,IAAK,IAAI6W,EAAW,EAAGA,EAAWD,EAAaC,IAAY,CACzD,MAAMC,EAAUhB,EAASe,GAGzB,IAAKC,EACH,SAGF,MAAMC,EAAgB,GAChBC,EAAU,sBAAyB,CACvCC,KAAM,UACNC,mBAAoB,EACpB5G,KAAMmG,EAAiBN,EACvBgB,SAAU,gBAEN,wBAAEC,GAA4BN,EACpC,IAAK,IAAIO,EAAa,EAAGA,EAAalB,EAAWkB,IAAc,CAE7D,GACEC,EAAuBD,EAAYjB,EAASK,EAAgBI,GAE5D,SAEF,MAAMU,EAAaF,EAAaZ,EAEhC,IAEE,IAAK,IAAI1W,EAAI,EAAGA,EAAI0W,EAAgB1W,IAAK,CACvC,MAAMyX,EAAQpB,EAAQrW,EAAIwX,GACtBC,IAAUX,GAAYO,GAAyBK,IAAID,GACpDR,EAAgBU,SAAS3X,EAAIwX,EAAY,GAEzCP,EAAgBU,SAAS3X,EAAG,EAEjC,CAEA,MAAM4X,EAAW,iBAAoC,CACnDxX,MAAOkX,IAKHO,EAAgB,mBAEtBA,EAAcC,YAAY7B,EAAIK,WAC9BuB,EAActB,eAAewB,WAAWd,GAGxCW,EAASI,aAAaH,GACtB,MAAMI,EAAU,CAAC,GACjBL,EAASM,iBAAiBD,GAC1BL,EAASO,gBAAe,GAGxB,MAGMC,EAAapF,EAHF4E,EAASS,iBAI1B,GAAID,EAAWrb,QAAQkD,OAAQ,CAC7B,MAAMiU,EAAWnB,EAA2BqF,EAAWhG,OAEvD4E,EAAcvJ,KAAK,CACjByG,WACAjB,SAAUmF,EACVE,YAAahB,EAAa,EAC1BA,aACAtS,uBAEJ,CACF,CAAE,MAAOuT,GACPrC,QAAQC,KAAKmB,GACbpB,QAAQC,KAAKoC,EACf,CACF,CAEA,MAAM9b,EAAW,CACfuI,uBAGIwT,EAAa,CACjB/a,MAAOsZ,EAAQtZ,MACfkD,MAAOoW,EAAQpW,MACflE,WACAua,iBAGFJ,EAAYnJ,KAAK+K,EACnB,CAEA,OAAO5B,CACT,CAEA,SAASW,EAAuBD,EAAYjB,EAASK,EAAgBI,GACnE,MAAM2B,EAAWnB,EAAaZ,EACxBgC,EAASD,EAAW/B,EAE1B,IAAK,IAAI1W,EAAIyY,EAAUzY,EAAI0Y,EAAQ1Y,IACjC,GAAIqW,EAAQrW,KAAO8W,EACjB,OAAO,EAIX,OAAO,CACT,C,eCxIA,MAAM6B,SACG,KAAAC,WAAkC,CAAC,CAAE,CAE5C,WAAA3a,GAEA,CAEA,cAAO4a,CAAQxc,EAAYiV,EAAOwH,IAjBpC,SAA4Bzc,GAC1B,IAAKA,GAAYO,KACf,MAAM,IAAI6I,MAAM,sBAGlB,IAAKpJ,EAAWI,UAAYJ,EAAWI,SAASsc,iBAC9C,MAAM,IAAItT,MAAM,+CAEpB,CAUIuT,CAAmB3c,GAEnB,MAAM,SAAEK,GAAaL,EAAWI,SAC1Bwc,EAAYN,EAAsBC,WAAWlc,GAEnD,IAAKuc,EACH,MAAM,IAAIxT,MACR,sBAAsB/I,mCAO1B,MAAMwc,EAAkBD,EAAUE,mBAChC9c,EACAyc,GAUF,MAAO,CACLM,oBAAqB9H,EAAQ,EAC7B+H,gBARY,CACZxS,KAAKyS,MAAsB,IAAhBzS,KAAK0S,UAChB1S,KAAKyS,MAAsB,IAAhBzS,KAAK0S,UAChB1S,KAAKyS,MAAsB,IAAhBzS,KAAK0S,WAMhBL,kBAEJ,CAEA,eAAOM,CAASP,GACdN,EAAsBC,WAAWK,EAAUvc,UAAYuc,CACzD,EAGFN,EAAsBa,SAASC,EAAA,GAE/B,U,eClDe,SAASC,EACtBrd,GAIA,OAF4BA,EAAWsd,qBAAuB,IAEnCjW,KACxBuC,IAAS,QAAcA,GAA2BrJ,KAAKwU,QAAQZ,UAEpE,CCRe,SAASoJ,EACtBvd,EACAuB,GAEA,MAAMic,EAAoBH,EAAyBrd,GAC7Cyd,EAAqB,GAgB3B,OAdAD,EAAkBzQ,SAAS2Q,IACzB,MAAMC,EAAYD,EAAiB9Z,OAG7Bga,EAAoC,IAAIjd,MAAMgd,GAGpD,IAAK,IAAIha,EAAI,EAAGA,EAAIga,EAAWha,IAC7Bia,EAAkBja,GAAKpC,EAASmC,cAAcga,EAAiB/Z,IAGjE8Z,EAAmBrM,KAAKwM,EAAkB,IAGrCH,CACT,C,yBCtBe,SAASI,EACtBC,EACAC,GAEAC,EAAA,EAAqBC,oBAAoBH,EAAyBC,EACpE,C,uLCQe,SAASG,EACtBle,EACAme,EAKAC,EAIA5V,GAOA,MAAM,cAAE6V,EAAa,cAAE3a,GAAkB0a,GACnC,KAAE7d,GAASP,GACX,uBAAEse,GAA2BH,EACnC,IAAMzd,OAAQyT,GAAagK,EAGvB3V,GAAS+V,UAAUC,UACrBrK,EAAW,oBACTgK,EAAazd,OACb8H,GAAS+V,UAAUE,UAIvB,IAAI,OAAErK,GAAW+J,EACjB,MAAMR,EAAYxJ,EAASvQ,OACrB8a,EAAsB,IAAI/d,MAAMgd,GAChCgB,EACJ,+BAAkCxK,GAC9ByK,GAAmB,QAAoB5e,GAE7C,QAAe4C,IAAXwR,EAAsB,CACxB,IAAIyK,GAAqB,EAGzB,GAAI1K,EAASvQ,OAAS,EAAG,CACvB,MAAMkb,EAAkB,+BACtB3K,EAAS,GACTA,EAASwJ,EAAY,IAGvBkB,EAAqB,oBAAgB,EAAGC,EAC1C,CAEA1K,EAASyK,CACX,CAGA,IAAIE,EAAmBH,GAC+B,EAAlDA,EAAiBre,KAAKwU,QAAQgK,iBAC9BT,OAEqB1b,IAArBmc,IACFA,EAAmBJ,GAGjBI,IAAqBJ,GACvBxK,EAASxD,UAGX,MAAMqO,EAAeze,EAAKE,QAAQC,OAAO2G,KAAK4E,GAAMvI,EAAcuI,KAElE,GAAI+S,EAAapb,OAAS,EAAG,CAEzB,+BAAkCob,KAEGD,GACrCxe,EAAKE,QAAQC,OAAOiQ,SAExB,CAEA,IAAK,IAAIhN,EAAI,EAAGA,EAAIga,EAAWha,IAC7B+a,EAAoB/a,GAAK0a,EAAclK,EAASxQ,IAGlDpD,EAAKwU,QAAQZ,SAAWuK,EACxBne,EAAKwU,QAAQX,OAASA,EACtB7T,EAAKwU,QAAQgK,iBAAmBA,GAEhC,QAAqB/e,EACvB,C,kDC0GA,QA3JA,SAAkBif,EAAMC,EAAM1W,GAC5B,IAAI2W,EAAUC,EAAUC,EAAS7I,EAAQ8I,EAASC,EAE9CC,EAAiB,EACjBC,GAAU,EACVC,GAAS,EACTC,GAAW,EAGf,MAAMC,GACHV,GAAiB,IAATA,GAAsD,mBAAjCvN,OAAOkO,sBAEvC,GAAoB,mBAATZ,EACT,MAAM,IAAIa,UAAU,uBAUtB,SAASC,EAAWC,GAClB,MAAMC,EAAOd,EACPe,EAAUd,EAMhB,OAJAD,EAAWC,OAAWxc,EACtB4c,EAAiBQ,EACjBxJ,EAASyI,EAAKkB,MAAMD,EAASD,GAEtBzJ,CACT,CAEA,SAAS4J,EAAWC,EAAanB,GAC/B,OAAIU,EACKjO,OAAOkO,sBAAsBQ,GAG/BzO,WAAWyO,EAAanB,EACjC,CA6BA,SAASoB,EAAaN,GACpB,MAAMO,EAAoBP,EAAOT,EAMjC,YACmB3c,IAAjB2c,GACAgB,GAAqBrB,GACrBqB,EAAoB,GACnBb,GATyBM,EAAOR,GASCH,CAEtC,CAEA,SAASmB,IACP,MAAMR,EAAOS,KAAKC,MAElB,GAAIJ,EAAaN,GACf,OAAOW,EAAaX,GAGtBV,EAAUc,EAAWI,EAhCvB,SAAuBR,GACrB,MACMY,EAAsBZ,EAAOR,EAC7BqB,EAAc3B,GAFMc,EAAOT,GAIjC,OAAOG,EACHlV,KAAKU,IAAI2V,EAAaxB,EAAUuB,GAChCC,CACN,CAwBqCC,CAAcd,GACnD,CAEA,SAASW,EAAaX,GAKpB,OAJAV,OAAU1c,EAIN+c,GAAYR,EACPY,EAAWC,IAEpBb,EAAWC,OAAWxc,EAEf4T,EACT,CAkBA,SAAShJ,KAAayS,GACpB,MAAMD,EAAOS,KAAKC,MACZK,EAAaT,EAAaN,GAMhC,GAJAb,EAAWc,EACXb,EAAW9e,KACXif,EAAeS,EAEXe,EAAY,CACd,QAAgBne,IAAZ0c,EACF,OApFN,SAAqBU,GAOnB,OALAR,EAAiBQ,EAEjBV,EAAUc,EAAWI,EAActB,GAG5BO,EAAUM,EAAWC,GAAQxJ,CACtC,CA4EawK,CAAYzB,GAErB,GAAIG,EAIF,OAFAJ,EAAUc,EAAWI,EAActB,GAE5Ba,EAAWR,EAEtB,CAKA,YAJgB3c,IAAZ0c,IACFA,EAAUc,EAAWI,EAActB,IAG9B1I,CACT,CAKA,OAzIA0I,EAAO3X,OAAO2X,IAAS,GACnB,OAAS1W,KACXiX,EAAUwB,QAAQzY,EAAQiX,SAC1BC,EAAS,YAAalX,EACtB6W,EAAUK,EAASlV,KAAKW,IAAI5D,OAAOiB,EAAQ6W,UAAY,EAAGH,GAAQG,EAClEM,EAAW,aAAcnX,EAAUyY,QAAQzY,EAAQmX,UAAYA,GAgIjEnS,EAAU0T,OAzCV,gBACkBte,IAAZ0c,GAlEN,SAAqBpP,GACnB,GAAI0P,EACF,OAAOjO,OAAOwP,qBAAqBjR,GAErCiC,aAAajC,EACf,CA8DIkR,CAAY9B,GAEdE,EAAiB,EACjBL,EAAWI,EAAeH,EAAWE,OAAU1c,CACjD,EAoCA4K,EAAU6T,MAlCV,WACE,YAAmBze,IAAZ0c,EAAwB9I,EAASmK,EAAaF,KAAKC,MAC5D,EAiCAlT,EAAU8T,QA/BV,WACE,YAAmB1e,IAAZ0c,CACT,EA+BO9R,CACT,C,kBC7Me,SAAS+T,EACtBC,GAEA,MAAMC,EAaR,SAA2BC,GACzB,MAAMC,EAAqB,CAACD,EAAa,GAAIA,EAAa,IAAI/W,KAAKiX,GAC7DC,EAAqB,CAACH,EAAa,GAAIA,EAAa,IAAI/W,KAAKmX,GAC7DC,EAAQJ,EAAmBA,EAAmB/d,OAAS,GACvDoe,EAAMH,EAAmB,GACzBI,EAASJ,EAAmBA,EAAmBje,OAAS,GAE9D,MAAO,CACLoe,MACAC,SACAF,SAGF,SAASH,EAAUhX,EAAGC,GACpB,OAAOD,EAAE,GAAKC,EAAE,IAAM,EAAI,CAC5B,CACA,SAASiX,EAAUlX,EAAGC,GACpB,OAAOD,EAAE,GAAKC,EAAE,IAAM,EAAI,CAC5B,CACF,CAhCkBqX,CAAkBV,GAC5BW,GAAWV,EAAQO,IAAI,GAAKP,EAAQQ,OAAO,IAAM,EAGvD,MAFoC,CAACR,EAAQM,MAAM,GAAII,EAGzD,C,uKCsMA,QAvMA,SACEC,EACA5Z,GASA,MAAM6Z,EAAS7Z,EAAQ8Z,cAAgB,IAClC3hB,MAAMyhB,EAAcpT,eAAeuT,QAMxC,IAAK/Z,EAAQga,eAAiBha,EAAQia,gBACpC,MAAM,IAAIrZ,MACR,6DAIJ,GAAIZ,EAAQga,cAAgBha,EAAQia,gBAClC,MAAM,IAAIrZ,MAAM,2DAGlB,GAAIZ,EAAQga,aAAc,CACxB,MAAME,EAAqB,EAAAzd,MAAMC,UAAUsD,EAAQga,eAE5CG,EAAYC,GAiDvB,SAA+BP,EAAQD,EAAeM,GACpD,MAAQzI,UAAW4I,GAAkBH,EAC/BI,EAAgBJ,EAAmBK,gBAEnCC,EAAMF,EAAclf,OAGpBqf,EAAsB,GAC5BA,EAAoBrf,OAASof,EAC7B,MAAMJ,EAAY,GAEZrX,EAAamX,EAAmBnX,WAGtC,IAAI2X,EAAY,EAChB,IAAK,IAAIvf,EAAI,EAAGqf,EAAMF,EAAclf,OAAQD,EAAIqf,EAAKrf,IAC1B,IAArBmf,EAAcnf,KAChBif,EAAUxR,KAAK,CACbzN,EAAI4H,EAAW,GACff,KAAKyS,MAAOtZ,EAAI4H,EAAW,GAAMA,EAAW,IAC5Cf,KAAKyS,MAAMtZ,GAAK4H,EAAW,GAAKA,EAAW,OAE7C0X,EAAoBC,KAAevf,GAKvCsf,EAAoBrf,OAASsf,EAE7B,MAAMC,EAA+Bf,EAAcgB,sBAC7CC,EAAS,GACTC,EACJH,EAA6B,GAAGvf,SAAWof,GAC3CO,KAAKC,UAAUpB,EAAcqB,WAC3BF,KAAKC,UAAUd,EAAmBe,SAItC,GAAIH,EAAc,CAChB,IAAK,IAAI3f,EAAI,EAAGA,EAAIsf,EAAoBrf,OAAQD,IAAK,CACnD,MAAM+f,EAAc,GACpBrB,EAAOtV,SAAS4W,IACd,MAAMC,EAAmBT,EAA6BQ,GACtDD,EAAYtS,KAAKwS,EAAiBX,EAAoBtf,IAAI,IAE5D0f,EAAOjS,KAAKsS,EACd,CAEA,MAAO,CAACL,EAAQT,EAClB,CAMA,MAAMiB,EAAW,EACfC,SAAUC,EACV3I,MAAO4I,EACPC,SAAUC,MAGV,GAAiB,IAAbF,EAEF,OAMF,MAAMG,GAAmB,QACvB/B,EAAcnI,UACdmI,EAAc7W,WACd6W,EAAcqB,QACdM,GAKF,IAAIK,EAAQ,EACZ,MAAMC,EAAc,IAAI3W,IAGxB2U,EAAOtV,SAAS4W,GAAUU,EAAY3S,IAAIiS,EAAO,KAEjD,MAAMW,EAAkB,EAAGrP,YACzB,IAAK,IAAItR,EAAI,EAAGA,EAAI0e,EAAOze,OAAQD,IAAK,CACtC,MAAMyX,EAAQ+H,EAA6Bxf,GAAGsR,GACxC0O,EAAQtB,EAAO1e,GACrB0gB,EAAY3S,IAAIiS,EAAOU,EAAY9R,IAAIoR,GAASvI,EAClD,CACAgJ,GAAO,GAGT,EAAAG,EAAA,GACEnC,EAAcnI,WACd,KAAM,GACNqK,EACAH,GAIF,MAAMK,EAAgB,GACtBH,EAAYtX,SAASmE,IACnBsT,EAAcpT,KAAKF,EAAMkT,EAAM,IAGjCxB,EAAUxR,KAAK8S,GACfb,EAAOjS,KAAKoT,EAAc,EAS5B,OAFA,EAAAD,EAAA,GAAqB1B,GAAe,KAAM,GAAMgB,GAEzC,CAACR,EAAQT,EAClB,CAtKoC6B,CAC9BpC,EACAD,EACAM,GAGF,MAAO,CAACC,EAAYC,EACtB,CAEA,GAAIpa,EAAQia,gBAAiB,CAC3B,MAAME,EAYV,SAAqCN,EAAQqC,EAAY1f,GACvD,MAAM,WAAEuG,EAAU,UAAE0O,GAAcjV,EAC5BiQ,EAAQgF,EAAU0K,aAAaD,GAMrC,GAJAzP,EAAM,GAAKzK,KAAKyS,MAAMhI,EAAM,IAC5BA,EAAM,GAAKzK,KAAKyS,MAAMhI,EAAM,IAC5BA,EAAM,GAAKzK,KAAKyS,MAAMhI,EAAM,KAEvB,EAAArM,UAAA,sBAAgCqM,EAAO1J,GAC1C,MAAM,IAAInC,MAAM,kBAIlB,MAAMwb,EAAYrZ,EAAW,GACvBsZ,EAAYtZ,EAAW,GAAKA,EAAW,GACvCuZ,EAAgB9f,EAAOoe,sBACvBhI,EAAQ,GAQd,OANAiH,EAAOtV,SAAS4W,IACd,MAAMC,EAAmBkB,EAAcnB,GACjCoB,EAAc9P,EAAM,GAAK4P,EAAY5P,EAAM,GAAK2P,EAAY3P,EAAM,GACxEmG,EAAMhK,KAAKwS,EAAiBmB,GAAa,IAGpC3J,CACT,CArCuB4J,CACjB3C,EACA7Z,EAAQia,gBACRL,GAGF,OAAOO,CACT,CAGF,ECAA,QArDA,SACEP,EACA6C,EACA3C,GAGA,MAAMD,EAASC,GAAgB,IAAI3hB,MAAMyhB,EAAcpT,eAAeuT,QAChE2C,EAAY7C,EAAOze,OAEzB,GAAIye,EAAOze,QAAU,EACnB,MAAM,IAAIwF,MAAM,0CAIlB,MAAM+b,EAAc/C,EAAcgB,sBAE5BgC,EAAcD,EAAY,GAAGvhB,OAC7ByhB,EAAa,IAAIC,aAAaF,GAEpC,GAAIH,IAAc,EAAAvY,MAAA,oBAA0B6Y,IAAK,CAC/C,IAAK,IAAI5hB,EAAI,EAAGA,EAAIuhB,EAAWvhB,IAAK,CAClC,MAAM6hB,EAAeL,EAAY9C,EAAO1e,IACxC,IAAK,IAAIiV,EAAI,EAAGA,EAAIwM,EAAaxM,IAC/ByM,EAAWzM,IAAM4M,EAAa5M,EAElC,CACA,OAAOyM,CACT,CAEA,GAAIJ,IAAc,EAAAvY,MAAA,oBAA0B+Y,SAAU,CACpD,GAAIpD,EAAOze,OAAS,EAClB,MAAM,IAAIwF,MAAM,sDAElB,IAAK,IAAIwP,EAAI,EAAGA,EAAIwM,EAAaxM,IAC/ByM,EAAWzM,IAAMuM,EAAY9C,EAAO,IAAIzJ,GAAKuM,EAAY9C,EAAO,IAAIzJ,GAEtE,OAAOyM,CACT,CAEA,GAAIJ,IAAc,EAAAvY,MAAA,oBAA0BgZ,QAAS,CACnD,IAAK,IAAI/hB,EAAI,EAAGA,EAAIuhB,EAAWvhB,IAAK,CAClC,MAAM6hB,EAAeL,EAAY9C,EAAO1e,IACxC,IAAK,IAAIiV,EAAI,EAAGA,EAAIwM,EAAaxM,IAC/ByM,EAAWzM,IAAM4M,EAAa5M,EAElC,CACA,IAAK,IAAI+M,EAAI,EAAGA,EAAIP,EAAaO,IAC/BN,EAAWM,GAAKN,EAAWM,GAAKT,EAElC,OAAOG,CACT,CACF,C,gFChDA,SAASO,EACPjkB,EACAkkB,EACAxiB,EAAY,GAIZ,MAAMC,GAAiB,IAAAC,mBAAkB5B,GACzC,IAAK2B,EACH,MAAM,IAAI8F,MAAM,oDAGlB,OAAO0c,EACLxiB,EACAuiB,EACAxiB,EAEJ,CAYA,SAASyiB,EACPxiB,EACAO,EACAR,GAIA,MAAM,kBAAE0iB,EAAiB,WAAE1Y,GAAe/J,EACpC0iB,EAAY,0BAChB3Y,EACA0Y,GAGF,IAAKC,EACH,OAAO,KAGT,MAAQC,eAAgBC,GAAUF,EAClC,IAAK,MAAMnL,KAAQqL,EAAO,CACxB,MAAMC,EAAQC,EACZF,EAAMrL,GACNvX,EACAO,EACAR,GAEF,GAAI8iB,EACF,OAAOA,CAEX,CAEA,OAAO,IACT,CAcA,SAASC,EACPC,EACA/iB,EACAO,EACAR,GAKA,MAAM,SAAE9B,GAAa+B,EAEfgjB,GAAc,IAAAC,gBACjBF,EAAKzkB,YAAgCvB,SACtCkB,GAAUI,SAEN6kB,EAAYjlB,GAAUklB,sBAC5B,GAAIH,GAAa1iB,OAAQ,CACvB,MAAM,QAAEjC,GAAY2B,EAAe/B,SACnC,IAAK,MAAMvB,KAAcsmB,EAAa,CACpC,MAAMte,EAAoBhI,EAAWI,UAAU4H,kBAC/C,KACGwe,GAAaxe,GAAqBwe,IAAcxe,IAChDqe,EAAKpgB,mBAMNogB,EAAKpgB,gBAAgBtE,EAAS3B,EAAY6D,EAAOR,EAAW,KAC5DgjB,EAAKjjB,wBAAwBzB,EAAS3B,EAAY6D,EAAOR,IAEzD,OAAOrD,CAEX,CACF,CACA,OAAO,IACT,C,qEC7HA,MAAM,iBAAE0mB,GAAqB,EAAAha,MACvBia,EAAc,KAEdC,EAA8B,CAClC,GAGIC,EAA2B,CAC/B,OAGIC,EAA0B,CAC9B,OAGIC,EAAe,CACnB,EAAG,KACH,EAAG,WAICC,EAAS,IASTC,EAAmC,CAACC,EAAOzmB,KAC/C,MAAM,YAAE0mB,EAAW,gBAAEC,GAAoBF,EACzC,IAAIG,EAAQD,EAAkB,KAAOT,EACjCW,EAAYD,EAAQL,EACpBpa,EAAQ,EACR2a,EAAkB,GAEtB,IACGJ,IACCA,EAAY1a,OAAS0a,EAAYK,4BAEnC,MAAO,CAAEH,QAAOC,YAAW1a,SAG7B,GAAIua,EAAY1a,OAASia,EAAiBe,aACxC,MAAO,CAAEJ,MAAOV,EAAaW,UAAWX,EAAcK,EAAQpa,SAGhE,GAAIua,EAAYK,4BAA6B,CAC3C,IAAIE,EAAaC,EACjB,GAAIhnB,MAAM8G,QAAQhH,IAA+B,IAAnBA,EAAQmD,QACnC8jB,EAAaC,GAAelnB,OACxB,GAAuB,mBAAZA,EAAwB,CACxC,MAAMC,EAASD,IACfinB,EAAchnB,EAAO,GACrBinB,EAAcjnB,EAAO,EACvB,CAEA,IAAIknB,EAAUT,EAAYK,4BAA4B9U,QACnDmV,GACCH,EAAY,IAAMG,EAAOC,qBACzBJ,EAAY,IAAMG,EAAOE,qBACzBL,EAAY,IAAMG,EAAOG,qBACzBN,EAAY,IAAMG,EAAOI,qBACzBN,EAAY,IAAME,EAAOC,qBACzBH,EAAY,IAAME,EAAOE,qBACzBJ,EAAY,IAAME,EAAOG,qBACzBL,EAAY,IAAME,EAAOI,sBAK7B,IAAKL,GAAShkB,OACZ,MAAO,CAAEyjB,QAAOC,YAAW1a,SAc7B,GARAgb,EAAUA,EAAQlV,QACfmV,GACCjB,EAA4B5Z,SAAS6a,EAAOK,iBAC5CrB,EAAyB7Z,SACvB,GAAG6a,EAAOM,2BAA2BN,EAAOO,8BAI7CR,EAAQhkB,OACX,MAAO,CAAEyjB,MAAOV,EAAaW,UAAWX,EAAcK,EAAQpa,SAIhE,MAAMib,EAASD,EAAQ,GAEjBS,EAAiB7d,KAAKC,IAAIod,EAAOQ,gBACjCC,EAAiB9d,KAAKC,IAAIod,EAAOS,gBAYvC,IAN4B,EAAA1f,UAAA,QAC1Byf,EACAC,EAnFM,MAkGN,MAAO,CAAEjB,MAAOV,EAAaW,UAAWX,EAAcK,EAAQpa,SAT9DA,EAAQ,GAAsB,GAAjByb,GACbd,EAAkB,YAClBF,EAAQ,KACRC,EAAY,KAQhB,MAAWH,EAAYva,QACrBA,EAAQua,EAAYva,OAetB,MAXc,CACZ8Z,EAAiB6B,KACjB7B,EAAiB/Z,KACjB+Z,EAAiB8B,MACjB9B,EAAiB+B,YAGTzb,SAASma,GAAa1a,QAC9B8a,EAAkBJ,EAAY1a,MAGzB,CACL4a,MAAOA,GAASE,EAAkB,IAAIA,IAAoB,IAC1DD,UAAWA,GAAaC,EAAkB,IAAIA,IAAoB,IAClE3a,QACD,EAGG8b,EAAkC,CAACxB,EAAOzmB,KAC9C,MAAOkoB,GAAcloB,GACf,YAAE0mB,GAAgBD,EACxB,IAAIG,EAAQ,CAAC,OACThE,EAAS,CAAC,MACVkE,EAAkB,GAEtB,IACGJ,IACCA,EAAY1a,OAAS0a,EAAYK,4BAEnC,MAAO,CAAEH,QAAOhE,UAIlB,GAAI8D,EAAYK,4BAA6B,CAE3C,MAAMoB,EACJzB,EAAYK,4BAA4B9U,QACrCmV,GACCjB,EAA4B5Z,SAAS6a,EAAOK,iBAC5CpB,EAAwB9Z,SACtB,GAAG6a,EAAOM,2BAA2BN,EAAOO,6BAIpD,IAAKQ,GAA0BhlB,OAC7B,MAAO,CAAEyjB,QAAOhE,UAGlB,MAAMwE,EAASe,EAAyBpf,MACrCqe,GACCc,EAAW,IAAMd,EAAOC,qBACxBa,EAAW,IAAMd,EAAOE,qBACxBY,EAAW,IAAMd,EAAOG,qBACxBW,EAAW,IAAMd,EAAOI,sBAG5B,IAAKJ,EACH,MAAO,CAAER,QAAOhE,UAKlB,MAAM,iBAAEwF,EAAmB,EAAC,iBAAEC,EAAmB,GAAMjB,GACjD,eAAEQ,EAAc,eAAEC,GAAmBT,EAErCkB,GACHJ,EAAW,GAAKd,EAAOG,oBAAsBc,GAC9CR,EAMFf,EAAkB,YAClBlE,EAAS,EAJNsF,EAAW,GAAKd,EAAOC,oBAAsBe,GAC9CR,EAGgBU,GAClB1B,EAAQ,CACNN,EAAac,EAAOM,yBACpBpB,EAAac,EAAOO,yBAExB,CAEA,MAAO,CACLf,QACAhE,SACAkE,kBACD,EASGyB,EAAuB9B,GAAUA,EAAMC,aAAa8B,QAAU,C,wECrNpE,MAAM,sBAAEC,GAA0B,YAiBlC,SAASC,EACPC,EACAnP,EACA1Y,GAQA,MAAO0gB,EAAQD,GAAOoH,EAGhBC,EAAc,iBACjBpH,EAAO,GAAKD,EAAI,IAAM,GACtBC,EAAO,GAAKD,EAAI,IAAM,GACtBC,EAAO,GAAKD,EAAI,IAAM,GAInBsH,EAAc,cAAcrH,EAAQD,GAAO,EAEjD,IAAKzgB,EACH,MAAM,IAAI6H,MACR,gEAIJ,MAAM,UAAE0B,EAAS,aAAEye,EAAY,iBAAEC,GAkBnC,SACEvP,EACA1Y,EACA6nB,EACAC,EACAC,GAEA,MAAOrH,EAAQD,GAAOoH,EAEhB7d,EAAa0O,EAAUwP,gBAEvBna,EAAS/N,EAASgO,YAKlBma,EAAS,gBACbpa,EAAOoa,OAAO,GACdpa,EAAOoa,OAAO,GACdpa,EAAOoa,OAAO,IAEVhhB,EAAkB,gBACtB4G,EAAO5G,gBAAgB,GACvB4G,EAAO5G,gBAAgB,GACvB4G,EAAO5G,gBAAgB,IAEnBihB,EAAY,cAElB,WAAWA,EAAWD,EAAQhhB,GAQ9B,MAAM6gB,EAAe,cACfC,EAAmB,cAEzB,iBAAiBD,EAAcvH,EAAKtZ,EAAiB4gB,GACrD,iBAAiBE,EAAkBvH,EAAQvZ,GAAkB4gB,GAG7D,iBAAiBC,EAAcA,EAAcI,GAAYL,GACzD,iBAAiBE,EAAkBA,EAAkBG,EAAWL,GAMhE,MAAMM,EAAaV,EACjBjP,EACAsP,GAEIM,EAAiBX,EACrBjP,EACAuP,GAGIM,EAAYV,EAAa/hB,KAAK4E,GAClCid,EAAsBjP,EAAWhO,KAI7BnB,GAAY,IAAAoB,8BAChB,CAAC0d,EAAYC,KAAmBC,GAChCve,GAGF,MAAO,CAAET,YAAWye,eAAcC,mBACpC,CAvFIO,CACE9P,EACA1Y,EACA6nB,EACAC,EACAC,GAGJ,MAAO,CACLxe,YACAue,YAAaA,EACbC,cACAC,aAAcA,EACdC,iBAAkBA,EAEtB,C,kDCzDe,SAASQ,EACtBhqB,GAEA,MAAMiqB,GAAY,OAA0BjqB,GAE5C,OAAOiqB,EAAUrmB,OAASqmB,EAAU,QAAKrnB,CAC3C,C,mCCSA,QANA,SAAkBwY,GAChB,MAAM3O,SAAc2O,EAEpB,OAAiB,OAAVA,IAA4B,WAAT3O,GAA8B,aAATA,EACjD,C,iBClBe,SAASyd,EACtBC,EACAC,GAEA,OACED,EAAME,MAAQD,EAAME,MACpBH,EAAMG,MAAQF,EAAMC,MACpBF,EAAMI,MAAQH,EAAMI,MACpBL,EAAMK,MAAQJ,EAAMG,IAExB,CCNe,SAASE,EACtBC,EACA7mB,GAEA,MAAM8mB,EAAYD,EAAKJ,KAAOI,EAAKL,KAC7BO,EAAaF,EAAKF,KAAOE,EAAKH,KAC9BM,EAAW,CAACF,EAAWC,GACvBE,EAA2B,CAC/BJ,EAAKL,KAAOM,EAAY,EACxBD,EAAKH,KAAOK,EAAa,GAKrBG,EAAkB,CACtBvgB,KAAKC,IAAI5G,EAAM,GAAKinB,EAAW,IAC/BtgB,KAAKC,IAAI5G,EAAM,GAAKinB,EAAW,KAI3BE,EAAKD,EAAgB,GAAmB,GAAdF,EAAS,GACnCI,EAAKF,EAAgB,GAAmB,GAAdF,EAAS,GAMzC,GAAIG,EAAK,GAAKC,EAAK,EACjB,OAAOD,EAAKA,EAAKC,EAAKA,EAGxB,MAAMC,EAAO1gB,KAAKW,IAAI6f,EAAI,GAAKxgB,KAAKW,IAAI8f,EAAI,GAE5C,OAAOC,EAAOA,CAChB,CChCe,SAASC,EACtBT,EACA7mB,GAEA,OAAO2G,KAAKgK,KAAKiW,EAAuBC,EAAM7mB,GAChD,C,mLCTA,QARA,SCEM,cAAEunB,GAAkB,EAAAxiB,UAEX,MAAMyiB,UAA6B,SACjC,KAAAlgB,IAAM,EAAEO,IAAU,QAClB,KAAAR,IAAM,CAACQ,IAAU,QACjB,KAAAwF,IAAM,CAAC,EAAG,QACV,KAAAkT,MAAQ,CAAE,QAIV,KAAAkH,QAAU,CAAC,EAAG,QACd,KAAAC,GAAK,CAAC,EAAG,QAGT,KAAAC,cAAgBJ,EAAcK,QAAQ,KAAM,CAEpD,gBAAOC,CAAUljB,GAClBA,EAAQmjB,qBACVN,EAAqBG,cAAgB,KAEzC,QAMO,KAAAI,cAAgB,EAAGxQ,MAAOyQ,EAAU/H,WAAW,SAElDnjB,MAAM8G,QAAQokB,IACdA,EAASjoB,OAAS,GACE,IAApBtD,KAAK6K,IAAIvH,SAETtD,KAAK6K,IAAIiG,KAAK9Q,KAAK6K,IAAI,GAAI7K,KAAK6K,IAAI,IACpC7K,KAAK4K,IAAIkG,KAAK9Q,KAAK4K,IAAI,GAAI5K,KAAK4K,IAAI,IACpC5K,KAAK4Q,IAAIE,KAAK9Q,KAAK4Q,IAAI,GAAI5Q,KAAK4Q,IAAI,IACpC5Q,KAAKgrB,QAAQla,KAAK,EAAG,GAErB9Q,KAAKirB,GAAGna,KAAK9Q,KAAKirB,GAAG,GAAIjrB,KAAKirB,GAAG,KAGnCjrB,KAAKkrB,eAAepa,KAAK0S,GACzB,MAAMgI,EAAWnrB,MAAM8G,QAAQokB,GAAYA,EAAW,CAACA,GAEvDvrB,KAAK8jB,OAAS,EACd9jB,KAAK6K,IAAI9D,KAAI,CAACC,EAAIykB,KAChB,MAAM3Q,EAAQ0Q,EAASC,GAEjBtd,EAAQ2M,EAAQ9a,KAAKgrB,QAAQS,GACnCzrB,KAAK4Q,IAAI6a,IAAQ3Q,EACjB9a,KAAKgrB,QAAQS,IAAQtd,EAAQnO,KAAK8jB,MAClC,MAAM4H,EAAS5Q,EAAQ9a,KAAKgrB,QAAQS,GACpCzrB,KAAKirB,GAAGQ,IAAQtd,EAAQud,EAGxB1rB,KAAK4K,IAAI6gB,GAAOvhB,KAAKU,IAAI5K,KAAK4K,IAAI6gB,GAAM3Q,GACxC9a,KAAK6K,IAAI4gB,GAAOvhB,KAAKW,IAAI7D,EAAI8T,EAAM,GACnC,CACF,QAWK,KAAA6Q,cAAiBzjB,IACtB,MAAM0jB,EAAO5rB,KAAK4Q,IAAI7J,KAAK6J,GAAQA,EAAM5Q,KAAK8jB,QACxC+H,EAAS7rB,KAAKirB,GAAGlkB,KAAK+kB,GAC1B5hB,KAAKgK,KAAK4X,EAAiB9rB,KAAK8jB,SAM5BiI,EAAO7jB,GAAS6jB,MAAQ,KAExBC,EAAyB,CAC7BnhB,IAAK,CACH0P,KAAM,MACNzZ,MAAO,YACPga,MAAOmR,EAAoBjsB,KAAK6K,KAChCkhB,QAEFnhB,IAAK,CACH2P,KAAM,MACNzZ,MAAO,YACPga,MAAOmR,EAAoBjsB,KAAK4K,KAChCmhB,QAEFH,KAAM,CACJrR,KAAM,OACNzZ,MAAO,aACPga,MAAOmR,EAAoBL,GAC3BG,QAEFF,OAAQ,CACNtR,KAAM,SACNzZ,MAAO,qBACPga,MAAOmR,EAAoBJ,GAC3BE,QAOFjI,MAAO,CACLvJ,KAAM,QACNzZ,MAAO,cACPga,MAAO9a,KAAK8jB,MACZiI,KAAM,MAERb,cAAelrB,KAAKkrB,cACpBgB,MAAO,IAqBT,OAnBAF,EAAME,MAAMpb,KACVkb,EAAMnhB,IACNmhB,EAAMJ,KACNI,EAAMH,OAGNG,EAAMH,OACNG,EAAMlI,OAGR9jB,KAAK6K,IAAM,EAAEO,KACbpL,KAAK4K,IAAM,CAACQ,KACZpL,KAAK4Q,IAAM,CAAC,GAEZ5Q,KAAKirB,GAAK,CAAC,GACXjrB,KAAKgrB,QAAU,CAAC,GAChBhrB,KAAK8jB,MAAQ,EACb9jB,KAAKkrB,cAAgBJ,EAAcK,QAAQ,MAEpCa,CAAK,CACZ,EAGJ,SAASC,EAAoB1Z,GAC3B,OAAsB,IAAfA,EAAIjP,OAAeiP,EAAI,GAAKA,CACrC,C,kBCxHe,SAAS4Z,EACtBC,EACA5I,EACA6I,EAAmB,CAAC,GAKpB,OAHKA,EAAQC,eACXC,EAA2BH,EAASC,GAE/BA,EAAQC,cAAc9I,EAC/B,C,oGAcA,MAAM+I,EAA6B,CAACH,EAASC,EAAmB,CAAC,KAC/D,MAAM,QAAEG,EAAO,QAAEC,EAAO,QAAEC,GAAYN,OAKX9pB,IAAzB+pB,EAAQM,mBACiBrqB,IAAzB+pB,EAAQO,mBACiBtqB,IAAzB+pB,EAAQQ,eAERR,EAAQM,aAA2B,IAAZH,EAAgB,EAAIA,GAAW,EAAI,EAC1DH,EAAQO,aAA2B,IAAZH,EAAgB,EAAIA,GAAW,EAAI,EAC1DJ,EAAQQ,aAA2B,IAAZH,EAAgB,EAAIA,GAAW,EAAI,GAG5D,MAAM,aAAEC,EAAY,aAAEC,EAAY,aAAEC,GAAiBR,GAC/C,OAAES,GAAWV,GACZW,EAASC,EAASC,GAAWH,EAuBpC,OArBAT,EAAQC,cAAiB9I,IAEvB,MAAMkH,EAAKlH,EAAS,GAAKuJ,EACzB,IAAI1U,EAASqS,EAAKA,EAAKiC,EACvB,GAAItU,EAAS,EACX,OAAO,EAGT,MAAMsS,EAAKnH,EAAS,GAAKwJ,EAEzB,GADA3U,GAAUsS,EAAKA,EAAKiC,EAChBvU,EAAS,EACX,OAAO,EAGT,MAAM6U,EAAK1J,EAAS,GAAKyJ,EAIzB,OAHA5U,GAAU6U,EAAKA,EAAKL,EAGbxU,GAAU,CAAC,EAGbgU,CAAO,EC1ED,SAASc,EACtBC,GAEA,MAAOzL,EAAQD,EAAK2L,EAAM5L,GAAS2L,EAKnC,MAAO,CAHuB,CAACC,EAAK,GAAI3L,EAAI,IACV,CAACD,EAAM,GAAIE,EAAO,IAGtD,C,oLCVe,SAAS2L,EACtBC,EACAC,EACAjqB,GAKA,IAAIkqB,EACJ,MAAMC,EAAkBC,EAAKpqB,MAAM4mB,uBAAuBoD,EAAWC,GAQrE,GAJID,EAAU,KAAOC,EAAQ,IAAMD,EAAU,KAAOC,EAAQ,KAC1DC,EAAeF,IAGZE,EAAc,CACjB,MAAMG,IACFrqB,EAAM,GAAKgqB,EAAU,KAAOC,EAAQ,GAAKD,EAAU,KAClDhqB,EAAM,GAAKgqB,EAAU,KAAOC,EAAQ,GAAKD,EAAU,KACtDG,EAGAD,EADEG,EAAa,EACAL,EACNK,EAAa,EACPJ,EAEA,CACbD,EAAU,GAAKK,GAAcJ,EAAQ,GAAKD,EAAU,IACpDA,EAAU,GAAKK,GAAcJ,EAAQ,GAAKD,EAAU,IAG1D,CAEA,MAAO,CACLhqB,MAAO,IAAIkqB,GACXC,gBAAiBC,EAAKpqB,MAAM4mB,uBAAuB5mB,EAAOkqB,GAE9D,CC3Ce,SAAStD,EACtBoD,EACAC,EACAjqB,GAEA,OAAO+pB,EAA2BC,EAAWC,EAASjqB,GAAOmqB,eAC/D,CCNe,SAAS7C,EACtB0C,EACAC,EACAjqB,GAEA,GAAyB,IAArBgqB,EAAUjqB,QAAmC,IAAnBkqB,EAAQlqB,QAAiC,IAAjBC,EAAMD,OAC1D,MAAMwF,MACJ,kEAIJ,OAAOoB,KAAKgK,KAAKiW,EAAuBoD,EAAWC,EAASjqB,GAC9D,CCpBA,SAASsqB,EAAKze,GACZ,MAAoB,iBAANA,EACVA,EACEA,EAAI,GACD,EACD,EACFA,GAAMA,EACN,EACA0e,IACFA,GACN,CAYe,SAASC,EACtBC,EACAC,EACAC,EACAC,GAEA,MAAOC,EAAIC,GAAML,GACVM,EAAIC,GAAMN,GACVO,EAAIC,GAAMP,GACVQ,EAAIC,GAAMR,EAGXS,EAAKL,EAAKF,EACVQ,EAAKT,EAAKE,EACVQ,EAAKR,EAAKD,EAAKD,EAAKG,EAGpBQ,EAAKH,EAAKJ,EAAKK,EAAKJ,EAAKK,EACzBE,EAAKJ,EAAKF,EAAKG,EAAKF,EAAKG,EAM/B,GAAW,IAAPC,GAAmB,IAAPC,GAAYnB,EAAKkB,KAAQlB,EAAKmB,GAC5C,OAIF,MAAMC,EAAKN,EAAKF,EACVS,EAAKV,EAAKE,EACVS,EAAKT,EAAKD,EAAKD,EAAKG,EAGpBS,EAAKH,EAAKb,EAAKc,EAAKb,EAAKc,EACzBE,EAAKJ,EAAKX,EAAKY,EAAKX,EAAKY,EAO/B,GAAW,IAAPC,GAAmB,IAAPC,GAAYxB,EAAKuB,KAAQvB,EAAKwB,GAC5C,OAMF,MAAMC,EAAQV,EAAKM,EAAKD,EAAKJ,EAC7B,IAAIU,EAOJA,EAAMV,EAAKM,EAAKD,EAAKJ,EACrB,MAAM1f,EAAImgB,EAAMD,EAEhBC,EAAMN,EAAKH,EAAKF,EAAKO,EAKrB,MAF0B,CAAC/f,EAFjBmgB,EAAMD,EAKlB,CCzFA,MAAME,EAAwB,IASf,SAASC,EACtBlC,EACAC,EACAjqB,GAKA,MAAMwmB,EAAOwD,EAAU,IAAMC,EAAQ,GAAKD,EAAU,GAAKC,EAAQ,GAC3DxD,EAAOuD,EAAU,IAAMC,EAAQ,GAAKD,EAAU,GAAKC,EAAQ,GAC3DvD,EAAOsD,EAAU,IAAMC,EAAQ,GAAKD,EAAU,GAAKC,EAAQ,GAC3DtD,EAAOqD,EAAU,IAAMC,EAAQ,GAAKD,EAAU,GAAKC,EAAQ,GASjE,KALEjqB,EAAM,IAAMwmB,EAAOyF,GACnBjsB,EAAM,IAAMymB,EAAOwF,GACnBjsB,EAAM,IAAM0mB,EAAOuF,GACnBjsB,EAAM,IAAM2mB,EAAOsF,GAGnB,OAAO,EAIT,MAAME,GACHlC,EAAQ,GAAKD,EAAU,KAAOhqB,EAAM,GAAKiqB,EAAQ,KACjDA,EAAQ,GAAKD,EAAU,KAAOhqB,EAAM,GAAKiqB,EAAQ,IAIpD,OAHuBkC,GAAe,EAAIA,GAAeA,IAGhCF,CAC3B,C,kDC/Be,SAAS3E,EAAgB8E,EAAWC,GACjD,OAAO1lB,KAAKgK,MAAK,OAAuByb,EAAIC,GAC9C,C,kBCHe,SAASzF,EAAuBwF,EAAWC,GACxD,GAAID,EAAGrsB,SAAWssB,EAAGtsB,OACnB,MAAMwF,MAAM,mDAGd,MAAOslB,EAAIC,EAAIwB,EAAK,GAAKF,GAClBrB,EAAIC,EAAIuB,EAAK,GAAKF,EACnBlF,EAAK4D,EAAKF,EACVzD,EAAK4D,EAAKF,EACVnB,EAAK4C,EAAKD,EAIhB,OAAOnF,EAAKA,EAAKC,EAAKA,EAAKuC,EAAKA,CAClC,C,kCChBe,SAAS6C,EACtBC,EACAC,GAEA,MAAO7B,EAAIC,GAAM2B,GACV1B,EAAIC,GAAM0B,EAKjB,MAAO,CAHM,EAAI3B,EAAKF,EACT,EAAIG,EAAKF,EAGxB,C,6qBCVe,SAAS6B,EAASrc,GAC/B,GAAIA,EAASvQ,OAAS,EACpB,OAAO,EAGT,MAAM6sB,EAAoBtc,EAASvQ,OAE7B8Q,EAAaP,EAAS,GACtBQ,EAAYR,EAASsc,EAAoB,GACzCC,EAAwBzC,EAAKpqB,MAAM4mB,uBACvC/V,EACAC,GAGF,OAAO,YAAgB,EAAG+b,EAC5B,CCTe,SAASC,EACtBxc,EACAtQ,EACA2E,EAGI,CACF4L,YAAQxR,IAGV,GAAIuR,EAASvQ,OAAS,EACpB,OAAO,EAGT,MAAM6sB,EAAoBtc,EAASvQ,OACnC,IAAIgtB,EAAmB,EAEvB,MAAM,OAAExc,EAAM,MAAE+D,GAAU3P,EAE1B,GAAI2P,GAAOvU,OACT,IAAK,MAAMitB,KAAQ1Y,EACjB,GAAIwY,EAAcE,EAAMhtB,GACtB,OAAO,EAMb,MAAMitB,SAA2BluB,IAAXwR,EAAuBoc,EAASrc,GAAYC,GAC5D2c,EAAkB5c,EAASvQ,QAAUktB,EAAc,EAAI,GAE7D,IAAK,IAAIntB,EAAI,EAAGA,GAAKotB,EAAiBptB,IAAK,CACzC,MAAMssB,EAAK9b,EAASxQ,GAKdusB,EAAK/b,EADKxQ,IAAM8sB,EAAoB,EAAI,EAAI9sB,EAAI,GAIhD2mB,EAAO2F,EAAG,IAAMC,EAAG,GAAKD,EAAG,GAAKC,EAAG,GACnC1F,EAAOyF,EAAG,IAAMC,EAAG,GAAKD,EAAG,GAAKC,EAAG,GACnC3F,EAAO0F,EAAG,IAAMC,EAAG,GAAKD,EAAG,GAAKC,EAAG,GAKzC,GAFErsB,EAAM,IAAMymB,GAAQzmB,EAAM,IAAM0mB,GAAQ1mB,EAAM,GAAK2mB,EAExB,CAE3B,IAAIwG,EADmBf,EAAG,KAAOC,EAAG,GAGpC,IAAKc,EAAY,CACf,MAAMC,GACFptB,EAAM,GAAKosB,EAAG,KAAOC,EAAG,GAAKD,EAAG,KAAQC,EAAG,GAAKD,EAAG,IAAMA,EAAG,GAEhEe,EAAantB,EAAM,IAAMotB,CAC3B,CAEAL,GAAoBI,EAAa,EAAI,CACvC,CACF,CAEA,SAAUJ,EAAmB,EAC/B,CCrEe,SAASM,EACtB/c,EACAzT,GAEA,IAAK,IAAIiD,EAAI,EAAGwtB,EAAWzwB,EAAOkD,OAAQD,EAAIwtB,EAAUxtB,IACtD,IAAKgtB,EAAcxc,EAAUzT,EAAOiD,IAClC,OAAO,EAIX,OAAO,CACT,C,eCZe,SAASytB,EAAQ1wB,GAE9B,MAAM2wB,EAAI3wB,EAAOkD,OACjB,IAAI0tB,EAAO,EACP1Y,EAAIyY,EAAI,EAEZ,IAAK,IAAI1tB,EAAI,EAAGA,EAAI0tB,EAAG1tB,IACrB2tB,IAAS5wB,EAAOkY,GAAG,GAAKlY,EAAOiD,GAAG,KAAOjD,EAAOkY,GAAG,GAAKlY,EAAOiD,GAAG,IAClEiV,EAAIjV,EAIN,OAAO6G,KAAKC,IAAI6mB,EAAO,EACzB,CCRe,SAASC,EAAcpd,GACpC,GAAIA,EAASvQ,OAAS,EACpB,OAAO,EAIT,MAAM4tB,EAAWrd,EAAS,GAC1B,IAAImd,EAAO,EAUX,IAAK,IAAI3tB,EAAI,EAAGqf,EAAM7O,EAASvQ,OAAQD,EAAIqf,EAAKrf,IAAK,CACnD,MAAMssB,EAAK9b,EAASxQ,GAGdusB,EAAK/b,EADKxQ,IAAMqf,EAAM,EAAI,EAAIrf,EAAI,GAElC8tB,EAAKxB,EAAG,GAAKuB,EAAS,GACtBE,EAAKzB,EAAG,GAAKuB,EAAS,GACtBG,EAAKzB,EAAG,GAAKsB,EAAS,GAK5BF,GAAQG,GAJGvB,EAAG,GAAKsB,EAAS,IAIVE,EAAKC,CACzB,CAKA,OAFAL,GAAQ,GAEDA,CACT,CC1Ce,SAASM,EAAoBzd,GAI1C,OAHmBod,EAAcpd,IAGZ,EAAI,GAAK,CAChC,CCmCe,SAAS0d,EAAW1d,GACjC,MAAM2d,EA9CR,SAAwB3d,GACtB,MAAM2d,EAAU,cAGVN,EAAWrd,EAAS,GAU1B,IAAK,IAAIxQ,EAAI,EAAGqf,EAAM7O,EAASvQ,OAAQD,EAAIqf,EAAKrf,IAAK,CACnD,MAAMssB,EAAK9b,EAASxQ,GAGdusB,EAAK/b,EADKxQ,IAAMqf,EAAM,EAAI,EAAIrf,EAAI,GAGlC8tB,EAAKxB,EAAG,GAAKuB,EAAS,GACtBE,EAAKzB,EAAG,GAAKuB,EAAS,GACtBO,EAAK9B,EAAG,GAAKuB,EAAS,GACtBG,EAAKzB,EAAG,GAAKsB,EAAS,GACtBQ,EAAK9B,EAAG,GAAKsB,EAAS,GACtBS,EAAK/B,EAAG,GAAKsB,EAAS,GAG5BM,EAAQ,IAAMJ,EAAKO,EAAKF,EAAKC,EAC7BF,EAAQ,IAAMC,EAAKJ,EAAKF,EAAKQ,EAC7BH,EAAQ,IAAML,EAAKO,EAAKN,EAAKC,CAC/B,CAMA,OAHA,WAAWG,EAASA,EAAS,IAGRA,CACvB,CAQkBI,CAAe/d,GAE/B,OAAO,eAAe2d,EAASA,EACjC,CC1Ce,SAASK,EAAWhe,GACjC,MAAMmd,EAAOC,EAAcpd,GAI3B,MAAO,CAAC,EAAG,EAAGmd,EAAO9mB,KAAKC,IAAI6mB,GAChC,C,eCMe,SAASc,EACtBnC,EACAoC,EACAnC,EACAoC,GAEA,IAAI9b,GAAS,EAGb,MAAM+b,EAAYtC,EAAG,GAAKoC,EAAG,GAAKpC,EAAG,GAAKoC,EAAG,GACvCG,EAAYvC,EAAG,GAAKoC,EAAG,GAAKpC,EAAG,GAAKoC,EAAG,GACvCI,EAAYxC,EAAG,GAAKoC,EAAG,GAAKpC,EAAG,GAAKoC,EAAG,GACvCK,EAAYzC,EAAG,GAAKoC,EAAG,GAAKpC,EAAG,GAAKoC,EAAG,GAGvCM,EAAYzC,EAAG,GAAKoC,EAAG,GAAKpC,EAAG,GAAKoC,EAAG,GACvCM,EAAY1C,EAAG,GAAKoC,EAAG,GAAKpC,EAAG,GAAKoC,EAAG,GACvCO,EAAY3C,EAAG,GAAKoC,EAAG,GAAKpC,EAAG,GAAKoC,EAAG,GACvCQ,EAAY5C,EAAG,GAAKoC,EAAG,GAAKpC,EAAG,GAAKoC,EAAG,GAI7C,GACEC,EAAYM,GACZJ,EAAYE,GACZH,EAAYM,GACZJ,EAAYE,EAEZ,OAAO,EAGT,MAAMG,EAAS,CACb/C,EAAYC,EAAIoC,EAAInC,GACpBF,EAAYC,EAAIoC,EAAIC,GACpBtC,EAAYE,EAAIoC,EAAIrC,GACpBD,EAAYE,EAAIoC,EAAID,IAItB,OAAIU,EAAO,KAAOA,EAAO,IAAMA,EAAO,KAAOA,EAAO,MAKlC,IAAdA,EAAO,IAAYC,EAAU/C,EAAIC,EAAImC,IAGhB,IAAdU,EAAO,IAAYC,EAAU/C,EAAIqC,EAAID,IAGvB,IAAdU,EAAO,IAAYC,EAAU9C,EAAID,EAAIqC,IAGvB,IAAdS,EAAO,IAAYC,EAAU9C,EAAImC,EAAIC,MAP9C9b,GAAS,GAYJA,EACT,CAMA,SAASwZ,EACP/jB,EACAgnB,EACAC,GAGA,MAAMC,GACHF,EAAE,GAAKhnB,EAAE,KAAOinB,EAAE,GAAKD,EAAE,KAAOA,EAAE,GAAKhnB,EAAE,KAAOinB,EAAE,GAAKD,EAAE,IAE5D,OAAyB,IAArBE,EACK,EAGFA,EAAmB,EAAI,EAAI,CACpC,CAKA,SAASH,EAAU/mB,EAAiBgnB,EAAiBC,GACnD,OACED,EAAE,IAAMzoB,KAAKW,IAAIc,EAAE,GAAIinB,EAAE,KACzBD,EAAE,IAAMzoB,KAAKU,IAAIe,EAAE,GAAIinB,EAAE,KACzBD,EAAE,IAAMzoB,KAAKW,IAAIc,EAAE,GAAIinB,EAAE,KACzBD,EAAE,IAAMzoB,KAAKU,IAAIe,EAAE,GAAIinB,EAAE,GAM7B,CCzGe,SAASE,EACtBjf,EACA8b,EACAoC,EACAje,GAAS,GAET,MAAMif,EAAgC,GAChC1V,EAAYxJ,EAASvQ,OACrB0vB,EAAO3V,GAAavJ,EAAS,EAAI,GAEvC,IAAK,IAAIzQ,EAAI,EAAGA,GAAK2vB,EAAM3vB,IAAK,CAC9B,MAEMiV,EAAIjV,IAAMga,EAAY,EAAI,EAAIha,EAAI,EAGpCyuB,EAA4BnC,EAAIoC,EALzBle,EAASxQ,GAGTwQ,EAASyE,KAGlBya,EAAcjiB,KAAK,CAACzN,EAAGiV,GAE3B,CAEA,OAAOya,CACT,C,eC3BA,MAAME,EAA2B,IAelB,SAASC,EACtBvD,EACAoC,EACAnC,EACAoC,GAEA,MAAMmB,EAAW,CAACpB,EAAG,GAAKpC,EAAG,GAAIoC,EAAG,GAAKpC,EAAG,IACtCyD,EAAW,CAACpB,EAAG,GAAKpC,EAAG,GAAIoC,EAAG,GAAKpC,EAAG,IACtCyD,EAAcD,EAAS,GAAKD,EAAS,GAAKC,EAAS,GAAKD,EAAS,GAGvE,IAFuBE,GAAe,EAAIA,GAAeA,GAEpCJ,EAA0B,CAE7C,MAAMK,EAAY,CAChB3D,EAAG,GAAKoC,EAAG,GAAKpC,EAAG,GAAKoC,EAAG,GAC3BpC,EAAG,GAAKoC,EAAG,GAAKpC,EAAG,GAAKoC,EAAG,GAC3BpC,EAAG,GAAKoC,EAAG,GAAKpC,EAAG,GAAKoC,EAAG,GAC3BpC,EAAG,GAAKoC,EAAG,GAAKpC,EAAG,GAAKoC,EAAG,IAIvBwB,EAAY,CAChB3D,EAAG,GAAKoC,EAAG,GAAKpC,EAAG,GAAKoC,EAAG,GAC3BpC,EAAG,GAAKoC,EAAG,GAAKpC,EAAG,GAAKoC,EAAG,GAC3BpC,EAAG,GAAKoC,EAAG,GAAKpC,EAAG,GAAKoC,EAAG,GAC3BpC,EAAG,GAAKoC,EAAG,GAAKpC,EAAG,GAAKoC,EAAG,IAS7B,KALEsB,EAAU,IAAMC,EAAU,IAC1BD,EAAU,IAAMC,EAAU,IAC1BD,EAAU,IAAMC,EAAU,IAC1BD,EAAU,IAAMC,EAAU,IAG1B,OASF,KAJE,uBAA8B5D,EAAIoC,EAAInC,IACtC,uBAA8BD,EAAIoC,EAAIC,IACtC,uBAA8BpC,EAAIoC,EAAIrC,IAGtC,OAYF,MAAO,CAHsB,KAJhB2D,EAAU,GAAKC,EAAU,GAAKD,EAAU,GAAKC,EAAU,KACvDD,EAAU,GAAKC,EAAU,GAAKD,EAAU,GAAKC,EAAU,KAIvC,KAHhBD,EAAU,GAAKC,EAAU,GAAKD,EAAU,GAAKC,EAAU,KACvDD,EAAU,GAAKC,EAAU,GAAKD,EAAU,GAAKC,EAAU,KAKtE,CAEA,IAAIjpB,EAAIqlB,EAAG,GAAKC,EAAG,GACfrlB,EAAIolB,EAAG,GAAKC,EAAG,GACnB,MACM4D,EAAaL,EAAS,GAAK7oB,EAAI6oB,EAAS,GAAK5oB,EACnDD,GAFmB8oB,EAAS,GAAK9oB,EAAI8oB,EAAS,GAAK7oB,GAElC8oB,EACjB9oB,EAAIipB,EAAaH,EAKjB,MAAO,CAHS1D,EAAG,GAAKrlB,EAAI6oB,EAAS,GACrBxD,EAAG,GAAKrlB,EAAI6oB,EAAS,GAGvC,CCrFA,IAAKM,EAMAC,EAQAC,EAwBL,SAASC,EAAoBC,GAE3B,IAAK,IAAIxwB,EAAI,EAAGqf,EAAMmR,EAAevwB,OAAQD,EAAIqf,EAAKrf,IAAK,CACzD,MAAMywB,EAAeD,EAAexwB,GAE/BywB,EAAaC,OAChBD,EAAaC,KAAOF,EAAexwB,IAAMqf,EAAM,EAAI,EAAIrf,EAAI,GAE/D,CACF,CAUA,SAAS2wB,EACPC,EACAC,GAEA,MAAMC,EAAwC,GACxCC,EAAwC,GACxCC,EAA2B,IAAIjnB,IAOrC,IAAIknB,EAFuBjE,EAAc6D,EAAgBD,EAAe,IAGpEN,EAAuBY,QACvBZ,EAAuBa,SAG3B,IAAK,IAAInxB,EAAI,EAAGqf,EAAMuR,EAAe3wB,OAAQD,EAAIqf,EAAKrf,IAAK,CACzD,MAAMssB,EAAKsE,EAAe5wB,GACpBoxB,EAAcpE,EAAc6D,EAAgBvE,GAC5C+E,EAA6B,CACjCvoB,KAAMsnB,EAAkBkB,OACxBC,YAAajF,EACbkF,SAAUJ,EACNf,EAAsBoB,OACtBpB,EAAsBqB,QAC1BC,SAAS,EACTjB,KAAM,MAGRI,EAAqBrjB,KAAK4jB,GAE1B,MAAM3C,EAAKkC,EAAe5wB,IAAMqf,EAAM,EAAI,EAAIrf,EAAI,GAC5C4xB,EAAoBnC,EACxBoB,EACAvE,EACAoC,GACAhrB,KAAKmuB,IACL,MAAMC,EAA8BD,EAAuB,GACrDtF,EAAKsE,EAAegB,EAAuB,IAC3ClD,EAAKkC,EAAegB,EAAuB,IAK3CE,EAAyBlC,EAC7BvD,EACAoC,EACAnC,EACAoC,GAQF,MAAO,CACLmD,sBACA/Q,WAAYgR,EACZC,4BARkC,yBAClC1F,EACAyF,GAOD,IAGHH,EAAkB5qB,MAChB,CAACgjB,EAAM5L,IACL4L,EAAKgI,4BAA8B5T,EAAM4T,8BAG7CJ,EAAkBxoB,SAAS6oB,IACzB,MAAM,oBAAEH,EAAqB/Q,WAAYgR,GACvCE,EAGIC,EAA6C,CACjDppB,KAAMsnB,EAAkB+B,aACxBZ,YAAaQ,EACbP,SAAUnB,EAAsB+B,KAChCtmB,UAAWmlB,EACXU,SAAS,EACTjB,KAAM,MAOF2B,EAA6C,IAC9CH,EACHpmB,UAAWwkB,EAAuBgC,QAClCC,QAAQ,GAGNtB,IAA+BX,EAAuBa,SACxDe,EAAgBxB,KAAO2B,EAEvBA,EAAgB3B,KAAOwB,EAGzB,IAAIM,EACFxB,EAAyBpiB,IAAIkjB,GAE1BU,IACHA,EAA2B,GAC3BxB,EAAyBjjB,IACvB+jB,EACAU,IAIJ1B,EAAqBrjB,KAAKykB,GAC1BM,EAAyB/kB,KAAK4kB,GAG9BpB,IAA+B,CAAC,GAEpC,CAGA,IAAK,IAAIjxB,EAAI,EAAGqf,EAAMwR,EAAe5wB,OAAQD,EAAIqf,EAAKrf,IAAK,CACzD,MAAMyyB,EAAwBzyB,EACxBssB,EAAKuE,EAAe7wB,GACpBqxB,EAA6B,CACjCvoB,KAAMsnB,EAAkBkB,OACxBC,YAAajF,EACbqF,SAAS,EACTjB,KAAM,MAGRK,EAAqBtjB,KAAK4jB,GAE1B,MAAMmB,EACJxB,EAAyBpiB,IAAI6jB,GAE1BD,GAA0BvyB,QAO/BuyB,EACG9uB,KAAKgvB,IAAsB,CAC1BA,oBACAC,wBAAyB,yBACvBrG,EACAoG,EAAkBnB,iBAGrBvqB,MACC,CAACgjB,EAAM5L,IACL4L,EAAK2I,wBAA0BvU,EAAMuU,0BAExCjvB,KAAI,EAAGgvB,uBAAwBA,IAC/BtpB,SAASspB,GACR3B,EAAqBtjB,KAAKilB,IAEhC,CAKA,OAHAnC,EAAoBO,GACpBP,EAAoBQ,GAEb,CAAED,uBAAsBC,uBACjC,CAQA,SAAS6B,EAAyBpC,GAChC,IAAK,IAAIxwB,EAAI,EAAGqf,EAAMmR,EAAevwB,OAAQD,EAAIqf,EAAKrf,IAAK,CACzD,MAAME,EAAQswB,EAAexwB,GAE7B,IAAKE,EAAMyxB,SAAWzxB,EAAMsxB,WAAanB,EAAsBqB,QAC7D,OAAOxxB,CAEX,CACF,CAKA,SAAS2yB,EACPjC,EACAC,GAEA,MAAMiC,EAAetE,EAAWoC,GAC1BmC,EAAevE,EAAWqC,GAC1BmC,EAAa,SAASD,EAAcD,GAIrC,YAAgB,EAAGE,KACtBnC,EAAiBA,EAAezwB,QAAQ4M,WAG1C,MAAM,qBAAE8jB,GAAyBH,EAC/BC,EACAC,GAEIoC,EACJL,EAAyB9B,GAG3B,IAAKmC,EACH,OAAOrC,EAAexwB,QAGxB,MAAM8yB,EAAiB,CAACD,EAAW1B,aACnC,IAAId,EAAewC,EAAWvC,KAE9B,KAAOD,IAAiBwC,GAEpBxC,EAAa3nB,OAASsnB,EAAkB+B,cACZ1B,EAAc8B,QAM5CW,EAAezlB,KAAKgjB,EAAac,aAJ/Bd,EAAeA,EAAaC,KAQhC,OAAOwC,CACT,CAKA,SAASC,EACPvC,EACAC,GAEA,MAAMiC,EAAetE,EAAWoC,GAC1BmC,EAAevE,EAAWqC,GAC1BmC,EAAa,SAASD,EAAcD,GAKrC,aAAiB,EAAGE,KACvBnC,EAAiBA,EAAezwB,QAAQ4M,WAG1C,MAAM,qBAAE8jB,GAAyBH,EAC/BC,EACAC,GAEF,IAAIoC,EAA4B,KAChC,MAAMG,EAAsB,GAE5B,KAAQH,EAAaL,EAAyB9B,IAAwB,CACpE,MAAMuC,EAAqB,CAACJ,EAAW1B,aACvC,IAAId,EAAewC,EAAWvC,KAI9B,IAFAuC,EAAWtB,SAAU,EAEdlB,IAAiBwC,GACtBxC,EAAakB,SAAU,EAGrBlB,EAAa3nB,OAASsnB,EAAkB+B,cACZ1B,EAAc8B,QAM5Cc,EAAmB5lB,KAAKgjB,EAAac,aAJnCd,EAAeA,EAAaC,KAQhC0C,EAAoB3lB,KAAK4lB,EAC3B,CAEA,OAAOD,CACT,CC3Ue,SAASE,EACtBv2B,EACAuvB,EACAoC,EACAje,GAAS,GAET,IAAI8iB,EACAte,EAEAxE,GACFwE,EAAIlY,EAAOkD,OAAS,EACpBszB,EAAW,IAEXte,EAAI,EACJse,EAAW,GAGb,IAAK,IAAIvzB,EAAIuzB,EAAUvzB,EAAIjD,EAAOkD,OAAQD,IAAK,CAI7C,GAAIyuB,EAA4BnC,EAAIoC,EAHzB3xB,EAAOkY,GACPlY,EAAOiD,IAGhB,MAAO,CAACiV,EAAGjV,GAGbiV,EAAIjV,CACN,CACF,CChCe,SAASwzB,EACtB3C,EACAD,GAKA,IAAK,IAAI5wB,EAAI,EAAGyzB,EAAY5C,EAAe5wB,OAAQD,EAAIyzB,EAAWzzB,IAAK,CACrE,MAIM0zB,EAA2BJ,EAC/B1C,EALeC,EAAe7wB,GAEf6wB,EADK7wB,IAAMyzB,EAAY,EAAI,EAAIzzB,EAAI,IASpD,GAAyC,IAArC0zB,GAA0BzzB,OAC5B,OAAO,CAEX,CAEA,OAAO,CACT,EFzBA,SAAKmwB,GACH,uBACA,kCACD,CAHD,CAAKA,IAAAA,EAAiB,KAMtB,SAAKC,GACH,0BACA,mBACA,sBACD,CAJD,CAAKA,IAAAA,EAAqB,KAQ1B,SAAKC,GACH,0BACA,yBACA,0BACD,CAJD,CAAKA,IAAAA,EAAsB,KGnB3B,MAAMqD,EAAkB,GAkBT,SAAS/Y,EACtBpK,EACAsK,EAAU6Y,GAEV,MAAM3Z,EAAYxJ,EAASvQ,OAG3B,GAAI+Z,EAAY,EACd,OAAOxJ,EAGT,MAAMojB,EAAiB9Y,EAAUA,EAC3B+Y,EAAiB,CAAC,CAAC,EAAG7Z,EAAY,IAKlC8Z,EAAqB,IAAI92B,MAAMgd,GAAWzG,MAAK,GAGrD,IAAIwgB,EAAqB,EAQzB,IALAD,EAAmB,IAAK,EACxBA,EAAmB9Z,EAAY,IAAK,EAI7B6Z,EAAe5zB,QAAQ,CAC5B,MAAO+zB,EAAYC,GAAYJ,EAAeK,MAG9C,GAAID,EAAWD,GAAe,EAC5B,SAGF,MAAMf,EAAaziB,EAASwjB,GACtBG,EAAW3jB,EAASyjB,GAC1B,IAAIG,GAAkBrsB,IAClBssB,GAAgB,EAGpB,IAAK,IAAIr0B,EAAIg0B,EAAa,EAAGh0B,EAAIi0B,EAAUj0B,IAAK,CAC9C,MAAMywB,EAAejgB,EAASxQ,GACxBs0B,EAAc,yBAClBrB,EACAkB,EACA1D,GAGE6D,EAAcF,IAChBA,EAAiBE,EACjBD,EAAer0B,EAEnB,CAIIo0B,EAAiBR,IAMrBE,EAAmBO,IAAgB,EACnCN,IAIAF,EAAepmB,KAAK,CAAC4mB,EAAcJ,IACnCJ,EAAepmB,KAAK,CAACumB,EAAYK,IACnC,CAGA,MAAME,EAAoC,IAAIv3B,MAAM+2B,GAEpD,IAAK,IAAIS,EAAW,EAAGC,EAAW,EAAGD,EAAWxa,EAAWwa,IACrDV,EAAmBU,KACrBD,EAAkBE,KAAcjkB,EAASgkB,IAI7C,OAAOD,CACT,CCjGe,SAASG,EACtB33B,EACAuvB,EACAoC,EACAje,GAAS,GAET,MAAMoC,EAAS,GACT8hB,EAAkBlF,EACtB1yB,EACAuvB,EACAoC,EACAje,GAGF,IAAK,IAAIzQ,EAAI,EAAGA,EAAI20B,EAAgB10B,OAAQD,IAAK,CAC/C,MAEM40B,EAAe/E,EAAqBvD,EAAIoC,EAFnC3xB,EAAO43B,EAAgB30B,GAAG,IAC1BjD,EAAO43B,EAAgB30B,GAAG,KAErC6S,EAAOpF,KAAKmnB,EACd,CAEA,OAAO/hB,CACT,CChBe,SAASgiB,EACtB93B,EACAuvB,EACAoC,EACAje,GAAS,GAET,IAAIqkB,EACAC,EAEAtkB,GACFskB,EAAUh4B,EAAOkD,OAAS,EAC1B60B,EAAiB,IAEjBC,EAAU,EACVD,EAAiB,GAGnB,MAAMpF,EAAgB,GAEtB,IAAK,IAAIsF,EAAUF,EAAgBE,EAAUj4B,EAAOkD,OAAQ+0B,IAAW,CACrE,MAAMzI,EAAKxvB,EAAOg4B,GACZpG,EAAK5xB,EAAOi4B,GAEdvG,EAA4BnC,EAAIoC,EAAInC,EAAIoC,IAC1Ce,EAAcjiB,KAAK,CAACsnB,EAASC,IAG/BD,EAAUC,CACZ,CAEA,GAA6B,IAAzBtF,EAAczvB,OAChB,OAIF,MAAMg1B,EAAY,GAElBvF,EAActmB,SAASwrB,IACrB,MAAMM,EAAqB,CACzBn4B,EAAO63B,EAAa,IACpB73B,EAAO63B,EAAa,KAGhBO,EAAW,EACdD,EAAmB,GAAG,GAAKA,EAAmB,GAAG,IAAM,GACvDA,EAAmB,GAAG,GAAKA,EAAmB,GAAG,IAAM,GAG1DD,EAAUxnB,KAAK,cAAoB0nB,EAAU7I,GAAI,IAGnD,MAAM8I,EAAcvuB,KAAKU,OAAO0tB,GAGhC,MAAO,CACLle,QAAS2Y,EAHgBuF,EAAUI,QAAQD,IAI3C3uB,SAAU2uB,EAEd,C,eCnEA,MAAM3tB,EAAU,KA8FhB,EAhF0C,CACxC7J,EACA03B,KAEA,IAAIxV,EACAyV,EACAC,EAEJ,GAAI53B,aAAoB,EAAA2H,cAAe,CAErC,MAAM+Q,EAAY1Y,EAAS63B,eAE3BF,EAAOjf,EAAUxK,UAAU1L,MAAM,EAAG,GACpCo1B,EAAOlf,EAAUxK,UAAU1L,MAAM,EAAG,GAEpC0f,EAAUxJ,EAAUwJ,OACtB,KAAO,CAEL,MAAMxJ,EAAY1Y,EAAS63B,gBACrB,UAAE3pB,EAAWgU,QAAS4V,GAAkBpf,GACxC,gBAAEvR,EAAe,OAAEghB,GAAWnoB,EAASgO,YAGvC+pB,EAAU7pB,EAAU1L,MAAM,EAAG,GAC7Bw1B,EAAU9pB,EAAU1L,MAAM,EAAG,GAC7By1B,EAAU/pB,EAAU1L,MAAM,EAAG,GAE7B4lB,EAAY,cAElB,WAAWA,EAAiBD,EAAchhB,GAE1C,MAAM+wB,EAAmBjvB,KAAKC,IAAI,SAASkf,EAAW2P,IAChDI,EAAmBlvB,KAAKC,IAAI,SAASkf,EAAW4P,IAChDI,EAAmBnvB,KAAKC,IAAI,SAASkf,EAAW6P,IAGtD,IAAII,EACJ,GAAIpvB,KAAKC,IAAI,EAAIgvB,GAAoBruB,EACnCwuB,EAAWP,EAAc,GACzBH,EAAOI,OACF,GAAI9uB,KAAKC,IAAI,EAAIivB,GAAoBtuB,EAC1CwuB,EAAWP,EAAc,GACzBH,EAAOK,MACF,MAAI/uB,KAAKC,IAAI,EAAIkvB,GAAoBvuB,GAI1C,MAAM,IAAIhC,MAAM,oDAHhBwwB,EAAWP,EAAc,GACzBH,EAAOM,CAGT,CAEA,MAAMK,EAAgBrvB,KAAKC,IAAI,SAASif,EAAQ4P,IAC1CQ,EAAgBtvB,KAAKC,IAAI,SAASif,EAAQ6P,IAC1CQ,EAAgBvvB,KAAKC,IAAI,SAASif,EAAQ8P,IAGhD,IAAIQ,EACJ,GAAIxvB,KAAKC,IAAI,EAAIovB,GAAiBzuB,EAChC4uB,EAAWX,EAAc,GACzBF,EAAOG,OACF,GAAI9uB,KAAKC,IAAI,EAAIqvB,GAAiB1uB,EACvC4uB,EAAWX,EAAc,GACzBF,EAAOI,MACF,MAAI/uB,KAAKC,IAAI,EAAIsvB,GAAiB3uB,GAIvC,MAAM,IAAIhC,MAAM,oDAHhB4wB,EAAWX,EAAc,GACzBF,EAAOK,CAGT,CAEA/V,EAAU,CAACmW,EAAUI,EACvB,CAOA,MAAO,CAAEvW,QAL6B,CACpCA,EAAQ,GAAKwV,EACbxV,EAAQ,GAAKwV,GAGoBC,OAAMC,OAAM,ECjFjD,EAR6C,CAC3ClJ,EACAC,EACA+J,IAEO,UAAUhK,EAAIC,GAAM+J,ECuD7B,EA1D+B,CAC7Bt4B,EACA+f,EACAwY,EACAC,KAEA,MAAM,KAAEjB,EAAI,KAAEC,EAAI,QAAE1V,GAAY0W,EAC1B72B,GAAiB,IAAAC,mBAAkB5B,IACnC,SAAEJ,GAAa+B,EAErB,IAAKoe,EAAa9d,OAGhB,OAFA8d,EAAatQ,KAAK8oB,GAClBrgB,QAAQugB,IAAI,kCACL,EAGT,MAAMC,EAAe94B,EAAS8c,cAC5BqD,EAAaA,EAAa9d,OAAS,IAE/B02B,EAAc/4B,EAAS8c,cAAc6b,GACrCK,EAAe,cAErB,cAAcA,EAAcD,EAAaD,GAEzC,MAAMG,EAAQhwB,KAAKC,IAAI,SAAS8vB,EAAcrB,IACxCuB,EAAQjwB,KAAKC,IAAI,SAAS8vB,EAAcpB,IAExCuB,EAAiBlwB,KAAKW,IAC1BX,KAAKyS,MAAMud,EAAQ/W,EAAQ,IAC3BjZ,KAAKyS,MAAMwd,EAAQhX,EAAQ,KAG7B,GAAIiX,EAAiB,EAAG,CACtB,MAAMC,EAAkBjZ,EAAaA,EAAa9d,OAAS,GAErDg3B,EAAa,UAAUD,EAAiBT,GAExCW,EAAY,cAElB,cAAcA,EAAWX,EAAgBS,GAEzC,SAASE,EAAWA,EAAU,GAAKD,EAAYC,EAAU,GAAKD,GAE9D,MAAME,EAAeF,EAAaF,EAElC,IAAK,IAAI/2B,EAAI,EAAGA,GAAK+2B,EAAgB/2B,IACnC+d,EAAatQ,KAAK,CAChBupB,EAAgB,GAAKG,EAAeD,EAAU,GAAKl3B,EACnDg3B,EAAgB,GAAKG,EAAeD,EAAU,GAAKl3B,GAGzD,MACE+d,EAAatQ,KAAK8oB,GAGpB,OAAOQ,CAAc,ECPvB,EAjD8B,CAC5BzuB,EACAgkB,EACAC,EACA7sB,KAGA,MAAM03B,EAAM,CAAC9uB,EAAE,GAAKgkB,EAAG,GAAIhkB,EAAE,GAAKgkB,EAAG,IAC/B+K,EAAO,CAAC9K,EAAG,GAAKD,EAAG,GAAIC,EAAG,GAAKD,EAAG,IAElC1lB,EAAMwwB,EAAI,GAAKC,EAAK,GAAKD,EAAI,GAAKC,EAAK,GAG7C,GAAIzwB,EAAM,EACR,OAAO,EAGT,MAAM0wB,EAAUzwB,KAAKgK,KAAKwmB,EAAK,GAAKA,EAAK,GAAKA,EAAK,GAAKA,EAAK,IAE7D,GAAgB,IAAZC,EACF,OAAO,EAGT,MAAMC,EAAsB3wB,EAAM0wB,EAC5BE,EAAiB,CAACH,EAAK,GAAKC,EAASD,EAAK,GAAKC,GAC/CG,EAAmB,CACvBD,EAAe,GAAKD,EACpBC,EAAe,GAAKD,GAEhBG,EAAgC,CACpCpL,EAAG,GAAKmL,EAAiB,GACzBnL,EAAG,GAAKmL,EAAiB,IAK3B,QAFiB,cAAcnvB,EAAGovB,GAEnBh4B,MAMX,cAAc4sB,EAAIoL,GAAmB,cAAcpL,EAAIC,GAIhD,EClDPzR,EAAU,KAST,SAAS6c,EAAYnnB,GAI1B,IAAIonB,EAEJ,MAAMC,EAAa,EAAA5yB,UAAA,yBAAmCuL,EAAU,IAEhE,IAAK,IAAIxQ,EAAI,EAAGA,EAAI,EAAGA,IACrB,GACE63B,EAAWC,OACT,CAAC53B,EAAOoR,EAAOuX,IAAUhiB,KAAKC,IAAI5G,EAAMF,GAAK6oB,EAAM,GAAG7oB,IAAM8a,IAE9D,CACA8c,EAAuB53B,EACvB,KACF,CAGF,QAA6Bf,IAAzB24B,EACF,MAAM,IAAInyB,MACR,6EAKJ,MAAMsyB,EAAW,GAEXC,GAAYJ,EAAuB,GAAK,EACxCK,GAAaL,EAAuB,GAAK,EAE/C,IAAK,IAAI53B,EAAI,EAAGA,EAAIwQ,EAASvQ,OAAQD,IACnC+3B,EAAStqB,KAAK,CAAC+C,EAASxQ,GAAGg4B,GAAWxnB,EAASxQ,GAAGi4B,KAGpD,MAAO,CACLL,uBACAM,kBAAmBH,EAEvB,CClCO,SAASI,EACdj4B,EACAsQ,EACA3L,EAAwC,CAAC,GAEzC,MAAM,qBAAE+yB,EAAoB,kBAAEM,GAAsBP,EAAYnnB,IAE1D,MAAEgE,GAAU3P,EACZuzB,EAAiB,GAEvB,GAAI5jB,EACF,IAAK,IAAIxU,EAAI,EAAGA,EAAIwU,EAAMvU,OAAQD,IAAK,CACrC,MAAMktB,EAAO1Y,EAAMxU,GACbq4B,EAAS,GAEf,IAAK,IAAIpjB,EAAI,EAAGA,EAAIiY,EAAKjtB,OAAQgV,IAC/BojB,EAAO5qB,KAAK,CACVyf,EAAKjY,IAAI2iB,EAAuB,GAAK,GACrC1K,EAAKjY,IAAI2iB,EAAuB,GAAK,KAIzCQ,EAAe3qB,KAAK4qB,EACtB,CAQF,OAAOrL,EAAckL,EALL,CACdh4B,GAAO03B,EAAuB,GAAK,GACnC13B,GAAO03B,EAAuB,GAAK,IAGY,CAAEpjB,MAAO4jB,GAC5D,C,uECOe,SAAS5Q,EACtB8Q,EACAp4B,GAEA,GAAoB,IAAhBo4B,EAAKr4B,QAAiC,IAAjBC,EAAMD,OAC7B,MAAMwF,MACJ,8EAIJ,MAAOukB,EAAM3L,EAAKka,EAAOC,GAAUF,EAEnC,IAAIlD,EAAc,OAClB,MAAMqD,EAjDR,SACEzO,EACA3L,EACAka,EACAC,GAqBA,MAPqB,CACnBna,IAAK,CAb4B,CAAC2L,EAAM3L,GACT,CAAC2L,EAAOuO,EAAOla,IAa9CD,MAAO,CAX4B,CAAC4L,EAAOuO,EAAOla,GACjB,CAAC2L,EAAOuO,EAAOla,EAAMma,IAWtDla,OAAQ,CAT4B,CAAC0L,EAAOuO,EAAOla,EAAMma,GACvB,CAACxO,EAAM3L,EAAMma,IAS/CxO,KAAM,CAP4B,CAACA,EAAM3L,EAAMma,GACf,CAACxO,EAAM3L,IAU3C,CAuBuBqa,CAAmB1O,EAAM3L,EAAKka,EAAOC,GAW1D,OATAG,OAAO/Z,KAAK6Z,GAAcrvB,SAAS2N,IACjC,MAAOmT,EAAWC,GAAWsO,EAAa1hB,GACpCtQ,EAAW0L,EAAA,gBAA4B+X,EAAWC,EAASjqB,GAE7DuG,EAAW2uB,IACbA,EAAc3uB,EAChB,IAGK2uB,CACT,C,kBCxDe,SAASwD,EAAcC,EAAgB1Y,GACpD,MAAM,OAAEsJ,EAAM,OAAEqP,GAAWD,EACrBE,EAAUF,EAAOE,SAAWD,EAASA,EAE3C,OACG3Y,EAAS,GAAKsJ,EAAO,KAAOtJ,EAAS,GAAKsJ,EAAO,KAC/CtJ,EAAS,GAAKsJ,EAAO,KAAOtJ,EAAS,GAAKsJ,EAAO,KACjDtJ,EAAS,GAAKsJ,EAAO,KAAOtJ,EAAS,GAAKsJ,EAAO,KACpDsP,CAEJ,C,6JCzBA,MAAMtxB,EAAU,KACVuxB,EAAS,EACTC,EAAU,EAEhB,SAASC,EAAMhN,EAAKD,EAAOkN,GACzB,MAAOC,EAAIC,GAAMF,EACjB,GAAItyB,KAAKC,IAAImlB,GAASxkB,EACpB,OAAOykB,EAAM,EAEf,MAAMoN,EAAIpN,EAAMD,EAEhB,GAAIA,EAAQ,EAAG,CACb,GAAIqN,EAAID,EACN,OAAO,EAELC,EAAIF,IACND,EAAE,GAAKG,EAEX,KAAO,CACL,GAAIA,EAAIF,EACN,OAAO,EAELE,EAAID,IACNF,EAAE,GAAKG,EAEX,CACA,OAAO,CACT,CAUe,SAASrqB,EAAKhI,EAAGC,EAAGqyB,EAAKC,EAAKC,GAC3C,MAAO1O,EAAIC,GAAM/jB,GACVgkB,EAAIC,GAAMhkB,EACXmgB,EAAK4D,EAAKF,EACVzD,EAAK4D,EAAKF,EAYhB,QAVW/rB,IAAPu6B,QAA2Bv6B,IAAPw6B,GACtBD,EAAKvyB,EACLwyB,EAAKvyB,IAELsyB,EAAG,GAAKvyB,EAAE,GACVuyB,EAAG,GAAKvyB,EAAE,GACVwyB,EAAG,GAAKvyB,EAAE,GACVuyB,EAAG,GAAKvyB,EAAE,IAIVL,KAAKC,IAAIugB,GAAM5f,GACfZ,KAAKC,IAAIwgB,GAAM7f,GACfsjB,GAAMwO,EAAI,IACVxO,GAAMwO,EAAI,IACVvO,GAAMuO,EAAI,IACVvO,GAAMuO,EAAI,GAEV,OAAOP,EAGT,MAAMG,EAAI,CAAC,EAAG,GACd,GACED,EAAMK,EAAI,GAAKxO,EAAI1D,EAAI8R,IACvBD,EAAMnO,EAAKwO,EAAI,IAAKlS,EAAI8R,IACxBD,EAAMK,EAAI,GAAKvO,EAAI1D,EAAI6R,IACvBD,EAAMlO,EAAKuO,EAAI,IAAKjS,EAAI6R,GACxB,CACA,MAAOC,EAAIC,GAAMF,EASjB,OARIE,EAAK,IACPI,EAAG,GAAK1O,EAAKsO,EAAKhS,EAClBoS,EAAG,GAAKzO,EAAKqO,EAAK/R,GAEhB8R,EAAK,IACPI,EAAG,IAAMJ,EAAK/R,EACdmS,EAAG,IAAMJ,EAAK9R,GAET0R,CACT,CACA,OAAOC,CACT,C,kBCpFe,SAASS,EAAwBtsB,GAI9C,IAAIif,EAAc,GAClB,MAAMsN,EAAevsB,EAAO,GAAK,EAAI,IAAM,IACrCwsB,EAAexsB,EAAO,GAAK,EAAI,IAAM,IACrCysB,EAAezsB,EAAO,GAAK,EAAI,IAAM,IAGrCtG,EAAM,CAACD,KAAKC,IAAIsG,EAAO,IAAKvG,KAAKC,IAAIsG,EAAO,IAAKvG,KAAKC,IAAIsG,EAAO,KAEjE0sB,EAAM,KAEZ,IAAK,IAAI95B,EAAI,EAAGA,EAAI,EAAGA,IACrB,GAAI8G,EAAI,GAAKgzB,GAAOhzB,EAAI,GAAKA,EAAI,IAAMA,EAAI,GAAKA,EAAI,GAClDulB,GAAesN,EACf7yB,EAAI,GAAK,OACJ,GAAIA,EAAI,GAAKgzB,GAAOhzB,EAAI,GAAKA,EAAI,IAAMA,EAAI,GAAKA,EAAI,GACzDulB,GAAeuN,EACf9yB,EAAI,GAAK,OACJ,GAAIA,EAAI,GAAKgzB,GAAOhzB,EAAI,GAAKA,EAAI,IAAMA,EAAI,GAAKA,EAAI,GACzDulB,GAAewN,EACf/yB,EAAI,GAAK,OACJ,GAAIA,EAAI,GAAKgzB,GAAOhzB,EAAI,GAAKgzB,GAAOhzB,EAAI,KAAOA,EAAI,GACxDulB,GAAesN,EAAeC,EAC9B9yB,EAAI,GAAK,EACTA,EAAI,GAAK,OACJ,GAAIA,EAAI,GAAKgzB,GAAOhzB,EAAI,GAAKgzB,GAAOhzB,EAAI,KAAOA,EAAI,GACxDulB,GAAesN,EAAeE,EAC9B/yB,EAAI,GAAK,EACTA,EAAI,GAAK,MACJ,MAAIA,EAAI,GAAKgzB,GAAOhzB,EAAI,GAAKgzB,GAAOhzB,EAAI,KAAOA,EAAI,IAKxD,MAJAulB,GAAeuN,EAAeC,EAC9B/yB,EAAI,GAAK,EACTA,EAAI,GAAK,CAGX,CAGF,OAAOulB,CACT,C,kCC5Ce,SAAS0N,EACtBC,GAEA,IAAIC,EAAWD,EAAkB91B,QAAQ,IAAK,KAS9C,OAPA+1B,EAAWA,EAAS/1B,QAAQ,IAAK,KACjC+1B,EAAWA,EAAS/1B,QAAQ,IAAK,KACjC+1B,EAAWA,EAAS/1B,QAAQ,IAAK,KACjC+1B,EAAWA,EAAS/1B,QAAQ,IAAK,KACjC+1B,EAAWA,EAAS/1B,QAAQ,IAAK,KACjC+1B,EAAWA,EAASC,cAEbD,CACT,C,uGClBA,SACEE,iBAAgB,I,uSCGlB,SACEC,6BAA4B,IAC5BC,kCAAiC,IACjCC,4BAA2B,IAC3BC,kCAAiC,IACjCC,wBAAuB,I,kDC6BV,SAAS5Z,EACtBtK,EACAmkB,EACAva,EACA/Y,GAEA,IAAIuzB,EAAMC,EAAMC,EAAMC,EAAMC,EAAMC,EAE9BC,EACJ,MAAM,SAAEC,GAAa3kB,EAYrB,GARE0kB,EADG1kB,EAAiC8I,cACtB9I,EAAiC8I,gBAEjC9I,EACXC,eACAC,aACAC,WAGAukB,EAEH,YADA9kB,QAAQC,KAAK,qCAAsCG,GAIrD,MAAM1O,EAAa0O,EAAUwP,gBAExB3e,IAQDuzB,EAAMC,IAAQC,EAAMC,IAAQC,EAAMC,IAAS5zB,GAP7CuzB,EAAO,EACPC,EAAO/yB,EAAW,GAClBgzB,EAAO,EACPC,EAAOjzB,EAAW,GAClBkzB,EAAO,EACPC,EAAOnzB,EAAW,IAKpB,MAAMszB,EAAQ,gBAAgBR,EAAME,EAAME,GAEpChvB,EAAYwK,EAAU6kB,eACtBC,EAAatvB,EAAU1L,MAAM,EAAG,GAChCi7B,EAAgBvvB,EAAU1L,MAAM,EAAG,GACnCk7B,EAAiBxvB,EAAU1L,MAAM,EAAG,GAEpC0f,EAAUxJ,EAAUilB,cACnBC,EAAYC,EAAeC,GAAmB5b,EAG/C6b,EAAgBrlB,EAAUslB,aAAaV,GAEvCW,EAAU,gBACdT,EAAW,GAAKI,EAChBJ,EAAW,GAAKI,EAChBJ,EAAW,GAAKI,GAGZM,EAAa,gBACjBT,EAAc,GAAKI,EACnBJ,EAAc,GAAKI,EACnBJ,EAAc,GAAKI,GAGfM,EAAe,gBACnBT,EAAe,GAAKI,EACpBJ,EAAe,GAAKI,EACpBJ,EAAe,GAAKI,GAGhBM,EACJf,GACAD,EAAW/6B,OAAS2H,EAAW,GAAKA,EAAW,GAAKA,EAAW,GAC3DqZ,EAAYrZ,EAAW,GAAKo0B,EAC5B9a,EAAYtZ,EAAW,GAAKqZ,EAE5B4G,EAAqC,GAErCoU,EAAa,WAAWN,GAE9B,IAAK,IAAI3Z,EAAI8Y,EAAM9Y,GAAK+Y,EAAM/Y,IAAK,CACjC,MAAMka,EAAY,WAAWD,GAE7B,IAAK,IAAIhnB,EAAI2lB,EAAM3lB,GAAK4lB,EAAM5lB,IAAK,CACjC,MAAMknB,EAAY,WAAWF,GAE7B,IAAK,IAAIj8B,EAAI06B,EAAM16B,GAAK26B,EAAM36B,IAAK,CACjC,MAAMsgB,EAAyB,CAACtgB,EAAGiV,EAAG+M,GAGtC,GAAIyY,EAAewB,EAA4B3b,GAAW,CACxD,MAAMhP,EAAQ0Q,EAAId,EAAYjM,EAAIgM,EAAYjhB,EAAIg8B,EAClD,IAAIvkB,EAEFA,EADEukB,EAAY,EACN,CACNhB,EAAW1pB,GACX0pB,EAAW1pB,EAAQ,GACnB0pB,EAAW1pB,EAAQ,IAGb0pB,EAAW1pB,GAGrBuW,EAAcpa,KAAK,CACjBgK,QACAnG,QACAgP,WACAH,SAAU8b,EAAW77B,UAEnB8f,GACFA,EAAS,CAAEzI,QAAOnG,QAAOgP,WAAUH,SAAU8b,GAEjD,CAGA,SAASA,EAAYA,EAAYJ,EACnC,CAGA,UAAUI,EAAYE,GACtB,SAASF,EAAYA,EAAYH,EACnC,CAGA,UAAUG,EAAYC,GACtB,SAASD,EAAYA,EAAYF,EACnC,CAEA,OAAOlU,CACT,C,8FC7JA,MAAM,sBAAEtC,GAA0B,YAiBnB,SAAS6W,EACtB9lB,EACAmP,EACAvF,EACAtiB,GAMA,MAAM,UAAEuJ,EAAS,YAAEue,EAAW,YAAEC,GAmBlC,SACEF,EACAnP,EACA1Y,GAMA,MAAO0gB,EAAQD,GAAOoH,EAGhBC,EAAc,iBACjBpH,EAAO,GAAKD,EAAI,IAAM,GACtBC,EAAO,GAAKD,EAAI,IAAM,GACtBC,EAAO,GAAKD,EAAI,IAAM,GAInBsH,EAAc,cAAcrH,EAAQD,GAAO,EAEjD,IAAIlX,EAEJ,IAAKvJ,EAAU,CAUb,MAAMy+B,EAAY9W,EAChBjP,EACAoP,GAGI4W,EAAWhmB,EAAUilB,aACrBgB,EAAa11B,KAAKU,OAAO+0B,GAEzBE,EAAe31B,KAAK41B,KAAK9W,EAAc4W,GAQ7C,OANAp1B,EAAY,CACV,CAACk1B,EAAU,GAAKG,EAAcH,EAAU,GAAKG,GAC7C,CAACH,EAAU,GAAKG,EAAcH,EAAU,GAAKG,GAC7C,CAACH,EAAU,GAAKG,EAAcH,EAAU,GAAKG,IAGxC,CACLr1B,YACAue,YAAaA,EACbC,cAEJ,CAUA,OARAxe,EAeF,SACEmP,EACA1Y,EACA6nB,EACAC,EACAC,GAEA,MAAOrH,EAAQD,GAAOoH,EAEhB7d,EAAa0O,EAAUwP,gBACvBna,EAAS/N,EAASgO,YAKlBma,EAAS,gBACbpa,EAAOoa,OAAO,GACdpa,EAAOoa,OAAO,GACdpa,EAAOoa,OAAO,IAEVhhB,EAAkB,gBACtB4G,EAAO5G,gBAAgB,GACvB4G,EAAO5G,gBAAgB,GACvB4G,EAAO5G,gBAAgB,IAEnBihB,EAAY,cAElB,WAAWA,EAAWD,EAAQhhB,GAQ9B,MAAM6gB,EAAe,cACfC,EAAmB,cAEzB,iBAAiBD,EAAcvH,EAAKtZ,EAAiB4gB,GACrD,iBAAiBE,EAAkBvH,EAAQvZ,GAAkB4gB,GAG7D,iBAAiBC,EAAcA,EAAcI,GAAYL,GACzD,iBAAiBE,EAAkBA,EAAkBG,EAAWL,GAIhE,MAAM+W,EAAmB,CACTnX,EAAsBjP,EAAyBsP,GAE3DL,EAAsBjP,EAAyBuP,IAK7C1e,GAAY,IAAAw1B,2BAA0BD,EAAkB90B,GAE9D,OAAOT,CACT,CAzEcif,CACV9P,EACA1Y,EACA6nB,EACAC,EACAC,GAGK,CACLxe,YACAue,YAAaA,EACbC,cAEJ,CAxFkDiX,CAC9CnX,EACAnP,EACA1Y,GAGIi/B,EAAY,CAChBpT,OAAQ/D,EACRoT,OAAQnT,IAGV,OACErP,GACC6J,IAAa,OAAc0c,EAAW1c,IACvCD,EACA/Y,EAEJ,C,iBCxDO,SAAS21B,EAAc58B,EAAO68B,EAAW,GAC9C,OACEC,WAAW98B,EAAM,IAAI+8B,QAAQF,GAC7B,IACAC,WAAW98B,EAAM,IAAI+8B,QAAQF,GAC7B,IACAC,WAAW98B,EAAM,IAAI+8B,QAAQF,GAC7B,GAEJ,C,sICCO,SAAStpB,EAAS1W,EAAQqrB,GAC/B,MAAM8U,EAAa,EAAN9U,EACb,GAAI8U,EAAOngC,EAAOkD,OAChB,OAAO,gBACLlD,EAAOmgC,GACPngC,EAAOmgC,EAAO,GACdngC,EAAOmgC,EAAO,GAGpB,CAOO,SAASC,EAAwBlqB,GACtC,MAAMmqB,EAAYnqB,EAASG,WAAWqD,UACtC,IAAI2R,EAAM,EACV,MAAMqQ,EAAe,IAAI1uB,IAGzB,KAAOqe,EAAMgV,EAAUn9B,QAAQ,CAC7B,MAAMo9B,EAAcD,EAAUhV,KACxBrR,EAAU,GAChB,IAAK,IAAI/W,EAAI,EAAGA,EAAIq9B,EAAar9B,IAC/B+W,EAAQtJ,KAAK2vB,EAAUhV,EAAMpoB,IAE/By4B,EAAa1qB,IAAIgJ,EAAQ,GAAIA,GAC7BqR,GAAOiV,CACT,CAEA,MAAMnpB,EAAW,GAGXopB,EAAqB55B,IACzB,IAAK,MAAO65B,EAAK9lB,KAAU/T,EAAIqQ,UAC7B,QAAc9U,IAAVwY,EACF,OAAO8lB,EAGX,OAAQ,CAAC,EAIX,IAAItK,EAAaqK,EAAkB7E,GACnC,MAAuB,IAAhBxF,GAAmB,CACxB,MAAM7hB,EAAU,CAAC6hB,GACjB,KAAOwF,EAAa/gB,IAAIub,IAAa,CACnC,MAAMuK,EAAY/E,EAAa7pB,IAAIqkB,GAAY,GAC3CwF,EAAa/gB,IAAI8lB,IACnBpsB,EAAQ3D,KAAK+vB,GAEf/E,EAAa5pB,OAAOokB,GACpBA,EAAauK,CACf,CACAtpB,EAASzG,KAAK2D,GACd6hB,EAAaqK,EAAkB7E,EACjC,CAEA,OAAOvkB,EAASjU,OAASiU,OAAWjV,CACtC,CAOO,SAASw+B,EAAkBxqB,GAChC,MAAMyqB,EAAkBP,EAAwBlqB,GAChD,IAAKyqB,EACH,OAGF,MAAMC,EAAgB1qB,EAASE,YAAYsD,UAC3C,OAAOinB,EAAgBh6B,KAAKk6B,GAC1BA,EAAel6B,KAAK4N,GAAUmC,EAASkqB,EAAersB,MAE1D,C,wECVA,QArEA,SACEqR,EACAkb,EACAh5B,EAAU,CAAC,GAEX,MAAMi5B,EAAe,GAkCrB,OAjCAnb,EAAYvZ,SAAS/M,IACnB,MAAM,KAAEO,GAASP,GACX,OAAEU,GAAWH,EAAKE,SAElB,UAAEwZ,EAAS,WAAE1O,GAAei2B,EAElC,IAAIE,EAAchhC,EAElB,GAAIH,EAAKohC,aAAaC,iBAAkB,CACtC,MAAM,iBAAEA,GAAqBrhC,EAAKohC,YAClCD,EAAc,GAAGG,UAAUD,EAC7B,CAEA,MAAME,EAAsBJ,EAAYr6B,KACrC06B,GAAU,kCAA8B9nB,EAAW8nB,KAEtD,IAAIj3B,GAAY,IAAAk3B,GACdF,EACAv2B,GAKE/C,EAAQuC,qBAAuBxK,EAAKohC,aAAaC,mBACnD92B,GAAY,OACVA,EACAtC,EAAQuC,qBAIZ02B,EAAarwB,KAAKtG,EAAU,IAGF,IAAxB22B,EAAa79B,OACR69B,EAAa,GAKJA,EAAatsB,QAC7B,CAAC8sB,EAAaC,KACL,CACL7D,KAAM7zB,KAAKU,IAAI+2B,EAAY5D,KAAM6D,EAAa7D,MAC9CE,KAAM/zB,KAAKU,IAAI+2B,EAAY1D,KAAM2D,EAAa3D,MAC9CE,KAAMj0B,KAAKU,IAAI+2B,EAAYxD,KAAMyD,EAAazD,MAC9CH,KAAM9zB,KAAKW,IAAI82B,EAAY3D,KAAM4D,EAAa5D,MAC9CE,KAAMh0B,KAAKW,IAAI82B,EAAYzD,KAAM0D,EAAa1D,MAC9CE,KAAMl0B,KAAKW,IAAI82B,EAAYvD,KAAMwD,EAAaxD,SAGlD,CACEL,KAAM3yB,IACN6yB,KAAM7yB,IACN+yB,KAAM/yB,IACN4yB,MAAO5yB,IACP8yB,MAAO9yB,IACPgzB,MAAOhzB,KAKb,C,oMCzEA,MAAM,QAAEkJ,GAAY,YAMdutB,EAAW,CAJH,gBAAgB,EAAG,EAAG,GACtB,gBAAgB,EAAG,EAAG,GACtB,gBAAgB,EAAG,EAAG,IAUpC,SAASC,EAAuBN,GAC9B,MAAMO,EAAgB,cACpB,cACAP,EAAoB,GACpBA,EAAoB,IAGhBQ,EAAgB,cACpB,cACAR,EAAoB,GACpBA,EAAoB,IAiBtB,MARkB,IALCS,EAAwBF,EAAeF,MACvCI,EAAwBD,EAAeH,IAIT1G,OAC9C+G,GACC5tB,EAAQ4tB,EAAO,IACf5tB,EAAQ4tB,EAAO,KACf5tB,EAAQ4tB,EAAO,MACf5tB,EAAQ4tB,EAAO,MAIrB,CAGA,SAASD,EAAwBE,EAAKC,GACpC,OAAOA,EAAKr7B,KAAKs7B,GAAkC,IAAxB,WAAWF,EAAKE,GAAen4B,KAAKo4B,IACjE,C,kDC9Be,SAASp0B,EACtBjN,EACAiH,GAKA,KAFuB,IAAAjF,mBAAkBhC,EAASI,SAGhD,MAAM,IAAIyH,MAAM,0DAGlB,GACE7H,aAAoB,EAAA2H,eACc,IAAlC3H,EAAS0I,cAAcrG,OAEvB,MAAM,IAAIwF,MAAM,wCAGlB,MAAM,SAAErE,EAAQ,MAAE0J,EAAK,YAAEo0B,GAAgBr6B,EAErCjH,aAAoB,EAAAuN,eAWnB,SACLvN,EACAwD,EACA0J,EACAo0B,GAAc,GAEd,MAAMC,EAAmBD,GAEnB,eAAE10B,EAAc,iBAAEC,EAAgB,eAAE20B,GACxC,wCAAoCxhC,EAAUwD,EAAU+9B,GAE1D,IAAKC,EACH,OAGF,MAAM,WAAEC,EAAU,yBAAEC,EAAwB,OAAE3zB,GAAWyzB,GACnD,WAAEG,EAAU,gBAAEx6B,EAAe,SAAEysB,GAAa7lB,GAE5C,cAAE6zB,EAAa,YAAEC,GAAgB,kCACrCF,EACA/N,EACA6N,EACAt6B,EACAu6B,EACAx0B,GAGFlN,EAAS8hC,UAAU,CACjBH,WAAYC,EACZhO,SAAUiO,IAEZ7hC,EAAS+hC,SAET,MAAMC,EAAmBn1B,EAAmBK,EAEtC+0B,EACJ,CACEz+B,WACAxD,WACAkN,QACA80B,mBACAn1B,mBACAD,iBACAs1B,eAAgBliC,EAASklB,sBAI1B8c,EAAmBp1B,GAAkBo1B,EAAmB,IACzDhiC,EAASklB,oBAKT,yBACE,EAAAte,YACA,EAAAu7B,OAAOC,4BACPH,GAGF,yBACE,EAAAr7B,YACA,EAAAu7B,OAAOE,uBACPJ,EAGN,CA3EIK,CAAatiC,EAAUwD,EAAU0J,EAAOo0B,GAEvCthC,EAAkCiN,OACjCC,EACAjG,EAAQoG,gBACRpG,EAAQoI,KAGd,C,8HC5BA,MAAM,OAAEkzB,GAAW,YAEbC,EAA8B,CAClC,IAAYC,eACZ,IAAYC,sBAGC,MAAMjmB,SACZ,KAAAkmB,UAAY,EAAG,CAEtB,cAAOC,CAAQ9jC,GACRC,KAAK4jC,UAAUl3B,SAAS3M,IAC3BC,KAAK4jC,UAAU9yB,KAAK/Q,EAExB,CA4BA,0BAAO4d,CACLH,EACAC,EAAwC,CAAC,GAEzC,MAAM,UAAEmmB,EAAS,eAAE/wB,EAAc,aAAEC,EAAY,WAAE6H,GAAe8C,EAChE,IAAK,MAAM1d,KAAY6jC,GAAalmB,EAAqBkmB,UAAW,CAClE,MAAM5d,EAAc,uBAClBjmB,EACAyd,GAEF,GAAKwI,GAAa1iB,OAGlB,IAAK,MAAM5D,KAAcsmB,EAAa,CACpC,MAAM,iBAAE8d,EAAgB,KAAE7jC,EAAI,cAAEsI,EAAa,SAAEzI,GAAaJ,EACxDokC,IACFpkC,EAAWqkC,wBAAyB,GAEjCx7B,IAGDuK,GAAgBA,IAAiB7S,EAAK2S,aAAaE,mBAItCxQ,IAAfqY,GACA7a,GACA6a,IAAe7a,EAAS6a,YAKxB9H,GACAA,IAAmB5S,EAAK2S,aAAaC,kBAIvC,OAAiCnT,GACjCA,EAAW6I,eAAgB,GAC7B,CACF,CACF,QAOO,KAAAy7B,0BAA6BriC,IAClC,MAAMjC,EAAaiC,EAAIG,OAAOpC,WAC9B,IAAKA,GAAYI,SACf,OAEF,MAAM,SAAEC,EAAQ,iBAAEkkC,GAAqBvkC,EAAWI,SAElD,IACGE,KAAK4jC,UAAUl3B,SAAS3M,KACxBC,KAAK4jC,UAAUl3B,SAASu3B,GAEzB,OAGF,MAAMhjC,GAAW,OAAyBvB,GAC1C,IAAKuB,EAEH,YADAsY,QAAQC,KAAK,8BAA+B9Z,GAG9C,MACMwkC,EAA0C,CAC9CjjC,WACAkjC,UAHsCC,EAAanjC,GAInDvB,aACAokC,iBAAkBpkC,EAAWokC,kBAEzBO,IAAwB3kC,EAAWokC,iBAGzC,GADApkC,EAAW6I,eAAgB,EACvB87B,EAKF,OAFA,OAAyBH,QACzB,OAAYA,GAGd,MAAMI,EAAa,CACjB,CACE1D,IAAK,eACL9lB,MAAOpb,EAAWO,KAAK2S,aAAaE,aACpCyxB,UAAY7kC,GAAeA,EAAWO,KAAK2S,cAE7C,CACEguB,IAAK,kBACL9lB,MAAOpb,EAAWI,SAASsI,gBAC3Bm8B,UAAY7kC,GAAeA,EAAWI,UAExC,CACE8gC,IAAK,SACL9lB,MAAOpb,EAAWI,SAASspB,OAC3Bmb,UAAY7kC,GAAeA,EAAWI,WAG1C,IAAI0kC,GAA2B,OAC7BN,EACAI,GAGF,MAAM,WAAE3pB,GAAejb,EAAWI,SAC5B2kC,EAAW,IAAIrxB,IACrBoxB,EAAyB/3B,SAASi4B,IAChC,GACEA,EAAwBX,wBACxBW,EAAwB5kC,SAAS6a,aAAeA,EAChD,CACA,MAAM,iBAAEmpB,GAAqBY,EAC7BD,EAASl4B,IAAIu3B,EACf,KAEFU,EAA2BA,EAAyBpyB,QACjDsyB,IACED,EAAS1pB,IAAI2pB,EAAwBZ,oBAI1CpkC,EAAWokC,iBACTU,EAAyB,IAAIV,kBAAoBN,IACnDU,EAAaJ,iBAAmBpkC,EAAWokC,kBAC3C,OAAYI,EAAa,CACzB,QAMK,KAAAS,uBAA0BhjC,IAC/B,MAAMjC,EAAaiC,EAAIG,OAAOpC,YACxB,WAAEklC,EAAa,IAAYlB,gBAAmB/hC,EAAIG,OACxD,IAAKpC,GAAYI,SACf,OAEF,MAAM,SAAEC,EAAQ,iBAAEkkC,GAAqBvkC,EAAWI,SAElD,IACIE,KAAK4jC,UAAUl3B,SAAS3M,KACvBC,KAAK4jC,UAAUl3B,SAASu3B,KAC1BR,EAA4B/2B,SAASk4B,GAEtC,OAEF,MAAM3jC,GAAW,OAAyBvB,GAC1C,IAAKuB,EAKH,YAJAsY,QAAQC,KACN,gEACA9Z,GAIAA,EAAW6I,iBAGb,OAAiC7I,GACjCA,EAAW6I,eAAgB,GAG7B,MACM27B,EAA0C,CAC9CjjC,WACAkjC,UAHsCC,EAAanjC,GAInDvB,aACAokC,iBAAkBpkC,EAAWokC,iBAC7Be,sBAAuBD,IAAe,IAAYjB,uBAEpD,OAAYO,EAAa,CACzB,QAKK,KAAAY,uBAA0BnjC,IAC/B,MAAMjC,EAAaiC,EAAIG,OAAOpC,WAC9B,IAAKA,GAAYI,SACf,OAEF,MAAM,SAAEC,GAAaL,EAAWI,SAEhC,IAAKE,KAAK4jC,UAAUl3B,SAAS3M,IAAaL,EAAW6I,cACnD,OAEF,MAAMtH,GAAW,OAAyBvB,GAE1C,IAAKuB,EAKH,YAJAsY,QAAQC,KACN,iDACA9Z,GAKJ,MACMwkC,EAA0C,CAC9CjjC,WACAkjC,UAHsCC,EAAanjC,GAInDvB,aACAokC,iBAAkBpkC,EAAWokC,kBAG/BpkC,EAAW6I,eAAgB,GAC3B,OAAyB27B,EAAa,CACtC,EAGJ,SAASE,EAAanjC,GAKpB,MAJwC,CACtC8jC,eAAgB9jC,EAAS+jC,oBACzB3c,WAAYpnB,EAASgkC,yBAGzB,C,qECjRO,SAASC,EACdC,EACAC,GAIA,QAAkB9iC,KAFA,IAAA+iC,cAAaF,GAG7B,QAG8B,QAAsBA,GAE9B14B,SAASsZ,IAC/BA,EAAKpjB,cAAc2iC,8BAA8BC,QAAQH,mBACvDA,CAAkB,GAExB,CAEO,SAASI,EAA4BL,GAC1C,MAAMzf,GAAY,IAAA2f,cAAaF,GAE/B,QAAkB7iC,IAAdojB,EACF,OAGF,MAAM+f,EAAgB/f,EAAUC,eAEhC,IAAKqW,OAAO/Z,KAAKwjB,GAAeniC,OAC9B,OAGF,MACMoiC,GAD0B,QAAsBP,GACJ,GAElD,OAAKO,EAIEA,EAAkB/iC,cAAc2iC,8BAA8BC,QAClEH,wBALH,CAMF,C,2FCjCO,SAASO,EACdR,EACAS,EACA7lC,GAEA,MAAM2lB,GAAY,IAAA2f,cAAaF,GAE/B,QAAkB7iC,IAAdojB,EACF,QAG8B,QAAsByf,EAAaplC,GAE3C0M,SAASsZ,IAC/BA,EAAKpjB,cAAcijC,UAAYA,EAG/B7f,EAAK8f,uBAAuB,IAI9B,MAAMC,EAAgBpgB,EAAUqgB,mBAE1BC,EAAqBhK,OAAO/Z,KAAK6jB,GAAe/+B,KACnD65B,GAAQkF,EAAclF,KAGzB,IAAKoF,EAAmB1iC,OACtB,OAGF,MAAM,kBAAEmiB,GAAsBugB,EAAmB,GAI3CC,EAAcvgB,EAAUwgB,iBAExBj6B,GAAkB,IAAAk6B,oBAAmB1gB,IAE3C,OAAsCxZ,EAAiBg6B,EACzD,CASO,SAASG,EACdjB,EACAplC,GAEA,MAAM2lB,GAAY,IAAA2f,cAAaF,GAE/B,QAAkB7iC,IAAdojB,EACF,OAGF,MAAM+f,EAAgB/f,EAAUC,eAEhC,IAAKqW,OAAO/Z,KAAKwjB,GAAeniC,OAC9B,OAGF,MAGMoiC,GAH0B,QAAsBP,EAAaplC,GAGjB,GAElD,OAAK2lC,EAKEA,EAAkB/iC,cAAcijC,eALvC,CAMF,C,qECnFO,SAASS,EACdlB,EACAmB,EACAC,EAAqC,CAAEC,WAAW,IAIlD,QAAkBlkC,KAFA,IAAA+iC,cAAaF,GAG7B,OAGF,MAAMsB,GAA0B,QAAsBtB,GAChDxiC,EAAgB,IACjB4jC,UACejkC,IAAdgkC,GAA2B,CAAEA,cAGnCG,EAAwBh6B,SAASsZ,IAC/BA,EAAKpjB,cAAc2iC,8BAA8BoB,UAAY,IACxD3gB,EAAKpjB,cAAc2iC,8BAA8BoB,aACjD/jC,EACJ,GAEL,CAEO,SAASgkC,EAA8BxB,GAC5C,MAAMzf,GAAY,IAAA2f,cAAaF,GAE/B,QAAkB7iC,IAAdojB,EACF,OAGF,MAAM+f,EAAgB/f,EAAUC,eAEhC,IAAKqW,OAAO/Z,KAAKwjB,GAAeniC,OAC9B,OAGF,MACMoiC,GAD0B,QAAsBP,GACJ,GAElD,OAAKO,EAIEA,EAAkB/iC,cAAc2iC,8BAA8BoB,UAClEJ,eALH,CAMF,C,mFC7Ce,SAASM,EACtB5yB,EACAC,EACA4yB,GAEA,MAAMC,EAAOD,EAAYE,MAAM/yB,GACzBgzB,EAAOH,EAAYE,MAAM9yB,GACzBgzB,EAAY,eACZ,QAAEC,GAAYL,EACd14B,EAAQ,SAAS,cAAe24B,EAAME,GAItCG,EAAWj9B,KAAKk9B,MAAMl9B,KAAKW,OAAOsD,EAAMpH,IAAImD,KAAKC,OACvD,GAAIg9B,EAAW,EAEb,OAAO,EAET,MAAME,EAAY,WAAW,cAAel5B,EAAO,EAAIg5B,GAEvD,IAAK,IAAI9jC,EAAI,EAAGA,EAAI8jC,EAAU9jC,IAE5B,GADA,iBAAiB4jC,EAAWD,EAAMK,EAAWhkC,IACxC6jC,EAAQD,GACX,OAAO,EAGX,OAAO,CACT,CC9BA,MAAMn8B,EAAU,IAqBD,SAASw8B,EACtB/vB,EACA8B,EACAe,GAEA,MAAM,cAAEC,GAAkB9C,GACpB,aAAEzE,EAAY,wBAAE4H,GAA4BN,EAClD,IAAImtB,EACJ,MAAMV,EDOR,SACExtB,EACAvG,EACA4H,GAGA,MAAMpB,EAAM,EAAA3U,MAAMC,UAAUyU,GAC5B,IAAKC,EAEH,YADAC,QAAQC,KAAK,uBAAuBH,KAItC,MAAMK,EAAUJ,EAAIK,UAAUC,eAAeC,aAAaC,UACpD8hB,EAAQtiB,EAAIrO,WAAW,GACvB8O,EAAiB6hB,EAAQtiB,EAAIrO,WAAW,GAE9C,MAAO,CAKLu8B,WAAY,CAACxzB,EAAQC,KACnB,MAAM1Q,EAAQ,SAAS,cAAeyQ,EAAQC,GAAQlN,KAAKC,GAAOA,EAAK,IACjEygC,EAAMnuB,EAAIK,UAAU0K,aAAa9gB,GAAewD,IAAImD,KAAKk9B,QACxD/jC,EAAGiV,EAAG+M,GAAKoiB,EAEZ3sB,EAAQpB,EADArW,EAAIiV,EAAIsjB,EAAQvW,EAAItL,GAElC,OAAOe,IAAUhI,GAAgB4H,GAAyBK,IAAID,EAAM,EAGtEisB,MAAQxjC,GAAU+V,EAAIK,UAAU0K,aAAa9gB,GAE7C2jC,QAAUO,IACR,MAAOpkC,EAAGiV,EAAG+M,GAAKoiB,EACZ9yB,EACJzK,KAAKk9B,MAAM/jC,GAAK6G,KAAKk9B,MAAM9uB,GAAKsjB,EAAQ1xB,KAAKk9B,MAAM/hB,GAAKtL,EACpDe,EAAQpB,EAAQ/E,GACtB,OAAOmG,IAAUhI,GAAgB4H,GAAyBK,IAAID,EAAM,EAG1E,CC/CsB4sB,CAClBruB,EACAvG,EACA4H,GAEF,IAAK,MAAMitB,KAAgBttB,EAAe,CACxC,MAAMutB,EAAgBC,EACpBF,EACAd,EACAU,GAEGK,IAGLL,EAAmBK,EACrB,CAIA,OAHIL,GACFvL,OAAO8L,OAAOP,EAAkBntB,GAE3BmtB,CACT,CAWA,SAASM,EACPF,EACAd,EACAkB,EAAa,CAAEC,SAAU,EAAGC,SAAU,IAEtC,MAAM,OAAE7nC,GAAWunC,EAAarxB,UACxB2xB,SAAUC,EAAiBF,SAAUG,GAAoBJ,EACjE,IAEIK,EAFAJ,EAAWG,EAAkBA,EAC7BF,EAAWC,EAAkBA,EAEjC,IAAK,IAAIG,EAAS,EAAGA,EAASjoC,EAAOkD,OAAQ+kC,IAC3C,IAAK,IAAIC,EAASD,EAAS,EAAGC,EAASloC,EAAOkD,OAAQglC,IAAU,CAC9D,MAAMt0B,EAAS5T,EAAOioC,GAChBp0B,EAAS7T,EAAOkoC,GAChBC,EAAY,aAAav0B,EAAQC,GACnCs0B,EAAYP,IAGZO,EAAYz9B,EAAUk9B,EAAWl9B,GAAWs9B,GAK3CvB,EAAYW,WAAWxzB,EAAQC,IAK/B2yB,EAAgB5yB,EAAQC,EAAQ4yB,KAIrCmB,EAAWO,EAAYz9B,EACvBs9B,EAAiB,CAACC,EAAQC,GAC1BL,EAAW,GACb,CAEF,IAAKG,EACH,OAGFJ,EAAW99B,KAAKgK,KAAK8zB,EAAWl9B,GAChC,MAAM09B,EAAUpoC,EAAOgoC,EAAe,IAChCK,EAAUroC,EAAOgoC,EAAe,IAChCM,EAAY,SAAS,cAAeF,EAASC,GAGnD,IAAIE,EAFJ,WAAWD,EAAWA,EAAW,EAAIV,GAIrC,IAAK,IAAIK,EAAS,EAAGA,EAASjoC,EAAOkD,OAAQ+kC,IAC3C,IAAK,IAAIC,EAASD,EAAS,EAAGC,EAASloC,EAAOkD,OAAQglC,IAAU,CAC9D,MAAMt0B,EAAS5T,EAAOioC,GAChBp0B,EAAS7T,EAAOkoC,GAChBC,EAAY,aAAav0B,EAAQC,GACvC,GAAIs0B,GAAaN,EACf,SAEF,MAAM95B,EAAQ,SAAS,cAAe6F,EAAQC,GAElC/J,KAAKC,IAAI,SAASgE,EAAOu6B,IAAcx+B,KAAKgK,KAAKq0B,GACnDz9B,GAIL+7B,EAAYW,WAAWxzB,EAAQC,IAK/B2yB,EAAgB5yB,EAAQC,EAAQ4yB,KAGrCoB,EAAWM,EACXI,EAAiB,CAACN,EAAQC,GAC5B,CAGF,IAAKK,EAEH,OAEFV,EAAW/9B,KAAKgK,KAAK+zB,GAWrB,MAPsB,CACpBW,UAAW,CAACJ,EAASC,GACrBI,UAAW,CALGzoC,EAAOuoC,EAAe,IACtBvoC,EAAOuoC,EAAe,KAKpCX,WACAC,cACGN,EAGP,CC1JA,MAAM,SAAE3uB,GAAaC,EAAA,QAYN,SAAS6vB,EAAmCl2B,GACzD,MAAM2E,GAAW,IAAA2B,iCAAgC,CAC/CC,cAAevG,IAGjB,IAAK2E,GAAUjU,SAAWiU,EAAS,GAAG8C,cAAc/W,OAClD,OAGF,MAAM,mBACJ0P,EAAkB,SAClBoG,EAAW,CACT,KACA,CAAEtY,MAAO,cAAekD,MAAO,KAAM0W,wBAAyB,QAE9D9H,GACInO,SAAU4U,GAAgBrG,EAAmBgG,GAE/ClG,EAAesG,EAASzO,WAAW3D,KAASA,IAClD,OAAsB,IAAlB8L,GAGJsG,EAAStG,GAAcA,aAAeA,EAC/Bw0B,EACL/vB,EAAS,GACT8B,EACAD,EAAStG,UAPX,CASF,C,kBCzBe,SAASi2B,EACtBC,EACA/nC,GAEA,MAAM,UAAE2nC,EAAS,UAAEC,EAAS,MAAE/nC,EAAQ,GAAE,WAAE6Z,GAAequB,GAClDC,EAAQC,GAAUN,GAClBO,EAAQC,GAAUP,EAEnBzoC,EAAS,CAAC6oC,EAAQC,EAAQC,EAAQC,GA+BxC,MA9B8B,CAC5BxpC,aAAa,EACbC,aAAa,EACbC,SAAU,CACRC,SAAU,mBAGPkB,EAASC,iBAAiB,CAAEyZ,gBAEjC1a,KAAM,CACJE,QAAS,CACPC,SACAE,QAAS,CACPC,UAAU,EACVC,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CAChBC,QAAS,CAAC,EAAG,EAAG,GAChBC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnBC,YAAa,CAAC,EAAG,EAAG,KAGxBwB,kBAAmB,MAErBvB,QACAugC,YAAa,CAAC,GAEhB74B,UAAU,EACVC,WAAW,EAGf,C,kCClDA,SAAS4gC,EACPC,EACAC,GAQA,OAN4B,IAAIn8B,IAC9Bk8B,EAAcviC,KAAI,CAACxC,EAASoQ,IACnB,CAACpQ,EAASglC,EAAqB50B,MAK5C,C,sFCAe60B,eAAeC,EAAgCC,GAiB5D,MAAM,WAAE38B,EAAU,kBAAE0Y,EAAiB,QAAEvd,GAAYwhC,EACnD,IAAI,eAAE72B,GAAmB62B,EACzB,MAAM1mC,GAAiB,IAAA2mC,wBAAuB58B,EAAY0Y,GAE1D,IAAKziB,EACH,MAAM,IAAI8F,MAAM,oBAGlB,MAAM,SAAE7H,GAAa+B,EACrB,KAAM/B,aAAoB,EAAAuN,gBACxB,MAAM,IAAI1F,MAAM,6CAGlB,MAAM,IAAEQ,GAAQrI,EAAS2oC,kBASzB,QAPuBtnC,IAAnBuQ,IAEFA,EAAiB,GAAGvJ,wBAClBpB,GAASzD,UAAY,qBAAiBhB,MAAM,EAAG,MAI/CyE,EAAS,CAGX,MAAM2hC,EAAa,IAAU3hC,SACvB,EAAA4hC,aAAA,kBAA+BD,EAAYh3B,EACnD,KAAO,CAEL,MAAQvJ,IAAK7E,GAAaxD,EAAS2oC,wBAC7B,EAAAE,aAAA,wCAAqDrlC,EAAU,CACnEA,SAAUoO,GAEd,CAEA,OAAOA,CACT,C,kDCTA,QAlDA,SACEk3B,EACAj3B,EAAe,EACfrO,EAAW,kBAEXslC,EAAUt9B,SAAQ,EAAG0C,YAAWlE,aAAY++B,SAAQ7mB,cAClD,KACG,oBAAgBlY,EAAY8+B,EAAU,GAAG9+B,aACzC,oBAAgBkE,EAAW46B,EAAU,GAAG56B,YACxC,oBAAgBgU,EAAS4mB,EAAU,GAAG5mB,UACtC,oBAAgB6mB,EAAQD,EAAU,GAAGC,SAEtC,MAAM,IAAIlhC,MAAM,8CAClB,IAGF,MAAMmhC,EAAWF,EAAU,GAGrBG,EAAa,IAAIC,EADJF,EAASxnB,gBAAwBnhB,aACnB2oC,EAASxnB,gBAAgBnf,QAE1DymC,EAAUt9B,SAASw9B,IACjB,MAAM5L,EAAa4L,EAASxnB,gBAC5B,IAAK,IAAIpf,EAAI,EAAGA,EAAIg7B,EAAW/6B,OAAQD,IACjCg7B,EAAWh7B,KAAOyP,IACpBo3B,EAAW7mC,GAAKyP,EAEpB,IAGF,MAAM5K,EAAU,CACdm2B,WAAY6L,EACZpqC,SAAUmqC,EAASnqC,SACnBqjB,QAAS8mB,EAAS9mB,QAClB6mB,OAAQC,EAASD,OACjB76B,UAAW86B,EAAS96B,UACpBlE,WAAYg/B,EAASh/B,YAWvB,OANqB,EAAA6+B,aAAA,kBACnB5hC,EACAzD,GAJmB,EASvB,C,iBCyIA,SAAS2lC,EAAKC,EAAQC,EAAWhnC,GAI/B,OAHc,IAAIjD,MAAMiD,EAAS,GACfinC,KAAKD,GAETD,GAAQ5mC,OAAOH,EAC/B,C,iBAEA,QAjLA,SACEknC,EACAC,EACAviC,EAA4B,CAAC,GAE7B,MAAMwiC,EAAUxiC,EAAQwiC,QAClBC,EAAaziC,EAAQyiC,WACrBC,EAAS1iC,EAAQ0iC,OACjBC,EAAY3iC,EAAQ2iC,YAAa,EACjCC,EAAY74B,EAAIw4B,GAChBM,EA6GN,WACE,MAAMA,EASR,SAAiBznC,GACf,MAAM0nC,EAAQ,GAERC,EAAc,SAAUZ,GAC5B,OAAOA,EAAOvjC,MAAM,IAAIC,KAAI,SAAUy1B,GACpC,OAAO0O,SAAS1O,EAAG,IAAM,CAC3B,GACF,EAEA,IAAK,IAAIn5B,EAAI,EAAGA,EAAI6G,KAAKiK,IAAI,EAAG7Q,GAASD,GAAK,EAAG,CAC/C,MAAMgnC,EAASD,EAAK/mC,EAAE8nC,SAAS,GAAI,IAAK7nC,GAExC0nC,EAAMl6B,KAAKm6B,EAAYZ,GACzB,CAEA,OAAOW,CACT,CAzBuBI,CAAQX,EAAKnnC,QAElC,OAAOynC,EAAa34B,QAAO,SAAUi5B,GACnC,MAAMvnB,EAmCZ,SAAwBoI,GACtB,IAAIpI,EAAQ,EAEZ,IAAK,IAAIzgB,EAAI,EAAGA,EAAI6oB,EAAM5oB,OAAQD,GAAK,EACpB,IAAb6oB,EAAM7oB,KACRygB,GAAS,GAIb,OAAOA,CACT,CA7CoBwnB,CAAeD,GAE7B,OAAiB,IAAVvnB,IAA0B,IAAVA,GAAe+mB,EACxC,GACF,CArHqBU,GACfC,EAAQ,GACRC,EAAU,GACVC,EAAS,IAAIt4B,IACbu4B,EAAS,IAAIv+B,IAInB,IAFAo+B,EAAM16B,KAAK,CAAE86B,YAAanB,IAEnBe,EAAMloC,OAAS,GACpBuoC,EAAML,EAAMjU,OAGd,MAAO,CACLkU,UACAK,WA2HF,WACE,MAAM5f,EAAQ7rB,MAAM0rC,KAAKJ,EAAO5oB,UAEhC,OADAmJ,EAAM7b,UACC6b,CACT,CA/Hc4f,IAGd,SAASD,EAAMG,GACb,MAAMC,EAAUD,EAAIJ,YACdM,EAAWF,EAAIG,cAmBvB,SAAiBvL,GACf,MAAOxxB,EAAGgJ,EAAG4B,EAAI,GAAK4mB,EAGhBwL,EAAOh9B,EAAI,MAAQ,OAASgJ,EAAI,MAAQ,OAAS4B,EAAI,QAC3D,OAAO0xB,EAAO3wB,IAAIqxB,EACpB,EAvBMpX,CAAQiX,KAyBd,SAAuBrL,GACrB,MAAOxxB,EAAGgJ,EAAG4B,EAAI,GAAK4mB,EAChBwL,EAAOh9B,EAAI,MAAQ,OAASgJ,EAAI,MAAQ,OAAS4B,EAAI,QAC3D0xB,EAAOn/B,IAAI6/B,EACb,CA1BEC,CAAcJ,GA4BhB,SAAgBA,GACd,MAAMK,EAAOr6B,EAAIg6B,GAEjB,OAAOrB,EAASA,EAAO0B,EAAMxB,GAAawB,IAASxB,CACrD,CA9BMyB,CAAON,IAgCb,SAAuBA,GACrBR,EAAQ36B,KAAKm7B,GACTvB,GAEFA,KAAWuB,EAEf,CArCIO,CAAcP,GAmDlB,SAAsBA,GACpB,IAAK,IAAI5oC,EAAI,EAAGA,EAAI0nC,EAAaznC,OAAQD,GAAK,EAAG,CAC/C,MAAMgoC,EAAON,EAAa1nC,GACpBopC,EAAWR,EAAQxoC,MAAM,GAE/B,IAAK,IAAI6U,EAAI,EAAGA,EAAI2zB,EAAQ3oC,OAAQgV,GAAK,EACvCm0B,EAASn0B,IAAM+yB,EAAK/yB,GAGtBkzB,EAAM16B,KAAK,CACT86B,YAAaa,EACbN,aAAcF,GAElB,CACF,CAhEIS,CAAaT,IAsCjB,SAAwBC,GACtB,MAAO98B,EAAGgJ,EAAG4B,EAAI,GAAKkyB,EAGhBE,EAAOh9B,EAAI,MAAQ,OAASgJ,EAAI,MAAQ,OAAS4B,EAAI,QAC3D2xB,EAAOv6B,IAAIg7B,EAAMF,GACbvB,GAEFA,KAAcuB,EAElB,CA9CIS,CAAeT,GAEnB,CA8DA,SAASj6B,EAAIg6B,GAEX,OAAOzB,KAAUyB,EACnB,CA6CF,C,4DC5Ke,SAASW,EACtBh6B,GAEA,MAAQzG,KAAM0gC,GAAuBj6B,EACrC,GAAQi6B,IACD,UAA2B7zB,SAC9B,OAAO,SAEP,MAAM,IAAIlQ,MAAM,gCAAgC+jC,IAEtD,C,4DCVO,SAASC,EAAwCj6B,GACtD,MAAMD,GAAe,IAAAG,iBAAgBF,IAC/B,kBAAEK,GAAsBN,EAAaI,mBAAmBC,QAE9D,IAAK,MAAOH,EAAci6B,KAAmB75B,EAAkBkE,UAAW,CAKxE,GAJiC/W,MAAM0rC,KAAKgB,GAAgB7jC,MACzDvJ,IAAkB,QAAcA,GAAeC,cAIhD,OAAOkT,CAEX,CAGF,C,wECGO,SAASk6B,EACdn6B,EACAo6B,GACA,SAAEhsC,EAAQ,aAAEisC,IAEZ,MAAMt6B,GAAe,IAAAG,iBAAgBF,GAE/Bs6B,EAAev6B,EAAaI,mBAAmBo6B,SAErD,IAAI,OAAqBD,GAAe,CACtC,MAAM,SAAE1oC,GAAa0oC,EACf/qB,EAAqB,EAAAzd,MAAMC,UAAUH,GAE3C,IAAK2d,EACH,OAGF,MAAMzI,EAAYyI,EAAmBzI,UAE/B7G,EAAe6G,EAAU0zB,wBAAwBJ,GAIjDK,EAkHV,SACE/nB,EACAzS,EACA7R,EACA0Y,EACAuzB,GAEA,MAAMK,EAAmB,CAACC,EAAgBC,KACxC,MAAMC,EAAiB,CAACnoB,EAAY,GAAKioB,EAAQjoB,EAAY,GAAKkoB,GAE5DR,EAAahsC,EAAS8c,cAAc2vB,GAC1C,OAAO/zB,EAAU0zB,wBAAwBJ,EAAW,EAGtD,OAAOU,EAAgBJ,EAAkBz6B,EAAco6B,EACzD,CAjImBU,CAFK3sC,EAASmC,cAAc6pC,GAIzCn6B,EACA7R,EACA0Y,EACAuzB,GAGF,OAAOI,EAASx6B,OAAexQ,CACjC,CAGA,MAAM,oBAAEurC,GAAwBV,EAE1BhK,EAAkBliC,EAAkCklB,oBAEpD2nB,EAAsBD,EAAoB57B,IAAIkxB,GAGpD,IAFc,EAAAx+B,MAAMopC,SAASD,GAG3B,OAMF,MAAME,GAA8B,IAAAC,kCAClCr7B,EAAaC,iBAGT,8BAAEq7B,GAAkCF,EAA4B,GAChEG,EAAoBltC,EAASmtC,SAASF,GACtCv0B,EAAYw0B,GAAmB/kC,MAAMilC,YAAYC,eACjDC,EAAW,EAAAjmC,UAAA,sBAAgCqR,EAAWszB,GAEtDhiC,EAAa0O,EAAUwP,gBACvBqlB,EAAgB70B,EAAU60B,cAC9B,EAAAlmC,UAAA,aAAuBmmC,yBACrBxjC,EACA0O,EAAUC,eAAeC,aAAaC,WAGpChH,EAAe07B,EAAaE,cAAcH,GAE1CjB,EAkDR,SACEiB,EACAtjC,EACAujC,EACA17B,EACAo6B,GAEA,MAAMK,EAAmB,CAACC,EAAgBC,EAAgBkB,KACxD,MAAMC,EAAc,CAClBL,EAAS,GAAKf,EACde,EAAS,GAAKd,EACdc,EAAS,GAAKI,GAGhB,OAAOH,EAAaK,YAAYD,EAAY,EAG9C,OAAOjB,EAAgBJ,EAAkBz6B,EAAco6B,EACzD,CApEiB4B,CACbP,EACAtjC,EACAujC,EACA17B,GAGF,OAAOw6B,EAASx6B,OAAexQ,CACjC,CASA,SAASqrC,EACPJ,EAKAz6B,EACAo6B,EAAe,GAEf,MAAM6B,EAAgB1uC,MAAM0rC,KAC1B,CAAEzoC,OAAQ,EAAI4pC,EAAe,IAC7B,CAACr2B,EAAGxT,IAAMA,EAAI6pC,IAGhB,IAAK,MAAMM,KAAUuB,EACnB,IAAK,MAAMtB,KAAUsB,EACnB,IAAK,MAAMJ,KAAUI,EAAe,CAClC,GAAe,IAAXvB,GAA2B,IAAXC,GAA2B,IAAXkB,EAClC,SAGF,MAAMK,EAAgBzB,EAAiBC,EAAQC,EAAQkB,GAEvD,QAAsBrsC,IAAlB0sC,GAA+Bl8B,IAAiBk8B,EAClD,OAAO,CAEX,CAIJ,OAAO,CACT,C,0GClHO,SAASC,EACdp8B,EACAo6B,EACA/kC,EAAU,CAAC,GAEX,MAAM0K,GAAe,IAAAG,iBAAgBF,GAE/BG,EAAqBJ,EAAaI,mBAGlCk8B,EACJhnC,GAAS2kC,oBAAsB7Q,OAAO/Z,KAAKjP,GAAoB,GAEjE,IAAKk8B,EACH,MAAM,IAAIpmC,MACR,gBAAgB+J,uCAIpB,OAAQq8B,GACN,KAAK,EAAAj2B,4BAA4BD,SAC/B,OAgBC,SACLpG,EACAq6B,GACA,SAAEhsC,IAEF,MAAMksC,EAAev6B,EAAaI,mBAAmBo6B,SAErD,IAAI,OAAqBD,GAAe,CACtC,MAAM,SAAE1oC,GAAa0oC,EACf/qB,EAAqB,EAAAzd,MAAMC,UAAUH,GAE3C,IAAK2d,EACH,OAMF,OAFEA,EAAmBzI,UAAU0zB,wBAAwBJ,EAGzD,CAGA,MAAM,oBAAEY,GAAwBV,EAE1BhK,EAAkBliC,EAAkCklB,oBAEpD2nB,EAAsBD,EAAoB57B,IAAIkxB,GAGpD,IAFc,EAAAx+B,MAAMopC,SAASD,GAG3B,OAMF,MAAME,GAA8B,IAAAC,kCAClCr7B,EAAaC,iBAGT,8BAAEq7B,GAAkCF,EAA4B,GAEhEG,EAAoBltC,EAASmtC,SAASF,GACtCv0B,EAAYw0B,GAAmB/kC,MAAMilC,YAAYC,eACjDC,EAAW,EAAAjmC,UAAA,sBAAgCqR,EAAWszB,GAEtDhiC,EAAa0O,EAAUwP,gBACvBqlB,EAAgB70B,EAAU60B,cAC9B,EAAAlmC,UAAA,aAAuBmmC,yBACrBxjC,EACA0O,EAAUC,eAAeC,aAAaC,WAK1C,OAFqB00B,EAAaE,cAAcH,EAGlD,CAxEaY,CAA6Bv8B,EAAcq6B,EAAY/kC,GAChE,KAAK,EAAA+Q,4BAA4Bm2B,QAC/B,OAgFC,SACLx8B,EACAq6B,GACA,SAAEhsC,IAEF,MAAMouC,EAAcz8B,EAAaI,mBAAmBC,QAE9Cq8B,EAAiBjvC,MAAM0rC,KAAKsD,EAAYn8B,kBAAkB+O,SAC1D,gBAAE7Z,GAAoBnH,EAASgO,YAErC,IAAK,MAAM6D,KAAgBw8B,EAAgB,CACzC,MAAMC,EAAiBF,EAAYn8B,kBAAkBjB,IAAIa,GAEzD,GAAKy8B,EAIL,IAAK,MAAM5vC,KAAiB4vC,EAAgB,CAC1C,MAAM7vC,GAAa,QACjBC,GAGF,IAAKD,EACH,SAGF,MAAM,SAAEmU,GAAanU,EAAWO,KAAKwU,QAErC,GACG,EAAAnM,UAAA,QAAkBF,EAAiB1I,EAAWI,SAASsI,mBAQtD,IAAAozB,yBAAwByR,EAAYp5B,GACtC,OAAO5M,OAAO6L,EAElB,CACF,CACF,CA1Ha08B,CAA4B58B,EAAcq6B,EAAY/kC,GAC/D,QACE,OAEN,C,kFC1CO,SAAS29B,EAAsBV,GACpC,MAAMzf,GAAY,IAAA2f,cAAaF,GAE/B,QAAkB7iC,IAAdojB,EACF,QAG8B,QAAsByf,GAE9B14B,SAASsZ,IAE/BA,EAAK8f,uBAAuB,IAI9B,MAAMC,EAAgBpgB,EAAUqgB,mBAE1BC,EAAqBhK,OAAO/Z,KAAK6jB,GAAe/+B,KACnD65B,GAAQkF,EAAclF,KAGzB,IAAKoF,EAAmB1iC,OACtB,OAGF,MAAM,kBAAEmiB,GAAsBugB,EAAmB,GAI3CC,EAAcvgB,EAAUwgB,iBAExBj6B,GAAkB,IAAAk6B,oBAAmB1gB,IAE3C,OAAsCxZ,EAAiBg6B,EACzD,C,6DCpCe,SAASwJ,EACtB5C,EACArmC,GAEA,GAAQqmC,IACD,UAA2B7zB,SAC9B,OAAO,OAAsBxS,GAE7B,MAAM,IAAIsC,MAAM,gCAAgC+jC,IAEtD,C,mFCwEA,QArDA,SACEE,EACA3qB,EACAstB,EACAxnC,GAEA,MAAM8d,EAAc+mB,EAAehmC,KAAKpH,GAC/B,EAAAkN,MAAA,cAAoBlN,KAK7B,IAAI6K,GAyBN,SAA8Bwb,GAC5B,MAAM2pB,EAAiB,CACrB,KAA0B5vC,SAC1B,KAAkCA,UAGpC,IAAK,MAAML,KAAcsmB,EAAa,CACpC,MAAMzL,EAAO7a,EAAWI,SAASC,SACjC,IAAK4vC,EAAejjC,SAAS6N,GAC3B,MAAM,IAAIzR,MACR,uHAGN,CACF,CAzCE8mC,CAAqB5pB,GAGrB,IAAK,IAAI3iB,EAAI,EAAGA,EAAIqsC,EAA2BpsC,OAAQD,IAAK,CAGxDqsC,EAA2BrsC,GAAGqB,OAAO+d,gBAAgBnf,SACpC8e,EAAmBK,gBAAgBnf,QAAgB,IAAND,IAC9DmH,GAAY,OACVwb,EACA0pB,EAA2BrsC,GAAGqB,OAC9BwD,GAGN,CAEA,MAAM2nC,GAA2B,OAC/BztB,EACAstB,EACA,IAAKxnC,EAASsC,cAKhB,OAFAqlC,EAAyBC,WAElBD,CACT,C,oHCtCe,SAASE,EACtB1uC,EACAsB,GAEA,MAAQ1C,KAAM+vC,GAAsBrtC,EAC9BK,GAAiB,IAAAC,mBAAkB5B,GACnC+Y,GAAW41B,EAAkBC,YAAcC,GAC/CltC,EACAgtC,GAEF,IAAK51B,EACH,OAEF,MAAM/R,EAAsBrF,EAAe/B,SAASkvC,yBAC9CC,EAAoB,4BACpB,aAAEt9B,EAAY,eAAED,GAAmBuH,EACnCi2B,EAAiB,uBACrBrwC,KAAKD,UAAY,IAAkBA,SACnCsI,GAEF,IAAIioC,GAA2B,EAC/B,MAAMC,EAAgCF,EAAej+B,QAClDo+B,IACC,MAAM,QAAEp2B,GAAYo2B,EAA0BvwC,KAC9C,GAAKma,EAUL,OANEA,EAAQvH,iBAAmBA,GAC3BuH,EAAQtH,eAAiBA,IAEzBw9B,GAA2B,EAC3BE,EAA0BvwC,KAAKma,QAAUA,KAElCA,CAAO,IAWpB,IAAIq2B,EA4CJ,GApDKH,GAGHC,EAA8Bz/B,KAAK,CACjC7Q,KAAM,CAAEma,aAKZm2B,EAA8B9jC,SAASikC,IACrC,MAAMt3B,EAAW,IACTgB,QAASu2B,GAAkBD,EAA6BzwC,MAC1D,aAAE6S,EAAY,eAAED,GAAmB89B,EACzCv3B,EAAStG,GAAgB69B,EACzB,yBACED,EAA6B/wC,eAE/B,MAAMqpC,GAAoB,OAAmC,IACxDoH,EAAkBlnC,MAClB0J,GAAiBA,EAAaC,iBAAmBA,IAEpDuG,aAGF,IAAK4vB,EACH,OAEF,MAAM4H,GAAwB,OAC5B5H,EACAhmC,EAAe/B,UAEjB2vC,EAAsBjxC,cACpB+wC,EAA6B/wC,cAC/BixC,EAAsB3wC,KAAKma,QAAUu2B,EAErC,MAAMhxC,EAAgB,sBACpBixC,EACAvoC,GAGF,GACEsoC,EAAc79B,eAAiBsH,EAAQtH,cACvC69B,EAAc99B,iBAAmBuH,EAAQvH,eACzC,CACA49B,EAAmBzH,EACnB,MAAM,MAAE6H,GAAUz2B,EACdy2B,GACF,eAAuBC,oBAAoBnxC,EAAekxC,EAE9D,KAGEJ,EAAkB,CACpB,MAAM,WAAE91B,GAAe81B,EACjB/mC,EAAW1G,EAAe/B,SAAS0I,eAGzC,IAAAonC,aAAY1vC,EAAS,CACnBgnB,WAAY3e,EAASpG,OAAS,EAAIqX,IAEpC3X,EAAe/B,SAAS+hC,QAC1B,MACEzpB,QAAQC,KAAK,0BAGf,OAAOi3B,CACT,CAEO,SAASP,EACdltC,EACAL,GAEA,MAAMytC,EAAoB,2BAC1B,IAAKA,EAAkB9sC,OACrB,OAEF,MAAMuP,EACJlQ,EAAckQ,gBAAkBu9B,EAAkB,GAAGv9B,eACjDC,EACJnQ,EAAcmQ,cACd,qCAAgDD,GAClD,IAAKC,EACH,OAEF,MAAMk+B,EAAcruC,EAAcquC,aAAa/+B,IAAIa,GACnD,MAAO,CACLhS,MAAO,WAAWgS,IAClBA,eACAD,oBACGm+B,EAEP,C,wECrCA,QA5GA,SACE5uB,EACA6uB,EACAvB,EACAwB,GAEA,MAAM7S,EAAajc,EAAmBK,iBAGhC,cAAE0uB,EAAa,eAAEC,IAAmB,QACxChvB,EACAstB,GA+BF,OAnBA0B,EAAe3kC,SAAS4kC,IACtB,MAAM,WAAEC,GAAeD,EAEnBC,IAAejT,EAAW/6B,OAmElC,SACE+6B,EACA4S,EACAI,GAEA,MAAM,gBAAEE,EAAe,MAAEC,EAAK,MAAEC,GAAUJ,EAE1C,IAAK,IAAIhuC,EAAI,EAAGA,EAAIg7B,EAAW/6B,OAAQD,IACrC,GAAIg7B,EAAWh7B,KAAO4tC,EAAmB,CACvC,MAAMn2B,EAAQy2B,EAAgBluC,GAC9Bg7B,EAAWh7B,GAAKyX,GAAS02B,GAAS12B,GAAS22B,EAAQR,EAAoB,CACzE,CAEJ,CA/EMS,CAAsBrT,EAAY4S,EAAmBI,GAkB3D,SACEhT,EACA4S,EACAI,EACAD,EACAD,EACAD,GAEA,MAAM,UAAEv3B,EAAS,MAAE63B,EAAK,MAAEC,EAAK,WAAExmC,GAAeomC,EAEhD,IAAIM,EAAOC,EAAU/qC,EAErB,IAAK,IAAIxD,EAAI,EAAGA,EAAIg7B,EAAW/6B,OAAQD,IACrC,GAAIg7B,EAAWh7B,KAAO4tC,EAAmB,CACvC,MAAMY,GAAgB,QACpBl4B,EACA1O,EACAmmC,EAAeD,GAAehuB,QAC9BiuB,EAAeD,GAAex3B,UAAU7C,SAASzT,IAG7CyuC,EAAkB,EAAGh3B,YACzB62B,GAAgB,EACZ72B,GAASjU,EAAM2qC,OAAS12B,GAASjU,EAAM4qC,QACzCG,GAAsB,EACxB,EAGFD,EAAQ,EACRC,EAAW,EACX/qC,EAAQ,CAAE2qC,QAAOC,SACjB,IAAIM,GAAc,GAGlB,IAAA9tB,sBACEtK,GACA,KAAM,GACNm4B,EACAD,GAGFE,EAA8B,IAAhBb,EAAoBU,EAAW,EAAIA,IAAaD,EAC9DtT,EAAWh7B,GAAK0uC,EAAcd,EAAoB,CACpD,CAGJ,CA9DMe,CACE3T,EACA4S,EACAI,EACAD,EACAD,EACAD,EAEJ,KAGF,IAAAe,iCAAgC7vB,EAAmB3d,UAE5C2d,CACT,C,wECyFA,QApHA,SACEA,EACAstB,EACAxnC,GAEA,MAAQyR,UAAWu4B,GAA0B9vB,EACvCic,EAAajc,EAAmBK,iBAEhC,UAAE0vB,EAAS,UAAE3nC,GAActC,EAC3BgpC,EAAchpC,GAASgpC,aAAe,EAG5C,GAAIiB,EACF,IAAK,IAAI9uC,EAAI,EAAGA,EAAIg7B,EAAW/6B,OAAQD,IACrCg7B,EAAWh7B,GAAK,EAIpB,MAAM,cAAE8tC,EAAa,eAAEC,IAAmB,QACxChvB,EACAstB,GAIF,IAAIkC,EAAUD,EAAO9qC,EAErB,MAAMurC,EAAmB,CAACf,EAAYgB,EAAcC,KAMlD,MAOM,UAAE34B,EAAS,WAAE1O,EAAU,MAAEumC,EAAK,MAAEC,GAAUJ,EAE1CQ,GAAgB,QACpBl4B,EACA1O,EACAonC,EACAC,GAIFX,EAAQ,EACRC,EAAW,EACX/qC,EAAQ,CAAE2qC,QAAOC,SAEjB,IAAIM,GAAc,EAUlB,OAPA,IAAA9tB,sBAAqBtK,GAAW,KAAM,IAxBd,EAAGmB,YACzB62B,GAAgB,EACZ72B,GAASjU,EAAM2qC,OAAS12B,GAASjU,EAAM4qC,QACzCG,GAAsB,EACxB,GAoB2DC,GAEzC,IAAhBX,EACFa,EAAcH,EAAW,EACD,GAAfV,IACTa,EAAcH,IAAaD,GAEtBI,CAAW,EAIdQ,EAAY,CAAClB,EAAY1tB,KAC7B,MAAM,UAAEhK,EAAS,gBAAE43B,EAAe,MAAEC,EAAK,MAAEC,GAAUJ,EAG/Cv2B,EAAQy2B,EAFC53B,EAAU64B,mBAAmB7uB,IAI5C,QAAI7I,GAAS02B,GAAS12B,GAAS22B,EAI/B,EAoCF,OAJA,IAAAxtB,sBAAqBiuB,GAAuB,KAAM,IAxBjC,EAAGv9B,QAAOgP,WAAUH,eACnC,IAAIivB,EAASrB,EAAe9tC,OAAS,EACrC,IAAK,IAAID,EAAI,EAAGA,EAAI+tC,EAAe9tC,SAG/BmvC,EADErB,EAAe/tC,GAAGiuC,aAAejT,EAAW/6B,OACrCivC,EAAUnB,EAAe/tC,GAAIsgB,GAG7ByuB,EACPhB,EAAe/tC,GACf+tC,EAAeD,GAAehuB,QAC9BK,GAGCivB,GAZoCpvC,KAiBvCovC,IACFpU,EAAW1pB,GAASzM,EAAQ4K,cAAgB,EAC9C,GAGgEtI,IAElE,IAAAynC,iCAAgC7vB,EAAmB3d,UAE5C2d,CACT,C,sGC1IO,SAASswB,EAAsBvN,EAAqBplC,GACzD,MAAM2lB,GAAY,IAAA2f,cAAaF,GAE/B,QAAkB7iC,IAAdojB,EACF,OAGF,MAAM+f,EAAgB/f,EAAUC,eAEhC,IAAKqW,OAAO/Z,KAAKwjB,GAAeniC,OAC9B,OAGF,GAAIvD,GAAY0lC,EAAc1lC,GAC5B,MAAO,CAAC0lC,EAAc1lC,IAQxB,OAJgCi8B,OAAOjZ,OAAO0iB,GAAerzB,QAC1DugC,GAAiBA,aAAwB,KAI9C,CAEA,MAAMC,EAAc,CAACtoC,EAAGC,IACf0Y,KAAKC,UAAU5Y,KAAO2Y,KAAKC,UAAU3Y,GAOvC,SAASsoC,EACdl5B,EACA1O,EACAonC,EACAC,GAEA,MAAMQ,EAAoB,GAC1B,IAAK,IAAIzvC,EAAI,EAAGA,EAAI,EAAGA,IACrB,IAAK,IAAIiV,EAAI,EAAGA,EAAI,EAAGA,IACrB,IAAK,IAAI+M,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,MAAM9hB,EAAQ,IAAI+uC,GAClB/uC,EAAM,GAAKA,EAAM,IAAW,EAAJF,EAAQ,GAAKgvC,EAAa,GAAM,EACxD9uC,EAAM,GAAKA,EAAM,IAAW,EAAJ+U,EAAQ,GAAK+5B,EAAa,GAAM,EACxD9uC,EAAM,GAAKA,EAAM,IAAW,EAAJ8hB,EAAQ,GAAKgtB,EAAa,GAAM,EACxDS,EAAkBhiC,KAAKvN,EACzB,CAGJ,MAAMwvC,EAAkBD,EAAkB/rC,KACvC06B,GAAU,kCAA8B9nB,EAAW8nB,KAOtD,OALsB,IAAAC,GACpBqR,EACA9nC,EAIJ,CAKO,SAAS+nC,EACd5wB,EACAstB,GAEA,MAAQvsB,QAAS8vB,GAAwB7wB,EACnCic,EAAajc,EAAmBK,gBAGhC2uB,EAAiB,GACvB,IAAID,EAAgB,EACpB,IAAK,IAAI9tC,EAAI,EAAGA,EAAIqsC,EAA2BpsC,OAAQD,IAAK,CAC1D,MAAM,UAAEsW,EAAS,QAAEwJ,EAAO,WAAElY,GAC1BykC,EAA2BrsC,GAAGqB,OAE1B4sC,EACJ5B,EAA2BrsC,GAAGqB,OAAO+d,gBAAgBnf,OAGrDguC,IAAejT,EAAW/6B,QAC1BsvC,EAAYzvB,EAAS8vB,KAErB9B,EAAgB9tC,GAIlB,MAAMkuC,EAAkB53B,EAAUC,eAAeC,aAAaC,UACxD03B,EAAQ9B,EAA2BrsC,GAAGmuC,MACtCC,EAAQ/B,EAA2BrsC,GAAGouC,MAE5CL,EAAetgC,KAAK,CAClB6I,YACA43B,kBACAC,QACAC,QACAtuB,UACAlY,aACAqmC,cAEJ,CAEA,MAAO,CACLF,iBACAD,gBAEJ,C,8ECvGA,IAWI+B,EAXAvwC,EAAgB,CAClBwwC,oBAAqB/nC,IAOrBgoC,sBAAsB,GAMxB,SAASC,EAAShyC,GAEhB,MAAMiyC,GAAoB,OAAajyC,GAEvC,IAAKiyC,EACH,OAGF,MAAMC,EAAgBD,GAAqB,CAAC,EACtC9H,GAAQ,QAAanqC,GAE3B,IAAKmqC,GAAO9hC,UAAUpG,OAEpB,YADAiW,QAAQC,KAAK,uDAIf,MAAM,oBAAEg6B,GAAwBhI,EAMhC,GAHA+H,EAAcr1B,UAAYq1B,EAAcE,kBAAkBnwC,QAG5B,IAA1BiwC,EAAcr1B,QAChB,OAKF,SAASw1B,EAAeC,GACtB,MAAMh/B,EAAQ4+B,EAAcE,iBAAiB/a,QAAQib,GAEjDh/B,GAAS,GAEX4+B,EAAcE,iBAAiB59B,OAAOlB,EAAO,EAEjD,CAIA2+B,EAAkBG,iBAAiBppC,MAAK,CAACC,EAAGC,IAAMD,EAAIC,IA8BtD,GA7B6BgpC,EAAcE,iBAAiBhwC,QAEvCgJ,SAAQ,SAAUknC,GACrC,MAAMpvC,EAAUinC,EAAM9hC,SAASiqC,GAE/B,IAAKpvC,EACH,QAGe2F,KAAKC,IAAIqpC,EAAsBG,GAQnC,EACP,EAAAhvC,MAAMivC,mBAAmBrvC,GACzB,EAAAI,MAAMkvC,SAAStvC,KAInBmvC,EAAeC,EAEnB,KAIKJ,EAAcE,iBAAiBnwC,OAClC,OAIGX,EAAcywC,sBACjB,EAAAU,qBAAqBC,kBAAkB,MAIzC,MAAMC,GAAU,QACdT,EAAcE,iBACdjI,EAAMgI,qBAGR,IAAIjvC,EACA0vC,EAWJ,IAAIC,EAAaF,EAAQxhC,IACrB2hC,EAAcH,EAAQvhC,KAC1B,MAAM2hC,EAAqB,GAE3B,KACEF,GAAc,GACdC,EAAcZ,EAAcE,iBAAiBnwC,QAC7C,CACA,MAAM+wC,EAAe7I,EAAMgI,oBAQrBc,IANJD,EAAed,EAAcE,iBAAiBS,GAC9CvxC,EAAcwwC,sBAK4Be,GAAc,EACpDK,IAJJhB,EAAcE,iBAAiBU,GAAeE,EAC9C1xC,EAAcwwC,sBAIOgB,EAAcZ,EAAcE,iBAAiBnwC,OAEpE,IAAKixC,IAAqBD,EACxB,MAGEA,IACFL,EAAmBV,EAAcE,iBAAiBS,KAClD3vC,EAAUinC,EAAM9hC,SAASuqC,GACzBG,EAAmBtjC,KAAKvM,IAGtBgwC,IACFN,EAAmBV,EAAcE,iBAAiBU,KAClD5vC,EAAUinC,EAAM9hC,SAASuqC,GACzBG,EAAmBtjC,KAAKvM,GAE5B,CAEA,MAAMiwC,EAAY,CAACjwC,EAAS2D,IAC1B,EAAAusC,YAAA,kBAA8BlwC,EAAS2D,IAEnC,iBAAEwsC,EAAgB,uBAAEC,IACxB,wBAAuBC,UAEnBC,EAAoBH,GAAoBC,EAE9CP,EAAmB3nC,SAASlI,IAG1B,MAAM2D,EAAU,CACd4sC,aAAc,CACZ3oC,KAAM0oC,OAAoBvyC,EAAY,gBAExCyyC,SAAU,CACR72B,SAAS,GAEX22B,oBACAG,YAAW,MAGb,EAAAlB,qBAAqBmB,WACnBT,EAAUU,KAAK,KAAM3wC,EAAS2D,GAC9B,KAEA,CACE3D,WAEF,KAED,GAEL,CAEA,SAAS4wC,EAAev5B,GAGtB/J,aAAaqhC,GACbA,EAAuB5hC,YAAW,WAChC,MAAMjQ,EAAUua,EAAEw5B,OAIlB,IACE/B,EAAShyC,EACX,CAAE,MAAOg0C,GACP,MACF,CACF,GAxLyB,GAyL3B,CAyEA,MAEA,EAFsB,CAAEC,OAvExB,SAAgBj0C,GACd,MAAMmqC,GAAQ,QAAanqC,GAE3B,IAAKmqC,IAAUA,EAAM9hC,UAAsC,IAA1B8hC,EAAM9hC,SAASpG,OAE9C,YADAiW,QAAQC,KAAK,uDAKf,MAAM85B,EAAoB,CACxBG,kBAAkB,QAAM,EAAGjI,EAAM9hC,SAASpG,OAAS,GACnD4a,SAAS,EACT/O,UAAW,GAIPomC,EAAsBjC,EAAkBG,iBAAiB/a,QAC7D8S,EAAMgI,qBAGRF,EAAkBG,iBAAiB59B,OAAO0/B,EAAqB,IAE/D,OAAal0C,EAASiyC,GAEtBD,EAAShyC,GAETA,EAAQm0C,oBAAoB,EAAAppC,MAAA,OAAaqpC,gBAAiBN,GAC1D9zC,EAAQq0C,iBAAiB,EAAAtpC,MAAA,OAAaqpC,gBAAiBN,GAEvD,MAAMQ,GAAwB,QAAyBt0C,GAEvD,EAAAwG,YAAY2tC,oBACV,EAAAppC,MAAA,OAAawpC,0BACbD,GAEF,EAAA9tC,YAAY6tC,iBACV,EAAAtpC,MAAA,OAAawpC,0BACbD,EAEJ,EAgCgCE,QA9BhC,SAAiBx0C,GACfwQ,aAAaqhC,GACb7xC,EAAQm0C,oBAAoB,EAAAppC,MAAA,OAAaqpC,gBAAiBN,GAE1D,MAAMQ,GAAwB,QAAyBt0C,GAEvD,EAAAwG,YAAY2tC,oBACV,EAAAppC,MAAA,OAAawpC,0BACbD,GAGF,MAAMrC,GAAoB,OAAajyC,GAGnCiyC,GAAqBA,EAAkBG,iBAAiBnwC,SAC1DgwC,EAAkBp1B,SAAU,EAG5B,EAAA41B,qBAAqBC,kBAAkB,MAE3C,EAUyC+B,iBARzC,WACE,OAAOnzC,CACT,EAM2DozC,iBAJ3D,SAA0BvvC,GACxB7D,EAAgB6D,CAClB,G,eC5QA,IAUI,EAVA,EAAgB,CAClB2sC,oBAAqB/nC,IAErB4qC,UAAW,EACXC,SAAU,EAEVC,qBAAsB,GACtB9C,sBAAsB,GAiExB,SAAS,EAAS/xC,GAChB,MAAMmqC,GAAQ,QAAanqC,GAC3B,IAAKmqC,GAAO9hC,UAAUpG,OAEpB,YADAiW,QAAQC,KAAK,uDAKf,MAAM85B,GAAoB,OAAajyC,GAEvC,IAAKiyC,EACH,OAGF,MAAMC,EAAgBD,GAAqB,CAAC,EAM5C,GAHAC,EAAcr1B,UAAYq1B,EAAcE,kBAAkBnwC,QAG5B,IAA1BiwC,EAAcr1B,QAChB,OAKF,SAASw1B,EAAeC,GACtB,MAAMh/B,EAAQ4+B,EAAcE,iBAAiB/a,QAAQib,GAEjDh/B,GAAS,GAEX4+B,EAAcE,iBAAiB59B,OAAOlB,EAAO,EAEjD,CAIA,MAAMwhC,EAAuB5C,EAAcE,iBAAiBhwC,SACtD,oBAAE+vC,GAAwBhI,EA6BhC,GA3BA2K,EAAqB1pC,SAASknC,IAC5B,MAAMpvC,EAAUinC,EAAM9hC,SAASiqC,GAE/B,IAAKpvC,EACH,QAGe2F,KAAKC,IAAIqpC,EAAsBG,GAQnC,EACP,EAAAhvC,MAAMivC,mBAAmBrvC,GACzB,EAAAI,MAAMkvC,SAAStvC,KAInBmvC,EAAeC,EACjB,KAKGJ,EAAcE,iBAAiBnwC,OAClC,OAIG,EAAc8vC,sBACjB,EAAAU,qBAAqBsC,gBAAe,QAAkB5K,IAmDxD,MAAMgJ,EAAY,CAACjwC,EAAS2D,IAC1B,EAAAusC,YAAA,kBACqBlwC,EAAS2D,GAC3BmuC,MAAK,IAnDV,SAAsB9xC,GAGpBmvC,EAFqBlI,EAAM9hC,SAASgvB,QAAQn0B,IAG5C,MAAMqiB,EAAQ,EAAAjiB,MAAM2xC,8BAA8B/xC,IAC5C,MAAEgyC,GAAUhD,EACZiD,EAAiB5vB,GAAOA,OAAO4vB,gBAAkB,EACvD,GAAIA,EAAgB,CAClBD,EAAM7sC,SAAS0H,IAAI7M,EAASiyC,GAC5BD,EAAMC,gBAAkBA,EACxB,MAAMC,EAAe7vB,GAAOA,OAAO6vB,cAAgB,EACnDF,EAAME,cAAgBA,CACxB,CAEA,IAAKlD,EAAcE,iBAAiBnwC,QAC9BsjB,GAAO8vB,YAAa,CACtB,MAAM,YAAEA,GAAgB9vB,EAClB+vB,EAAQ,EAAAhyC,MAAMiyC,kBAAoB,EAAIF,EAC5C,GAAKnD,EAAcsD,WAKZ,GAAIN,EAAM7sC,SAASkK,KAAM,CAC9B2iC,EAAMO,SAAW32B,KAAKC,MAAQm2B,EAAMhY,MACpC,MAAM,KAAE3qB,GAAS2iC,EAAM7sC,SACvB6sC,EAAMQ,SAAWnjC,EACjB2F,QAAQugB,IACN,kBACAyc,EAAMO,SACN,KACAljC,EACA,QACA,sBACA,IAAAojC,aAAYT,EAAMO,SAAWljC,GAC7B,KACA,gBACA,IAAAojC,aAAYT,EAAME,aAAe7iC,GACjC,KACA,kBACA,IAAAojC,aAAYT,EAAMC,eAAiB5iC,GACnC,KAEJ,OAxBE2iC,EAAMU,YAAc92B,KAAKC,MAAQm2B,EAAMhY,MACvCgY,EAAMW,YAAcX,EAAM7sC,SAASkK,KACnCujC,EAAgB91C,EAASs1C,GACzB,EAASt1C,EAsBb,CAEJ,CAKgB+1C,CAAa7yC,MAEvB,iBAAEmwC,EAAgB,uBAAEC,IACxB,wBAAuBC,UAEnBC,EAAoBH,GAAoBC,EAE9CpB,EAAcE,iBAAiBhnC,SAASknC,IACtC,MAAMpvC,EAAUinC,EAAM9hC,SAASiqC,GAGzBzrC,EAAU,CACd4sC,aAAc,CACZ3oC,KAAM0oC,OAAoBvyC,EAAY,gBAExCyyC,SAAU,CACR72B,SAAS,GAEX22B,oBACAG,YAAW,MAGb,EAAAlB,qBAAqBmB,WACnBT,EAAUU,KAAK,KAAM3wC,EAAS2D,GAC9B,KAEA,CACE3D,WAEF,KAED,GAEL,CAEA,SAAS,EAAeqX,GAGtB/J,aAAa,GACb,EAAuBP,YAAW,WAChC,MAAMjQ,EAAUua,EAAEw5B,OAIlB,IACE+B,EAAgB91C,GAChB,EAASA,EACX,CAAE,MAAOg0C,GACP,MACF,CACF,GA5OyB,EA6O3B,CAGA,MAEM8B,EAAkB,CAAC91C,EAASs1C,KAChC,MAAMnL,GAAQ,QAAanqC,GAC3B,IAAKmqC,IAAUA,EAAM9hC,UAAsC,IAA1B8hC,EAAM9hC,SAASpG,OAE9C,YADAiW,QAAQC,KAAK,uDAIf,MAAM,oBAAEg6B,GAAwBhI,EAChC,IAAI,SAAEyK,EAAW,EAAC,UAAED,EAAY,GAAM,EACtC,MAAM,qBAAEE,EAAuB,IAAO,EAEhC5C,GAAoB,OAAajyC,IAAY,CACjDoyC,iBAAkB,GAClBD,sBACA6D,WAAY,EACZn5B,SAAS,EACT/O,UAAW,EACXonC,MAAO,CACLhY,MAAOpe,KAAKC,MACZ1W,SAAU,IAAI0D,IACdopC,eAAgB,EAChBC,aAAc,EACda,WAAY,IAGVnpC,EAAQqlC,EAAsBF,EAAkBE,oBAStD,GARAF,EAAkBnkC,UAAmBhB,EA5BZ,GAAK,EAAI,EA6BlCmlC,EAAkBE,oBAAsBA,EACxCF,EAAkBp1B,SAAU,EAExBo1B,EAAkB+D,WAAa,MACjC/D,EAAkB+D,YAAcnB,GAG9BhsC,KAAKC,IAAIgE,GAAS8nC,IAAa9nC,EAIjC,GADAmlC,EAAkB+D,WAAa,EAC3BV,EAAO,CAET,MAAMY,EAAmB/D,EAAsBhI,EAAM9hC,SAASpG,OAC9D0yC,EAAY9rC,KAAK41B,KAAK6W,EAAQY,GAC9BtB,EAAW/rC,KAAK41B,KAAK6W,GAAS,EAAIY,IAClCjE,EAAkBuD,WAAY,CAChC,MACEvD,EAAkBuD,WAAY,OAEvB1oC,EAAQ,GACjB6nC,GAAa1C,EAAkB+D,WAC/BpB,EAAW,IAEXA,GAAY3C,EAAkB+D,WAC9BrB,EAAY,GAGd,MAAMwB,EAAWttC,KAAKW,IAAI,EAAG2oC,EAAsBwC,GAE7CyB,EAAWvtC,KAAKU,IACpB4gC,EAAM9hC,SAASpG,OAAS,EACxBkwC,EAAsByC,GAIlBxC,EAAmB,GACzB,IAAK,IAAIpwC,EAAImwC,EAAsB,EAAGnwC,GAAKo0C,EAAUp0C,IACnDowC,EAAiB3iC,KAAKzN,GAExB,IAAK,IAAIA,EAAImwC,EAAsB,EAAGnwC,GAAKm0C,EAAUn0C,IACnDowC,EAAiB3iC,KAAKzN,GAExBiwC,EAAkBG,iBAAmBA,GAErC,OAAapyC,EAASiyC,EAAkB,EA+B1C,MAOA,EAP6B,CAC3BgC,OA1Tcj0C,IACd,MAAMmqC,GAAQ,QAAanqC,GAE3B,IAAKmqC,IAAUA,EAAM9hC,UAAsC,IAA1B8hC,EAAM9hC,SAASpG,OAE9C,YADAiW,QAAQC,KAAK,uDAIf29B,EAAgB91C,GAEhB,EAASA,GAETA,EAAQm0C,oBAAoB,EAAAppC,MAAA,OAAaqpC,gBAAiB,GAC1Dp0C,EAAQq0C,iBAAiB,EAAAtpC,MAAA,OAAaqpC,gBAAiB,GAEvD,MAAME,GAAwB,QAAyBt0C,GAEvD,EAAAwG,YAAY2tC,oBACV,EAAAppC,MAAA,OAAawpC,0BACbD,GAEF,EAAA9tC,YAAY6tC,iBACV,EAAAtpC,MAAA,OAAawpC,0BACbD,EACD,EAmSDE,QA9BF,SAAiBx0C,GACfwQ,aAAa,GACbxQ,EAAQm0C,oBAAoB,EAAAppC,MAAA,OAAaqpC,gBAAiB,GAE1D,MAAME,GAAwB,QAAyBt0C,GAEvD,EAAAwG,YAAY2tC,oBACV,EAAAppC,MAAA,OAAawpC,0BACbD,GAGF,MAAMrC,GAAoB,OAAajyC,GAGnCiyC,IACFA,EAAkBp1B,SAAU,EAGhC,EAaE43B,iBAXF,WACE,OAAO,CACT,EAUEC,iBARF,SAA0BvvC,GACxB,EAAgBA,CAClB,E,6DClTA,QAnBA,SAAkBmY,EAAMC,EAAM1W,GAC5B,IAAIiX,GAAU,EACVE,GAAW,EAEf,GAAoB,mBAATV,EACT,MAAM,IAAIa,UAAU,uBAOtB,OALI,OAAStX,KACXiX,EAAU,YAAajX,EAAUyY,QAAQzY,EAAQiX,SAAWA,EAC5DE,EAAW,aAAcnX,EAAUyY,QAAQzY,EAAQmX,UAAYA,IAG1D,OAASV,EAAMC,EAAM,CAC1BO,UACAE,WACAN,QAASH,GAEb,C,kBCxDA,SAAS84B,EACP71C,EACA81C,GAEA,MAAMC,EAAOC,EAAch2C,GACrBi2C,EAAOD,EAAcF,GAC3B,MAAO,CACLI,KAAMC,EAAkBJ,EAAKG,KAAMD,EAAKC,MACxCE,OAAQD,EAAkBJ,EAAKK,OAAQH,EAAKG,QAC5Cj2C,OAAQg2C,EAAkBJ,EAAK51C,OAAQ81C,EAAK91C,QAC5Cy/B,OAiKFyW,EAjK2BN,EAAKnW,MAkKhCztB,EAlKuC8jC,EAAKrW,MAoKrC,CAACyW,EAAO,GAAKlkC,EAAO,GAAIkkC,EAAO,GAAKlkC,EAAO,GAAIkkC,EAAO,GAAKlkC,EAAO,MAJ3E,IACEkkC,EACAlkC,CAhKF,CASA,SAASmkC,EACPt2C,EACA81C,GAEA,MAAMC,EAAOC,EAAch2C,GACrBi2C,EAAOD,EAAcF,GAC3B,MAAO,CACLI,KAAMK,EAAeR,EAAKG,KAAMD,EAAKC,MACrCE,OAAQG,EAAeR,EAAKK,OAAQH,EAAKG,QACzCj2C,OAAQo2C,EAAeR,EAAK51C,OAAQ81C,EAAK91C,QACzCy/B,MAAO4W,EAAeT,EAAKnW,MAAOqW,EAAKrW,OAE3C,CAEA,SAAS6W,EACPz2C,EACA81C,GAGF,CASA,SAASY,EACP12C,EACA81C,GAEA,MAAMa,EAAkBC,EAAkC52C,GACpD62C,EAAeD,EAAkCd,GAOvD,MANsB,CACpBI,KAAMS,EAAgBT,KAAOW,EAAaX,KAC1CE,OAAQO,EAAgBP,OAASS,EAAaT,OAC9Cj2C,OAAQw2C,EAAgBx2C,OAAS02C,EAAa12C,OAC9Cy/B,MAAO+W,EAAgB/W,MAAQiX,EAAajX,MAGhD,CAQA,SAASkX,EAAev4C,GACtB,OAAO6iB,KAAK21B,MAAM31B,KAAKC,UAAU9iB,GACnC,CAEA,SAASy4C,EAAWz4C,GAClB,OAAO6iB,KAAK21B,MAAM31B,KAAKC,UAAU9iB,GACnC,CAEA,SAASy3C,EAAcz3C,GACrB,OAAOA,EAAOyU,QACZ,CAACikC,EAAMlB,KACE,CACLG,KAAM,CACJe,EAAKf,KAAK,GAAKH,EAAKG,KAAK,GAAK33C,EAAOkD,OACrCw1C,EAAKf,KAAK,GAAKH,EAAKG,KAAK,GAAK33C,EAAOkD,QAEvC20C,OAAQ,CACNa,EAAKb,OAAO,GAAKL,EAAKK,OAAO,GAAK73C,EAAOkD,OACzCw1C,EAAKb,OAAO,GAAKL,EAAKK,OAAO,GAAK73C,EAAOkD,QAE3CtB,OAAQ,CACN82C,EAAK92C,OAAO,GAAK41C,EAAK51C,OAAO,GAAK5B,EAAOkD,OACzCw1C,EAAK92C,OAAO,GAAK41C,EAAK51C,OAAO,GAAK5B,EAAOkD,QAE3Cm+B,MAAO,CACLqX,EAAKrX,MAAM,GAAKmW,EAAKnW,MAAM,GAAKrhC,EAAOkD,OACvCw1C,EAAKrX,MAAM,GAAKmW,EAAKnW,MAAM,GAAKrhC,EAAOkD,OACvCw1C,EAAKrX,MAAM,GAAKmW,EAAKnW,MAAM,GAAKrhC,EAAOkD,WAI7C,CACEy0C,KAAM,CAAC,EAAG,GACVE,OAAQ,CAAC,EAAG,GACZj2C,OAAQ,CAAC,EAAG,GACZy/B,MAAO,CAAC,EAAG,EAAG,IAGpB,CAEA,SAASsX,EAAmB34C,GAC1B,OAAOA,EAAOyU,QACZ,CAACikC,EAAMlB,KACE,CACLG,KAAM,CACJe,EAAKf,KAAK,GAAKH,EAAKG,KAAK,GAAK33C,EAAOkD,OACrCw1C,EAAKf,KAAK,GAAKH,EAAKG,KAAK,GAAK33C,EAAOkD,QAEvC20C,OAAQ,CACNa,EAAKb,OAAO,GAAKL,EAAKK,OAAO,GAAK73C,EAAOkD,OACzCw1C,EAAKb,OAAO,GAAKL,EAAKK,OAAO,GAAK73C,EAAOkD,QAE3CtB,OAAQ,CACN82C,EAAK92C,OAAO,GAAK41C,EAAK51C,OAAO,GAAK5B,EAAOkD,OACzCw1C,EAAK92C,OAAO,GAAK41C,EAAK51C,OAAO,GAAK5B,EAAOkD,QAE3Cm+B,MAAO,CACLqX,EAAKrX,MAAM,GAAKmW,EAAKnW,MAAM,GAAKrhC,EAAOkD,OACvCw1C,EAAKrX,MAAM,GAAKmW,EAAKnW,MAAM,GAAKrhC,EAAOkD,OACvCw1C,EAAKrX,MAAM,GAAKmW,EAAKnW,MAAM,GAAKrhC,EAAOkD,QAEzC01C,MAAO,CACLC,WAAY,KACZC,QAASJ,EAAKE,MAAME,QAAUtB,EAAKoB,MAAME,QAAU94C,EAAOkD,OAC1D61C,QAASL,EAAKE,MAAMG,QAAUvB,EAAKoB,MAAMG,QAAU/4C,EAAOkD,OAC1D81C,MAAON,EAAKE,MAAMI,MAAQxB,EAAKoB,MAAMI,MAAQh5C,EAAOkD,OACpD+1C,cACEP,EAAKE,MAAMK,cAAgBzB,EAAKoB,MAAMK,cAAgBj5C,EAAOkD,WAIrE,CACEy0C,KAAM,CAAC,EAAG,GACVE,OAAQ,CAAC,EAAG,GACZj2C,OAAQ,CAAC,EAAG,GACZy/B,MAAO,CAAC,EAAG,EAAG,GACduX,MAAO,CACLC,WAAY,KACZC,QAAS,EACTC,QAAS,EACTC,MAAO,EACPC,cAAe,IAIvB,CAQA,SAASrB,EACPE,EACAlkC,GAEA,MAAO,CAACkkC,EAAO,GAAKlkC,EAAO,GAAIkkC,EAAO,GAAKlkC,EAAO,GACpD,CASA,SAASykC,EAAkCr4C,GAEzC,MAAMk5C,EAA8B,GACpC,IAAK,IAAIj2C,EAAI,EAAGA,EAAIjD,EAAOkD,OAAQD,IACjC,IAAK,IAAIiV,EAAI,EAAGA,EAAIlY,EAAOkD,OAAQgV,IAC7BjV,EAAIiV,GACNghC,EAAexoC,KAAK,CAClBinC,KAAMK,EAAeh4C,EAAOiD,GAAG00C,KAAM33C,EAAOkY,GAAGy/B,MAC/CE,OAAQG,EAAeh4C,EAAOiD,GAAG40C,OAAQ73C,EAAOkY,GAAG2/B,QACnDj2C,OAAQo2C,EAAeh4C,EAAOiD,GAAGrB,OAAQ5B,EAAOkY,GAAGtW,QACnDy/B,MAAO4W,EAAej4C,EAAOiD,GAAGo+B,MAAOrhC,EAAOkY,GAAGmpB,SAOzD,OAAO6X,EAAezkC,QACpB,CAACikC,EAAMlB,KACE,CACLG,KAAMe,EAAKf,KAAOH,EAAKG,KAAOuB,EAAeh2C,OAC7C20C,OAAQa,EAAKb,OAASL,EAAKK,OAASqB,EAAeh2C,OACnDtB,OAAQ82C,EAAK92C,OAAS41C,EAAK51C,OAASs3C,EAAeh2C,OACnDm+B,MAAOqX,EAAKrX,MAAQmW,EAAKnW,MAAQ6X,EAAeh2C,UAGpD,CACEy0C,KAAM,EACNE,OAAQ,EACRj2C,OAAQ,EACRy/B,MAAO,GAGb,CAEA,SAAS2W,EAAeF,EAAsBlkC,GAC5C,OAAO9J,KAAKgK,KACVhK,KAAKiK,IAAI+jC,EAAO,GAAKlkC,EAAO,GAAI,GAAK9J,KAAKiK,IAAI+jC,EAAO,GAAKlkC,EAAO,GAAI,GAEzE,CAEA,SAASqkC,EAAeH,EAAsBlkC,GAC5C,OAAO9J,KAAKgK,KACVhK,KAAKiK,IAAI+jC,EAAO,GAAKlkC,EAAO,GAAI,GAC9B9J,KAAKiK,IAAI+jC,EAAO,GAAKlkC,EAAO,GAAI,GAChC9J,KAAKiK,IAAI+jC,EAAO,GAAKlkC,EAAO,GAAI,GAEtC,C,kRCrMA,QA5BO,SACLulC,GAEAA,EAAa9sC,SAAS04B,IACpB,MAAMzf,GAAY,IAAA2f,cAAaF,GAE/B,IAAKzf,EAEH,YADAnM,QAAQC,KAAK,+BAA+B2rB,KAIxBzf,EAAUqgB,mBAElBt5B,SAAS+sC,IACrB,MAAM,kBAAE/zB,EAAiB,WAAE1Y,GAAeysC,EAEpCvtC,GAAkB,IAAAk6B,oBAAmB1gB,GAC3C,IAAKxZ,EAEH,YADAsN,QAAQC,KAAK,qCAAqCiM,KAIpD,MAAMxkB,EAAWgL,EAAgBwtC,YAAY1sC,IAC7C,QAAwB9L,EAASI,QAAQ,GACzC,GAEN,C,kBCxBe,SAASq4C,EACtB/vB,EACAthB,GAEA,MAAMsxC,EAAehwB,EAAUrmB,OACzBs2C,EAAmC,GAEzC,IAAK,IAAIC,EAAK,EAAGA,EAAKF,EAAcE,IAAM,CACxC,MAAM54C,EAAW0oB,EAAUkwB,GAE3BtgC,QAAQugB,IAAI,YAAY+f,iBAAkB54C,EAASkvC,4BAC/ClvC,EAASkvC,2BAA6B9nC,GACxCuxC,EAAiC9oC,KAAK7P,EAE1C,CAEA,OAAO24C,CACT,C,0MCvBA,MAAM,OAAEE,EAAM,QAAEC,EAAO,QAAEC,GAAY,EAAAC,UAUtB,SAASC,EACtBvwB,EACA5pB,GAEA,MAAM45C,EAAehwB,EAAUrmB,OAEzB62C,EAA2B,GAEjC,IAAK,IAAIN,EAAK,EAAGA,EAAKF,EAAcE,IAAM,CACxC,MAAM54C,EAAW0oB,EAAUkwB,GAErBn0B,EAAY,6BAChBzkB,EAAS2O,GACT3O,EAASwkB,mBAGX,IAAKC,EACH,SAGc00B,EACd10B,EACA3lB,IAIAo6C,EAAyBrpC,KAAK7P,EAElC,CAEA,OAAOk5C,CACT,CAWA,SAASC,EACP10B,EACA3lB,GAEA,MAAM,YAAEs6C,GAAgB30B,EAClBK,EAAOs0B,EAAYt6C,GAEzB,IAAKgmB,EACH,OAAO,EAGT,MAAMu0B,EAAWv0B,EAAKw0B,KAEtB,OAAOD,IAAaR,GAAUQ,IAAaP,GAAWO,IAAaN,CACrE,C,0BC9CA,QAhBO,SACLrwB,EACA3a,EACAwrC,EAAM,MAEN,OAAO7wB,EAAUvX,QAAQnR,IACvB,MAAMw5C,EAAWx5C,EAASgO,YAM1B,OAHE/E,KAAKC,IAAI,SAASswC,EAASryC,gBAAiB4G,EAAO5G,kBACnDoyC,CAEe,GAErB,ECPe,SAASE,EACtBr5C,EACAtB,EACA46C,GAAyB,GAEzB,MAAM33C,GAAiB,IAAAC,mBAAkB5B,IACnC,gBAAE4K,EAAe,oBAAE5D,GAAwBrF,EAGjD,IAAI2mB,EAAY1d,EAAgB2uC,eAEhCjxB,EAAY+vB,EACV/vB,EACAthB,GAEFshB,EAAYuwB,EAA+BvwB,EAAW5pB,GAEtD,MAAMkB,EAAWgL,EAAgBwtC,YAAYz2C,EAAe+J,YAExD4tC,IACFhxB,EAAY,EACVA,EACA1oB,EAASgO,cAMb,OAFoB0a,EAAU5iB,KAAK8yC,GAAOA,EAAGjqC,IAG/C,C,4LCtCA,SAASirC,EACP55C,EACAqD,GAEA,GAAIrD,aAAoB,EAAAuD,mBAAoB,CAC1C,MAAMs2C,EAAiBx2C,EAASwC,MAAM,aAChCrC,EACJq2C,EAAex3C,OAAS,EACpBw3C,EAAe,GAAGh0C,MAAM,KAAK,GAC7Bg0C,EAAe,GACfp2C,EAAS,EAAAC,MAAMC,UAAUH,GAC/B,QAASC,GAAQG,SAAWm3B,OAAO/Z,KAAKvd,EAAOG,SAASvB,OAAS,CACnE,CAAO,GAAIrC,aAAoB,EAAA2H,cAAe,CAC5C,MAAM,SAAEmsC,GAAa9zC,EAAS63B,gBAAkB,CAAC,EACjD,QAASic,GAAUgG,MACrB,CACE,OAAO,CAEX,C,wEC+CA,QAnDAvR,eACEnoC,EACA6G,EAAU,CAAC,GAEX,MAAM,WAAEmgB,EAAU,gBAAE/Z,EAAe,SAAE7J,GAAayD,EAC5ClF,GAAiB,IAAAC,mBAAkB5B,GAEzC,IAAK2B,EACH,MAAM,IAAI8F,MAAM,6BAGlB,MAAM,SAAE7H,GAAa+B,GAEbqlB,WAAY2yB,EAAiB,eAAEjW,GAWzC,SACE9jC,EACAqN,GAEA,GAAIrN,aAAoB,EAAA2H,cACtB,MAAO,CACLm8B,eAAgB9jC,EAAS0I,cAAcrG,OACvC+kB,WAAY/Z,EACRrN,EAAS8M,wBACT9M,EAASgkC,0BAEV,GAAIhkC,aAAoB,EAAAuN,eAC7B,OAAO,+CAA2CvN,GAElD,MAAM,IAAI6H,MAAM,4BAEpB,CA3B4DmyC,CACxDh6C,EACAqN,GAIIH,EAuBR,SACE42B,EACA1c,GAEA,MAAM6yB,EAAiBnW,EAAiB,EAExC,OAAO,QAAK1c,EAAY,EAAG6yB,EAC7B,CA/B2BC,CAAqBpW,EAAgB1c,GAC7B2yB,GAEjC,OAAO/5C,EAAU,CAAEkN,QAAOG,kBAAiB7J,YAC7C,C,6DC/Be,SAAS22C,EACtBn6C,EACAo6C,GAGA,KAAMp6C,aAAoB,EAAAuN,gBACxB,OAGF,MAAM,WAAEo0B,GAAe3hC,EAASgO,YAE1Bd,EAAsB,CAAC,EAAG,EAAG,GAKnC,OAJA,SAASA,EAAOktC,EAAWzY,GAO7B,SAAqB3hC,EAAUkN,GAC7B,MAAMa,EAAS/N,EAASgO,YAClBqsC,EAAStsC,EAAO5G,gBAEhBmzC,EAAU,SAASptC,EAAOmtC,GAC1BE,EAAiB,gBAAgBF,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAIpE,GAFA,WAAWE,EAAgBA,EAAgBD,GAGzCrxC,KAAKC,IAAIqxC,EAAe,IAAM,MAC9BtxC,KAAKC,IAAIqxC,EAAe,IAAM,MAC9BtxC,KAAKC,IAAIqxC,EAAe,IAAM,KAC9B,CACA,MAAM3Y,EAA8B,CAAC,EAAG,EAAG,GACrCC,EAA4B,CAAC,EAAG,EAAG,GAEzC,SAASD,EAAe7zB,EAAO4zB,WAAY4Y,GAC3C,SAAS1Y,EAAa9zB,EAAO6lB,SAAU2mB,GAEvCv6C,EAAS8hC,UAAU,CACjBH,WAAYC,EACZhO,SAAUiO,IAEZ7hC,EAAS+hC,QACX,CACF,CA/BEyY,CAAYx6C,EAAUkN,IAEf,CACT,C,6DC3BA,MAAMutC,EAAgB70C,GACbA,GAASA,EAAM4qC,MAAQ5qC,EAAM2qC,MCDhCmK,EAAuB/nC,KAClBA,GAAQA,EAAKgoB,MAAQ,GAAKhoB,EAAKioB,OAAS,ECD7C+f,EAAyB,CAC7BtxC,EACAC,MAESD,KAAOC,GAAKD,EAAEknC,QAAUjnC,EAAEinC,OAASlnC,EAAEmnC,QAAUlnC,EAAEknC,MCJtDoK,EAAwB,CAACvxC,EAAiBC,MACrCD,KAAOC,GAAKD,EAAEsxB,QAAUrxB,EAAEqxB,OAAStxB,EAAEuxB,SAAWtxB,EAAEsxB,O,eCQ7D,MCEM,MAAEigB,GAAU,EAAAxzC,UAMlB,MAAMyzC,EAOJ,WAAAz6C,CAAY06C,GACVD,EAAeE,cAAcD,GAE7B,MAAM,SACJE,EAAQ,KACRtoC,EAAO,CAAEgoB,MAAO,GAAIC,OAAQ,KAAK,WACjCsgB,EAAa,CAAE3K,MAAO,EAAGC,MAAO,GAAG,SACnC2K,EAAW,CAAE5K,MAAO,EAAGC,MAAO,GAAG,UACjC4K,EAAS,wBACTC,GAA0B,GACxBN,EAEJh8C,KAAKu8C,UAAYL,EACjBl8C,KAAKw8C,YAAcL,EACnBn8C,KAAKy8C,UAAYL,EACjBp8C,KAAK08C,oBAAsBJ,EAC3Bt8C,KAAK28C,QAAU38C,KAAK48C,mBAAmBhpC,GAEnCyoC,GACFr8C,KAAK68C,SAASR,EAElB,CAEA,YAAWH,GACT,OAAOl8C,KAAKu8C,SACd,CAEA,YAAWL,CAASA,GAClBl8C,KAAKu8C,UAAYL,EACjBl8C,KAAKgjC,QACP,CAEA,QAAWpvB,GACT,MAAM,MAAEgoB,EAAK,OAAEC,GAAW77B,KAAK28C,QAC/B,MAAO,CAAE/gB,QAAOC,SAClB,CAEA,QAAWjoB,CAAKA,GACd,MAAQ+oC,QAAS36C,GAAWhC,KAEvB27C,EAAoB/nC,KAASioC,EAAsB75C,EAAQ4R,KAIhE5T,KAAK88C,eAAe96C,EAAQ4R,GAC5B5T,KAAKgjC,SACP,CAEA,cAAWmZ,GACT,MAAO,IAAKn8C,KAAKw8C,YACnB,CAEA,cAAWL,CAAWA,GAEjBT,EAAaS,KACdP,EAAuBO,EAAYn8C,KAAKw8C,eAK1Cx8C,KAAKw8C,YAAcL,EACnBn8C,KAAKgjC,SACP,CAEA,YAAWoZ,GACT,MAAO,IAAKp8C,KAAKy8C,UACnB,CAEA,YAAWL,CAASA,GAEfV,EAAaU,KACdR,EAAuBQ,EAAUp8C,KAAKy8C,aAKxCz8C,KAAKy8C,UAAYL,EACjBp8C,KAAKgjC,SACP,CAEA,sBAAW+Z,GACT,OAAO/8C,KAAK08C,mBACd,CAEA,sBAAWK,CAAmBA,GACxBA,IAAuB/8C,KAAK08C,sBAIhC18C,KAAK08C,oBAAsBK,EAC3B/8C,KAAKgjC,SACP,CAEO,QAAA6Z,CAASR,GACdA,EAAUW,YAAYh9C,KAAK28C,SAC3B38C,KAAKgjC,QACP,CAEO,OAAAia,GACL,MAAQN,QAAS36C,GAAWhC,MACtB,cAAEk9C,GAAkBl7C,EAE1Bk7C,GAAeC,YAAYn7C,EAC7B,CAEQ,oBAAOi6C,CAAcD,GAC3B,MAAM,KAAEpoC,EAAI,WAAEuoC,EAAU,SAAEC,GAAaJ,EAEvC,GAAIpoC,IAAS+nC,EAAoB/nC,GAC/B,MAAM,IAAI9K,MAAM,kBAGlB,GAAIqzC,IAAeT,EAAaS,GAC9B,MAAM,IAAIrzC,MAAM,wBAGlB,GAAIszC,IAAaV,EAAaU,GAC5B,MAAM,IAAItzC,MAAM,qBAEpB,CAEQ,cAAAg0C,CAAe96C,EAA2B4R,GAChD,MAAM,MAAEgoB,EAAK,OAAEC,GAAWjoB,EAE1B5R,EAAO45B,MAAQA,EACf55B,EAAO65B,OAASA,EAEhBG,OAAO8L,OAAO9lC,EAAO6uC,MAAO,CAC1BjV,MAAO,GAAGA,MACVC,OAAQ,GAAGA,OAEf,CAEQ,kBAAA+gB,CAAmBhpC,GACzB,MAAM5R,EAASo7C,SAASC,cAAc,UAYtC,OAVArhB,OAAO8L,OAAO9lC,EAAO6uC,MAAO,CAC1Bhc,SAAU,WACVnT,IAAK,IACL2L,KAAM,IACNiwB,cAAe,OACfC,UAAW,eAGbv9C,KAAK88C,eAAe96C,EAAQ4R,GAErB5R,CACT,CAEQ,MAAAghC,GACN,IAAKhjC,KAAK28C,QAAQa,YAChB,OAGF,MAAQjB,UAAWL,GAAal8C,MACxBy9C,UAAWC,GAAcxB,EAC3ByB,EAAcD,EAAUp6C,OAAS,EAKjCs6C,EAAiBjpC,IACrB,MAAMkpC,EAAS,EAAIlpC,EAKnB,KAAIA,EAAQ,GAAKA,GAASgpC,GAI1B,MAAO,CACLhpC,QACAkgB,SAAU6oB,EAAUG,GACpB75C,MAAO,CACL05C,EAAUG,EAAS,GACnBH,EAAUG,EAAS,GACnBH,EAAUG,EAAS,IAEtB,GAGG,MAAEjiB,EAAK,OAAEC,GAAW77B,KAAK28C,QACzBmB,EAAgB99C,KAAK28C,QAAQoB,WAAW,MACxCC,EAAepiB,EAAQC,EACvBoiB,EAAWD,EAAepiB,EAAQC,GAChC4gB,UAAWL,GAAap8C,KAC1B6G,EAAQ7G,KAAK08C,oBAAsB18C,KAAKw8C,YAAc,IAAKJ,IAE3D,YAAE8B,GAAgB,EAAA51C,UAAA,0BACtB8zC,EAAS5K,MACT4K,EAAS3K,OAGX,IAAI0M,EACAC,EAAoBR,EAAc,GAGtC,MAAMS,GAAoBx3C,EAAM4qC,MAAQ5qC,EAAM2qC,QAAUyM,EAAW,GACnE,IAAIK,EAAgBz3C,EAAM2qC,MAE1B,IAAK,IAAInuC,EAAI,EAAGA,EAAI46C,EAAU56C,IAAK,CACjC,MAAMk7C,GAAaD,EAAgBlC,EAAS5K,OAAS0M,EAKrD,GAAIE,EACF,IAAK,IAAI/6C,EAAI+6C,EAAkBzpC,MAAOtR,EAAIs6C,KACpCY,GAAaH,EAAkBvpB,UADkBxxB,IAKrD86C,EAAqBC,EACrBA,EAAoBR,EAAcv6C,EAAI,GAI1C,IAAIm7C,EAYJ,GAAKL,EAEE,GAAKC,EAEL,CACL,MAAMK,GACHF,EAAYJ,EAAmBtpB,WAC/BupB,EAAkBvpB,SAAWspB,EAAmBtpB,UD5PlCvqB,EC+Pf6zC,EAAmBn6C,MD/PDuG,ECgQlB6zC,EAAkBp6C,MDhQG24B,ECiQrB8hB,EAHFD,ED7PC,CACLl0C,EAAE,IAAM,EAAIqyB,GAAKpyB,EAAE,GAAKoyB,EACxBryB,EAAE,IAAM,EAAIqyB,GAAKpyB,EAAE,GAAKoyB,EACxBryB,EAAE,IAAM,EAAIqyB,GAAKpyB,EAAE,GAAKoyB,EC+PtB,MAXE6hB,EAAY,IAAIL,EAAmBn6C,YAFnCw6C,EAAY,IAAIJ,EAAkBp6C,OAepC,MAAMA,EAAQw6C,EAAUz3C,KAAK/C,GAC3B83C,EAAM5xC,KAAKk9B,MAAc,IAARpjC,GAAc,EAAG,OAGpC85C,EAAcY,UAAY,OAAO16C,EAAM,OAAOA,EAAM,OAAOA,EAAM,MAE7Dg6C,EACFF,EAAca,SAASt7C,EAAG,EAAG,EAAGw4B,GAEhCiiB,EAAca,SAAS,EAAG9iB,EAASx4B,EAAI,EAAGu4B,EAAO,GAGnD0iB,GAAiBD,CACnB,CDlRoB,IAAC/zC,EAAGC,EAAGoyB,CCmR7B,EChRF,MAAMiiB,EAAW,CACfC,KAAM,aACNC,MAAO,QACPC,UAAW,EACXC,WAAY,EACZC,kBAAmB,EACnBC,cAAe,EAGfC,YAAa,CAAC,EAAG,IAAK,EAAG,KAG3B,MAAMC,EAaJ,WAAA99C,CAAY06C,GACVoD,EAAcnD,cAAcD,GAE5B,MAAM,IACJt6B,EAAM,EAAC,KACP2L,EAAO,EAAC,KACRzZ,EAAO,CAAEgoB,MAAO,GAAIC,OAAQ,KAAK,WACjCsgB,EAAa,CAAE3K,MAAO,EAAGC,MAAO,GAAG,SACnC2K,EAAW,CAAE5K,MAAO,EAAGC,MAAO,GAC9B4N,MAAOC,EAAU,UACjBjD,EAAS,wBACTC,GAA0B,GACxBN,GAEInL,MAAO0O,EAAY1qB,SAAU2qB,GAAsBF,GAAc,CAAC,EAE1Et/C,KAAKw8C,YAAcL,EACnBn8C,KAAKy8C,UAAYL,EACjBp8C,KAAKy/C,MAAQF,GAAYG,MAAQd,EAASC,KAC1C7+C,KAAK2/C,OAASJ,GAAYv7C,OAAS46C,EAASE,MAC5C9+C,KAAK4/C,UAAYL,GAAYM,UAAYjB,EAASG,UAClD/+C,KAAK8/C,WAAaP,GAAYQ,WAAanB,EAASI,WACpDh/C,KAAKggD,aAAeT,GAAYU,aAAerB,EAASK,kBACxDj/C,KAAKkgD,aAAeX,GAAYY,aAAevB,EAASM,cACxDl/C,KAAKogD,mBACHZ,GAAqBa,EAAA,EAA0BC,MACjDtgD,KAAKugD,yBAA2BjE,EAChCt8C,KAAK28C,QAAU38C,KAAKwgD,qBAAqB5sC,EAAM8N,EAAK2L,GAEhDgvB,GACFr8C,KAAK68C,SAASR,EAElB,CAEA,QAAWzoC,GACT,MAAM,MAAEgoB,EAAK,OAAEC,GAAW77B,KAAK28C,QAC/B,MAAO,CAAE/gB,QAAOC,SAClB,CAEA,QAAWjoB,CAAKA,GACd,MAAQ+oC,QAAS36C,GAAWhC,KAEvB27C,EAAoB/nC,KAASioC,EAAsB75C,EAAQ4R,KAIhE5T,KAAK88C,eAAe96C,EAAQ4R,GAC5B5T,KAAKgjC,SACP,CAKA,OAAWthB,GACT,OAAOza,OAAOikC,SAASlrC,KAAK28C,QAAQ9L,MAAMnvB,IAC5C,CAKA,OAAWA,CAAIA,GACb,MAAQi7B,QAAS36C,GAAWhC,KAGxB0hB,IAFe1hB,KAAK0hB,MAMxB1f,EAAO6uC,MAAMnvB,IAAM,GAAGA,MACtB1hB,KAAKgjC,SACP,CAKA,QAAW3V,GACT,OAAOpmB,OAAOikC,SAASlrC,KAAK28C,QAAQ9L,MAAMxjB,KAC5C,CAKA,QAAWA,CAAKA,GACd,MAAQsvB,QAAS36C,GAAWhC,KAGxBqtB,IAFgBrtB,KAAKqtB,OAMzBrrB,EAAO6uC,MAAMxjB,KAAO,GAAGA,MACvBrtB,KAAKgjC,SACP,CAKA,cAAWmZ,GACT,MAAO,IAAKn8C,KAAKw8C,YACnB,CAKA,cAAWL,CAAWA,GAEjBT,EAAaS,KACdP,EAAuBO,EAAYn8C,KAAKw8C,eAK1Cx8C,KAAKw8C,YAAcL,EACnBn8C,KAAKgjC,SACP,CAMA,YAAWoZ,GACT,MAAO,IAAKp8C,KAAKy8C,UACnB,CAMA,YAAWL,CAASA,GAEfV,EAAaU,KACdR,EAAuBQ,EAAUp8C,KAAKy8C,aAKxCz8C,KAAKy8C,UAAYL,EACjBp8C,KAAKgjC,SACP,CAKA,YAAW6c,GACT,OAAO7/C,KAAK4/C,SACd,CAKA,YAAWC,CAASA,GACdA,IAAa7/C,KAAK4/C,YAItB5/C,KAAK4/C,UAAYC,EACjB7/C,KAAKgjC,SACP,CAKA,aAAW+c,GACT,OAAO//C,KAAK8/C,UACd,CAOA,aAAWC,CAAUA,GACfA,IAAc//C,KAAK8/C,aAIvB9/C,KAAK8/C,WAAaC,EAClB//C,KAAKgjC,SACP,CAKA,SAAWh/B,GACT,OAAOhE,KAAK2/C,MACd,CASA,SAAW37C,CAAMA,GACXA,IAAUhE,KAAK2/C,SAInB3/C,KAAK2/C,OAAS37C,EACdhE,KAAKgjC,SACP,CAOA,2BAAWsZ,GACT,OAAOt8C,KAAKugD,wBACd,CAOA,2BAAWjE,CAAwBmE,GAC7BA,IAAkBzgD,KAAKugD,2BAI3BvgD,KAAKugD,yBAA2BE,EAChCzgD,KAAKgjC,SACP,CAKA,WAAW0d,GACT,MAAsC,UAA/B1gD,KAAK28C,QAAQ9L,MAAM8P,OAC5B,CAKA,WAAWD,CAAQA,GACbA,IAAY1gD,KAAK0gD,UAIrB1gD,KAAK28C,QAAQ9L,MAAM8P,QAAUD,EAAU,QAAU,OAE7CA,GACF1gD,KAAKgjC,SAET,CAMO,QAAA6Z,CAASR,GACdA,EAAUW,YAAYh9C,KAAK28C,SAC3B38C,KAAKgjC,QACP,CAEQ,oBAAOiZ,CAAcD,GAC3B,MAAM,KAAEpoC,EAAI,WAAEuoC,EAAU,SAAEC,GAAaJ,EAEvC,GAAIpoC,IAAS+nC,EAAoB/nC,GAC/B,MAAM,IAAI9K,MAAM,kBAGlB,GAAIqzC,IAAeT,EAAaS,GAC9B,MAAM,IAAIrzC,MAAM,wBAGlB,GAAIszC,IAAaV,EAAaU,GAC5B,MAAM,IAAItzC,MAAM,qBAEpB,CAEQ,cAAAg0C,CAAe96C,EAA2B4R,GAChD,MAAM,MAAEgoB,EAAK,OAAEC,GAAWjoB,EAE1B5R,EAAO45B,MAAQA,EACf55B,EAAO65B,OAASA,EAEhBG,OAAO8L,OAAO9lC,EAAO6uC,MAAO,CAC1BjV,MAAO,GAAGA,MACVC,OAAQ,GAAGA,OAEf,CAEQ,oBAAA2kB,CACN5sC,EACA8N,EACA2L,GAEA,MAAMrrB,EAASo7C,SAASC,cAAc,UAYtC,OAVArhB,OAAO8L,OAAO9lC,EAAO6uC,MAAO,CAC1B8P,QAAS,OACT9rB,SAAU,WACV0oB,UAAW,aACX77B,IAAK,GAAGA,MACR2L,KAAM,GAAGA,QAGXrtB,KAAK88C,eAAe96C,EAAQ4R,GAErB5R,CACT,CAgBQ,SAAA4+C,CAAU/5C,GAChB,MAAM,MAAE2qC,EAAK,MAAEC,GAAU5qC,EAInBg6C,GAHapP,EAAQD,IAGKxxC,KAAKkgD,aAAe,GAG9CY,EAAY52C,KAAKiK,IACrB,IACCjK,KAAKyS,MAAMzS,KAAK62C,MAAM72C,KAAKC,IAAI02C,MAI5BG,EAAuBH,EAAYC,EAQnCG,EALiBrC,EAASO,YAAYj2C,MACzC6nB,GAAMA,GAAKiwB,IAIgBF,EAGxBI,EAAWh3C,KAAK41B,KAAK2R,EAAQwP,GAAQA,EACrCE,EAAWj3C,KAAKyS,MAAM60B,EAAQyP,GAAQA,EAGtCG,EAAal3C,KAAKk9B,OAAO8Z,EAAWC,GAAYF,GAAQ,EACxD5B,EAAQ,GAEd,IAAK,IAAIh8C,EAAI,EAAGA,EAAI+9C,EAAY/9C,IAC9Bg8C,EAAMvuC,KAAKqwC,EAAW99C,EAAI49C,GAG5B,MAAO,CAAEE,WAAUD,WAAUD,OAAM5B,QACrC,CAEQ,gBAAAgC,EAAiB,SAAExsB,EAAQ,aAAEysB,IACnC,MAAM,MAAE1lB,GAAU57B,KAAK28C,QASvB,MAAO,CAAE4E,WANU,CADjB3lB,EAAQ57B,KAAK6/C,SAAWyB,EAAa1lB,MAAQ57B,KAAKggD,aACxBnrB,GAMP2sB,WALF,CACjBjjB,MAAO,CAAC3C,EAAQ57B,KAAK4/C,UAAW/qB,GAChC4sB,IAAK,CAAC7lB,EAAO/G,IAIjB,CAEQ,iBAAA6sB,EAAkB,SAAE7sB,IAO1B,MAAO,CAAE0sB,WANU,CAACvhD,KAAK4/C,UAAY5/C,KAAKggD,aAAcnrB,GAMnC2sB,WALF,CACjBjjB,MAAO,CAAC,EAAG1J,GACX4sB,IAAK,CAACzhD,KAAK4/C,UAAW/qB,IAI1B,CAEQ,eAAA8sB,EAAgB,SAAE9sB,EAAQ,aAAEysB,IAClC,MAAM,IAAIx4C,MAAM,kBAClB,CAEQ,kBAAA84C,EAAmB,SAAE/sB,EAAQ,aAAEysB,IACrC,MAAM,IAAIx4C,MAAM,kBAClB,CAEQ,MAAAk6B,GACN,MAAQ2Z,QAAS36C,GAAWhC,KAE5B,IAAKgC,EAAOw7C,cAAgBx9C,KAAK0gD,QAC/B,OAGF,MAAM,MAAE9kB,EAAK,OAAEC,GAAW75B,EACpBg8C,EAAepiB,GAASC,EACxBgmB,EAAsB7D,EAAepiB,EAAQC,EAC7CiiB,EAAgB97C,EAAO+7C,WAAW,OAChCtB,UAAWL,GAAap8C,KAC1B6G,EAAQ7G,KAAKugD,yBACfvgD,KAAKw8C,YACL,IAAKJ,GACH0F,EAAaj7C,EAAM4qC,MAAQ5qC,EAAM2qC,OACjC,MAAE6N,GAAUr/C,KAAK4gD,UAAU/5C,GAEjCi3C,EAAciE,UAAU,EAAG,EAAGnmB,EAAOC,GACrCiiB,EAAc4B,KAAO1/C,KAAKy/C,MAC1B3B,EAAckE,aAAe,SAC7BlE,EAAcY,UAAY1+C,KAAK2/C,OAC/B7B,EAAcmE,YAAcjiD,KAAK2/C,OACjC7B,EAAc35C,UAAYnE,KAAK+/C,UAE/BV,EAAM5yC,SAASy1C,IACb,IAAIrtB,EAAW3qB,KAAKk9B,MAClBya,IAAwBK,EAAOr7C,EAAM2qC,OAASsQ,IAQhD,GAJK9D,IACHnpB,EAAWgH,EAAShH,GAGlBA,EAAW,GAAKA,EAAWgtB,EAC7B,OAGF,MAAM/gD,EAAQohD,EAAK/W,WACbmW,EAAexD,EAAcqE,YAAYrhD,GAC/C,IAAIshD,EAIAA,EAFApE,EACEh+C,KAAKogD,qBAAuBC,EAAA,EAA0BgC,IAC7CriD,KAAK2hD,gBAAgB,CAAE9sB,WAAUysB,iBAEjCthD,KAAK4hD,mBAAmB,CAAE/sB,WAAUysB,iBAG7CthD,KAAKogD,qBAAuBC,EAAA,EAA0BiC,KAC7CtiD,KAAKqhD,iBAAiB,CAAExsB,WAAUysB,iBAElCthD,KAAK0hD,kBAAkB,CAAE7sB,aAIxC,MAAM,WAAE0sB,EAAU,WAAEC,GAAeY,GAC3B7jB,MAAOgkB,EAAWd,IAAKe,GAAYhB,EAQ3C,OANA1D,EAAc2E,YACd3E,EAAc4E,OAAOH,EAAU,GAAIA,EAAU,IAC7CzE,EAAc6E,OAAOH,EAAQ,GAAIA,EAAQ,IACzC1E,EAAc8E,SAAS9hD,EAAOygD,EAAW,GAAIA,EAAW,IACxDzD,EAAc+E,SAEPhuB,CAAQ,GAEnB,E,eCrcF,MAAeiuB,EAMb,WAAAxhD,EAAY,GAAEsO,EAAE,UAAEysC,IAgGV,KAAA0G,yBAA4B3rC,IAClC,IAAIwkB,EACAC,EAEJ,MAAM,YAAEmnB,EAAW,eAAEC,GAAmB7rC,EAAQ,GAM5C4rC,GACFpnB,EAAQonB,EAAYpnB,MACpBC,EAASmnB,EAAYnnB,QACZonB,GAAgB3/C,SACzBs4B,EAAQqnB,EAAe,GAAGC,WAC1BrnB,EAASonB,EAAe,GAAGE,WAG7BnjD,KAAKojD,eAAiB,CAAExnB,QAAOC,UAC/B77B,KAAKqjD,mBAAmB,EAlHxBrjD,KAAKsjD,IAAM1zC,EACX5P,KAAKojD,eAAiB,CAAExnB,MAAO,EAAGC,OAAQ,GAC1C77B,KAAKujD,aAAevjD,KAAKwjD,kBAAkB5zC,GAC3C5P,KAAKyjD,yBAA2B,IAAIC,eAClC1jD,KAAK+iD,0BAGH1G,GACFr8C,KAAK68C,SAASR,EAElB,CAKA,MAAWzsC,GACT,OAAO5P,KAAKsjD,GACd,CAKA,eAAWK,GACT,OAAO3jD,KAAKujD,YACd,CAMO,QAAA1G,CAASR,GACd,MACEkH,aAAcI,EACdF,yBAA0BG,GACxB5jD,MACIk9C,cAAe2G,GAAqBF,EAEvCtH,GAAaA,IAAcwH,IAI5BA,GACFD,EAAeE,UAAUD,GAG3BxH,EAAUW,YAAY2G,GACtBC,EAAeG,QAAQ1H,GACzB,CAKO,OAAA2H,GACL,MACET,aAAcI,EACdF,yBAA0BG,GACxB5jD,MACE,cAAEk9C,GAAkByG,EAE1BzG,GAAeC,YAAYwG,GAC3BC,EAAeK,YACjB,CAEA,iBAAcC,GAEZ,MAAO,IAAKlkD,KAAKojD,eACnB,CAOU,iBAAAI,CAAkB5zC,GAC1B,MAAM+zC,EAAcvG,SAASC,cAAc,OAU3C,OARAsG,EAAY/zC,GAAKA,EACjB+zC,EAAYQ,UAAU53C,IAAI,UAE1ByvB,OAAO8L,OAAO6b,EAAY9S,MAAO,CAC/BjV,MAAO,OACPC,OAAQ,SAGH8nB,CACT,CAMU,iBAAAN,GAEV,ECpIF,MAAM,EAAW,CACfe,WAAY,EACZC,oBAAqBhE,EAAA,EAA0BC,MAC/CgE,eAAgB,IAclB,MAAMC,UAAiBzB,EAWrB,WAAAxhD,CAAY06C,GACVv6C,MAAMu6C,GAJA,KAAAwI,cAAe,EACf,KAAAC,gBAAiB,EAuOjB,KAAAC,mBAAsB/iD,IAC5B3B,KAAKwkD,cAAe,EACpBxkD,KAAK2kD,YACLhjD,EAAIijD,iBAAiB,EAGf,KAAAC,kBAAqBljD,IAC3B3B,KAAKwkD,cAAe,EACpBxkD,KAAK8kD,YACLnjD,EAAIijD,iBAAiB,EAGf,KAAAG,mBAAsBpjD,IAC5B3B,KAAKykD,gBAAiB,EACtBzkD,KAAK2kD,YACL3kD,KAAKglD,sBAAsBrjD,GAC3BA,EAAIijD,iBAAiB,EAGf,KAAAK,mBAAqB,CAACtjD,EAAKujD,KACjC,MAAMC,EAAcnlD,KAAKolD,oBACnBvjD,EAAgB7B,KAAKqlD,yBAAyB1jD,IAC5CvB,OAAQklD,EAAalJ,SAAUmJ,GAAkBL,EACnDM,EAAc,SAClB,cACA3jD,EAAc4jD,MACdH,EAAYG,OAGRC,EAAUF,EAAY,GAAKL,EAAY,GACvCQ,EAAUH,EAAY,GAAKL,EAAY,GAE7C,IAAKO,IAAYC,EACf,OAGF,MAAQnU,MAAOoU,EAAUnU,MAAOoU,GAAaN,EAC7C,IAAI,YAAErH,EAAW,aAAE4H,GAAiB,sCAClCF,EACAC,GAGF3H,EAAch0C,KAAKW,IAAIqzC,EAAcwH,EAAS,GAC9CI,GAAgBH,EAEhB,MAAMI,EAAc,uCAClB7H,EACA4H,GAGF9lD,KAAKo8C,SAAW2J,EAChBpkD,EAAIijD,kBACJjjD,EAAIqkD,gBAAgB,EAGd,KAAAC,iBAAoBtkD,IAC1B3B,KAAKykD,gBAAiB,EACtBzkD,KAAK8kD,YACL9kD,KAAKkmD,2BACLvkD,EAAIijD,iBAAiB,EA7RrB5kD,KAAKmmD,uBACH,IAAI,0DACNnmD,KAAKomD,WAAa7B,EAAS8B,gBAAgBrK,GAC3Ch8C,KAAKsmD,oBAAsB/B,EAASgC,uBAAuBvK,GAC3Dh8C,KAAK28C,QAAU38C,KAAKwmD,cAAcxK,GAClCh8C,KAAKymD,UAAYzmD,KAAK0mD,gBAAgB1K,GACtCh8C,KAAKogD,mBACHpE,EAAMqD,OAAOxqB,UAAY,EAASwvB,oBAEpCrkD,KAAK28C,QAAQE,SAAS78C,KAAK2jD,aAC3B3jD,KAAKymD,UAAU5J,SAAS78C,KAAK2jD,aAE7B3jD,KAAK2mD,+BACP,CAKA,sBAAWC,GACT,OAAO5mD,KAAKsmD,mBACd,CAKA,sBAAWM,CAAmBC,GAC5B,GAAIA,IAAiB7mD,KAAKsmD,oBACxB,OAGF,MAAMpK,EAAWl8C,KAAKomD,WAAWn0C,IAAI40C,GAEhC3K,GAKLl8C,KAAKsmD,oBAAsBO,EAC3B7mD,KAAK28C,QAAQT,SAAWA,GALtB3iC,QAAQC,KAAK,0BAA0BqtC,KAM3C,CAEA,cAAW1K,GACT,OAAOn8C,KAAK28C,QAAQR,UACtB,CAEA,cAAWA,CAAWA,GACpBn8C,KAAK28C,QAAQR,WAAaA,EAC1Bn8C,KAAKymD,UAAUtK,WAAaA,CAC9B,CAEA,YAAWC,GACT,OAAOp8C,KAAK28C,QAAQP,QACtB,CAEA,YAAWA,CAASA,GAClB,MAAQA,SAAU0K,GAAoB9mD,KAAK28C,QAGxCjB,EAAaU,KACdR,EAAuBQ,EAAU0K,KAKnC9mD,KAAK28C,QAAQP,SAAWA,EACxBp8C,KAAKymD,UAAUrK,SAAWA,EAC1Bp8C,KAAK+mD,YAAY3K,GACnB,CAEA,sBAAWW,GACT,OAAO/8C,KAAK28C,QAAQI,kBACtB,CAEA,sBAAWA,CAAmBjiC,GAC5B9a,KAAK28C,QAAQI,mBAAqBjiC,EAClC9a,KAAKymD,UAAUnK,wBAA0BxhC,CAC3C,CAEO,OAAAkpC,GACLviD,MAAMuiD,UACNhkD,KAAKmmD,uBAAuBa,OAC9B,CAEU,iBAAAxD,GACR,MAAMG,EAAcvG,SAASC,cAAc,OAS3C,OAPArhB,OAAO8L,OAAO6b,EAAY9S,MAAO,CAC/Bhc,SAAU,WACV9wB,SAAU,IACV63B,MAAO,OACPC,OAAQ,SAGH8nB,CACT,CAEU,iBAAAN,GACR5hD,MAAM4hD,oBACNrjD,KAAKinD,iBACLjnD,KAAK28C,QAAQ/oC,KAAO5T,KAAKkkD,aAC3B,CAEU,iBAAAkB,GACR,MAAO,CAAC,EAAShB,WAAY,EAASA,WACxC,CAEU,WAAA2C,CAAY3K,GAEtB,CAEU,SAAAuI,GACR3kD,KAAKinD,iBACLjnD,KAAKymD,UAAU/F,SAAU,CAC3B,CAEU,SAAAoE,GACJ9kD,KAAKykD,gBAAkBzkD,KAAKwkD,eAIhCxkD,KAAKymD,UAAU/F,SAAU,EAC3B,CAEQ,sBAAO2F,CAAgBrK,GAC7B,MAAM,UAAEkL,GAAclL,EAEtB,OAAOkL,EAAUryC,QACf,CAACsyC,EAAOC,IAASD,EAAM/1C,IAAIg2C,EAAKC,KAAMD,IACtC,IAAIh6C,IAER,CAEQ,6BAAOm5C,CAAuBvK,GACpC,MAAM,mBAAE4K,EAAkB,UAAEM,GAAclL,EAK1C,QAHI4K,GACFM,EAAUI,MAAMC,GAAOA,EAAGF,OAAST,IAEbA,EAAqBM,EAAU,GAAGG,IAC5D,CAEQ,aAAAb,CAAcxK,GACpB,MAAM,WAAEG,EAAU,SAAEC,EAAQ,wBAAEE,GAA4BN,EACpDE,EAAWl8C,KAAKomD,WAAWn0C,IAAIjS,KAAKsmD,qBAE1C,OAAO,IAAIvK,EAAe,CACxBG,WACAC,aACAC,SAAUA,EACVE,2BAEJ,CAEO,eAAAoK,CAAgB1K,GACrB,MAAMsD,EAAatD,EAAMqD,MAEzB,OAAO,IAAID,EAAc,CACvBjD,WAAYH,EAAMG,WAClBC,SAAUJ,EAAMI,SAChBiD,MAAOC,EACPhD,wBAAyBN,EAAMM,yBAEnC,CAEQ,wBAAA+I,CAAyB1jD,GAC/B,MAAQgiD,YAAatiD,GAAYrB,KAC3BwnD,EAA4B,CAAC7lD,EAAI8lD,QAAS9lD,EAAI+lD,SAC9CC,EAA0B,CAAChmD,EAAIimD,MAAOjmD,EAAIkmD,OAC1ClsB,EAAOt6B,EAAQymD,wBAMrB,MAAO,CAAE7P,OAAQuP,EAAazP,KAAM4P,EAAWlC,MALb,CAChCkC,EAAU,GAAKhsB,EAAKtO,KAAOhc,OAAO02C,YAClCJ,EAAU,GAAKhsB,EAAKja,IAAMrQ,OAAO22C,aAIrC,CAEQ,cAAAf,GACN,MAAQrrB,MAAOqsB,EAAgBpsB,OAAQqsB,GACrCloD,KAAKkkD,cAGP,GAAuB,IAAnB+D,GAA4C,IAApBC,EAC1B,OAGF,MAAQzB,UAAW0B,EAAU/H,mBAAoBZ,GAAsBx/C,KACjEg+C,EAAeiK,GAAkBC,EACjCtsB,EAAQoiB,EAAeiK,EAAiB,EAAS3D,eACjDzoB,EAASmiB,EAAe,EAASsG,eAAiB4D,EAExD,ICvOJ,SACEE,EACAC,EACA7I,GAOA,OALqB4I,GAAiBC,EAElC,CAAC,EAAAhI,0BAA0BgC,IAAK,EAAAhC,0BAA0BiI,QAC1D,CAAC,EAAAjI,0BAA0BiC,KAAM,EAAAjC,0BAA0BC,QAEhC5zC,SAAS8yC,EAC1C,CD6NO+I,CACCN,EACAC,EACA1I,GAGF,MAAM,IAAI12C,MACR,uEAIJ,IAAI0/C,EACAC,EAEJN,EAASv0C,KAAO,CAAEgoB,QAAOC,UAErBmiB,GACFyK,EAAe,EACfD,EACEhJ,IAAsBa,EAAA,EAA0BgC,KAC3CxmB,EACDqsB,IAENM,EAAc,EACdC,EACEjJ,IAAsBa,EAAA,EAA0BiC,MAC3C1mB,EACDqsB,GAGRE,EAASzmC,IAAM8mC,EACfL,EAAS96B,KAAOo7B,CAClB,CAgEQ,6BAAA9B,GACN,MAAQR,uBAAwBuC,GAAY1oD,MACpC2jD,YAAatiD,GAAYrB,KAEjC0oD,EAAQhT,iBAAiBr0C,EAAS,YAAarB,KAAK0kD,oBACpDgE,EAAQhT,iBAAiBr0C,EAAS,WAAYrB,KAAK6kD,mBACnD6D,EAAQhT,iBACNr0C,EACA,YACArB,KAAK+kD,mBAET,CAEQ,qBAAAC,CAAsBrjD,GAC5B,MAAQwkD,uBAAwBuC,GAAY1oD,KAGtC2oD,EAAmB,CAAEvoD,OAFZJ,KAAKqlD,yBAAyB1jD,GAEVy6C,SADlB,IAAKp8C,KAAK28C,QAAQP,WAGnCp8C,KAAKkmD,2BAELwC,EAAQhT,iBAAiB0H,SAAU,cAAep9C,KAAKimD,kBACvDyC,EAAQhT,iBAAiB0H,SAAU,iBAAkBz7C,GACnD3B,KAAKilD,mBAAmBtjD,EAAKgnD,IAEjC,CAEQ,wBAAAzC,GACN,MAAQC,uBAAwBuC,GAAY1oD,KAE5C0oD,EAAQlT,oBAAoB4H,SAAU,eACtCsL,EAAQlT,oBAAoB4H,SAAU,gBACxC,E,uEE7VF,MAAM,OAAExwC,GAAW,EAAAR,MACbw8C,EAAoB,CAAEpX,OAAQ,IAAMC,MAAO,KAKjD,MAAMoX,UAAyBtE,EAAA,EAO7B,WAAAjjD,CAAY06C,GACV,MAAM,QAAE36C,EAAO,SAAEoD,GAAau3C,EACxBG,EAAa0M,EAAiBC,eAAeznD,EAASoD,GACtD23C,EAAWyM,EAAiBE,aAAa1nD,EAASoD,GAExDhD,MAAM,IAAKu6C,EAAOG,aAAYC,aAqFxB,KAAA4M,cAAgB,KAGtB,GAAIhpD,KAAKipD,oBACP,OAGF,MAAMC,EAAWlpD,KAAKmpD,eAAiBhpC,KAAKC,MAExC8oC,GAAY,EACdlpD,KAAK8kD,YAEL9kD,KAAKipD,oBAAsB53C,OAAOC,YAAW,KAE3CtR,KAAKipD,oBAAsB,EAC3BjpD,KAAKgpD,eAAe,GACnBE,EACL,EASM,KAAAE,uBAAyB,KAC/BppD,KAAKm8C,WAAa0M,EAAiBC,eAAe9oD,KAAKqpD,SAAS,EAG1D,KAAAC,6BACN3nD,IAEA,MAAM,SAAE8C,GAAa9C,EAAIG,OAAO2H,YAEhC,GAAIhF,IAAazE,KAAKupD,UACpB,OAGF,MAAQF,SAAUhoD,GAAYrB,KAC9BA,KAAKm8C,WAAa0M,EAAiBC,eAAeznD,EAASoD,EAAS,EAG9D,KAAA+kD,6BACN7nD,IAEA,MAAM,WAAEoL,EAAU,SAAEtI,EAAUoC,MAAOu1C,EAAQ,SAAEF,GAAav6C,EAAIG,QAC1D,SAAEb,GAAajB,KAAKgD,eACtB+J,IAAe9L,EAAS2O,IAAMnL,IAAazE,KAAKupD,YAIpDvpD,KAAKo8C,SAAWA,EAEZF,IACFl8C,KAAK4mD,mBAAqB1K,EAAS3hC,MAErCva,KAAKypD,uBAAsB,EAGrB,KAAAC,kCACN/nD,IAEA,MAAM,WAAEoL,EAAU,SAAEmvC,EAAQ,SAAEz3C,GAAa9C,EAAIG,QACzC,SAAEb,GAAajB,KAAKgD,eAEtB+J,IAAe9L,EAAS2O,IAAMnL,IAAazE,KAAKupD,YAIpDvpD,KAAK4mD,mBAAqB1K,EAAS3hC,KAAI,EAzJvCva,KAAKqpD,SAAWhoD,EAChBrB,KAAKupD,UAAY9kD,EAEjBzE,KAAK2pD,8BACP,CAEA,WAAWtoD,GACT,OAAOrB,KAAKqpD,QACd,CAEA,kBAAWrmD,GACT,OAAO,IAAAC,mBAAkBjD,KAAKqpD,SAChC,CAEU,iBAAAjE,GACR,MAAM,SAAEnkD,GAAajB,KAAKgD,eAC1B,OC5CJ,SACE/B,EACAwD,EACAyD,GAMA,GAAiB,OAFA,gCAA4BjH,EAAUwD,GAEhC,CACrB,MAAM,YAAEmlD,EAAW,aAAEC,GAAiB5oD,EAASI,QACzCyoD,EAAe,EAAI5/C,KAAKW,IAAI++C,EAAaC,GACzCE,GAAc,IAAAlP,qBAAoB55C,EAAUwD,IAC5C,mBAAEulD,GAAqB,GAAS9hD,GAAW,CAAC,EAI5C+hD,EAAcD,EAAqB,EAAIF,EAE7C,OAAOC,EACH,CAACE,EAAaH,GACd,CAACG,EAvBkB,EAwBzB,CAEA,MAAO,CA1BkB,IA2B3B,CDmBW7E,CAAkBnkD,EAAUjB,KAAKupD,UAC1C,CAEU,WAAAxC,CAAY3K,GACpB36C,MAAMslD,YAAY3K,GAElB,MAAM,SAAEn7C,GAAajB,KAAKgD,eAE1B,GAAI/B,aAAoB,EAAA2H,cACtB3H,EAASipD,cAAc,CACrB9N,SAAUA,IAEZn7C,EAAS+hC,cACJ,GAAI/hC,aAAoB,EAAAuN,eAAgB,CAC7C,MAAQ+6C,UAAW9kD,GAAazE,KAC1BmqD,EAA+B,EAAA7hD,UAAA,yBACnC7D,EACAxD,EAASwkB,mBAGXxkB,EAASipD,cAAc,CAAE9N,YAAY33C,GACrC0lD,EAA6B19C,SAASotC,GAAOA,EAAG7W,UAClD,CACF,CAEQ,qBAAO8lB,CAAeznD,EAASoD,GACrC,MAAMzB,GAAiB,IAAAC,mBAAkB5B,IACnC,SAAEJ,GAAa+B,EAEfoG,EAAQ3E,EACVxD,EAASmtC,SAAS3pC,GAClBxD,EAAS2oC,kBAEb,IAAKxgC,EACH,OAAOw/C,EAGT,MACMzM,EADY/yC,EAAMA,MAAMilC,YAAYC,eACb10B,eAAeC,aAAauwC,WAEzD,OAAyB,IAAlBjO,EAAW,IAA8B,IAAlBA,EAAW,GACrCyM,EACA,CAAEpX,MAAO2K,EAAW,GAAI1K,MAAO0K,EAAW,GAChD,CAEQ,mBAAO4M,CAAa1nD,EAASoD,GACnC,MAAMzB,GAAiB,IAAAC,mBAAkB5B,IACnC,SAAEJ,GAAa+B,EAEfqnD,EAAc5lD,EAChBxD,EAASmtC,SAAS3pC,GAClBxD,EAAS2oC,kBAEb,IAAKygB,IAAgB,EAAA/hD,UAAA,aAAuB+hD,GAC1C,OAAOzB,EAGT,MAAMxM,EAAYiO,EAAYjhD,MAC3BkhD,cACAC,uBAAuB,GACvBH,WAEH,OAAuB,IAAhBhO,EAAS,IAA4B,IAAhBA,EAAS,GACjCwM,EACA,CAAEpX,MAAO4K,EAAS,GAAI3K,MAAO2K,EAAS,GAC5C,CAsBQ,oBAAAqN,CAAqBe,EAAW,KACtCxqD,KAAKmpD,eAAiBhpC,KAAKC,MAAQoqC,EACnCxqD,KAAK2kD,YACL3kD,KAAKgpD,eACP,CAiDQ,4BAAAW,GACN,MAAQN,SAAUhoD,GAAYrB,KAE9B,EAAA6H,YAAY6tC,iBACV9oC,EAAO69C,sBACPzqD,KAAKspD,8BAGPjoD,EAAQq0C,iBACN9oC,EAAO6oC,gBACPz1C,KAAKopD,wBAGP/nD,EAAQq0C,iBACN9oC,EAAO89C,aACP1qD,KAAKwpD,8BAGPnoD,EAAQq0C,iBACN9oC,EAAO+9C,kBACP3qD,KAAK0pD,kCAET,E,kBE9MF,IAAYrJ,E,iBAAZ,SAAYA,GACV,YACA,cACA,kBACA,eACD,CALD,CAAYA,IAAAA,EAAyB,I,2RCQrC,SAASuK,EAAuBjxC,EAAWvK,EAAGgJ,EAAGwjB,EAAOC,GACtD,MAAMgvB,EAAY,GAClB,IAAIl2C,EAAQ,EACZ,MAAMm2C,EAAYnxC,EAAU0kB,WAC5B,IAAI0sB,EAASC,EAAKC,EAElB,GAAItxC,EAAU3V,MACZ,IAAKgnD,EAAM,EAAGA,EAAMnvB,EAAQmvB,IAC1B,IAAKC,EAAS,EAAGA,EAASrvB,EAAOqvB,IAAU,CACzCF,EAA2D,IAA/CC,EAAM5yC,GAAKuB,EAAUuxC,SAAWD,EAAS77C,IACrD,MAAM+7C,EAAML,EAAUC,GAChBK,EAAQN,EAAUC,EAAU,GAC5BM,EAAOP,EAAUC,EAAU,GAEjCF,EAAUl2C,KAAW,MAASw2C,EAAM,MAASC,EAAQ,MAASC,CAChE,MAGF,IAAKL,EAAM,EAAGA,EAAMnvB,EAAQmvB,IAC1B,IAAKC,EAAS,EAAGA,EAASrvB,EAAOqvB,IAC/BF,GAAWC,EAAM5yC,GAAKuB,EAAUuxC,SAAWD,EAAS77C,GACpDy7C,EAAUl2C,KAAWm2C,EAAUC,GAKrC,OAAOF,CACT,CCxCA,SAASS,EAAoBC,EAAgBC,EAAWC,GACtD,MAAMC,EAAYH,EAAejoD,OACjC,IAAIsH,EAAM6gD,EACN5gD,EAAM2gD,EACN56C,EAAM,EAEV,GAAI86C,EAAY,EACd,MAAO,CACL9gD,MACAC,MACA+gB,MAAO4/B,EAAYC,GAAa,GAIpC,IAAK,IAAI92C,EAAQ,EAAGA,EAAQ+2C,EAAW/2C,IAAS,CAC9C,MAAMg3C,EAAMJ,EAAe52C,GAE3B/J,EAAMV,KAAKU,IAAIA,EAAK+gD,GACpB9gD,EAAMX,KAAKW,IAAIA,EAAK8gD,GACpB/6C,GAAO+6C,CACT,CAEA,MAAO,CACL/gD,MACAC,MACA+gB,KAAMhb,EAAM86C,EAEhB,C,eCpBA,SAASE,EAAiC3qD,GACxC,GAAIA,aAAoB,EAAAuN,eACtB,OASJ,SAAgCvN,GAC9B,MAAM,WAAEo9B,EAAU,MAAEzC,EAAK,OAAEC,GACzB,0CAAsC56B,IAChC2J,IAAKihD,EAAehhD,IAAKihD,GAC/B,sBAAkBztB,GACd55B,EAAWxD,EAAS8qD,cACpBrnD,EAAS,EAAAC,MAAMC,UAAUH,IAEzB,SAAE3E,EAAQ,yBAAEksD,GAA6BtnD,GACvCunD,KAAMC,EAAMC,QAASjB,GAAYprD,GACnC,MAAEkE,GAAUgoD,EAClB,MAAO,CACL3tB,aACAzC,QACAC,SACAgwB,gBACAC,gBACAI,OACAhB,UACAlnD,QAEJ,CA9BWooD,CAAuBnrD,GAEhC,GAAIA,aAAoB,EAAA2H,cACtB,OA6BJ,SAA+B3H,GAC7B,MAAM0Y,EAAY1Y,EAAS63B,gBACrB,WAAEuF,GAAe1kB,GACf/O,IAAKihD,EAAehhD,IAAKihD,GAC/B,sBAAkBztB,GACdzC,EAAQjiB,EAAU1O,WAAW,GAC7B4wB,EAASliB,EAAU1O,WAAW,IAC9B,KAAEihD,EAAI,QAAEhB,EAAO,MAAElnD,GAAU/C,EAASorD,sBAE1C,MAAO,CACLhuB,aACAzC,QACAC,SACAgwB,gBACAC,gBACAI,OACAhB,UACAlnD,QAEJ,CAhDWsoD,CAAsBrrD,GAG/B,MAAM,IAAI6H,MAAM,yBAClB,C,oFCXA,MAAM,cACJyjD,EAAa,cACbC,GACE,EAAAC,EAMJ,SAASC,EAAwBC,EAAWC,GAmB1CA,EAAMC,eAAe/7C,KAAK,2BAM1B67C,EAAUG,iBAAmB,IAAMF,EAAMG,cAMzCJ,EAAUpxC,iBAAmBD,IAC3BsxC,EAAMG,cAAgBzxC,EACtBqxC,EAAU7c,UAAU,EAEtB,MAAMkd,EAAM,GACNC,EAAe,GACfC,EAAW,GACXC,EAAc,IAAeC,cAWnCT,EAAUU,gBAAkB,CAAC5lB,EAAK6lB,EAAMhzC,EAASizC,EAAYC,EAASC,KACpE,MAAOpqD,EAAGiV,EAAG+M,GAAKoiB,EAGlBulB,EAAI,GAAK3nC,EAAIioC,EAAK,GAAKA,EAAK,GAAKh1C,EAAIg1C,EAAK,GAAKjqD,EAC/C2pD,EAAI,GAAKA,EAAI,GAAKO,EAAWC,GAC7BR,EAAI,GAAKA,EAAI,GAAKO,EAAWE,GAC7BT,EAAI,GAAKA,EAAI,GAAKO,EAAWC,GAG7B,IAAK,IAAIE,EAAK,EAAGA,EAAK,IAAKA,EACzBT,EAAaS,GAAMpzC,EAAQ0yC,EAAIU,GACjC,EAWFf,EAAUgB,eAAiB,CAAClmB,EAAKuC,EAAQ7mB,EAASqqC,EAASC,KACzD,MAAMpqD,EAAIokC,EAAI+lB,GACRl1C,EAAImvB,EAAIgmB,GAGdP,EAAS,GAAKljB,EAAOwjB,GAAWnqD,EAAI8f,EAAQqqC,GAC5CN,EAAS,GAAKljB,EAAOyjB,GAAWn1C,EAAI6K,EAAQsqC,GAC5CP,EAAS,GAAKA,EAAS,GAAK/pC,EAAQqqC,GACpCN,EAAS,GAAKA,EAAS,GACvBA,EAAS,GAAKA,EAAS,GACvBA,EAAS,GAAKA,EAAS,GAAK/pC,EAAQsqC,GACpCP,EAAS,GAAKA,EAAS,GACvBA,EAAS,GAAKA,EAAS,EAAE,EAiB3BP,EAAUiB,aAAe,CAACC,EAAMpmB,EAAK6lB,EAAMtjB,EAAQ7mB,EAAS7I,EAASla,EAAQqV,EAAO83C,EAAYC,EAASC,KACvG,MAAMpoC,EAAIoiB,EAAImlB,EAAMkB,aACdC,EAAY,CAAC,EAAG,EAAG,EAAG,GACtBC,EAAM,GACZ,IAAIC,EACJtB,EAAUU,gBAAgB5lB,EAAK6lB,EAAMhzC,EAASizC,EAAYC,EAASC,GACnE,IAAI94C,EAAQ,EACZ,IAAK,IAAI8W,EAAM,EAAGA,EAAM,EAAGA,IACrBwhC,EAAaxhC,IAAQoiC,IACvBl5C,GAASo5C,EAAUtiC,IAIvB,MAAMyiC,EAAa,IAAaC,QAAQx5C,GACxC,GAAIu5C,EAAW,GAAK,EAClB,OAGFvB,EAAUgB,eAAelmB,EAAKuC,EAAQ7mB,EAASqqC,EAASC,GACxD,MAAMzzC,EAAIgwB,EAAO4iB,EAAMkB,aAAezoC,EAAIlC,EAAQypC,EAAMkB,aACxD,IAAK,IAAIriC,EAAM,EAAGyiC,EAAWziC,IAAQ,EAAGA,GAAO,EAAG,CAChDhW,EAAM3E,KAAK,GACX,IAAK,IAAIs9C,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAChC,MAAMC,EAAY,IAAaC,QAAQJ,EAAWziC,EAAM2iC,IAKxD,GAJAH,OAAM3rD,EACFsqD,EAAM2B,cACRN,EAAMd,EAAYqB,eAAexB,EAAIqB,EAAU,IAAKrB,EAAIqB,EAAU,MAAMvzC,YAE9DxY,IAAR2rD,EAAmB,CACrB,MAAMtxB,GAAKkxB,EAAOZ,EAAaoB,EAAU,MAAQpB,EAAaoB,EAAU,IAAMpB,EAAaoB,EAAU,KAC/FI,EAAKvB,EAASzpD,MAAqB,EAAf4qD,EAAU,GAA6B,GAApBA,EAAU,GAAK,IACtDjgC,EAAK8+B,EAASzpD,MAAqB,EAAf4qD,EAAU,GAA6B,GAApBA,EAAU,GAAK,IAC5DL,EAAIR,GAAWiB,EAAG,GAAK9xB,GAAKvO,EAAG,GAAKqgC,EAAG,IACvCT,EAAIP,GAAWgB,EAAG,GAAK9xB,GAAKvO,EAAG,GAAKqgC,EAAG,IACvCT,EAAIpB,EAAMkB,aAAe9zC,EACzBi0C,EAAM7tD,EAAOkD,OAAS,EACtBlD,EAAO0Q,KAAKk9C,EAAI,GAAIA,EAAI,GAAIA,EAAI,IAC5BpB,EAAM2B,aACRpB,EAAYuB,WAAW1B,EAAIqB,EAAU,IAAKrB,EAAIqB,EAAU,IAAKJ,EAEjE,CACAx4C,EAAM3E,KAAKm9C,EACb,CACF,GAEFtB,EAAUgC,YAAc,CAACC,EAAQC,KAE/B,MAAMnlB,EAAQklB,EAAO,GACrB,IAAKllB,EAEH,YADA6iB,EAAc,4BAGhB,GAAyB,MAArBK,EAAMkB,aAAuBlB,EAAMkB,YAAc,GAAKlB,EAAMkB,YAAc,EAE5E,YADAvB,EAAc,mCAGhBhzC,QAAQmG,KAAK,YAGb,MAAMsqB,EAASN,EAAMolB,YACf3rC,EAAUumB,EAAM9K,aAChB0uB,EAAO5jB,EAAMvgB,gBACb4lC,EAASrlB,EAAMslB,YACfzB,EAAa7jB,EAAMulB,kBAAkBF,GACrCz0C,EAAUovB,EAAM9vB,eAAeC,aAAaC,WAC3C0zC,EAASC,GAjKlB,WACE,IAAID,EAAU,EACVC,EAAU,EAQd,OAP0B,IAAtBb,EAAMkB,aACRN,EAAU,EACVC,EAAU,GACqB,IAAtBb,EAAMkB,cACfN,EAAU,EACVC,EAAU,GAEL,CAACD,EAASC,EACnB,CAsJ6ByB,GAGrB9uD,EAAS,GAGTqV,EAAQ,GAGd,IAAI4P,EAAInb,KAAKk9B,MAAMwlB,EAAMnpD,OACrB4hB,GAAKioC,EAAKV,EAAMkB,eAClBzoC,EAAI,GAIN,MAAMoiB,EAAM,CAAC,EAAG,EAAG,GACnBA,EAAImlB,EAAMkB,aAAezoC,EACzB,IAAK,IAAI8pC,EAAK,EAAGA,EAAKvC,EAAMG,cAAczpD,SAAU6rD,EAAI,CACtD,IAAK,IAAI72C,EAAI,EAAGA,EAAIg1C,EAAKG,GAAW,IAAKn1C,EAAG,CAC1CmvB,EAAIgmB,GAAWn1C,EACf,IAAK,IAAIjV,EAAI,EAAGA,EAAIiqD,EAAKE,GAAW,IAAKnqD,EACvCokC,EAAI+lB,GAAWnqD,EACfspD,EAAUiB,aAAahB,EAAMG,cAAcoC,GAAK1nB,EAAK6lB,EAAMtjB,EAAQ7mB,EAAS7I,EAASla,EAAQqV,EAAO83C,EAAYC,EAASC,EAE7H,CACAN,EAAYiC,YACd,CAGA,MAAMC,EAAW,mBACjBA,EAAS74C,YAAY84C,QAAQ,IAAItqC,aAAa5kB,GAAS,GACvDivD,EAAS54C,WAAW64C,QAAQ,IAAIC,YAAY95C,IAC5Co5C,EAAQ,GAAKQ,EACb7C,EAAc,mBACdjzC,QAAQi2C,QAAQ,WAAW,CAE/B,CAMA,MAAMC,EAAiB,CACrB1C,cAAe,GACfe,YAAa,EACbrqD,MAAO,EACP8qD,aAAa,GAKf,SAASmB,EAAO/C,EAAWC,GACzB,IAAI+C,EAAgBC,UAAUtsD,OAAS,QAAsBhB,IAAjBstD,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzF5zB,OAAO8L,OAAO8kB,EAAO6C,EAAgBE,GAGrC,EAAAlD,EAAMoD,IAAIlD,EAAWC,GAGrB,EAAAH,EAAMqD,KAAKnD,EAAWC,EAAO,EAAG,GAChC,EAAAH,EAAMsD,OAAOpD,EAAWC,EAAO,CAAC,cAAe,QAAS,gBAGxD,EAAAH,EAAMqD,KAAKnD,EAAWC,EAAO,EAAG,GAChCF,EAAwBC,EAAWC,EACrC,CAQA,IAAIoD,EAA4B,CAC9B5C,YALkB,EAAAX,EAAMW,YAAYsC,EAAQ,2BAM5CA,S","sources":["webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/base/AnnotationTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/displayTools/Labelmap/labelmapConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/annotationFrameRange.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/annotationHydration.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/boundingBox/extend2DBoundingBoxInViewAxis.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/boundingBox/getBoundingBoxAroundShape.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/calibrateImageSpacing.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/cine/events.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/cine/state.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/cine/playClip.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/clip.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/addContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/areSameSegment.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/isContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/removeContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/calculatePerimeter.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/findHandlePolylineIndex.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/areCoplanarContours.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/contourFinder.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/getDeduplicatedVTKPolyDataPoints.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/detectContourHoles.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/generateContourSetsFromLabelmap.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/AnnotationToPointData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/getContourHolesDataWorld.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/getContourHolesDataCanvas.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/interpolation/acceptAutogeneratedInterpolations.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/updateContourPolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/debounce.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/drawing/getTextBoxCoordsCanvas.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/dynamicVolume/getDataInTime.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/dynamicVolume/generateImageFromTimeData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getAnnotationNearPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getCalibratedUnits.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getSphereBoundsInfo.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getViewportForAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/isObject.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/aabb/intersectAABB.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/aabb/distanceToPointSquared.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/aabb/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/basic/Calculator.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/basic/BasicStatsCalculator.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/ellipse/pointInEllipse.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/ellipse/getCanvasEllipseCorners.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/distanceToPointSquaredInfo.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/distanceToPointSquared.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/intersectLine.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/isPointOnLineSegment.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/point/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/point/distanceToPointSquared.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/point/mirror.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/isClosed.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/containsPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/containsPoints.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getArea.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getSignedArea.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getWindingDirection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getNormal3.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getNormal2.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/areLineSegmentsIntersecting.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getLineSegmentIntersectionsIndexes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getLinesIntersection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/combinePolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getFirstLineSegmentIntersectionIndexes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/intersectPolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/decimate.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getLineSegmentIntersectionsCoordinates.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getClosestLineSegmentIntersection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getSubPixelSpacingAndXYDirections.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/pointsAreWithinCloseContourProximity.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/addCanvasPointsToArray.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/pointCanProjectOnLine.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/projectTo2D.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/isPointInsidePolyline3D.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/rectangle/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/sphere/pointInSphere.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/vec2/liangBarksyClip.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/orientation/getOrientationStringLPS.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/orientation/invertOrientationStringLPS.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/planarFreehandROITool/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/planar/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/pointInShapeCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/pointInSurroundingSphereCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/pointToString.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/polyData/utils.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/rectangleROITool/getBoundsIJKFromRectangleAnnotations.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/rectangleROITool/isAxisAlignedRectangle.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/scroll.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/InterpolationManager/InterpolationManager.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/brushReplaceForToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/brushSizeForToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/brushThresholdForToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/isLineInSegment.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/findLargestBidirectional.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/contourAndFindLargestBidirectional.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/createBidirectionalToolData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/createImageIdReferenceMap.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/createLabelmapVolumeForViewport.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/createMergedLabelmapForIndex.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/floodFill.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getDefaultRepresentationConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getHoveredContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getSegmentAtLabelmapBorder.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getSegmentAtWorldPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/invalidateBrushCursor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/isValidRepresentationConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/rectangleROIThresholdVolumeByRange.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/segmentContourAction.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/thresholdSegmentationByRange.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/thresholdVolumeByRange.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/utilities.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/stackPrefetch/stackPrefetch.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/stackPrefetch/stackContextPrefetch.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/throttle.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/touch/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/triggerAnnotationRenderForToolGroupIds.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/filterViewportsWithFrameOfReferenceUID.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/filterViewportsWithToolEnabled.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/filterViewportsWithParallelNormals.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/getViewportIdsWithToolToRender.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewport/isViewportPreScaled.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewport/jumpToSlice.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewport/jumpToWorld.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/common/isRangeValid.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/common/isColorbarSizeValid.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/common/areColorbarRangesEqual.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/common/areColorbarSizesEqual.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/vec3/interpolateVec3.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/ColorbarCanvas.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/ColorbarTicks.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/widgets/Widget.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/Colorbar.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/common/isRangeTextPositionValid.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/ViewportColorbar.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getVOIMultipliers.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/windowlevel/getLuminanceFromRegion.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/windowlevel/calculateMinMaxMean.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/windowlevel/extractWindowLevelRegionToolData.ts","webpack:///../../../node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares.js"],"sourcesContent":["import {\r\n  BaseVolumeViewport,\r\n  cache,\r\n  getEnabledElement,\r\n  metaData,\r\n  utilities as csUtils,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { vec2 } from 'gl-matrix';\r\n\r\nimport AnnotationDisplayTool from './AnnotationDisplayTool';\r\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\r\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\r\nimport {\r\n  Annotation,\r\n  Annotations,\r\n  EventTypes,\r\n  ToolHandle,\r\n  InteractionTypes,\r\n  ToolProps,\r\n  PublicToolProps,\r\n} from '../../types';\r\nimport { addAnnotation } from '../../stateManagement/annotation/annotationState';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\r\n\r\n/**\r\n * Abstract class for tools which create and display annotations on the\r\n * cornerstone3D canvas. In addition, it provides a base class for segmentation\r\n * tools that require drawing an annotation before running the segmentation strategy\r\n * for instance threshold segmentation based on an area and a threshold.\r\n * Annotation tools make use of drawing utilities to draw SVG elements on the viewport.\r\n *\r\n * To create a new annotation tool, derive from this class and implement the\r\n * abstract methods.\r\n */\r\nabstract class AnnotationTool extends AnnotationDisplayTool {\r\n  /**\r\n   * Creates a base annotation object, adding in any annotation base data provided\r\n   */\r\n  public static createAnnotation(...annotationBaseData): Annotation {\r\n    let annotation: Annotation = {\r\n      annotationUID: null as string,\r\n      highlighted: true,\r\n      invalidated: true,\r\n      metadata: {\r\n        toolName: this.toolName,\r\n      },\r\n      data: {\r\n        text: '',\r\n        handles: {\r\n          points: new Array<Types.Point3>(),\r\n          textBox: {\r\n            hasMoved: false,\r\n            worldPosition: <Types.Point3>[0, 0, 0],\r\n            worldBoundingBox: {\r\n              topLeft: <Types.Point3>[0, 0, 0],\r\n              topRight: <Types.Point3>[0, 0, 0],\r\n              bottomLeft: <Types.Point3>[0, 0, 0],\r\n              bottomRight: <Types.Point3>[0, 0, 0],\r\n            },\r\n          },\r\n        },\r\n        label: '',\r\n      },\r\n    } as unknown as Annotation;\r\n    for (const baseData of annotationBaseData) {\r\n      annotation = csUtils.deepMerge(annotation, baseData);\r\n    }\r\n    return annotation;\r\n  }\r\n\r\n  /**\r\n   * Creates a new annotation for the given viewport.  This just adds the\r\n   * viewport reference data to the metadata, and otherwise returns the\r\n   * static class createAnnotation data.\r\n   */\r\n  public static createAnnotationForViewport(viewport, ...annotationBaseData) {\r\n    return this.createAnnotation(\r\n      { metadata: viewport.getViewReference() },\r\n      ...annotationBaseData\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Creates and adds an annotation of the given type, firing the annotation\r\n   * modified event on the new annotation.\r\n   * This implicitly uses the static class when you call it on the correct\r\n   * base class.  For example, you can call the KeyImageTool.createAnnotation\r\n   * method on KeyImageTool.toolName by calling KeyImageTool.createAndAddAnnotation\r\n   *\r\n   */\r\n  public static createAndAddAnnotation(viewport, ...annotationBaseData) {\r\n    const annotation = this.createAnnotationForViewport(\r\n      viewport,\r\n      ...annotationBaseData\r\n    );\r\n    addAnnotation(annotation, viewport.element);\r\n    triggerAnnotationModified(annotation, viewport.element);\r\n  }\r\n\r\n  static toolName;\r\n  // ===================================================================\r\n  // Abstract Methods - Must be implemented.\r\n  // ===================================================================\r\n\r\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\r\n    super(toolProps, defaultToolProps);\r\n\r\n    if (toolProps.configuration?.getTextLines) {\r\n      this.configuration.getTextLines = toolProps.configuration.getTextLines;\r\n    }\r\n\r\n    if (toolProps.configuration?.statsCalculator) {\r\n      this.configuration.statsCalculator =\r\n        toolProps.configuration.statsCalculator;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @abstract addNewAnnotation Creates a new annotation based on the clicked mouse position\r\n   *\r\n   * @param evt - The normalized mouse event\r\n   * @param interactionType -  The interaction type used to add the annotation.\r\n   */\r\n  abstract addNewAnnotation(\r\n    evt: EventTypes.InteractionEventType,\r\n    interactionType: InteractionTypes\r\n  ): Annotation;\r\n\r\n  /**\r\n   * @abstract cancel Used to cancel the ongoing tool drawing and manipulation\r\n   *\r\n   */\r\n  abstract cancel(element: HTMLDivElement);\r\n\r\n  /**\r\n   * handleSelectedCallback Custom callback for when a handle is selected.\r\n   *\r\n   * @param evt - The normalized mouse event\r\n   * @param annotation - The annotation selected.\r\n   * @param handle - The selected handle (either Types.Point3 in space for annotations, or TextBoxHandle object for text boxes).\r\n   * @param interactionType - The interaction type the handle was selected with.\r\n   */\r\n  abstract handleSelectedCallback(\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: Annotation,\r\n    handle: ToolHandle,\r\n    interactionType: InteractionTypes\r\n  ): void;\r\n\r\n  /**\r\n   * Custom callback for when an annotation is selected\r\n   *\r\n   * @param evt - The normalized mouse event\r\n   * @param annotation - The `Annotation` to check.\r\n   * @param interactionType - The interaction type used to select the tool.\r\n   */\r\n  abstract toolSelectedCallback(\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: Annotation,\r\n    interactionType: InteractionTypes,\r\n    canvasCoords?: Types.Point2\r\n  ): void;\r\n\r\n  /**\r\n   * Returns true if the provided canvas coordinate tool is near the annotation\r\n   *\r\n   * @param element - The HTML element\r\n   * @param annotation - The annotation to check\r\n   * @param canvasCoords - The canvas coordinate to check\r\n   * @param proximity - The minimum proximity to consider the point near\r\n   * @param interactionType - The interaction type used to select the tool.\r\n   *\r\n   * @returns boolean if the point is near.\r\n   */\r\n  abstract isPointNearTool(\r\n    element: HTMLDivElement,\r\n    annotation: Annotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number,\r\n    interactionType: string\r\n  ): boolean;\r\n\r\n  /**\r\n   * @virtual Event handler for Cornerstone MOUSE_MOVE event.\r\n   *\r\n   *\r\n   * @param evt - The normalized mouse event\r\n   * @param filteredAnnotations - The annotations to check for hover interactions\r\n   * @returns True if the annotation needs to be re-drawn by the annotationRenderingEngine.\r\n   */\r\n  public mouseMoveCallback = (\r\n    evt: EventTypes.MouseMoveEventType,\r\n    filteredAnnotations?: Annotations\r\n  ): boolean => {\r\n    if (!filteredAnnotations) {\r\n      return false;\r\n    }\r\n\r\n    const { element, currentPoints } = evt.detail;\r\n    const canvasCoords = currentPoints.canvas;\r\n    let annotationsNeedToBeRedrawn = false;\r\n\r\n    for (const annotation of filteredAnnotations) {\r\n      // Do not do anything if the annotation is locked or hidden.\r\n      if (\r\n        isAnnotationLocked(annotation) ||\r\n        !isAnnotationVisible(annotation.annotationUID)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      const { data } = annotation;\r\n      const activateHandleIndex = data.handles\r\n        ? data.handles.activeHandleIndex\r\n        : undefined;\r\n\r\n      // Perform tool specific imagePointNearToolOrHandle to determine if the mouse\r\n      // is near the tool or its handles or its textBox.\r\n      const near = this._imagePointNearToolOrHandle(\r\n        element,\r\n        annotation,\r\n        canvasCoords,\r\n        6 // Todo: This should come from the state\r\n      );\r\n\r\n      const nearToolAndNotMarkedActive = near && !annotation.highlighted;\r\n      const notNearToolAndMarkedActive = !near && annotation.highlighted;\r\n      if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\r\n        annotation.highlighted = !annotation.highlighted;\r\n        annotationsNeedToBeRedrawn = true;\r\n      } else if (\r\n        data.handles &&\r\n        data.handles.activeHandleIndex !== activateHandleIndex\r\n      ) {\r\n        // Active handle index has changed, re-render.\r\n        annotationsNeedToBeRedrawn = true;\r\n      }\r\n    }\r\n\r\n    return annotationsNeedToBeRedrawn;\r\n  };\r\n\r\n  /**\r\n   * It checks if the mouse click is near TextBoxHandle or AnnotationHandle itself, and\r\n   * return either it. It prioritize TextBoxHandle over AnnotationHandle. If\r\n   * the mouse click is not near any of the handles, it does not return anything.\r\n   *\r\n   * @param element - The element that the tool is attached to.\r\n   * @param annotation - The annotation object associated with the annotation\r\n   * @param canvasCoords - The coordinates of the mouse click on canvas\r\n   * @param proximity - The distance from the mouse cursor to the point\r\n   * that is considered \"near\".\r\n   * @returns The handle that is closest to the cursor, or null if the cursor\r\n   * is not near any of the handles.\r\n   */\r\n  getHandleNearImagePoint(\r\n    element: HTMLDivElement,\r\n    annotation: Annotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): ToolHandle | undefined {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    const { data } = annotation;\r\n    const { isCanvasAnnotation } = data;\r\n    const { points, textBox } = data.handles;\r\n\r\n    if (textBox) {\r\n      const { worldBoundingBox } = textBox;\r\n      if (worldBoundingBox) {\r\n        const canvasBoundingBox = {\r\n          topLeft: viewport.worldToCanvas(worldBoundingBox.topLeft),\r\n          topRight: viewport.worldToCanvas(worldBoundingBox.topRight),\r\n          bottomLeft: viewport.worldToCanvas(worldBoundingBox.bottomLeft),\r\n          bottomRight: viewport.worldToCanvas(worldBoundingBox.bottomRight),\r\n        };\r\n\r\n        if (\r\n          canvasCoords[0] >= canvasBoundingBox.topLeft[0] &&\r\n          canvasCoords[0] <= canvasBoundingBox.bottomRight[0] &&\r\n          canvasCoords[1] >= canvasBoundingBox.topLeft[1] &&\r\n          canvasCoords[1] <= canvasBoundingBox.bottomRight[1]\r\n        ) {\r\n          data.handles.activeHandleIndex = null;\r\n          return textBox as ToolHandle;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i < points?.length; i++) {\r\n      const point = points[i];\r\n      const annotationCanvasCoordinate = isCanvasAnnotation\r\n        ? point.slice(0, 2)\r\n        : viewport.worldToCanvas(point);\r\n\r\n      const near =\r\n        vec2.distance(\r\n          canvasCoords,\r\n          annotationCanvasCoordinate as Types.Point2\r\n        ) < proximity;\r\n\r\n      if (near === true) {\r\n        data.handles.activeHandleIndex = i;\r\n        return point;\r\n      }\r\n    }\r\n\r\n    data.handles.activeHandleIndex = null;\r\n  }\r\n\r\n  /**\r\n   * It returns the style for the text box\r\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\r\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\r\n   * met (hierarchy is checked from most specific to least specific which is\r\n   * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\r\n   * @param annotation - The annotation for the tool that is\r\n   * currently active.\r\n   * @returns An object of the style settings for the text box.\r\n   */\r\n  public getLinkedTextBoxStyle(\r\n    specifications: StyleSpecifier,\r\n    annotation?: Annotation\r\n  ): Record<string, unknown> {\r\n    // Todo: this function can be used to set different styles for different toolMode\r\n    // for the textBox.\r\n\r\n    return {\r\n      visibility: this.getStyle(\r\n        'textBoxVisibility',\r\n        specifications,\r\n        annotation\r\n      ),\r\n      fontFamily: this.getStyle(\r\n        'textBoxFontFamily',\r\n        specifications,\r\n        annotation\r\n      ),\r\n      fontSize: this.getStyle('textBoxFontSize', specifications, annotation),\r\n      color: this.getStyle('textBoxColor', specifications, annotation),\r\n      shadow: this.getStyle('textBoxShadow', specifications, annotation),\r\n      background: this.getStyle(\r\n        'textBoxBackground',\r\n        specifications,\r\n        annotation\r\n      ),\r\n      lineWidth: this.getStyle(\r\n        'textBoxLinkLineWidth',\r\n        specifications,\r\n        annotation\r\n      ),\r\n      lineDash: this.getStyle(\r\n        'textBoxLinkLineDash',\r\n        specifications,\r\n        annotation\r\n      ),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Returns true if the viewport is scaled to SUV units\r\n   * @param viewport - The viewport\r\n   * @param targetId - The annotation targetId\r\n   * @param imageId - The annotation imageId\r\n   * @returns\r\n   */\r\n  isSuvScaled(\r\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\r\n    targetId: string,\r\n    imageId?: string\r\n  ): boolean {\r\n    if (viewport instanceof BaseVolumeViewport) {\r\n      const volumeId = csUtils.getVolumeId(targetId);\r\n      const volume = cache.getVolume(volumeId);\r\n      return volume?.scaling?.PT !== undefined;\r\n    }\r\n    const scalingModule: Types.ScalingParameters | undefined =\r\n      imageId && metaData.get('scalingModule', imageId);\r\n    return typeof scalingModule?.suvbw === 'number';\r\n  }\r\n\r\n  /**\r\n   * Get the style that will be applied to all annotations such as length, cobb\r\n   * angle, arrow annotate, etc. when rendered on a canvas or svg layer\r\n   */\r\n  protected getAnnotationStyle(context: {\r\n    annotation: Annotation;\r\n    styleSpecifier: StyleSpecifier;\r\n  }) {\r\n    const { annotation, styleSpecifier } = context;\r\n    const getStyle = (property) =>\r\n      this.getStyle(property, styleSpecifier, annotation);\r\n    const { annotationUID } = annotation;\r\n    const visibility = isAnnotationVisible(annotationUID);\r\n    const locked = isAnnotationLocked(annotation);\r\n\r\n    const lineWidth = getStyle('lineWidth') as number;\r\n    const lineDash = getStyle('lineDash') as string;\r\n    const color = getStyle('color') as string;\r\n    const shadow = getStyle('shadow') as boolean;\r\n    const textboxStyle = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\r\n\r\n    return {\r\n      visibility,\r\n      locked,\r\n      color,\r\n      lineWidth,\r\n      lineDash,\r\n      lineOpacity: 1,\r\n      fillColor: color,\r\n      fillOpacity: 0,\r\n      shadow,\r\n      textbox: textboxStyle,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Returns true if the `canvasCoords` are near a handle or selectable part of the tool\r\n   *\r\n   * @param element - The HTML element\r\n   * @param annotation - The annotation to check\r\n   * @param canvasCoords - The canvas coordinates to check\r\n   * @param proximity - The proximity to consider\r\n   *\r\n   * @returns If the point is near.\r\n   */\r\n  private _imagePointNearToolOrHandle(\r\n    element: HTMLDivElement,\r\n    annotation: Annotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): boolean {\r\n    // Based on the tool instance type, check if the point is near the tool handles\r\n    const handleNearImagePoint = this.getHandleNearImagePoint(\r\n      element,\r\n      annotation,\r\n      canvasCoords,\r\n      proximity\r\n    );\r\n\r\n    if (handleNearImagePoint) {\r\n      return true;\r\n    }\r\n\r\n    // If the point is not near the handles, check if the point is near the tool\r\n    const toolNewImagePoint = this.isPointNearTool(\r\n      element,\r\n      annotation,\r\n      canvasCoords,\r\n      proximity,\r\n      'mouse'\r\n    );\r\n\r\n    if (toolNewImagePoint) {\r\n      return true;\r\n    }\r\n  }\r\n}\r\n\r\nAnnotationTool.toolName = 'AnnotationTool';\r\nexport default AnnotationTool;\r\n","import { LabelmapConfig } from '../../../types/LabelmapTypes';\r\n\r\nconst defaultLabelmapConfig: LabelmapConfig = {\r\n  renderOutline: true,\r\n  outlineWidthActive: 3,\r\n  outlineWidthInactive: 2,\r\n  activeSegmentOutlineWidthDelta: 0,\r\n  renderFill: true,\r\n  renderFillInactive: true,\r\n  fillAlpha: 0.7,\r\n  fillAlphaInactive: 0.65,\r\n  outlineOpacity: 1,\r\n  outlineOpacityInactive: 0.85,\r\n};\r\n\r\nfunction getDefaultLabelmapConfig(): LabelmapConfig {\r\n  return defaultLabelmapConfig;\r\n}\r\n\r\n// Checks if the labelmap config is valid, which means\r\n// if all the required fields are present and have the correct type\r\nfunction isValidLabelmapConfig(config): boolean {\r\n  return (\r\n    config &&\r\n    typeof config.renderOutline === 'boolean' &&\r\n    typeof config.outlineWidthActive === 'number' &&\r\n    typeof config.outlineWidthInactive === 'number' &&\r\n    typeof config.activeSegmentOutlineWidthDelta === 'number' &&\r\n    typeof config.renderFill === 'boolean' &&\r\n    typeof config.renderFillInactive === 'boolean' &&\r\n    typeof config.fillAlpha === 'number' &&\r\n    typeof config.fillAlphaInactive === 'number' &&\r\n    typeof config.outlineOpacity === 'number' &&\r\n    typeof config.outlineOpacityInactive === 'number'\r\n  );\r\n}\r\n\r\nexport default getDefaultLabelmapConfig;\r\nexport { isValidLabelmapConfig };\r\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\r\nimport Events from '../enums/Events';\r\nimport { Annotation } from '../types';\r\n\r\nexport type FramesRange = [number, number] | number;\r\n\r\n/**\r\n * This class handles the annotation frame range values for multiframes.\r\n * Mostly used for the Video viewport, it allows references to\r\n * a range of frame values.\r\n */\r\nexport default class AnnotationFrameRange {\r\n  protected static frameRangeExtractor =\r\n    /(\\/frames\\/|[&?]frameNumber=)([^/&?]*)/i;\r\n\r\n  protected static imageIdToFrames(imageId: string): FramesRange {\r\n    const match = imageId.match(this.frameRangeExtractor);\r\n    if (!match || !match[2]) {\r\n      return null;\r\n    }\r\n    const range = match[2].split('-').map((it) => Number(it));\r\n    if (range.length === 1) {\r\n      return range[0];\r\n    }\r\n    return range as FramesRange;\r\n  }\r\n\r\n  public static framesToString(range) {\r\n    if (Array.isArray(range)) {\r\n      return `${range[0]}-${range[1]}`;\r\n    }\r\n    return String(range);\r\n  }\r\n\r\n  protected static framesToImageId(\r\n    imageId: string,\r\n    range: FramesRange | string\r\n  ): string {\r\n    const match = imageId.match(this.frameRangeExtractor);\r\n    if (!match || !match[2]) {\r\n      return null;\r\n    }\r\n    const newRangeString = this.framesToString(range);\r\n    return imageId.replace(\r\n      this.frameRangeExtractor,\r\n      `${match[1]}${newRangeString}`\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Sets the range of frames to associate with the given annotation.\r\n   * The range can be a single frame number (1 based according to DICOM),\r\n   * or a range of values in the format `min-max` where min, max are inclusive\r\n   * Modifies the referencedImageID to specify the updated URL.\r\n   */\r\n  public static setFrameRange(\r\n    annotation: Annotation,\r\n    range: FramesRange | string,\r\n    eventBase?: { viewportId; renderingEngineId }\r\n  ) {\r\n    const { referencedImageId } = annotation.metadata;\r\n    annotation.metadata.referencedImageId = this.framesToImageId(\r\n      referencedImageId,\r\n      range\r\n    );\r\n    const eventDetail = {\r\n      ...eventBase,\r\n      annotation,\r\n    };\r\n    triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);\r\n  }\r\n\r\n  public static getFrameRange(\r\n    annotation: Annotation\r\n  ): number | [number, number] {\r\n    return this.imageIdToFrames(annotation.metadata.referencedImageId);\r\n  }\r\n}\r\n","import {\r\n  Types,\r\n  utilities,\r\n  BaseVolumeViewport,\r\n  StackViewport,\r\n  cache,\r\n  metaData,\r\n} from '@cornerstonejs/core';\r\nimport { Annotation } from '../types';\r\nimport { addAnnotation } from '../stateManagement';\r\nimport { vec3 } from 'gl-matrix';\r\n\r\nfunction annotationHydration(\r\n  viewport: Types.IViewport,\r\n  toolName: string,\r\n  worldPoints: Types.Point3[],\r\n  options?: {\r\n    FrameOfReferenceUID?: string;\r\n    annotationUID?: string;\r\n  }\r\n): Annotation {\r\n  const viewReference = viewport.getViewReference();\r\n  const { viewPlaneNormal, FrameOfReferenceUID } = viewReference;\r\n  const annotation = {\r\n    annotationUID: options?.annotationUID || utilities.uuidv4(),\r\n    data: {\r\n      handles: {\r\n        points: worldPoints,\r\n      },\r\n    },\r\n    highlighted: false,\r\n    autoGenerated: false,\r\n    invalidated: false,\r\n    isLocked: false,\r\n    isVisible: true,\r\n    metadata: {\r\n      toolName,\r\n      viewPlaneNormal,\r\n      FrameOfReferenceUID,\r\n      referencedImageId: getReferencedImageId(\r\n        viewport,\r\n        worldPoints[0],\r\n        viewPlaneNormal\r\n      ),\r\n      ...options,\r\n    },\r\n  };\r\n  addAnnotation(annotation, viewport.element);\r\n  return annotation;\r\n}\r\n\r\nfunction getReferencedImageId(\r\n  viewport: Types.IViewport,\r\n  worldPos: Types.Point3,\r\n  viewPlaneNormal: Types.Point3\r\n): string {\r\n  let referencedImageId;\r\n\r\n  if (viewport instanceof StackViewport) {\r\n    referencedImageId = getClosestImageIdForStackViewport(\r\n      viewport,\r\n      worldPos,\r\n      viewPlaneNormal\r\n    );\r\n  } else if (viewport instanceof BaseVolumeViewport) {\r\n    const targetId = getTargetId(viewport);\r\n    const volumeId = utilities.getVolumeId(targetId);\r\n    const imageVolume = cache.getVolume(volumeId);\r\n\r\n    referencedImageId = utilities.getClosestImageId(\r\n      imageVolume,\r\n      worldPos,\r\n      viewPlaneNormal\r\n    );\r\n  } else {\r\n    throw new Error(\r\n      'getReferencedImageId: viewport must be a StackViewport or BaseVolumeViewport'\r\n    );\r\n  }\r\n\r\n  return referencedImageId;\r\n}\r\n\r\nfunction getTargetId(viewport: Types.IViewport): string | undefined {\r\n  const targetId = viewport.getReferenceId?.();\r\n  if (targetId) {\r\n    return targetId;\r\n  }\r\n  if (viewport instanceof BaseVolumeViewport) {\r\n    return `volumeId:${getTargetVolumeId(viewport)}`;\r\n  }\r\n  throw new Error('getTargetId: viewport must have a getTargetId method');\r\n}\r\n\r\nfunction getTargetVolumeId(viewport: Types.IViewport): string | undefined {\r\n  const actorEntries = viewport.getActors();\r\n\r\n  if (!actorEntries) {\r\n    return;\r\n  }\r\n  return actorEntries.find(\r\n    (actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume'\r\n  )?.uid;\r\n}\r\n\r\nfunction getClosestImageIdForStackViewport(\r\n  viewport: StackViewport,\r\n  worldPos: Types.Point3,\r\n  viewPlaneNormal: Types.Point3\r\n): string {\r\n  const imageIds = viewport.getImageIds();\r\n  if (!imageIds || !imageIds.length) {\r\n    return;\r\n  }\r\n\r\n  const distanceImagePairs = imageIds.map((imageId) => {\r\n    const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\r\n    const distance = calculateDistanceToImage(\r\n      worldPos,\r\n      imagePositionPatient,\r\n      viewPlaneNormal\r\n    );\r\n    return { imageId, distance };\r\n  });\r\n\r\n  distanceImagePairs.sort((a, b) => a.distance - b.distance);\r\n\r\n  return distanceImagePairs[0].imageId;\r\n}\r\n\r\nfunction calculateDistanceToImage(\r\n  worldPos: Types.Point3,\r\n  ImagePositionPatient: Types.Point3,\r\n  viewPlaneNormal: Types.Point3\r\n): number {\r\n  const dir = vec3.create();\r\n  vec3.sub(dir, worldPos, ImagePositionPatient);\r\n\r\n  const dot = vec3.dot(dir, viewPlaneNormal);\r\n\r\n  return Math.abs(dot);\r\n}\r\nexport { annotationHydration, getClosestImageIdForStackViewport };\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Uses the current bounds of the 2D rectangle and extends it in the view axis by numSlices\r\n * It compares min and max of each IJK to find the view axis (for axial, zMin === zMax) and\r\n * then calculates the extended range. It will assume the slice is relative to the\r\n * current slice and will add the given slices to the current max of the boundingBox.\r\n * @param boundsIJK - [[iMin, iMax], [jMin, jMax], [kMin, kMax]]\r\n * @param slices - number of slices to project before and after\r\n * @returns extended bounds\r\n */\r\nfunction extend2DBoundingBoxInViewAxis(\r\n  boundsIJK: [Types.Point2, Types.Point2, Types.Point2],\r\n  numSlicesToProject: number\r\n): [Types.Point2, Types.Point2, Types.Point2] {\r\n  // find which index in boundsIJK has the same first and last value\r\n  const sliceNormalIndex = boundsIJK.findIndex(([min, max]) => min === max);\r\n\r\n  if (sliceNormalIndex === -1) {\r\n    throw new Error('3D bounding boxes not supported in an oblique plane');\r\n  }\r\n\r\n  // get the index and subtract slices from the min and add to the max\r\n  boundsIJK[sliceNormalIndex][0] -= numSlicesToProject;\r\n  boundsIJK[sliceNormalIndex][1] += numSlicesToProject;\r\n  return boundsIJK;\r\n}\r\n\r\nexport default extend2DBoundingBoxInViewAxis;\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport { CONSTANTS } from '@cornerstonejs/core';\r\n\r\nconst { EPSILON } = CONSTANTS;\r\n\r\n/** Bounding box type */\r\ntype BoundingBox =\r\n  | [Types.Point2, Types.Point2, null]\r\n  | [Types.Point2, Types.Point2, Types.Point2];\r\n\r\nfunction calculateBoundingBox(\r\n  points,\r\n  dimensions,\r\n  isWorld = false\r\n): BoundingBox {\r\n  let xMin = Infinity;\r\n  let xMax = isWorld ? -Infinity : 0;\r\n  let yMin = Infinity;\r\n  let yMax = isWorld ? -Infinity : 0;\r\n  let zMin = Infinity;\r\n  let zMax = isWorld ? -Infinity : 0;\r\n\r\n  const is3D = points[0]?.length === 3;\r\n\r\n  // use for loop for performance\r\n  for (let i = 0; i < points.length; i++) {\r\n    const p = points[i];\r\n    xMin = Math.min(p[0], xMin);\r\n    xMax = Math.max(p[0], xMax);\r\n    yMin = Math.min(p[1], yMin);\r\n    yMax = Math.max(p[1], yMax);\r\n\r\n    if (is3D) {\r\n      zMin = Math.min(p[2] ?? zMin, zMin);\r\n      zMax = Math.max(p[2] ?? zMax, zMax);\r\n    }\r\n  }\r\n\r\n  if (dimensions) {\r\n    xMin = Math.max(isWorld ? dimensions[0] + EPSILON : 0, xMin);\r\n    xMax = Math.min(\r\n      isWorld ? dimensions[0] - EPSILON : dimensions[0] - 1,\r\n      xMax\r\n    );\r\n    yMin = Math.max(isWorld ? dimensions[1] + EPSILON : 0, yMin);\r\n    yMax = Math.min(\r\n      isWorld ? dimensions[1] - EPSILON : dimensions[1] - 1,\r\n      yMax\r\n    );\r\n\r\n    if (is3D && dimensions.length === 3) {\r\n      zMin = Math.max(isWorld ? dimensions[2] + EPSILON : 0, zMin);\r\n      zMax = Math.min(\r\n        isWorld ? dimensions[2] - EPSILON : dimensions[2] - 1,\r\n        zMax\r\n      );\r\n    }\r\n  } else if (!isWorld) {\r\n    // still need to bound to 0 and Infinity if no dimensions are provided for ijk\r\n    xMin = Math.max(0, xMin);\r\n    xMax = Math.min(Infinity, xMax);\r\n    yMin = Math.max(0, yMin);\r\n    yMax = Math.min(Infinity, yMax);\r\n\r\n    if (is3D) {\r\n      zMin = Math.max(0, zMin);\r\n      zMax = Math.min(Infinity, zMax);\r\n    }\r\n  }\r\n\r\n  return is3D\r\n    ? [\r\n        [xMin, xMax],\r\n        [yMin, yMax],\r\n        [zMin, zMax],\r\n      ]\r\n    : [[xMin, xMax], [yMin, yMax], null];\r\n}\r\n\r\n/**\r\n * With a given vertices (points) coordinates in 2D or 3D in IJK, it calculates the minimum and maximum\r\n * coordinate in each axis, and returns them. If clipBounds are provided it also\r\n * clip the min, max to the provided width, height and depth\r\n *\r\n * @param points - shape corner points coordinates either in IJK (image coordinate)\r\n * @param dimensions - bounds to clip the min, max\r\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\r\n */\r\nexport function getBoundingBoxAroundShapeIJK(\r\n  points: Types.Point2[] | Types.Point3[],\r\n  dimensions?: Types.Point2 | Types.Point3\r\n): BoundingBox {\r\n  return calculateBoundingBox(points, dimensions, false);\r\n}\r\n\r\n/**\r\n * With a given vertices (points) coordinates in 2D or 3D in World Coordinates, it calculates the minimum and maximum\r\n * coordinate in each axis, and returns them. If clipBounds are provided it also\r\n * clip the min, max to the provided width, height and depth\r\n *\r\n * @param points - shape corner points coordinates either in IJK (image coordinate)\r\n * @param clipBounds - bounds to clip the min, max\r\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\r\n */\r\nexport function getBoundingBoxAroundShapeWorld(\r\n  points: Types.Point2[] | Types.Point3[],\r\n  clipBounds?: Types.Point2 | Types.Point3\r\n): BoundingBox {\r\n  return calculateBoundingBox(points, clipBounds, true);\r\n}\r\n","import { utilities, Enums } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nconst { calibratedPixelSpacingMetadataProvider } = utilities;\r\n\r\n/**\r\n * It adds the provided spacing to the Cornerstone internal calibratedPixelSpacing\r\n * metadata provider, then it invalidates all the tools that have the imageId as\r\n * their reference imageIds. Finally, it triggers a re-render for invalidated annotations.\r\n * @param imageId - ImageId for the calibrated image\r\n * @param rowPixelSpacing - Spacing in row direction\r\n * @param calibrationOrScale - either the calibration object or a scale value\r\n */\r\nexport default function calibrateImageSpacing(\r\n  imageId: string,\r\n  renderingEngine: Types.IRenderingEngine,\r\n  calibrationOrScale: Types.IImageCalibration | number\r\n): void {\r\n  // Handle simple parameter version\r\n  if (typeof calibrationOrScale === 'number') {\r\n    calibrationOrScale = {\r\n      type: Enums.CalibrationTypes.USER,\r\n      scale: calibrationOrScale,\r\n    };\r\n  }\r\n  // 1. Add the calibratedPixelSpacing metadata to the metadata\r\n  calibratedPixelSpacingMetadataProvider.add(imageId, calibrationOrScale);\r\n\r\n  // 2. Update the actor for stackViewports\r\n  const viewports = renderingEngine.getStackViewports();\r\n\r\n  // 2.1 If imageId is already being used in a stackViewport -> update actor\r\n  viewports.forEach((viewport) => {\r\n    const imageIds = viewport.getImageIds();\r\n    if (imageIds.includes(imageId)) {\r\n      viewport.calibrateSpacing(imageId);\r\n    }\r\n  });\r\n\r\n  // 2.2 If imageId is cached but not being displayed in a viewport, stackViewport\r\n  // will handle using the calibratedPixelSpacing since it has been added\r\n  // to the provider\r\n}\r\n","/**\r\n * CINE Tool Events\r\n */\r\nenum Events {\r\n  CLIP_STOPPED = 'CORNERSTONE_CINE_TOOL_STOPPED',\r\n  CLIP_STARTED = 'CORNERSTONE_CINE_TOOL_STARTED',\r\n}\r\n\r\nexport default Events;\r\n","import { getEnabledElement } from '@cornerstonejs/core';\r\nimport { CINETypes } from '../../types';\r\n\r\nconst state: Record<string, CINETypes.ToolData> = {};\r\n\r\nfunction addToolState(element: HTMLDivElement, data: CINETypes.ToolData): void {\r\n  const enabledElement = getEnabledElement(element);\r\n  const { viewportId } = enabledElement;\r\n  state[viewportId] = data;\r\n}\r\n\r\nfunction getToolState(element: HTMLDivElement): CINETypes.ToolData | undefined {\r\n  const enabledElement = getEnabledElement(element);\r\n  const { viewportId } = enabledElement;\r\n  return state[viewportId];\r\n}\r\n\r\nfunction getToolStateByViewportId(\r\n  viewportId: string\r\n): CINETypes.ToolData | undefined {\r\n  return state[viewportId];\r\n}\r\n\r\nexport { addToolState, getToolState, getToolStateByViewportId };\r\n","import { glMatrix, vec3 } from 'gl-matrix';\r\nimport {\r\n  utilities as csUtils,\r\n  getEnabledElement,\r\n  StackViewport,\r\n  VolumeViewport,\r\n  cache,\r\n  BaseVolumeViewport,\r\n  Enums,\r\n} from '@cornerstonejs/core';\r\n\r\nimport { Types } from '@cornerstonejs/core';\r\nimport CINE_EVENTS from './events';\r\nimport { addToolState, getToolState, getToolStateByViewportId } from './state';\r\nimport { CINETypes } from '../../types';\r\nimport scroll from '../scroll';\r\n\r\nconst { ViewportStatus } = Enums;\r\nconst { triggerEvent } = csUtils;\r\n\r\nconst debounced = true;\r\nconst dynamicVolumesPlayingMap = new Map();\r\n\r\n/**\r\n * Starts playing a clip or adjusts the frame rate of an already playing clip.  framesPerSecond is\r\n * optional and defaults to 30 if not specified.  A negative framesPerSecond will play the clip in reverse.\r\n * The element must be a stack of images\r\n * @param element - HTML Element\r\n * @param framesPerSecond - Number of frames per second\r\n */\r\nfunction playClip(\r\n  element: HTMLDivElement,\r\n  playClipOptions: CINETypes.PlayClipOptions\r\n): void {\r\n  let playClipTimeouts;\r\n  let playClipIsTimeVarying;\r\n\r\n  if (element === undefined) {\r\n    throw new Error('playClip: element must not be undefined');\r\n  }\r\n\r\n  const enabledElement = getEnabledElement(element);\r\n\r\n  if (!enabledElement) {\r\n    throw new Error(\r\n      'playClip: element must be a valid Cornerstone enabled element'\r\n    );\r\n  }\r\n\r\n  if (!playClipOptions) {\r\n    playClipOptions = {};\r\n  }\r\n\r\n  // 4D Cine is enabled by default\r\n  playClipOptions.dynamicCineEnabled =\r\n    playClipOptions.dynamicCineEnabled ?? true;\r\n\r\n  const { viewport } = enabledElement;\r\n  const volume = _getVolumeFromViewport(viewport);\r\n  const playClipContext = _createCinePlayContext(viewport, playClipOptions);\r\n  let playClipData = getToolState(element);\r\n\r\n  const isDynamicCinePlaying =\r\n    playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume();\r\n\r\n  // If user is trying to play CINE for a 4D volume it first needs\r\n  // to stop CINE that has may be playing for any other viewport.\r\n  if (isDynamicCinePlaying) {\r\n    _stopDynamicVolumeCine(element);\r\n  }\r\n\r\n  if (!playClipData) {\r\n    playClipData = {\r\n      intervalId: undefined,\r\n      framesPerSecond: 30,\r\n      lastFrameTimeStamp: undefined,\r\n      ignoreFrameTimeVector: false,\r\n      usingFrameTimeVector: false,\r\n      frameTimeVector: playClipOptions.frameTimeVector ?? undefined,\r\n      speed: playClipOptions.frameTimeVectorSpeedMultiplier ?? 1,\r\n      reverse: playClipOptions.reverse ?? false,\r\n      loop: playClipOptions.loop ?? true,\r\n    };\r\n    addToolState(element, playClipData);\r\n  } else {\r\n    // Make sure the specified clip is not running before any property update.\r\n    // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\r\n    // prevent stopping a 4D CINE in case it is playing on another viewport.\r\n    _stopClip(element, {\r\n      stopDynamicCine: !isDynamicCinePlaying,\r\n      viewportId: viewport.id,\r\n    });\r\n  }\r\n\r\n  playClipData.dynamicCineEnabled = playClipOptions.dynamicCineEnabled;\r\n\r\n  // If a framesPerSecond is specified and is valid, update the playClipData now\r\n  if (\r\n    playClipOptions.framesPerSecond < 0 ||\r\n    playClipOptions.framesPerSecond > 0\r\n  ) {\r\n    playClipData.framesPerSecond = Number(playClipOptions.framesPerSecond);\r\n    playClipData.reverse = playClipData.framesPerSecond < 0;\r\n    // If framesPerSecond is given, frameTimeVector will be ignored...\r\n    playClipData.ignoreFrameTimeVector = true;\r\n  }\r\n\r\n  // Determine if frame time vector should be used instead of a fixed frame rate...\r\n  if (\r\n    playClipData.ignoreFrameTimeVector !== true &&\r\n    playClipData.frameTimeVector &&\r\n    playClipData.frameTimeVector.length === playClipContext.numScrollSteps &&\r\n    playClipContext.frameTimeVectorEnabled\r\n  ) {\r\n    const { timeouts, isTimeVarying } = _getPlayClipTimeouts(\r\n      playClipData.frameTimeVector,\r\n      playClipData.speed\r\n    );\r\n\r\n    playClipTimeouts = timeouts;\r\n    playClipIsTimeVarying = isTimeVarying;\r\n  }\r\n\r\n  // This function encapsulates the frame rendering logic...\r\n  const playClipAction = () => {\r\n    const { numScrollSteps, currentStepIndex } = playClipContext;\r\n    let newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);\r\n    const newStepIndexOutOfRange =\r\n      newStepIndex < 0 || newStepIndex >= numScrollSteps;\r\n\r\n    if (!playClipData.loop && newStepIndexOutOfRange) {\r\n      // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\r\n      // prevent stopping a 4D CINE in case it is playing on another viewport.\r\n      _stopClip(element, {\r\n        stopDynamicCine: !isDynamicCinePlaying,\r\n        viewportId: viewport.id,\r\n      });\r\n\r\n      const eventDetail = { element };\r\n\r\n      triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, eventDetail);\r\n      return;\r\n    }\r\n\r\n    // Loop around if newStepIndex is out of range\r\n    if (newStepIndex >= numScrollSteps) {\r\n      newStepIndex = 0;\r\n    } else if (newStepIndex < 0) {\r\n      newStepIndex = numScrollSteps - 1;\r\n    }\r\n\r\n    const delta = newStepIndex - currentStepIndex;\r\n\r\n    if (delta) {\r\n      playClipContext.scroll(delta);\r\n    }\r\n  };\r\n\r\n  if (isDynamicCinePlaying) {\r\n    dynamicVolumesPlayingMap.set(volume.volumeId, element);\r\n  }\r\n\r\n  // If playClipTimeouts array is available, not empty and its elements are NOT uniform ...\r\n  // ... (at least one timeout is different from the others), use alternate setTimeout implementation\r\n  if (\r\n    playClipTimeouts &&\r\n    playClipTimeouts.length > 0 &&\r\n    playClipIsTimeVarying\r\n  ) {\r\n    playClipData.usingFrameTimeVector = true;\r\n    playClipData.intervalId = window.setTimeout(\r\n      function playClipTimeoutHandler() {\r\n        playClipData.intervalId = window.setTimeout(\r\n          playClipTimeoutHandler,\r\n          playClipTimeouts[playClipContext.currentStepIndex]\r\n        );\r\n        playClipAction();\r\n      },\r\n      0\r\n    );\r\n  } else {\r\n    // ... otherwise user setInterval implementation which is much more efficient.\r\n    playClipData.usingFrameTimeVector = false;\r\n    playClipData.intervalId = window.setInterval(\r\n      playClipAction,\r\n      1000 / Math.abs(playClipData.framesPerSecond)\r\n    );\r\n  }\r\n\r\n  const eventDetail = {\r\n    element,\r\n  };\r\n\r\n  triggerEvent(element, CINE_EVENTS.CLIP_STARTED, eventDetail);\r\n}\r\n\r\n/**\r\n * Stops an already playing clip.\r\n * @param element - HTML Element\r\n */\r\nfunction stopClip(element: HTMLDivElement, options = {} as any): void {\r\n  _stopClip(element, {\r\n    stopDynamicCine: true,\r\n    ...options,\r\n  });\r\n}\r\n\r\nfunction _stopClip(\r\n  element: HTMLDivElement,\r\n  options = { stopDynamicCine: true, viewportId: undefined }\r\n) {\r\n  const { stopDynamicCine, viewportId } = options;\r\n  const enabledElement = getEnabledElement(element);\r\n\r\n  let toolState;\r\n  if (!enabledElement) {\r\n    if (viewportId) {\r\n      toolState = getToolStateByViewportId(viewportId);\r\n    } else {\r\n      return;\r\n    }\r\n  } else {\r\n    const { viewport } = enabledElement;\r\n    toolState = getToolState(viewport.element);\r\n  }\r\n\r\n  if (toolState) {\r\n    _stopClipWithData(toolState);\r\n  }\r\n\r\n  if (\r\n    stopDynamicCine &&\r\n    enabledElement?.viewport instanceof BaseVolumeViewport\r\n  ) {\r\n    _stopDynamicVolumeCine(element);\r\n  }\r\n}\r\n\r\n/**\r\n * [private] Stops any CINE playing for the dynamic volume loaded on this viewport\r\n * @param element - HTML Element\r\n */\r\nfunction _stopDynamicVolumeCine(element) {\r\n  const { viewport } = getEnabledElement(element);\r\n  const volume = _getVolumeFromViewport(viewport);\r\n\r\n  // If the current viewport has a 4D volume loaded it may be playing\r\n  // if it is also loaded on another viewport and user has started CINE\r\n  // for that one. This guarantees the other viewport will also be stopped.\r\n  if (volume?.isDynamicVolume()) {\r\n    const dynamicCineElement = dynamicVolumesPlayingMap.get(volume.volumeId);\r\n\r\n    dynamicVolumesPlayingMap.delete(volume.volumeId);\r\n\r\n    if (dynamicCineElement && dynamicCineElement !== element) {\r\n      stopClip(<HTMLDivElement>dynamicCineElement);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * [private] Turns a Frame Time Vector (0018,1065) array into a normalized array of timeouts. Each element\r\n * ... of the resulting array represents the amount of time each frame will remain on the screen.\r\n * @param vector - A Frame Time Vector (0018,1065) as specified in section C.7.6.5.1.2 of DICOM standard.\r\n * @param speed - A speed factor which will be applied to each element of the resulting array.\r\n * @returns An array with timeouts for each animation frame.\r\n */\r\nfunction _getPlayClipTimeouts(vector: number[], speed: number) {\r\n  let i;\r\n  let sample;\r\n  let delay;\r\n  let sum = 0;\r\n  const limit = vector.length;\r\n  const timeouts = [];\r\n\r\n  // Initialize time varying to false\r\n  let isTimeVarying = false;\r\n\r\n  if (typeof speed !== 'number' || speed <= 0) {\r\n    speed = 1;\r\n  }\r\n\r\n  // First element of a frame time vector must be discarded\r\n  for (i = 1; i < limit; i++) {\r\n    // eslint-disable-next-line no-bitwise\r\n    delay = (Number(vector[i]) / speed) | 0; // Integral part only\r\n    timeouts.push(delay);\r\n    if (i === 1) {\r\n      // Use first item as a sample for comparison\r\n      sample = delay;\r\n    } else if (delay !== sample) {\r\n      isTimeVarying = true;\r\n    }\r\n\r\n    sum += delay;\r\n  }\r\n\r\n  if (timeouts.length > 0) {\r\n    if (isTimeVarying) {\r\n      // If it's a time varying vector, make the last item an average...\r\n      // eslint-disable-next-line no-bitwise\r\n      delay = (sum / timeouts.length) | 0;\r\n    } else {\r\n      delay = timeouts[0];\r\n    }\r\n\r\n    timeouts.push(delay);\r\n  }\r\n\r\n  return { timeouts, isTimeVarying };\r\n}\r\n\r\n/**\r\n * [private] Performs the heavy lifting of stopping an ongoing animation.\r\n * @param element - HTML Element\r\n * @param playClipData - The data from playClip that needs to be stopped.\r\n */\r\nfunction _stopClipWithData(playClipData) {\r\n  const id = playClipData.intervalId;\r\n\r\n  if (typeof id !== 'undefined') {\r\n    playClipData.intervalId = undefined;\r\n    if (playClipData.usingFrameTimeVector) {\r\n      clearTimeout(id);\r\n    } else {\r\n      clearInterval(id);\r\n    }\r\n  }\r\n}\r\n\r\nfunction _getVolumesFromViewport(viewport): Types.IImageVolume[] {\r\n  return viewport\r\n    .getActors()\r\n    .map((actor) => cache.getVolume(actor.uid))\r\n    .filter((volume) => !!volume);\r\n}\r\n\r\nfunction _getVolumeFromViewport(viewport): Types.IImageVolume {\r\n  const volumes = _getVolumesFromViewport(viewport);\r\n  const dynamicVolume = volumes.find((volume) => volume.isDynamicVolume());\r\n\r\n  return dynamicVolume ?? volumes[0];\r\n}\r\n\r\nfunction _createStackViewportCinePlayContext(\r\n  viewport: StackViewport,\r\n  waitForRendered: number\r\n): CINETypes.CinePlayContext {\r\n  const imageIds = viewport.getImageIds();\r\n\r\n  return {\r\n    get numScrollSteps(): number {\r\n      return imageIds.length;\r\n    },\r\n    get currentStepIndex(): number {\r\n      return viewport.getTargetImageIdIndex();\r\n    },\r\n    get frameTimeVectorEnabled(): boolean {\r\n      // It is always in acquired orientation\r\n      return true;\r\n    },\r\n    waitForRenderedCount: 0,\r\n    scroll(delta: number): void {\r\n      if (\r\n        this.waitForRenderedCount <= waitForRendered &&\r\n        viewport.viewportStatus !== ViewportStatus.RENDERED\r\n      ) {\r\n        this.waitForRenderedCount++;\r\n        return;\r\n      }\r\n      this.waitForRenderedCount = 0;\r\n      scroll(viewport, { delta, debounceLoading: debounced });\r\n    },\r\n  };\r\n}\r\n\r\nfunction _createVolumeViewportCinePlayContext(\r\n  viewport: VolumeViewport,\r\n  volume: Types.IImageVolume\r\n): CINETypes.CinePlayContext {\r\n  const { volumeId } = volume;\r\n  const cachedScrollInfo = {\r\n    viewPlaneNormal: vec3.create(),\r\n    scrollInfo: null,\r\n  };\r\n\r\n  const getScrollInfo = () => {\r\n    const camera = viewport.getCamera();\r\n    const updateCache =\r\n      !cachedScrollInfo.scrollInfo ||\r\n      !vec3.equals(camera.viewPlaneNormal, cachedScrollInfo.viewPlaneNormal);\r\n\r\n    // Number of steps would change only after rotating the volume so it\r\n    // caches the result and recomputes only when necessary. Until it is\r\n    // rotated the current frame is updated locally\r\n    if (updateCache) {\r\n      const scrollInfo = csUtils.getVolumeViewportScrollInfo(\r\n        viewport,\r\n        volumeId\r\n      );\r\n\r\n      cachedScrollInfo.viewPlaneNormal = camera.viewPlaneNormal;\r\n      cachedScrollInfo.scrollInfo = scrollInfo;\r\n    }\r\n\r\n    return cachedScrollInfo.scrollInfo;\r\n  };\r\n\r\n  return {\r\n    get numScrollSteps(): number {\r\n      return getScrollInfo().numScrollSteps;\r\n    },\r\n    get currentStepIndex(): number {\r\n      return getScrollInfo().currentStepIndex;\r\n    },\r\n    get frameTimeVectorEnabled(): boolean {\r\n      const camera = viewport.getCamera();\r\n      const volumeViewPlaneNormal = volume.direction\r\n        .slice(6, 9)\r\n        .map((x) => -x) as Types.Point3;\r\n      const dot = vec3.dot(volumeViewPlaneNormal, camera.viewPlaneNormal);\r\n\r\n      // Check if the volume is in acquired orientation\r\n      // it may be flipped or rotated in plane\r\n      return glMatrix.equals(dot, 1);\r\n    },\r\n    scroll(delta: number): void {\r\n      getScrollInfo().currentStepIndex += delta;\r\n      scroll(viewport, { delta });\r\n    },\r\n  };\r\n}\r\n\r\nfunction _createDynamicVolumeViewportCinePlayContext(\r\n  volume: Types.IDynamicImageVolume\r\n): CINETypes.CinePlayContext {\r\n  return {\r\n    get numScrollSteps(): number {\r\n      return volume.numTimePoints;\r\n    },\r\n    get currentStepIndex(): number {\r\n      return volume.timePointIndex;\r\n    },\r\n    get frameTimeVectorEnabled(): boolean {\r\n      // Looping throught time does not uses frameTimeVector\r\n      return false;\r\n    },\r\n    scroll(delta: number): void {\r\n      // Updating this property (setter) makes it move to the desired time point\r\n      volume.timePointIndex += delta;\r\n    },\r\n  };\r\n}\r\n\r\nfunction _createCinePlayContext(\r\n  viewport,\r\n  playClipOptions: CINETypes.PlayClipOptions\r\n): CINETypes.CinePlayContext {\r\n  if (viewport instanceof StackViewport) {\r\n    return _createStackViewportCinePlayContext(\r\n      viewport,\r\n      playClipOptions.waitForRendered ?? 30\r\n    );\r\n  }\r\n\r\n  if (viewport instanceof VolumeViewport) {\r\n    const volume = _getVolumeFromViewport(viewport);\r\n\r\n    if (playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume()) {\r\n      return _createDynamicVolumeViewportCinePlayContext(\r\n        <Types.IDynamicImageVolume>volume\r\n      );\r\n    }\r\n\r\n    return _createVolumeViewportCinePlayContext(viewport, volume);\r\n  }\r\n\r\n  throw new Error('Unknown viewport type');\r\n}\r\n\r\nexport { playClip, stopClip };\r\n","/**\r\n * Clips a value to an upper and lower bound.\r\n * @export @public @method\r\n * @name clip\r\n *\r\n * @param  {number} val  The value to clip.\r\n * @param  {number} low  The lower bound.\r\n * @param  {number} high The upper bound.\r\n * @returns {number}      The clipped value.\r\n */\r\nexport function clip(val, low, high) {\r\n  return Math.min(Math.max(low, val), high);\r\n}\r\n\r\n/**\r\n * Clips a value within a box.\r\n * @export @public @method\r\n * @name clipToBox\r\n *\r\n * @param  {Object} point The point to clip\r\n * @param  {Object} box   The bounding box to clip to.\r\n * @returns {Object}       The clipped point.\r\n */\r\nexport function clipToBox(point, box) {\r\n  // Clip an {x, y} point to a box of size {width, height}\r\n  point.x = clip(point.x, 0, box.width);\r\n  point.y = clip(point.y, 0, box.height);\r\n}\r\n\r\nexport default clip;\r\n","import { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\r\nimport { ContourSegmentationAnnotation } from '../../types';\r\n\r\n/**\r\n * Adds a contour segmentation annotation to the specified segmentation.\r\n * @param annotation - The contour segmentation annotation to add.\r\n */\r\nexport function addContourSegmentationAnnotation(\r\n  annotation: ContourSegmentationAnnotation\r\n) {\r\n  if (annotation.parentAnnotationUID) {\r\n    // Don't add it for parent annotations - this happens during interpolation\r\n    return;\r\n  }\r\n  if (!annotation.data.segmentation) {\r\n    throw new Error(\r\n      'addContourSegmentationAnnotation: annotation does not have a segmentation data'\r\n    );\r\n  }\r\n\r\n  const { segmentationId, segmentIndex } = annotation.data.segmentation;\r\n  const segmentation = getSegmentation(segmentationId);\r\n\r\n  if (!segmentation.representationData.CONTOUR) {\r\n    segmentation.representationData.CONTOUR = { annotationUIDsMap: new Map() };\r\n  }\r\n\r\n  const { annotationUIDsMap } = segmentation.representationData.CONTOUR;\r\n\r\n  let annotationsUIDsSet = annotationUIDsMap.get(segmentIndex);\r\n\r\n  if (!annotationsUIDsSet) {\r\n    annotationsUIDsSet = new Set();\r\n    annotationUIDsMap.set(segmentIndex, annotationsUIDsSet);\r\n  }\r\n\r\n  annotationUIDsMap.set(\r\n    segmentIndex,\r\n    annotationsUIDsSet.add(annotation.annotationUID)\r\n  );\r\n}\r\n","import { ContourSegmentationAnnotation } from '../../types/ContourSegmentationAnnotation';\r\n\r\n/**\r\n * Check if two contour segmentations are from same segmentId,\r\n * segmentationRepresentationUID and segmentIndex.\r\n * @param firstAnnotation - First annotation\r\n * @param secondAnnotation - Second annotation\r\n * @returns True if they are from same segmentId, segmentationRepresentationUID\r\n * and segmentIndex or false otherwise.\r\n */\r\nexport default function areSameSegment(\r\n  firstAnnotation: ContourSegmentationAnnotation,\r\n  secondAnnotation: ContourSegmentationAnnotation\r\n) {\r\n  const { segmentation: firstSegmentation } = firstAnnotation.data;\r\n  const { segmentation: secondSegmentation } = secondAnnotation.data;\r\n\r\n  return (\r\n    firstSegmentation.segmentationId === secondSegmentation.segmentationId &&\r\n    firstSegmentation.segmentIndex === secondSegmentation.segmentIndex\r\n  );\r\n}\r\n","import { Annotation } from '../../types';\r\nimport { ContourSegmentationAnnotation } from '../../types/ContourSegmentationAnnotation';\r\n\r\nexport default function isContourSegmentationAnnotation(\r\n  annotation: Annotation\r\n): annotation is ContourSegmentationAnnotation {\r\n  return !!(<ContourSegmentationAnnotation>annotation).data?.segmentation;\r\n}\r\n","import { state } from '../../stateManagement/segmentation';\r\nimport { ContourSegmentationAnnotation } from '../../types';\r\n\r\n/**\r\n * Removes a contour segmentation annotation from the given annotation.\r\n * If the annotation does not have a segmentation data, this method returns\r\n * quietly.  This can occur for interpolated segmentations that have not yet\r\n * been converted to real segmentations or other in-process segmentations.\r\n * @param annotation - The contour segmentation annotation to remove.\r\n */\r\nexport function removeContourSegmentationAnnotation(\r\n  annotation: ContourSegmentationAnnotation\r\n) {\r\n  if (!annotation.data.segmentation) {\r\n    throw new Error(\r\n      'removeContourSegmentationAnnotation: annotation does not have a segmentation data'\r\n    );\r\n  }\r\n\r\n  const { segmentationId, segmentIndex } = annotation.data.segmentation;\r\n  const segmentation = state.getSegmentation(segmentationId);\r\n  const { annotationUIDsMap } = segmentation?.representationData.CONTOUR || {};\r\n  const annotationsUIDsSet = annotationUIDsMap?.get(segmentIndex);\r\n\r\n  if (!annotationsUIDsSet) {\r\n    return;\r\n  }\r\n\r\n  annotationsUIDsSet.delete(annotation.annotationUID);\r\n\r\n  // Delete segmentIndex Set if there is no more annotations\r\n  if (!annotationsUIDsSet.size) {\r\n    annotationUIDsMap.delete(segmentIndex);\r\n  }\r\n}\r\n","/**\r\n * Calculates the perimeter of a polyline.\r\n *\r\n * @param polyline - The polyline represented as an array of points.\r\n * @param closed - Indicates whether the polyline is closed or not.\r\n * @returns The perimeter of the polyline.\r\n */\r\nfunction calculatePerimeter(polyline: number[][], closed: boolean): number {\r\n  let perimeter = 0;\r\n\r\n  for (let i = 0; i < polyline.length - 1; i++) {\r\n    const point1 = polyline[i];\r\n    const point2 = polyline[i + 1];\r\n    perimeter += Math.sqrt(\r\n      Math.pow(point2[0] - point1[0], 2) + Math.pow(point2[1] - point1[1], 2)\r\n    );\r\n  }\r\n\r\n  if (closed) {\r\n    const firstPoint = polyline[0];\r\n    const lastPoint = polyline[polyline.length - 1];\r\n    perimeter += Math.sqrt(\r\n      Math.pow(lastPoint[0] - firstPoint[0], 2) +\r\n        Math.pow(lastPoint[1] - firstPoint[1], 2)\r\n    );\r\n  }\r\n\r\n  return perimeter;\r\n}\r\n\r\nexport default calculatePerimeter;\r\n","import { utilities as csUtils } from '@cornerstonejs/core';\r\nimport { vec3 } from 'gl-matrix';\r\n\r\nimport { ContourAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\n\r\nconst { isEqual } = csUtils;\r\n\r\n/**\r\n * Finds the index in the polyline of the specified handle.  If the handle\r\n * doesn't match a polyline point, then finds the closest polyline point.\r\n *\r\n * Assumes polyline is in the same orientation as the handles.\r\n *\r\n * @param annotation - to find the polyline and handles in\r\n * @param handleIndex - the index of hte handle to look for.\r\n *     Negative values are treated relative to the end of the handle index.\r\n * @returns Index in polyline of the closest handle\r\n *     * 0 for handleIndex 0\r\n *     * length for `handleIndex===handles length`\r\n */\r\nexport default function findHandlePolylineIndex(\r\n  annotation: ContourAnnotation,\r\n  handleIndex: number\r\n): number {\r\n  const { polyline } = annotation.data.contour;\r\n  const { points } = annotation.data.handles;\r\n  const { length } = points;\r\n  if (handleIndex === length) {\r\n    return polyline.length;\r\n  }\r\n  if (handleIndex < 0) {\r\n    handleIndex = (handleIndex + length) % length;\r\n  }\r\n  if (handleIndex === 0) {\r\n    return 0;\r\n  }\r\n  const handle = points[handleIndex];\r\n  const index = polyline.findIndex((point) => isEqual(handle, point));\r\n  if (index !== -1) {\r\n    return index;\r\n  }\r\n  // Need to find nearest\r\n  let closestDistance = Infinity;\r\n  return polyline.reduce((closestIndex, point, testIndex) => {\r\n    const distance = vec3.squaredDistance(point, handle);\r\n    if (distance < closestDistance) {\r\n      closestDistance = distance;\r\n      return testIndex;\r\n    }\r\n    return closestIndex;\r\n  }, -1);\r\n}\r\n","import { glMatrix, vec3 } from 'gl-matrix';\r\nimport { ContourAnnotation } from '../../types/ContourAnnotation';\r\n\r\n/**\r\n * Check if two contour segmentation annotations are coplanar.\r\n *\r\n * A plane may be represented by a normal and a distance then to know if they\r\n * are coplanar we need to:\r\n *   - check if the normals of the two annotations are pointing to the same\r\n *   direction or to opposite directions (dot product equal to 1 or -1\r\n *   respectively)\r\n *   - Get one point from each polyline and project it onto the normal to get\r\n *   the distance from the origin (0, 0, 0).\r\n */\r\nexport default function areCoplanarContours(\r\n  firstAnnotation: ContourAnnotation,\r\n  secondAnnotation: ContourAnnotation\r\n) {\r\n  const { viewPlaneNormal: firstViewPlaneNormal } = firstAnnotation.metadata;\r\n  const { viewPlaneNormal: secondViewPlaneNormal } = secondAnnotation.metadata;\r\n  const dot = vec3.dot(firstViewPlaneNormal, secondViewPlaneNormal);\r\n  const parallelPlanes = glMatrix.equals(1, Math.abs(dot));\r\n\r\n  if (!parallelPlanes) {\r\n    return false;\r\n  }\r\n\r\n  const { polyline: firstPolyline } = firstAnnotation.data.contour;\r\n  const { polyline: secondPolyline } = secondAnnotation.data.contour;\r\n\r\n  // Choose one of the normals and calculate the distance of a point from each\r\n  // polyline along that normal. Both normal cannot be used with absolute dot\r\n  // product values because one of the view planes may be flipped or one of the\r\n  // points may be at the same distance but in the opposite direction\r\n  const firstDistance = vec3.dot(firstViewPlaneNormal, firstPolyline[0]);\r\n  const secondDistance = vec3.dot(firstViewPlaneNormal, secondPolyline[0]);\r\n\r\n  return glMatrix.equals(firstDistance, secondDistance);\r\n}\r\n","function findNextLink(line, lines, contourPoints) {\r\n  let index = -1;\r\n  lines.forEach((cell, i) => {\r\n    if (index >= 0) {\r\n      return;\r\n    }\r\n\r\n    if (cell.a == line.b) {\r\n      index = i;\r\n    }\r\n  });\r\n\r\n  if (index >= 0) {\r\n    const nextLine = lines[index];\r\n    lines.splice(index, 1);\r\n\r\n    contourPoints.push(nextLine.b);\r\n\r\n    if (contourPoints[0] == nextLine.b) {\r\n      return {\r\n        remainingLines: lines,\r\n        contourPoints,\r\n        type: 'CLOSED_PLANAR',\r\n        //type: 'CLOSEDPLANAR_XOR',\r\n      };\r\n    }\r\n\r\n    return findNextLink(nextLine, lines, contourPoints);\r\n  }\r\n\r\n  return {\r\n    remainingLines: lines,\r\n    contourPoints,\r\n    type: 'OPEN_PLANAR',\r\n  };\r\n}\r\n\r\n/**\r\n *\r\n * @param {*} lines\r\n */\r\nexport function findContours(lines) {\r\n  if (lines.length == 0) {\r\n    return [];\r\n  }\r\n\r\n  const contourPoints = [];\r\n\r\n  const firstCell = lines.shift();\r\n  contourPoints.push(firstCell.a);\r\n  contourPoints.push(firstCell.b);\r\n  const result = findNextLink(firstCell, lines, contourPoints);\r\n\r\n  if (result.remainingLines.length == 0) {\r\n    return [\r\n      {\r\n        type: result.type,\r\n        contourPoints: result.contourPoints,\r\n      },\r\n    ];\r\n  } else {\r\n    const extraContours = findContours(result.remainingLines);\r\n    extraContours.push({\r\n      type: result.type,\r\n      contourPoints: result.contourPoints,\r\n    });\r\n    return extraContours;\r\n  }\r\n}\r\n\r\nexport function findContoursFromReducedSet(lines) {\r\n  return findContours(lines);\r\n}\r\n\r\nexport default {\r\n  findContours,\r\n  findContoursFromReducedSet,\r\n};\r\n","/**\r\n * Iterate through polyData from vtkjs and merge any points that are the same\r\n * then update merged point references within lines array\r\n * @param polyData - vtkPolyData\r\n * @param bypass - bypass the duplicate point removal\r\n * @returns the updated polyData\r\n */\r\nexport function getDeduplicatedVTKPolyDataPoints(polyData, bypass = false) {\r\n  const points = polyData.getPoints();\r\n  const lines = polyData.getLines();\r\n\r\n  // Todo: This is cloning which is not ideal, we should move to use the PointsArrayManager\r\n  // that will get merged soon\r\n  const pointsArray = new Array(points.getNumberOfPoints())\r\n    .fill(0)\r\n    .map((_, i) => points.getPoint(i).slice());\r\n\r\n  const linesArray = new Array(lines.getNumberOfCells()).fill(0).map((_, i) => {\r\n    const cell = lines.getCell(i * 3).slice();\r\n    return { a: cell[0], b: cell[1] };\r\n  });\r\n\r\n  if (bypass) {\r\n    return { points: pointsArray, lines: linesArray };\r\n  }\r\n\r\n  const newPoints = [];\r\n  for (const [i, pt] of pointsArray.entries()) {\r\n    // Todo: This is an n^2 algorithm - consider using a Map<string,Point3>.\r\n    // Generates a reasonable amount of garbage, but I think the performance\r\n    //  of that is better than doing repeated compares across the entire array.\r\n    const index = newPoints.findIndex(\r\n      (point) => point[0] === pt[0] && point[1] === pt[1] && point[2] === pt[2]\r\n    );\r\n\r\n    if (index >= 0) {\r\n      linesArray.map((line) => {\r\n        if (line.a === i) {\r\n          line.a = index;\r\n        }\r\n        if (line.b === i) {\r\n          line.b = index;\r\n        }\r\n        return line;\r\n      });\r\n    } else {\r\n      const newIndex = newPoints.length;\r\n      newPoints.push(pt);\r\n      linesArray.map((line) => {\r\n        if (line.a === i) {\r\n          line.a = newIndex;\r\n        }\r\n        if (line.b === i) {\r\n          line.b = newIndex;\r\n        }\r\n        return line;\r\n      });\r\n    }\r\n  }\r\n\r\n  const newLines = linesArray.filter((line) => line.a !== line.b);\r\n\r\n  return { points: newPoints, lines: newLines };\r\n}\r\n\r\nexport default { getDeduplicatedVTKPolyDataPoints };\r\n","/**\r\n * Functions for detecting and dealing with holes within contours.\r\n * Expected Contour format:\r\n * {\r\n *   type,\r\n *   contourPoints\r\n * }\r\n */\r\n\r\n/**\r\n * Checks if point is inside polygon defined by vertices array\r\n * Code from\r\n * https://stackoverflow.com/questions/22521982/check-if-point-is-inside-a-polygon\r\n * most original version based on:\r\n * https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html/pnpoly.html\r\n * @param {*} point\r\n * @param {*} vertices\r\n * @returns\r\n */\r\nconst getIsPointInsidePolygon = (point, vertices) => {\r\n  // Todo: this is a duplicated logic we should merge it with the other one\r\n  // which is containsPoint in the utilities\r\n  const x = point[0];\r\n  const y = point[1];\r\n\r\n  let inside = false;\r\n  for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {\r\n    const xi = vertices[i][0],\r\n      yi = vertices[i][1];\r\n    const xj = vertices[j][0],\r\n      yj = vertices[j][1];\r\n\r\n    const intersect =\r\n      yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\r\n    if (intersect) {\r\n      inside = !inside;\r\n    }\r\n  }\r\n\r\n  return inside;\r\n};\r\n\r\n/**\r\n * Check if inner contour is completely surrounded by outer contour.\r\n * @param {*} outerContour\r\n * @param {*} innerContour\r\n * @returns\r\n */\r\nfunction checkEnclosed(outerContour, innerContour, points) {\r\n  const vertices = [];\r\n  outerContour.contourPoints.forEach((point) => {\r\n    vertices.push([points[point][0], points[point][1]]);\r\n  });\r\n\r\n  let pointsNotEnclosed = 0;\r\n  innerContour.contourPoints.forEach((point) => {\r\n    const result = getIsPointInsidePolygon(\r\n      [points[point][0], points[point][1]],\r\n      vertices\r\n    );\r\n    //console.log(result);\r\n\r\n    if (!result) {\r\n      pointsNotEnclosed++;\r\n    }\r\n  });\r\n\r\n  return pointsNotEnclosed === 0;\r\n}\r\n\r\n/**\r\n * Check if contours have holes, if so update contour accordingly\r\n * @param {*} polyData\r\n * @param {*} bypass\r\n */\r\nexport function processContourHoles(contours, points, useXOR = true) {\r\n  //console.log(points);\r\n\r\n  // Add non-closed planars to contour list\r\n  const retContours = contours.filter(\r\n    (contour) => contour.type !== 'CLOSED_PLANAR'\r\n  );\r\n\r\n  // Find closed planar contours\r\n  const closedContours = contours.filter(\r\n    (contour) => contour.type === 'CLOSED_PLANAR'\r\n  );\r\n\r\n  // Iterate through each contour in list check for contours that have holes\r\n  const contourWithHoles = [];\r\n  let contourWithoutHoles = [];\r\n  closedContours.forEach((contour, index) => {\r\n    const holes = [];\r\n\r\n    // Check if any other contour is a hole surrounded by current contour\r\n    closedContours.forEach((hContour, hIndex) => {\r\n      if (index != hIndex) {\r\n        // Check if inner loop contour is a hole of outer loop contour\r\n        if (checkEnclosed(contour, hContour, points)) {\r\n          holes.push(hIndex);\r\n        }\r\n      }\r\n    });\r\n\r\n    // Check if holes were found\r\n    if (holes.length > 0) {\r\n      // Note current contour and reference of its holes\r\n      contourWithHoles.push({\r\n        contour,\r\n        holes,\r\n      });\r\n    } else {\r\n      // Note contour index without holes\r\n      contourWithoutHoles.push(index);\r\n    }\r\n  });\r\n\r\n  if (useXOR) {\r\n    // XOR method\r\n    contourWithHoles.forEach((contourHoleSet) => {\r\n      // Modify contour with hole to type CLOSEDPLANAR_XOR\r\n      contourHoleSet.contour.type = 'CLOSEDPLANAR_XOR';\r\n      retContours.push(contourHoleSet.contour);\r\n\r\n      contourHoleSet.holes.forEach((holeIndex) => {\r\n        // Modify hole type to CLOSEDPLANAR_XOR\r\n        // and add to contour list to be returned\r\n        closedContours[holeIndex].type = 'CLOSEDPLANAR_XOR';\r\n        retContours.push(closedContours[holeIndex]);\r\n\r\n        // Remove hole from list of contours without holes\r\n        contourWithoutHoles = contourWithoutHoles.filter((contourIndex) => {\r\n          return contourIndex !== holeIndex;\r\n        });\r\n      });\r\n    });\r\n\r\n    // Add remaining contours to list (neither hole nor have holes)\r\n    contourWithoutHoles.forEach((contourIndex) => {\r\n      retContours.push(closedContours[contourIndex]);\r\n    });\r\n  } else {\r\n    // Keyhole method, not implemented\r\n  }\r\n\r\n  return retContours;\r\n}\r\n\r\nexport default { processContourHoles };\r\n","import { cache as cornerstoneCache } from '@cornerstonejs/core';\r\nimport vtkImageMarchingSquares from '@kitware/vtk.js/Filters/General/ImageMarchingSquares';\r\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\r\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\r\n\r\nimport { getDeduplicatedVTKPolyDataPoints } from '../contours';\r\nimport { findContoursFromReducedSet } from './contourFinder';\r\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\r\n\r\nconst { Labelmap } = SegmentationRepresentations;\r\n\r\nfunction generateContourSetsFromLabelmap({ segmentations }) {\r\n  const { representationData, segments = [0, 1] } = segmentations;\r\n  const { volumeId: segVolumeId } = representationData[Labelmap];\r\n\r\n  // Get segmentation volume\r\n  const vol = cornerstoneCache.getVolume(segVolumeId);\r\n  if (!vol) {\r\n    console.warn(`No volume found for ${segVolumeId}`);\r\n    return;\r\n  }\r\n\r\n  const numSlices = vol.dimensions[2];\r\n\r\n  // NOTE: Workaround for marching squares not finding closed contours at\r\n  // boundary of image volume, clear pixels along x-y border of volume\r\n  const segData = vol.imageData.getPointData().getScalars().getData();\r\n  const pixelsPerSlice = vol.dimensions[0] * vol.dimensions[1];\r\n\r\n  for (let z = 0; z < numSlices; z++) {\r\n    for (let y = 0; y < vol.dimensions[1]; y++) {\r\n      const index = y * vol.dimensions[0] + z * pixelsPerSlice;\r\n      segData[index] = 0;\r\n      segData[index + vol.dimensions[0] - 1] = 0;\r\n    }\r\n  }\r\n\r\n  // end workaround\r\n  //\r\n  //\r\n  const ContourSets = [];\r\n\r\n  const { FrameOfReferenceUID } = vol.metadata;\r\n  // Iterate through all segments in current segmentation set\r\n  const numSegments = segments.length;\r\n  for (let segIndex = 0; segIndex < numSegments; segIndex++) {\r\n    const segment = segments[segIndex];\r\n\r\n    // Skip empty segments\r\n    if (!segment) {\r\n      continue;\r\n    }\r\n\r\n    const sliceContours = [];\r\n    const scalars = vtkDataArray.newInstance({\r\n      name: 'Scalars',\r\n      numberOfComponents: 1,\r\n      size: pixelsPerSlice * numSlices,\r\n      dataType: 'Uint8Array',\r\n    });\r\n    const { containedSegmentIndices } = segment;\r\n    for (let sliceIndex = 0; sliceIndex < numSlices; sliceIndex++) {\r\n      // Check if the slice is empty before running marching cube\r\n      if (\r\n        isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex)\r\n      ) {\r\n        continue;\r\n      }\r\n      const frameStart = sliceIndex * pixelsPerSlice;\r\n\r\n      try {\r\n        // Modify segData for this specific segment directly\r\n        for (let i = 0; i < pixelsPerSlice; i++) {\r\n          const value = segData[i + frameStart];\r\n          if (value === segIndex || containedSegmentIndices?.has(value)) {\r\n            (scalars as any).setValue(i + frameStart, 1);\r\n          } else {\r\n            (scalars as any).setValue(i, 0);\r\n          }\r\n        }\r\n\r\n        const mSquares = vtkImageMarchingSquares.newInstance({\r\n          slice: sliceIndex,\r\n        });\r\n\r\n        // filter out the scalar data so that only it has background and\r\n        // the current segment index\r\n        const imageDataCopy = vtkImageData.newInstance();\r\n\r\n        imageDataCopy.shallowCopy(vol.imageData);\r\n        imageDataCopy.getPointData().setScalars(scalars);\r\n\r\n        // Connect pipeline\r\n        mSquares.setInputData(imageDataCopy);\r\n        const cValues = [1];\r\n        mSquares.setContourValues(cValues);\r\n        mSquares.setMergePoints(false);\r\n\r\n        // Perform marching squares\r\n        const msOutput = mSquares.getOutputData();\r\n\r\n        // Clean up output from marching squares\r\n        const reducedSet = getDeduplicatedVTKPolyDataPoints(msOutput);\r\n        if (reducedSet.points?.length) {\r\n          const contours = findContoursFromReducedSet(reducedSet.lines);\r\n\r\n          sliceContours.push({\r\n            contours,\r\n            polyData: reducedSet,\r\n            FrameNumber: sliceIndex + 1,\r\n            sliceIndex,\r\n            FrameOfReferenceUID,\r\n          });\r\n        }\r\n      } catch (e) {\r\n        console.warn(sliceIndex);\r\n        console.warn(e);\r\n      }\r\n    }\r\n\r\n    const metadata = {\r\n      FrameOfReferenceUID,\r\n    };\r\n\r\n    const ContourSet = {\r\n      label: segment.label,\r\n      color: segment.color,\r\n      metadata,\r\n      sliceContours,\r\n    };\r\n\r\n    ContourSets.push(ContourSet);\r\n  }\r\n\r\n  return ContourSets;\r\n}\r\n\r\nfunction isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex) {\r\n  const startIdx = sliceIndex * pixelsPerSlice;\r\n  const endIdx = startIdx + pixelsPerSlice;\r\n\r\n  for (let i = startIdx; i < endIdx; i++) {\r\n    if (segData[i] === segIndex) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport { generateContourSetsFromLabelmap };\r\n","import RectangleROIStartEndThreshold from './RectangleROIStartEndThreshold';\r\n\r\nfunction validateAnnotation(annotation) {\r\n  if (!annotation?.data) {\r\n    throw new Error('Tool data is empty');\r\n  }\r\n\r\n  if (!annotation.metadata || annotation.metadata.referenceImageId) {\r\n    throw new Error('Tool data is not associated with any imageId');\r\n  }\r\n}\r\n\r\nclass AnnotationToPointData {\r\n  static TOOL_NAMES: Record<string, any> = {};\r\n\r\n  constructor() {\r\n    // empty\r\n  }\r\n\r\n  static convert(annotation, index, metadataProvider) {\r\n    validateAnnotation(annotation);\r\n\r\n    const { toolName } = annotation.metadata;\r\n    const toolClass = AnnotationToPointData.TOOL_NAMES[toolName];\r\n\r\n    if (!toolClass) {\r\n      throw new Error(\r\n        `Unknown tool type: ${toolName}, cannot convert to RTSSReport`\r\n      );\r\n    }\r\n\r\n    // Each toolData should become a list of contours, ContourSequence\r\n    // contains a list of contours with their pointData, their geometry\r\n    // type and their length.\r\n    const ContourSequence = toolClass.getContourSequence(\r\n      annotation,\r\n      metadataProvider\r\n    );\r\n\r\n    // Todo: random rgb color for now, options should be passed in\r\n    const color = [\r\n      Math.floor(Math.random() * 255),\r\n      Math.floor(Math.random() * 255),\r\n      Math.floor(Math.random() * 255),\r\n    ];\r\n\r\n    return {\r\n      ReferencedROINumber: index + 1,\r\n      ROIDisplayColor: color,\r\n      ContourSequence,\r\n    };\r\n  }\r\n\r\n  static register(toolClass) {\r\n    AnnotationToPointData.TOOL_NAMES[toolClass.toolName] = toolClass;\r\n  }\r\n}\r\n\r\nAnnotationToPointData.register(RectangleROIStartEndThreshold);\r\n\r\nexport default AnnotationToPointData;\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport type { Annotation, ContourAnnotation } from '../../types';\r\nimport { getAnnotation } from '../../stateManagement';\r\n\r\n/**\r\n * Get child polylines data in world space for contour annotations that represent the holes\r\n * @param annotation - Annotation\r\n * @param viewport - Viewport used to convert the points from world to canvas space\r\n * @returns An array that contains all child polylines (holes) in world space\r\n */\r\nexport default function getContourHolesDataWorld(\r\n  annotation: Annotation\r\n): Types.Point3[][] {\r\n  const childAnnotationUIDs = annotation.childAnnotationUIDs ?? [];\r\n\r\n  return childAnnotationUIDs.map(\r\n    (uid) => (getAnnotation(uid) as ContourAnnotation).data.contour.polyline\r\n  );\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport type { Annotation } from '../../types';\r\nimport getContourHolesDataWorld from './getContourHolesDataWorld';\r\n\r\n/**\r\n * Get the polylines for the child annotations (holes)\r\n * @param annotation - Annotation\r\n * @param viewport - Viewport used to convert the points from world to canvas space\r\n * @returns An array that contains all child polylines\r\n */\r\nexport default function getContourHolesDataCanvas(\r\n  annotation: Annotation,\r\n  viewport: Types.IViewport\r\n): Types.Point2[][] {\r\n  const worldHoleContours = getContourHolesDataWorld(annotation);\r\n  const canvasHoleContours = [];\r\n\r\n  worldHoleContours.forEach((worldHoleContour) => {\r\n    const numPoints = worldHoleContour.length;\r\n\r\n    // Pre-allocated arrays are 3-4x faster than multiple \"push()\" calls\r\n    const canvasHoleContour: Types.Point2[] = new Array(numPoints);\r\n\r\n    // Using FOR loop instead of map() for better performance when processing large arrays\r\n    for (let i = 0; i < numPoints; i++) {\r\n      canvasHoleContour[i] = viewport.worldToCanvas(worldHoleContour[i]);\r\n    }\r\n\r\n    canvasHoleContours.push(canvasHoleContour);\r\n  });\r\n\r\n  return canvasHoleContours;\r\n}\r\n","import InterpolationManager from '../../segmentation/InterpolationManager/InterpolationManager';\r\nimport type { AcceptInterpolationSelector } from '../../../types/InterpolationTypes';\r\nimport type AnnotationGroupSelector from '../../../types/AnnotationGroupSelector';\r\n\r\n/**\r\n * Accepts interpolated annotations, marking them as autoGenerated false.\r\n *\r\n * @param annotationGroupSelector - viewport or FOR to select annotations on\r\n * @param selector - nested selection criteria\r\n */\r\nexport default function acceptAutogeneratedInterpolations(\r\n  annotationGroupSelector: AnnotationGroupSelector,\r\n  selector: AcceptInterpolationSelector\r\n) {\r\n  InterpolationManager.acceptAutoGenerated(annotationGroupSelector, selector);\r\n}\r\n","import { utilities as csUtils } from '@cornerstonejs/core';\r\nimport { Types } from '@cornerstonejs/core';\r\nimport type { ContourAnnotation } from '../../types';\r\nimport type { ContourWindingDirection } from '../../types/ContourAnnotation';\r\nimport * as math from '../math';\r\nimport {\r\n  getParentAnnotation,\r\n  invalidateAnnotation,\r\n} from '../../stateManagement';\r\n\r\n/**\r\n * Update the contour polyline data\r\n * @param annotation - Contour annotation\r\n * @param viewport - Viewport\r\n * @param polylineData - Polyline data (points, winding direction and closed)\r\n * @param transforms - Methods to convert points to/from canvas and world spaces\r\n * @param options - Options\r\n *   - decimate: allow to set some parameters to decimate the polyline reducing\r\n *   the amount of points stored which also affects how fast it will draw the\r\n *   annotation in a viewport, compute the winding direction, append/remove\r\n *   contours and create holes. A higher `epsilon` value results in a polyline\r\n *   with less points.\r\n */\r\nexport default function updateContourPolyline(\r\n  annotation: ContourAnnotation,\r\n  polylineData: {\r\n    points: Types.Point2[];\r\n    closed?: boolean;\r\n    targetWindingDirection?: ContourWindingDirection;\r\n  },\r\n  transforms: {\r\n    canvasToWorld: (point: Types.Point2) => Types.Point3;\r\n    worldToCanvas: (point: Types.Point3) => Types.Point2;\r\n  },\r\n  options?: {\r\n    decimate?: {\r\n      enabled?: boolean;\r\n      epsilon?: number;\r\n    };\r\n  }\r\n) {\r\n  const { canvasToWorld, worldToCanvas } = transforms;\r\n  const { data } = annotation;\r\n  const { targetWindingDirection } = polylineData;\r\n  let { points: polyline } = polylineData;\r\n\r\n  // Decimate the polyline to reduce tha amount of points\r\n  if (options?.decimate?.enabled) {\r\n    polyline = math.polyline.decimate(\r\n      polylineData.points,\r\n      options?.decimate?.epsilon\r\n    );\r\n  }\r\n\r\n  let { closed } = polylineData;\r\n  const numPoints = polyline.length;\r\n  const polylineWorldPoints = new Array(numPoints);\r\n  const currentPolylineWindingDirection =\r\n    math.polyline.getWindingDirection(polyline);\r\n  const parentAnnotation = getParentAnnotation(annotation) as ContourAnnotation;\r\n\r\n  if (closed === undefined) {\r\n    let currentClosedState = false;\r\n\r\n    // With two points it is just a line and do not make sense to consider it closed\r\n    if (polyline.length > 3) {\r\n      const lastToFirstDist = math.point.distanceToPointSquared(\r\n        polyline[0],\r\n        polyline[numPoints - 1]\r\n      );\r\n\r\n      currentClosedState = csUtils.isEqual(0, lastToFirstDist);\r\n    }\r\n\r\n    closed = currentClosedState;\r\n  }\r\n\r\n  // It must be in the opposite direction if it is a child annotation (hole)\r\n  let windingDirection = parentAnnotation\r\n    ? parentAnnotation.data.contour.windingDirection * -1\r\n    : targetWindingDirection;\r\n\r\n  if (windingDirection === undefined) {\r\n    windingDirection = currentPolylineWindingDirection;\r\n  }\r\n\r\n  if (windingDirection !== currentPolylineWindingDirection) {\r\n    polyline.reverse();\r\n  }\r\n\r\n  const handlePoints = data.handles.points.map((p) => worldToCanvas(p));\r\n\r\n  if (handlePoints.length > 2) {\r\n    const currentHandlesWindingDirection =\r\n      math.polyline.getWindingDirection(handlePoints);\r\n\r\n    if (currentHandlesWindingDirection !== windingDirection) {\r\n      data.handles.points.reverse();\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < numPoints; i++) {\r\n    polylineWorldPoints[i] = canvasToWorld(polyline[i]);\r\n  }\r\n\r\n  data.contour.polyline = polylineWorldPoints;\r\n  data.contour.closed = closed;\r\n  data.contour.windingDirection = windingDirection;\r\n\r\n  invalidateAnnotation(annotation);\r\n}\r\n","import isObject from './isObject';\r\n\r\n/**\r\n * Creates a debounced function that delays invoking `func` until after `wait`\r\n * milliseconds have elapsed since the last time the debounced function was\r\n * invoked, or until the next browser frame is drawn. The debounced function\r\n * comes with a `cancel` method to cancel delayed `func` invocations and a\r\n * `flush` method to immediately invoke them. Provide `options` to indicate\r\n * whether `func` should be invoked on the leading and/or trailing edge of the\r\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\r\n * debounced function. Subsequent calls to the debounced function return the\r\n * result of the last `func` invocation.\r\n *\r\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\r\n * invoked on the trailing edge of the timeout only if the debounced function\r\n * is invoked more than once during the `wait` timeout.\r\n *\r\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\r\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\r\n *\r\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\r\n * invocation will be deferred until the next frame is drawn (typically about\r\n * 16ms).\r\n *\r\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\r\n * for details over the differences between `debounce` and `throttle`.\r\n *\r\n * @param {Function} func The function to debounce.\r\n * @param {number} [wait=0]\r\n *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is\r\n *  used (if available).\r\n * @param {Object} [options={}] The options object.\r\n * @param {boolean} [options.leading=false]\r\n *  Specify invoking on the leading edge of the timeout.\r\n * @param {number} [options.maxWait]\r\n *  The maximum time `func` is allowed to be delayed before it's invoked.\r\n * @param {boolean} [options.trailing=true]\r\n *  Specify invoking on the trailing edge of the timeout.\r\n * @returns {Function} Returns the new debounced function.\r\n * @example\r\n *\r\n * // Avoid costly calculations while the window size is in flux.\r\n * jQuery(window).on('resize', debounce(calculateLayout, 150))\r\n *\r\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\r\n * jQuery(element).on('click', debounce(sendMail, 300, {\r\n *   'leading': true,\r\n *   'trailing': false\r\n * }))\r\n *\r\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\r\n * const debounced = debounce(batchLog, 250, { 'maxWait': 1000 })\r\n * const source = new EventSource('/stream')\r\n * jQuery(source).on('message', debounced)\r\n *\r\n * // Cancel the trailing debounced invocation.\r\n * jQuery(window).on('popstate', debounced.cancel)\r\n *\r\n * // Check for pending invocations.\r\n * const status = debounced.pending() ? \"Pending...\" : \"Ready\"\r\n */\r\nfunction debounce(func, wait, options) {\r\n  let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\r\n\r\n  let lastInvokeTime = 0;\r\n  let leading = false;\r\n  let maxing = false;\r\n  let trailing = true;\r\n\r\n  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\r\n  const useRAF =\r\n    !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';\r\n\r\n  if (typeof func !== 'function') {\r\n    throw new TypeError('Expected a function');\r\n  }\r\n  wait = Number(wait) || 0;\r\n  if (isObject(options)) {\r\n    leading = Boolean(options.leading);\r\n    maxing = 'maxWait' in options;\r\n    maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;\r\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\r\n  }\r\n\r\n  function invokeFunc(time) {\r\n    const args = lastArgs;\r\n    const thisArg = lastThis;\r\n\r\n    lastArgs = lastThis = undefined;\r\n    lastInvokeTime = time;\r\n    result = func.apply(thisArg, args);\r\n\r\n    return result;\r\n  }\r\n\r\n  function startTimer(pendingFunc, wait) {\r\n    if (useRAF) {\r\n      return window.requestAnimationFrame(pendingFunc);\r\n    }\r\n\r\n    return setTimeout(pendingFunc, wait);\r\n  }\r\n\r\n  function cancelTimer(id) {\r\n    if (useRAF) {\r\n      return window.cancelAnimationFrame(id);\r\n    }\r\n    clearTimeout(id);\r\n  }\r\n\r\n  function leadingEdge(time) {\r\n    // Reset any `maxWait` timer.\r\n    lastInvokeTime = time;\r\n    // Start the timer for the trailing edge.\r\n    timerId = startTimer(timerExpired, wait);\r\n\r\n    // Invoke the leading edge.\r\n    return leading ? invokeFunc(time) : result;\r\n  }\r\n\r\n  function remainingWait(time) {\r\n    const timeSinceLastCall = time - lastCallTime;\r\n    const timeSinceLastInvoke = time - lastInvokeTime;\r\n    const timeWaiting = wait - timeSinceLastCall;\r\n\r\n    return maxing\r\n      ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\r\n      : timeWaiting;\r\n  }\r\n\r\n  function shouldInvoke(time) {\r\n    const timeSinceLastCall = time - lastCallTime;\r\n    const timeSinceLastInvoke = time - lastInvokeTime;\r\n\r\n    // Either this is the first call, activity has stopped and we're at the\r\n    // trailing edge, the system time has gone backwards and we're treating\r\n    // it as the trailing edge, or we've hit the `maxWait` limit.\r\n    return (\r\n      lastCallTime === undefined ||\r\n      timeSinceLastCall >= wait ||\r\n      timeSinceLastCall < 0 ||\r\n      (maxing && timeSinceLastInvoke >= maxWait)\r\n    );\r\n  }\r\n\r\n  function timerExpired() {\r\n    const time = Date.now();\r\n\r\n    if (shouldInvoke(time)) {\r\n      return trailingEdge(time);\r\n    }\r\n    // Restart the timer.\r\n    timerId = startTimer(timerExpired, remainingWait(time));\r\n  }\r\n\r\n  function trailingEdge(time) {\r\n    timerId = undefined;\r\n\r\n    // Only invoke if we have `lastArgs` which means `func` has been\r\n    // debounced at least once.\r\n    if (trailing && lastArgs) {\r\n      return invokeFunc(time);\r\n    }\r\n    lastArgs = lastThis = undefined;\r\n\r\n    return result;\r\n  }\r\n\r\n  function cancel() {\r\n    if (timerId !== undefined) {\r\n      cancelTimer(timerId);\r\n    }\r\n    lastInvokeTime = 0;\r\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\r\n  }\r\n\r\n  function flush() {\r\n    return timerId === undefined ? result : trailingEdge(Date.now());\r\n  }\r\n\r\n  function pending() {\r\n    return timerId !== undefined;\r\n  }\r\n\r\n  function debounced(...args) {\r\n    const time = Date.now();\r\n    const isInvoking = shouldInvoke(time);\r\n\r\n    lastArgs = args;\r\n    lastThis = this; // eslint-disable-line consistent-this\r\n    lastCallTime = time;\r\n\r\n    if (isInvoking) {\r\n      if (timerId === undefined) {\r\n        return leadingEdge(lastCallTime);\r\n      }\r\n      if (maxing) {\r\n        // Handle invocations in a tight loop.\r\n        timerId = startTimer(timerExpired, wait);\r\n\r\n        return invokeFunc(lastCallTime);\r\n      }\r\n    }\r\n    if (timerId === undefined) {\r\n      timerId = startTimer(timerExpired, wait);\r\n    }\r\n\r\n    return result;\r\n  }\r\n  debounced.cancel = cancel;\r\n  debounced.flush = flush;\r\n  debounced.pending = pending;\r\n\r\n  return debounced;\r\n}\r\n\r\nexport default debounce;\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Determine the coordinates that will place the textbox to the right of the\r\n * annotation.\r\n *\r\n * @param annotationCanvasPoints - The canvas points of the annotation's handles.\r\n * @returns - The coordinates for default placement of the textbox.\r\n */\r\nexport default function getTextBoxCoordsCanvas(\r\n  annotationCanvasPoints: Array<Types.Point2>\r\n): Types.Point2 {\r\n  const corners = _determineCorners(annotationCanvasPoints);\r\n  const centerY = (corners.top[1] + corners.bottom[1]) / 2;\r\n  const textBoxCanvas = <Types.Point2>[corners.right[0], centerY];\r\n\r\n  return textBoxCanvas;\r\n}\r\n\r\n/**\r\n * Determine the handles that have the min/max x and y values.\r\n *\r\n * @param canvasPoints - The canvas points of the annotation's handles.\r\n * @returns - The top, left, bottom, and right handles.\r\n */\r\nfunction _determineCorners(canvasPoints: Array<Types.Point2>) {\r\n  const handlesLeftToRight = [canvasPoints[0], canvasPoints[1]].sort(_compareX);\r\n  const handlesTopToBottom = [canvasPoints[0], canvasPoints[1]].sort(_compareY);\r\n  const right = handlesLeftToRight[handlesLeftToRight.length - 1];\r\n  const top = handlesTopToBottom[0];\r\n  const bottom = handlesTopToBottom[handlesTopToBottom.length - 1];\r\n\r\n  return {\r\n    top,\r\n    bottom,\r\n    right,\r\n  };\r\n\r\n  function _compareX(a, b) {\r\n    return a[0] < b[0] ? -1 : 1;\r\n  }\r\n  function _compareY(a, b) {\r\n    return a[1] < b[1] ? -1 : 1;\r\n  }\r\n}\r\n","import { utilities, cache, Types } from '@cornerstonejs/core';\r\nimport { getVoxelOverlap } from '../segmentation/utilities';\r\nimport pointInShapeCallback from '../pointInShapeCallback';\r\n\r\n/**\r\n * Gets the scalar data for a series of time points for either a single\r\n * coordinate or a segmentation mask, it will return the an array of scalar\r\n * data for a single coordinate or an array of arrays for a segmentation.\r\n *\r\n * @param dynamicVolume - 4D volume to compute time point data from\r\n * @param options - frameNumbers: which frames to use as timepoints, if left\r\n * blank, gets data timepoints over all frames\r\n * maskVolumeId: segmentationId to get timepoint data of\r\n * imageCoordinate: world coordinate to get timepoint data of\r\n * @returns\r\n */\r\nfunction getDataInTime(\r\n  dynamicVolume: Types.IDynamicImageVolume,\r\n  options: {\r\n    frameNumbers?;\r\n    maskVolumeId?;\r\n    imageCoordinate?;\r\n  }\r\n): number[] | number[][] {\r\n  let dataInTime;\r\n\r\n  // if frameNumbers is not provided, all frames are selected\r\n  const frames = options.frameNumbers || [\r\n    ...Array(dynamicVolume.numTimePoints).keys(),\r\n  ];\r\n\r\n  // You only need to provide either maskVolumeId OR imageCoordinate.\r\n  // Throws error if neither maskVolumeId or imageCoordinate is given,\r\n  // throws error if BOTH maskVolumeId and imageCoordinate is given\r\n  if (!options.maskVolumeId && !options.imageCoordinate) {\r\n    throw new Error(\r\n      'You should provide either maskVolumeId or imageCoordinate'\r\n    );\r\n  }\r\n\r\n  if (options.maskVolumeId && options.imageCoordinate) {\r\n    throw new Error('You can only use one of maskVolumeId or imageCoordinate');\r\n  }\r\n\r\n  if (options.maskVolumeId) {\r\n    const segmentationVolume = cache.getVolume(options.maskVolumeId);\r\n\r\n    const [dataInTime, ijkCoords] = _getTimePointDataMask(\r\n      frames,\r\n      dynamicVolume,\r\n      segmentationVolume\r\n    );\r\n\r\n    return [dataInTime, ijkCoords];\r\n  }\r\n\r\n  if (options.imageCoordinate) {\r\n    const dataInTime = _getTimePointDataCoordinate(\r\n      frames,\r\n      options.imageCoordinate,\r\n      dynamicVolume\r\n    );\r\n\r\n    return dataInTime;\r\n  }\r\n\r\n  return dataInTime;\r\n}\r\n\r\nfunction _getTimePointDataCoordinate(frames, coordinate, volume) {\r\n  const { dimensions, imageData } = volume;\r\n  const index = imageData.worldToIndex(coordinate);\r\n\r\n  index[0] = Math.floor(index[0]);\r\n  index[1] = Math.floor(index[1]);\r\n  index[2] = Math.floor(index[2]);\r\n\r\n  if (!utilities.indexWithinDimensions(index, dimensions)) {\r\n    throw new Error('outside bounds');\r\n  }\r\n\r\n  // calculate offset for index\r\n  const yMultiple = dimensions[0];\r\n  const zMultiple = dimensions[0] * dimensions[1];\r\n  const allScalarData = volume.getScalarDataArrays();\r\n  const value = [];\r\n\r\n  frames.forEach((frame) => {\r\n    const activeScalarData = allScalarData[frame];\r\n    const scalarIndex = index[2] * zMultiple + index[1] * yMultiple + index[0];\r\n    value.push(activeScalarData[scalarIndex]);\r\n  });\r\n\r\n  return value;\r\n}\r\n\r\nfunction _getTimePointDataMask(frames, dynamicVolume, segmentationVolume) {\r\n  const { imageData: maskImageData } = segmentationVolume;\r\n  const segScalarData = segmentationVolume.getScalarData();\r\n\r\n  const len = segScalarData.length;\r\n\r\n  // Pre-allocate memory for array\r\n  const nonZeroVoxelIndices = [];\r\n  nonZeroVoxelIndices.length = len;\r\n  const ijkCoords = [];\r\n\r\n  const dimensions = segmentationVolume.dimensions;\r\n\r\n  // Get the index of every non-zero voxel in mask\r\n  let actualLen = 0;\r\n  for (let i = 0, len = segScalarData.length; i < len; i++) {\r\n    if (segScalarData[i] !== 0) {\r\n      ijkCoords.push([\r\n        i % dimensions[0],\r\n        Math.floor((i / dimensions[0]) % dimensions[1]),\r\n        Math.floor(i / (dimensions[0] * dimensions[1])),\r\n      ]);\r\n      nonZeroVoxelIndices[actualLen++] = i;\r\n    }\r\n  }\r\n\r\n  // Trim the array to actual size\r\n  nonZeroVoxelIndices.length = actualLen;\r\n\r\n  const dynamicVolumeScalarDataArray = dynamicVolume.getScalarDataArrays();\r\n  const values = [];\r\n  const isSameVolume =\r\n    dynamicVolumeScalarDataArray[0].length === len &&\r\n    JSON.stringify(dynamicVolume.spacing) ===\r\n      JSON.stringify(segmentationVolume.spacing);\r\n\r\n  // if the segmentation mask is the same size as the dynamic volume (one frame)\r\n  // means we can just return the scalar data for the non-zero voxels\r\n  if (isSameVolume) {\r\n    for (let i = 0; i < nonZeroVoxelIndices.length; i++) {\r\n      const indexValues = [];\r\n      frames.forEach((frame) => {\r\n        const activeScalarData = dynamicVolumeScalarDataArray[frame];\r\n        indexValues.push(activeScalarData[nonZeroVoxelIndices[i]]);\r\n      });\r\n      values.push(indexValues);\r\n    }\r\n\r\n    return [values, ijkCoords];\r\n  }\r\n\r\n  // In case that the segmentation mask is not the same size as the dynamic volume (one frame)\r\n  // then we need to consider each voxel in the segmentation mask and check if it\r\n  // overlaps with the other volume, and if so we need to average the values of the\r\n  // overlapping voxels.\r\n  const callback = ({\r\n    pointLPS: segPointLPS,\r\n    value: segValue,\r\n    pointIJK: segPointIJK,\r\n  }) => {\r\n    // see if the value is non-zero\r\n    if (segValue === 0) {\r\n      // not interested\r\n      return;\r\n    }\r\n\r\n    // Then for each non-zero voxel in the segmentation mask, we should\r\n    // again perform the pointInShapeCallback to run the averaging callback\r\n    // function to get the average value of the overlapping voxels.\r\n    const overlapIJKMinMax = getVoxelOverlap(\r\n      dynamicVolume.imageData,\r\n      dynamicVolume.dimensions,\r\n      dynamicVolume.spacing,\r\n      segPointLPS\r\n    );\r\n\r\n    // count represents the number of voxels of the dynamic volume that represents\r\n    // one voxel of the segmentation mask\r\n    let count = 0;\r\n    const perFrameSum = new Map();\r\n\r\n    // Pre-initialize the Map\r\n    frames.forEach((frame) => perFrameSum.set(frame, 0));\r\n\r\n    const averageCallback = ({ index }) => {\r\n      for (let i = 0; i < frames.length; i++) {\r\n        const value = dynamicVolumeScalarDataArray[i][index];\r\n        const frame = frames[i];\r\n        perFrameSum.set(frame, perFrameSum.get(frame) + value);\r\n      }\r\n      count++;\r\n    };\r\n\r\n    pointInShapeCallback(\r\n      dynamicVolume.imageData,\r\n      () => true,\r\n      averageCallback,\r\n      overlapIJKMinMax\r\n    );\r\n\r\n    // average the values\r\n    const averageValues = [];\r\n    perFrameSum.forEach((sum) => {\r\n      averageValues.push(sum / count);\r\n    });\r\n\r\n    ijkCoords.push(segPointIJK);\r\n    values.push(averageValues);\r\n  };\r\n\r\n  // Since we have the non-zero voxel indices of the segmentation mask,\r\n  // we theoretically can use them, however, we kind of need to compute the\r\n  // pointLPS for each of the non-zero voxel indices, which is a bit of a pain.\r\n  // Todo: consider using the nonZeroVoxelIndices to compute the pointLPS\r\n  pointInShapeCallback(maskImageData, () => true, callback);\r\n\r\n  return [values, ijkCoords];\r\n}\r\n\r\nexport default getDataInTime;\r\n","import { Enums, Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Gets the scalar data for a series of time frames from a 4D volume, returns an\r\n * array of scalar data after performing AVERAGE, SUM or SUBTRACT to be used to\r\n * create a 3D volume\r\n *\r\n * @param dynamicVolume4D - volume to compute time frame data from\r\n * @param operation - operation to perform on time frame data, operations include\r\n * SUM, AVERAGE, and SUBTRACT (can only be used with 2 time frames provided)\r\n * @param frameNumbers - an array of frame indices to perform the operation on, if\r\n * left empty, all frames will be used\r\n * @returns\r\n */\r\nfunction generateImageFromTimeData(\r\n  dynamicVolume: Types.IDynamicImageVolume,\r\n  operation: string,\r\n  frameNumbers?: number[]\r\n) {\r\n  // If no time frames provided, use all time frames\r\n  const frames = frameNumbers || [...Array(dynamicVolume.numTimePoints).keys()];\r\n  const numFrames = frames.length;\r\n\r\n  if (frames.length <= 1) {\r\n    throw new Error('Please provide two or more time points');\r\n  }\r\n\r\n  // Gets scalar data for all time frames\r\n  const typedArrays = dynamicVolume.getScalarDataArrays();\r\n\r\n  const arrayLength = typedArrays[0].length;\r\n  const finalArray = new Float32Array(arrayLength);\r\n\r\n  if (operation === Enums.DynamicOperatorType.SUM) {\r\n    for (let i = 0; i < numFrames; i++) {\r\n      const currentArray = typedArrays[frames[i]];\r\n      for (let j = 0; j < arrayLength; j++) {\r\n        finalArray[j] += currentArray[j];\r\n      }\r\n    }\r\n    return finalArray;\r\n  }\r\n\r\n  if (operation === Enums.DynamicOperatorType.SUBTRACT) {\r\n    if (frames.length > 2) {\r\n      throw new Error('Please provide only 2 time points for subtraction.');\r\n    }\r\n    for (let j = 0; j < arrayLength; j++) {\r\n      finalArray[j] += typedArrays[frames[0]][j] - typedArrays[frames[1]][j];\r\n    }\r\n    return finalArray;\r\n  }\r\n\r\n  if (operation === Enums.DynamicOperatorType.AVERAGE) {\r\n    for (let i = 0; i < numFrames; i++) {\r\n      const currentArray = typedArrays[frames[i]];\r\n      for (let j = 0; j < arrayLength; j++) {\r\n        finalArray[j] += currentArray[j];\r\n      }\r\n    }\r\n    for (let k = 0; k < arrayLength; k++) {\r\n      finalArray[k] = finalArray[k] / numFrames;\r\n    }\r\n    return finalArray;\r\n  }\r\n}\r\n\r\nexport default generateImageFromTimeData;\r\n","import { getEnabledElement } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { AnnotationTool, BaseTool } from '../tools';\r\nimport { Annotation } from '../types';\r\nimport { getAnnotations } from '../stateManagement/annotation/annotationState';\r\nimport * as ToolGroupManager from '../store/ToolGroupManager';\r\n\r\n/**\r\n * Get the annotation that is close to the provided canvas point, it will return\r\n * the first annotation that is found.\r\n *\r\n * @param element - The element to search for an annotation on.\r\n * @param canvasPoint - The canvasPoint on the page where the user clicked.\r\n * @param proximity - The distance from the canvasPoint to the annotation.\r\n * @returns The annotation for the element\r\n */\r\nfunction getAnnotationNearPoint(\r\n  element: HTMLDivElement,\r\n  canvasPoint: Types.Point2,\r\n  proximity = 5\r\n): Annotation | null {\r\n  // Todo: this function should return closest annotation, BUT, we are not using\r\n  // the function anywhere.\r\n  const enabledElement = getEnabledElement(element);\r\n  if (!enabledElement) {\r\n    throw new Error('getAnnotationNearPoint: enabledElement not found');\r\n  }\r\n\r\n  return getAnnotationNearPointOnEnabledElement(\r\n    enabledElement,\r\n    canvasPoint,\r\n    proximity\r\n  );\r\n}\r\n\r\n/**\r\n * \"Find the annotation near the point on the enabled element.\" it will return the\r\n * first annotation that is found.\r\n *\r\n * @param enabledElement - The element that is currently active.\r\n * @param point - The point to search near.\r\n * @param proximity - The distance from the point that the annotation must\r\n * be within.\r\n * @returns A Annotation object.\r\n */\r\nfunction getAnnotationNearPointOnEnabledElement(\r\n  enabledElement: Types.IEnabledElement,\r\n  point: Types.Point2,\r\n  proximity: number\r\n): Annotation | null {\r\n  // Todo: this function should return closest annotation, BUT, we are not using\r\n  // the function anywhere.\r\n  const { renderingEngineId, viewportId } = enabledElement;\r\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\r\n    viewportId,\r\n    renderingEngineId\r\n  );\r\n\r\n  if (!toolGroup) {\r\n    return null;\r\n  }\r\n\r\n  const { _toolInstances: tools } = toolGroup;\r\n  for (const name in tools) {\r\n    const found = findAnnotationNearPointByTool(\r\n      tools[name],\r\n      enabledElement,\r\n      point,\r\n      proximity\r\n    );\r\n    if (found) {\r\n      return found;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * For the provided toolClass, it will find the annotation that is near the point,\r\n * it will return the first annotation that is found.\r\n *\r\n * @param tool - AnnotationTool\r\n * @param enabledElement - The element that is currently active.\r\n * @param point - The point in the image where the user clicked.\r\n * @param proximity - The distance from the point that the tool must be\r\n * within to be considered \"near\" the point.\r\n * @returns The annotation object that is being returned is the annotation object that\r\n * is being used in the tool.\r\n */\r\nfunction findAnnotationNearPointByTool(\r\n  tool: AnnotationTool,\r\n  enabledElement: Types.IEnabledElement,\r\n  point: Types.Point2,\r\n  proximity: number\r\n): Annotation | null {\r\n  // Todo: this function does not return closest annotation. It just returns\r\n  // the first annotation that is found in the proximity. BUT, we are not using\r\n  // the function anywhere.\r\n  const { viewport } = enabledElement;\r\n\r\n  const annotations = getAnnotations(\r\n    (tool.constructor as typeof BaseTool).toolName,\r\n    viewport?.element\r\n  );\r\n  const currentId = viewport?.getCurrentImageId?.();\r\n  if (annotations?.length) {\r\n    const { element } = enabledElement.viewport;\r\n    for (const annotation of annotations) {\r\n      const referencedImageId = annotation.metadata?.referencedImageId;\r\n      if (\r\n        (currentId && referencedImageId && currentId !== referencedImageId) ||\r\n        !tool.isPointNearTool\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        tool.isPointNearTool(element, annotation, point, proximity, '') ||\r\n        tool.getHandleNearImagePoint(element, annotation, point, proximity)\r\n      ) {\r\n        return annotation;\r\n      }\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nexport { getAnnotationNearPoint, getAnnotationNearPointOnEnabledElement };\r\n","import { Enums, utilities } from '@cornerstonejs/core';\r\n\r\nconst { CalibrationTypes } = Enums;\r\nconst PIXEL_UNITS = 'px';\r\n\r\nconst SUPPORTED_REGION_DATA_TYPES = [\r\n  1, // Tissue\r\n];\r\n\r\nconst SUPPORTED_LENGTH_VARIANT = [\r\n  '3,3', // x: cm  &  y:cm\r\n];\r\n\r\nconst SUPPORTED_PROBE_VARIANT = [\r\n  '4,3', // x: seconds  &  y : cm\r\n];\r\n\r\nconst UNIT_MAPPING = {\r\n  3: 'cm',\r\n  4: 'seconds',\r\n};\r\n\r\nconst EPS = 1e-3;\r\nconst SQUARE = '\\xb2';\r\n/**\r\n * Extracts the calibrated length units, area units, and the scale\r\n * for converting from internal spacing to image spacing.\r\n *\r\n * @param handles - to detect if spacing information is different between points\r\n * @param image - to extract the calibration from\r\n * @returns Object containing the units, area units, and scale\r\n */\r\nconst getCalibratedLengthUnitsAndScale = (image, handles) => {\r\n  const { calibration, hasPixelSpacing } = image;\r\n  let units = hasPixelSpacing ? 'mm' : PIXEL_UNITS;\r\n  let areaUnits = units + SQUARE;\r\n  let scale = 1;\r\n  let calibrationType = '';\r\n\r\n  if (\r\n    !calibration ||\r\n    (!calibration.type && !calibration.sequenceOfUltrasoundRegions)\r\n  ) {\r\n    return { units, areaUnits, scale };\r\n  }\r\n\r\n  if (calibration.type === CalibrationTypes.UNCALIBRATED) {\r\n    return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\r\n  }\r\n\r\n  if (calibration.sequenceOfUltrasoundRegions) {\r\n    let imageIndex1, imageIndex2;\r\n    if (Array.isArray(handles) && handles.length === 2) {\r\n      [imageIndex1, imageIndex2] = handles;\r\n    } else if (typeof handles === 'function') {\r\n      const points = handles();\r\n      imageIndex1 = points[0];\r\n      imageIndex2 = points[1];\r\n    }\r\n\r\n    let regions = calibration.sequenceOfUltrasoundRegions.filter(\r\n      (region) =>\r\n        imageIndex1[0] >= region.regionLocationMinX0 &&\r\n        imageIndex1[0] <= region.regionLocationMaxX1 &&\r\n        imageIndex1[1] >= region.regionLocationMinY0 &&\r\n        imageIndex1[1] <= region.regionLocationMaxY1 &&\r\n        imageIndex2[0] >= region.regionLocationMinX0 &&\r\n        imageIndex2[0] <= region.regionLocationMaxX1 &&\r\n        imageIndex2[1] >= region.regionLocationMinY0 &&\r\n        imageIndex2[1] <= region.regionLocationMaxY1\r\n    );\r\n\r\n    // If we are not in a region at all we should show the underlying calibration\r\n    // which might be the mm spacing for the image\r\n    if (!regions?.length) {\r\n      return { units, areaUnits, scale };\r\n    }\r\n\r\n    // if we are in a region then it is the question of whether we support it\r\n    // or not. If we do not support it we should show px\r\n\r\n    regions = regions.filter(\r\n      (region) =>\r\n        SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\r\n        SUPPORTED_LENGTH_VARIANT.includes(\r\n          `${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`\r\n        )\r\n    );\r\n\r\n    if (!regions.length) {\r\n      return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\r\n    }\r\n\r\n    // Todo: expand on this logic\r\n    const region = regions[0];\r\n\r\n    const physicalDeltaX = Math.abs(region.physicalDeltaX);\r\n    const physicalDeltaY = Math.abs(region.physicalDeltaY);\r\n\r\n    // if we are in a supported region then we should check if the\r\n    // physicalDeltaX and physicalDeltaY are the same. If they are not\r\n    // then we should show px again, but if they are the same then we should\r\n    // show the units\r\n    const isSamePhysicalDelta = utilities.isEqual(\r\n      physicalDeltaX,\r\n      physicalDeltaY,\r\n      EPS\r\n    );\r\n\r\n    if (isSamePhysicalDelta) {\r\n      // 1 to 1 aspect ratio, we use just one of them\r\n      scale = 1 / (physicalDeltaX * 10);\r\n      calibrationType = 'US Region';\r\n      units = 'mm';\r\n      areaUnits = 'mm' + SQUARE;\r\n    } else {\r\n      // here we are showing at the aspect ratio of the physical delta\r\n      // if they are not the same, then we should show px, but the correct solution\r\n      // is to grab each point separately and scale them individually\r\n      // Todo: implement this\r\n      return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\r\n    }\r\n  } else if (calibration.scale) {\r\n    scale = calibration.scale;\r\n  }\r\n\r\n  // everything except REGION/Uncalibrated\r\n  const types = [\r\n    CalibrationTypes.ERMF,\r\n    CalibrationTypes.USER,\r\n    CalibrationTypes.ERROR,\r\n    CalibrationTypes.PROJECTION,\r\n  ];\r\n\r\n  if (types.includes(calibration?.type)) {\r\n    calibrationType = calibration.type;\r\n  }\r\n\r\n  return {\r\n    units: units + (calibrationType ? ` ${calibrationType}` : ''),\r\n    areaUnits: areaUnits + (calibrationType ? ` ${calibrationType}` : ''),\r\n    scale,\r\n  };\r\n};\r\n\r\nconst getCalibratedProbeUnitsAndValue = (image, handles) => {\r\n  const [imageIndex] = handles;\r\n  const { calibration } = image;\r\n  let units = ['raw'];\r\n  let values = [null];\r\n  let calibrationType = '';\r\n\r\n  if (\r\n    !calibration ||\r\n    (!calibration.type && !calibration.sequenceOfUltrasoundRegions)\r\n  ) {\r\n    return { units, values };\r\n    // Todo: add support for other scenarios\r\n  }\r\n\r\n  if (calibration.sequenceOfUltrasoundRegions) {\r\n    // for Probe tool\r\n    const supportedRegionsMetadata =\r\n      calibration.sequenceOfUltrasoundRegions.filter(\r\n        (region) =>\r\n          SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\r\n          SUPPORTED_PROBE_VARIANT.includes(\r\n            `${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`\r\n          )\r\n      );\r\n\r\n    if (!supportedRegionsMetadata?.length) {\r\n      return { units, values };\r\n    }\r\n\r\n    const region = supportedRegionsMetadata.find(\r\n      (region) =>\r\n        imageIndex[0] >= region.regionLocationMinX0 &&\r\n        imageIndex[0] <= region.regionLocationMaxX1 &&\r\n        imageIndex[1] >= region.regionLocationMinY0 &&\r\n        imageIndex[1] <= region.regionLocationMaxY1\r\n    );\r\n\r\n    if (!region) {\r\n      return { units, values };\r\n    }\r\n\r\n    // Todo: I think this is a ok assumption for now that if the referencePixelX0 and referencePixelY0\r\n    // are not defined, then we can assume 0 for them\r\n    const { referencePixelX0 = 0, referencePixelY0 = 0 } = region;\r\n    const { physicalDeltaX, physicalDeltaY } = region;\r\n\r\n    const yValue =\r\n      (imageIndex[1] - region.regionLocationMinY0 - referencePixelY0) *\r\n      physicalDeltaY;\r\n\r\n    const xValue =\r\n      (imageIndex[0] - region.regionLocationMinX0 - referencePixelX0) *\r\n      physicalDeltaX;\r\n\r\n    calibrationType = 'US Region';\r\n    values = [xValue, yValue];\r\n    units = [\r\n      UNIT_MAPPING[region.physicalUnitsXDirection],\r\n      UNIT_MAPPING[region.physicalUnitsYDirection],\r\n    ];\r\n  }\r\n\r\n  return {\r\n    units,\r\n    values,\r\n    calibrationType,\r\n  };\r\n};\r\n\r\n/** Gets the aspect ratio of the screen display relative to the image\r\n * display in order to square up measurement values.\r\n * That is, suppose the spacing on the image is 1, 0.5 (x,y spacing)\r\n * This is displayed at 1, 1 spacing on screen, then the\r\n * aspect value will be 1/0.5 = 2\r\n */\r\nconst getCalibratedAspect = (image) => image.calibration?.aspect || 1;\r\n\r\nexport {\r\n  getCalibratedLengthUnitsAndScale,\r\n  getCalibratedAspect,\r\n  getCalibratedProbeUnitsAndValue,\r\n};\r\n","import { utilities as csUtils } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\r\nimport { vec3 } from 'gl-matrix';\r\nimport { BoundsIJK } from '../types';\r\nimport { getBoundingBoxAroundShapeIJK } from './boundingBox';\r\n\r\nconst { transformWorldToIndex } = csUtils;\r\n\r\n/**\r\n * Given an imageData, and the great circle top and bottom points of a sphere,\r\n * this function will run the callback for each point of the imageData that is\r\n * within the sphere defined by the great circle points. If the viewport\r\n * is provided, region of interest will be an accurate approximation of the\r\n * sphere (using viewport camera), and the resulting performance will be\r\n * better.\r\n *\r\n * @privateRemarks great circle also known as orthodrome is the intersection of\r\n * the sphere and the plane that passes through the center of the sphere\r\n *\r\n * @param imageData - The volume imageData\r\n * @param circlePoints - bottom and top points of the great circle in world coordinates\r\n * @param callback - A callback function that will be called for each point in the shape.\r\n */\r\nfunction getSphereBoundsInfo(\r\n  circlePoints: [Types.Point3, Types.Point3],\r\n  imageData: vtkImageData,\r\n  viewport\r\n): {\r\n  boundsIJK: BoundsIJK;\r\n  centerWorld: Types.Point3;\r\n  radiusWorld: number;\r\n  topLeftWorld: Types.Point3;\r\n  bottomRightWorld: Types.Point3;\r\n} {\r\n  const [bottom, top] = circlePoints;\r\n\r\n  // Sphere center in world\r\n  const centerWorld = vec3.fromValues(\r\n    (bottom[0] + top[0]) / 2,\r\n    (bottom[1] + top[1]) / 2,\r\n    (bottom[2] + top[2]) / 2\r\n  );\r\n\r\n  // sphere radius in world\r\n  const radiusWorld = vec3.distance(bottom, top) / 2;\r\n\r\n  if (!viewport) {\r\n    throw new Error(\r\n      'viewport is required in order to calculate the sphere bounds'\r\n    );\r\n  }\r\n\r\n  const { boundsIJK, topLeftWorld, bottomRightWorld } =\r\n    _computeBoundsIJKWithCamera(\r\n      imageData,\r\n      viewport,\r\n      circlePoints,\r\n      centerWorld,\r\n      radiusWorld\r\n    );\r\n\r\n  return {\r\n    boundsIJK,\r\n    centerWorld: centerWorld as Types.Point3,\r\n    radiusWorld,\r\n    topLeftWorld: topLeftWorld as Types.Point3,\r\n    bottomRightWorld: bottomRightWorld as Types.Point3,\r\n  };\r\n}\r\n\r\nfunction _computeBoundsIJKWithCamera(\r\n  imageData,\r\n  viewport,\r\n  circlePoints,\r\n  centerWorld,\r\n  radiusWorld\r\n) {\r\n  const [bottom, top] = circlePoints;\r\n\r\n  const dimensions = imageData.getDimensions() as Types.Point3;\r\n\r\n  const camera = viewport.getCamera();\r\n\r\n  // Calculate viewRight from the camera, this will get used in order to\r\n  // calculate circles topLeft and bottomRight on different planes of intersection\r\n  // between sphere and viewPlane\r\n  const viewUp = vec3.fromValues(\r\n    camera.viewUp[0],\r\n    camera.viewUp[1],\r\n    camera.viewUp[2]\r\n  );\r\n  const viewPlaneNormal = vec3.fromValues(\r\n    camera.viewPlaneNormal[0],\r\n    camera.viewPlaneNormal[1],\r\n    camera.viewPlaneNormal[2]\r\n  );\r\n  const viewRight = vec3.create();\r\n\r\n  vec3.cross(viewRight, viewUp, viewPlaneNormal);\r\n\r\n  // we need to find the bounding box of the sphere in the image, e.g., the\r\n  // topLeftWorld and bottomRightWorld points of the bounding box.\r\n  // We go from the sphereCenter in the normal direction of amount radius, and\r\n  // we go left to find the topLeftWorld point of the bounding box. Next we go\r\n  // in the opposite direction and go right to find the bottomRightWorld point\r\n  // of the bounding box.\r\n  const topLeftWorld = vec3.create();\r\n  const bottomRightWorld = vec3.create();\r\n\r\n  vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\r\n  vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\r\n\r\n  // go in the direction of viewRight with the value of radius\r\n  vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\r\n  vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\r\n\r\n  // In order to correctly come up with the boundsIJK, we need to consider\r\n  // all the points IJK to get the bounds, since the viewport might have\r\n  // rotate views and we cannot guarantee that the topLeft and bottomRight in the\r\n  // world, are the ones that will define the bounds in IJK\r\n  const topLeftIJK = transformWorldToIndex(\r\n    imageData,\r\n    topLeftWorld as Types.Point3\r\n  );\r\n  const bottomRightIJK = transformWorldToIndex(\r\n    imageData,\r\n    bottomRightWorld as Types.Point3\r\n  );\r\n\r\n  const pointsIJK = circlePoints.map((p) =>\r\n    transformWorldToIndex(imageData, p)\r\n  );\r\n\r\n  // get the bounding box of the sphere in the image\r\n  const boundsIJK = getBoundingBoxAroundShapeIJK(\r\n    [topLeftIJK, bottomRightIJK, ...pointsIJK],\r\n    dimensions\r\n  );\r\n\r\n  return { boundsIJK, topLeftWorld, bottomRightWorld };\r\n}\r\n\r\nexport { getSphereBoundsInfo };\r\n","import type { Annotation } from '../types';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport getViewportsForAnnotation from './getViewportsForAnnotation';\r\n\r\n/**\r\n * Finds a matching viewport in terms of the orientation of the annotation data\r\n * and the frame of reference.  This doesn't mean the annotation IS being displayed\r\n * in the viewport, just that it could be by navigating the slice, and/or pan/zoom,\r\n * without changing the orientation.\r\n *\r\n * @param annotation - to find a viewport that it could display in\r\n * @returns The viewport to display in\r\n */\r\nexport default function getViewportForAnnotation(\r\n  annotation: Annotation\r\n): Types.IStackViewport | Types.IVolumeViewport | undefined {\r\n  const viewports = getViewportsForAnnotation(annotation);\r\n\r\n  return viewports.length ? viewports[0] : undefined;\r\n}\r\n","/**\r\n * Checks if `value` is the\r\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\r\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\r\n *\r\n * @since 0.1.0\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\r\n * @example\r\n *\r\n * isObject({})\r\n * // => true\r\n *\r\n * isObject([1, 2, 3])\r\n * // => true\r\n *\r\n * isObject(Function)\r\n * // => true\r\n *\r\n * isObject(null)\r\n * // => false\r\n */\r\nfunction isObject(value) {\r\n  const type = typeof value;\r\n\r\n  return value !== null && (type === 'object' || type === 'function');\r\n}\r\n\r\nexport default isObject;\r\n","import { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Check if two axis-aligned bounding boxes intersect\r\n * @param aabb1 - First AABB\r\n * @param aabb2 - Second AABB\r\n * @returns True if they intersect or false otherwise\r\n */\r\nexport default function intersectAABB(\r\n  aabb1: Types.AABB2,\r\n  aabb2: Types.AABB2\r\n): boolean {\r\n  return (\r\n    aabb1.minX <= aabb2.maxX &&\r\n    aabb1.maxX >= aabb2.minX &&\r\n    aabb1.minY <= aabb2.maxY &&\r\n    aabb1.maxY >= aabb2.minY\r\n  );\r\n}\r\n","import { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Calculates the distance of a point to an AABB using 2D Box SDF (Signed Distance Field)\r\n *\r\n * The SDF of a Box\r\n * https://www.youtube.com/watch?v=62-pRVZuS5c\r\n *\r\n * @param aabb - Axis-aligned bound box\r\n * @param point - 2D point\r\n * @returns The closest distance between the 2D point and the AABB\r\n */\r\nexport default function distanceToPointSquared(\r\n  aabb: Types.AABB2,\r\n  point: Types.Point2\r\n): number {\r\n  const aabbWidth = aabb.maxX - aabb.minX;\r\n  const aabbHeight = aabb.maxY - aabb.minY;\r\n  const aabbSize = [aabbWidth, aabbHeight];\r\n  const aabbCenter: Types.Point2 = [\r\n    aabb.minX + aabbWidth / 2,\r\n    aabb.minY + aabbHeight / 2,\r\n  ];\r\n\r\n  // Translates the point as the center of the AABB is the new origin.\r\n  // THe point is also mirroed to the first quadrant to simplify the math.\r\n  const translatedPoint = [\r\n    Math.abs(point[0] - aabbCenter[0]),\r\n    Math.abs(point[1] - aabbCenter[1]),\r\n  ];\r\n\r\n  // Calculate the distance from the point to the vertical and horizontal AABB borders\r\n  const dx = translatedPoint[0] - aabbSize[0] * 0.5;\r\n  const dy = translatedPoint[1] - aabbSize[1] * 0.5;\r\n\r\n  // dx >  0 && dy >  0: diagonal line connecting the point to AABB's corner\r\n  // dx >  0 && dy <= 0: a line parallel to x-axis connecting the point to AABB's right side\r\n  // dx <= 0 && dy >  0: a line parallel to y-axis connecting the point to AABB's top side\r\n  // dx <= 0 && dy <= 0: the point is inside the AABB\r\n  if (dx > 0 && dy > 0) {\r\n    return dx * dx + dy * dy;\r\n  }\r\n\r\n  const dist = Math.max(dx, 0) + Math.max(dy, 0);\r\n\r\n  return dist * dist;\r\n}\r\n","import { Types } from '@cornerstonejs/core';\r\nimport distanceToPointSquared from './distanceToPointSquared';\r\n\r\n/**\r\n * Calculates the squared distance of a point to an AABB using\r\n * 2D Box SDF (Signed Distance Field)\r\n *\r\n * The SDF of a Box\r\n * https://www.youtube.com/watch?v=62-pRVZuS5c\r\n *\r\n * @param aabb - Axis-aligned bound box (minX, minY, maxX and maxY)\r\n * @param point - 2D point\r\n * @returns The squared distance between the 2D point and the AABB\r\n */\r\nexport default function distanceToPoint(\r\n  aabb: Types.AABB2,\r\n  point: Types.Point2\r\n): number {\r\n  return Math.sqrt(distanceToPointSquared(aabb, point));\r\n}\r\n","import { NamedStatistics } from '../../../types';\r\n\r\nabstract class Calculator {\r\n  static run: ({ value }) => void;\r\n  /**\r\n   * Gets the statistics as both an array of values, as well as the named values.\r\n   */\r\n  static getStatistics: () => NamedStatistics;\r\n}\r\n\r\nexport default Calculator;\r\n","import { utilities } from '@cornerstonejs/core';\r\nimport { NamedStatistics } from '../../../types';\r\nimport Calculator from './Calculator';\r\n\r\nconst { PointsManager } = utilities;\r\n\r\nexport default class BasicStatsCalculator extends Calculator {\r\n  private static max = [-Infinity];\r\n  private static min = [Infinity];\r\n  private static sum = [0];\r\n  private static count = 0;\r\n\r\n  // private static sumSquares = [0];\r\n  // Values for Welford's algorithm\r\n  private static runMean = [0];\r\n  private static m2 = [0];\r\n\r\n  // Collect the points to be returned\r\n  private static pointsInShape = PointsManager.create3(1024);\r\n\r\n  public static statsInit(options: { noPointsCollection: boolean }) {\r\n    if (options.noPointsCollection) {\r\n      BasicStatsCalculator.pointsInShape = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This callback is used when we verify if the point is in the annotation drawn\r\n   * so we can get every point in the shape to calculate the statistics\r\n   */\r\n  static statsCallback = ({ value: newValue, pointLPS = null }): void => {\r\n    if (\r\n      Array.isArray(newValue) &&\r\n      newValue.length > 1 &&\r\n      this.max.length === 1\r\n    ) {\r\n      this.max.push(this.max[0], this.max[0]);\r\n      this.min.push(this.min[0], this.min[0]);\r\n      this.sum.push(this.sum[0], this.sum[0]);\r\n      this.runMean.push(0, 0);\r\n      // this.sumSquares.push(this.sumSquares[0], this.sumSquares[0]);\r\n      this.m2.push(this.m2[0], this.m2[0]);\r\n    }\r\n\r\n    this.pointsInShape?.push(pointLPS);\r\n    const newArray = Array.isArray(newValue) ? newValue : [newValue];\r\n\r\n    this.count += 1;\r\n    this.max.map((it, idx) => {\r\n      const value = newArray[idx];\r\n\r\n      const delta = value - this.runMean[idx];\r\n      this.sum[idx] += value;\r\n      this.runMean[idx] += delta / this.count;\r\n      const delta2 = value - this.runMean[idx];\r\n      this.m2[idx] += delta * delta2;\r\n      // this.sumSquares[idx] += value * value;\r\n\r\n      this.min[idx] = Math.min(this.min[idx], value);\r\n      this.max[idx] = Math.max(it, value);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Basic function that calculates statistics for a given array of points.\r\n   * @returns An object that contains :\r\n   * max : The maximum value of the array\r\n   * mean : mean of the array\r\n   * stdDev : standard deviation of the array\r\n   * array : An array of hte above values, in order.\r\n   */\r\n\r\n  static getStatistics = (options?: { unit: string }): NamedStatistics => {\r\n    const mean = this.sum.map((sum) => sum / this.count);\r\n    const stdDev = this.m2.map((squaredDiffSum) =>\r\n      Math.sqrt(squaredDiffSum / this.count)\r\n    );\r\n    // const stdDevWithSumSquare = this.sumSquares.map((it, idx) =>\r\n    //   Math.sqrt(this.sumSquares[idx] / this.count - mean[idx] ** 2)\r\n    // );\r\n\r\n    const unit = options?.unit || null;\r\n\r\n    const named: NamedStatistics = {\r\n      max: {\r\n        name: 'max',\r\n        label: 'Max Pixel',\r\n        value: singleArrayAsNumber(this.max),\r\n        unit,\r\n      },\r\n      min: {\r\n        name: 'min',\r\n        label: 'Min Pixel',\r\n        value: singleArrayAsNumber(this.min),\r\n        unit,\r\n      },\r\n      mean: {\r\n        name: 'mean',\r\n        label: 'Mean Pixel',\r\n        value: singleArrayAsNumber(mean),\r\n        unit,\r\n      },\r\n      stdDev: {\r\n        name: 'stdDev',\r\n        label: 'Standard Deviation',\r\n        value: singleArrayAsNumber(stdDev),\r\n        unit,\r\n      },\r\n      // stdDevWithSumSquare: {\r\n      //   name: 'stdDevWithSumSquare',\r\n      //   value: singleArrayAsNumber(stdDevWithSumSquare),\r\n      //   unit,\r\n      // },\r\n      count: {\r\n        name: 'count',\r\n        label: 'Pixel Count',\r\n        value: this.count,\r\n        unit: null,\r\n      },\r\n      pointsInShape: this.pointsInShape,\r\n      array: [],\r\n    };\r\n    named.array.push(\r\n      named.max,\r\n      named.mean,\r\n      named.stdDev,\r\n      // Use the stdDev twice to preserve old ordering - this is updated to be\r\n      // correct value with Welford's algorithm now.\r\n      named.stdDev,\r\n      named.count\r\n    );\r\n\r\n    this.max = [-Infinity];\r\n    this.min = [Infinity];\r\n    this.sum = [0];\r\n    // this.sumSquares = [0];\r\n    this.m2 = [0];\r\n    this.runMean = [0];\r\n    this.count = 0;\r\n    this.pointsInShape = PointsManager.create3(1024);\r\n\r\n    return named;\r\n  };\r\n}\r\n\r\nfunction singleArrayAsNumber(val: number[]) {\r\n  return val.length === 1 ? val[0] : val;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\ninterface Inverts {\r\n  invXRadiusSq?: number;\r\n  invYRadiusSq?: number;\r\n  invZRadiusSq?: number;\r\n  fast?: boolean;\r\n  /**\r\n   * If you call the pointInEllipse.precalculateInverts first, then you\r\n   * can call precalculated directly instead of having the extra time for\r\n   * the if conditions.\r\n   */\r\n  precalculated?: (pointLPS: Types.Point3) => boolean;\r\n}\r\n\r\n/**\r\n * Given an ellipse and a point, return true if the point is inside the ellipse\r\n * @param ellipse - The ellipse object to check against.\r\n * @param pointLPS - The point in LPS space to test.\r\n * @param inverts - An object to cache the inverted radius squared values, if you\r\n * are testing multiple points against the same ellipse then it is recommended to\r\n * pass in the same object to cache the values. However, there is a simpler way\r\n * to do this by passing in the fast flag as true, then on the first iteration\r\n * the values will be cached and on subsequent iterations the cached values will\r\n * be used.\r\n *\r\n * @returns A boolean value.\r\n */\r\nexport default function pointInEllipse(\r\n  ellipse,\r\n  pointLPS,\r\n  inverts: Inverts = {}\r\n) {\r\n  if (!inverts.precalculated) {\r\n    precalculatePointInEllipse(ellipse, inverts);\r\n  }\r\n  return inverts.precalculated(pointLPS);\r\n}\r\n\r\n/**\r\n * This will perform some precalculations to make things faster.\r\n * Ideally, use the 'precalculated' function inside inverts to call the\r\n * test function.  This minimizes re-reading of variables and only needs the\r\n * LPS passed each time.\r\n * That is:\r\n *\r\n * ```\r\n *    const inverts = precalculatePointInEllipse(ellipse);\r\n *    if( inverts.precalculated(pointLPS) ) ...\r\n * ```\r\n */\r\nconst precalculatePointInEllipse = (ellipse, inverts: Inverts = {}) => {\r\n  const { xRadius, yRadius, zRadius } = ellipse;\r\n\r\n  // This will run only once since we are caching the values in the same\r\n  // object that is passed in.\r\n  if (\r\n    inverts.invXRadiusSq === undefined ||\r\n    inverts.invYRadiusSq === undefined ||\r\n    inverts.invZRadiusSq === undefined\r\n  ) {\r\n    inverts.invXRadiusSq = xRadius !== 0 ? 1 / xRadius ** 2 : 0;\r\n    inverts.invYRadiusSq = yRadius !== 0 ? 1 / yRadius ** 2 : 0;\r\n    inverts.invZRadiusSq = zRadius !== 0 ? 1 / zRadius ** 2 : 0;\r\n  }\r\n\r\n  const { invXRadiusSq, invYRadiusSq, invZRadiusSq } = inverts;\r\n  const { center } = ellipse;\r\n  const [centerL, centerP, centerS] = center;\r\n\r\n  inverts.precalculated = (pointLPS) => {\r\n    // Calculate the sum of normalized squared distances\r\n    const dx = pointLPS[0] - centerL;\r\n    let inside = dx * dx * invXRadiusSq;\r\n    if (inside > 1) {\r\n      return false;\r\n    }\r\n\r\n    const dy = pointLPS[1] - centerP;\r\n    inside += dy * dy * invYRadiusSq;\r\n    if (inside > 1) {\r\n      return false;\r\n    }\r\n\r\n    const dz = pointLPS[2] - centerS;\r\n    inside += dz * dz * invZRadiusSq;\r\n\r\n    // Check if the point is inside the ellipse\r\n    return inside <= 1;\r\n  };\r\n\r\n  return inverts;\r\n};\r\n\r\nexport { precalculatePointInEllipse };\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\nexport type CanvasCoordinates = [\r\n  Types.Point2, // bottom\r\n  Types.Point2, // top\r\n  Types.Point2, // left\r\n  Types.Point2 // right\r\n];\r\n\r\n/**\r\n * It takes the canvas coordinates of the ellipse corners and returns the top left and bottom right\r\n * corners of it\r\n *\r\n * @param ellipseCanvasPoints - The coordinates of the ellipse in the canvas.\r\n * @returns An array of two points.\r\n */\r\nexport default function getCanvasEllipseCorners(\r\n  ellipseCanvasPoints: CanvasCoordinates\r\n): Array<Types.Point2> {\r\n  const [bottom, top, left, right] = ellipseCanvasPoints;\r\n\r\n  const topLeft = <Types.Point2>[left[0], top[1]];\r\n  const bottomRight = <Types.Point2>[right[0], bottom[1]];\r\n\r\n  return [topLeft, bottomRight];\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport * as math from '../';\r\n\r\n/**\r\n * Calculate the closest point and the squared distance between a reference point and a line segment.\r\n *\r\n * It projects the reference point onto the line segment but it shall be bounded by the\r\n * start/end points since this is a line segment and not a line which could be extended.\r\n *\r\n * @param lineStart - Start point of the line segment\r\n * @param lineEnd - End point of the line segment\r\n * @param point - Reference point\r\n * @returns Closest point and the squared distance between a `point` and a line\r\n *   segment defined by `lineStart` and `lineEnd` points\r\n */\r\nexport default function distanceToPointSquaredInfo(\r\n  lineStart: Types.Point2,\r\n  lineEnd: Types.Point2,\r\n  point: Types.Point2\r\n): {\r\n  point: Types.Point2;\r\n  distanceSquared: number;\r\n} {\r\n  let closestPoint: Types.Point2;\r\n  const distanceSquared = math.point.distanceToPointSquared(lineStart, lineEnd);\r\n\r\n  // Check if lineStart equal to the lineEnd which means the closest point\r\n  // is any of these two points\r\n  if (lineStart[0] === lineEnd[0] && lineStart[1] === lineEnd[1]) {\r\n    closestPoint = lineStart;\r\n  }\r\n\r\n  if (!closestPoint) {\r\n    const dotProduct =\r\n      ((point[0] - lineStart[0]) * (lineEnd[0] - lineStart[0]) +\r\n        (point[1] - lineStart[1]) * (lineEnd[1] - lineStart[1])) /\r\n      distanceSquared;\r\n\r\n    if (dotProduct < 0) {\r\n      closestPoint = lineStart;\r\n    } else if (dotProduct > 1) {\r\n      closestPoint = lineEnd;\r\n    } else {\r\n      closestPoint = [\r\n        lineStart[0] + dotProduct * (lineEnd[0] - lineStart[0]),\r\n        lineStart[1] + dotProduct * (lineEnd[1] - lineStart[1]),\r\n      ];\r\n    }\r\n  }\r\n\r\n  return {\r\n    point: [...closestPoint],\r\n    distanceSquared: math.point.distanceToPointSquared(point, closestPoint),\r\n  };\r\n}\r\n","import { Types } from '@cornerstonejs/core';\r\nimport distanceToPointSquaredInfo from './distanceToPointSquaredInfo';\r\n\r\n/**\r\n * Calculates the distance-squared of a point to a line segment\r\n *\r\n * @param lineStart - x,y coordinates of the start of the line\r\n * @param lineEnd - x,y coordinates of the end of the line\r\n * @param point - x,y of the point\r\n * @returns distance-squared\r\n */\r\nexport default function distanceToPointSquared(\r\n  lineStart: Types.Point2,\r\n  lineEnd: Types.Point2,\r\n  point: Types.Point2\r\n): number {\r\n  return distanceToPointSquaredInfo(lineStart, lineEnd, point).distanceSquared;\r\n}\r\n","import distanceToPointSquared from './distanceToPointSquared';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Calculates the distance of a point to a line\r\n *\r\n * @param lineStart - x,y coordinates of the start of the line\r\n * @param lineEnd - x,y coordinates of the end of the line\r\n * @param point - x,y of the point\r\n * @returns distance\r\n */\r\nexport default function distanceToPoint(\r\n  lineStart: Types.Point2,\r\n  lineEnd: Types.Point2,\r\n  point: Types.Point2\r\n): number {\r\n  if (lineStart.length !== 2 || lineEnd.length !== 2 || point.length !== 2) {\r\n    throw Error(\r\n      'lineStart, lineEnd, and point should have 2 elements of [x, y]'\r\n    );\r\n  }\r\n\r\n  return Math.sqrt(distanceToPointSquared(lineStart, lineEnd, point));\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\n// Returns sign of number\r\nfunction sign(x: any) {\r\n  return typeof x === 'number'\r\n    ? x\r\n      ? x < 0\r\n        ? -1\r\n        : 1\r\n      : x === x\r\n      ? 0\r\n      : NaN\r\n    : NaN;\r\n}\r\n\r\n/**\r\n * Calculates the intersection point between two lines in the 2D plane\r\n *\r\n * @param line1Start - x,y coordinates of the start of the first line\r\n * @param line1End - x,y coordinates of the end of the first line\r\n * @param line2Start - x,y coordinates of the start of the second line\r\n * @param line2End - x,y coordinates of the end of the second line\r\n * @returns [x,y] - point x,y of the point\r\n */\r\n\r\nexport default function intersectLine(\r\n  line1Start: Types.Point2,\r\n  line1End: Types.Point2,\r\n  line2Start: Types.Point2,\r\n  line2End: Types.Point2\r\n): number[] {\r\n  const [x1, y1] = line1Start;\r\n  const [x2, y2] = line1End;\r\n  const [x3, y3] = line2Start;\r\n  const [x4, y4] = line2End;\r\n\r\n  // Compute a1, b1, c1, where line joining points 1 and 2 is \"a1 x  +  b1 y  +  c1  =  0\"\r\n  const a1 = y2 - y1;\r\n  const b1 = x1 - x2;\r\n  const c1 = x2 * y1 - x1 * y2;\r\n\r\n  // Compute r3 and r4\r\n  const r3 = a1 * x3 + b1 * y3 + c1;\r\n  const r4 = a1 * x4 + b1 * y4 + c1;\r\n\r\n  /* Check signs of r3 and r4.  If both point 3 and point 4 lie on\r\n   * same side of line 1, the line segments do not intersect.\r\n   */\r\n\r\n  if (r3 !== 0 && r4 !== 0 && sign(r3) === sign(r4)) {\r\n    return;\r\n  }\r\n\r\n  // Compute a2, b2, c2\r\n  const a2 = y4 - y3;\r\n  const b2 = x3 - x4;\r\n  const c2 = x4 * y3 - x3 * y4;\r\n\r\n  // Compute r1 and r2\r\n  const r1 = a2 * x1 + b2 * y1 + c2;\r\n  const r2 = a2 * x2 + b2 * y2 + c2;\r\n\r\n  /* Check signs of r1 and r2.  If both point 1 and point 2 lie\r\n   * on same side of second line segment, the line segments do\r\n   * not intersect.\r\n   */\r\n\r\n  if (r1 !== 0 && r2 !== 0 && sign(r1) === sign(r2)) {\r\n    return;\r\n  }\r\n\r\n  /* Line segments intersect: compute intersection point.\r\n   */\r\n\r\n  const denom = a1 * b2 - a2 * b1;\r\n  let num;\r\n\r\n  /* The denom/2 is to get rounding instead of truncating.  It\r\n   * is added or subtracted to the numerator, depending upon the\r\n   * sign of the numerator.\r\n   */\r\n\r\n  num = b1 * c2 - b2 * c1;\r\n  const x = num / denom;\r\n\r\n  num = a2 * c1 - a1 * c2;\r\n  const y = num / denom;\r\n\r\n  const intersectionPoint = [x, y];\r\n\r\n  return intersectionPoint;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\nconst ORIENTATION_TOLERANCE = 1e-2;\r\n\r\n/**\r\n * Test if a point is on a line segment\r\n * @param lineStart - Line segment start point\r\n * @param lineEnd - Line segment end point\r\n * @param point - Point to test\r\n * @returns True if the point lies on the line segment or false otherwise\r\n */\r\nexport default function isPointOnLineSegment(\r\n  lineStart: Types.Point2,\r\n  lineEnd: Types.Point2,\r\n  point: Types.Point2\r\n): boolean {\r\n  // The code below runs ~4x faster than calling `line.distanceToPointSquared()` (155 vs 598 ms)\r\n\r\n  // No Math.min/max call for better performance when testing thousands of points\r\n  const minX = lineStart[0] <= lineEnd[0] ? lineStart[0] : lineEnd[0];\r\n  const maxX = lineStart[0] >= lineEnd[0] ? lineStart[0] : lineEnd[0];\r\n  const minY = lineStart[1] <= lineEnd[1] ? lineStart[1] : lineEnd[1];\r\n  const maxY = lineStart[1] >= lineEnd[1] ? lineStart[1] : lineEnd[1];\r\n\r\n  // Checks if the point lies inside the AABB\r\n  const aabbContainsPoint =\r\n    point[0] >= minX - ORIENTATION_TOLERANCE &&\r\n    point[0] <= maxX + ORIENTATION_TOLERANCE &&\r\n    point[1] >= minY - ORIENTATION_TOLERANCE &&\r\n    point[1] <= maxY + ORIENTATION_TOLERANCE;\r\n\r\n  if (!aabbContainsPoint) {\r\n    return false;\r\n  }\r\n\r\n  // Now that we know the point is inside the AABB we check if it lies on the line segment\r\n  const orientation =\r\n    (lineEnd[1] - lineStart[1]) * (point[0] - lineEnd[0]) -\r\n    (lineEnd[0] - lineStart[0]) * (point[1] - lineEnd[1]);\r\n  const absOrientation = orientation >= 0 ? orientation : -orientation;\r\n\r\n  // The orientation must be zero for points that lies on the same line\r\n  return absOrientation <= ORIENTATION_TOLERANCE;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport distanceToPointSquared from './distanceToPointSquared';\r\n\r\ntype Point = Types.Point2 | Types.Point3;\r\n\r\n/**\r\n * Calculates the distance of a point to another point\r\n *\r\n * @param p1 - x,y or x,y,z of the point\r\n * @param p2 - x,y or x,y,z of the point\r\n * @returns distance\r\n */\r\nexport default function distanceToPoint(p1: Point, p2: Point): number {\r\n  return Math.sqrt(distanceToPointSquared(p1, p2));\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\ntype Point = Types.Point2 | Types.Point3;\r\n\r\n/**\r\n * Calculates the distance squared of a point to another point\r\n *\r\n * @param p1 - x,y or x,y,z of the point\r\n * @param p2 - x,y or x,y,z of the point\r\n * @returns distance\r\n */\r\nexport default function distanceToPointSquared(p1: Point, p2: Point): number {\r\n  if (p1.length !== p2.length) {\r\n    throw Error('Both points should have the same dimensionality');\r\n  }\r\n\r\n  const [x1, y1, z1 = 0] = p1;\r\n  const [x2, y2, z2 = 0] = p2;\r\n  const dx = x2 - x1;\r\n  const dy = y2 - y1;\r\n  const dz = z2 - z1;\r\n\r\n  // Time to square 10M numbers:\r\n  //   (n * n) = 161ms | (n ** 2) = 199ms | Math.pow(n, 2) = 29529ms\r\n  return dx * dx + dy * dy + dz * dz;\r\n}\r\n","import { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Get a mirrored point along the line created by two points where one of them\r\n * is the static (\"anchor\") point and the other one is the point to be mirroed.\r\n * @param mirrorPoint - 2D Point to be mirroed\r\n * @param staticPoint - Static 2D point\r\n * @returns Mirroed 2D point\r\n */\r\nexport default function mirror(\r\n  mirrorPoint: Types.Point2,\r\n  staticPoint: Types.Point2\r\n): Types.Point2 {\r\n  const [x1, y1] = mirrorPoint;\r\n  const [x2, y2] = staticPoint;\r\n\r\n  const newX = 2 * x2 - x1;\r\n  const newY = 2 * y2 - y1;\r\n\r\n  return [newX, newY];\r\n}\r\n","import { glMatrix } from 'gl-matrix';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport * as math from '..';\r\n\r\n/**\r\n * A polyline is considered closed if the start and end points are at the same position\r\n *\r\n * @param polyline - Polyline points (2D)\r\n * @returns True if the polyline is already closed or false otherwise\r\n */\r\nexport default function isClosed(polyline: Types.Point2[]): boolean {\r\n  if (polyline.length < 3) {\r\n    return false;\r\n  }\r\n\r\n  const numPolylinePoints = polyline.length;\r\n\r\n  const firstPoint = polyline[0];\r\n  const lastPoint = polyline[numPolylinePoints - 1];\r\n  const distFirstToLastPoints = math.point.distanceToPointSquared(\r\n    firstPoint,\r\n    lastPoint\r\n  );\r\n\r\n  return glMatrix.equals(0, distFirstToLastPoints);\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport isClosed from './isClosed';\r\n\r\n/**\r\n * Checks if a 2D point is inside the polyline.\r\n *\r\n * A point is inside a curve/polygon if the number of intersections between the horizontal\r\n * ray emanating from the given point and to the right and the line segments is odd.\r\n * https://www.eecs.umich.edu/courses/eecs380/HANDOUTS/PROJ2/InsidePoly.html\r\n *\r\n * Note that a point on the polyline is considered inside.\r\n *\r\n * @param polyline - Polyline points (2D)\r\n * @param point - 2D Point\r\n * @returns True if the point is inside the polyline or false otherwise\r\n */\r\nexport default function containsPoint(\r\n  polyline: Types.Point2[],\r\n  point: Types.Point2,\r\n  options: {\r\n    closed?: boolean;\r\n    holes?: Types.Point2[][];\r\n  } = {\r\n    closed: undefined,\r\n  }\r\n): boolean {\r\n  if (polyline.length < 3) {\r\n    return false;\r\n  }\r\n\r\n  const numPolylinePoints = polyline.length;\r\n  let numIntersections = 0;\r\n\r\n  const { closed, holes } = options;\r\n\r\n  if (holes?.length) {\r\n    for (const hole of holes) {\r\n      if (containsPoint(hole, point)) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Test intersection against [end, start] line segment if it should be closed\r\n  const shouldClose = !(closed === undefined ? isClosed(polyline) : closed);\r\n  const maxSegmentIndex = polyline.length - (shouldClose ? 1 : 2);\r\n\r\n  for (let i = 0; i <= maxSegmentIndex; i++) {\r\n    const p1 = polyline[i];\r\n\r\n    // Calculating the next point index without using % (mod) operator like in\r\n    // `(i + 1) % numPolylinePoints` to make it 20% faster\r\n    const p2Index = i === numPolylinePoints - 1 ? 0 : i + 1;\r\n    const p2 = polyline[p2Index];\r\n\r\n    // Calculating min/max without using Math.min/max to make it ~3% faster\r\n    const maxX = p1[0] >= p2[0] ? p1[0] : p2[0];\r\n    const maxY = p1[1] >= p2[1] ? p1[1] : p2[1];\r\n    const minY = p1[1] <= p2[1] ? p1[1] : p2[1];\r\n\r\n    const mayIntersectLineSegment =\r\n      point[0] <= maxX && point[1] >= minY && point[1] < maxY;\r\n\r\n    if (mayIntersectLineSegment) {\r\n      const isVerticalLine = p1[0] === p2[0];\r\n      let intersects = isVerticalLine;\r\n\r\n      if (!intersects) {\r\n        const xIntersection =\r\n          ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];\r\n\r\n        intersects = point[0] <= xIntersection;\r\n      }\r\n\r\n      numIntersections += intersects ? 1 : 0;\r\n    }\r\n  }\r\n\r\n  return !!(numIntersections % 2);\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport containsPoint from './containsPoint';\r\n\r\n/**\r\n * Checks if a polyline contains a set of points.\r\n *\r\n * @param polyline - Polyline points (2D)\r\n * @param points - 2D points to verify\r\n * @returns True if all points are inside the polyline or false otherwise\r\n */\r\nexport default function containsPoints(\r\n  polyline: Types.Point2[],\r\n  points: Types.Point2[]\r\n): boolean {\r\n  for (let i = 0, numPoint = points.length; i < numPoint; i++) {\r\n    if (!containsPoint(polyline, points[i])) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Calculates the area of an array of `Point2` points using the shoelace algorithm.\r\n *\r\n * The units of the area are in the same units as the points are in. E.g. if\r\n * the points are in canvas, then the result is in canvas pixels ^2; If they are\r\n * in mm, then the result is in mm^2; etc.\r\n */\r\nexport default function getArea(points: Types.Point2[]): number {\r\n  // Shoelace algorithm.\r\n  const n = points.length;\r\n  let area = 0.0;\r\n  let j = n - 1;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);\r\n    j = i; // j is previous vertex to i\r\n  }\r\n\r\n  // Return absolute value of half the sum (half as summing up traingles).\r\n  return Math.abs(area / 2.0);\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Returns the area with signal of a 2D polyline\r\n * https://www.youtube.com/watch?v=GpsKrAipXm8&t=1900s\r\n *\r\n * This functions has a runtime very close to `getArea` and it is recommended to\r\n * be called only if you need the area signal (eg: calculate polygon normal or\r\n * winding direction). If you do not need the area signal you should always call\r\n * `getArea`.\r\n *\r\n * @param polyline - Polyline points (2D)\r\n * @returns Area of the polyline (with signal)\r\n */\r\nexport default function getSignedArea(polyline: Types.Point2[]): number {\r\n  if (polyline.length < 3) {\r\n    return 0;\r\n  }\r\n\r\n  // Reference point can be any point on the same plane\r\n  const refPoint = polyline[0];\r\n  let area = 0;\r\n\r\n  // Takes three points (reference point and two other points from each line\r\n  // segment) and calculate the area with cross product. The magnitude of the\r\n  // vector returned by a cross product is equal to the area of the parallelogram\r\n  // that the vectors span which is two times the area of the triangle.\r\n  //\r\n  // Not calling vec3 mathods makes the function run much faster since polylines\r\n  // may have thousands of points when using freehand ROI tool and that would\r\n  // increase considerably the number of function calls.\r\n  for (let i = 0, len = polyline.length; i < len; i++) {\r\n    const p1 = polyline[i];\r\n    // Using ternary instead of % (mod) operator to make it faster\r\n    const p2Index = i === len - 1 ? 0 : i + 1;\r\n    const p2 = polyline[p2Index];\r\n    const aX = p1[0] - refPoint[0];\r\n    const aY = p1[1] - refPoint[1];\r\n    const bX = p2[0] - refPoint[0];\r\n    const bY = p2[1] - refPoint[1];\r\n\r\n    // Cross product between vectors \"a\" and \"b\" which returns (0, 0, crossProd)\r\n    // for 2D vectors.\r\n    area += aX * bY - aY * bX;\r\n  }\r\n\r\n  // Divide by two because cross product returns two times the area for each triangle\r\n  area *= 0.5;\r\n\r\n  return area;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport getSignedArea from './getSignedArea';\r\n\r\n/**\r\n * Calculate the winding direction (CW or CCW) of a polyline\r\n * @param polyline - Polyline (2D)\r\n * @returns 1 for CW or -1 for CCW polylines\r\n */\r\nexport default function getWindingDirection(polyline: Types.Point2[]): number {\r\n  const signedArea = getSignedArea(polyline);\r\n\r\n  // Return 1 or -1 which is also possible to convert into ContourOrientation\r\n  return signedArea >= 0 ? 1 : -1;\r\n}\r\n","import { vec3 } from 'gl-matrix';\r\nimport { Types } from '@cornerstonejs/core';\r\n\r\nfunction _getAreaVector(polyline: Types.Point3[]): Types.Point3 {\r\n  const vecArea = vec3.create();\r\n\r\n  // Reference point can be any point on the same plane\r\n  const refPoint = polyline[0];\r\n\r\n  // Takes three points, reference point and two other points from each line\r\n  // segment, and calculate the area with cross product. The magnitude of the\r\n  // vector returned by a cross product is equal to the area of the parallelogram\r\n  // that the vectors span which is two times the area of the triangle.\r\n  //\r\n  // Not calling vec3 mathods makes the function run much faster since polylines\r\n  // may have thousands of points when using freehand ROI tool and that would\r\n  // increase considerably the number of function calls.\r\n  for (let i = 0, len = polyline.length; i < len; i++) {\r\n    const p1 = polyline[i];\r\n    // Using ternary instead of % (mod) operator to make it faster\r\n    const p2Index = i === len - 1 ? 0 : i + 1;\r\n    const p2 = polyline[p2Index];\r\n\r\n    const aX = p1[0] - refPoint[0];\r\n    const aY = p1[1] - refPoint[1];\r\n    const aZ = p1[2] - refPoint[2];\r\n    const bX = p2[0] - refPoint[0];\r\n    const bY = p2[1] - refPoint[1];\r\n    const bZ = p2[2] - refPoint[2];\r\n\r\n    // Cross product without calling vec3.cross() for better performance\r\n    vecArea[0] += aY * bZ - aZ * bY;\r\n    vecArea[1] += aZ * bX - aX * bZ;\r\n    vecArea[2] += aX * bY - aY * bX;\r\n  }\r\n\r\n  // Divide by two because cross product returns two times the area for each triangle\r\n  vec3.scale(vecArea, vecArea, 0.5);\r\n\r\n  // The magnitude of the vector is the area of the polyline\r\n  return <Types.Point3>vecArea;\r\n}\r\n\r\n/**\r\n * Calculate the normal of a 3D planar polyline\r\n * @param polyline - Planar polyline in 3D space\r\n * @returns Normal of the 3D planar polyline\r\n */\r\nexport default function getNormal3(polyline: Types.Point3[]): Types.Point3 {\r\n  const vecArea = _getAreaVector(polyline);\r\n\r\n  return vec3.normalize(vecArea, vecArea) as Types.Point3;\r\n}\r\n","import { Types } from '@cornerstonejs/core';\r\nimport getSignedArea from './getSignedArea';\r\n\r\n/**\r\n * Calculate the normal of a 2D polyline\r\n * https://www.youtube.com/watch?v=GpsKrAipXm8&t=1982s\r\n *\r\n * @param polyline - Planar polyline in 2D space\r\n * @returns Normal of the 2D planar polyline\r\n */\r\nexport default function getNormal2(polyline: Types.Point2[]): Types.Point3 {\r\n  const area = getSignedArea(polyline);\r\n\r\n  // The normal of a 2D polyline is (0, 0, 1) or (0, 0, -1) depending if it\r\n  // is CW or CCW polyline\r\n  return [0, 0, area / Math.abs(area)] as Types.Point3;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\n// ATTENTION: this is an internal function and it should not be added to \"polyline\"\r\n// namespace.\r\n//\r\n// TODO: there is a similar function in math.lineSegment.intersectLine but we\r\n// need to investigate why it is 6x slower than this one when thousands of\r\n// intersections are calculated. Also that one may return [NaN, NaN] for\r\n// collinear points.\r\n\r\n/**\r\n * Checks whether the line (`p1`,`q1`) intersects the line (`p2`,`q2`) via an\r\n * orientation algorithm.\r\n *\r\n * Credit and details: geeksforgeeks.org/check-if-two-given-line-segments-intersect/\r\n *\r\n * @param p1 - Start point of line segment 1\r\n * @param q1 - End point of line segment 1\r\n * @param p2 - Start point of line segment 2\r\n * @param q2 - End point of line segment 2\r\n * @returns True if the line segments intersect or false otherwise\r\n */\r\nexport default function areLineSegmentsIntersecting(\r\n  p1: Types.Point2,\r\n  q1: Types.Point2,\r\n  p2: Types.Point2,\r\n  q2: Types.Point2\r\n): boolean {\r\n  let result = false;\r\n\r\n  // Line 1 AABB\r\n  const line1MinX = p1[0] < q1[0] ? p1[0] : q1[0];\r\n  const line1MinY = p1[1] < q1[1] ? p1[1] : q1[1];\r\n  const line1MaxX = p1[0] > q1[0] ? p1[0] : q1[0];\r\n  const line1MaxY = p1[1] > q1[1] ? p1[1] : q1[1];\r\n\r\n  // Line 2 AABB\r\n  const line2MinX = p2[0] < q2[0] ? p2[0] : q2[0];\r\n  const line2MinY = p2[1] < q2[1] ? p2[1] : q2[1];\r\n  const line2MaxX = p2[0] > q2[0] ? p2[0] : q2[0];\r\n  const line2MaxY = p2[1] > q2[1] ? p2[1] : q2[1];\r\n\r\n  // If AABBs do not intersect it is impossible for the lines to intersect.\r\n  // Checking AABB before doing any math makes it run ~12% faster.\r\n  if (\r\n    line1MinX > line2MaxX ||\r\n    line1MaxX < line2MinX ||\r\n    line1MinY > line2MaxY ||\r\n    line1MaxY < line2MinY\r\n  ) {\r\n    return false;\r\n  }\r\n\r\n  const orient = [\r\n    orientation(p1, q1, p2),\r\n    orientation(p1, q1, q2),\r\n    orientation(p2, q2, p1),\r\n    orientation(p2, q2, q1),\r\n  ];\r\n\r\n  // General Case\r\n  if (orient[0] !== orient[1] && orient[2] !== orient[3]) {\r\n    return true;\r\n  }\r\n\r\n  // Special Cases\r\n  if (orient[0] === 0 && onSegment(p1, p2, q1)) {\r\n    // If p1, q1 and p2 are colinear and p2 lies on segment p1q1\r\n    result = true;\r\n  } else if (orient[1] === 0 && onSegment(p1, q2, q1)) {\r\n    // If p1, q1 and p2 are colinear and q2 lies on segment p1q1\r\n    result = true;\r\n  } else if (orient[2] === 0 && onSegment(p2, p1, q2)) {\r\n    // If p2, q2 and p1 are colinear and p1 lies on segment p2q2\r\n    result = true;\r\n  } else if (orient[3] === 0 && onSegment(p2, q1, q2)) {\r\n    // If p2, q2 and q1 are colinear and q1 lies on segment p2q2\r\n    result = true;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Checks the orientation of 3 points, returns a 0, 1 or 2 based on\r\n * the orientation of the points.\r\n */\r\nfunction orientation(\r\n  p: Types.Point2,\r\n  q: Types.Point2,\r\n  r: Types.Point2\r\n): number {\r\n  // Take the cross product between vectors PQ and QR\r\n  const orientationValue =\r\n    (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\r\n\r\n  if (orientationValue === 0) {\r\n    return 0; // Colinear\r\n  }\r\n\r\n  return orientationValue > 0 ? 1 : 2;\r\n}\r\n\r\n/**\r\n * Checks if point `q` lies on the segment (`p`,`r`).\r\n */\r\nfunction onSegment(p: Types.Point2, q: Types.Point2, r: Types.Point2): boolean {\r\n  if (\r\n    q[0] <= Math.max(p[0], r[0]) &&\r\n    q[0] >= Math.min(p[0], r[0]) &&\r\n    q[1] <= Math.max(p[1], r[1]) &&\r\n    q[1] >= Math.min(p[1], r[1])\r\n  ) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\r\n\r\n/**\r\n * Get all intersections between a polyline and a line segment.\r\n * @param polyline - Polyline points\r\n * @param p1 - Start point of line segment\r\n * @param q1 - End point of line segment\r\n * @param closed - Test the intersection against the line segment that connects\r\n * the last to the first point when set to true\r\n * @returns Start/end point indexes of all line segments that intersect (p1, q1)\r\n */\r\nexport default function getLineSegmentIntersectionsIndexes(\r\n  polyline: Types.Point2[],\r\n  p1: Types.Point2,\r\n  q1: Types.Point2,\r\n  closed = true\r\n): Types.Point2[] {\r\n  const intersections: Types.Point2[] = [];\r\n  const numPoints = polyline.length;\r\n  const maxI = numPoints - (closed ? 1 : 2);\r\n\r\n  for (let i = 0; i <= maxI; i++) {\r\n    const p2 = polyline[i];\r\n    // Do not use % operator for better performance\r\n    const j = i === numPoints - 1 ? 0 : i + 1;\r\n    const q2 = polyline[j];\r\n\r\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\r\n      intersections.push([i, j]);\r\n    }\r\n  }\r\n\r\n  return intersections;\r\n}\r\n","import { Types } from '@cornerstonejs/core';\r\nimport * as mathLine from '../line';\r\n\r\n// ATTENTION: this is an internal function and it should not be added to \"polyline\" namespace\r\n\r\n// Tested with +1M random overlapping line segments and any tolerance below this\r\n// one may return invalid results.\r\nconst PARALLEL_LINES_TOLERANCE = 1e-2;\r\n\r\n/**\r\n * It returns the intersection between two lines (not line segments) or a midpoint\r\n * when the line segments overlap. This function calculates the intersection between\r\n * lines because it considers that getFirstLineSegmentIntersectionIndexes,\r\n * getLineSegmentIntersectionsCoordinates or getLineSegmentIntersectionsIndexes\r\n * has already been called first which guarantees.\r\n *\r\n * @param p1 - Line segment 1 start\r\n * @param q1 - Line segment 1 end\r\n * @param p2 - Line segment 2 start\r\n * @param q2 - Line segment 21 end\r\n * @returns The intersection between two lines or a midpoint when they overlap\r\n */\r\nexport default function getLinesIntersection(\r\n  p1: Types.Point2,\r\n  q1: Types.Point2,\r\n  p2: Types.Point2,\r\n  q2: Types.Point2\r\n) {\r\n  const diffQ1P1 = [q1[0] - p1[0], q1[1] - p1[1]];\r\n  const diffQ2P2 = [q2[0] - p2[0], q2[1] - p2[1]];\r\n  const denominator = diffQ2P2[1] * diffQ1P1[0] - diffQ2P2[0] * diffQ1P1[1];\r\n  const absDenominator = denominator >= 0 ? denominator : -denominator;\r\n\r\n  if (absDenominator < PARALLEL_LINES_TOLERANCE) {\r\n    // No Math.min/max calls for better performance.\r\n    const line1AABB = [\r\n      p1[0] < q1[0] ? p1[0] : q1[0], // 0: minX\r\n      p1[0] > q1[0] ? p1[0] : q1[0], // 1: maxX\r\n      p1[1] < q1[1] ? p1[1] : q1[1], // 2: minY\r\n      p1[1] > q1[1] ? p1[1] : q1[1], // 3: maxY\r\n    ];\r\n\r\n    // No Math.min/max calls for better performance.\r\n    const line2AABB = [\r\n      p2[0] < q2[0] ? p2[0] : q2[0], // 0: minX\r\n      p2[0] > q2[0] ? p2[0] : q2[0], // 1: maxX\r\n      p2[1] < q2[1] ? p2[1] : q2[1], // 2: minY\r\n      p2[1] > q2[1] ? p2[1] : q2[1], // 3: maxY\r\n    ];\r\n\r\n    const aabbIntersects =\r\n      line1AABB[0] <= line2AABB[1] && // minX1 <= maxX2\r\n      line1AABB[1] >= line2AABB[0] && // maxX1 >= minX2\r\n      line1AABB[2] <= line2AABB[3] && // minY1 <= maxY2\r\n      line1AABB[3] >= line2AABB[2]; // maxY1 >= minY2\r\n\r\n    if (!aabbIntersects) {\r\n      return;\r\n    }\r\n\r\n    // Three tests are enough to know if the lines overlap\r\n    const overlap =\r\n      mathLine.isPointOnLineSegment(p1, q1, p2) ||\r\n      mathLine.isPointOnLineSegment(p1, q1, q2) ||\r\n      mathLine.isPointOnLineSegment(p2, q2, p1);\r\n\r\n    if (!overlap) {\r\n      return;\r\n    }\r\n\r\n    // min/max seems to be inverted but that is correct because it is looking\r\n    // for the intersection range. No Math.min/max calls for better performance.\r\n    const minX = line1AABB[0] > line2AABB[0] ? line1AABB[0] : line2AABB[0];\r\n    const maxX = line1AABB[1] < line2AABB[1] ? line1AABB[1] : line2AABB[1];\r\n    const minY = line1AABB[2] > line2AABB[2] ? line1AABB[2] : line2AABB[2];\r\n    const maxY = line1AABB[3] < line2AABB[3] ? line1AABB[3] : line2AABB[3];\r\n    const midX = (minX + maxX) * 0.5;\r\n    const midY = (minY + maxY) * 0.5;\r\n\r\n    return [midX, midY];\r\n  }\r\n\r\n  let a = p1[1] - p2[1];\r\n  let b = p1[0] - p2[0];\r\n  const numerator1 = diffQ2P2[0] * a - diffQ2P2[1] * b;\r\n  const numerator2 = diffQ1P1[0] * a - diffQ1P1[1] * b;\r\n  a = numerator1 / denominator;\r\n  b = numerator2 / denominator;\r\n\r\n  const resultX = p1[0] + a * diffQ1P1[0];\r\n  const resultY = p1[1] + a * diffQ1P1[1];\r\n\r\n  return [resultX, resultY];\r\n}\r\n","import { Types } from '@cornerstonejs/core';\r\nimport * as mathPoint from '../point';\r\nimport getLineSegmentIntersectionsIndexes from './getLineSegmentIntersectionsIndexes';\r\nimport containsPoint from './containsPoint';\r\nimport getNormal2 from './getNormal2';\r\nimport { glMatrix, vec3 } from 'gl-matrix';\r\nimport getLinesIntersection from './getLinesIntersection';\r\n\r\nenum PolylinePointType {\r\n  Vertex,\r\n  Intersection,\r\n}\r\n\r\n// Position of the point related to the intersection region\r\nenum PolylinePointPosition {\r\n  Outside = -1,\r\n  Edge = 0,\r\n  Inside = 1,\r\n}\r\n\r\n// Direction from last point to the intersection point to know if it is entering\r\n// or exiting the intersection region\r\nenum PolylinePointDirection {\r\n  Exiting = -1,\r\n  Unknown = 0,\r\n  Entering = 1,\r\n}\r\n\r\ntype PolylinePoint = {\r\n  type: PolylinePointType;\r\n  coordinates: Types.Point2;\r\n  position?: PolylinePointPosition;\r\n  visited: boolean;\r\n  next: PolylinePoint;\r\n};\r\n\r\ntype PolylineIntersectionPoint = PolylinePoint & {\r\n  direction: PolylinePointDirection;\r\n  cloned?: boolean;\r\n};\r\n\r\n/**\r\n * Ensure all polyline point objects are pointing to the next object in case\r\n * it is still not point to anyone.\r\n * @param polylinePoints - Array that contains all polyline points (vertices and intersections)\r\n */\r\nfunction ensuresNextPointers(polylinePoints: PolylinePoint[]) {\r\n  // Make sure all nodes point to a valid node\r\n  for (let i = 0, len = polylinePoints.length; i < len; i++) {\r\n    const currentPoint = polylinePoints[i];\r\n\r\n    if (!currentPoint.next) {\r\n      currentPoint.next = polylinePoints[i === len - 1 ? 0 : i + 1];\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Creates one linked list per polyline that contains all vertices and intersections\r\n * found while walking along the edges.\r\n *\r\n * @param targetPolyline - Target polyline\r\n * @param sourcePolyline - Source polyline\r\n * @returns Two linked lists with all vertices and intersections.\r\n */\r\nfunction getSourceAndTargetPointsList(\r\n  targetPolyline: Types.Point2[],\r\n  sourcePolyline: Types.Point2[]\r\n) {\r\n  const targetPolylinePoints: PolylinePoint[] = [];\r\n  const sourcePolylinePoints: PolylinePoint[] = [];\r\n  const sourceIntersectionsCache = new Map<\r\n    number,\r\n    PolylineIntersectionPoint[]\r\n  >();\r\n\r\n  const isFirstPointInside = containsPoint(sourcePolyline, targetPolyline[0]);\r\n\r\n  let intersectionPointDirection = isFirstPointInside\r\n    ? PolylinePointDirection.Exiting\r\n    : PolylinePointDirection.Entering;\r\n\r\n  // Store all vertices and intersection for target contour\r\n  for (let i = 0, len = targetPolyline.length; i < len; i++) {\r\n    const p1 = targetPolyline[i];\r\n    const pointInside = containsPoint(sourcePolyline, p1);\r\n    const vertexPoint: PolylinePoint = {\r\n      type: PolylinePointType.Vertex,\r\n      coordinates: p1,\r\n      position: pointInside\r\n        ? PolylinePointPosition.Inside\r\n        : PolylinePointPosition.Outside,\r\n      visited: false,\r\n      next: null,\r\n    };\r\n\r\n    targetPolylinePoints.push(vertexPoint);\r\n\r\n    const q1 = targetPolyline[i === len - 1 ? 0 : i + 1];\r\n    const intersectionsInfo = getLineSegmentIntersectionsIndexes(\r\n      sourcePolyline,\r\n      p1,\r\n      q1\r\n    ).map((intersectedLineSegment) => {\r\n      const sourceLineSegmentId: number = intersectedLineSegment[0];\r\n      const p2 = sourcePolyline[intersectedLineSegment[0]];\r\n      const q2 = sourcePolyline[intersectedLineSegment[1]];\r\n\r\n      // lineSegment.intersectLine returns the midpoint of the four points\r\n      // when the lines are parallel or co-incident.  Otherwise it will return\r\n      // an extension of the line.\r\n      const intersectionCoordinate = getLinesIntersection(\r\n        p1,\r\n        q1,\r\n        p2,\r\n        q2\r\n      ) as Types.Point2;\r\n\r\n      const targetStartPointDistSquared = mathPoint.distanceToPointSquared(\r\n        p1,\r\n        intersectionCoordinate\r\n      );\r\n\r\n      return {\r\n        sourceLineSegmentId,\r\n        coordinate: intersectionCoordinate,\r\n        targetStartPointDistSquared,\r\n      };\r\n    });\r\n\r\n    intersectionsInfo.sort(\r\n      (left, right) =>\r\n        left.targetStartPointDistSquared - right.targetStartPointDistSquared\r\n    );\r\n\r\n    intersectionsInfo.forEach((intersectionInfo) => {\r\n      const { sourceLineSegmentId, coordinate: intersectionCoordinate } =\r\n        intersectionInfo;\r\n\r\n      // Intersection point to be added to the target polyline list\r\n      const targetEdgePoint: PolylineIntersectionPoint = {\r\n        type: PolylinePointType.Intersection,\r\n        coordinates: intersectionCoordinate,\r\n        position: PolylinePointPosition.Edge,\r\n        direction: intersectionPointDirection,\r\n        visited: false,\r\n        next: null,\r\n      };\r\n\r\n      // Intersection point to be added to the source polyline list.\r\n      // At this point there is no way to know if the point is entering or\r\n      // exiting the intersection region but that is not going to be used\r\n      // hence it is set to \"unknown\".\r\n      const sourceEdgePoint: PolylineIntersectionPoint = {\r\n        ...targetEdgePoint,\r\n        direction: PolylinePointDirection.Unknown,\r\n        cloned: true,\r\n      };\r\n\r\n      if (intersectionPointDirection === PolylinePointDirection.Entering) {\r\n        targetEdgePoint.next = sourceEdgePoint;\r\n      } else {\r\n        sourceEdgePoint.next = targetEdgePoint;\r\n      }\r\n\r\n      let sourceIntersectionPoints =\r\n        sourceIntersectionsCache.get(sourceLineSegmentId);\r\n\r\n      if (!sourceIntersectionPoints) {\r\n        sourceIntersectionPoints = [];\r\n        sourceIntersectionsCache.set(\r\n          sourceLineSegmentId,\r\n          sourceIntersectionPoints\r\n        );\r\n      }\r\n\r\n      targetPolylinePoints.push(targetEdgePoint);\r\n      sourceIntersectionPoints.push(sourceEdgePoint);\r\n\r\n      // Switches from \"exiting\" to \"entering\" and vice-versa\r\n      intersectionPointDirection *= -1;\r\n    });\r\n  }\r\n\r\n  // Store all vertices and intersections for source contour\r\n  for (let i = 0, len = sourcePolyline.length; i < len; i++) {\r\n    const lineSegmentId: number = i;\r\n    const p1 = sourcePolyline[i];\r\n    const vertexPoint: PolylinePoint = {\r\n      type: PolylinePointType.Vertex,\r\n      coordinates: p1,\r\n      visited: false,\r\n      next: null,\r\n    };\r\n\r\n    sourcePolylinePoints.push(vertexPoint);\r\n\r\n    const sourceIntersectionPoints =\r\n      sourceIntersectionsCache.get(lineSegmentId);\r\n\r\n    if (!sourceIntersectionPoints?.length) {\r\n      continue;\r\n    }\r\n\r\n    // Calculate the distance between each intersection point to the start point\r\n    // of the line segment, sort them by distance and return a sorted array that\r\n    // contains all intersection points.\r\n    sourceIntersectionPoints\r\n      .map((intersectionPoint) => ({\r\n        intersectionPoint,\r\n        lineSegStartDistSquared: mathPoint.distanceToPointSquared(\r\n          p1,\r\n          intersectionPoint.coordinates\r\n        ),\r\n      }))\r\n      .sort(\r\n        (left, right) =>\r\n          left.lineSegStartDistSquared - right.lineSegStartDistSquared\r\n      )\r\n      .map(({ intersectionPoint }) => intersectionPoint)\r\n      .forEach((intersectionPoint) =>\r\n        sourcePolylinePoints.push(intersectionPoint)\r\n      );\r\n  }\r\n\r\n  ensuresNextPointers(targetPolylinePoints);\r\n  ensuresNextPointers(sourcePolylinePoints);\r\n\r\n  return { targetPolylinePoints, sourcePolylinePoints };\r\n}\r\n\r\n/**\r\n * Get the next unvisited polyline points that is outside the intersection region.\r\n * @param polylinePoints - All polyline points (vertices and intersections)\r\n * @returns Any unvisited point that is outside the intersection region if it\r\n * exists or `undefined` otherwise\r\n */\r\nfunction getUnvisitedOutsidePoint(polylinePoints: PolylinePoint[]) {\r\n  for (let i = 0, len = polylinePoints.length; i < len; i++) {\r\n    const point = polylinePoints[i];\r\n\r\n    if (!point.visited && point.position === PolylinePointPosition.Outside) {\r\n      return point;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Merge two planar polylines (2D)\r\n */\r\nfunction mergePolylines(\r\n  targetPolyline: Types.Point2[],\r\n  sourcePolyline: Types.Point2[]\r\n) {\r\n  const targetNormal = getNormal2(targetPolyline);\r\n  const sourceNormal = getNormal2(sourcePolyline);\r\n  const dotNormals = vec3.dot(sourceNormal, targetNormal);\r\n\r\n  // Both polylines need to be CW or CCW to be merged and one of them needs to\r\n  // be reversed if theirs orientation are not the same\r\n  if (!glMatrix.equals(1, dotNormals)) {\r\n    sourcePolyline = sourcePolyline.slice().reverse();\r\n  }\r\n\r\n  const { targetPolylinePoints } = getSourceAndTargetPointsList(\r\n    targetPolyline,\r\n    sourcePolyline\r\n  );\r\n  const startPoint: PolylinePoint =\r\n    getUnvisitedOutsidePoint(targetPolylinePoints);\r\n\r\n  // Source polyline contains target polyline\r\n  if (!startPoint) {\r\n    return targetPolyline.slice();\r\n  }\r\n\r\n  const mergedPolyline = [startPoint.coordinates];\r\n  let currentPoint = startPoint.next;\r\n\r\n  while (currentPoint !== startPoint) {\r\n    if (\r\n      currentPoint.type === PolylinePointType.Intersection &&\r\n      (<PolylineIntersectionPoint>currentPoint).cloned\r\n    ) {\r\n      currentPoint = currentPoint.next;\r\n      continue;\r\n    }\r\n\r\n    mergedPolyline.push(currentPoint.coordinates);\r\n    currentPoint = currentPoint.next;\r\n  }\r\n\r\n  return mergedPolyline;\r\n}\r\n\r\n/**\r\n * Subtract two planar polylines (2D)\r\n */\r\nfunction subtractPolylines(\r\n  targetPolyline: Types.Point2[],\r\n  sourcePolyline: Types.Point2[]\r\n): Types.Point2[][] {\r\n  const targetNormal = getNormal2(targetPolyline);\r\n  const sourceNormal = getNormal2(sourcePolyline);\r\n  const dotNormals = vec3.dot(sourceNormal, targetNormal);\r\n\r\n  // The polylines need to have different orientation (CW+CCW or CCW+CW) to be\r\n  // subtracted and one of them needs to be reversed if theirs orientation are\r\n  // the same\r\n  if (!glMatrix.equals(-1, dotNormals)) {\r\n    sourcePolyline = sourcePolyline.slice().reverse();\r\n  }\r\n\r\n  const { targetPolylinePoints } = getSourceAndTargetPointsList(\r\n    targetPolyline,\r\n    sourcePolyline\r\n  );\r\n  let startPoint: PolylinePoint = null;\r\n  const subtractedPolylines = [];\r\n\r\n  while ((startPoint = getUnvisitedOutsidePoint(targetPolylinePoints))) {\r\n    const subtractedPolyline = [startPoint.coordinates];\r\n    let currentPoint = startPoint.next;\r\n\r\n    startPoint.visited = true;\r\n\r\n    while (currentPoint !== startPoint) {\r\n      currentPoint.visited = true;\r\n\r\n      if (\r\n        currentPoint.type === PolylinePointType.Intersection &&\r\n        (<PolylineIntersectionPoint>currentPoint).cloned\r\n      ) {\r\n        currentPoint = currentPoint.next;\r\n        continue;\r\n      }\r\n\r\n      subtractedPolyline.push(currentPoint.coordinates);\r\n      currentPoint = currentPoint.next;\r\n    }\r\n\r\n    subtractedPolylines.push(subtractedPolyline);\r\n  }\r\n\r\n  return subtractedPolylines;\r\n}\r\n\r\nexport { mergePolylines, subtractPolylines };\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\r\n\r\n/**\r\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\r\n * `points`, and returns the first value.\r\n *\r\n * @param points - Polyline points\r\n * @param p1 - First point of the line segment that is being tested\r\n * @param q1 - Second point of the line segment that is being tested\r\n * @param closed - Test the intersection with the line segment that connects\r\n *   the last and first points of the polyline\r\n * @returns Indexes of the line segment points from the polyline that intersects [p1, q1]\r\n */\r\nexport default function getFirstLineSegmentIntersectionIndexes(\r\n  points: Types.Point2[],\r\n  p1: Types.Point2,\r\n  q1: Types.Point2,\r\n  closed = true\r\n): Types.Point2 | undefined {\r\n  let initialI;\r\n  let j;\r\n\r\n  if (closed) {\r\n    j = points.length - 1;\r\n    initialI = 0;\r\n  } else {\r\n    j = 0;\r\n    initialI = 1;\r\n  }\r\n\r\n  for (let i = initialI; i < points.length; i++) {\r\n    const p2 = points[j];\r\n    const q2 = points[i];\r\n\r\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\r\n      return [j, i];\r\n    }\r\n\r\n    j = i;\r\n  }\r\n}\r\n","import { Types } from '@cornerstonejs/core';\r\nimport getFirstLineSegmentIntersectionIndexes from './getFirstLineSegmentIntersectionIndexes';\r\n\r\n/**\r\n * Check if two polylines intersect comparing line segment by line segment.\r\n * @param sourcePolyline - Source polyline\r\n * @param targetPolyline - Target polyline\r\n * @returns True if the polylines intersect or false otherwise\r\n */\r\nexport default function intersectPolyline(\r\n  sourcePolyline: Types.Point2[],\r\n  targetPolyline: Types.Point2[]\r\n): boolean {\r\n  // Naive way to detect intersection between polylines in O(n^2).\r\n  // TODO: Implement Bentley Ottmann sweep line algorithm or maybe some\r\n  // algorithm that uses r-tree may make it run faster\r\n  for (let i = 0, sourceLen = sourcePolyline.length; i < sourceLen; i++) {\r\n    const sourceP1 = sourcePolyline[i];\r\n    const sourceP2Index = i === sourceLen - 1 ? 0 : i + 1;\r\n    const sourceP2 = sourcePolyline[sourceP2Index];\r\n\r\n    const intersectionPointIndexes = getFirstLineSegmentIntersectionIndexes(\r\n      targetPolyline,\r\n      sourceP1,\r\n      sourceP2\r\n    );\r\n\r\n    if (intersectionPointIndexes?.length === 2) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport * as mathLine from '../line';\r\n\r\nconst DEFAULT_EPSILON = 0.1;\r\n\r\n/**\r\n * Ramer–Douglas–Peucker algorithm implementation to decimate a polyline\r\n * to a similar polyline with fewer points\r\n *\r\n * https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\r\n * https://rosettacode.org/wiki/Ramer-Douglas-Peucker_line_simplification\r\n * https://karthaus.nl/rdp/\r\n *\r\n * @param polyline - Polyline to decimate\r\n * @param epsilon - A maximum given distance 'epsilon' to decide if a point\r\n * should or shouldn't be added the decimated polyline version. In each\r\n * iteration the polyline is split into two polylines and the distance of each\r\n * point from those new polylines are checked against the line that connects\r\n * the first and last points.\r\n * @returns Decimated polyline\r\n */\r\nexport default function decimate(\r\n  polyline: Types.Point2[],\r\n  epsilon = DEFAULT_EPSILON\r\n) {\r\n  const numPoints = polyline.length;\r\n\r\n  // The polyline must have at least a start and end points\r\n  if (numPoints < 3) {\r\n    return polyline;\r\n  }\r\n\r\n  const epsilonSquared = epsilon * epsilon;\r\n  const partitionQueue = [[0, numPoints - 1]];\r\n\r\n  // Used a boolean array to set each point that will be in the decimated polyline\r\n  // because pre-allocated arrays are 3-4x faster than thousands of push() calls\r\n  // to add all points to a new array.\r\n  const polylinePointFlags = new Array(numPoints).fill(false);\r\n\r\n  // Start and end points are always added to the decimated polyline\r\n  let numDecimatedPoints = 2;\r\n\r\n  // Add start and end points to the decimated polyline\r\n  polylinePointFlags[0] = true;\r\n  polylinePointFlags[numPoints - 1] = true;\r\n\r\n  // Iterative approach using a queue instead of recursion to reduce the number\r\n  // of function calls (performance)\r\n  while (partitionQueue.length) {\r\n    const [startIndex, endIndex] = partitionQueue.pop();\r\n\r\n    // Return if there is no point between the start and end points\r\n    if (endIndex - startIndex === 1) {\r\n      continue;\r\n    }\r\n\r\n    const startPoint = polyline[startIndex];\r\n    const endPoint = polyline[endIndex];\r\n    let maxDistSquared = -Infinity;\r\n    let maxDistIndex = -1;\r\n\r\n    // Search for the furthest point\r\n    for (let i = startIndex + 1; i < endIndex; i++) {\r\n      const currentPoint = polyline[i];\r\n      const distSquared = mathLine.distanceToPointSquared(\r\n        startPoint,\r\n        endPoint,\r\n        currentPoint\r\n      );\r\n\r\n      if (distSquared > maxDistSquared) {\r\n        maxDistSquared = distSquared;\r\n        maxDistIndex = i;\r\n      }\r\n    }\r\n\r\n    // Do not add any of the points because the fursthest one is very close to\r\n    // the line based on the epsilon value\r\n    if (maxDistSquared < epsilonSquared) {\r\n      continue;\r\n    }\r\n\r\n    // Update the flag for the furthest point because it will be added to the\r\n    // decimated polyline\r\n    polylinePointFlags[maxDistIndex] = true;\r\n    numDecimatedPoints++;\r\n\r\n    // Partition the points into two parts using maxDistIndex as the pivot point\r\n    // and process both sides\r\n    partitionQueue.push([maxDistIndex, endIndex]);\r\n    partitionQueue.push([startIndex, maxDistIndex]);\r\n  }\r\n\r\n  // A pre-allocated array is 3-4x faster then multiple push() calls\r\n  const decimatedPolyline: Types.Point2[] = new Array(numDecimatedPoints);\r\n\r\n  for (let srcIndex = 0, dstIndex = 0; srcIndex < numPoints; srcIndex++) {\r\n    if (polylinePointFlags[srcIndex]) {\r\n      decimatedPolyline[dstIndex++] = polyline[srcIndex];\r\n    }\r\n  }\r\n\r\n  return decimatedPolyline;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport getLineSegmentIntersectionsIndexes from './getLineSegmentIntersectionsIndexes';\r\nimport getLinesIntersection from './getLinesIntersection';\r\n\r\n/**\r\n * Returns all intersections points between a line segment and a polyline\r\n */\r\nexport default function getLineSegmentIntersectionsCoordinates(\r\n  points: Types.Point2[],\r\n  p1: Types.Point2,\r\n  q1: Types.Point2,\r\n  closed = true\r\n): Types.Point2[] {\r\n  const result = [];\r\n  const polylineIndexes = getLineSegmentIntersectionsIndexes(\r\n    points,\r\n    p1,\r\n    q1,\r\n    closed\r\n  );\r\n\r\n  for (let i = 0; i < polylineIndexes.length; i++) {\r\n    const p2 = points[polylineIndexes[i][0]];\r\n    const q2 = points[polylineIndexes[i][1]];\r\n    const intersection = getLinesIntersection(p1, q1, p2, q2);\r\n    result.push(intersection);\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { vec2 } from 'gl-matrix';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\r\n\r\n/**\r\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\r\n * `points`, and returns the closest value.\r\n * @param points - Polyline points\r\n * @param p1 - Start point of the line segment\r\n * @param q1 - End point of the line segment\r\n * @param closed - Test the intersection against the line that connects the first to the last when closed\r\n * @returns The closest line segment from polyline that intersects the line segment [p1, q1]\r\n */\r\nexport default function getClosestLineSegmentIntersection(\r\n  points: Types.Point2[],\r\n  p1: Types.Point2,\r\n  q1: Types.Point2,\r\n  closed = true\r\n): { segment: Types.Point2; distance: number } | undefined {\r\n  let initialQ2Index;\r\n  let p2Index;\r\n\r\n  if (closed) {\r\n    p2Index = points.length - 1;\r\n    initialQ2Index = 0;\r\n  } else {\r\n    p2Index = 0;\r\n    initialQ2Index = 1;\r\n  }\r\n\r\n  const intersections = [];\r\n\r\n  for (let q2Index = initialQ2Index; q2Index < points.length; q2Index++) {\r\n    const p2 = points[p2Index];\r\n    const q2 = points[q2Index];\r\n\r\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\r\n      intersections.push([p2Index, q2Index]);\r\n    }\r\n\r\n    p2Index = q2Index;\r\n  }\r\n\r\n  if (intersections.length === 0) {\r\n    return;\r\n  }\r\n\r\n  // Find intersection closest to the start point\r\n  const distances = [];\r\n\r\n  intersections.forEach((intersection) => {\r\n    const intersectionPoints = [\r\n      points[intersection[0]],\r\n      points[intersection[1]],\r\n    ];\r\n\r\n    const midpoint = [\r\n      (intersectionPoints[0][0] + intersectionPoints[1][0]) / 2,\r\n      (intersectionPoints[0][1] + intersectionPoints[1][1]) / 2,\r\n    ];\r\n\r\n    distances.push(vec2.distance(<vec2>midpoint, p1));\r\n  });\r\n\r\n  const minDistance = Math.min(...distances);\r\n  const indexOfMinDistance = distances.indexOf(minDistance);\r\n\r\n  return {\r\n    segment: intersections[indexOfMinDistance],\r\n    distance: minDistance,\r\n  };\r\n}\r\n","import { StackViewport } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport { vec3 } from 'gl-matrix';\r\n\r\nconst EPSILON = 1e-3;\r\n\r\n/**\r\n * Gets the desired spacing for points in the polyline for the\r\n * `PlanarFreehandROITool` in the x and y canvas directions, as well as\r\n * returning these canvas directions in world space.\r\n *\r\n * @param viewport - The Cornerstone3D `StackViewport` or `VolumeViewport`.\r\n * @param subPixelResolution - The number to divide the image pixel spacing by\r\n * to get the sub pixel spacing. E.g. `10` will return spacings 10x smaller than\r\n * the native image spacing.\r\n * @returns The spacings of the X and Y directions, and the 3D directions of the\r\n * x and y directions.\r\n */\r\nconst getSubPixelSpacingAndXYDirections = (\r\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\r\n  subPixelResolution: number\r\n): { spacing: Types.Point2; xDir: Types.Point3; yDir: Types.Point3 } => {\r\n  let spacing;\r\n  let xDir;\r\n  let yDir;\r\n\r\n  if (viewport instanceof StackViewport) {\r\n    // Check XY directions\r\n    const imageData = viewport.getImageData();\r\n\r\n    xDir = imageData.direction.slice(0, 3);\r\n    yDir = imageData.direction.slice(3, 6);\r\n\r\n    spacing = imageData.spacing;\r\n  } else {\r\n    // Check volume directions\r\n    const imageData = viewport.getImageData();\r\n    const { direction, spacing: volumeSpacing } = imageData;\r\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\r\n\r\n    // Calculate size of spacing vector in normal direction\r\n    const iVector = direction.slice(0, 3) as Types.Point3;\r\n    const jVector = direction.slice(3, 6) as Types.Point3;\r\n    const kVector = direction.slice(6, 9) as Types.Point3;\r\n\r\n    const viewRight = vec3.create(); // Get the X direction of the viewport\r\n\r\n    vec3.cross(viewRight, <vec3>viewUp, <vec3>viewPlaneNormal);\r\n\r\n    const absViewRightDotI = Math.abs(vec3.dot(viewRight, iVector));\r\n    const absViewRightDotJ = Math.abs(vec3.dot(viewRight, jVector));\r\n    const absViewRightDotK = Math.abs(vec3.dot(viewRight, kVector));\r\n\r\n    // Get X spacing\r\n    let xSpacing;\r\n    if (Math.abs(1 - absViewRightDotI) < EPSILON) {\r\n      xSpacing = volumeSpacing[0];\r\n      xDir = iVector;\r\n    } else if (Math.abs(1 - absViewRightDotJ) < EPSILON) {\r\n      xSpacing = volumeSpacing[1];\r\n      xDir = jVector;\r\n    } else if (Math.abs(1 - absViewRightDotK) < EPSILON) {\r\n      xSpacing = volumeSpacing[2];\r\n      xDir = kVector;\r\n    } else {\r\n      throw new Error('No support yet for oblique plane planar contours');\r\n    }\r\n\r\n    const absViewUpDotI = Math.abs(vec3.dot(viewUp, iVector));\r\n    const absViewUpDotJ = Math.abs(vec3.dot(viewUp, jVector));\r\n    const absViewUpDotK = Math.abs(vec3.dot(viewUp, kVector));\r\n\r\n    // Get Y spacing\r\n    let ySpacing;\r\n    if (Math.abs(1 - absViewUpDotI) < EPSILON) {\r\n      ySpacing = volumeSpacing[0];\r\n      yDir = iVector;\r\n    } else if (Math.abs(1 - absViewUpDotJ) < EPSILON) {\r\n      ySpacing = volumeSpacing[1];\r\n      yDir = jVector;\r\n    } else if (Math.abs(1 - absViewUpDotK) < EPSILON) {\r\n      ySpacing = volumeSpacing[2];\r\n      yDir = kVector;\r\n    } else {\r\n      throw new Error('No support yet for oblique plane planar contours');\r\n    }\r\n\r\n    spacing = [xSpacing, ySpacing];\r\n  }\r\n\r\n  const subPixelSpacing: Types.Point2 = [\r\n    spacing[0] / subPixelResolution,\r\n    spacing[1] / subPixelResolution,\r\n  ];\r\n\r\n  return { spacing: subPixelSpacing, xDir, yDir };\r\n};\r\n\r\nexport default getSubPixelSpacingAndXYDirections;\r\n","import { vec2 } from 'gl-matrix';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Returns true if points `p1` and `p2` are within `closeContourProximity`.\r\n */\r\nconst pointsAreWithinCloseContourProximity = (\r\n  p1: Types.Point2,\r\n  p2: Types.Point2,\r\n  closeContourProximity: number\r\n): boolean => {\r\n  return vec2.dist(p1, p2) < closeContourProximity;\r\n};\r\n\r\nexport default pointsAreWithinCloseContourProximity;\r\n","import { getEnabledElement } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport { vec2, vec3 } from 'gl-matrix';\r\nimport { PlanarFreehandROICommonData } from './planarFreehandROIInternalTypes';\r\n\r\n/**\r\n * Adds one or more points to the array at a resolution defined by the underlying image.\r\n */\r\nconst addCanvasPointsToArray = (\r\n  element: HTMLDivElement,\r\n  canvasPoints: Types.Point2[],\r\n  newCanvasPoint: Types.Point2,\r\n  commonData: PlanarFreehandROICommonData\r\n): number => {\r\n  const { xDir, yDir, spacing } = commonData;\r\n  const enabledElement = getEnabledElement(element);\r\n  const { viewport } = enabledElement;\r\n\r\n  if (!canvasPoints.length) {\r\n    canvasPoints.push(newCanvasPoint);\r\n    console.log('>>>>> !canvasPoints. :: RETURN');\r\n    return 1;\r\n  }\r\n\r\n  const lastWorldPos = viewport.canvasToWorld(\r\n    canvasPoints[canvasPoints.length - 1]\r\n  );\r\n  const newWorldPos = viewport.canvasToWorld(newCanvasPoint);\r\n  const worldPosDiff = vec3.create();\r\n\r\n  vec3.subtract(worldPosDiff, newWorldPos, lastWorldPos);\r\n\r\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\r\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\r\n\r\n  const numPointsToAdd = Math.max(\r\n    Math.floor(xDist / spacing[0]),\r\n    Math.floor(yDist / spacing[0])\r\n  );\r\n\r\n  if (numPointsToAdd > 1) {\r\n    const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\r\n\r\n    const canvasDist = vec2.dist(lastCanvasPoint, newCanvasPoint);\r\n\r\n    const canvasDir = vec2.create();\r\n\r\n    vec2.subtract(canvasDir, newCanvasPoint, lastCanvasPoint);\r\n\r\n    vec2.set(canvasDir, canvasDir[0] / canvasDist, canvasDir[1] / canvasDist);\r\n\r\n    const distPerPoint = canvasDist / numPointsToAdd;\r\n\r\n    for (let i = 1; i <= numPointsToAdd; i++) {\r\n      canvasPoints.push([\r\n        lastCanvasPoint[0] + distPerPoint * canvasDir[0] * i,\r\n        lastCanvasPoint[1] + distPerPoint * canvasDir[1] * i,\r\n      ]);\r\n    }\r\n  } else {\r\n    canvasPoints.push(newCanvasPoint);\r\n  }\r\n\r\n  return numPointsToAdd;\r\n};\r\n\r\nexport default addCanvasPointsToArray;\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport { vec2 } from 'gl-matrix';\r\n\r\n/**\r\n * Returns `true` if the point `p` can project onto point (`p1`, `p2`), and if\r\n * this projected point is less than `proximity` units away.\r\n */\r\nconst pointCanProjectOnLine = (\r\n  p: Types.Point2,\r\n  p1: Types.Point2,\r\n  p2: Types.Point2,\r\n  proximity: number\r\n): boolean => {\r\n  // Perfom checks in order of computational complexity.\r\n  const p1p = [p[0] - p1[0], p[1] - p1[1]];\r\n  const p1p2 = [p2[0] - p1[0], p2[1] - p1[1]];\r\n\r\n  const dot = p1p[0] * p1p2[0] + p1p[1] * p1p2[1];\r\n\r\n  // Dot product needs to be positive to be a candidate for projection onto line segment.\r\n  if (dot < 0) {\r\n    return false;\r\n  }\r\n\r\n  const p1p2Mag = Math.sqrt(p1p2[0] * p1p2[0] + p1p2[1] * p1p2[1]);\r\n\r\n  if (p1p2Mag === 0) {\r\n    return false;\r\n  }\r\n\r\n  const projectionVectorMag = dot / p1p2Mag;\r\n  const p1p2UnitVector = [p1p2[0] / p1p2Mag, p1p2[1] / p1p2Mag];\r\n  const projectionVector = [\r\n    p1p2UnitVector[0] * projectionVectorMag,\r\n    p1p2UnitVector[1] * projectionVectorMag,\r\n  ];\r\n  const projectionPoint = <Types.Point2>[\r\n    p1[0] + projectionVector[0],\r\n    p1[1] + projectionVector[1],\r\n  ];\r\n\r\n  const distance = vec2.distance(p, projectionPoint);\r\n\r\n  if (distance > proximity) {\r\n    // point is too far away.\r\n    return false;\r\n  }\r\n\r\n  // Check projects onto line segment.\r\n  if (vec2.distance(p1, projectionPoint) > vec2.distance(p1, p2)) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nexport default pointCanProjectOnLine;\r\n","import { utilities } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nconst epsilon = 1e-6;\r\n\r\n/**\r\n * Projects a polyline from 3D to 2D by reducing one dimension.\r\n *\r\n * @param polyline - The polyline to be projected.\r\n * @returns An object containing the shared dimension index and the projected polyline in 2D.\r\n * @throws Error if a shared dimension index cannot be found for the polyline.\r\n */\r\nexport function projectTo2D(polyline: Types.Point3[]) {\r\n  // We need to reduce one dimension to 2D, so basically\r\n  // we need to find the dimension index that is shared by all points\r\n  // Use the first three points, two is enough but three is more robust\r\n  let sharedDimensionIndex;\r\n\r\n  const testPoints = utilities.getRandomSampleFromArray(polyline, 50);\r\n\r\n  for (let i = 0; i < 3; i++) {\r\n    if (\r\n      testPoints.every(\r\n        (point, index, array) => Math.abs(point[i] - array[0][i]) < epsilon\r\n      )\r\n    ) {\r\n      sharedDimensionIndex = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (sharedDimensionIndex === undefined) {\r\n    throw new Error(\r\n      'Cannot find a shared dimension index for polyline, probably oblique plane'\r\n    );\r\n  }\r\n\r\n  // convert polyline list and point to 2D\r\n  const points2D = [] as Types.Point2[];\r\n\r\n  const firstDim = (sharedDimensionIndex + 1) % 3;\r\n  const secondDim = (sharedDimensionIndex + 2) % 3;\r\n\r\n  for (let i = 0; i < polyline.length; i++) {\r\n    points2D.push([polyline[i][firstDim], polyline[i][secondDim]]);\r\n  }\r\n\r\n  return {\r\n    sharedDimensionIndex,\r\n    projectedPolyline: points2D,\r\n  };\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport containsPoint from './containsPoint';\r\nimport { projectTo2D } from './projectTo2D';\r\n\r\n/**\r\n * Determines whether a 3D point is inside a polyline in 3D space.\r\n *\r\n * The algorithm works by reducing the polyline and point to 2D space, and then\r\n * using the 2D algorithm to determine whether the point is inside the polyline.\r\n *\r\n * @param point - The 3D point to test.\r\n * @param polyline - The polyline represented as an array of 3D points.\r\n * @param options.holesPolyline - An array of polylines representing each hole, so it\r\n * is an array of arrays of 3D points.\r\n * @returns A boolean indicating whether the point is inside the polyline.\r\n * @throws An error if a shared dimension index cannot be found for the polyline points.\r\n */\r\nexport function isPointInsidePolyline3D(\r\n  point: Types.Point3,\r\n  polyline: Types.Point3[],\r\n  options: { holes?: Types.Point3[][] } = {}\r\n) {\r\n  const { sharedDimensionIndex, projectedPolyline } = projectTo2D(polyline);\r\n\r\n  const { holes } = options;\r\n  const projectedHoles = [] as Types.Point2[][];\r\n\r\n  if (holes) {\r\n    for (let i = 0; i < holes.length; i++) {\r\n      const hole = holes[i];\r\n      const hole2D = [] as Types.Point2[];\r\n\r\n      for (let j = 0; j < hole.length; j++) {\r\n        hole2D.push([\r\n          hole[j][(sharedDimensionIndex + 1) % 3],\r\n          hole[j][(sharedDimensionIndex + 2) % 3],\r\n        ]);\r\n      }\r\n\r\n      projectedHoles.push(hole2D);\r\n    }\r\n  }\r\n\r\n  const point2D = [\r\n    point[(sharedDimensionIndex + 1) % 3],\r\n    point[(sharedDimensionIndex + 2) % 3],\r\n  ] as Types.Point2;\r\n\r\n  return containsPoint(projectedPolyline, point2D, { holes: projectedHoles });\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport * as lineSegment from '../line';\r\n\r\ntype rectLineSegments = {\r\n  top: Types.Point2[];\r\n  right: Types.Point2[];\r\n  bottom: Types.Point2[];\r\n  left: Types.Point2[];\r\n};\r\n\r\n/**\r\n * Given a rectangle left, top, width and height, return an object containing the\r\n * line segments that make up the rectangle's four sides\r\n * @param left - The x-coordinate of the left edge of the rectangle.\r\n * @param top - The y-coordinate of the top edge of the rectangle.\r\n * @param width - The width of the rectangle.\r\n * @param height - The height of the rectangle.\r\n * @returns An object with four keys, each of which contains an array of two\r\n * points.\r\n */\r\nfunction rectToLineSegments(\r\n  left: number,\r\n  top: number,\r\n  width: number,\r\n  height: number\r\n): rectLineSegments {\r\n  const topLineStart: Types.Point2 = [left, top];\r\n  const topLineEnd: Types.Point2 = [left + width, top];\r\n\r\n  const rightLineStart: Types.Point2 = [left + width, top];\r\n  const rightLineEnd: Types.Point2 = [left + width, top + height];\r\n\r\n  const bottomLineStart: Types.Point2 = [left + width, top + height];\r\n  const bottomLineEnd: Types.Point2 = [left, top + height];\r\n\r\n  const leftLineStart: Types.Point2 = [left, top + height];\r\n  const leftLineEnd: Types.Point2 = [left, top];\r\n\r\n  const lineSegments = {\r\n    top: [topLineStart, topLineEnd],\r\n    right: [rightLineStart, rightLineEnd],\r\n    bottom: [bottomLineStart, bottomLineEnd],\r\n    left: [leftLineStart, leftLineEnd],\r\n  };\r\n\r\n  return lineSegments;\r\n}\r\n\r\n/**\r\n * Calculates distance of the point to the rectangle. It calculates the minimum\r\n * distance between the point and each line segment of the rectangle.\r\n *\r\n * @param rect - coordinates of the rectangle [left, top, width, height]\r\n * @param point - [x,y] coordinates of a point\r\n * @returns\r\n */\r\nexport default function distanceToPoint(\r\n  rect: number[],\r\n  point: Types.Point2\r\n): number {\r\n  if (rect.length !== 4 || point.length !== 2) {\r\n    throw Error(\r\n      'rectangle:[left, top, width, height] or point: [x,y] not defined correctly'\r\n    );\r\n  }\r\n\r\n  const [left, top, width, height] = rect;\r\n\r\n  let minDistance = 655535;\r\n  const lineSegments = rectToLineSegments(left, top, width, height);\r\n\r\n  Object.keys(lineSegments).forEach((segment) => {\r\n    const [lineStart, lineEnd] = lineSegments[segment];\r\n    const distance = lineSegment.distanceToPoint(lineStart, lineEnd, point);\r\n\r\n    if (distance < minDistance) {\r\n      minDistance = distance;\r\n    }\r\n  });\r\n\r\n  return minDistance;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport { vec3 } from 'gl-matrix';\r\n\r\ntype Sphere = {\r\n  center: Types.Point3 | vec3;\r\n  radius: number;\r\n  // Square of the radius\r\n  radius2?: number;\r\n};\r\n\r\n/**\r\n * Checks if a point is inside a sphere. Note: this is similar to the\r\n * `pointInEllipse` function, but since we don't need checks for the\r\n * ellipse's rotation in different views, we can use a simpler equation\r\n * which would be faster (no if statements).\r\n *\r\n * This is safe to call for point in circle as long as you don't call it with\r\n * anything off-plane - that is, a circle is a degenerate sphere that is\r\n * intersected with the primary plane.\r\n *\r\n * @param sphere - Sphere object with center and radius and radius squared\r\n *     as radius2 if you are calling this a huge number of times.\r\n * @param pointLPS - the point to check in world coordinates\r\n * @returns boolean\r\n */\r\nexport default function pointInSphere(sphere: Sphere, pointLPS: vec3): boolean {\r\n  const { center, radius } = sphere;\r\n  const radius2 = sphere.radius2 || radius * radius;\r\n\r\n  return (\r\n    (pointLPS[0] - center[0]) * (pointLPS[0] - center[0]) +\r\n      (pointLPS[1] - center[1]) * (pointLPS[1] - center[1]) +\r\n      (pointLPS[2] - center[2]) * (pointLPS[2] - center[2]) <=\r\n    radius2\r\n  );\r\n}\r\n","// Pulled from source: https://github.com/w8r/liang-barsky\r\n// MIT Licensed.\r\n\r\n/**\r\n * Fast, destructive implementation of Liang-Barsky line clipping algorithm.\r\n * It clips a 2D segment by a rectangle.\r\n * @author Alexander Milevski <info@w8r.name>\r\n * @license MIT\r\n */\r\n\r\nconst EPSILON = 1e-6;\r\nconst INSIDE = 1;\r\nconst OUTSIDE = 0;\r\n\r\nfunction clipT(num, denom, c) {\r\n  const [tE, tL] = c;\r\n  if (Math.abs(denom) < EPSILON) {\r\n    return num < 0;\r\n  }\r\n  const t = num / denom;\r\n\r\n  if (denom > 0) {\r\n    if (t > tL) {\r\n      return 0;\r\n    }\r\n    if (t > tE) {\r\n      c[0] = t;\r\n    }\r\n  } else {\r\n    if (t < tE) {\r\n      return 0;\r\n    }\r\n    if (t < tL) {\r\n      c[1] = t;\r\n    }\r\n  }\r\n  return 1;\r\n}\r\n\r\n/**\r\n * @param  {Point} a\r\n * @param  {Point} b\r\n * @param  {BoundingBox} box [xmin, ymin, xmax, ymax]\r\n * @param  {Point?} [da]\r\n * @param  {Point?} [db]\r\n * @return {number}\r\n */\r\nexport default function clip(a, b, box, da?, db?) {\r\n  const [x1, y1] = a;\r\n  const [x2, y2] = b;\r\n  const dx = x2 - x1;\r\n  const dy = y2 - y1;\r\n\r\n  if (da === undefined || db === undefined) {\r\n    da = a;\r\n    db = b;\r\n  } else {\r\n    da[0] = a[0];\r\n    da[1] = a[1];\r\n    db[0] = b[0];\r\n    db[1] = b[1];\r\n  }\r\n\r\n  if (\r\n    Math.abs(dx) < EPSILON &&\r\n    Math.abs(dy) < EPSILON &&\r\n    x1 >= box[0] &&\r\n    x1 <= box[2] &&\r\n    y1 >= box[1] &&\r\n    y1 <= box[3]\r\n  ) {\r\n    return INSIDE;\r\n  }\r\n\r\n  const c = [0, 1];\r\n  if (\r\n    clipT(box[0] - x1, dx, c) &&\r\n    clipT(x1 - box[2], -dx, c) &&\r\n    clipT(box[1] - y1, dy, c) &&\r\n    clipT(y1 - box[3], -dy, c)\r\n  ) {\r\n    const [tE, tL] = c;\r\n    if (tL < 1) {\r\n      db[0] = x1 + tL * dx;\r\n      db[1] = y1 + tL * dy;\r\n    }\r\n    if (tE > 0) {\r\n      da[0] += tE * dx;\r\n      da[1] += tE * dy;\r\n    }\r\n    return INSIDE;\r\n  }\r\n  return OUTSIDE;\r\n}\r\n","import { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Returns the orientation of the vector in the patient coordinate system.\r\n * @public\r\n *\r\n * @param vector - Input array\r\n * @returns The orientation in the patient coordinate system.\r\n */\r\nexport default function getOrientationStringLPS(vector: Types.Point3): string {\r\n  // Thanks to David Clunie\r\n  // https://sites.google.com/site/dicomnotes/\r\n\r\n  let orientation = '';\r\n  const orientationX = vector[0] < 0 ? 'R' : 'L';\r\n  const orientationY = vector[1] < 0 ? 'A' : 'P';\r\n  const orientationZ = vector[2] < 0 ? 'F' : 'H';\r\n\r\n  // Should probably make this a function vector3.abs\r\n  const abs = [Math.abs(vector[0]), Math.abs(vector[1]), Math.abs(vector[2])];\r\n\r\n  const MIN = 0.0001;\r\n\r\n  for (let i = 0; i < 3; i++) {\r\n    if (abs[0] > MIN && abs[0] > abs[1] && abs[0] > abs[2]) {\r\n      orientation += orientationX;\r\n      abs[0] = 0;\r\n    } else if (abs[1] > MIN && abs[1] > abs[0] && abs[1] > abs[2]) {\r\n      orientation += orientationY;\r\n      abs[1] = 0;\r\n    } else if (abs[2] > MIN && abs[2] > abs[0] && abs[2] > abs[1]) {\r\n      orientation += orientationZ;\r\n      abs[2] = 0;\r\n    } else if (abs[0] > MIN && abs[1] > MIN && abs[0] === abs[1]) {\r\n      orientation += orientationX + orientationY;\r\n      abs[0] = 0;\r\n      abs[1] = 0;\r\n    } else if (abs[0] > MIN && abs[2] > MIN && abs[0] === abs[2]) {\r\n      orientation += orientationX + orientationZ;\r\n      abs[0] = 0;\r\n      abs[2] = 0;\r\n    } else if (abs[1] > MIN && abs[2] > MIN && abs[1] === abs[2]) {\r\n      orientation += orientationY + orientationZ;\r\n      abs[1] = 0;\r\n      abs[2] = 0;\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n\r\n  return orientation;\r\n}\r\n","/**\r\n * Inverts an orientation string.\r\n * @public\r\n *\r\n * @param orientationString - The orientation.\r\n * @returns The inverted orientationString.\r\n */\r\nexport default function invertOrientationStringLPS(\r\n  orientationString: string\r\n): string {\r\n  let inverted = orientationString.replace('H', 'f');\r\n\r\n  inverted = inverted.replace('F', 'h');\r\n  inverted = inverted.replace('R', 'l');\r\n  inverted = inverted.replace('L', 'r');\r\n  inverted = inverted.replace('A', 'p');\r\n  inverted = inverted.replace('P', 'a');\r\n  inverted = inverted.toUpperCase();\r\n\r\n  return inverted;\r\n}\r\n","import smoothAnnotation from './smoothAnnotation';\r\n\r\nexport default {\r\n  smoothAnnotation,\r\n};\r\n\r\nexport { smoothAnnotation };\r\n","import filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\r\nimport getWorldWidthAndHeightFromCorners from './getWorldWidthAndHeightFromCorners';\r\nimport filterAnnotationsForDisplay from './filterAnnotationsForDisplay';\r\nimport getPointInLineOfSightWithCriteria from './getPointInLineOfSightWithCriteria';\r\nimport { isPlaneIntersectingAABB } from './isPlaneIntersectingAABB';\r\n\r\nexport default {\r\n  filterAnnotationsWithinSlice,\r\n  getWorldWidthAndHeightFromCorners,\r\n  filterAnnotationsForDisplay,\r\n  getPointInLineOfSightWithCriteria,\r\n  isPlaneIntersectingAABB,\r\n};\r\n\r\nexport {\r\n  filterAnnotationsWithinSlice,\r\n  getWorldWidthAndHeightFromCorners,\r\n  filterAnnotationsForDisplay,\r\n  getPointInLineOfSightWithCriteria,\r\n  isPlaneIntersectingAABB,\r\n};\r\n","import { vec3 } from 'gl-matrix';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\r\nimport BoundsIJK from '../types/BoundsIJK';\r\n\r\nexport type PointInShape = {\r\n  value: number;\r\n  index: number;\r\n  pointIJK: vec3;\r\n  pointLPS: vec3 | number[];\r\n};\r\n\r\nexport type PointInShapeCallback = ({\r\n  value,\r\n  index,\r\n  pointIJK,\r\n  pointLPS,\r\n}: {\r\n  value: number;\r\n  index: number;\r\n  pointIJK: vec3;\r\n  pointLPS: vec3;\r\n}) => void;\r\n\r\nexport type ShapeFnCriteria = (pointLPS: vec3, pointIJK: vec3) => boolean;\r\n\r\n/**\r\n * For each point in the image (If boundsIJK is not provided, otherwise, for each\r\n * point in the provided bounding box), It runs the provided callback IF the point\r\n * passes the provided criteria to be inside the shape (which is defined by the\r\n * provided pointInShapeFn)\r\n *\r\n * @param imageData - The image data object.\r\n * @param dimensions - The dimensions of the image.\r\n * @param pointInShapeFn - A function that takes a point in LPS space and returns\r\n * true if the point is in the shape and false if it is not.\r\n * @param callback - A function that will be called for\r\n * every point in the shape.\r\n * @param boundsIJK - The bounds of the volume in IJK coordinates.\r\n */\r\nexport default function pointInShapeCallback(\r\n  imageData: vtkImageData | Types.CPUImageData,\r\n  pointInShapeFn: ShapeFnCriteria,\r\n  callback?: PointInShapeCallback,\r\n  boundsIJK?: BoundsIJK\r\n): Array<PointInShape> {\r\n  let iMin, iMax, jMin, jMax, kMin, kMax;\r\n\r\n  let scalarData;\r\n  const { numComps } = imageData as any;\r\n\r\n  // if getScalarData is a method on imageData\r\n  if ((imageData as Types.CPUImageData).getScalarData) {\r\n    scalarData = (imageData as Types.CPUImageData).getScalarData();\r\n  } else {\r\n    scalarData = (imageData as vtkImageData)\r\n      .getPointData()\r\n      .getScalars()\r\n      .getData();\r\n  }\r\n\r\n  if (!scalarData) {\r\n    console.warn('No scalar data found for imageData', imageData);\r\n    return;\r\n  }\r\n\r\n  const dimensions = imageData.getDimensions();\r\n\r\n  if (!boundsIJK) {\r\n    iMin = 0;\r\n    iMax = dimensions[0];\r\n    jMin = 0;\r\n    jMax = dimensions[1];\r\n    kMin = 0;\r\n    kMax = dimensions[2];\r\n  } else {\r\n    [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = boundsIJK;\r\n  }\r\n\r\n  const start = vec3.fromValues(iMin, jMin, kMin);\r\n\r\n  const direction = imageData.getDirection();\r\n  const rowCosines = direction.slice(0, 3);\r\n  const columnCosines = direction.slice(3, 6);\r\n  const scanAxisNormal = direction.slice(6, 9);\r\n\r\n  const spacing = imageData.getSpacing();\r\n  const [rowSpacing, columnSpacing, scanAxisSpacing] = spacing;\r\n\r\n  // @ts-ignore will be fixed in vtk-master\r\n  const worldPosStart = imageData.indexToWorld(start);\r\n\r\n  const rowStep = vec3.fromValues(\r\n    rowCosines[0] * rowSpacing,\r\n    rowCosines[1] * rowSpacing,\r\n    rowCosines[2] * rowSpacing\r\n  );\r\n\r\n  const columnStep = vec3.fromValues(\r\n    columnCosines[0] * columnSpacing,\r\n    columnCosines[1] * columnSpacing,\r\n    columnCosines[2] * columnSpacing\r\n  );\r\n\r\n  const scanAxisStep = vec3.fromValues(\r\n    scanAxisNormal[0] * scanAxisSpacing,\r\n    scanAxisNormal[1] * scanAxisSpacing,\r\n    scanAxisNormal[2] * scanAxisSpacing\r\n  );\r\n\r\n  const xMultiple =\r\n    numComps ||\r\n    scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];\r\n  const yMultiple = dimensions[0] * xMultiple;\r\n  const zMultiple = dimensions[1] * yMultiple;\r\n\r\n  const pointsInShape: Array<PointInShape> = [];\r\n\r\n  const currentPos = vec3.clone(worldPosStart);\r\n\r\n  for (let k = kMin; k <= kMax; k++) {\r\n    const startPosJ = vec3.clone(currentPos);\r\n\r\n    for (let j = jMin; j <= jMax; j++) {\r\n      const startPosI = vec3.clone(currentPos);\r\n\r\n      for (let i = iMin; i <= iMax; i++) {\r\n        const pointIJK: Types.Point3 = [i, j, k];\r\n\r\n        // The current world position (pointLPS) is now in currentPos\r\n        if (pointInShapeFn(currentPos as Types.Point3, pointIJK)) {\r\n          const index = k * zMultiple + j * yMultiple + i * xMultiple;\r\n          let value;\r\n          if (xMultiple > 2) {\r\n            value = [\r\n              scalarData[index],\r\n              scalarData[index + 1],\r\n              scalarData[index + 2],\r\n            ];\r\n          } else {\r\n            value = scalarData[index];\r\n          }\r\n\r\n          pointsInShape.push({\r\n            value,\r\n            index,\r\n            pointIJK,\r\n            pointLPS: currentPos.slice(),\r\n          });\r\n          if (callback) {\r\n            callback({ value, index, pointIJK, pointLPS: currentPos });\r\n          }\r\n        }\r\n\r\n        // Increment currentPos by rowStep for the next iteration\r\n        vec3.add(currentPos, currentPos, rowStep);\r\n      }\r\n\r\n      // Reset currentPos to the start of the next J line and increment by columnStep\r\n      vec3.copy(currentPos, startPosI);\r\n      vec3.add(currentPos, currentPos, columnStep);\r\n    }\r\n\r\n    // Reset currentPos to the start of the next K slice and increment by scanAxisStep\r\n    vec3.copy(currentPos, startPosJ);\r\n    vec3.add(currentPos, currentPos, scanAxisStep);\r\n  }\r\n\r\n  return pointsInShape;\r\n}\r\n","import { utilities as csUtils } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\r\nimport { vec3 } from 'gl-matrix';\r\nimport { pointInSphere } from './math/sphere';\r\nimport pointInShapeCallback, {\r\n  PointInShapeCallback,\r\n} from './pointInShapeCallback';\r\nimport { BoundsIJK } from '../types';\r\nimport { getBoundingBoxAroundShape } from './boundingBox';\r\n\r\nconst { transformWorldToIndex } = csUtils;\r\n\r\n/**\r\n * Given an imageData, and the great circle top and bottom points of a sphere,\r\n * this function will run the callback for each point of the imageData that is\r\n * within the sphere defined by the great circle points. If the viewport\r\n * is provided, region of interest will be an accurate approximation of the\r\n * sphere (using viewport camera), and the resulting performance will be\r\n * better.\r\n *\r\n * @privateRemarks great circle also known as orthodrome is the intersection of\r\n * the sphere and the plane that passes through the center of the sphere\r\n *\r\n * @param imageData - The volume imageData\r\n * @param circlePoints - bottom and top points of the great circle in world coordinates\r\n * @param callback - A callback function that will be called for each point in the shape.\r\n */\r\nexport default function pointInSurroundingSphereCallback(\r\n  imageData: vtkImageData,\r\n  circlePoints: [Types.Point3, Types.Point3],\r\n  callback: PointInShapeCallback,\r\n  viewport?: Types.IVolumeViewport\r\n): void {\r\n  // We can run the sphere equation to determine if a point is inside\r\n  // the sphere; however, since the imageData dimensions can be quite large, we\r\n  // can narrow down the search by estimating the bounds of the sphere in index\r\n  // space.\r\n  const { boundsIJK, centerWorld, radiusWorld } = _getBounds(\r\n    circlePoints,\r\n    imageData,\r\n    viewport\r\n  );\r\n\r\n  const sphereObj = {\r\n    center: centerWorld,\r\n    radius: radiusWorld,\r\n  };\r\n\r\n  pointInShapeCallback(\r\n    imageData,\r\n    (pointLPS) => pointInSphere(sphereObj, pointLPS),\r\n    callback,\r\n    boundsIJK\r\n  );\r\n}\r\n\r\nfunction _getBounds(\r\n  circlePoints: [Types.Point3, Types.Point3],\r\n  imageData: vtkImageData,\r\n  viewport\r\n): {\r\n  boundsIJK: BoundsIJK;\r\n  centerWorld: Types.Point3;\r\n  radiusWorld: number;\r\n} {\r\n  const [bottom, top] = circlePoints;\r\n\r\n  // Sphere center in world\r\n  const centerWorld = vec3.fromValues(\r\n    (bottom[0] + top[0]) / 2,\r\n    (bottom[1] + top[1]) / 2,\r\n    (bottom[2] + top[2]) / 2\r\n  );\r\n\r\n  // sphere radius in world\r\n  const radiusWorld = vec3.distance(bottom, top) / 2;\r\n\r\n  let boundsIJK;\r\n\r\n  if (!viewport) {\r\n    // If no viewport is provide (no camera), we can estimate the bounding box\r\n    // of the sphere in index space.\r\n    // This is done by calculating the maximum value for radius in the index\r\n    // space (since the radius is in world space, we need to convert it to index, and\r\n    // each dimensions can have a different scale factor). Therefore, by finding\r\n    // the minimum spacing value in the imageData, we can calculate the maximum\r\n    // radius in index space and use that to calculate the bounds of the sphere\r\n    // This will not be accurate, but it is a good first approximation.\r\n    // sphere center in index\r\n    const centerIJK = transformWorldToIndex(\r\n      imageData,\r\n      centerWorld as Types.Point3\r\n    );\r\n\r\n    const spacings = imageData.getSpacing();\r\n    const minSpacing = Math.min(...spacings);\r\n\r\n    const maxRadiusIJK = Math.ceil(radiusWorld / minSpacing);\r\n\r\n    boundsIJK = [\r\n      [centerIJK[0] - maxRadiusIJK, centerIJK[0] + maxRadiusIJK],\r\n      [centerIJK[1] - maxRadiusIJK, centerIJK[1] + maxRadiusIJK],\r\n      [centerIJK[2] - maxRadiusIJK, centerIJK[2] + maxRadiusIJK],\r\n    ];\r\n\r\n    return {\r\n      boundsIJK,\r\n      centerWorld: centerWorld as Types.Point3,\r\n      radiusWorld,\r\n    };\r\n  }\r\n\r\n  boundsIJK = _computeBoundsIJKWithCamera(\r\n    imageData,\r\n    viewport,\r\n    circlePoints,\r\n    centerWorld,\r\n    radiusWorld\r\n  );\r\n\r\n  return {\r\n    boundsIJK,\r\n    centerWorld: centerWorld as Types.Point3,\r\n    radiusWorld,\r\n  };\r\n}\r\n\r\nfunction _computeBoundsIJKWithCamera(\r\n  imageData,\r\n  viewport,\r\n  circlePoints,\r\n  centerWorld,\r\n  radiusWorld\r\n) {\r\n  const [bottom, top] = circlePoints;\r\n\r\n  const dimensions = imageData.getDimensions() as Types.Point3;\r\n  const camera = viewport.getCamera();\r\n\r\n  // Calculate viewRight from the camera, this will get used in order to\r\n  // calculate circles topLeft and bottomRight on different planes of intersection\r\n  // between sphere and viewPlane\r\n  const viewUp = vec3.fromValues(\r\n    camera.viewUp[0],\r\n    camera.viewUp[1],\r\n    camera.viewUp[2]\r\n  );\r\n  const viewPlaneNormal = vec3.fromValues(\r\n    camera.viewPlaneNormal[0],\r\n    camera.viewPlaneNormal[1],\r\n    camera.viewPlaneNormal[2]\r\n  );\r\n  const viewRight = vec3.create();\r\n\r\n  vec3.cross(viewRight, viewUp, viewPlaneNormal);\r\n\r\n  // we need to find the bounding box of the sphere in the image, e.g., the\r\n  // topLeftWorld and bottomRightWorld points of the bounding box.\r\n  // We go from the sphereCenter in the normal direction of amount radius, and\r\n  // we go left to find the topLeftWorld point of the bounding box. Next we go\r\n  // in the opposite direction and go right to find the bottomRightWorld point\r\n  // of the bounding box.\r\n  const topLeftWorld = vec3.create();\r\n  const bottomRightWorld = vec3.create();\r\n\r\n  vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\r\n  vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\r\n\r\n  // go in the direction of viewRight with the value of radius\r\n  vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\r\n  vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\r\n\r\n  // convert the world coordinates to index coordinates\r\n\r\n  const sphereCornersIJK = [\r\n    <Types.Point3>transformWorldToIndex(imageData, <Types.Point3>topLeftWorld),\r\n    <Types.Point3>(\r\n      transformWorldToIndex(imageData, <Types.Point3>bottomRightWorld)\r\n    ),\r\n  ];\r\n\r\n  // get the bounding box of the sphere in the image\r\n  const boundsIJK = getBoundingBoxAroundShape(sphereCornersIJK, dimensions);\r\n\r\n  return boundsIJK;\r\n}\r\n","export function pointToString(point, decimals = 5) {\r\n  return (\r\n    parseFloat(point[0]).toFixed(decimals) +\r\n    ',' +\r\n    parseFloat(point[1]).toFixed(decimals) +\r\n    ',' +\r\n    parseFloat(point[2]).toFixed(decimals) +\r\n    ','\r\n  );\r\n}\r\n","import vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport { vec3 } from 'gl-matrix';\r\n\r\n/**\r\n * Gets a point from an array of numbers given its index\r\n * @param points - array of number, each point defined by three consecutive numbers\r\n * @param idx - index of the point to retrieve\r\n * @returns\r\n */\r\nexport function getPoint(points, idx): Types.Point3 {\r\n  const idx3 = idx * 3;\r\n  if (idx3 < points.length) {\r\n    return vec3.fromValues(\r\n      points[idx3],\r\n      points[idx3 + 1],\r\n      points[idx3 + 2]\r\n    ) as Types.Point3;\r\n  }\r\n}\r\n\r\n/**\r\n * Extract contour point sets from the outline of a poly data actor\r\n * @param polyData - vtk polyData\r\n * @returns\r\n */\r\nexport function getPolyDataPointIndexes(polyData: vtkPolyData) {\r\n  const linesData = polyData.getLines().getData();\r\n  let idx = 0;\r\n  const lineSegments = new Map<number, number[]>();\r\n\r\n  // Populate lineSegments map\r\n  while (idx < linesData.length) {\r\n    const segmentSize = linesData[idx++];\r\n    const segment = [];\r\n    for (let i = 0; i < segmentSize; i++) {\r\n      segment.push(linesData[idx + i]);\r\n    }\r\n    lineSegments.set(segment[0], segment);\r\n    idx += segmentSize;\r\n  }\r\n\r\n  const contours = [];\r\n\r\n  // Function to find an available starting point\r\n  const findStartingPoint = (map) => {\r\n    for (const [key, value] of map.entries()) {\r\n      if (value !== undefined) {\r\n        return key;\r\n      }\r\n    }\r\n    return -1;\r\n  };\r\n\r\n  // Build contours\r\n  let startPoint = findStartingPoint(lineSegments);\r\n  while (startPoint !== -1) {\r\n    const contour = [startPoint];\r\n    while (lineSegments.has(startPoint)) {\r\n      const nextPoint = lineSegments.get(startPoint)[1];\r\n      if (lineSegments.has(nextPoint)) {\r\n        contour.push(nextPoint);\r\n      }\r\n      lineSegments.delete(startPoint);\r\n      startPoint = nextPoint;\r\n    }\r\n    contours.push(contour);\r\n    startPoint = findStartingPoint(lineSegments);\r\n  }\r\n\r\n  return contours.length ? contours : undefined;\r\n}\r\n\r\n/**\r\n * Extract contour points from a poly data object\r\n * @param polyData - vtk polyData\r\n * @returns\r\n */\r\nexport function getPolyDataPoints(polyData: vtkPolyData) {\r\n  const contoursIndexes = getPolyDataPointIndexes(polyData);\r\n  if (!contoursIndexes) {\r\n    return;\r\n  }\r\n\r\n  const rawPointsData = polyData.getPoints().getData();\r\n  return contoursIndexes.map((contourIndexes) =>\r\n    contourIndexes.map((index) => getPoint(rawPointsData, index))\r\n  );\r\n}\r\n","import { utilities as csUtils } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\r\nimport extend2DBoundingBoxInViewAxis from '../boundingBox/extend2DBoundingBoxInViewAxis';\r\n\r\ntype Options = {\r\n  numSlicesToProject?: number;\r\n};\r\n\r\nfunction getBoundsIJKFromRectangleAnnotations(\r\n  annotations,\r\n  referenceVolume,\r\n  options = {} as Options\r\n) {\r\n  const AllBoundsIJK = [];\r\n  annotations.forEach((annotation) => {\r\n    const { data } = annotation;\r\n    const { points } = data.handles;\r\n\r\n    const { imageData, dimensions } = referenceVolume;\r\n\r\n    let pointsToUse = points;\r\n    // If the tool is a 2D tool but has projection points, use them\r\n    if (data.cachedStats?.projectionPoints) {\r\n      const { projectionPoints } = data.cachedStats;\r\n      pointsToUse = [].concat(...projectionPoints); // cannot use flat() because of typescript compiler right now\r\n    }\r\n\r\n    const rectangleCornersIJK = pointsToUse.map(\r\n      (world) => csUtils.transformWorldToIndex(imageData, world) as Types.Point3\r\n    );\r\n    let boundsIJK = getBoundingBoxAroundShapeIJK(\r\n      rectangleCornersIJK,\r\n      dimensions\r\n    );\r\n\r\n    // If the tool is 2D but it is configured to project to X amount of slices\r\n    // Don't project the slices if projectionPoints have been used to define the extents\r\n    if (options.numSlicesToProject && !data.cachedStats?.projectionPoints) {\r\n      boundsIJK = extend2DBoundingBoxInViewAxis(\r\n        boundsIJK,\r\n        options.numSlicesToProject\r\n      );\r\n    }\r\n\r\n    AllBoundsIJK.push(boundsIJK);\r\n  });\r\n\r\n  if (AllBoundsIJK.length === 1) {\r\n    return AllBoundsIJK[0];\r\n  }\r\n\r\n  // Get the intersection of all the bounding boxes\r\n  // This is the bounding box that contains all the ROIs\r\n  const boundsIJK = AllBoundsIJK.reduce(\r\n    (accumulator, currentValue) => {\r\n      return {\r\n        iMin: Math.min(accumulator.iMin, currentValue.iMin),\r\n        jMin: Math.min(accumulator.jMin, currentValue.jMin),\r\n        kMin: Math.min(accumulator.kMin, currentValue.kMin),\r\n        iMax: Math.max(accumulator.iMax, currentValue.iMax),\r\n        jMax: Math.max(accumulator.jMax, currentValue.jMax),\r\n        kMax: Math.max(accumulator.kMax, currentValue.kMax),\r\n      };\r\n    },\r\n    {\r\n      iMin: Infinity,\r\n      jMin: Infinity,\r\n      kMin: Infinity,\r\n      iMax: -Infinity,\r\n      jMax: -Infinity,\r\n      kMax: -Infinity,\r\n    }\r\n  );\r\n\r\n  return boundsIJK;\r\n}\r\n\r\nexport default getBoundsIJKFromRectangleAnnotations;\r\n","import { vec3 } from 'gl-matrix';\r\nimport { utilities as csUtils } from '@cornerstonejs/core';\r\n\r\nconst { isEqual } = csUtils;\r\n\r\nconst iAxis = vec3.fromValues(1, 0, 0);\r\nconst jAxis = vec3.fromValues(0, 1, 0);\r\nconst kAxis = vec3.fromValues(0, 0, 1);\r\n\r\nconst axisList = [iAxis, jAxis, kAxis];\r\n\r\n/**\r\n * Determines whether a given rectangle in a 3D space (defined by its corner\r\n * points in IJK coordinates) is aligned with the IJK axes.\r\n * @param rectangleCornersIJK - The corner points of the rectangle in IJK coordinates\r\n * @returns True if the rectangle is aligned with the IJK axes, false otherwise\r\n */\r\nfunction isAxisAlignedRectangle(rectangleCornersIJK) {\r\n  const rectangleVec1 = vec3.subtract(\r\n    vec3.create(),\r\n    rectangleCornersIJK[0],\r\n    rectangleCornersIJK[1]\r\n  );\r\n\r\n  const rectangleVec2 = vec3.subtract(\r\n    vec3.create(),\r\n    rectangleCornersIJK[0],\r\n    rectangleCornersIJK[2]\r\n  );\r\n\r\n  // Calculate the angles with IJK axes for both vectors\r\n  const anglesVec1 = calculateAnglesWithAxes(rectangleVec1, axisList);\r\n  const anglesVec2 = calculateAnglesWithAxes(rectangleVec2, axisList);\r\n\r\n  // Check if all angles are aligned (0, 90, 180, or 270 degrees)\r\n  // we could do csUtils.isEqual(angle % 90, 0) but this is more explicit for reading\r\n  const isAligned = [...anglesVec1, ...anglesVec2].every(\r\n    (angle) =>\r\n      isEqual(angle, 0) ||\r\n      isEqual(angle, 90) ||\r\n      isEqual(angle, 180) ||\r\n      isEqual(angle, 270)\r\n  );\r\n\r\n  return isAligned;\r\n}\r\n\r\n// Function to calculate angle with IJK axes\r\nfunction calculateAnglesWithAxes(vec, axes) {\r\n  return axes.map((axis) => (vec3.angle(vec, axis) * 180) / Math.PI);\r\n}\r\n\r\nexport { isAxisAlignedRectangle };\r\n","import {\r\n  StackViewport,\r\n  Types,\r\n  VolumeViewport,\r\n  eventTarget,\r\n  EVENTS,\r\n  utilities as csUtils,\r\n  getEnabledElement,\r\n} from '@cornerstonejs/core';\r\nimport { ScrollOptions, EventTypes } from '../types';\r\n\r\n/**\r\n * It scrolls one slice in the Stack or Volume Viewport, it uses the options provided\r\n * to determine the slice to scroll to. For Stack Viewport, it scrolls in the 1 or -1\r\n * direction, for Volume Viewport, it uses the camera and focal point to determine the\r\n * slice to scroll to based on the spacings.\r\n * @param viewport - The viewport in which to scroll\r\n * @param options - Options to use for scrolling, including direction, invert, and volumeId\r\n * @returns\r\n */\r\nexport default function scroll(\r\n  viewport: Types.IViewport,\r\n  options: ScrollOptions\r\n): void {\r\n  // check if viewport is disabled then throw error\r\n  const enabledElement = getEnabledElement(viewport.element);\r\n\r\n  if (!enabledElement) {\r\n    throw new Error('Scroll::Viewport is not enabled (it might be disabled)');\r\n  }\r\n\r\n  if (\r\n    viewport instanceof StackViewport &&\r\n    viewport.getImageIds().length === 0\r\n  ) {\r\n    throw new Error('Scroll::Stack Viewport has no images');\r\n  }\r\n\r\n  const { volumeId, delta, scrollSlabs } = options;\r\n\r\n  if (viewport instanceof VolumeViewport) {\r\n    scrollVolume(viewport, volumeId, delta, scrollSlabs);\r\n  } else {\r\n    (viewport as Types.IStackViewport).scroll(\r\n      delta,\r\n      options.debounceLoading,\r\n      options.loop\r\n    );\r\n  }\r\n}\r\n\r\nexport function scrollVolume(\r\n  viewport: VolumeViewport,\r\n  volumeId: string,\r\n  delta: number,\r\n  scrollSlabs = false\r\n) {\r\n  const useSlabThickness = scrollSlabs;\r\n\r\n  const { numScrollSteps, currentStepIndex, sliceRangeInfo } =\r\n    csUtils.getVolumeViewportScrollInfo(viewport, volumeId, useSlabThickness);\r\n\r\n  if (!sliceRangeInfo) {\r\n    return;\r\n  }\r\n\r\n  const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;\r\n  const { focalPoint, viewPlaneNormal, position } = camera;\r\n\r\n  const { newFocalPoint, newPosition } = csUtils.snapFocalPointToSlice(\r\n    focalPoint,\r\n    position,\r\n    sliceRange,\r\n    viewPlaneNormal,\r\n    spacingInNormalDirection,\r\n    delta\r\n  );\r\n\r\n  viewport.setCamera({\r\n    focalPoint: newFocalPoint,\r\n    position: newPosition,\r\n  });\r\n  viewport.render();\r\n\r\n  const desiredStepIndex = currentStepIndex + delta;\r\n\r\n  const VolumeScrollEventDetail: EventTypes.VolumeScrollOutOfBoundsEventDetail =\r\n    {\r\n      volumeId,\r\n      viewport,\r\n      delta,\r\n      desiredStepIndex,\r\n      currentStepIndex,\r\n      numScrollSteps,\r\n      currentImageId: viewport.getCurrentImageId(),\r\n    };\r\n\r\n  if (\r\n    (desiredStepIndex > numScrollSteps || desiredStepIndex < 0) &&\r\n    viewport.getCurrentImageId() // Check that we are in the plane of acquistion\r\n  ) {\r\n    // One common use case of this trigger might be to load the next\r\n    // volume in a time series or the next segment of a partially loaded volume.\r\n\r\n    csUtils.triggerEvent(\r\n      eventTarget,\r\n      EVENTS.VOLUME_SCROLL_OUT_OF_BOUNDS,\r\n      VolumeScrollEventDetail\r\n    );\r\n  } else {\r\n    csUtils.triggerEvent(\r\n      eventTarget,\r\n      EVENTS.VOLUME_VIEWPORT_SCROLL,\r\n      VolumeScrollEventDetail\r\n    );\r\n  }\r\n}\r\n","import { utilities as csUtils } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport {\r\n  AnnotationCompletedEventType,\r\n  AnnotationModifiedEventType,\r\n  AnnotationRemovedEventType,\r\n} from '../../../types/EventTypes';\r\nimport { state as annotationState } from '../../../stateManagement/annotation';\r\nimport type AnnotationGroupSelector from '../../../types/AnnotationGroupSelector';\r\nimport getInterpolationDataCollection from '../../contours/interpolation/getInterpolationDataCollection';\r\nimport type {\r\n  InterpolationViewportData,\r\n  AcceptInterpolationSelector,\r\n} from '../../../types/InterpolationTypes';\r\nimport interpolate from '../../contours/interpolation/interpolate';\r\nimport deleteRelatedAnnotations from './deleteRelatedAnnotations';\r\nimport { InterpolationROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\r\nimport ChangeTypes from '../../../enums/ChangeTypes';\r\nimport getViewportForAnnotation from '../../getViewportForAnnotation';\r\nimport { addContourSegmentationAnnotation } from '../../contourSegmentation/addContourSegmentationAnnotation';\r\n\r\nconst { uuidv4 } = csUtils;\r\n\r\nconst ChangeTypesForInterpolation = [\r\n  ChangeTypes.HandlesUpdated,\r\n  ChangeTypes.InterpolationUpdated,\r\n];\r\n\r\nexport default class InterpolationManager {\r\n  static toolNames = [];\r\n\r\n  static addTool(toolName: string) {\r\n    if (!this.toolNames.includes(toolName)) {\r\n      this.toolNames.push(toolName);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Accepts the autogenerated interpolations, marking them as non-autogenerated.\r\n   * Can provide a selector to choose which ones to accept.\r\n   *\r\n   * Rules for which items to select:\r\n   * 1. Only choose annotations having the same segment index and segmentationID\r\n   * 2. Exclude all contours having the same interpolation UID as any other contours\r\n   *    on the same slice.\r\n   * 3. Exclude autogenerated annotations\r\n   * 4. Exclude any reset interpolationUIDs (this is a manual operation to allow\r\n   *    creating a new interpolation)\r\n   * 5. Find the set of interpolationUID's remaining\r\n   *    a. If the set is of size 0, assign a new interpolationUID\r\n   *    b. If the set is of size 1, assign that interpolationUID\r\n   *    c. Otherwise (optional, otherwise do b for size>1 randomly),\r\n   *       for every remaining annotation, find the one whose center\r\n   *       point is closest to the center point of the new annotation.\r\n   *       Choose that interpolationUID\r\n   *\r\n   * To allow creating new interpolated groups, the idea is to just use a new\r\n   * segment index, then have an operation to update the segment index of an\r\n   * interpolation set.  That way the user can easily draw/see the difference,\r\n   * and then merge them as required.\r\n   * However, the base rules allow creating two contours on a single image to\r\n   * create a separate set.\r\n   */\r\n  static acceptAutoGenerated(\r\n    annotationGroupSelector: AnnotationGroupSelector,\r\n    selector: AcceptInterpolationSelector = {}\r\n  ) {\r\n    const { toolNames, segmentationId, segmentIndex, sliceIndex } = selector;\r\n    for (const toolName of toolNames || InterpolationManager.toolNames) {\r\n      const annotations = annotationState.getAnnotations(\r\n        toolName,\r\n        annotationGroupSelector\r\n      ) as InterpolationROIAnnotation[];\r\n      if (!annotations?.length) {\r\n        continue;\r\n      }\r\n      for (const annotation of annotations) {\r\n        const { interpolationUID, data, autoGenerated, metadata } = annotation;\r\n        if (interpolationUID) {\r\n          annotation.interpolationCompleted = true;\r\n        }\r\n        if (!autoGenerated) {\r\n          continue;\r\n        }\r\n        if (segmentIndex && segmentIndex !== data.segmentation.segmentIndex) {\r\n          continue;\r\n        }\r\n        if (\r\n          sliceIndex !== undefined &&\r\n          metadata &&\r\n          sliceIndex !== metadata.sliceIndex\r\n        ) {\r\n          continue;\r\n        }\r\n        if (\r\n          segmentationId &&\r\n          segmentationId !== data.segmentation.segmentationId\r\n        ) {\r\n          continue;\r\n        }\r\n        addContourSegmentationAnnotation(annotation);\r\n        annotation.autoGenerated = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * When an annotation is completed, if the configuration includes interpolation,\r\n   * then find matching interpolations and interpolation between this segmentation\r\n   * and the other segmentations of the same type.\r\n   */\r\n  static handleAnnotationCompleted = (evt: AnnotationCompletedEventType) => {\r\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\r\n    if (!annotation?.metadata) {\r\n      return;\r\n    }\r\n    const { toolName, originalToolName } = annotation.metadata;\r\n\r\n    if (\r\n      !this.toolNames.includes(toolName) &&\r\n      !this.toolNames.includes(originalToolName)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    const viewport = getViewportForAnnotation(annotation);\r\n    if (!viewport) {\r\n      console.warn('Unable to find viewport for', annotation);\r\n      return;\r\n    }\r\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\r\n    const viewportData: InterpolationViewportData = {\r\n      viewport,\r\n      sliceData,\r\n      annotation,\r\n      interpolationUID: annotation.interpolationUID,\r\n    };\r\n    const hasInterpolationUID = !!annotation.interpolationUID;\r\n    // If any update, triggered on an annotation, then it will be treated as non-autogenerated.\r\n    annotation.autoGenerated = false;\r\n    if (hasInterpolationUID) {\r\n      // This has already been configured with matching details, so just run\r\n      //  the interpolation again.\r\n      deleteRelatedAnnotations(viewportData);\r\n      interpolate(viewportData);\r\n      return;\r\n    }\r\n    const filterData = [\r\n      {\r\n        key: 'segmentIndex',\r\n        value: annotation.data.segmentation.segmentIndex,\r\n        parentKey: (annotation) => annotation.data.segmentation,\r\n      },\r\n      {\r\n        key: 'viewPlaneNormal',\r\n        value: annotation.metadata.viewPlaneNormal,\r\n        parentKey: (annotation) => annotation.metadata,\r\n      },\r\n      {\r\n        key: 'viewUp',\r\n        value: annotation.metadata.viewUp,\r\n        parentKey: (annotation) => annotation.metadata,\r\n      },\r\n    ];\r\n    let interpolationAnnotations = getInterpolationDataCollection(\r\n      viewportData,\r\n      filterData\r\n    );\r\n    // Skip other type of annotation interpolationUID's that are co-located\r\n    const { sliceIndex } = annotation.metadata;\r\n    const skipUIDs = new Set<string>();\r\n    interpolationAnnotations.forEach((interpolationAnnotation) => {\r\n      if (\r\n        interpolationAnnotation.interpolationCompleted ||\r\n        interpolationAnnotation.metadata.sliceIndex === sliceIndex\r\n      ) {\r\n        const { interpolationUID } = interpolationAnnotation;\r\n        skipUIDs.add(interpolationUID);\r\n      }\r\n    });\r\n    interpolationAnnotations = interpolationAnnotations.filter(\r\n      (interpolationAnnotation) =>\r\n        !skipUIDs.has(interpolationAnnotation.interpolationUID)\r\n    );\r\n\r\n    // Assign a new interpolationUID (this is checked above, so will be empty initially)\r\n    annotation.interpolationUID =\r\n      interpolationAnnotations[0]?.interpolationUID || uuidv4();\r\n    viewportData.interpolationUID = annotation.interpolationUID;\r\n    interpolate(viewportData);\r\n  };\r\n\r\n  /**\r\n   * This method gets called when an annotation changes.  It will then trigger\r\n   * related already interpolated annotations to be updated with the modified data.\r\n   */\r\n  static handleAnnotationUpdate = (evt: AnnotationModifiedEventType) => {\r\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\r\n    const { changeType = ChangeTypes.HandlesUpdated } = evt.detail;\r\n    if (!annotation?.metadata) {\r\n      return;\r\n    }\r\n    const { toolName, originalToolName } = annotation.metadata;\r\n\r\n    if (\r\n      (!this.toolNames.includes(toolName) &&\r\n        !this.toolNames.includes(originalToolName)) ||\r\n      !ChangeTypesForInterpolation.includes(changeType)\r\n    ) {\r\n      return;\r\n    }\r\n    const viewport = getViewportForAnnotation(annotation);\r\n    if (!viewport) {\r\n      console.warn(\r\n        'Unable to find matching viewport for annotation interpolation',\r\n        annotation\r\n      );\r\n      return;\r\n    }\r\n    if (annotation.autoGenerated) {\r\n      // Dont fire the annotation changed events here, as that leads to recursion,\r\n      // although this is in fact completing the event, so trigger the segmentation add\r\n      addContourSegmentationAnnotation(annotation);\r\n      annotation.autoGenerated = false;\r\n    }\r\n\r\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\r\n    const viewportData: InterpolationViewportData = {\r\n      viewport,\r\n      sliceData,\r\n      annotation,\r\n      interpolationUID: annotation.interpolationUID,\r\n      isInterpolationUpdate: changeType === ChangeTypes.InterpolationUpdated,\r\n    };\r\n    interpolate(viewportData);\r\n  };\r\n\r\n  /**\r\n   * Delete interpolated annotations when their endpoints are deleted.\r\n   */\r\n  static handleAnnotationDelete = (evt: AnnotationRemovedEventType) => {\r\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\r\n    if (!annotation?.metadata) {\r\n      return;\r\n    }\r\n    const { toolName } = annotation.metadata;\r\n\r\n    if (!this.toolNames.includes(toolName) || annotation.autoGenerated) {\r\n      return;\r\n    }\r\n    const viewport = getViewportForAnnotation(annotation);\r\n\r\n    if (!viewport) {\r\n      console.warn(\r\n        \"No viewport, can't delete interpolated results\",\r\n        annotation\r\n      );\r\n      return;\r\n    }\r\n\r\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\r\n    const viewportData: InterpolationViewportData = {\r\n      viewport,\r\n      sliceData,\r\n      annotation,\r\n      interpolationUID: annotation.interpolationUID,\r\n    };\r\n    // If any update, triggered on an annotation, then it will be treated as non-interpolated.\r\n    annotation.autoGenerated = false;\r\n    deleteRelatedAnnotations(viewportData);\r\n  };\r\n}\r\n\r\nfunction getSliceData(viewport): Types.ImageSliceData {\r\n  const sliceData: Types.ImageSliceData = {\r\n    numberOfSlices: viewport.getNumberOfSlices(),\r\n    imageIndex: viewport.getCurrentImageIdIndex(),\r\n  };\r\n  return sliceData;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport { getToolGroup } from '../../store/ToolGroupManager';\r\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\r\nimport { getRenderingEngine } from '@cornerstonejs/core';\r\nimport { getBrushToolInstances } from './utilities';\r\n\r\nexport function setBrushReplaceForToolGroup(\r\n  toolGroupId: string,\r\n  targetSegmentIndex: string\r\n) {\r\n  const toolGroup = getToolGroup(toolGroupId);\r\n\r\n  if (toolGroup === undefined) {\r\n    return;\r\n  }\r\n\r\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\r\n\r\n  brushBasedToolInstances.forEach((tool) => {\r\n    tool.configuration.strategySpecificConfiguration.REPLACE.targetSegmentIndex =\r\n      targetSegmentIndex;\r\n  });\r\n}\r\n\r\nexport function getBrushReplaceForToolGroup(toolGroupId: string) {\r\n  const toolGroup = getToolGroup(toolGroupId);\r\n\r\n  if (toolGroup === undefined) {\r\n    return;\r\n  }\r\n\r\n  const toolInstances = toolGroup._toolInstances;\r\n\r\n  if (!Object.keys(toolInstances).length) {\r\n    return;\r\n  }\r\n\r\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\r\n  const brushToolInstance = brushBasedToolInstances[0];\r\n\r\n  if (!brushToolInstance) {\r\n    return;\r\n  }\r\n\r\n  return brushToolInstance.configuration.strategySpecificConfiguration.REPLACE\r\n    .targetSegmentIndex;\r\n}\r\n","import { getToolGroup } from '../../store/ToolGroupManager';\r\nimport BrushTool from '../../tools/segmentation/BrushTool';\r\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\r\nimport { getRenderingEngine } from '@cornerstonejs/core';\r\nimport { getBrushToolInstances } from './utilities';\r\n\r\n/**\r\n * Sets the brush size for all brush-based tools in a given tool group.\r\n * @param toolGroupId - The ID of the tool group to set the brush size for.\r\n * @param brushSize - The new brush size to set.\r\n * @param toolName - The name of the specific tool to set the brush size for (optional)\r\n * If not provided, all brush-based tools in the tool group will be affected.\r\n */\r\nexport function setBrushSizeForToolGroup(\r\n  toolGroupId: string,\r\n  brushSize: number,\r\n  toolName?: string\r\n): void {\r\n  const toolGroup = getToolGroup(toolGroupId);\r\n\r\n  if (toolGroup === undefined) {\r\n    return;\r\n  }\r\n\r\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\r\n\r\n  brushBasedToolInstances.forEach((tool: BrushTool) => {\r\n    tool.configuration.brushSize = brushSize;\r\n\r\n    // Invalidate the brush being rendered so it can update.\r\n    tool.invalidateBrushCursor();\r\n  });\r\n\r\n  // Trigger an annotation render for any viewports on the toolgroup\r\n  const viewportsInfo = toolGroup.getViewportsInfo();\r\n\r\n  const viewportsInfoArray = Object.keys(viewportsInfo).map(\r\n    (key) => viewportsInfo[key]\r\n  );\r\n\r\n  if (!viewportsInfoArray.length) {\r\n    return;\r\n  }\r\n\r\n  const { renderingEngineId } = viewportsInfoArray[0];\r\n\r\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\r\n  // ourselves here.\r\n  const viewportIds = toolGroup.getViewportIds();\r\n\r\n  const renderingEngine = getRenderingEngine(renderingEngineId);\r\n\r\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\r\n}\r\n\r\n/**\r\n * Gets the brush size for the first brush-based tool instance in a given tool group.\r\n * @param toolGroupId - The ID of the tool group to get the brush size for.\r\n * @param toolName - The name of the specific tool to get the brush size for (Optional)\r\n * If not provided, the first brush-based tool instance in the tool group will be used.\r\n * @returns The brush size of the selected tool instance, or undefined if no brush-based tool instance is found.\r\n */\r\nexport function getBrushSizeForToolGroup(\r\n  toolGroupId: string,\r\n  toolName?: string\r\n): void {\r\n  const toolGroup = getToolGroup(toolGroupId);\r\n\r\n  if (toolGroup === undefined) {\r\n    return;\r\n  }\r\n\r\n  const toolInstances = toolGroup._toolInstances;\r\n\r\n  if (!Object.keys(toolInstances).length) {\r\n    return;\r\n  }\r\n\r\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\r\n\r\n  // one is enough as they share the same brush size\r\n  const brushToolInstance = brushBasedToolInstances[0];\r\n\r\n  if (!brushToolInstance) {\r\n    return;\r\n  }\r\n\r\n  // TODO -> Assumes the brush sizes are the same and set via these helpers.\r\n  return brushToolInstance.configuration.brushSize;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport { getToolGroup } from '../../store/ToolGroupManager';\r\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\r\nimport { getRenderingEngine } from '@cornerstonejs/core';\r\nimport { getBrushToolInstances } from './utilities';\r\n\r\nexport function setBrushThresholdForToolGroup(\r\n  toolGroupId: string,\r\n  threshold: Types.Point2,\r\n  otherArgs: Record<string, unknown> = { isDynamic: false }\r\n) {\r\n  const toolGroup = getToolGroup(toolGroupId);\r\n\r\n  if (toolGroup === undefined) {\r\n    return;\r\n  }\r\n\r\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\r\n  const configuration = {\r\n    ...otherArgs,\r\n    ...(threshold !== undefined && { threshold }),\r\n  };\r\n\r\n  brushBasedToolInstances.forEach((tool) => {\r\n    tool.configuration.strategySpecificConfiguration.THRESHOLD = {\r\n      ...tool.configuration.strategySpecificConfiguration.THRESHOLD,\r\n      ...configuration,\r\n    };\r\n  });\r\n}\r\n\r\nexport function getBrushThresholdForToolGroup(toolGroupId: string) {\r\n  const toolGroup = getToolGroup(toolGroupId);\r\n\r\n  if (toolGroup === undefined) {\r\n    return;\r\n  }\r\n\r\n  const toolInstances = toolGroup._toolInstances;\r\n\r\n  if (!Object.keys(toolInstances).length) {\r\n    return;\r\n  }\r\n\r\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\r\n  const brushToolInstance = brushBasedToolInstances[0];\r\n\r\n  if (!brushToolInstance) {\r\n    return;\r\n  }\r\n\r\n  return brushToolInstance.configuration.strategySpecificConfiguration.THRESHOLD\r\n    .threshold;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport { cache } from '@cornerstonejs/core';\r\nimport { vec3 } from 'gl-matrix';\r\n\r\n/**\r\n * Determines if there is a point between point1 and point2 which is not\r\n * contained in the segmentation\r\n */\r\nexport default function isLineInSegment(\r\n  point1: Types.Point3,\r\n  point2: Types.Point3,\r\n  isInSegment\r\n) {\r\n  const ijk1 = isInSegment.toIJK(point1);\r\n  const ijk2 = isInSegment.toIJK(point2);\r\n  const testPoint = vec3.create();\r\n  const { testIJK } = isInSegment;\r\n  const delta = vec3.sub(vec3.create(), ijk1, ijk2);\r\n\r\n  // Test once for index value between the two points, so the max of the\r\n  // difference in IJK values\r\n  const testSize = Math.round(Math.max(...delta.map(Math.abs)));\r\n  if (testSize < 2) {\r\n    // No need to test when there are only two points\r\n    return true;\r\n  }\r\n  const unitDelta = vec3.scale(vec3.create(), delta, 1 / testSize);\r\n\r\n  for (let i = 1; i < testSize; i++) {\r\n    vec3.scaleAndAdd(testPoint, ijk2, unitDelta, i);\r\n    if (!testIJK(testPoint)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * Creates a function that tests to see if the provided line segment, specified\r\n * in LPS space (as endpoints) is contained in the segment\r\n */\r\nfunction createIsInSegment(\r\n  segVolumeId: string,\r\n  segmentIndex: number,\r\n  containedSegmentIndices?: Set<number>\r\n) {\r\n  // Get segmentation volume\r\n  const vol = cache.getVolume(segVolumeId);\r\n  if (!vol) {\r\n    console.warn(`No volume found for ${segVolumeId}`);\r\n    return;\r\n  }\r\n\r\n  const segData = vol.imageData.getPointData().getScalars().getData();\r\n  const width = vol.dimensions[0];\r\n  const pixelsPerSlice = width * vol.dimensions[1];\r\n\r\n  return {\r\n    /**\r\n     * Find the center point between point1 and point2, convert it to IJK space\r\n     * and test if the value at that location is in the segment\r\n     */\r\n    testCenter: (point1, point2) => {\r\n      const point = vec3.add(vec3.create(), point1, point2).map((it) => it / 2);\r\n      const ijk = vol.imageData.worldToIndex(point as vec3).map(Math.round);\r\n      const [i, j, k] = ijk;\r\n      const index = i + j * width + k * pixelsPerSlice;\r\n      const value = segData[index];\r\n      return value === segmentIndex || containedSegmentIndices?.has(value);\r\n    },\r\n\r\n    toIJK: (point) => vol.imageData.worldToIndex(point as vec3),\r\n\r\n    testIJK: (ijk) => {\r\n      const [i, j, k] = ijk;\r\n      const index =\r\n        Math.round(i) + Math.round(j) * width + Math.round(k) * pixelsPerSlice;\r\n      const value = segData[index];\r\n      return value === segmentIndex || containedSegmentIndices?.has(value);\r\n    },\r\n  };\r\n}\r\n\r\nexport { createIsInSegment, isLineInSegment };\r\n","import { vec3 } from 'gl-matrix';\r\n\r\nimport { createIsInSegment, isLineInSegment } from './isLineInSegment';\r\nimport type { BidirectionalData } from './createBidirectionalToolData';\r\n\r\nconst EPSILON = 1e-2;\r\n\r\n/**\r\n * Search in the contours for the given segment to find the largest bidirectional\r\n * that will fit entirely within the slice contours inside the contours object.\r\n * Assumptions/implementation details:\r\n *\r\n *   1. The major and minor bidirectional lines must not cross the contour\r\n *   2. The center point for both major and minor bidirectional lines must be\r\n *      within the segment, or the contained segment index.\r\n *   3. The major/minor axis must be orthogonal\r\n *\r\n * Note this does NOT test that the major/minor axis intersect.  Normally they will, but\r\n * it isn't a hard requirement.\r\n *\r\n * The way that islands within the contours are handled is to allow the island to be\r\n * coloured with something that is contained - that way both open and closed islands\r\n * can be handled correctly for finding the bidirectional  (an open island is a section\r\n * inside the segment that is open to the outside - this can happen at bone endpoints or when\r\n * one region flows into another)\r\n */\r\nexport default function findLargestBidirectional(\r\n  contours,\r\n  segVolumeId: string,\r\n  segment\r\n) {\r\n  const { sliceContours } = contours;\r\n  const { segmentIndex, containedSegmentIndices } = segment;\r\n  let maxBidirectional;\r\n  const isInSegment = createIsInSegment(\r\n    segVolumeId,\r\n    segmentIndex,\r\n    containedSegmentIndices\r\n  );\r\n  for (const sliceContour of sliceContours) {\r\n    const bidirectional = createBidirectionalForSlice(\r\n      sliceContour,\r\n      isInSegment,\r\n      maxBidirectional\r\n    );\r\n    if (!bidirectional) {\r\n      continue;\r\n    }\r\n    maxBidirectional = bidirectional;\r\n  }\r\n  if (maxBidirectional) {\r\n    Object.assign(maxBidirectional, segment);\r\n  }\r\n  return maxBidirectional;\r\n}\r\n\r\n/**\r\n * This function creates a bidirectional data object for the given slice and\r\n * slice contour, only when the major distance is larger than currentMax, or\r\n * equal to current max and the minor is larger than currentMax's minor.\r\n * It does this by looking at every pair of distances in sliceCountour to find\r\n * those larger than the currentMax, and then finds the minor distance for those\r\n * major distances.\r\n *\r\n */\r\nfunction createBidirectionalForSlice(\r\n  sliceContour,\r\n  isInSegment,\r\n  currentMax = { maxMajor: 0, maxMinor: 0 }\r\n) {\r\n  const { points } = sliceContour.polyData;\r\n  const { maxMinor: currentMaxMinor, maxMajor: currentMaxMajor } = currentMax;\r\n  let maxMajor = currentMaxMajor * currentMaxMajor;\r\n  let maxMinor = currentMaxMinor * currentMaxMinor;\r\n  let maxMajorPoints;\r\n  for (let index1 = 0; index1 < points.length; index1++) {\r\n    for (let index2 = index1 + 1; index2 < points.length; index2++) {\r\n      const point1 = points[index1];\r\n      const point2 = points[index2];\r\n      const distance2 = vec3.sqrDist(point1, point2);\r\n      if (distance2 < maxMajor) {\r\n        continue;\r\n      }\r\n      if (distance2 - EPSILON < maxMajor + EPSILON && maxMajorPoints) {\r\n        // Consider adding to the set of points rather than continuing here\r\n        // so that all minor axis can be tested\r\n        continue;\r\n      }\r\n      if (!isInSegment.testCenter(point1, point2)) {\r\n        // Center between the two points has to be in the segment, otherwise\r\n        // this is out of bounds.\r\n        continue;\r\n      }\r\n      if (!isLineInSegment(point1, point2, isInSegment)) {\r\n        // If the line intersects the segment boundary, then skip it\r\n        continue;\r\n      }\r\n      maxMajor = distance2 - EPSILON;\r\n      maxMajorPoints = [index1, index2];\r\n      maxMinor = 0;\r\n    }\r\n  }\r\n  if (!maxMajorPoints) {\r\n    return;\r\n  }\r\n\r\n  maxMajor = Math.sqrt(maxMajor + EPSILON);\r\n  const handle0 = points[maxMajorPoints[0]];\r\n  const handle1 = points[maxMajorPoints[1]];\r\n  const unitMajor = vec3.sub(vec3.create(), handle0, handle1);\r\n  vec3.scale(unitMajor, unitMajor, 1 / maxMajor);\r\n\r\n  let maxMinorPoints;\r\n\r\n  for (let index1 = 0; index1 < points.length; index1++) {\r\n    for (let index2 = index1 + 1; index2 < points.length; index2++) {\r\n      const point1 = points[index1];\r\n      const point2 = points[index2];\r\n      const distance2 = vec3.sqrDist(point1, point2);\r\n      if (distance2 <= maxMinor) {\r\n        continue;\r\n      }\r\n      const delta = vec3.sub(vec3.create(), point1, point2);\r\n\r\n      const dot = Math.abs(vec3.dot(delta, unitMajor)) / Math.sqrt(distance2);\r\n      if (dot > EPSILON) {\r\n        continue;\r\n      }\r\n\r\n      if (!isInSegment.testCenter(point1, point2)) {\r\n        // Center between the two points has to be in the segment, otherwise\r\n        // this is out of bounds.\r\n        continue;\r\n      }\r\n      if (!isLineInSegment(point1, point2, isInSegment)) {\r\n        continue;\r\n      }\r\n      maxMinor = distance2;\r\n      maxMinorPoints = [index1, index2];\r\n    }\r\n  }\r\n\r\n  if (!maxMinorPoints) {\r\n    // Didn't find a larger minor distance\r\n    return;\r\n  }\r\n  maxMinor = Math.sqrt(maxMinor);\r\n  const handle2 = points[maxMinorPoints[0]];\r\n  const handle3 = points[maxMinorPoints[1]];\r\n\r\n  const bidirectional = {\r\n    majorAxis: [handle0, handle1],\r\n    minorAxis: [handle2, handle3],\r\n    maxMajor,\r\n    maxMinor,\r\n    ...sliceContour,\r\n  } as BidirectionalData;\r\n  return bidirectional;\r\n}\r\n","import { generateContourSetsFromLabelmap } from '../contours';\r\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\r\nimport findLargestBidirectional from './findLargestBidirectional';\r\n\r\nconst { Labelmap } = SegmentationRepresentations;\r\n\r\n/**\r\n * Generates a contour object over the segment, and then uses the contouring to\r\n * find the largest bidirectional object that can be applied within the acquisition\r\n * plane that is within the segment index, or the contained segment indices.\r\n *\r\n * @param segmentation.segments - a list of segments to apply the contour to.\r\n * @param segmentation.segments.containedSegmentIndices - a set of segment indexes equivalent to the primary segment\r\n * @param segmentation.segments.label - the label for the segment\r\n * @param segmentation.segments.color - the color to use for the segment label\r\n */\r\nexport default function contourAndFindLargestBidirectional(segmentation) {\r\n  const contours = generateContourSetsFromLabelmap({\r\n    segmentations: segmentation,\r\n  });\r\n\r\n  if (!contours?.length || !contours[0].sliceContours.length) {\r\n    return;\r\n  }\r\n\r\n  const {\r\n    representationData,\r\n    segments = [\r\n      null,\r\n      { label: 'Unspecified', color: null, containedSegmentIndices: null },\r\n    ],\r\n  } = segmentation;\r\n  const { volumeId: segVolumeId } = representationData[Labelmap];\r\n\r\n  const segmentIndex = segments.findIndex((it) => !!it);\r\n  if (segmentIndex === -1) {\r\n    return;\r\n  }\r\n  segments[segmentIndex].segmentIndex = segmentIndex;\r\n  return findLargestBidirectional(\r\n    contours[0],\r\n    segVolumeId,\r\n    segments[segmentIndex]\r\n  );\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport type { Annotation } from '../../types/AnnotationTypes';\r\n\r\nexport type BidirectionalData = {\r\n  majorAxis: [Types.Point3, Types.Point3];\r\n  minorAxis: [Types.Point3, Types.Point3];\r\n  maxMajor: number;\r\n  maxMinor: number;\r\n  segmentIndex: number;\r\n  label?: string;\r\n  color?: string | number[];\r\n  referencedImageId: string;\r\n  sliceIndex: number;\r\n};\r\n\r\n/**\r\n * Creates data suitable for the BidirectionalTool from the basic bidirectional\r\n * data object.\r\n */\r\nexport default function createBidirectionalToolData(\r\n  bidirectionalData: BidirectionalData,\r\n  viewport\r\n): Annotation {\r\n  const { majorAxis, minorAxis, label = '', sliceIndex } = bidirectionalData;\r\n  const [major0, major1] = majorAxis;\r\n  const [minor0, minor1] = minorAxis;\r\n\r\n  const points = [major0, major1, minor0, minor1];\r\n  const bidirectionalToolData = {\r\n    highlighted: true,\r\n    invalidated: true,\r\n    metadata: {\r\n      toolName: 'Bidirectional',\r\n      // Get a view reference for the slice this applies to, not the currently\r\n      // displayed slice.  This will fill in the remaining data for that slice\r\n      ...viewport.getViewReference({ sliceIndex }),\r\n    },\r\n    data: {\r\n      handles: {\r\n        points,\r\n        textBox: {\r\n          hasMoved: false,\r\n          worldPosition: [0, 0, 0] as Types.Point3,\r\n          worldBoundingBox: {\r\n            topLeft: [0, 0, 0] as Types.Point3,\r\n            topRight: [0, 0, 0] as Types.Point3,\r\n            bottomLeft: [0, 0, 0] as Types.Point3,\r\n            bottomRight: [0, 0, 0] as Types.Point3,\r\n          },\r\n        },\r\n        activeHandleIndex: null,\r\n      },\r\n      label,\r\n      cachedStats: {},\r\n    },\r\n    isLocked: false,\r\n    isVisible: true,\r\n  };\r\n  return bidirectionalToolData;\r\n}\r\n","/**\r\n * Creates a map that associates each imageId with a set of segmentation imageIds.\r\n * Note that this function assumes that the imageIds and segmentationImageIds arrays\r\n * are the same length and same order.\r\n *\r\n * @param imageIdsArray - An array of imageIds.\r\n * @param segmentationImageIds - An array of segmentation imageIds.\r\n * @returns A map that maps each imageId to a set of segmentation imageIds.\r\n */\r\nfunction createImageIdReferenceMap(\r\n  imageIdsArray: string[],\r\n  segmentationImageIds: string[]\r\n): Map<string, string> {\r\n  const imageIdReferenceMap = new Map<string, string>(\r\n    imageIdsArray.map((imageId, index) => {\r\n      return [imageId, segmentationImageIds[index]];\r\n    })\r\n  );\r\n\r\n  return imageIdReferenceMap;\r\n}\r\n\r\nexport { createImageIdReferenceMap };\r\n","import cloneDeep from 'lodash.clonedeep';\r\nimport {\r\n  getEnabledElementByIds,\r\n  volumeLoader,\r\n  VolumeViewport,\r\n  utilities as csUtils,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Create a new 3D segmentation volume from the default imageData presented in\r\n * the first actor of the viewport. It looks at the metadata of the imageData\r\n * to determine the volume dimensions and spacing if particular options are not provided.\r\n *\r\n * @param viewportId - The Id of the viewport from which to derive the volume from.\r\n * @param renderingEngineId - The Id of the rendering engine the viewport belongs to.\r\n * @param [segmentationId] - The Id to name the generated segmentation. Autogenerated if not given.\r\n * @param [options] - LabelmapOptions\r\n * @returns A promise that resolves to the Id of the new labelmap volume.\r\n */\r\nexport default async function createLabelmapVolumeForViewport(input: {\r\n  viewportId: string;\r\n  renderingEngineId: string;\r\n  segmentationId?: string;\r\n  options?: {\r\n    volumeId: string;\r\n    scalarData: Float32Array | Uint8Array | Uint16Array | Int16Array;\r\n    targetBuffer: {\r\n      type: 'Float32Array' | 'Uint8Array' | 'Uint16Array' | 'Int8Array';\r\n    };\r\n    metadata: Types.Metadata;\r\n    dimensions: Types.Point3;\r\n    spacing: Types.Point3;\r\n    origin: Types.Point3;\r\n    direction: Types.Mat3;\r\n  };\r\n}): Promise<string> {\r\n  const { viewportId, renderingEngineId, options } = input;\r\n  let { segmentationId } = input;\r\n  const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\r\n\r\n  if (!enabledElement) {\r\n    throw new Error('element disabled');\r\n  }\r\n\r\n  const { viewport } = enabledElement;\r\n  if (!(viewport instanceof VolumeViewport)) {\r\n    throw new Error('Segmentation only supports VolumeViewport');\r\n  }\r\n\r\n  const { uid } = viewport.getDefaultActor();\r\n\r\n  if (segmentationId === undefined) {\r\n    // Name the segmentation volume with the viewport Id\r\n    segmentationId = `${uid}-based-segmentation-${\r\n      options?.volumeId ?? csUtils.uuidv4().slice(0, 8)\r\n    }`;\r\n  }\r\n\r\n  if (options) {\r\n    // create a new labelmap with its own properties\r\n    // This allows creation of a higher resolution labelmap vs reference volume\r\n    const properties = cloneDeep(options);\r\n    await volumeLoader.createLocalVolume(properties, segmentationId);\r\n  } else {\r\n    // create a labelmap from a reference volume\r\n    const { uid: volumeId } = viewport.getDefaultActor();\r\n    await volumeLoader.createAndCacheDerivedSegmentationVolume(volumeId, {\r\n      volumeId: segmentationId,\r\n    });\r\n  }\r\n\r\n  return segmentationId;\r\n}\r\n","import { Types } from '@cornerstonejs/core';\r\nimport { volumeLoader, utilities as csUtils } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Given a list of labelmaps (with the possibility of overlapping regions), and\r\n * a segmentIndex it creates a new labelmap with the same dimensions as the input labelmaps,\r\n * but merges them into a single labelmap for the segmentIndex. It wipes out\r\n * all other segment Indices. This is useful for calculating statistics regarding\r\n * a specific segment when there are overlapping regions between labelmap (e.g. TMTV)\r\n *\r\n * @param labelmaps - Array of labelmaps\r\n * @param segmentIndex - The segment index to merge\r\n * @returns Merged labelmap\r\n */\r\nfunction createMergedLabelmapForIndex(\r\n  labelmaps: Array<Types.IImageVolume>,\r\n  segmentIndex = 1,\r\n  volumeId = 'mergedLabelmap'\r\n): Types.IImageVolume {\r\n  labelmaps.forEach(({ direction, dimensions, origin, spacing }) => {\r\n    if (\r\n      !csUtils.isEqual(dimensions, labelmaps[0].dimensions) ||\r\n      !csUtils.isEqual(direction, labelmaps[0].direction) ||\r\n      !csUtils.isEqual(spacing, labelmaps[0].spacing) ||\r\n      !csUtils.isEqual(origin, labelmaps[0].origin)\r\n    ) {\r\n      throw new Error('labelmaps must have the same size and shape');\r\n    }\r\n  });\r\n\r\n  const labelmap = labelmaps[0];\r\n\r\n  const arrayType = (labelmap.getScalarData() as any).constructor;\r\n  const outputData = new arrayType(labelmap.getScalarData().length);\r\n\r\n  labelmaps.forEach((labelmap) => {\r\n    const scalarData = labelmap.getScalarData();\r\n    for (let i = 0; i < scalarData.length; i++) {\r\n      if (scalarData[i] === segmentIndex) {\r\n        outputData[i] = segmentIndex;\r\n      }\r\n    }\r\n  });\r\n\r\n  const options = {\r\n    scalarData: outputData,\r\n    metadata: labelmap.metadata,\r\n    spacing: labelmap.spacing,\r\n    origin: labelmap.origin,\r\n    direction: labelmap.direction,\r\n    dimensions: labelmap.dimensions,\r\n  };\r\n\r\n  const preventCache = true;\r\n  // Todo: following should be async\r\n  const mergedVolume = volumeLoader.createLocalVolume(\r\n    options,\r\n    volumeId,\r\n    preventCache\r\n  );\r\n\r\n  return mergedVolume;\r\n}\r\n\r\nexport default createMergedLabelmapForIndex;\r\n","import type {\r\n  FloodFillResult,\r\n  FloodFillGetter,\r\n  FloodFillOptions,\r\n} from '../../types';\r\nimport { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * floodFill.js - Taken from MIT OSS lib - https://github.com/tuzz/n-dimensional-flood-fill\r\n * Refactored to ES6.  Fixed the bounds/visits checks to use integer keys, restricting the\r\n * total search spacing to +/- 32k in each dimension, but resulting in about a hundred time\r\n * performance gain for larger regions since JavaScript does not have a hash map to allow the\r\n * map to work on keys.\r\n *\r\n * @param getter The getter to the elements of your data structure,\r\n *                          e.g. getter(x,y) for a 2D interprettation of your structure.\r\n * @param seed The seed for your fill. The dimensionality is infered\r\n *                        by the number of dimensions of the seed.\r\n * @param options.onFlood - An optional callback to execute when each pixel is flooded.\r\n *                             e.g. onFlood(x,y).\r\n * @param options.onBoundary - An optional callback to execute whenever a boundary is reached.\r\n *                                a boundary could be another segmentIndex, or the edge of your\r\n *                                data structure (i.e. when your getter returns undefined).\r\n * @param options.equals - An optional equality method for your datastructure.\r\n *                            Default is simply value1 = value2.\r\n * @param options.diagonals - Whether you allow flooding through diagonals. Defaults to false.\r\n *\r\n * @returns Flood fill results\r\n */\r\nfunction floodFill(\r\n  getter: FloodFillGetter,\r\n  seed: Types.Point2 | Types.Point3,\r\n  options: FloodFillOptions = {}\r\n): FloodFillResult {\r\n  const onFlood = options.onFlood;\r\n  const onBoundary = options.onBoundary;\r\n  const equals = options.equals;\r\n  const diagonals = options.diagonals || false;\r\n  const startNode = get(seed);\r\n  const permutations = prunedPermutations();\r\n  const stack = [];\r\n  const flooded = [];\r\n  const visits = new Set();\r\n  const bounds = new Map();\r\n\r\n  stack.push({ currentArgs: seed });\r\n\r\n  while (stack.length > 0) {\r\n    flood(stack.pop());\r\n  }\r\n\r\n  return {\r\n    flooded,\r\n    boundaries: boundaries(),\r\n  };\r\n\r\n  function flood(job) {\r\n    const getArgs = job.currentArgs;\r\n    const prevArgs = job.previousArgs;\r\n\r\n    if (visited(getArgs)) {\r\n      return;\r\n    }\r\n    markAsVisited(getArgs);\r\n\r\n    if (member(getArgs)) {\r\n      markAsFlooded(getArgs);\r\n      pushAdjacent(getArgs);\r\n    } else {\r\n      markAsBoundary(prevArgs);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Indicates if the key has been visited.\r\n   * @param key is a 2 or 3 element vector with values -32768...32767\r\n   */\r\n  function visited(key) {\r\n    const [x, y, z = 0] = key;\r\n    // Use an integer key value for checking visited, since JavaScript does not\r\n    // provide a generic hash key indexed hash map.\r\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\r\n    return visits.has(iKey);\r\n  }\r\n\r\n  function markAsVisited(key) {\r\n    const [x, y, z = 0] = key;\r\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\r\n    visits.add(iKey);\r\n  }\r\n\r\n  function member(getArgs) {\r\n    const node = get(getArgs);\r\n\r\n    return equals ? equals(node, startNode) : node === startNode;\r\n  }\r\n\r\n  function markAsFlooded(getArgs) {\r\n    flooded.push(getArgs);\r\n    if (onFlood) {\r\n      //@ts-ignore\r\n      onFlood(...getArgs);\r\n    }\r\n  }\r\n\r\n  function markAsBoundary(prevArgs) {\r\n    const [x, y, z = 0] = prevArgs;\r\n    // Use an integer key value for checking visited, since JavaScript does not\r\n    // provide a generic hash key indexed hash map.\r\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\r\n    bounds.set(iKey, prevArgs);\r\n    if (onBoundary) {\r\n      //@ts-ignore\r\n      onBoundary(...prevArgs);\r\n    }\r\n  }\r\n\r\n  function pushAdjacent(getArgs) {\r\n    for (let i = 0; i < permutations.length; i += 1) {\r\n      const perm = permutations[i];\r\n      const nextArgs = getArgs.slice(0);\r\n\r\n      for (let j = 0; j < getArgs.length; j += 1) {\r\n        nextArgs[j] += perm[j];\r\n      }\r\n\r\n      stack.push({\r\n        currentArgs: nextArgs,\r\n        previousArgs: getArgs,\r\n      });\r\n    }\r\n  }\r\n\r\n  function get(getArgs) {\r\n    //@ts-ignore\r\n    return getter(...getArgs);\r\n  }\r\n\r\n  // This is a significant performance hit - should be done as a wrapper\r\n  // only when needed.\r\n  // function safely(f, args) {\r\n  //   try {\r\n  //     return f(...args);\r\n  //   } catch (error) {\r\n  //     return;\r\n  //   }\r\n  // }\r\n\r\n  function prunedPermutations() {\r\n    const permutations = permute(seed.length);\r\n\r\n    return permutations.filter(function (perm) {\r\n      const count = countNonZeroes(perm);\r\n\r\n      return count !== 0 && (count === 1 || diagonals);\r\n    });\r\n  }\r\n\r\n  function permute(length) {\r\n    const perms = [];\r\n\r\n    const permutation = function (string) {\r\n      return string.split('').map(function (c) {\r\n        return parseInt(c, 10) - 1;\r\n      });\r\n    };\r\n\r\n    for (let i = 0; i < Math.pow(3, length); i += 1) {\r\n      const string = lpad(i.toString(3), '0', length);\r\n\r\n      perms.push(permutation(string));\r\n    }\r\n\r\n    return perms;\r\n  }\r\n\r\n  function boundaries() {\r\n    const array = Array.from(bounds.values());\r\n    array.reverse();\r\n    return array;\r\n  }\r\n}\r\n\r\nfunction defaultEquals(a, b) {\r\n  return a === b;\r\n}\r\n\r\nfunction countNonZeroes(array) {\r\n  let count = 0;\r\n\r\n  for (let i = 0; i < array.length; i += 1) {\r\n    if (array[i] !== 0) {\r\n      count += 1;\r\n    }\r\n  }\r\n\r\n  return count;\r\n}\r\n\r\nfunction lpad(string, character, length) {\r\n  const array = new Array(length + 1);\r\n  const pad = array.join(character);\r\n\r\n  return (pad + string).slice(-length);\r\n}\r\n\r\nexport default floodFill;\r\n","import getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\r\nimport SegmentationRepresentation from '../../enums/SegmentationRepresentations';\r\nimport { Segmentation } from '../../types/SegmentationStateTypes';\r\n\r\n/**\r\n * It returns a configuration object for the given representation type.\r\n * @param representationType - The type of segmentation representation\r\n * @returns A representation configuration object.\r\n */\r\nexport default function getDefaultRepresentationConfig(\r\n  segmentation: Segmentation\r\n) {\r\n  const { type: representationType } = segmentation;\r\n  switch (representationType) {\r\n    case SegmentationRepresentation.Labelmap:\r\n      return getDefaultLabelmapConfig();\r\n    default:\r\n      throw new Error(`Unknown representation type: ${representationType}`);\r\n  }\r\n}\r\n","import { getAnnotation } from '../../stateManagement';\r\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\r\n\r\n/**\r\n * Retrieves the index of the hovered contour segmentation annotation for a given segmentation ID.\r\n *\r\n * @param segmentationId - The ID of the segmentation.\r\n * @returns The index of the hovered contour segmentation annotation, or undefined if none is found.\r\n */\r\nexport function getHoveredContourSegmentationAnnotation(segmentationId) {\r\n  const segmentation = getSegmentation(segmentationId);\r\n  const { annotationUIDsMap } = segmentation.representationData.CONTOUR;\r\n\r\n  for (const [segmentIndex, annotationUIDs] of annotationUIDsMap.entries()) {\r\n    const highlightedAnnotationUID = Array.from(annotationUIDs).find(\r\n      (annotationUID) => getAnnotation(annotationUID).highlighted\r\n    );\r\n\r\n    if (highlightedAnnotationUID) {\r\n      return segmentIndex;\r\n    }\r\n  }\r\n\r\n  return undefined;\r\n}\r\n","import { cache, utilities } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport {\r\n  getSegmentation,\r\n  getSegmentationIdRepresentations,\r\n} from '../../stateManagement/segmentation/segmentationState';\r\nimport {\r\n  LabelmapSegmentationDataStack,\r\n  LabelmapSegmentationDataVolume,\r\n} from '../../types/LabelmapTypes';\r\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\r\n\r\ntype Options = {\r\n  viewport?: Types.IViewport;\r\n  searchRadius?: number;\r\n};\r\n\r\n/**\r\n * Retrieves the segment index at the border of a labelmap in a segmentation.\r\n *\r\n * @param segmentationId - The ID of the segmentation.\r\n * @param worldPoint - The world coordinates of the point.\r\n * @param options - Additional options.\r\n * @param options.viewport - The viewport to use.\r\n * @param options.searchRadius - The search radius to use.\r\n * @returns The segment index at the labelmap border, or undefined if not found.\r\n */\r\nexport function getSegmentAtLabelmapBorder(\r\n  segmentationId: string,\r\n  worldPoint: Types.Point3,\r\n  { viewport, searchRadius }: Options\r\n): number {\r\n  const segmentation = getSegmentation(segmentationId);\r\n\r\n  const labelmapData = segmentation.representationData.LABELMAP;\r\n\r\n  if (isVolumeSegmentation(labelmapData)) {\r\n    const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\r\n    const segmentationVolume = cache.getVolume(volumeId);\r\n\r\n    if (!segmentationVolume) {\r\n      return;\r\n    }\r\n\r\n    const imageData = segmentationVolume.imageData;\r\n\r\n    const segmentIndex = imageData.getScalarValueFromWorld(worldPoint);\r\n\r\n    const canvasPoint = viewport.worldToCanvas(worldPoint);\r\n\r\n    const onEdge = isSegmentOnEdgeCanvas(\r\n      canvasPoint as Types.Point2,\r\n      segmentIndex,\r\n      viewport,\r\n      imageData,\r\n      searchRadius\r\n    );\r\n\r\n    return onEdge ? segmentIndex : undefined;\r\n  }\r\n\r\n  // stack segmentation case\r\n  const { imageIdReferenceMap } = labelmapData as LabelmapSegmentationDataStack;\r\n\r\n  const currentImageId = (viewport as Types.IStackViewport).getCurrentImageId();\r\n\r\n  const segmentationImageId = imageIdReferenceMap.get(currentImageId);\r\n  const image = cache.getImage(segmentationImageId);\r\n\r\n  if (!image) {\r\n    return;\r\n  }\r\n\r\n  // find the first segmentationRepresentationUID for the segmentationId, since\r\n  // that is what we use as actorUID in the viewport\r\n\r\n  const segmentationRepresentations = getSegmentationIdRepresentations(\r\n    segmentation.segmentationId\r\n  );\r\n\r\n  const { segmentationRepresentationUID } = segmentationRepresentations[0];\r\n  const segmentationActor = viewport.getActor(segmentationRepresentationUID);\r\n  const imageData = segmentationActor?.actor.getMapper().getInputData();\r\n  const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\r\n\r\n  const dimensions = imageData.getDimensions();\r\n  const voxelManager = (imageData.voxelManager ||\r\n    utilities.VoxelManager.createVolumeVoxelManager(\r\n      dimensions,\r\n      imageData.getPointData().getScalars().getData()\r\n    )) as utilities.VoxelManager<number>;\r\n\r\n  const segmentIndex = voxelManager.getAtIJKPoint(indexIJK as Types.Point3);\r\n\r\n  const onEdge = isSegmentOnEdgeIJK(\r\n    indexIJK as Types.Point3,\r\n    dimensions,\r\n    voxelManager,\r\n    segmentIndex\r\n  );\r\n\r\n  return onEdge ? segmentIndex : undefined;\r\n}\r\n\r\n/**\r\n * Checks if a segment is on the edge of a labelmap.\r\n * @param getNeighborIndex - A function that returns the neighbor index given the delta values.\r\n * @param segmentIndex - The index of the segment to check.\r\n * @param searchRadius - The radius within which to search for neighboring segments. Default is 1.\r\n * @returns A boolean indicating whether the segment is on the edge.\r\n */\r\nfunction isSegmentOnEdge(\r\n  getNeighborIndex: (\r\n    deltaI: number,\r\n    deltaJ: number,\r\n    deltaK: number\r\n  ) => number | undefined,\r\n  segmentIndex: number,\r\n  searchRadius = 1 // Default search radius\r\n): boolean {\r\n  const neighborRange = Array.from(\r\n    { length: 2 * searchRadius + 1 },\r\n    (_, i) => i - searchRadius\r\n  );\r\n\r\n  for (const deltaI of neighborRange) {\r\n    for (const deltaJ of neighborRange) {\r\n      for (const deltaK of neighborRange) {\r\n        if (deltaI === 0 && deltaJ === 0 && deltaK === 0) {\r\n          continue; // Skipping the central point\r\n        }\r\n\r\n        const neighborIndex = getNeighborIndex(deltaI, deltaJ, deltaK);\r\n\r\n        if (neighborIndex !== undefined && segmentIndex !== neighborIndex) {\r\n          return true; // On the edge\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return false; // No edge neighbors found\r\n}\r\n\r\nfunction isSegmentOnEdgeIJK(\r\n  indexIJK: Types.Point3,\r\n  dimensions: Types.Point3,\r\n  voxelManager: any,\r\n  segmentIndex: number,\r\n  searchRadius?: number\r\n): boolean {\r\n  const getNeighborIndex = (deltaI: number, deltaJ: number, deltaK: number) => {\r\n    const neighborIJK = [\r\n      indexIJK[0] + deltaI,\r\n      indexIJK[1] + deltaJ,\r\n      indexIJK[2] + deltaK,\r\n    ];\r\n\r\n    return voxelManager.getAtIJK(...neighborIJK);\r\n  };\r\n\r\n  return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\r\n}\r\n\r\nfunction isSegmentOnEdgeCanvas(\r\n  canvasPoint: Types.Point2,\r\n  segmentIndex: number,\r\n  viewport: Types.IViewport,\r\n  imageData: any,\r\n  searchRadius?: number\r\n): boolean {\r\n  const getNeighborIndex = (deltaI: number, deltaJ: number) => {\r\n    const neighborCanvas = [canvasPoint[0] + deltaI, canvasPoint[1] + deltaJ];\r\n\r\n    const worldPoint = viewport.canvasToWorld(neighborCanvas as Types.Point2);\r\n    return imageData.getScalarValueFromWorld(worldPoint);\r\n  };\r\n\r\n  return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\r\n}\r\n","import { cache, utilities } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport { SegmentationRepresentations } from '../../enums';\r\nimport {\r\n  getSegmentation,\r\n  getSegmentationIdRepresentations,\r\n} from '../../stateManagement/segmentation/segmentationState';\r\nimport {\r\n  LabelmapSegmentationDataStack,\r\n  LabelmapSegmentationDataVolume,\r\n} from '../../types/LabelmapTypes';\r\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\r\nimport { ContourSegmentationAnnotation, Segmentation } from '../../types';\r\nimport { getAnnotation } from '../../stateManagement';\r\nimport { isPointInsidePolyline3D } from '../math/polyline';\r\n\r\ntype Options = {\r\n  representationType?: SegmentationRepresentations;\r\n  viewport?: Types.IViewport;\r\n};\r\n\r\n/**\r\n * Get the segment at the specified world point in the viewport.\r\n * @param segmentationId - The ID of the segmentation to get the segment for.\r\n * @param worldPoint - The world point to get the segment for.\r\n *\r\n * @returns The index of the segment at the world point, or undefined if not found.\r\n */\r\nexport function getSegmentAtWorldPoint(\r\n  segmentationId: string,\r\n  worldPoint: Types.Point3,\r\n  options = {} as Options\r\n): number {\r\n  const segmentation = getSegmentation(segmentationId);\r\n\r\n  const representationData = segmentation.representationData;\r\n\r\n  // if representationType is not provided, we will use the first representation\r\n  const desiredRepresentation =\r\n    options?.representationType ?? Object.keys(representationData)[0];\r\n\r\n  if (!desiredRepresentation) {\r\n    throw new Error(\r\n      `Segmentation ${segmentationId} does not have any representations`\r\n    );\r\n  }\r\n\r\n  switch (desiredRepresentation) {\r\n    case SegmentationRepresentations.Labelmap:\r\n      return getSegmentAtWorldForLabelmap(segmentation, worldPoint, options);\r\n    case SegmentationRepresentations.Contour:\r\n      return getSegmentAtWorldForContour(segmentation, worldPoint, options);\r\n    default:\r\n      return;\r\n  }\r\n}\r\n\r\n/**\r\n * Retrieves the segment index at a given world point for a labelmap.\r\n *\r\n * @param labelmapData - The labelmap segmentation data.\r\n * @param worldPoint - The world point to retrieve the segment at.\r\n *\r\n * @returns The segment index at the given world point, or undefined if not found.\r\n */\r\nexport function getSegmentAtWorldForLabelmap(\r\n  segmentation: Segmentation,\r\n  worldPoint: Types.Point3,\r\n  { viewport }: Options\r\n): number | undefined {\r\n  const labelmapData = segmentation.representationData.LABELMAP;\r\n\r\n  if (isVolumeSegmentation(labelmapData)) {\r\n    const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\r\n    const segmentationVolume = cache.getVolume(volumeId);\r\n\r\n    if (!segmentationVolume) {\r\n      return;\r\n    }\r\n\r\n    const segmentIndex =\r\n      segmentationVolume.imageData.getScalarValueFromWorld(worldPoint);\r\n\r\n    return segmentIndex;\r\n  }\r\n\r\n  // stack segmentation case\r\n  const { imageIdReferenceMap } = labelmapData as LabelmapSegmentationDataStack;\r\n\r\n  const currentImageId = (viewport as Types.IStackViewport).getCurrentImageId();\r\n\r\n  const segmentationImageId = imageIdReferenceMap.get(currentImageId);\r\n  const image = cache.getImage(segmentationImageId);\r\n\r\n  if (!image) {\r\n    return;\r\n  }\r\n\r\n  // find the first segmentationRepresentationUID for the segmentationId, since\r\n  // that is what we use as actorUID in the viewport\r\n\r\n  const segmentationRepresentations = getSegmentationIdRepresentations(\r\n    segmentation.segmentationId\r\n  );\r\n\r\n  const { segmentationRepresentationUID } = segmentationRepresentations[0];\r\n\r\n  const segmentationActor = viewport.getActor(segmentationRepresentationUID);\r\n  const imageData = segmentationActor?.actor.getMapper().getInputData();\r\n  const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\r\n\r\n  const dimensions = imageData.getDimensions();\r\n  const voxelManager = (imageData.voxelManager ||\r\n    utilities.VoxelManager.createVolumeVoxelManager(\r\n      dimensions,\r\n      imageData.getPointData().getScalars().getData()\r\n    )) as utilities.VoxelManager<number>;\r\n\r\n  const segmentIndex = voxelManager.getAtIJKPoint(indexIJK as Types.Point3);\r\n\r\n  return segmentIndex;\r\n}\r\n\r\n/**\r\n * Retrieves the segment index at a given world point for contour segmentation.\r\n *\r\n * @param segmentation - The segmentation data.\r\n * @param worldPoint - The world point to check.\r\n * @param options - The options for segmentation.\r\n * @returns The segment index at the given world point, or undefined if not found.\r\n */\r\nexport function getSegmentAtWorldForContour(\r\n  segmentation: Segmentation,\r\n  worldPoint: Types.Point3,\r\n  { viewport }: Options\r\n): number {\r\n  const contourData = segmentation.representationData.CONTOUR;\r\n\r\n  const segmentIndices = Array.from(contourData.annotationUIDsMap.keys());\r\n  const { viewPlaneNormal } = viewport.getCamera();\r\n\r\n  for (const segmentIndex of segmentIndices) {\r\n    const annotationsSet = contourData.annotationUIDsMap.get(segmentIndex);\r\n\r\n    if (!annotationsSet) {\r\n      continue;\r\n    }\r\n\r\n    for (const annotationUID of annotationsSet) {\r\n      const annotation = getAnnotation(\r\n        annotationUID\r\n      ) as ContourSegmentationAnnotation;\r\n\r\n      if (!annotation) {\r\n        continue;\r\n      }\r\n\r\n      const { polyline } = annotation.data.contour;\r\n\r\n      if (\r\n        !utilities.isEqual(viewPlaneNormal, annotation.metadata.viewPlaneNormal)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // This function checks whether we are inside the contour. It does not\r\n      // check if we are exactly on the contour, which is highly unlikely given\r\n      // the canvas pixel resolution of 1 decimal place we have by design.\r\n      if (isPointInsidePolyline3D(worldPoint, polyline)) {\r\n        return Number(segmentIndex);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { getToolGroup } from '../../store/ToolGroupManager';\r\nimport BrushTool from '../../tools/segmentation/BrushTool';\r\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\r\nimport { getRenderingEngine } from '@cornerstonejs/core';\r\nimport { getBrushToolInstances } from './utilities';\r\n\r\n/**\r\n * Invalidates the brush cursor for a specific tool group.\r\n * This function triggers the update of the brush being rendered.\r\n * It also triggers an annotation render for any viewports on the tool group.\r\n *\r\n * @param toolGroupId - The ID of the tool group.\r\n */\r\nexport function invalidateBrushCursor(toolGroupId: string): void {\r\n  const toolGroup = getToolGroup(toolGroupId);\r\n\r\n  if (toolGroup === undefined) {\r\n    return;\r\n  }\r\n\r\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\r\n\r\n  brushBasedToolInstances.forEach((tool: BrushTool) => {\r\n    // Invalidate the brush being rendered so it can update.\r\n    tool.invalidateBrushCursor();\r\n  });\r\n\r\n  // Trigger an annotation render for any viewports on the toolgroup\r\n  const viewportsInfo = toolGroup.getViewportsInfo();\r\n\r\n  const viewportsInfoArray = Object.keys(viewportsInfo).map(\r\n    (key) => viewportsInfo[key]\r\n  );\r\n\r\n  if (!viewportsInfoArray.length) {\r\n    return;\r\n  }\r\n\r\n  const { renderingEngineId } = viewportsInfoArray[0];\r\n\r\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\r\n  // ourselves here.\r\n  const viewportIds = toolGroup.getViewportIds();\r\n\r\n  const renderingEngine = getRenderingEngine(renderingEngineId);\r\n\r\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\r\n}\r\n","import { isValidLabelmapConfig } from '../../tools/displayTools/Labelmap/labelmapConfig';\r\nimport SegmentationRepresentation from '../../enums/SegmentationRepresentations';\r\nimport { RepresentationConfig } from '../../types/SegmentationStateTypes';\r\n\r\n/**\r\n * Given a representation type and a configuration, return true if the\r\n * configuration is valid for that representation type\r\n * @param representationType - The type of segmentation representation\r\n * @param config - RepresentationConfig\r\n * @returns A boolean value.\r\n */\r\nexport default function isValidRepresentationConfig(\r\n  representationType: string,\r\n  config: RepresentationConfig\r\n): boolean {\r\n  switch (representationType) {\r\n    case SegmentationRepresentation.Labelmap:\r\n      return isValidLabelmapConfig(config);\r\n    default:\r\n      throw new Error(`Unknown representation type: ${representationType}`);\r\n  }\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport { state } from '../../stateManagement/annotation';\r\nimport {\r\n  RectangleROIStartEndThresholdTool,\r\n  RectangleROIThresholdTool,\r\n} from '../../tools';\r\n\r\nimport thresholdVolumeByRange from './thresholdVolumeByRange';\r\nimport getBoundsIJKFromRectangleAnnotations from '../rectangleROITool/getBoundsIJKFromRectangleAnnotations';\r\nimport { ThresholdInformation } from './utilities';\r\n\r\nexport type ThresholdOptions = {\r\n  numSlicesToProject?: number; // number of slices to project before and after current slice\r\n  overwrite: boolean;\r\n  overlapType?: number; // type of the voxel overlap\r\n  segmentIndex?: number; // segment index to threshold\r\n};\r\n\r\nexport type AnnotationForThresholding = {\r\n  data: {\r\n    handles: {\r\n      points: Types.Point3[];\r\n    };\r\n    cachedStats?: {\r\n      projectionPoints?: Types.Point3[][];\r\n    };\r\n  };\r\n};\r\n\r\n/**\r\n * It uses the provided rectangleROI annotations (either RectangleROIThreshold, or\r\n * RectangleROIStartEndThreshold) to compute an ROI that is the intersection of\r\n * all the annotations. Then it uses the rectangleROIThreshold utility to threshold\r\n * the volume.\r\n * @param annotationUIDs - rectangleROI annotationsUIDs to use for ROI\r\n * @param segmentationVolume - the segmentation volume\r\n * @param thresholdVolumeInformation - object array containing the volume data and range threshold values\r\n * @param options - options for thresholding\r\n * @returns\r\n */\r\nfunction rectangleROIThresholdVolumeByRange(\r\n  annotationUIDs: string[],\r\n  segmentationVolume: Types.IImageVolume,\r\n  thresholdVolumeInformation: ThresholdInformation[],\r\n  options: ThresholdOptions\r\n): Types.IImageVolume {\r\n  const annotations = annotationUIDs.map((annotationUID) => {\r\n    return state.getAnnotation(annotationUID);\r\n  });\r\n\r\n  _validateAnnotations(annotations);\r\n\r\n  let boundsIJK;\r\n  for (let i = 0; i < thresholdVolumeInformation.length; i++) {\r\n    // make sure that the boundsIJK are generated by the correct volume\r\n    const volumeSize =\r\n      thresholdVolumeInformation[i].volume.getScalarData().length;\r\n    if (volumeSize === segmentationVolume.getScalarData().length || i === 0) {\r\n      boundsIJK = getBoundsIJKFromRectangleAnnotations(\r\n        annotations,\r\n        thresholdVolumeInformation[i].volume,\r\n        options\r\n      );\r\n    }\r\n  }\r\n\r\n  const outputSegmentationVolume = thresholdVolumeByRange(\r\n    segmentationVolume,\r\n    thresholdVolumeInformation,\r\n    { ...options, boundsIJK }\r\n  );\r\n\r\n  outputSegmentationVolume.modified();\r\n\r\n  return outputSegmentationVolume;\r\n}\r\n\r\nfunction _validateAnnotations(annotations) {\r\n  const validToolNames = [\r\n    RectangleROIThresholdTool.toolName,\r\n    RectangleROIStartEndThresholdTool.toolName,\r\n  ];\r\n\r\n  for (const annotation of annotations) {\r\n    const name = annotation.metadata.toolName;\r\n    if (!validToolNames.includes(name)) {\r\n      throw new Error(\r\n        'rectangleROIThresholdVolumeByRange only supports RectangleROIThreshold and RectangleROIStartEndThreshold annotations'\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport default rectangleROIThresholdVolumeByRange;\r\n","import { getEnabledElement, type Types } from '@cornerstonejs/core';\r\n\r\nimport type { Annotation } from '../../types/AnnotationTypes';\r\nimport * as segmentation from '../../stateManagement/segmentation';\r\nimport {\r\n  state as annotationState,\r\n  config as annotationConfig,\r\n} from '../../stateManagement/annotation';\r\nimport { jumpToSlice } from '../viewport';\r\nimport contourAndFindLargestBidirectional from './contourAndFindLargestBidirectional';\r\nimport createBidirectionalToolData from './createBidirectionalToolData';\r\nimport BidirectionalTool from '../../tools/annotation/BidirectionalTool';\r\n\r\nexport type Segment = {\r\n  segmentationId: string;\r\n  segmentIndex: number;\r\n  label: string;\r\n\r\n  style?: any;\r\n  containedSegmentIndices?: (number) => boolean;\r\n};\r\n\r\nexport type SegmentContourActionConfiguration = {\r\n  getSegment?: (\r\n    enabledElement: Types.IEnabledElement,\r\n    configuration: SegmentContourActionConfiguration\r\n  ) => Segment;\r\n\r\n  /**\r\n   * Optional map for data about each segment\r\n   */\r\n  segmentationId?: string;\r\n  segmentIndex?: number;\r\n  segmentData?: Map<number, Segment>;\r\n  toolGroupId?: string;\r\n};\r\n\r\nexport default function segmentContourAction(\r\n  element: HTMLDivElement,\r\n  configuration\r\n) {\r\n  const { data: configurationData } = configuration;\r\n  const enabledElement = getEnabledElement(element);\r\n  const segment = (configurationData.getSegment || defaultGetSegment)(\r\n    enabledElement,\r\n    configurationData\r\n  );\r\n  if (!segment) {\r\n    return;\r\n  }\r\n  const FrameOfReferenceUID = enabledElement.viewport.getFrameOfReferenceUID();\r\n  const segmentationsList = segmentation.state.getSegmentations();\r\n  const { segmentIndex, segmentationId } = segment;\r\n  const bidirectionals = annotationState.getAnnotations(\r\n    this.toolName || BidirectionalTool.toolName,\r\n    FrameOfReferenceUID\r\n  );\r\n  let hasExistingActiveSegment = false;\r\n  const existingLargestBidirectionals = bidirectionals.filter(\r\n    (existingBidirectionalItem) => {\r\n      const { segment } = existingBidirectionalItem.data;\r\n      if (!segment) {\r\n        return;\r\n      }\r\n      if (\r\n        segment.segmentationId === segmentationId &&\r\n        segment.segmentIndex === segmentIndex\r\n      ) {\r\n        hasExistingActiveSegment = true;\r\n        existingBidirectionalItem.data.segment = segment;\r\n      }\r\n      return !!segment;\r\n    }\r\n  );\r\n  if (!hasExistingActiveSegment) {\r\n    // Just create a dummy annotation object containing just enough information\r\n    // to create a real one.\r\n    existingLargestBidirectionals.push({\r\n      data: { segment },\r\n    } as unknown as Annotation);\r\n  }\r\n\r\n  let newBidirectional;\r\n  existingLargestBidirectionals.forEach((existingLargestBidirectional) => {\r\n    const segments = [];\r\n    const { segment: updateSegment } = existingLargestBidirectional.data;\r\n    const { segmentIndex, segmentationId } = updateSegment;\r\n    segments[segmentIndex] = updateSegment;\r\n    annotationState.removeAnnotation(\r\n      existingLargestBidirectional.annotationUID\r\n    );\r\n    const bidirectionalData = contourAndFindLargestBidirectional({\r\n      ...segmentationsList.find(\r\n        (segmentation) => segmentation.segmentationId === segmentationId\r\n      ),\r\n      segments,\r\n    });\r\n\r\n    if (!bidirectionalData) {\r\n      return;\r\n    }\r\n    const bidirectionalToolData = createBidirectionalToolData(\r\n      bidirectionalData,\r\n      enabledElement.viewport\r\n    );\r\n    bidirectionalToolData.annotationUID =\r\n      existingLargestBidirectional.annotationUID;\r\n    bidirectionalToolData.data.segment = updateSegment;\r\n\r\n    const annotationUID = annotationState.addAnnotation(\r\n      bidirectionalToolData,\r\n      FrameOfReferenceUID\r\n    );\r\n\r\n    if (\r\n      updateSegment.segmentIndex === segment.segmentIndex &&\r\n      updateSegment.segmentationId === segment.segmentationId\r\n    ) {\r\n      newBidirectional = bidirectionalData;\r\n      const { style } = segment;\r\n      if (style) {\r\n        annotationConfig.style.setAnnotationStyles(annotationUID, style);\r\n      }\r\n    }\r\n  });\r\n\r\n  if (newBidirectional) {\r\n    const { sliceIndex } = newBidirectional;\r\n    const imageIds = enabledElement.viewport.getImageIds();\r\n\r\n    // TODO - figure out why this is reversed\r\n    jumpToSlice(element, {\r\n      imageIndex: imageIds.length - 1 - sliceIndex,\r\n    });\r\n    enabledElement.viewport.render();\r\n  } else {\r\n    console.warn('No bidirectional found');\r\n  }\r\n\r\n  return newBidirectional;\r\n}\r\n\r\nexport function defaultGetSegment(\r\n  enabledElement: Types.IEnabledElement,\r\n  configuration: SegmentContourActionConfiguration\r\n): Segment {\r\n  const segmentationsList = segmentation.state.getSegmentations();\r\n  if (!segmentationsList.length) {\r\n    return;\r\n  }\r\n  const segmentationId =\r\n    configuration.segmentationId || segmentationsList[0].segmentationId;\r\n  const segmentIndex =\r\n    configuration.segmentIndex ??\r\n    segmentation.segmentIndex.getActiveSegmentIndex(segmentationId);\r\n  if (!segmentIndex) {\r\n    return;\r\n  }\r\n  const segmentData = configuration.segmentData?.get(segmentIndex);\r\n  return {\r\n    label: `Segment ${segmentIndex}`,\r\n    segmentIndex,\r\n    segmentationId,\r\n    ...segmentData,\r\n  };\r\n}\r\n","import { Types } from '@cornerstonejs/core';\r\nimport { pointInShapeCallback } from '../../utilities';\r\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\r\nimport {\r\n  getVoxelOverlap,\r\n  processVolumes,\r\n  ThresholdInformation,\r\n} from './utilities';\r\n\r\n/**\r\n * It thresholds a segmentation volume based on a set of threshold values with\r\n * respect to a list of volumes and respective threshold ranges.\r\n * @param segmentationVolume - the segmentation volume to be modified\r\n * @param segmentationIndex - the index of the segmentation to modify\r\n * @param thresholdVolumeInformation - array of objects containing volume data\r\n * and a range (lower and upper values) to threshold\r\n * @param overlapType - indicates if the user requires all voxels pass\r\n * (overlapType = 1) or any voxel pass (overlapType = 0)\r\n * @returns\r\n */\r\nfunction thresholdSegmentationByRange(\r\n  segmentationVolume: Types.IImageVolume,\r\n  segmentationIndex: number,\r\n  thresholdVolumeInformation: ThresholdInformation[],\r\n  overlapType: number\r\n): Types.IImageVolume {\r\n  const scalarData = segmentationVolume.getScalarData();\r\n\r\n  // prepare a list of volume information objects for callback functions\r\n  const { baseVolumeIdx, volumeInfoList } = processVolumes(\r\n    segmentationVolume,\r\n    thresholdVolumeInformation\r\n  );\r\n\r\n  /**\r\n   * This function will test all overlaps between a voxel in base volume\r\n   * (the reference for segmentation volume creation) and voxels in other\r\n   * volumes.\r\n   * If the segmentation volume and the image volume are the same size,\r\n   * checks if the scalar data at each point is within the threshold values.\r\n   * If the segmentation volume and the image volume are different sizes,\r\n   * checks the voxel overlap\r\n   */\r\n  volumeInfoList.forEach((volumeInfo) => {\r\n    const { volumeSize } = volumeInfo;\r\n\r\n    if (volumeSize === scalarData.length) {\r\n      _handleSameSizeVolume(scalarData, segmentationIndex, volumeInfo);\r\n    } else {\r\n      _handleDifferentSizeVolume(\r\n        scalarData,\r\n        segmentationIndex,\r\n        volumeInfo,\r\n        volumeInfoList,\r\n        baseVolumeIdx,\r\n        overlapType\r\n      );\r\n    }\r\n  });\r\n\r\n  triggerSegmentationDataModified(segmentationVolume.volumeId);\r\n\r\n  return segmentationVolume;\r\n}\r\n\r\nfunction _handleDifferentSizeVolume(\r\n  scalarData: Types.PixelDataTypedArray,\r\n  segmentationIndex: number,\r\n  volumeInfo: any,\r\n  volumeInfoList: any,\r\n  baseVolumeIdx: number,\r\n  overlapType: number\r\n) {\r\n  const { imageData, lower, upper, dimensions } = volumeInfo;\r\n\r\n  let total, overlaps, range;\r\n\r\n  for (let i = 0; i < scalarData.length; i++) {\r\n    if (scalarData[i] === segmentationIndex) {\r\n      const overlapBounds = getVoxelOverlap(\r\n        imageData,\r\n        dimensions,\r\n        volumeInfoList[baseVolumeIdx].spacing,\r\n        volumeInfoList[baseVolumeIdx].imageData.getPoint(i)\r\n      );\r\n\r\n      const callbackOverlap = ({ value }) => {\r\n        total = total + 1;\r\n        if (value >= range.lower && value <= range.upper) {\r\n          overlaps = overlaps + 1;\r\n        }\r\n      };\r\n\r\n      total = 0;\r\n      overlaps = 0;\r\n      range = { lower, upper };\r\n      let overlapTest = false;\r\n\r\n      // check all voxel overlaps\r\n      pointInShapeCallback(\r\n        imageData,\r\n        () => true,\r\n        callbackOverlap,\r\n        overlapBounds\r\n      );\r\n\r\n      overlapTest = overlapType === 0 ? overlaps > 0 : overlaps === total;\r\n      scalarData[i] = overlapTest ? segmentationIndex : 0;\r\n    }\r\n  }\r\n  return { total, range, overlaps };\r\n}\r\n\r\nfunction _handleSameSizeVolume(\r\n  scalarData: Types.PixelDataTypedArray,\r\n  segmentationIndex: number,\r\n  volumeInfo: any\r\n) {\r\n  const { referenceValues, lower, upper } = volumeInfo;\r\n\r\n  for (let i = 0; i < scalarData.length; i++) {\r\n    if (scalarData[i] === segmentationIndex) {\r\n      const value = referenceValues[i];\r\n      scalarData[i] = value >= lower && value <= upper ? segmentationIndex : 0;\r\n    }\r\n  }\r\n}\r\n\r\nexport default thresholdSegmentationByRange;\r\n","import { Types } from '@cornerstonejs/core';\r\nimport { pointInShapeCallback } from '../../utilities';\r\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\r\nimport { BoundsIJK } from '../../types';\r\nimport {\r\n  getVoxelOverlap,\r\n  processVolumes,\r\n  ThresholdInformation,\r\n} from './utilities';\r\n\r\nexport type ThresholdRangeOptions = {\r\n  overwrite: boolean;\r\n  boundsIJK: BoundsIJK;\r\n  overlapType?: number;\r\n  segmentIndex?: number;\r\n};\r\n\r\n/**\r\n * It thresholds a segmentation volume based on a set of threshold values with\r\n * respect to a list of volumes and respective threshold ranges.\r\n * @param segmentationVolume - the segmentation volume to be modified\r\n * @param thresholdVolumeInformation - array of objects containing volume data\r\n * and a range (lower and upper values) to threshold\r\n * @param options - the options for thresholding\r\n * As there is a chance the volumes might have different dimensions and spacing,\r\n * could be the case of no 1 to 1 mapping. So we need to work with the idea of\r\n * voxel overlaps (1 to many mappings). We consider all intersections valid, to\r\n * avoid the complexity to calculate a minimum voxel intersection percentage.\r\n * This function, given a voxel center and spacing, calculates the overlap of\r\n * the voxel with another volume and range check the voxels in the overlap.\r\n * Three situations can occur: all voxels pass the range check, some voxels pass\r\n * or none voxels pass. The overlapType parameter indicates if the user requires\r\n * all voxels pass (overlapType = 1) or any voxel pass (overlapType = 0)\r\n *\r\n * @returns segmented volume\r\n */\r\nfunction thresholdVolumeByRange(\r\n  segmentationVolume: Types.IImageVolume,\r\n  thresholdVolumeInformation: ThresholdInformation[],\r\n  options: ThresholdRangeOptions,\r\n): Types.IImageVolume {\r\n  const { imageData: segmentationImageData } = segmentationVolume;\r\n  const scalarData = segmentationVolume.getScalarData();\r\n\r\n  const { overwrite, boundsIJK } = options;\r\n  const overlapType = options?.overlapType || 0;\r\n\r\n  // set the segmentation to all zeros\r\n  if (overwrite) {\r\n    for (let i = 0; i < scalarData.length; i++) {\r\n      scalarData[i] = 0;\r\n    }\r\n  }\r\n\r\n  const { baseVolumeIdx, volumeInfoList } = processVolumes(\r\n    segmentationVolume,\r\n    thresholdVolumeInformation\r\n  );\r\n\r\n  // global variables used in callbackOverlap function\r\n  let overlaps, total, range;\r\n\r\n  const testOverlapRange = (volumeInfo, voxelSpacing, voxelCenter) => {\r\n    /**\r\n     * This callback function will test all overlaps between a voxel in base\r\n     * volume (the reference for segmentation volume creation) and voxels in other\r\n     * volumes.\r\n     */\r\n    const callbackOverlap = ({ value }) => {\r\n      total = total + 1;\r\n      if (value >= range.lower && value <= range.upper) {\r\n        overlaps = overlaps + 1;\r\n      }\r\n    };\r\n\r\n    const { imageData, dimensions, lower, upper } = volumeInfo;\r\n\r\n    const overlapBounds = getVoxelOverlap(\r\n      imageData,\r\n      dimensions,\r\n      voxelSpacing,\r\n      voxelCenter\r\n    );\r\n\r\n    // reset global variables and setting the range check\r\n    total = 0;\r\n    overlaps = 0;\r\n    range = { lower, upper };\r\n\r\n    let overlapTest = false;\r\n\r\n    // check all voxel overlaps\r\n    pointInShapeCallback(imageData, () => true, callbackOverlap, overlapBounds);\r\n\r\n    if (overlapType === 0) {\r\n      overlapTest = overlaps > 0; // any voxel overlap is accepted\r\n    } else if (overlapType == 1) {\r\n      overlapTest = overlaps === total; // require all voxel overlaps\r\n    }\r\n    return overlapTest;\r\n  };\r\n\r\n  // range checks a voxel in a volume with same dimension as the segmentation\r\n  const testRange = (volumeInfo, pointIJK) => {\r\n    const { imageData, referenceValues, lower, upper } = volumeInfo;\r\n    const offset = imageData.computeOffsetIndex(pointIJK);\r\n\r\n    const value = referenceValues[offset];\r\n    // console.log('VALUE', value, lower, upper)\r\n    if (value <= lower || value >= upper) {\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * This callback function will test all overlaps between a voxel in base\r\n   * volume (the reference for segmentation volume creation) and voxels in other\r\n   * volumes.\r\n   */\r\n  const callback = ({ index, pointIJK, pointLPS }) => {\r\n    let insert = volumeInfoList.length > 0;\r\n    for (let i = 0; i < volumeInfoList.length; i++) {\r\n      // if volume has the same size as segmentation volume, just range check\r\n      if (volumeInfoList[i].volumeSize === scalarData.length) {\r\n        insert = testRange(volumeInfoList[i], pointIJK);\r\n      } else {\r\n        // if not, need to calculate overlaps\r\n        insert = testOverlapRange(\r\n          volumeInfoList[i],\r\n          volumeInfoList[baseVolumeIdx].spacing,\r\n          pointLPS\r\n        );\r\n      }\r\n      if (!insert) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (insert) {\r\n      scalarData[index] = options.segmentIndex || 1;\r\n    }\r\n  };\r\n\r\n  pointInShapeCallback(segmentationImageData, () => true, callback, boundsIJK);\r\n\r\n  triggerSegmentationDataModified(segmentationVolume.volumeId);\r\n\r\n  return segmentationVolume;\r\n}\r\n\r\nexport default thresholdVolumeByRange;\r\n","import { Types } from '@cornerstonejs/core';\r\nimport { utilities as csUtils } from '@cornerstonejs/core';\r\nimport { getToolGroup } from '../../store/ToolGroupManager';\r\nimport BrushTool from '../../tools/segmentation/BrushTool';\r\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\r\n\r\nexport type ThresholdInformation = {\r\n  volume: Types.IImageVolume;\r\n  lower: number;\r\n  upper: number;\r\n};\r\n\r\nexport function getBrushToolInstances(toolGroupId: string, toolName?: string) {\r\n  const toolGroup = getToolGroup(toolGroupId);\r\n\r\n  if (toolGroup === undefined) {\r\n    return;\r\n  }\r\n\r\n  const toolInstances = toolGroup._toolInstances;\r\n\r\n  if (!Object.keys(toolInstances).length) {\r\n    return;\r\n  }\r\n\r\n  if (toolName && toolInstances[toolName]) {\r\n    return [toolInstances[toolName]];\r\n  }\r\n\r\n  // For each tool that has BrushTool as base class, set the brush size.\r\n  const brushBasedToolInstances = Object.values(toolInstances).filter(\r\n    (toolInstance) => toolInstance instanceof BrushTool\r\n  ) as BrushTool[];\r\n\r\n  return brushBasedToolInstances;\r\n}\r\n\r\nconst equalsCheck = (a, b) => {\r\n  return JSON.stringify(a) === JSON.stringify(b);\r\n};\r\n\r\n/**\r\n * Given the center of a voxel in world coordinates, calculate the voxel\r\n * corners in world coords to calculate the voxel overlap in another volume\r\n */\r\nexport function getVoxelOverlap(\r\n  imageData,\r\n  dimensions,\r\n  voxelSpacing,\r\n  voxelCenter\r\n) {\r\n  const voxelCornersWorld = [];\r\n  for (let i = 0; i < 2; i++) {\r\n    for (let j = 0; j < 2; j++) {\r\n      for (let k = 0; k < 2; k++) {\r\n        const point = [...voxelCenter]; // Create a new point from voxelCenter\r\n        point[0] = point[0] + ((i * 2 - 1) * voxelSpacing[0]) / 2;\r\n        point[1] = point[1] + ((j * 2 - 1) * voxelSpacing[1]) / 2;\r\n        point[2] = point[2] + ((k * 2 - 1) * voxelSpacing[2]) / 2;\r\n        voxelCornersWorld.push(point);\r\n      }\r\n    }\r\n  }\r\n  const voxelCornersIJK = voxelCornersWorld.map(\r\n    (world) => csUtils.transformWorldToIndex(imageData, world) as Types.Point3\r\n  );\r\n  const overlapBounds = getBoundingBoxAroundShapeIJK(\r\n    voxelCornersIJK,\r\n    dimensions\r\n  );\r\n\r\n  return overlapBounds;\r\n}\r\n\r\n/**\r\n * Prepare a list of volume information objects for callback functions\r\n */\r\nexport function processVolumes(\r\n  segmentationVolume: Types.IImageVolume,\r\n  thresholdVolumeInformation: ThresholdInformation[]\r\n) {\r\n  const { spacing: segmentationSpacing } = segmentationVolume;\r\n  const scalarData = segmentationVolume.getScalarData();\r\n\r\n  // prepare a list of volume information objects for callback functions\r\n  const volumeInfoList = [];\r\n  let baseVolumeIdx = 0;\r\n  for (let i = 0; i < thresholdVolumeInformation.length; i++) {\r\n    const { imageData, spacing, dimensions } =\r\n      thresholdVolumeInformation[i].volume;\r\n\r\n    const volumeSize =\r\n      thresholdVolumeInformation[i].volume.getScalarData().length;\r\n    // discover the index of the volume the segmentation data is based on\r\n    if (\r\n      volumeSize === scalarData.length &&\r\n      equalsCheck(spacing, segmentationSpacing)\r\n    ) {\r\n      baseVolumeIdx = i;\r\n    }\r\n\r\n    // prepare information used in callback functions\r\n    const referenceValues = imageData.getPointData().getScalars().getData();\r\n    const lower = thresholdVolumeInformation[i].lower;\r\n    const upper = thresholdVolumeInformation[i].upper;\r\n\r\n    volumeInfoList.push({\r\n      imageData,\r\n      referenceValues,\r\n      lower,\r\n      upper,\r\n      spacing,\r\n      dimensions,\r\n      volumeSize,\r\n    });\r\n  }\r\n\r\n  return {\r\n    volumeInfoList,\r\n    baseVolumeIdx,\r\n  };\r\n}\r\n","import {\r\n  imageLoader,\r\n  Enums,\r\n  eventTarget,\r\n  imageLoadPoolManager,\r\n  cache,\r\n  getConfiguration as getCoreConfiguration,\r\n} from '@cornerstonejs/core';\r\nimport { addToolState, getToolState } from './state';\r\nimport {\r\n  getStackData,\r\n  requestType,\r\n  priority,\r\n  getPromiseRemovedHandler,\r\n  nearestIndex,\r\n  range,\r\n} from './stackPrefetchUtils';\r\n\r\nlet configuration = {\r\n  maxImagesToPrefetch: Infinity,\r\n  // Preserving the existing pool should be the default behaviour, as there might\r\n  // be a volume of the same series already being loaded in the pool, and we don't want\r\n  // to cancel it middle of the way when the other stack viewport mounts. Worst case scenario\r\n  // there will be a few extra images in the pool but by the time that their turn comes\r\n  // we will have already loaded the volume and it will get read from the CACHE,\r\n  // so who cares\r\n  preserveExistingPool: true,\r\n};\r\n\r\nlet resetPrefetchTimeout;\r\nconst resetPrefetchDelay = 10;\r\n\r\nfunction prefetch(element) {\r\n  // Get the stackPrefetch tool data\r\n  const stackPrefetchData = getToolState(element);\r\n\r\n  if (!stackPrefetchData) {\r\n    return;\r\n  }\r\n\r\n  const stackPrefetch = stackPrefetchData || {};\r\n  const stack = getStackData(element);\r\n\r\n  if (!stack?.imageIds?.length) {\r\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\r\n    return;\r\n  }\r\n\r\n  const { currentImageIdIndex } = stack;\r\n\r\n  // If all the requests are complete, disable the stackPrefetch tool\r\n  stackPrefetch.enabled &&= stackPrefetch.indicesToRequest?.length;\r\n\r\n  // Make sure the tool is still enabled\r\n  if (stackPrefetch.enabled === false) {\r\n    return;\r\n  }\r\n\r\n  // Remove an imageIdIndex from the list of indices to request\r\n  // This fires when the individual image loading deferred is resolved\r\n  function removeFromList(imageIdIndex) {\r\n    const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\r\n\r\n    if (index > -1) {\r\n      // Don't remove last element if imageIdIndex not found\r\n      stackPrefetch.indicesToRequest.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  // Remove all already cached images from the\r\n  // IndicesToRequest array\r\n  stackPrefetchData.indicesToRequest.sort((a, b) => a - b);\r\n  const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\r\n\r\n  indicesToRequestCopy.forEach(function (imageIdIndex) {\r\n    const imageId = stack.imageIds[imageIdIndex];\r\n\r\n    if (!imageId) {\r\n      return;\r\n    }\r\n\r\n    const distance = Math.abs(currentImageIdIndex - imageIdIndex);\r\n    // For nearby objects, ensure the last accessed time is updated\r\n    // by using getImageLoadObject.\r\n    // For more distant objects, just check if available, but dont\r\n    // change the access time.\r\n    // This allows throwing data that hasn't been accessed and is not\r\n    // nearby.\r\n    const imageCached =\r\n      distance < 6\r\n        ? cache.getImageLoadObject(imageId)\r\n        : cache.isLoaded(imageId);\r\n\r\n    if (imageCached) {\r\n      // Already in cache\r\n      removeFromList(imageIdIndex);\r\n    }\r\n  });\r\n\r\n  // Stop here if there are no images left to request\r\n  // After those in the cache have been removed\r\n  if (!stackPrefetch.indicesToRequest.length) {\r\n    return;\r\n  }\r\n\r\n  // Clear the requestPool of prefetch requests, if needed.\r\n  if (!configuration.preserveExistingPool) {\r\n    imageLoadPoolManager.clearRequestStack(requestType);\r\n  }\r\n\r\n  // Identify the nearest imageIdIndex to the currentImageIdIndex\r\n  const nearest = nearestIndex(\r\n    stackPrefetch.indicesToRequest,\r\n    stack.currentImageIdIndex\r\n  );\r\n\r\n  let imageId;\r\n  let nextImageIdIndex;\r\n  const preventCache = false;\r\n\r\n  function doneCallback(image) {\r\n    console.log('prefetch done: %s', image.imageId);\r\n    const imageIdIndex = stack.imageIds.indexOf(image.imageId);\r\n\r\n    removeFromList(imageIdIndex);\r\n  }\r\n\r\n  // Prefetch images around the current image (before and after)\r\n  let lowerIndex = nearest.low;\r\n  let higherIndex = nearest.high;\r\n  const imageIdsToPrefetch = [];\r\n\r\n  while (\r\n    lowerIndex >= 0 ||\r\n    higherIndex < stackPrefetch.indicesToRequest.length\r\n  ) {\r\n    const currentIndex = stack.currentImageIdIndex;\r\n    const shouldSkipLower =\r\n      currentIndex - stackPrefetch.indicesToRequest[lowerIndex] >\r\n      configuration.maxImagesToPrefetch;\r\n    const shouldSkipHigher =\r\n      stackPrefetch.indicesToRequest[higherIndex] - currentIndex >\r\n      configuration.maxImagesToPrefetch;\r\n\r\n    const shouldLoadLower = !shouldSkipLower && lowerIndex >= 0;\r\n    const shouldLoadHigher =\r\n      !shouldSkipHigher && higherIndex < stackPrefetch.indicesToRequest.length;\r\n\r\n    if (!shouldLoadHigher && !shouldLoadLower) {\r\n      break;\r\n    }\r\n\r\n    if (shouldLoadLower) {\r\n      nextImageIdIndex = stackPrefetch.indicesToRequest[lowerIndex--];\r\n      imageId = stack.imageIds[nextImageIdIndex];\r\n      imageIdsToPrefetch.push(imageId);\r\n    }\r\n\r\n    if (shouldLoadHigher) {\r\n      nextImageIdIndex = stackPrefetch.indicesToRequest[higherIndex++];\r\n      imageId = stack.imageIds[nextImageIdIndex];\r\n      imageIdsToPrefetch.push(imageId);\r\n    }\r\n  }\r\n\r\n  const requestFn = (imageId, options) =>\r\n    imageLoader.loadAndCacheImage(imageId, options);\r\n\r\n  const { useNorm16Texture, preferSizeOverAccuracy } =\r\n    getCoreConfiguration().rendering;\r\n\r\n  const useNativeDataType = useNorm16Texture || preferSizeOverAccuracy;\r\n\r\n  imageIdsToPrefetch.forEach((imageId) => {\r\n    // IMPORTANT: Request type should be passed if not the 'interaction'\r\n    // highest priority will be used for the request type in the imageRetrievalPool\r\n    const options = {\r\n      targetBuffer: {\r\n        type: useNativeDataType ? undefined : 'Float32Array',\r\n      },\r\n      preScale: {\r\n        enabled: true,\r\n      },\r\n      useNativeDataType,\r\n      requestType,\r\n    };\r\n\r\n    imageLoadPoolManager.addRequest(\r\n      requestFn.bind(null, imageId, options),\r\n      requestType,\r\n      // Additional details\r\n      {\r\n        imageId,\r\n      },\r\n      priority\r\n      // addToBeginning\r\n    );\r\n  });\r\n}\r\n\r\nfunction onImageUpdated(e) {\r\n  // Start prefetching again (after a delay)\r\n  // When the user has scrolled to a new image\r\n  clearTimeout(resetPrefetchTimeout);\r\n  resetPrefetchTimeout = setTimeout(function () {\r\n    const element = e.target;\r\n\r\n    // If playClip is enabled and the user loads a different series in the viewport\r\n    // An exception will be thrown because the element will not be enabled anymore\r\n    try {\r\n      prefetch(element);\r\n    } catch (error) {\r\n      return;\r\n    }\r\n  }, resetPrefetchDelay);\r\n}\r\n\r\nfunction enable(element) {\r\n  const stack = getStackData(element);\r\n\r\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\r\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\r\n    return;\r\n  }\r\n\r\n  // Use the currentImageIdIndex from the stack as the initialImageIdIndex\r\n  const stackPrefetchData = {\r\n    indicesToRequest: range(0, stack.imageIds.length - 1),\r\n    enabled: true,\r\n    direction: 1,\r\n  };\r\n\r\n  // Remove the currentImageIdIndex from the list to request\r\n  const indexOfCurrentImage = stackPrefetchData.indicesToRequest.indexOf(\r\n    stack.currentImageIdIndex\r\n  );\r\n\r\n  stackPrefetchData.indicesToRequest.splice(indexOfCurrentImage, 1);\r\n\r\n  addToolState(element, stackPrefetchData);\r\n\r\n  prefetch(element);\r\n\r\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\r\n  element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\r\n\r\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\r\n\r\n  eventTarget.removeEventListener(\r\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\r\n    promiseRemovedHandler\r\n  );\r\n  eventTarget.addEventListener(\r\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\r\n    promiseRemovedHandler\r\n  );\r\n}\r\n\r\nfunction disable(element) {\r\n  clearTimeout(resetPrefetchTimeout);\r\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\r\n\r\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\r\n\r\n  eventTarget.removeEventListener(\r\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\r\n    promiseRemovedHandler\r\n  );\r\n\r\n  const stackPrefetchData = getToolState(element);\r\n  // If there is actually something to disable, disable it\r\n\r\n  if (stackPrefetchData && stackPrefetchData.indicesToRequest.length) {\r\n    stackPrefetchData.enabled = false;\r\n\r\n    // Clear current prefetch requests from the requestPool\r\n    imageLoadPoolManager.clearRequestStack(requestType);\r\n  }\r\n}\r\n\r\nfunction getConfiguration() {\r\n  return configuration;\r\n}\r\n\r\nfunction setConfiguration(config) {\r\n  configuration = config;\r\n}\r\n\r\nconst stackPrefetch = { enable, disable, getConfiguration, setConfiguration };\r\n\r\nexport default stackPrefetch;\r\n","import {\r\n  imageLoader,\r\n  Enums,\r\n  eventTarget,\r\n  imageLoadPoolManager,\r\n  cache,\r\n  getConfiguration as getCoreConfiguration,\r\n} from '@cornerstonejs/core';\r\nimport { addToolState, getToolState } from './state';\r\nimport {\r\n  getStackData,\r\n  requestType,\r\n  priority,\r\n  clearFromImageIds,\r\n  getPromiseRemovedHandler,\r\n} from './stackPrefetchUtils';\r\nimport { roundNumber } from '../../utilities';\r\n\r\nlet configuration = {\r\n  maxImagesToPrefetch: Infinity,\r\n  // Fetch up to 2 image before and after\r\n  minBefore: 2,\r\n  maxAfter: 2,\r\n  // Increment the cache size by 10 images\r\n  directionExtraImages: 10,\r\n  preserveExistingPool: false,\r\n};\r\n\r\nlet resetPrefetchTimeout;\r\n// Starting the prefetch quickly isn't an issue as the main image is already being\r\n// loaded, so a 5 ms prefetch delay is fine\r\nconst resetPrefetchDelay = 5;\r\n\r\n/**\r\n * Call this to enable stack context sensitive prefetch.  Should be called\r\n * before stack data is set in order to start prefetch after load first image.\r\n * This will add a STACK_NEW_IMAGE to detect when a new image is displayed, and then\r\n * update the prefetch stack.  The context sensitive prefetch reacts to the\r\n * initial display, or significant moves, the already loaded images, the\r\n * cache size and the direction of navigation.  The behaviour is:\r\n *\r\n * 1. On navigating to a new image initially, or one that is at a different position:\r\n *  * Fetch the next/previous 2 images\r\n * 2. If the user is navigating forward/backward by less than 5 images, then\r\n *  * Prefetch additional images in the direction of navigation, up to 100\r\n * 3. If all the images in a given prefetch have completed, then:\r\n *  * Use the last prefetched image size as an image size for the stack\r\n *  * Fetch up to 1/4 of the cache size images near the current image\r\n *\r\n * This is designed to:\r\n *   * Get nearby images immediately so that they are available for navigation\r\n *     * Under the assumption that users might click and view an image, then\r\n *       navigate to next/previous image to see the exact image they want\r\n *   * Not interfere with loading other viewports if they are still loading\r\n *     * Load priority is prefetch, and minimal images are requested initially\r\n *   * Load an entire series if it will fit in memory\r\n *     * Allows navigating to other parts of the series and display images immediately\r\n *   * Have images available for CINE/navigation in one direction even when\r\n *     there is more image data than will fit in memory.\r\n *     * Up to 100 images in the direction of travel will be prefetched\r\n *\r\n * @param element - to prefetch on\r\n */\r\nconst enable = (element): void => {\r\n  const stack = getStackData(element);\r\n\r\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\r\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\r\n    return;\r\n  }\r\n\r\n  updateToolState(element);\r\n\r\n  prefetch(element);\r\n\r\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\r\n  element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\r\n\r\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\r\n\r\n  eventTarget.removeEventListener(\r\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\r\n    promiseRemovedHandler\r\n  );\r\n  eventTarget.addEventListener(\r\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\r\n    promiseRemovedHandler\r\n  );\r\n};\r\n\r\nfunction prefetch(element) {\r\n  const stack = getStackData(element);\r\n  if (!stack?.imageIds?.length) {\r\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\r\n    return;\r\n  }\r\n\r\n  // Get the stackPrefetch tool data\r\n  const stackPrefetchData = getToolState(element);\r\n\r\n  if (!stackPrefetchData) {\r\n    return;\r\n  }\r\n\r\n  const stackPrefetch = stackPrefetchData || {};\r\n\r\n  // If all the requests are complete, disable the stackPrefetch tool\r\n  stackPrefetch.enabled &&= stackPrefetch.indicesToRequest?.length;\r\n\r\n  // Make sure the tool is still enabled\r\n  if (stackPrefetch.enabled === false) {\r\n    return;\r\n  }\r\n\r\n  // Remove an imageIdIndex from the list of indices to request\r\n  // This fires when the individual image loading deferred is resolved\r\n  function removeFromList(imageIdIndex) {\r\n    const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\r\n\r\n    if (index > -1) {\r\n      // Don't remove last element if imageIdIndex not found\r\n      stackPrefetch.indicesToRequest.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  // Remove all already cached images from the\r\n  // IndicesToRequest array.\r\n  const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\r\n  const { currentImageIdIndex } = stack;\r\n\r\n  indicesToRequestCopy.forEach((imageIdIndex) => {\r\n    const imageId = stack.imageIds[imageIdIndex];\r\n\r\n    if (!imageId) {\r\n      return;\r\n    }\r\n\r\n    const distance = Math.abs(currentImageIdIndex - imageIdIndex);\r\n    // For nearby objects, ensure the last accessed time is updated\r\n    // by using getImageLoadObject.\r\n    // For more distant objects, just check if available, but dont\r\n    // change the access time.\r\n    // This allows throwing data that hasn't been accessed and is not\r\n    // nearby.\r\n    const imageCached =\r\n      distance < 6\r\n        ? cache.getImageLoadObject(imageId)\r\n        : cache.isLoaded(imageId);\r\n\r\n    if (imageCached) {\r\n      // Already in cache\r\n      removeFromList(imageIdIndex);\r\n    }\r\n  });\r\n\r\n  // Stop here if there are no images left to request\r\n  // After those in the cache have been removed\r\n  if (!stackPrefetch.indicesToRequest.length) {\r\n    return;\r\n  }\r\n\r\n  // Clear the requestPool of prefetch requests, if needed.\r\n  if (!configuration.preserveExistingPool) {\r\n    imageLoadPoolManager.filterRequests(clearFromImageIds(stack));\r\n  }\r\n\r\n  function doneCallback(imageId: string) {\r\n    const imageIdIndex = stack.imageIds.indexOf(imageId);\r\n\r\n    removeFromList(imageIdIndex);\r\n    const image = cache.getCachedImageBasedOnImageURI(imageId);\r\n    const { stats } = stackPrefetch;\r\n    const decodeTimeInMS = image?.image?.decodeTimeInMS || 0;\r\n    if (decodeTimeInMS) {\r\n      stats.imageIds.set(imageId, decodeTimeInMS);\r\n      stats.decodeTimeInMS += decodeTimeInMS;\r\n      const loadTimeInMS = image?.image?.loadTimeInMS || 0;\r\n      stats.loadTimeInMS += loadTimeInMS;\r\n    }\r\n\r\n    if (!stackPrefetch.indicesToRequest.length) {\r\n      if (image?.sizeInBytes) {\r\n        const { sizeInBytes } = image;\r\n        const usage = cache.getMaxCacheSize() / 4 / sizeInBytes;\r\n        if (!stackPrefetch.cacheFill) {\r\n          stats.initialTime = Date.now() - stats.start;\r\n          stats.initialSize = stats.imageIds.size;\r\n          updateToolState(element, usage);\r\n          prefetch(element);\r\n        } else if (stats.imageIds.size) {\r\n          stats.fillTime = Date.now() - stats.start;\r\n          const { size } = stats.imageIds;\r\n          stats.fillSize = size;\r\n          console.log(\r\n            'Done cache fill',\r\n            stats.fillTime,\r\n            'ms',\r\n            size,\r\n            'items',\r\n            'average total time',\r\n            roundNumber(stats.fillTime / size),\r\n            'ms',\r\n            'average load',\r\n            roundNumber(stats.loadTimeInMS / size),\r\n            'ms',\r\n            'average decode',\r\n            roundNumber(stats.decodeTimeInMS / size),\r\n            'ms'\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const requestFn = (imageId, options) =>\r\n    imageLoader\r\n      .loadAndCacheImage(imageId, options)\r\n      .then(() => doneCallback(imageId));\r\n\r\n  const { useNorm16Texture, preferSizeOverAccuracy } =\r\n    getCoreConfiguration().rendering;\r\n\r\n  const useNativeDataType = useNorm16Texture || preferSizeOverAccuracy;\r\n\r\n  stackPrefetch.indicesToRequest.forEach((imageIdIndex) => {\r\n    const imageId = stack.imageIds[imageIdIndex];\r\n    // IMPORTANT: Request type should be passed if not the 'interaction'\r\n    // highest priority will be used for the request type in the imageRetrievalPool\r\n    const options = {\r\n      targetBuffer: {\r\n        type: useNativeDataType ? undefined : 'Float32Array',\r\n      },\r\n      preScale: {\r\n        enabled: true,\r\n      },\r\n      useNativeDataType,\r\n      requestType,\r\n    };\r\n\r\n    imageLoadPoolManager.addRequest(\r\n      requestFn.bind(null, imageId, options),\r\n      requestType,\r\n      // Additional details\r\n      {\r\n        imageId,\r\n      },\r\n      priority\r\n      // addToBeginning\r\n    );\r\n  });\r\n}\r\n\r\nfunction onImageUpdated(e) {\r\n  // Start prefetching again (after a delay)\r\n  // When the user has scrolled to a new image\r\n  clearTimeout(resetPrefetchTimeout);\r\n  resetPrefetchTimeout = setTimeout(function () {\r\n    const element = e.target;\r\n\r\n    // If playClip is enabled and the user loads a different series in the viewport\r\n    // An exception will be thrown because the element will not be enabled anymore\r\n    try {\r\n      updateToolState(element);\r\n      prefetch(element);\r\n    } catch (error) {\r\n      return;\r\n    }\r\n  }, resetPrefetchDelay);\r\n}\r\n\r\n// Not a full signum, but good enough for direction.\r\nconst signum = (x) => (x < 0 ? -1 : 1);\r\n\r\nconst updateToolState = (element, usage?: number) => {\r\n  const stack = getStackData(element);\r\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\r\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\r\n    return;\r\n  }\r\n\r\n  const { currentImageIdIndex } = stack;\r\n  let { maxAfter = 2, minBefore = 2 } = configuration;\r\n  const { directionExtraImages = 10 } = configuration;\r\n  // Use the currentImageIdIndex from the stack as the initialImageIdIndex\r\n  const stackPrefetchData = getToolState(element) || {\r\n    indicesToRequest: [],\r\n    currentImageIdIndex,\r\n    stackCount: 0,\r\n    enabled: true,\r\n    direction: 1,\r\n    stats: {\r\n      start: Date.now(),\r\n      imageIds: new Map(),\r\n      decodeTimeInMS: 0,\r\n      loadTimeInMS: 0,\r\n      totalBytes: 0,\r\n    },\r\n  };\r\n  const delta = currentImageIdIndex - stackPrefetchData.currentImageIdIndex;\r\n  stackPrefetchData.direction = signum(delta);\r\n  stackPrefetchData.currentImageIdIndex = currentImageIdIndex;\r\n  stackPrefetchData.enabled = true;\r\n\r\n  if (stackPrefetchData.stackCount < 100) {\r\n    stackPrefetchData.stackCount += directionExtraImages;\r\n  }\r\n\r\n  if (Math.abs(delta) > maxAfter || !delta) {\r\n    // Not incrementing by 1, so stop increasing the data size\r\n    // TODO - consider reversing the CINE playback\r\n    stackPrefetchData.stackCount = 0;\r\n    if (usage) {\r\n      // The usage of the cache that this stack can use\r\n      const positionFraction = currentImageIdIndex / stack.imageIds.length;\r\n      minBefore = Math.ceil(usage * positionFraction);\r\n      maxAfter = Math.ceil(usage * (1 - positionFraction));\r\n      stackPrefetchData.cacheFill = true;\r\n    } else {\r\n      stackPrefetchData.cacheFill = false;\r\n    }\r\n  } else if (delta < 0) {\r\n    minBefore += stackPrefetchData.stackCount;\r\n    maxAfter = 0;\r\n  } else {\r\n    maxAfter += stackPrefetchData.stackCount;\r\n    minBefore = 0;\r\n  }\r\n\r\n  const minIndex = Math.max(0, currentImageIdIndex - minBefore);\r\n\r\n  const maxIndex = Math.min(\r\n    stack.imageIds.length - 1,\r\n    currentImageIdIndex + maxAfter\r\n  );\r\n\r\n  // Order these correctly initially\r\n  const indicesToRequest = [];\r\n  for (let i = currentImageIdIndex + 1; i <= maxIndex; i++) {\r\n    indicesToRequest.push(i);\r\n  }\r\n  for (let i = currentImageIdIndex - 1; i >= minIndex; i--) {\r\n    indicesToRequest.push(i);\r\n  }\r\n  stackPrefetchData.indicesToRequest = indicesToRequest;\r\n\r\n  addToolState(element, stackPrefetchData);\r\n};\r\n\r\nfunction disable(element) {\r\n  clearTimeout(resetPrefetchTimeout);\r\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\r\n\r\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\r\n\r\n  eventTarget.removeEventListener(\r\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\r\n    promiseRemovedHandler\r\n  );\r\n\r\n  const stackPrefetchData = getToolState(element);\r\n  // If there is actually something to disable, disable it\r\n\r\n  if (stackPrefetchData) {\r\n    stackPrefetchData.enabled = false;\r\n    // Don't worry about clearing the requests - there aren't that many too be bothersome\r\n  }\r\n}\r\n\r\nfunction getConfiguration() {\r\n  return configuration;\r\n}\r\n\r\nfunction setConfiguration(config) {\r\n  configuration = config;\r\n}\r\n\r\nconst stackContextPrefetch = {\r\n  enable,\r\n  disable,\r\n  getConfiguration,\r\n  setConfiguration,\r\n};\r\n\r\nexport default stackContextPrefetch;\r\n","import debounce from './debounce';\r\nimport isObject from './isObject';\r\n\r\n/**\r\n * Creates a throttled function that only invokes `func` at most once per\r\n * every `wait` milliseconds (or once per browser frame). The throttled function\r\n * comes with a `cancel` method to cancel delayed `func` invocations and a\r\n * `flush` method to immediately invoke them. Provide `options` to indicate\r\n * whether `func` should be invoked on the leading and/or trailing edge of the\r\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\r\n * throttled function. Subsequent calls to the throttled function return the\r\n * result of the last `func` invocation.\r\n *\r\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\r\n * invoked on the trailing edge of the timeout only if the throttled function\r\n * is invoked more than once during the `wait` timeout.\r\n *\r\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\r\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\r\n *\r\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\r\n * invocation will be deferred until the next frame is drawn (typically about\r\n * 16ms).\r\n *\r\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\r\n * for details over the differences between `throttle` and `debounce`.\r\n *\r\n * @param {Function} func The function to throttle.\r\n * @param {number} [wait=0]\r\n *  The number of milliseconds to throttle invocations to; if omitted,\r\n *  `requestAnimationFrame` is used (if available).\r\n * @param {Object} [options={}] The options object.\r\n * @param {boolean} [options.leading=true]\r\n *  Specify invoking on the leading edge of the timeout.\r\n * @param {boolean} [options.trailing=true]\r\n *  Specify invoking on the trailing edge of the timeout.\r\n * @returns {Function} Returns the new throttled function.\r\n * @example\r\n *\r\n * // Avoid excessively updating the position while scrolling.\r\n * jQuery(window).on('scroll', throttle(updatePosition, 100))\r\n *\r\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\r\n * const throttled = throttle(renewToken, 300000, { 'trailing': false })\r\n * jQuery(element).on('click', throttled)\r\n *\r\n * // Cancel the trailing throttled invocation.\r\n * jQuery(window).on('popstate', throttled.cancel)\r\n */\r\nfunction throttle(func, wait, options) {\r\n  let leading = true;\r\n  let trailing = true;\r\n\r\n  if (typeof func !== 'function') {\r\n    throw new TypeError('Expected a function');\r\n  }\r\n  if (isObject(options)) {\r\n    leading = 'leading' in options ? Boolean(options.leading) : leading;\r\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\r\n  }\r\n\r\n  return debounce(func, wait, {\r\n    leading,\r\n    trailing,\r\n    maxWait: wait,\r\n  });\r\n}\r\n\r\nexport default throttle;\r\n","import { IDistance, IPoints, ITouchPoints } from '../../types';\r\nimport { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Returns the difference between multiple `IPoints` instances.\r\n * @param currentPoints - The current points.\r\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\r\n *\r\n * @returns The difference in IPoints format\r\n */\r\nfunction getDeltaPoints(\r\n  currentPoints: IPoints[],\r\n  lastPoints: IPoints[]\r\n): IPoints {\r\n  const curr = getMeanPoints(currentPoints);\r\n  const last = getMeanPoints(lastPoints);\r\n  return {\r\n    page: _subtractPoints2D(curr.page, last.page),\r\n    client: _subtractPoints2D(curr.client, last.client),\r\n    canvas: _subtractPoints2D(curr.canvas, last.canvas),\r\n    world: _subtractPoints3D(curr.world, last.world),\r\n  };\r\n}\r\n\r\n/**\r\n * Returns the distance between multiple `IPoints` instances.\r\n * @param currentPoints - The current points.\r\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\r\n *\r\n * @returns The distance difference in IDistance format\r\n */\r\nfunction getDeltaDistance(\r\n  currentPoints: IPoints[],\r\n  lastPoints: IPoints[]\r\n): IDistance {\r\n  const curr = getMeanPoints(currentPoints);\r\n  const last = getMeanPoints(lastPoints);\r\n  return {\r\n    page: _getDistance2D(curr.page, last.page),\r\n    client: _getDistance2D(curr.client, last.client),\r\n    canvas: _getDistance2D(curr.canvas, last.canvas),\r\n    world: _getDistance3D(curr.world, last.world),\r\n  };\r\n}\r\n\r\nfunction getDeltaRotation(\r\n  currentPoints: ITouchPoints[],\r\n  lastPoints: ITouchPoints[]\r\n) {\r\n  // TODO\r\n}\r\n\r\n/**\r\n * Returns the distance difference between multiple `IPoints` instances.\r\n * @param currentPoints - The current points.\r\n * @param lastPoints -- The last points.\r\n *\r\n * @returns The difference in IPoints format\r\n */\r\nfunction getDeltaDistanceBetweenIPoints(\r\n  currentPoints: IPoints[],\r\n  lastPoints: IPoints[]\r\n): IDistance {\r\n  const currentDistance = _getMeanDistanceBetweenAllIPoints(currentPoints);\r\n  const lastDistance = _getMeanDistanceBetweenAllIPoints(lastPoints);\r\n  const deltaDistance = {\r\n    page: currentDistance.page - lastDistance.page,\r\n    client: currentDistance.client - lastDistance.client,\r\n    canvas: currentDistance.canvas - lastDistance.canvas,\r\n    world: currentDistance.world - lastDistance.world,\r\n  };\r\n  return deltaDistance;\r\n}\r\n\r\n/**\r\n * Copies a set of points.\r\n * @param points - The `IPoints` instance to copy.\r\n *\r\n * @returns A copy of the points.\r\n */\r\nfunction copyPointsList(points: ITouchPoints[]): ITouchPoints[] {\r\n  return JSON.parse(JSON.stringify(points));\r\n}\r\n\r\nfunction copyPoints(points: ITouchPoints): ITouchPoints {\r\n  return JSON.parse(JSON.stringify(points));\r\n}\r\n\r\nfunction getMeanPoints(points: IPoints[]): IPoints {\r\n  return points.reduce(\r\n    (prev, curr) => {\r\n      return {\r\n        page: [\r\n          prev.page[0] + curr.page[0] / points.length,\r\n          prev.page[1] + curr.page[1] / points.length,\r\n        ],\r\n        client: [\r\n          prev.client[0] + curr.client[0] / points.length,\r\n          prev.client[1] + curr.client[1] / points.length,\r\n        ],\r\n        canvas: [\r\n          prev.canvas[0] + curr.canvas[0] / points.length,\r\n          prev.canvas[1] + curr.canvas[1] / points.length,\r\n        ],\r\n        world: [\r\n          prev.world[0] + curr.world[0] / points.length,\r\n          prev.world[1] + curr.world[1] / points.length,\r\n          prev.world[2] + curr.world[2] / points.length,\r\n        ],\r\n      };\r\n    },\r\n    {\r\n      page: [0, 0],\r\n      client: [0, 0],\r\n      canvas: [0, 0],\r\n      world: [0, 0, 0],\r\n    }\r\n  );\r\n}\r\n\r\nfunction getMeanTouchPoints(points: ITouchPoints[]): ITouchPoints {\r\n  return points.reduce(\r\n    (prev, curr) => {\r\n      return {\r\n        page: [\r\n          prev.page[0] + curr.page[0] / points.length,\r\n          prev.page[1] + curr.page[1] / points.length,\r\n        ],\r\n        client: [\r\n          prev.client[0] + curr.client[0] / points.length,\r\n          prev.client[1] + curr.client[1] / points.length,\r\n        ],\r\n        canvas: [\r\n          prev.canvas[0] + curr.canvas[0] / points.length,\r\n          prev.canvas[1] + curr.canvas[1] / points.length,\r\n        ],\r\n        world: [\r\n          prev.world[0] + curr.world[0] / points.length,\r\n          prev.world[1] + curr.world[1] / points.length,\r\n          prev.world[2] + curr.world[2] / points.length,\r\n        ],\r\n        touch: {\r\n          identifier: null,\r\n          radiusX: prev.touch.radiusX + curr.touch.radiusX / points.length,\r\n          radiusY: prev.touch.radiusY + curr.touch.radiusY / points.length,\r\n          force: prev.touch.force + curr.touch.force / points.length,\r\n          rotationAngle:\r\n            prev.touch.rotationAngle + curr.touch.rotationAngle / points.length,\r\n        },\r\n      };\r\n    },\r\n    {\r\n      page: [0, 0],\r\n      client: [0, 0],\r\n      canvas: [0, 0],\r\n      world: [0, 0, 0],\r\n      touch: {\r\n        identifier: null,\r\n        radiusX: 0,\r\n        radiusY: 0,\r\n        force: 0,\r\n        rotationAngle: 0,\r\n      },\r\n    }\r\n  );\r\n}\r\n/**\r\n * _subtractPoints - Subtracts `point1` from `point0`.\r\n * @param point0 - The first point.\r\n * @param point1 - The second point to subtract from the first.\r\n *\r\n * @returns The difference.\r\n */\r\nfunction _subtractPoints2D(\r\n  point0: Types.Point2,\r\n  point1: Types.Point2\r\n): Types.Point2 {\r\n  return [point0[0] - point1[0], point0[1] - point1[1]];\r\n}\r\n\r\nfunction _subtractPoints3D(\r\n  point0: Types.Point3,\r\n  point1: Types.Point3\r\n): Types.Point3 {\r\n  return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\r\n}\r\n\r\nfunction _getMeanDistanceBetweenAllIPoints(points: IPoints[]): IDistance {\r\n  // get mean distance between all unordered pairs of points\r\n  const pairedDistance: IDistance[] = [];\r\n  for (let i = 0; i < points.length; i++) {\r\n    for (let j = 0; j < points.length; j++) {\r\n      if (i < j) {\r\n        pairedDistance.push({\r\n          page: _getDistance2D(points[i].page, points[j].page),\r\n          client: _getDistance2D(points[i].client, points[j].client),\r\n          canvas: _getDistance2D(points[i].canvas, points[j].canvas),\r\n          world: _getDistance3D(points[i].world, points[j].world),\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  // take the average distance\r\n  return pairedDistance.reduce(\r\n    (prev, curr) => {\r\n      return {\r\n        page: prev.page + curr.page / pairedDistance.length,\r\n        client: prev.client + curr.client / pairedDistance.length,\r\n        canvas: prev.canvas + curr.canvas / pairedDistance.length,\r\n        world: prev.world + curr.world / pairedDistance.length,\r\n      };\r\n    },\r\n    {\r\n      page: 0,\r\n      client: 0,\r\n      canvas: 0,\r\n      world: 0,\r\n    }\r\n  );\r\n}\r\n\r\nfunction _getDistance2D(point0: Types.Point2, point1: Types.Point2): number {\r\n  return Math.sqrt(\r\n    Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2)\r\n  );\r\n}\r\n\r\nfunction _getDistance3D(point0: Types.Point3, point1: Types.Point3): number {\r\n  return Math.sqrt(\r\n    Math.pow(point0[0] - point1[0], 2) +\r\n      Math.pow(point0[1] - point1[1], 2) +\r\n      Math.pow(point0[2] - point1[2], 2)\r\n  );\r\n}\r\n\r\nexport {\r\n  getMeanPoints,\r\n  getMeanTouchPoints,\r\n  copyPoints,\r\n  copyPointsList,\r\n  getDeltaDistanceBetweenIPoints,\r\n  getDeltaPoints,\r\n  getDeltaDistance,\r\n  getDeltaRotation,\r\n};\r\n","import { getRenderingEngine, type Types } from '@cornerstonejs/core';\r\nimport triggerAnnotationRender from './triggerAnnotationRender';\r\nimport { getToolGroup } from '../store/ToolGroupManager';\r\n\r\n/**\r\n * Triggers annotation rendering for the specified tool group IDs.\r\n *\r\n * @param toolGroupIds - An array of tool group IDs.\r\n */\r\nexport function triggerAnnotationRenderForToolGroupIds(\r\n  toolGroupIds: string[]\r\n): void {\r\n  toolGroupIds.forEach((toolGroupId) => {\r\n    const toolGroup = getToolGroup(toolGroupId);\r\n\r\n    if (!toolGroup) {\r\n      console.warn(`ToolGroup not available for ${toolGroupId}`);\r\n      return;\r\n    }\r\n\r\n    const viewportsInfo = toolGroup.getViewportsInfo();\r\n\r\n    viewportsInfo.forEach((viewportInfo) => {\r\n      const { renderingEngineId, viewportId } = viewportInfo;\r\n\r\n      const renderingEngine = getRenderingEngine(renderingEngineId);\r\n      if (!renderingEngine) {\r\n        console.warn(`RenderingEngine not available for ${renderingEngineId}`);\r\n        return;\r\n      }\r\n\r\n      const viewport = renderingEngine.getViewport(viewportId);\r\n      triggerAnnotationRender(viewport.element);\r\n    });\r\n  });\r\n}\r\n\r\nexport default triggerAnnotationRenderForToolGroupIds;\r\n","import type { Types } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Given an array of viewports, returns a list of viewports that are viewing a\r\n * world space with the given `FrameOfReferenceUID`.\r\n *\r\n * @param viewports - An array of viewports.\r\n * @param FrameOfReferenceUID - The UID defining a particular world space/Frame Of Reference.\r\n *\r\n * @returns A filtered array of viewports.\r\n */\r\nexport default function filterViewportsWithFrameOfReferenceUID(\r\n  viewports: Array<Types.IViewport>,\r\n  FrameOfReferenceUID: string\r\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\r\n  const numViewports = viewports.length;\r\n  const viewportsWithFrameOfReferenceUID = [];\r\n\r\n  for (let vp = 0; vp < numViewports; vp++) {\r\n    const viewport = viewports[vp];\r\n\r\n    console.log(`VIEWPORT ${vp} WITH FORUID ${viewport.getFrameOfReferenceUID()}`)\r\n    if (viewport.getFrameOfReferenceUID() === FrameOfReferenceUID) {\r\n      viewportsWithFrameOfReferenceUID.push(viewport);\r\n    }\r\n  }\r\n\r\n  return viewportsWithFrameOfReferenceUID;\r\n}\r\n","import type { Types } from '@cornerstonejs/core';\r\nimport type { IToolGroup } from '../../types';\r\nimport { ToolGroupManager } from '../../store';\r\nimport { ToolModes } from '../../enums';\r\n\r\nconst { Active, Passive, Enabled } = ToolModes;\r\n\r\n/**\r\n * Given an array of viewports, returns a list of viewports that have the the specified tool enabled.\r\n *\r\n * @param viewports - An array of viewports.\r\n * @param toolName - The name of the tool to filter on.\r\n *\r\n * @returns A filtered array of viewports.\r\n */\r\nexport default function filterViewportsWithToolEnabled(\r\n  viewports: Array<Types.IViewport>,\r\n  toolName: string\r\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\r\n  const numViewports = viewports.length;\r\n\r\n  const viewportsWithToolEnabled = [];\r\n\r\n  for (let vp = 0; vp < numViewports; vp++) {\r\n    const viewport = viewports[vp];\r\n\r\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\r\n      viewport.id,\r\n      viewport.renderingEngineId\r\n    );\r\n\r\n    if (!toolGroup) {\r\n      continue;\r\n    }\r\n\r\n    const hasTool = _toolGroupHasActiveEnabledOrPassiveTool(\r\n      toolGroup,\r\n      toolName\r\n    );\r\n\r\n    if (hasTool) {\r\n      viewportsWithToolEnabled.push(viewport);\r\n    }\r\n  }\r\n\r\n  return viewportsWithToolEnabled;\r\n}\r\n\r\n/**\r\n * Given a toolGroup, return true if it contains the tool with the given `toolName` and it is\r\n * active, passive or enabled.\r\n *\r\n * @param toolGroup - The `toolGroup` to check.\r\n * @param toolName - The name of the tool.\r\n *\r\n * @returns True if the tool is enabled, passive or active in the `toolGroup`.\r\n */\r\nfunction _toolGroupHasActiveEnabledOrPassiveTool(\r\n  toolGroup: IToolGroup,\r\n  toolName: string\r\n) {\r\n  const { toolOptions } = toolGroup;\r\n  const tool = toolOptions[toolName];\r\n\r\n  if (!tool) {\r\n    return false;\r\n  }\r\n\r\n  const toolMode = tool.mode;\r\n\r\n  return toolMode === Active || toolMode === Passive || toolMode === Enabled;\r\n}\r\n","import { vec3 } from 'gl-matrix';\r\n\r\n/**\r\n * It filters the viewports that are looking in the same view as the camera\r\n * It basically checks if the viewPlaneNormal is parallel to the camera viewPlaneNormal\r\n * @param viewports - Array of viewports to filter\r\n * @param camera - Camera to compare against\r\n * @returns - Array of viewports with the same view\r\n */\r\nexport function filterViewportsWithParallelNormals(\r\n  viewports,\r\n  camera,\r\n  EPS = 0.999\r\n) {\r\n  return viewports.filter((viewport) => {\r\n    const vpCamera = viewport.getCamera();\r\n\r\n    const isParallel =\r\n      Math.abs(vec3.dot(vpCamera.viewPlaneNormal, camera.viewPlaneNormal)) >\r\n      EPS;\r\n\r\n    return isParallel;\r\n  });\r\n}\r\n\r\nexport default filterViewportsWithParallelNormals;\r\n","import { getEnabledElement } from '@cornerstonejs/core';\r\nimport filterViewportsWithFrameOfReferenceUID from './filterViewportsWithFrameOfReferenceUID';\r\nimport filterViewportsWithToolEnabled from './filterViewportsWithToolEnabled';\r\nimport filterViewportsWithParallelNormals from './filterViewportsWithParallelNormals';\r\n\r\n/**\r\n * Given a cornerstone3D enabled `element`, and a `toolName`, find all viewportIds\r\n * looking at the same Frame Of Reference that have the tool with the given `toolName`\r\n * active, passive or enabled.\r\n *\r\n * @param element - The target cornerstone3D enabled element.\r\n * @param toolName - The string toolName.\r\n * @param requireParallelNormals - If true, only return viewports that have parallel normals.\r\n *\r\n * @returns An array of viewportIds.\r\n */\r\nexport default function getViewportIdsWithToolToRender(\r\n  element: HTMLDivElement,\r\n  toolName: string,\r\n  requireParallelNormals = true\r\n): string[] {\r\n  const enabledElement = getEnabledElement(element);\r\n  const { renderingEngine, FrameOfReferenceUID } = enabledElement;\r\n  // console.log('FORUID TO MATCH : ', FrameOfReferenceUID)\r\n\r\n  let viewports = renderingEngine.getViewports();\r\n\r\n  viewports = filterViewportsWithFrameOfReferenceUID(\r\n    viewports,\r\n    FrameOfReferenceUID\r\n  );\r\n  viewports = filterViewportsWithToolEnabled(viewports, toolName);\r\n\r\n  const viewport = renderingEngine.getViewport(enabledElement.viewportId);\r\n\r\n  if (requireParallelNormals) {\r\n    viewports = filterViewportsWithParallelNormals(\r\n      viewports,\r\n      viewport.getCamera()\r\n    );\r\n  }\r\n\r\n  const viewportIds = viewports.map((vp) => vp.id);\r\n\r\n  return viewportIds;\r\n}\r\n","import {\r\n  cache,\r\n  StackViewport,\r\n  Types,\r\n  BaseVolumeViewport,\r\n} from '@cornerstonejs/core';\r\n\r\nfunction isViewportPreScaled(\r\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\r\n  targetId: string\r\n): boolean {\r\n  if (viewport instanceof BaseVolumeViewport) {\r\n    const targetIdTokens = targetId.split('volumeId:');\r\n    const volumeId =\r\n      targetIdTokens.length > 1\r\n        ? targetIdTokens[1].split('?')[0]\r\n        : targetIdTokens[0];\r\n    const volume = cache.getVolume(volumeId);\r\n    return !!volume?.scaling && Object.keys(volume.scaling).length > 0;\r\n  } else if (viewport instanceof StackViewport) {\r\n    const { preScale } = viewport.getImageData() || {};\r\n    return !!preScale?.scaled;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport { isViewportPreScaled };\r\n","import {\r\n  getEnabledElement,\r\n  StackViewport,\r\n  VolumeViewport,\r\n  utilities as csUtils,\r\n  Types,\r\n} from '@cornerstonejs/core';\r\nimport JumpToSliceOptions from '../../types/JumpToSliceOptions';\r\nimport clip from '../clip';\r\nimport scroll from '../scroll';\r\n\r\n/**\r\n * It uses the imageIndex in the Options to scroll to the slice that is intended.\r\n * It works for both Stack and Volume viewports. In VolumeViewports, the imageIndex\r\n * should be given with respect to the index in the 3D image in the view direction\r\n * (i.e. the index of the slice in Axial, Sagittal, Coronal, or Oblique).\r\n *\r\n * @param element - the HTML Div element scrolling inside\r\n * @param options - the options used for jumping to a slice\r\n * @returns Promise that resolves to ImageIdIndex\r\n */\r\nasync function jumpToSlice(\r\n  element: HTMLDivElement,\r\n  options = {} as JumpToSliceOptions\r\n): Promise<void> {\r\n  const { imageIndex, debounceLoading, volumeId } = options;\r\n  const enabledElement = getEnabledElement(element);\r\n\r\n  if (!enabledElement) {\r\n    throw new Error('Element has been disabled');\r\n  }\r\n\r\n  const { viewport } = enabledElement;\r\n\r\n  const { imageIndex: currentImageIndex, numberOfSlices } = _getImageSliceData(\r\n    viewport,\r\n    debounceLoading\r\n  );\r\n\r\n  const imageIndexToJump = _getImageIndexToJump(numberOfSlices, imageIndex);\r\n  const delta = imageIndexToJump - currentImageIndex;\r\n\r\n  scroll(viewport, { delta, debounceLoading, volumeId });\r\n}\r\n\r\nfunction _getImageSliceData(\r\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\r\n  debounceLoading?: boolean\r\n): Types.ImageSliceData {\r\n  if (viewport instanceof StackViewport) {\r\n    return {\r\n      numberOfSlices: viewport.getImageIds().length,\r\n      imageIndex: debounceLoading\r\n        ? viewport.getTargetImageIdIndex()\r\n        : viewport.getCurrentImageIdIndex(),\r\n    };\r\n  } else if (viewport instanceof VolumeViewport) {\r\n    return csUtils.getImageSliceDataForVolumeViewport(viewport);\r\n  } else {\r\n    throw new Error('Unsupported viewport type');\r\n  }\r\n}\r\n\r\nfunction _getImageIndexToJump(\r\n  numberOfSlices: number,\r\n  imageIndex: number\r\n): number {\r\n  const lastSliceIndex = numberOfSlices - 1;\r\n\r\n  return clip(imageIndex, 0, lastSliceIndex);\r\n}\r\n\r\nexport default jumpToSlice;\r\n","import { VolumeViewport } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { vec3 } from 'gl-matrix';\r\n\r\n// Todo: merge this utility functionality with Crosshair _jump\r\n/**\r\n * Uses the viewport's current camera to jump to a specific world coordinate\r\n * @param enabledElement - enabled element\r\n * @param jumpWorld - location in the world to jump to\r\n * @returns True if successful\r\n */\r\nexport default function jumpToWorld(\r\n  viewport: Types.IVolumeViewport,\r\n  jumpWorld: Types.Point3\r\n): true | undefined {\r\n  // if not instance of volumeViewport, return\r\n  if (!(viewport instanceof VolumeViewport)) {\r\n    return;\r\n  }\r\n\r\n  const { focalPoint } = viewport.getCamera();\r\n\r\n  const delta: Types.Point3 = [0, 0, 0];\r\n  vec3.sub(delta, jumpWorld, focalPoint);\r\n\r\n  _applyShift(viewport, delta);\r\n\r\n  return true;\r\n}\r\n\r\nfunction _applyShift(viewport, delta) {\r\n  const camera = viewport.getCamera();\r\n  const normal = camera.viewPlaneNormal;\r\n\r\n  const dotProd = vec3.dot(delta, normal);\r\n  const projectedDelta = vec3.fromValues(normal[0], normal[1], normal[2]);\r\n\r\n  vec3.scale(projectedDelta, projectedDelta, dotProd);\r\n\r\n  if (\r\n    Math.abs(projectedDelta[0]) > 1e-3 ||\r\n    Math.abs(projectedDelta[1]) > 1e-3 ||\r\n    Math.abs(projectedDelta[2]) > 1e-3\r\n  ) {\r\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\r\n    const newPosition: Types.Point3 = [0, 0, 0];\r\n\r\n    vec3.add(newFocalPoint, camera.focalPoint, projectedDelta);\r\n    vec3.add(newPosition, camera.position, projectedDelta);\r\n\r\n    viewport.setCamera({\r\n      focalPoint: newFocalPoint,\r\n      position: newPosition,\r\n    });\r\n    viewport.render();\r\n  }\r\n}\r\n","import type { ColorbarImageRange } from '../types/ColorbarImageRange';\r\n\r\nconst isRangeValid = (range: ColorbarImageRange) => {\r\n  return range && range.upper > range.lower;\r\n};\r\n\r\nexport { isRangeValid as default, isRangeValid };\r\n","import type { ColorbarSize } from '../types/ColorbarSize';\r\n\r\nconst isColorbarSizeValid = (size: ColorbarSize) => {\r\n  return !!size && size.width > 0 && size.height > 0;\r\n};\r\n\r\nexport { isColorbarSizeValid as default, isColorbarSizeValid };\r\n","import type { ColorbarImageRange } from '../types/ColorbarImageRange';\r\n\r\nconst areColorbarRangesEqual = (\r\n  a: ColorbarImageRange,\r\n  b: ColorbarImageRange\r\n) => {\r\n  return !!a && !!b && a.lower === b.lower && a.upper === b.upper;\r\n};\r\n\r\nexport { areColorbarRangesEqual as default, areColorbarRangesEqual };\r\n","import type { ColorbarSize } from '../types/ColorbarSize';\r\n\r\nconst areColorbarSizesEqual = (a: ColorbarSize, b: ColorbarSize) => {\r\n  return !!a && !!b && a.width === b.width && a.height === b.height;\r\n};\r\n\r\nexport { areColorbarSizesEqual as default, areColorbarSizesEqual };\r\n","/**\r\n * Linear interpolation between two vec3.\r\n * Can be used, for example, to interpolate between two RGB colors.\r\n * @param a - First vec3\r\n * @param b - Second vec3\r\n * @param t - Time \"t\".\r\n *   - Vector A is returned for values smaller than or equel to 0.\r\n *   - Vector B is returned for values greater than or equal to 1.\r\n *   - An interpolation between vectors A and B is returned otherwise.\r\n * @returns\r\n */\r\nconst interpolateVec3 = (a, b, t) => {\r\n  return [\r\n    a[0] * (1 - t) + b[0] * t,\r\n    a[1] * (1 - t) + b[1] * t,\r\n    a[2] * (1 - t) + b[2] * t,\r\n  ];\r\n};\r\n\r\nexport { interpolateVec3 as default, interpolateVec3 };\r\n","import { IColorMapPreset } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\r\nimport { utilities } from '@cornerstonejs/core';\r\nimport interpolateVec3 from '../../math/vec3/interpolateVec3';\r\nimport { ColorbarCanvasProps } from './types/ColorbarCanvasProps';\r\nimport type { ColorbarImageRange, ColorbarVOIRange } from './types';\r\nimport type { ColorbarSize } from './types/ColorbarSize';\r\nimport {\r\n  isRangeValid,\r\n  areColorbarRangesEqual,\r\n  isColorbarSizeValid,\r\n  areColorbarSizesEqual,\r\n} from './common';\r\n\r\nconst { clamp } = utilities;\r\n\r\n/**\r\n * Canvas referenced by the color bar where the colormap is rendered. It may\r\n * show the full image range or only the VOI range.\r\n */\r\nclass ColorbarCanvas {\r\n  private _canvas: HTMLCanvasElement;\r\n  private _imageRange: ColorbarImageRange;\r\n  private _voiRange: ColorbarVOIRange;\r\n  private _colormap: IColorMapPreset;\r\n  private _showFullImageRange: boolean;\r\n\r\n  constructor(props: ColorbarCanvasProps) {\r\n    ColorbarCanvas.validateProps(props);\r\n\r\n    const {\r\n      colormap,\r\n      size = { width: 20, height: 100 },\r\n      imageRange = { lower: 0, upper: 1 },\r\n      voiRange = { lower: 0, upper: 1 },\r\n      container,\r\n      showFullPixelValueRange = false,\r\n    } = props;\r\n\r\n    this._colormap = colormap;\r\n    this._imageRange = imageRange;\r\n    this._voiRange = voiRange;\r\n    this._showFullImageRange = showFullPixelValueRange;\r\n    this._canvas = this._createRootElement(size);\r\n\r\n    if (container) {\r\n      this.appendTo(container);\r\n    }\r\n  }\r\n\r\n  public get colormap(): IColorMapPreset {\r\n    return this._colormap;\r\n  }\r\n\r\n  public set colormap(colormap: IColorMapPreset) {\r\n    this._colormap = colormap;\r\n    this.render();\r\n  }\r\n\r\n  public get size(): ColorbarSize {\r\n    const { width, height } = this._canvas;\r\n    return { width, height };\r\n  }\r\n\r\n  public set size(size: ColorbarSize) {\r\n    const { _canvas: canvas } = this;\r\n\r\n    if (!isColorbarSizeValid(size) || areColorbarSizesEqual(canvas, size)) {\r\n      return;\r\n    }\r\n\r\n    this._setCanvasSize(canvas, size);\r\n    this.render();\r\n  }\r\n\r\n  public get imageRange(): ColorbarImageRange {\r\n    return { ...this._imageRange };\r\n  }\r\n\r\n  public set imageRange(imageRange: ColorbarImageRange) {\r\n    if (\r\n      !isRangeValid(imageRange) ||\r\n      areColorbarRangesEqual(imageRange, this._imageRange)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    this._imageRange = imageRange;\r\n    this.render();\r\n  }\r\n\r\n  public get voiRange(): ColorbarVOIRange {\r\n    return { ...this._voiRange };\r\n  }\r\n\r\n  public set voiRange(voiRange: ColorbarVOIRange) {\r\n    if (\r\n      !isRangeValid(voiRange) ||\r\n      areColorbarRangesEqual(voiRange, this._voiRange)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    this._voiRange = voiRange;\r\n    this.render();\r\n  }\r\n\r\n  public get showFullImageRange(): boolean {\r\n    return this._showFullImageRange;\r\n  }\r\n\r\n  public set showFullImageRange(showFullImageRange: boolean) {\r\n    if (showFullImageRange === this._showFullImageRange) {\r\n      return;\r\n    }\r\n\r\n    this._showFullImageRange = showFullImageRange;\r\n    this.render();\r\n  }\r\n\r\n  public appendTo(container: HTMLElement) {\r\n    container.appendChild(this._canvas);\r\n    this.render();\r\n  }\r\n\r\n  public dispose() {\r\n    const { _canvas: canvas } = this;\r\n    const { parentElement } = canvas;\r\n\r\n    parentElement?.removeChild(canvas);\r\n  }\r\n\r\n  private static validateProps(props: ColorbarCanvasProps) {\r\n    const { size, imageRange, voiRange } = props;\r\n\r\n    if (size && !isColorbarSizeValid(size)) {\r\n      throw new Error('Invalid \"size\"');\r\n    }\r\n\r\n    if (imageRange && !isRangeValid(imageRange)) {\r\n      throw new Error('Invalid \"imageRange\"');\r\n    }\r\n\r\n    if (voiRange && !isRangeValid(voiRange)) {\r\n      throw new Error('Invalid \"voiRange\"');\r\n    }\r\n  }\r\n\r\n  private _setCanvasSize(canvas: HTMLCanvasElement, size: ColorbarSize) {\r\n    const { width, height } = size;\r\n\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n\r\n    Object.assign(canvas.style, {\r\n      width: `${width}px`,\r\n      height: `${height}px`,\r\n    });\r\n  }\r\n\r\n  private _createRootElement(size: ColorbarSize) {\r\n    const canvas = document.createElement('canvas');\r\n\r\n    Object.assign(canvas.style, {\r\n      position: 'absolute',\r\n      top: '0',\r\n      left: '0',\r\n      pointerEvents: 'none',\r\n      boxSizing: 'border-box',\r\n    });\r\n\r\n    this._setCanvasSize(canvas, size);\r\n\r\n    return canvas;\r\n  }\r\n\r\n  private render(): void {\r\n    if (!this._canvas.isConnected) {\r\n      return;\r\n    }\r\n\r\n    const { _colormap: colormap } = this;\r\n    const { RGBPoints: rgbPoints } = colormap;\r\n    const colorsCount = rgbPoints.length / 4;\r\n\r\n    // Returns a color point from rgbPoints. Each point has position, red,\r\n    // green and blue components which means each point has an offset equal\r\n    // to `4 * index`\r\n    const getColorPoint = (index) => {\r\n      const offset = 4 * index;\r\n\r\n      // It can get out of bounds when `voiRange.upper` is smaller than\r\n      // `imageRange.upper`. It's also checking if is smaller than zero\r\n      // for safety only because that should never happens.\r\n      if (index < 0 || index >= colorsCount) {\r\n        return;\r\n      }\r\n\r\n      return {\r\n        index,\r\n        position: rgbPoints[offset],\r\n        color: [\r\n          rgbPoints[offset + 1],\r\n          rgbPoints[offset + 2],\r\n          rgbPoints[offset + 3],\r\n        ],\r\n      };\r\n    };\r\n\r\n    const { width, height } = this._canvas;\r\n    const canvasContext = this._canvas.getContext('2d');\r\n    const isHorizontal = width > height;\r\n    const maxValue = isHorizontal ? width : height;\r\n    const { _voiRange: voiRange } = this;\r\n    const range = this._showFullImageRange ? this._imageRange : { ...voiRange };\r\n\r\n    const { windowWidth } = utilities.windowLevel.toWindowLevel(\r\n      voiRange.lower,\r\n      voiRange.upper\r\n    );\r\n\r\n    let previousColorPoint = undefined;\r\n    let currentColorPoint = getColorPoint(0);\r\n\r\n    // Starts from `range.lower` incrementing by incRawPixelValue on each iteration\r\n    const incRawPixelValue = (range.upper - range.lower) / (maxValue - 1);\r\n    let rawPixelValue = range.lower;\r\n\r\n    for (let i = 0; i < maxValue; i++) {\r\n      const tVoiRange = (rawPixelValue - voiRange.lower) / windowWidth;\r\n\r\n      // Find the color in a linear way (O(n) complexity).\r\n      // currentColorPoint shall move to the next color until tVoiRange is smaller\r\n      // than or equal to next color position.\r\n      if (currentColorPoint) {\r\n        for (let i = currentColorPoint.index; i < colorsCount; i++) {\r\n          if (tVoiRange <= currentColorPoint.position) {\r\n            break;\r\n          }\r\n\r\n          previousColorPoint = currentColorPoint;\r\n          currentColorPoint = getColorPoint(i + 1);\r\n        }\r\n      }\r\n\r\n      let normColor;\r\n\r\n      // For:\r\n      //   - firstColorPoint = getColorPoint(0)\r\n      //   - secondColorPoint = getColorPoint(1)\r\n      //   - lastColorPoint = getColorPoint(colorsCount - 1)\r\n      // Then\r\n      //   - previousColorPoint shall be undefined when tVoiRange < firstColorPoint.position\r\n      //   - currentColorPoint shall be undefined when tVoiRange > lastColorPoint.position\r\n      //   - previousColorPoint and currentColorPoint will be defined when\r\n      //     currentColorPoint.position is between secondColorPoint.position and\r\n      //     lastColorPoint.position.\r\n      if (!previousColorPoint) {\r\n        normColor = [...currentColorPoint.color];\r\n      } else if (!currentColorPoint) {\r\n        normColor = [...previousColorPoint.color];\r\n      } else {\r\n        const tColorRange =\r\n          (tVoiRange - previousColorPoint.position) /\r\n          (currentColorPoint.position - previousColorPoint.position);\r\n\r\n        normColor = interpolateVec3(\r\n          previousColorPoint.color,\r\n          currentColorPoint.color,\r\n          tColorRange\r\n        );\r\n      }\r\n\r\n      const color = normColor.map((color) =>\r\n        clamp(Math.round(color * 255), 0, 255)\r\n      );\r\n\r\n      canvasContext.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;\r\n\r\n      if (isHorizontal) {\r\n        canvasContext.fillRect(i, 0, 1, height);\r\n      } else {\r\n        canvasContext.fillRect(0, height - i - 1, width, 1);\r\n      }\r\n\r\n      rawPixelValue += incRawPixelValue;\r\n    }\r\n  }\r\n}\r\n\r\nexport { ColorbarCanvas as default, ColorbarCanvas };\r\n","import type {\r\n  ColorbarImageRange,\r\n  ColorbarVOIRange,\r\n  ColorbarSize,\r\n  ColorbarTicksProps,\r\n} from './types';\r\nimport {\r\n  isColorbarSizeValid,\r\n  isRangeValid,\r\n  areColorbarRangesEqual,\r\n  areColorbarSizesEqual,\r\n} from './common';\r\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\r\n\r\nconst DEFAULTS = {\r\n  FONT: '10px Arial',\r\n  COLOR: 'white',\r\n  TICK_SIZE: 5,\r\n  TICK_WIDTH: 1,\r\n  TICK_LABEL_MARGIN: 3,\r\n  MAX_NUM_TICKS: 8,\r\n\r\n  // Must start with 1 and end with 10\r\n  TICKS_STEPS: [1, 2.5, 5, 10],\r\n};\r\n\r\nclass ColorbarTicks {\r\n  private _canvas: HTMLCanvasElement;\r\n  private _imageRange: ColorbarImageRange;\r\n  private _voiRange: ColorbarVOIRange;\r\n  private _color: string;\r\n  private _tickSize: number;\r\n  private _tickWidth: number;\r\n  private _labelMargin: number;\r\n  private _maxNumTicks: number;\r\n  private _rangeTextPosition: ColorbarRangeTextPosition;\r\n  private _showFullPixelValueRange: boolean;\r\n  private _font: string;\r\n\r\n  constructor(props: ColorbarTicksProps) {\r\n    ColorbarTicks.validateProps(props);\r\n\r\n    const {\r\n      top = 0,\r\n      left = 0,\r\n      size = { width: 20, height: 100 },\r\n      imageRange = { lower: 0, upper: 1 },\r\n      voiRange = { lower: 0, upper: 1 },\r\n      ticks: ticksProps,\r\n      container,\r\n      showFullPixelValueRange = false,\r\n    } = props;\r\n\r\n    const { style: ticksStyle, position: rangeTextPosition } = ticksProps ?? {};\r\n\r\n    this._imageRange = imageRange;\r\n    this._voiRange = voiRange;\r\n    this._font = ticksStyle?.font ?? DEFAULTS.FONT;\r\n    this._color = ticksStyle?.color ?? DEFAULTS.COLOR;\r\n    this._tickSize = ticksStyle?.tickSize ?? DEFAULTS.TICK_SIZE;\r\n    this._tickWidth = ticksStyle?.tickWidth ?? DEFAULTS.TICK_WIDTH;\r\n    this._labelMargin = ticksStyle?.labelMargin ?? DEFAULTS.TICK_LABEL_MARGIN;\r\n    this._maxNumTicks = ticksStyle?.maxNumTicks ?? DEFAULTS.MAX_NUM_TICKS;\r\n    this._rangeTextPosition =\r\n      rangeTextPosition ?? ColorbarRangeTextPosition.Right;\r\n    this._showFullPixelValueRange = showFullPixelValueRange;\r\n    this._canvas = this._createCanvasElement(size, top, left);\r\n\r\n    if (container) {\r\n      this.appendTo(container);\r\n    }\r\n  }\r\n\r\n  public get size(): ColorbarSize {\r\n    const { width, height } = this._canvas;\r\n    return { width, height };\r\n  }\r\n\r\n  public set size(size: ColorbarSize) {\r\n    const { _canvas: canvas } = this;\r\n\r\n    if (!isColorbarSizeValid(size) || areColorbarSizesEqual(canvas, size)) {\r\n      return;\r\n    }\r\n\r\n    this._setCanvasSize(canvas, size);\r\n    this.render();\r\n  }\r\n\r\n  /**\r\n   * Canvas top position (pixels)\r\n   */\r\n  public get top(): number {\r\n    return Number.parseInt(this._canvas.style.top);\r\n  }\r\n\r\n  /**\r\n   * Change the canvas top position (pixels)\r\n   */\r\n  public set top(top: number) {\r\n    const { _canvas: canvas } = this;\r\n    const currentTop = this.top;\r\n\r\n    if (top === currentTop) {\r\n      return;\r\n    }\r\n\r\n    canvas.style.top = `${top}px`;\r\n    this.render();\r\n  }\r\n\r\n  /**\r\n   * Canvas left position (pixels)\r\n   */\r\n  public get left(): number {\r\n    return Number.parseInt(this._canvas.style.left);\r\n  }\r\n\r\n  /**\r\n   * Change the canvas left position (pixels)\r\n   */\r\n  public set left(left: number) {\r\n    const { _canvas: canvas } = this;\r\n    const currentLeft = this.left;\r\n\r\n    if (left === currentLeft) {\r\n      return;\r\n    }\r\n\r\n    canvas.style.left = `${left}px`;\r\n    this.render();\r\n  }\r\n\r\n  /**\r\n   * Image range\r\n   */\r\n  public get imageRange() {\r\n    return { ...this._imageRange };\r\n  }\r\n\r\n  /**\r\n   * Set the image range that should goes from minPixelValue to maxPixelValue\r\n   */\r\n  public set imageRange(imageRange: ColorbarVOIRange) {\r\n    if (\r\n      !isRangeValid(imageRange) ||\r\n      areColorbarRangesEqual(imageRange, this._imageRange)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    this._imageRange = imageRange;\r\n    this.render();\r\n  }\r\n\r\n  /**\r\n   * VOI range\r\n   * (lower: wc - ww / 2, upper: wc + ww / 2)\r\n   */\r\n  public get voiRange() {\r\n    return { ...this._voiRange };\r\n  }\r\n\r\n  /**\r\n   * Set the VOI Range\r\n   * (lower: wc - ww / 2, upper: wc + ww / 2)\r\n   */\r\n  public set voiRange(voiRange: ColorbarVOIRange) {\r\n    if (\r\n      !isRangeValid(voiRange) ||\r\n      areColorbarRangesEqual(voiRange, this._voiRange)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    this._voiRange = voiRange;\r\n    this.render();\r\n  }\r\n\r\n  /**\r\n   * Tick size (pixels)\r\n   */\r\n  public get tickSize(): number {\r\n    return this._tickSize;\r\n  }\r\n\r\n  /**\r\n   * Set the tick size\r\n   */\r\n  public set tickSize(tickSize: number) {\r\n    if (tickSize === this._tickSize) {\r\n      return;\r\n    }\r\n\r\n    this._tickSize = tickSize;\r\n    this.render();\r\n  }\r\n\r\n  /**\r\n   * Tick width (pixels)\r\n   */\r\n  public get tickWidth(): number {\r\n    return this._tickWidth;\r\n  }\r\n\r\n  /**\r\n   * Set the tick width. This width is used as `lineWidth` by CanvasRenderingContext2D.\r\n   *\r\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineWidth\r\n   */\r\n  public set tickWidth(tickWidth: number) {\r\n    if (tickWidth === this._tickWidth) {\r\n      return;\r\n    }\r\n\r\n    this._tickWidth = tickWidth;\r\n    this.render();\r\n  }\r\n\r\n  /**\r\n   * Color used for ticks and labels.\r\n   */\r\n  public get color(): string {\r\n    return this._color;\r\n  }\r\n\r\n  /**\r\n   * Set the color used for ticks and labels. This color is used as `strokeStyle`\r\n   * and `fillStyle` by CanvasRenderingContext2D.\r\n   *\r\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle\r\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle\r\n   */\r\n  public set color(color: string) {\r\n    if (color === this._color) {\r\n      return;\r\n    }\r\n\r\n    this._color = color;\r\n    this.render();\r\n  }\r\n\r\n  /**\r\n   * Return `true` when the ticks displayed are in the range from `imageRange.lower`\r\n   * to `imageRange.upper` or `false` when they are in the range from `voiRange.lower`\r\n   * to `voiRange.upper`\r\n   */\r\n  public get showFullPixelValueRange(): boolean {\r\n    return this._showFullPixelValueRange;\r\n  }\r\n\r\n  /**\r\n   * Change which range should be used when rendering the ticks. Set it to `true`\r\n   * to show from `imageRange.lower` to `imageRange.upper` or `false` show from\r\n   * `voiRange.lower` to `voiRange.upper`.\r\n   */\r\n  public set showFullPixelValueRange(showFullRange: boolean) {\r\n    if (showFullRange === this._showFullPixelValueRange) {\r\n      return;\r\n    }\r\n\r\n    this._showFullPixelValueRange = showFullRange;\r\n    this.render();\r\n  }\r\n\r\n  /**\r\n   * Ticks visibility\r\n   */\r\n  public get visible() {\r\n    return this._canvas.style.display === 'block';\r\n  }\r\n\r\n  /**\r\n   * Show/Hide the ticks\r\n   */\r\n  public set visible(visible) {\r\n    if (visible === this.visible) {\r\n      return;\r\n    }\r\n\r\n    this._canvas.style.display = visible ? 'block' : 'none';\r\n\r\n    if (visible) {\r\n      this.render();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Append the canvas to its parent element\r\n   * @param container - HTML element where the canvas should be added to\r\n   */\r\n  public appendTo(container: HTMLElement) {\r\n    container.appendChild(this._canvas);\r\n    this.render();\r\n  }\r\n\r\n  private static validateProps(props: ColorbarTicksProps) {\r\n    const { size, imageRange, voiRange } = props;\r\n\r\n    if (size && !isColorbarSizeValid(size)) {\r\n      throw new Error('Invalid \"size\"');\r\n    }\r\n\r\n    if (imageRange && !isRangeValid(imageRange)) {\r\n      throw new Error('Invalid \"imageRange\"');\r\n    }\r\n\r\n    if (voiRange && !isRangeValid(voiRange)) {\r\n      throw new Error('Invalid \"voiRange\"');\r\n    }\r\n  }\r\n\r\n  private _setCanvasSize(canvas: HTMLCanvasElement, size: ColorbarSize) {\r\n    const { width, height } = size;\r\n\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n\r\n    Object.assign(canvas.style, {\r\n      width: `${width}px`,\r\n      height: `${height}px`,\r\n    });\r\n  }\r\n\r\n  private _createCanvasElement(\r\n    size: ColorbarSize,\r\n    top: number,\r\n    left: number\r\n  ): HTMLCanvasElement {\r\n    const canvas = document.createElement('canvas');\r\n\r\n    Object.assign(canvas.style, {\r\n      display: 'none',\r\n      position: 'absolute',\r\n      boxSizing: 'border-box',\r\n      top: `${top}px`,\r\n      left: `${left}px`,\r\n    });\r\n\r\n    this._setCanvasSize(canvas, size);\r\n\r\n    return canvas;\r\n  }\r\n\r\n  /**\r\n   * Calculate how many ticks can be displayed on the screen based on the\r\n   * pre-defined steps (`TICKS_STEPS`) as follow:\r\n   *   1. Calculate what should be the step (`roughStep`) based on the range and\r\n   *   the number of desired steps (`maxNumTicks`).\r\n   *   2. Find a number power of 10 (eg: 0.1, 1, 10, 100, etc.) that can be used\r\n   *   to multiply `roughStep` and return a number between 1 and 10 which is\r\n   *   called `roughtStepNormalized`.\r\n   *   3. Find in the TICKS_STEPS array a number that is bigger than or equal to\r\n   *   the `roughtStepNormalized` value (`normalizedStep`).\r\n   *   4. Multiply the `normalizedStep` to move it to the real range.\r\n   *\r\n   * @param range - Range with \"lower\" and \"upper\" values\r\n   */\r\n  private _getTicks(range) {\r\n    const { lower, upper } = range;\r\n    const rangeValue = upper - lower;\r\n\r\n    // First approximation based on the max number of ticks\r\n    const roughStep = rangeValue / (this._maxNumTicks - 1);\r\n\r\n    // Normalize rough step to find the normalized one that fits best\r\n    const stepPower = Math.pow(\r\n      10,\r\n      -Math.floor(Math.log10(Math.abs(roughStep)))\r\n    );\r\n\r\n    // Get a number between 1 and 10\r\n    const roughtStepNormalized = roughStep * stepPower;\r\n\r\n    // Find a normalize step that is greater than or equal to `roughtStepNormalized`\r\n    const normalizedStep = DEFAULTS.TICKS_STEPS.find(\r\n      (n) => n >= roughtStepNormalized\r\n    );\r\n\r\n    // Move `normalizedStep` to the real range\r\n    const step = normalizedStep / stepPower;\r\n\r\n    // Determine the scale limits based on the chosen step.\r\n    const scaleMax = Math.ceil(upper / step) * step;\r\n    const scaleMin = Math.floor(lower / step) * step;\r\n\r\n    // Find a possible tick values for the `step` computed\r\n    const ticksCount = Math.round((scaleMax - scaleMin) / step) + 1;\r\n    const ticks = [];\r\n\r\n    for (let i = 0; i < ticksCount; i++) {\r\n      ticks.push(scaleMin + i * step);\r\n    }\r\n\r\n    return { scaleMin, scaleMax, step, ticks };\r\n  }\r\n\r\n  private _getLeftTickInfo({ position, labelMeasure }) {\r\n    const { width } = this._canvas;\r\n    const labelX =\r\n      width - this.tickSize - labelMeasure.width - this._labelMargin;\r\n    const labelPoint = [labelX, position];\r\n    const tickPoints = {\r\n      start: [width - this._tickSize, position],\r\n      end: [width, position],\r\n    };\r\n\r\n    return { labelPoint, tickPoints };\r\n  }\r\n\r\n  private _getRightTickInfo({ position }) {\r\n    const labelPoint = [this._tickSize + this._labelMargin, position];\r\n    const tickPoints = {\r\n      start: [0, position],\r\n      end: [this._tickSize, position],\r\n    };\r\n\r\n    return { labelPoint, tickPoints };\r\n  }\r\n\r\n  private _getTopTickInfo({ position, labelMeasure }) {\r\n    throw new Error('Not implemented');\r\n  }\r\n\r\n  private _getBottomTickInfo({ position, labelMeasure }) {\r\n    throw new Error('Not implemented');\r\n  }\r\n\r\n  private render() {\r\n    const { _canvas: canvas } = this;\r\n\r\n    if (!canvas.isConnected || !this.visible) {\r\n      return;\r\n    }\r\n\r\n    const { width, height } = canvas;\r\n    const isHorizontal = width >= height;\r\n    const maxCanvasPixelValue = isHorizontal ? width : height;\r\n    const canvasContext = canvas.getContext('2d');\r\n    const { _voiRange: voiRange } = this;\r\n    const range = this._showFullPixelValueRange\r\n      ? this._imageRange\r\n      : { ...voiRange };\r\n    const rangeWidth = range.upper - range.lower;\r\n    const { ticks } = this._getTicks(range);\r\n\r\n    canvasContext.clearRect(0, 0, width, height);\r\n    canvasContext.font = this._font;\r\n    canvasContext.textBaseline = 'middle';\r\n    canvasContext.fillStyle = this._color;\r\n    canvasContext.strokeStyle = this._color;\r\n    canvasContext.lineWidth = this.tickWidth;\r\n\r\n    ticks.forEach((tick) => {\r\n      let position = Math.round(\r\n        maxCanvasPixelValue * ((tick - range.lower) / rangeWidth)\r\n      );\r\n\r\n      // Zero at the bottom and max at the top on vertical colorbars\r\n      if (!isHorizontal) {\r\n        position = height - position;\r\n      }\r\n\r\n      if (position < 0 || position > maxCanvasPixelValue) {\r\n        return;\r\n      }\r\n\r\n      const label = tick.toString();\r\n      const labelMeasure = canvasContext.measureText(label);\r\n      let tickInfo;\r\n\r\n      if (isHorizontal) {\r\n        if (this._rangeTextPosition === ColorbarRangeTextPosition.Top) {\r\n          tickInfo = this._getTopTickInfo({ position, labelMeasure });\r\n        } else {\r\n          tickInfo = this._getBottomTickInfo({ position, labelMeasure });\r\n        }\r\n      } else {\r\n        if (this._rangeTextPosition === ColorbarRangeTextPosition.Left) {\r\n          tickInfo = this._getLeftTickInfo({ position, labelMeasure });\r\n        } else {\r\n          tickInfo = this._getRightTickInfo({ position });\r\n        }\r\n      }\r\n\r\n      const { labelPoint, tickPoints } = tickInfo;\r\n      const { start: tickStart, end: tickEnd } = tickPoints;\r\n\r\n      canvasContext.beginPath();\r\n      canvasContext.moveTo(tickStart[0], tickStart[1]);\r\n      canvasContext.lineTo(tickEnd[0], tickEnd[1]);\r\n      canvasContext.fillText(label, labelPoint[0], labelPoint[1]);\r\n      canvasContext.stroke();\r\n\r\n      return position;\r\n    });\r\n  }\r\n}\r\n\r\nexport { ColorbarTicks as default, ColorbarTicks };\r\n","import type { WidgetProps, WidgetSize } from './types';\r\n\r\n/**\r\n * Base class for any widget that can be added to cornerstone. Currently it is\r\n * responsible only for holding the `rootElement`, contains a method that allows\r\n * adding it to the DOM and it also listens to container's size changes when the\r\n * widget is already added to the DOM. `dispose` must be called to destroy the\r\n * widget because it removes the widget from the DOM and stop listening to\r\n * container changes.\r\n *\r\n * You can apply some styles to widgets using the widget id or the `widget` class.\r\n *\r\n * Example:\r\n *   type ColorPickerProps = WidgetProps & {\r\n *     selectedColor: string;\r\n *   }\r\n *\r\n *   class ColorPicker extends Widget {\r\n *     constructor(props: ColorPickerProps) {\r\n *       super(props);\r\n *       // [code]\r\n *     }\r\n *\r\n *     public show() {\r\n *       console.log('Show color picker');\r\n *     }\r\n *\r\n *     protected containerResized() {\r\n *       console.log('New container size: ', this.containerSize);\r\n *     }\r\n *   }\r\n *\r\n *   const colorPicker = new ColorPicker({\r\n *     container: document.body,\r\n *     selectedColor: '#000';\r\n *   });\r\n *\r\n *   // another way to add the color picker to the DOM\r\n *   colorPicker.appendTo(document.body)\r\n *\r\n *   // Show color picker\r\n *   colorPicker.show();\r\n */\r\nabstract class Widget {\r\n  private _id: string;\r\n  private _rootElement: HTMLElement;\r\n  private _containerSize: WidgetSize;\r\n  private _containerResizeObserver: ResizeObserver;\r\n\r\n  constructor({ id, container }: WidgetProps) {\r\n    this._id = id;\r\n    this._containerSize = { width: 0, height: 0 };\r\n    this._rootElement = this.createRootElement(id);\r\n    this._containerResizeObserver = new ResizeObserver(\r\n      this._containerResizeCallback\r\n    );\r\n\r\n    if (container) {\r\n      this.appendTo(container);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Widget id\r\n   */\r\n  public get id() {\r\n    return this._id;\r\n  }\r\n\r\n  /**\r\n   * Widget's root element\r\n   */\r\n  public get rootElement(): HTMLElement {\r\n    return this._rootElement;\r\n  }\r\n\r\n  /**\r\n   * Append the widget to a parent element\r\n   * @param container - HTML element where the widget should be added to\r\n   */\r\n  public appendTo(container: HTMLElement) {\r\n    const {\r\n      _rootElement: rootElement,\r\n      _containerResizeObserver: resizeObserver,\r\n    } = this;\r\n    const { parentElement: currentContainer } = rootElement;\r\n\r\n    if (!container || container === currentContainer) {\r\n      return;\r\n    }\r\n\r\n    if (currentContainer) {\r\n      resizeObserver.unobserve(currentContainer);\r\n    }\r\n\r\n    container.appendChild(rootElement);\r\n    resizeObserver.observe(container);\r\n  }\r\n\r\n  /**\r\n   * Removes the widget from the DOM and stop listening to DOM events\r\n   */\r\n  public destroy() {\r\n    const {\r\n      _rootElement: rootElement,\r\n      _containerResizeObserver: resizeObserver,\r\n    } = this;\r\n    const { parentElement } = rootElement;\r\n\r\n    parentElement?.removeChild(rootElement);\r\n    resizeObserver.disconnect();\r\n  }\r\n\r\n  protected get containerSize(): WidgetSize {\r\n    // Returns a copy to prevent any external change\r\n    return { ...this._containerSize };\r\n  }\r\n\r\n  /**\r\n   * Creates the root element which is a div by default\r\n   * @param id - Root element id\r\n   * @returns A new HTML element where all other elements should be added to\r\n   */\r\n  protected createRootElement(id: string): HTMLElement {\r\n    const rootElement = document.createElement('div');\r\n\r\n    rootElement.id = id;\r\n    rootElement.classList.add('widget');\r\n\r\n    Object.assign(rootElement.style, {\r\n      width: '100%',\r\n      height: '100%',\r\n    });\r\n\r\n    return rootElement;\r\n  }\r\n\r\n  /**\r\n   * Method called every time widget's container is resize giving the\r\n   * opportunity to children classes to act when that happens.\r\n   */\r\n  protected onContainerResize() {\r\n    // no-op\r\n  }\r\n\r\n  private _containerResizeCallback = (entries: ResizeObserverEntry[]): void => {\r\n    let width;\r\n    let height;\r\n\r\n    const { contentRect, contentBoxSize } = entries[0];\r\n\r\n    // `contentRect` is better supported than `borderBoxSize` or `contentBoxSize`,\r\n    // but it is left over from an earlier implementation of the Resize Observer API\r\n    // and may be deprecated in future versions.\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry/contentRect\r\n    if (contentRect) {\r\n      width = contentRect.width;\r\n      height = contentRect.height;\r\n    } else if (contentBoxSize?.length) {\r\n      width = contentBoxSize[0].inlineSize;\r\n      height = contentBoxSize[0].blockSize;\r\n    }\r\n\r\n    this._containerSize = { width, height };\r\n    this.onContainerResize();\r\n  };\r\n}\r\n\r\nexport { Widget as default, Widget };\r\n","import { IColorMapPreset } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\r\nimport { vec2 } from 'gl-matrix';\r\nimport { utilities as csUtils, Types } from '@cornerstonejs/core';\r\nimport type { ColorbarProps, ColorbarVOIRange } from './types';\r\nimport { isRangeValid, areColorbarRangesEqual } from './common';\r\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\r\nimport { ColorbarCanvas } from './ColorbarCanvas';\r\nimport { ColorbarTicks } from './ColorbarTicks';\r\nimport isRangeTextPositionValid from './common/isRangeTextPositionValid';\r\nimport Widget from '../../../widgets/Widget';\r\n\r\nconst DEFAULTS = {\r\n  MULTIPLIER: 1,\r\n  RANGE_TEXT_POSITION: ColorbarRangeTextPosition.Right,\r\n  TICKS_BAR_SIZE: 50,\r\n};\r\n\r\ntype ColorbarPoints = {\r\n  page: Types.Point2;\r\n  client: Types.Point2;\r\n  local: Types.Point2;\r\n};\r\n\r\n/**\r\n * A base colorbar class that is not associated with any viewport. It is\r\n * possible to click and drag to change the VOI range, shows the ticks during\r\n * interaction and it can show full image range or VOI range.\r\n */\r\nclass Colorbar extends Widget {\r\n  private _colormaps: Map<string, IColorMapPreset>;\r\n  private _activeColormapName: string;\r\n  private _eventListenersManager: csUtils.eventListener.MultiTargetEventListenerManager;\r\n  private _canvas: ColorbarCanvas;\r\n  private _ticksBar: ColorbarTicks;\r\n  private _rangeTextPosition: ColorbarRangeTextPosition;\r\n\r\n  private _isMouseOver = false;\r\n  private _isInteracting = false;\r\n\r\n  constructor(props: ColorbarProps) {\r\n    super(props);\r\n\r\n    this._eventListenersManager =\r\n      new csUtils.eventListener.MultiTargetEventListenerManager();\r\n    this._colormaps = Colorbar.getColormapsMap(props);\r\n    this._activeColormapName = Colorbar.getInitialColormapName(props);\r\n    this._canvas = this._createCanvas(props);\r\n    this._ticksBar = this._createTicksBar(props);\r\n    this._rangeTextPosition =\r\n      props.ticks?.position ?? DEFAULTS.RANGE_TEXT_POSITION;\r\n\r\n    this._canvas.appendTo(this.rootElement);\r\n    this._ticksBar.appendTo(this.rootElement);\r\n\r\n    this._addRootElementEventListeners();\r\n  }\r\n\r\n  /**\r\n   * Returns the active LUT name\r\n   */\r\n  public get activeColormapName() {\r\n    return this._activeColormapName;\r\n  }\r\n\r\n  /**\r\n   * Set the current active LUT name and re-renders the color bar\r\n   */\r\n  public set activeColormapName(colormapName: string) {\r\n    if (colormapName === this._activeColormapName) {\r\n      return;\r\n    }\r\n\r\n    const colormap = this._colormaps.get(colormapName);\r\n\r\n    if (!colormap) {\r\n      console.warn(`Invalid colormap name (${colormapName})`);\r\n      return;\r\n    }\r\n\r\n    this._activeColormapName = colormapName;\r\n    this._canvas.colormap = colormap;\r\n  }\r\n\r\n  public get imageRange() {\r\n    return this._canvas.imageRange;\r\n  }\r\n\r\n  public set imageRange(imageRange: ColorbarVOIRange) {\r\n    this._canvas.imageRange = imageRange;\r\n    this._ticksBar.imageRange = imageRange;\r\n  }\r\n\r\n  public get voiRange() {\r\n    return this._canvas.voiRange;\r\n  }\r\n\r\n  public set voiRange(voiRange: ColorbarVOIRange) {\r\n    const { voiRange: currentVoiRange } = this._canvas;\r\n\r\n    if (\r\n      !isRangeValid(voiRange) ||\r\n      areColorbarRangesEqual(voiRange, currentVoiRange)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    this._canvas.voiRange = voiRange;\r\n    this._ticksBar.voiRange = voiRange;\r\n    this.onVoiChange(voiRange);\r\n  }\r\n\r\n  public get showFullImageRange() {\r\n    return this._canvas.showFullImageRange;\r\n  }\r\n\r\n  public set showFullImageRange(value: boolean) {\r\n    this._canvas.showFullImageRange = value;\r\n    this._ticksBar.showFullPixelValueRange = value;\r\n  }\r\n\r\n  public destroy() {\r\n    super.destroy();\r\n    this._eventListenersManager.reset();\r\n  }\r\n\r\n  protected createRootElement(): HTMLElement {\r\n    const rootElement = document.createElement('div');\r\n\r\n    Object.assign(rootElement.style, {\r\n      position: 'relative',\r\n      fontSize: '0',\r\n      width: '100%',\r\n      height: '100%',\r\n    });\r\n\r\n    return rootElement;\r\n  }\r\n\r\n  protected onContainerResize() {\r\n    super.onContainerResize();\r\n    this.updateTicksBar();\r\n    this._canvas.size = this.containerSize;\r\n  }\r\n\r\n  protected getVOIMultipliers(): [number, number] {\r\n    return [DEFAULTS.MULTIPLIER, DEFAULTS.MULTIPLIER];\r\n  }\r\n\r\n  protected onVoiChange(voiRange: ColorbarVOIRange) {\r\n    // no-op\r\n  }\r\n\r\n  protected showTicks() {\r\n    this.updateTicksBar();\r\n    this._ticksBar.visible = true;\r\n  }\r\n\r\n  protected hideTicks() {\r\n    if (this._isInteracting || this._isMouseOver) {\r\n      return;\r\n    }\r\n\r\n    this._ticksBar.visible = false;\r\n  }\r\n\r\n  private static getColormapsMap(props: ColorbarProps) {\r\n    const { colormaps } = props;\r\n\r\n    return colormaps.reduce(\r\n      (items, item) => items.set(item.Name, item),\r\n      new Map<string, IColorMapPreset>()\r\n    );\r\n  }\r\n\r\n  private static getInitialColormapName(props: ColorbarProps) {\r\n    const { activeColormapName, colormaps } = props;\r\n    const colormapExists =\r\n      !!activeColormapName &&\r\n      colormaps.some((cm) => cm.Name === activeColormapName);\r\n\r\n    return colormapExists ? activeColormapName : colormaps[0].Name;\r\n  }\r\n\r\n  private _createCanvas(props: ColorbarProps) {\r\n    const { imageRange, voiRange, showFullPixelValueRange } = props;\r\n    const colormap = this._colormaps.get(this._activeColormapName);\r\n\r\n    return new ColorbarCanvas({\r\n      colormap,\r\n      imageRange,\r\n      voiRange: voiRange,\r\n      showFullPixelValueRange,\r\n    });\r\n  }\r\n\r\n  public _createTicksBar(props: ColorbarProps): ColorbarTicks {\r\n    const ticksProps = props.ticks;\r\n\r\n    return new ColorbarTicks({\r\n      imageRange: props.imageRange,\r\n      voiRange: props.voiRange,\r\n      ticks: ticksProps,\r\n      showFullPixelValueRange: props.showFullPixelValueRange,\r\n    });\r\n  }\r\n\r\n  private _getPointsFromMouseEvent(evt: MouseEvent): ColorbarPoints {\r\n    const { rootElement: element } = this;\r\n    const clientPoint: Types.Point2 = [evt.clientX, evt.clientY];\r\n    const pagePoint: Types.Point2 = [evt.pageX, evt.pageY];\r\n    const rect = element.getBoundingClientRect();\r\n    const localPoints: Types.Point2 = [\r\n      pagePoint[0] - rect.left - window.pageXOffset,\r\n      pagePoint[1] - rect.top - window.pageYOffset,\r\n    ];\r\n\r\n    return { client: clientPoint, page: pagePoint, local: localPoints };\r\n  }\r\n\r\n  private updateTicksBar() {\r\n    const { width: containerWidth, height: containerHeight } =\r\n      this.containerSize;\r\n\r\n    // ResizeObserver have not triggered any event when this happen\r\n    if (containerWidth === 0 && containerHeight === 0) {\r\n      return;\r\n    }\r\n\r\n    const { _ticksBar: ticksBar, _rangeTextPosition: rangeTextPosition } = this;\r\n    const isHorizontal = containerWidth >= containerHeight;\r\n    const width = isHorizontal ? containerWidth : DEFAULTS.TICKS_BAR_SIZE;\r\n    const height = isHorizontal ? DEFAULTS.TICKS_BAR_SIZE : containerHeight;\r\n\r\n    if (\r\n      !isRangeTextPositionValid(\r\n        containerWidth,\r\n        containerHeight,\r\n        rangeTextPosition\r\n      )\r\n    ) {\r\n      throw new Error(\r\n        'Invalid rangeTextPosition value for the current colobar orientation'\r\n      );\r\n    }\r\n\r\n    let ticksBarTop;\r\n    let ticksBarLeft;\r\n\r\n    ticksBar.size = { width, height };\r\n\r\n    if (isHorizontal) {\r\n      ticksBarLeft = 0;\r\n      ticksBarTop =\r\n        rangeTextPosition === ColorbarRangeTextPosition.Top\r\n          ? -height\r\n          : containerHeight;\r\n    } else {\r\n      ticksBarTop = 0;\r\n      ticksBarLeft =\r\n        rangeTextPosition === ColorbarRangeTextPosition.Left\r\n          ? -width\r\n          : containerWidth;\r\n    }\r\n\r\n    ticksBar.top = ticksBarTop;\r\n    ticksBar.left = ticksBarLeft;\r\n  }\r\n\r\n  private _mouseOverCallback = (evt) => {\r\n    this._isMouseOver = true;\r\n    this.showTicks();\r\n    evt.stopPropagation();\r\n  };\r\n\r\n  private _mouseOutCallback = (evt) => {\r\n    this._isMouseOver = false;\r\n    this.hideTicks();\r\n    evt.stopPropagation();\r\n  };\r\n\r\n  private _mouseDownCallback = (evt: MouseEvent) => {\r\n    this._isInteracting = true;\r\n    this.showTicks();\r\n    this._addVOIEventListeners(evt);\r\n    evt.stopPropagation();\r\n  };\r\n\r\n  private _mouseDragCallback = (evt, initialState) => {\r\n    const multipliers = this.getVOIMultipliers();\r\n    const currentPoints = this._getPointsFromMouseEvent(evt);\r\n    const { points: startPoints, voiRange: startVOIRange } = initialState;\r\n    const canvasDelta = vec2.sub(\r\n      vec2.create(),\r\n      currentPoints.local,\r\n      startPoints.local\r\n    );\r\n\r\n    const wwDelta = canvasDelta[0] * multipliers[0];\r\n    const wcDelta = canvasDelta[1] * multipliers[1];\r\n\r\n    if (!wwDelta && !wcDelta) {\r\n      return;\r\n    }\r\n\r\n    const { lower: voiLower, upper: voiUpper } = startVOIRange;\r\n    let { windowWidth, windowCenter } = csUtils.windowLevel.toWindowLevel(\r\n      voiLower,\r\n      voiUpper\r\n    );\r\n\r\n    windowWidth = Math.max(windowWidth + wwDelta, 1);\r\n    windowCenter += wcDelta;\r\n\r\n    const newVoiRange = csUtils.windowLevel.toLowHighRange(\r\n      windowWidth,\r\n      windowCenter\r\n    );\r\n\r\n    this.voiRange = newVoiRange;\r\n    evt.stopPropagation();\r\n    evt.preventDefault();\r\n  };\r\n\r\n  private _mouseUpCallback = (evt) => {\r\n    this._isInteracting = false;\r\n    this.hideTicks();\r\n    this._removeVOIEventListeners();\r\n    evt.stopPropagation();\r\n  };\r\n\r\n  private _addRootElementEventListeners() {\r\n    const { _eventListenersManager: manager } = this;\r\n    const { rootElement: element } = this;\r\n\r\n    manager.addEventListener(element, 'mouseover', this._mouseOverCallback);\r\n    manager.addEventListener(element, 'mouseout', this._mouseOutCallback);\r\n    manager.addEventListener(\r\n      element,\r\n      'mousedown',\r\n      this._mouseDownCallback as EventListener\r\n    );\r\n  }\r\n\r\n  private _addVOIEventListeners(evt: MouseEvent) {\r\n    const { _eventListenersManager: manager } = this;\r\n    const points = this._getPointsFromMouseEvent(evt);\r\n    const voiRange = { ...this._canvas.voiRange };\r\n    const initialDragState = { points, voiRange };\r\n\r\n    this._removeVOIEventListeners();\r\n\r\n    manager.addEventListener(document, 'voi.mouseup', this._mouseUpCallback);\r\n    manager.addEventListener(document, 'voi.mousemove', (evt) =>\r\n      this._mouseDragCallback(evt, initialDragState)\r\n    );\r\n  }\r\n\r\n  private _removeVOIEventListeners() {\r\n    const { _eventListenersManager: manager } = this;\r\n\r\n    manager.removeEventListener(document, 'voi.mouseup');\r\n    manager.removeEventListener(document, 'voi.mousemove');\r\n  }\r\n}\r\n\r\nexport { Colorbar as default, Colorbar };\r\n","import { ColorbarRangeTextPosition } from '../enums';\r\n\r\nfunction isRangeTextPositionValid(\r\n  colorbarWidth: number,\r\n  colorbarHeight: number,\r\n  rangeTextPosition: ColorbarRangeTextPosition\r\n) {\r\n  const isHorizontal = colorbarWidth >= colorbarHeight;\r\n  const validRangeTextPositions = isHorizontal\r\n    ? [ColorbarRangeTextPosition.Top, ColorbarRangeTextPosition.Bottom]\r\n    : [ColorbarRangeTextPosition.Left, ColorbarRangeTextPosition.Right];\r\n\r\n  return validRangeTextPositions.includes(rangeTextPosition);\r\n}\r\n\r\nexport { isRangeTextPositionValid as default, isRangeTextPositionValid };\r\n","import {\r\n  eventTarget,\r\n  VolumeViewport,\r\n  StackViewport,\r\n  Types,\r\n  Enums,\r\n  utilities,\r\n  getEnabledElement,\r\n} from '@cornerstonejs/core';\r\nimport { Colorbar } from './Colorbar';\r\nimport type { ViewportColorbarProps, ColorbarVOIRange } from './types';\r\nimport { getVOIMultipliers } from '../../getVOIMultipliers';\r\n\r\nconst { Events } = Enums;\r\nconst defaultImageRange = { lower: -1000, upper: 1000 };\r\n/**\r\n * A colorbar associated with a viewport that updates automatically when the\r\n * viewport VOI changes or when the stack/volume are updated..\r\n */\r\nclass ViewportColorbar extends Colorbar {\r\n  private _element: HTMLDivElement;\r\n  private _volumeId: string;\r\n\r\n  private _hideTicksTime: number;\r\n  private _hideTicksTimeoutId: number;\r\n\r\n  constructor(props: ViewportColorbarProps) {\r\n    const { element, volumeId } = props;\r\n    const imageRange = ViewportColorbar._getImageRange(element, volumeId);\r\n    const voiRange = ViewportColorbar._getVOIRange(element, volumeId);\r\n\r\n    super({ ...props, imageRange, voiRange });\r\n\r\n    this._element = element;\r\n    this._volumeId = volumeId;\r\n\r\n    this._addCornerstoneEventListener();\r\n  }\r\n\r\n  public get element() {\r\n    return this._element;\r\n  }\r\n\r\n  public get enabledElement() {\r\n    return getEnabledElement(this._element);\r\n  }\r\n\r\n  protected getVOIMultipliers(): [number, number] {\r\n    const { viewport } = this.enabledElement;\r\n    return getVOIMultipliers(viewport, this._volumeId);\r\n  }\r\n\r\n  protected onVoiChange(voiRange: ColorbarVOIRange) {\r\n    super.onVoiChange(voiRange);\r\n\r\n    const { viewport } = this.enabledElement;\r\n\r\n    if (viewport instanceof StackViewport) {\r\n      viewport.setProperties({\r\n        voiRange: voiRange,\r\n      });\r\n      viewport.render();\r\n    } else if (viewport instanceof VolumeViewport) {\r\n      const { _volumeId: volumeId } = this;\r\n      const viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(\r\n        volumeId,\r\n        viewport.renderingEngineId\r\n      );\r\n\r\n      viewport.setProperties({ voiRange }, volumeId);\r\n      viewportsContainingVolumeUID.forEach((vp) => vp.render());\r\n    }\r\n  }\r\n\r\n  private static _getImageRange(element, volumeId?) {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    const actor = volumeId\r\n      ? viewport.getActor(volumeId)\r\n      : viewport.getDefaultActor();\r\n\r\n    if (!actor) {\r\n      return defaultImageRange;\r\n    }\r\n\r\n    const imageData = actor.actor.getMapper().getInputData();\r\n    const imageRange = imageData.getPointData().getScalars().getRange();\r\n\r\n    return imageRange[0] === 0 && imageRange[1] === 0\r\n      ? defaultImageRange\r\n      : { lower: imageRange[0], upper: imageRange[1] };\r\n  }\r\n\r\n  private static _getVOIRange(element, volumeId) {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    const volumeActor = volumeId\r\n      ? viewport.getActor(volumeId)\r\n      : viewport.getDefaultActor();\r\n\r\n    if (!volumeActor || !utilities.isImageActor(volumeActor)) {\r\n      return defaultImageRange;\r\n    }\r\n\r\n    const voiRange = (volumeActor.actor as Types.ImageActor)\r\n      .getProperty()\r\n      .getRGBTransferFunction(0)\r\n      .getRange();\r\n\r\n    return voiRange[0] === 0 && voiRange[1] === 0\r\n      ? defaultImageRange\r\n      : { lower: voiRange[0], upper: voiRange[1] };\r\n  }\r\n\r\n  private autoHideTicks = () => {\r\n    // Avoiding calling setTimeout multiple times when manipulating the VOI\r\n    // via WindowLevel tool for better performance\r\n    if (this._hideTicksTimeoutId) {\r\n      return;\r\n    }\r\n\r\n    const timeLeft = this._hideTicksTime - Date.now();\r\n\r\n    if (timeLeft <= 0) {\r\n      this.hideTicks();\r\n    } else {\r\n      this._hideTicksTimeoutId = window.setTimeout(() => {\r\n        // Recursive call until there is no more time left\r\n        this._hideTicksTimeoutId = 0;\r\n        this.autoHideTicks();\r\n      }, timeLeft);\r\n    }\r\n  };\r\n\r\n  private showAndAutoHideTicks(interval = 1000) {\r\n    this._hideTicksTime = Date.now() + interval;\r\n    this.showTicks();\r\n    this.autoHideTicks();\r\n  }\r\n\r\n  private _stackNewImageCallback = () => {\r\n    this.imageRange = ViewportColorbar._getImageRange(this._element);\r\n  };\r\n\r\n  private _imageVolumeModifiedCallback = (\r\n    evt: Types.EventTypes.ImageVolumeModifiedEvent\r\n  ) => {\r\n    const { volumeId } = evt.detail.imageVolume;\r\n\r\n    if (volumeId !== this._volumeId) {\r\n      return;\r\n    }\r\n\r\n    const { _element: element } = this;\r\n    this.imageRange = ViewportColorbar._getImageRange(element, volumeId);\r\n  };\r\n\r\n  private _viewportVOIModifiedCallback = (\r\n    evt: Types.EventTypes.VoiModifiedEvent\r\n  ) => {\r\n    const { viewportId, volumeId, range: voiRange, colormap } = evt.detail;\r\n    const { viewport } = this.enabledElement;\r\n    if (viewportId !== viewport.id || volumeId !== this._volumeId) {\r\n      return;\r\n    }\r\n\r\n    this.voiRange = voiRange;\r\n\r\n    if (colormap) {\r\n      this.activeColormapName = colormap.name;\r\n    }\r\n    this.showAndAutoHideTicks();\r\n  };\r\n\r\n  private _viewportColormapModifiedCallback = (\r\n    evt: Types.EventTypes.ColormapModifiedEvent\r\n  ) => {\r\n    const { viewportId, colormap, volumeId } = evt.detail;\r\n    const { viewport } = this.enabledElement;\r\n\r\n    if (viewportId !== viewport.id || volumeId !== this._volumeId) {\r\n      return;\r\n    }\r\n\r\n    this.activeColormapName = colormap.name;\r\n  };\r\n\r\n  private _addCornerstoneEventListener() {\r\n    const { _element: element } = this;\r\n\r\n    eventTarget.addEventListener(\r\n      Events.IMAGE_VOLUME_MODIFIED,\r\n      this._imageVolumeModifiedCallback\r\n    );\r\n\r\n    element.addEventListener(\r\n      Events.STACK_NEW_IMAGE,\r\n      this._stackNewImageCallback\r\n    );\r\n\r\n    element.addEventListener(\r\n      Events.VOI_MODIFIED,\r\n      this._viewportVOIModifiedCallback as EventListener\r\n    );\r\n\r\n    element.addEventListener(\r\n      Events.COLORMAP_MODIFIED,\r\n      this._viewportColormapModifiedCallback as EventListener\r\n    );\r\n  }\r\n}\r\n\r\nexport { ViewportColorbar as default, ViewportColorbar };\r\n","import { Types, utilities as csUtils } from '@cornerstonejs/core';\r\nimport { isViewportPreScaled } from './viewport';\r\n\r\nconst DEFAULT_MULTIPLIER = 4;\r\n\r\nfunction getVOIMultipliers(\r\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\r\n  volumeId?: string,\r\n  options?: {\r\n    fixedPTWindowWidth?: boolean;\r\n  }\r\n): [number, number] {\r\n  const modality = csUtils.getViewportModality(viewport, volumeId);\r\n\r\n  if (modality === 'PT') {\r\n    const { clientWidth, clientHeight } = viewport.element;\r\n    const ptMultiplier = 5 / Math.max(clientWidth, clientHeight);\r\n    const isPreScaled = isViewportPreScaled(viewport, volumeId);\r\n    const { fixedPTWindowWidth = true } = options ?? {};\r\n\r\n    // Set the \"X\" multiplier equal to zero in order to do not allow\r\n    // any change to the window width (0 * cursorDeltaX = 0)\r\n    const xMultiplier = fixedPTWindowWidth ? 0 : ptMultiplier;\r\n\r\n    return isPreScaled\r\n      ? [xMultiplier, ptMultiplier]\r\n      : [xMultiplier, DEFAULT_MULTIPLIER];\r\n  }\r\n\r\n  return [DEFAULT_MULTIPLIER, DEFAULT_MULTIPLIER];\r\n}\r\n\r\nexport { getVOIMultipliers as default, getVOIMultipliers };\r\n","/**\r\n * Specify the position of the text/ticks.\r\n * Left/Right are the valid options for a vertical colorbars and Top/Bottom\r\n * for the horizontal ones.\r\n */\r\nexport enum ColorbarRangeTextPosition {\r\n  Top = 'top',\r\n  Left = 'left',\r\n  Bottom = 'bottom',\r\n  Right = 'right',\r\n}\r\n","/**\r\n * Extracts the luminance values from a specified region of an image.\r\n *\r\n * @param {Object} imageData - The image data object containing pixel information.\r\n * @param {Uint8Array} imageData.scalarData - The pixel data array.\r\n * @param {boolean} imageData.color - A flag indicating if the image is in color (true) or grayscale (false).\r\n * @param {number} imageData.columns - The number of columns (width) in the image.\r\n * @param {number} x - The x-coordinate of the top-left corner of the region.\r\n * @param {number} y - The y-coordinate of the top-left corner of the region.\r\n * @param {number} width - The width of the region.\r\n * @param {number} height - The height of the region.\r\n * @returns {number[]} An array containing the luminance values of the specified region.\r\n */\r\nfunction getLuminanceFromRegion(imageData, x, y, width, height) {\r\n  const luminance = [];\r\n  let index = 0;\r\n  const pixelData = imageData.scalarData;\r\n  let spIndex, row, column;\r\n\r\n  if (imageData.color) {\r\n    for (row = 0; row < height; row++) {\r\n      for (column = 0; column < width; column++) {\r\n        spIndex = ((row + y) * imageData.columns + (column + x)) * 4;\r\n        const red = pixelData[spIndex];\r\n        const green = pixelData[spIndex + 1];\r\n        const blue = pixelData[spIndex + 2];\r\n\r\n        luminance[index++] = 0.2126 * red + 0.7152 * green + 0.0722 * blue;\r\n      }\r\n    }\r\n  } else {\r\n    for (row = 0; row < height; row++) {\r\n      for (column = 0; column < width; column++) {\r\n        spIndex = (row + y) * imageData.columns + (column + x);\r\n        luminance[index++] = pixelData[spIndex];\r\n      }\r\n    }\r\n  }\r\n\r\n  return luminance;\r\n}\r\n\r\nexport { getLuminanceFromRegion };\r\n","function calculateMinMaxMean(pixelLuminance, globalMin, globalMax) {\r\n  const numPixels = pixelLuminance.length;\r\n  let min = globalMax;\r\n  let max = globalMin;\r\n  let sum = 0;\r\n\r\n  if (numPixels < 2) {\r\n    return {\r\n      min,\r\n      max,\r\n      mean: (globalMin + globalMax) / 2,\r\n    };\r\n  }\r\n\r\n  for (let index = 0; index < numPixels; index++) {\r\n    const spv = pixelLuminance[index];\r\n\r\n    min = Math.min(min, spv);\r\n    max = Math.max(max, spv);\r\n    sum += spv;\r\n  }\r\n\r\n  return {\r\n    min,\r\n    max,\r\n    mean: sum / numPixels,\r\n  };\r\n}\r\n\r\nexport { calculateMinMaxMean };\r\n","import {\r\n  VolumeViewport,\r\n  utilities as csUtils,\r\n  cache,\r\n  StackViewport,\r\n} from '@cornerstonejs/core';\r\n\r\nfunction extractWindowLevelRegionToolData(viewport) {\r\n  if (viewport instanceof VolumeViewport) {\r\n    return extractImageDataVolume(viewport);\r\n  }\r\n  if (viewport instanceof StackViewport) {\r\n    return extractImageDataStack(viewport);\r\n  }\r\n\r\n  throw new Error('Viewport not supported');\r\n}\r\n\r\nfunction extractImageDataVolume(viewport) {\r\n  const { scalarData, width, height } =\r\n    csUtils.getCurrentVolumeViewportSlice(viewport);\r\n  const { min: minPixelValue, max: maxPixelValue } =\r\n    csUtils.getMinMax(scalarData);\r\n  const volumeId = viewport.getVolumeId();\r\n  const volume = cache.getVolume(volumeId);\r\n  // @ts-ignore\r\n  const { metadata, cornerstoneImageMetaData } = volume;\r\n  const { Rows: rows, Columns: columns } = metadata;\r\n  const { color } = cornerstoneImageMetaData;\r\n  return {\r\n    scalarData,\r\n    width,\r\n    height,\r\n    minPixelValue,\r\n    maxPixelValue,\r\n    rows,\r\n    columns,\r\n    color,\r\n  };\r\n}\r\n\r\nfunction extractImageDataStack(viewport) {\r\n  const imageData = viewport.getImageData();\r\n  const { scalarData } = imageData;\r\n  const { min: minPixelValue, max: maxPixelValue } =\r\n    csUtils.getMinMax(scalarData);\r\n  const width = imageData.dimensions[0];\r\n  const height = imageData.dimensions[1];\r\n  const { rows, columns, color } = viewport.getCornerstoneImage();\r\n\r\n  return {\r\n    scalarData,\r\n    width,\r\n    height,\r\n    minPixelValue,\r\n    maxPixelValue,\r\n    rows,\r\n    columns,\r\n    color,\r\n  };\r\n}\r\n\r\nexport { extractWindowLevelRegionToolData };\r\n","import { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport vtkCaseTable from './ImageMarchingSquares/caseTable.js';\n\nconst {\n  vtkErrorMacro,\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageMarchingSquares methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMarchingSquares(publicAPI, model) {\n  /**\n   * Get the X,Y kernels based on the set slicing mode.\n   * @returns {[number, number]}\n   */\n  function getKernels() {\n    let kernelX = 0; // default K slicing mode\n    let kernelY = 1;\n    if (model.slicingMode === 1) {\n      kernelX = 0;\n      kernelY = 2;\n    } else if (model.slicingMode === 0) {\n      kernelX = 1;\n      kernelY = 2;\n    }\n    return [kernelX, kernelY];\n  }\n\n  // Set our className\n  model.classHierarchy.push('vtkImageMarchingSquares');\n\n  /**\n   * Get the list of contour values.\n   * @returns {number[]}\n   */\n  publicAPI.getContourValues = () => model.contourValues;\n\n  /**\n   * Set the list contour values.\n   * @param {number[]} cValues\n   */\n  publicAPI.setContourValues = cValues => {\n    model.contourValues = cValues;\n    publicAPI.modified();\n  };\n  const ids = [];\n  const pixelScalars = [];\n  const pixelPts = [];\n  const edgeLocator = vtkEdgeLocator.newInstance();\n\n  /**\n   * Retrieve scalars and pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelScalars = (ijk, dims, scalars, increments, kernelX, kernelY) => {\n    const [i, j, k] = ijk;\n\n    // First get the indices for the pixel\n    ids[0] = k * dims[1] * dims[0] + j * dims[0] + i; // i, j, k\n    ids[1] = ids[0] + increments[kernelX]; // i+1, j, k\n    ids[2] = ids[0] + increments[kernelY]; // i, j+1, k\n    ids[3] = ids[2] + increments[kernelX]; // i+1, j+1, k\n\n    // Now retrieve the scalars\n    for (let ii = 0; ii < 4; ++ii) {\n      pixelScalars[ii] = scalars[ids[ii]];\n    }\n  };\n\n  /**\n   * Retrieve pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing spacing of the image\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelPoints = (ijk, origin, spacing, kernelX, kernelY) => {\n    const i = ijk[kernelX];\n    const j = ijk[kernelY];\n\n    // (i,i+1),(j,j+1),(k,k+1) - i varies fastest; then j; then k\n    pixelPts[0] = origin[kernelX] + i * spacing[kernelX]; // 0\n    pixelPts[1] = origin[kernelY] + j * spacing[kernelY];\n    pixelPts[2] = pixelPts[0] + spacing[kernelX]; // 1\n    pixelPts[3] = pixelPts[1];\n    pixelPts[4] = pixelPts[0]; // 2\n    pixelPts[5] = pixelPts[1] + spacing[kernelY];\n    pixelPts[6] = pixelPts[2]; // 3\n    pixelPts[7] = pixelPts[5];\n  };\n\n  /**\n   * Produce points and lines for the polydata.\n   * @param {number[]} cVal list of contour values\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing sapcing of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {number[]} points list of points\n   * @param {number[]} lines list of lines\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.produceLines = (cVal, ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY) => {\n    const k = ijk[model.slicingMode];\n    const CASE_MASK = [1, 2, 8, 4]; // case table is actually for quad\n    const xyz = [];\n    let pId;\n    publicAPI.getPixelScalars(ijk, dims, scalars, increments, kernelX, kernelY);\n    let index = 0;\n    for (let idx = 0; idx < 4; idx++) {\n      if (pixelScalars[idx] >= cVal) {\n        index |= CASE_MASK[idx]; // eslint-disable-line no-bitwise\n      }\n    }\n\n    const pixelLines = vtkCaseTable.getCase(index);\n    if (pixelLines[0] < 0) {\n      return; // don't get the pixel coordinates, nothing to do\n    }\n\n    publicAPI.getPixelPoints(ijk, origin, spacing, kernelX, kernelY);\n    const z = origin[model.slicingMode] + k * spacing[model.slicingMode];\n    for (let idx = 0; pixelLines[idx] >= 0; idx += 2) {\n      lines.push(2);\n      for (let eid = 0; eid < 2; eid++) {\n        const edgeVerts = vtkCaseTable.getEdge(pixelLines[idx + eid]);\n        pId = undefined;\n        if (model.mergePoints) {\n          pId = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])?.value;\n        }\n        if (pId === undefined) {\n          const t = (cVal - pixelScalars[edgeVerts[0]]) / (pixelScalars[edgeVerts[1]] - pixelScalars[edgeVerts[0]]);\n          const x0 = pixelPts.slice(edgeVerts[0] * 2, (edgeVerts[0] + 1) * 2);\n          const x1 = pixelPts.slice(edgeVerts[1] * 2, (edgeVerts[1] + 1) * 2);\n          xyz[kernelX] = x0[0] + t * (x1[0] - x0[0]);\n          xyz[kernelY] = x0[1] + t * (x1[1] - x0[1]);\n          xyz[model.slicingMode] = z;\n          pId = points.length / 3;\n          points.push(xyz[0], xyz[1], xyz[2]);\n          if (model.mergePoints) {\n            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);\n          }\n        }\n        lines.push(pId);\n      }\n    }\n  };\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    if (model.slicingMode == null || model.slicingMode < 0 || model.slicingMode > 2) {\n      vtkErrorMacro('Invalid or missing slicing mode');\n      return;\n    }\n    console.time('msquares');\n\n    // Retrieve output and volume data\n    const origin = input.getOrigin();\n    const spacing = input.getSpacing();\n    const dims = input.getDimensions();\n    const extent = input.getExtent();\n    const increments = input.computeIncrements(extent);\n    const scalars = input.getPointData().getScalars().getData();\n    const [kernelX, kernelY] = getKernels();\n\n    // Points - dynamic array\n    const points = [];\n\n    // Cells - dynamic array\n    const lines = [];\n\n    // Ensure slice is valid\n    let k = Math.round(model.slice);\n    if (k >= dims[model.slicingMode]) {\n      k = 0;\n    }\n\n    // Loop over all contour values, and then pixels, determine case and process\n    const ijk = [0, 0, 0];\n    ijk[model.slicingMode] = k;\n    for (let cv = 0; cv < model.contourValues.length; ++cv) {\n      for (let j = 0; j < dims[kernelY] - 1; ++j) {\n        ijk[kernelY] = j;\n        for (let i = 0; i < dims[kernelX] - 1; ++i) {\n          ijk[kernelX] = i;\n          publicAPI.produceLines(model.contourValues[cv], ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY);\n        }\n      }\n      edgeLocator.initialize();\n    }\n\n    // Update output\n    const polydata = vtkPolyData.newInstance();\n    polydata.getPoints().setData(new Float32Array(points), 3);\n    polydata.getLines().setData(new Uint32Array(lines));\n    outData[0] = polydata;\n    vtkDebugMacro('Produced output');\n    console.timeEnd('msquares');\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  contourValues: [],\n  slicingMode: 2,\n  slice: 0,\n  mergePoints: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['slicingMode', 'slice', 'mergePoints']);\n\n  // Object specific methods\n  macro.algo(publicAPI, model, 1, 1);\n  vtkImageMarchingSquares(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageMarchingSquares');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageMarchingSquares$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageMarchingSquares$1 as default, extend, newInstance };\n"],"names":["AnnotationTool","createAnnotation","annotationBaseData","annotation","annotationUID","highlighted","invalidated","metadata","toolName","this","data","text","handles","points","Array","textBox","hasMoved","worldPosition","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","label","baseData","createAnnotationForViewport","viewport","getViewReference","createAndAddAnnotation","addAnnotation","element","constructor","toolProps","defaultToolProps","super","mouseMoveCallback","evt","filteredAnnotations","currentPoints","detail","canvasCoords","canvas","annotationsNeedToBeRedrawn","isAnnotationLocked","isAnnotationVisible","activateHandleIndex","activeHandleIndex","undefined","near","_imagePointNearToolOrHandle","nearToolAndNotMarkedActive","notNearToolAndMarkedActive","configuration","getTextLines","statsCalculator","getHandleNearImagePoint","proximity","enabledElement","getEnabledElement","isCanvasAnnotation","canvasBoundingBox","worldToCanvas","i","length","point","annotationCanvasCoordinate","slice","getLinkedTextBoxStyle","specifications","visibility","getStyle","fontFamily","fontSize","color","shadow","background","lineWidth","lineDash","isSuvScaled","targetId","imageId","BaseVolumeViewport","volumeId","volume","cache","getVolume","scaling","PT","scalingModule","metaData","suvbw","getAnnotationStyle","context","styleSpecifier","property","locked","lineOpacity","fillColor","fillOpacity","textbox","isPointNearTool","defaultLabelmapConfig","renderOutline","outlineWidthActive","outlineWidthInactive","activeSegmentOutlineWidthDelta","renderFill","renderFillInactive","fillAlpha","fillAlphaInactive","outlineOpacity","outlineOpacityInactive","isValidLabelmapConfig","config","AnnotationFrameRange","frameRangeExtractor","imageIdToFrames","match","range","split","map","it","Number","framesToString","isArray","String","framesToImageId","newRangeString","replace","setFrameRange","eventBase","referencedImageId","eventDetail","triggerEvent","eventTarget","ANNOTATION_MODIFIED","getFrameRange","annotationHydration","worldPoints","options","viewReference","viewPlaneNormal","FrameOfReferenceUID","utilities","autoGenerated","isLocked","isVisible","getReferencedImageId","worldPos","StackViewport","getClosestImageIdForStackViewport","Error","getReferenceId","actorEntries","getActors","find","actorEntry","actor","getClassName","uid","getTargetVolumeId","getTargetId","imageVolume","imageIds","getImageIds","distanceImagePairs","imagePositionPatient","distance","ImagePositionPatient","dir","dot","Math","abs","calculateDistanceToImage","sort","a","b","boundsIJK","numSlicesToProject","sliceNormalIndex","findIndex","min","max","EPSILON","CONSTANTS","calculateBoundingBox","dimensions","isWorld","xMin","Infinity","xMax","yMin","yMax","zMin","zMax","is3D","p","getBoundingBoxAroundShapeIJK","getBoundingBoxAroundShapeWorld","clipBounds","calibratedPixelSpacingMetadataProvider","calibrateImageSpacing","renderingEngine","calibrationOrScale","type","Enums","USER","scale","add","getStackViewports","forEach","includes","calibrateSpacing","Events","state","addToolState","viewportId","getToolState","ViewportStatus","debounced","dynamicVolumesPlayingMap","Map","playClip","playClipOptions","playClipTimeouts","playClipIsTimeVarying","dynamicCineEnabled","_getVolumeFromViewport","playClipContext","waitForRendered","numScrollSteps","currentStepIndex","getTargetImageIdIndex","frameTimeVectorEnabled","waitForRenderedCount","scroll","delta","viewportStatus","RENDERED","debounceLoading","_createStackViewportCinePlayContext","VolumeViewport","isDynamicVolume","numTimePoints","timePointIndex","_createDynamicVolumeViewportCinePlayContext","cachedScrollInfo","scrollInfo","getScrollInfo","camera","getCamera","volumeViewPlaneNormal","direction","x","_createVolumeViewportCinePlayContext","_createCinePlayContext","playClipData","isDynamicCinePlaying","_stopDynamicVolumeCine","_stopClip","stopDynamicCine","id","intervalId","framesPerSecond","lastFrameTimeStamp","ignoreFrameTimeVector","usingFrameTimeVector","frameTimeVector","speed","frameTimeVectorSpeedMultiplier","reverse","loop","timeouts","isTimeVarying","vector","sample","delay","sum","limit","push","_getPlayClipTimeouts","playClipAction","newStepIndex","newStepIndexOutOfRange","CLIP_STOPPED","set","window","setTimeout","playClipTimeoutHandler","setInterval","CLIP_STARTED","stopClip","toolState","getToolStateByViewportId","clearTimeout","clearInterval","_stopClipWithData","dynamicCineElement","get","delete","volumes","filter","_getVolumesFromViewport","clip","val","low","high","addContourSegmentationAnnotation","parentAnnotationUID","segmentation","segmentationId","segmentIndex","getSegmentation","representationData","CONTOUR","annotationUIDsMap","annotationsUIDsSet","Set","areSameSegment","firstAnnotation","secondAnnotation","firstSegmentation","secondSegmentation","isContourSegmentationAnnotation","removeContourSegmentationAnnotation","size","polyline","closed","perimeter","point1","point2","sqrt","pow","firstPoint","lastPoint","isEqual","findHandlePolylineIndex","handleIndex","contour","handle","index","closestDistance","reduce","closestIndex","testIndex","areCoplanarContours","firstViewPlaneNormal","secondViewPlaneNormal","firstPolyline","secondPolyline","firstDistance","secondDistance","findNextLink","line","lines","contourPoints","cell","nextLine","splice","remainingLines","findContours","firstCell","shift","result","extraContours","findContoursFromReducedSet","getDeduplicatedVTKPolyDataPoints","polyData","bypass","getPoints","getLines","pointsArray","getNumberOfPoints","fill","_","getPoint","linesArray","getNumberOfCells","getCell","newPoints","pt","entries","newIndex","processContourHoles","contours","useXOR","retContours","closedContours","contourWithHoles","contourWithoutHoles","holes","hContour","hIndex","outerContour","innerContour","vertices","pointsNotEnclosed","y","inside","j","xi","yi","xj","yj","getIsPointInsidePolygon","checkEnclosed","contourHoleSet","holeIndex","contourIndex","Labelmap","SegmentationRepresentations","generateContourSetsFromLabelmap","segmentations","segments","segVolumeId","vol","console","warn","numSlices","segData","imageData","getPointData","getScalars","getData","pixelsPerSlice","z","ContourSets","numSegments","segIndex","segment","sliceContours","scalars","name","numberOfComponents","dataType","containedSegmentIndices","sliceIndex","isSliceEmptyForSegment","frameStart","value","has","setValue","mSquares","imageDataCopy","shallowCopy","setScalars","setInputData","cValues","setContourValues","setMergePoints","reducedSet","getOutputData","FrameNumber","e","ContourSet","startIdx","endIdx","AnnotationToPointData","TOOL_NAMES","convert","metadataProvider","referenceImageId","validateAnnotation","toolClass","ContourSequence","getContourSequence","ReferencedROINumber","ROIDisplayColor","floor","random","register","RectangleROIStartEndThreshold","getContourHolesDataWorld","childAnnotationUIDs","getContourHolesDataCanvas","worldHoleContours","canvasHoleContours","worldHoleContour","numPoints","canvasHoleContour","acceptAutogeneratedInterpolations","annotationGroupSelector","selector","InterpolationManager","acceptAutoGenerated","updateContourPolyline","polylineData","transforms","canvasToWorld","targetWindingDirection","decimate","enabled","epsilon","polylineWorldPoints","currentPolylineWindingDirection","parentAnnotation","currentClosedState","lastToFirstDist","windingDirection","handlePoints","func","wait","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","useRAF","requestAnimationFrame","TypeError","invokeFunc","time","args","thisArg","apply","startTimer","pendingFunc","shouldInvoke","timeSinceLastCall","timerExpired","Date","now","trailingEdge","timeSinceLastInvoke","timeWaiting","remainingWait","isInvoking","leadingEdge","Boolean","cancel","cancelAnimationFrame","cancelTimer","flush","pending","getTextBoxCoordsCanvas","annotationCanvasPoints","corners","canvasPoints","handlesLeftToRight","_compareX","handlesTopToBottom","_compareY","right","top","bottom","_determineCorners","centerY","dynamicVolume","frames","frameNumbers","keys","maskVolumeId","imageCoordinate","segmentationVolume","dataInTime","ijkCoords","maskImageData","segScalarData","getScalarData","len","nonZeroVoxelIndices","actualLen","dynamicVolumeScalarDataArray","getScalarDataArrays","values","isSameVolume","JSON","stringify","spacing","indexValues","frame","activeScalarData","callback","pointLPS","segPointLPS","segValue","pointIJK","segPointIJK","overlapIJKMinMax","count","perFrameSum","averageCallback","pointInShapeCallback","averageValues","_getTimePointDataMask","coordinate","worldToIndex","yMultiple","zMultiple","allScalarData","scalarIndex","_getTimePointDataCoordinate","operation","numFrames","typedArrays","arrayLength","finalArray","Float32Array","SUM","currentArray","SUBTRACT","AVERAGE","k","getAnnotationNearPoint","canvasPoint","getAnnotationNearPointOnEnabledElement","renderingEngineId","toolGroup","_toolInstances","tools","found","findAnnotationNearPointByTool","tool","annotations","getAnnotations","currentId","getCurrentImageId","CalibrationTypes","PIXEL_UNITS","SUPPORTED_REGION_DATA_TYPES","SUPPORTED_LENGTH_VARIANT","SUPPORTED_PROBE_VARIANT","UNIT_MAPPING","SQUARE","getCalibratedLengthUnitsAndScale","image","calibration","hasPixelSpacing","units","areaUnits","calibrationType","sequenceOfUltrasoundRegions","UNCALIBRATED","imageIndex1","imageIndex2","regions","region","regionLocationMinX0","regionLocationMaxX1","regionLocationMinY0","regionLocationMaxY1","regionDataType","physicalUnitsXDirection","physicalUnitsYDirection","physicalDeltaX","physicalDeltaY","ERMF","ERROR","PROJECTION","getCalibratedProbeUnitsAndValue","imageIndex","supportedRegionsMetadata","referencePixelX0","referencePixelY0","yValue","getCalibratedAspect","aspect","transformWorldToIndex","getSphereBoundsInfo","circlePoints","centerWorld","radiusWorld","topLeftWorld","bottomRightWorld","getDimensions","viewUp","viewRight","topLeftIJK","bottomRightIJK","pointsIJK","_computeBoundsIJKWithCamera","getViewportForAnnotation","viewports","intersectAABB","aabb1","aabb2","minX","maxX","minY","maxY","distanceToPointSquared","aabb","aabbWidth","aabbHeight","aabbSize","aabbCenter","translatedPoint","dx","dy","dist","distanceToPoint","PointsManager","BasicStatsCalculator","runMean","m2","pointsInShape","create3","statsInit","noPointsCollection","statsCallback","newValue","newArray","idx","delta2","getStatistics","mean","stdDev","squaredDiffSum","unit","named","singleArrayAsNumber","array","pointInEllipse","ellipse","inverts","precalculated","precalculatePointInEllipse","xRadius","yRadius","zRadius","invXRadiusSq","invYRadiusSq","invZRadiusSq","center","centerL","centerP","centerS","dz","getCanvasEllipseCorners","ellipseCanvasPoints","left","distanceToPointSquaredInfo","lineStart","lineEnd","closestPoint","distanceSquared","math","dotProduct","sign","NaN","intersectLine","line1Start","line1End","line2Start","line2End","x1","y1","x2","y2","x3","y3","x4","y4","a1","b1","c1","r3","r4","a2","b2","c2","r1","r2","denom","num","ORIENTATION_TOLERANCE","isPointOnLineSegment","orientation","p1","p2","z1","z2","mirror","mirrorPoint","staticPoint","isClosed","numPolylinePoints","distFirstToLastPoints","containsPoint","numIntersections","hole","shouldClose","maxSegmentIndex","intersects","xIntersection","containsPoints","numPoint","getArea","n","area","getSignedArea","refPoint","aX","aY","bX","getWindingDirection","getNormal3","vecArea","aZ","bY","bZ","_getAreaVector","getNormal2","areLineSegmentsIntersecting","q1","q2","line1MinX","line1MinY","line1MaxX","line1MaxY","line2MinX","line2MinY","line2MaxX","line2MaxY","orient","onSegment","q","r","orientationValue","getLineSegmentIntersectionsIndexes","intersections","maxI","PARALLEL_LINES_TOLERANCE","getLinesIntersection","diffQ1P1","diffQ2P2","denominator","line1AABB","line2AABB","numerator2","PolylinePointType","PolylinePointPosition","PolylinePointDirection","ensuresNextPointers","polylinePoints","currentPoint","next","getSourceAndTargetPointsList","targetPolyline","sourcePolyline","targetPolylinePoints","sourcePolylinePoints","sourceIntersectionsCache","intersectionPointDirection","Exiting","Entering","pointInside","vertexPoint","Vertex","coordinates","position","Inside","Outside","visited","intersectionsInfo","intersectedLineSegment","sourceLineSegmentId","intersectionCoordinate","targetStartPointDistSquared","intersectionInfo","targetEdgePoint","Intersection","Edge","sourceEdgePoint","Unknown","cloned","sourceIntersectionPoints","lineSegmentId","intersectionPoint","lineSegStartDistSquared","getUnvisitedOutsidePoint","mergePolylines","targetNormal","sourceNormal","dotNormals","startPoint","mergedPolyline","subtractPolylines","subtractedPolylines","subtractedPolyline","getFirstLineSegmentIntersectionIndexes","initialI","intersectPolyline","sourceLen","intersectionPointIndexes","DEFAULT_EPSILON","epsilonSquared","partitionQueue","polylinePointFlags","numDecimatedPoints","startIndex","endIndex","pop","endPoint","maxDistSquared","maxDistIndex","distSquared","decimatedPolyline","srcIndex","dstIndex","getLineSegmentIntersectionsCoordinates","polylineIndexes","intersection","getClosestLineSegmentIntersection","initialQ2Index","p2Index","q2Index","distances","intersectionPoints","midpoint","minDistance","indexOf","subPixelResolution","xDir","yDir","getImageData","volumeSpacing","iVector","jVector","kVector","absViewRightDotI","absViewRightDotJ","absViewRightDotK","xSpacing","absViewUpDotI","absViewUpDotJ","absViewUpDotK","ySpacing","closeContourProximity","newCanvasPoint","commonData","log","lastWorldPos","newWorldPos","worldPosDiff","xDist","yDist","numPointsToAdd","lastCanvasPoint","canvasDist","canvasDir","distPerPoint","p1p","p1p2","p1p2Mag","projectionVectorMag","p1p2UnitVector","projectionVector","projectionPoint","projectTo2D","sharedDimensionIndex","testPoints","every","points2D","firstDim","secondDim","projectedPolyline","isPointInsidePolyline3D","projectedHoles","hole2D","rect","width","height","lineSegments","rectToLineSegments","Object","pointInSphere","sphere","radius","radius2","INSIDE","OUTSIDE","clipT","c","tE","tL","t","box","da","db","getOrientationStringLPS","orientationX","orientationY","orientationZ","MIN","invertOrientationStringLPS","orientationString","inverted","toUpperCase","smoothAnnotation","filterAnnotationsWithinSlice","getWorldWidthAndHeightFromCorners","filterAnnotationsForDisplay","getPointInLineOfSightWithCriteria","isPlaneIntersectingAABB","pointInShapeFn","iMin","iMax","jMin","jMax","kMin","kMax","scalarData","numComps","start","getDirection","rowCosines","columnCosines","scanAxisNormal","getSpacing","rowSpacing","columnSpacing","scanAxisSpacing","worldPosStart","indexToWorld","rowStep","columnStep","scanAxisStep","xMultiple","currentPos","startPosJ","startPosI","pointInSurroundingSphereCallback","centerIJK","spacings","minSpacing","maxRadiusIJK","ceil","sphereCornersIJK","getBoundingBoxAroundShape","_getBounds","sphereObj","pointToString","decimals","parseFloat","toFixed","idx3","getPolyDataPointIndexes","linesData","segmentSize","findStartingPoint","key","nextPoint","getPolyDataPoints","contoursIndexes","rawPointsData","contourIndexes","referenceVolume","AllBoundsIJK","pointsToUse","cachedStats","projectionPoints","concat","rectangleCornersIJK","world","g","accumulator","currentValue","axisList","isAxisAlignedRectangle","rectangleVec1","rectangleVec2","calculateAnglesWithAxes","angle","vec","axes","axis","PI","scrollSlabs","useSlabThickness","sliceRangeInfo","sliceRange","spacingInNormalDirection","focalPoint","newFocalPoint","newPosition","setCamera","render","desiredStepIndex","VolumeScrollEventDetail","currentImageId","EVENTS","VOLUME_SCROLL_OUT_OF_BOUNDS","VOLUME_VIEWPORT_SCROLL","scrollVolume","uuidv4","ChangeTypesForInterpolation","HandlesUpdated","InterpolationUpdated","toolNames","addTool","interpolationUID","interpolationCompleted","handleAnnotationCompleted","originalToolName","viewportData","sliceData","getSliceData","hasInterpolationUID","filterData","parentKey","interpolationAnnotations","skipUIDs","interpolationAnnotation","handleAnnotationUpdate","changeType","isInterpolationUpdate","handleAnnotationDelete","numberOfSlices","getNumberOfSlices","getCurrentImageIdIndex","setBrushReplaceForToolGroup","toolGroupId","targetSegmentIndex","getToolGroup","strategySpecificConfiguration","REPLACE","getBrushReplaceForToolGroup","toolInstances","brushToolInstance","setBrushSizeForToolGroup","brushSize","invalidateBrushCursor","viewportsInfo","getViewportsInfo","viewportsInfoArray","viewportIds","getViewportIds","getRenderingEngine","getBrushSizeForToolGroup","setBrushThresholdForToolGroup","threshold","otherArgs","isDynamic","brushBasedToolInstances","THRESHOLD","getBrushThresholdForToolGroup","isLineInSegment","isInSegment","ijk1","toIJK","ijk2","testPoint","testIJK","testSize","round","unitDelta","findLargestBidirectional","maxBidirectional","testCenter","ijk","createIsInSegment","sliceContour","bidirectional","createBidirectionalForSlice","assign","currentMax","maxMajor","maxMinor","currentMaxMinor","currentMaxMajor","maxMajorPoints","index1","index2","distance2","handle0","handle1","unitMajor","maxMinorPoints","majorAxis","minorAxis","contourAndFindLargestBidirectional","createBidirectionalToolData","bidirectionalData","major0","major1","minor0","minor1","createImageIdReferenceMap","imageIdsArray","segmentationImageIds","async","createLabelmapVolumeForViewport","input","getEnabledElementByIds","getDefaultActor","properties","volumeLoader","labelmaps","origin","labelmap","outputData","arrayType","lpad","string","character","join","getter","seed","onFlood","onBoundary","equals","diagonals","startNode","permutations","perms","permutation","parseInt","toString","permute","perm","countNonZeroes","prunedPermutations","stack","flooded","visits","bounds","currentArgs","flood","boundaries","from","job","getArgs","prevArgs","previousArgs","iKey","markAsVisited","node","member","markAsFlooded","nextArgs","pushAdjacent","markAsBoundary","getDefaultRepresentationConfig","representationType","getHoveredContourSegmentationAnnotation","annotationUIDs","getSegmentAtLabelmapBorder","worldPoint","searchRadius","labelmapData","LABELMAP","getScalarValueFromWorld","onEdge","getNeighborIndex","deltaI","deltaJ","neighborCanvas","isSegmentOnEdge","isSegmentOnEdgeCanvas","imageIdReferenceMap","segmentationImageId","getImage","segmentationRepresentations","getSegmentationIdRepresentations","segmentationRepresentationUID","segmentationActor","getActor","getMapper","getInputData","indexIJK","voxelManager","createVolumeVoxelManager","getAtIJKPoint","deltaK","neighborIJK","getAtIJK","isSegmentOnEdgeIJK","neighborRange","neighborIndex","getSegmentAtWorldPoint","desiredRepresentation","getSegmentAtWorldForLabelmap","Contour","contourData","segmentIndices","annotationsSet","getSegmentAtWorldForContour","isValidRepresentationConfig","thresholdVolumeInformation","validToolNames","_validateAnnotations","outputSegmentationVolume","modified","segmentContourAction","configurationData","getSegment","defaultGetSegment","getFrameOfReferenceUID","segmentationsList","bidirectionals","hasExistingActiveSegment","existingLargestBidirectionals","existingBidirectionalItem","newBidirectional","existingLargestBidirectional","updateSegment","bidirectionalToolData","style","setAnnotationStyles","jumpToSlice","segmentData","segmentationIndex","overlapType","baseVolumeIdx","volumeInfoList","volumeInfo","volumeSize","referenceValues","lower","upper","_handleSameSizeVolume","total","overlaps","overlapBounds","callbackOverlap","overlapTest","_handleDifferentSizeVolume","triggerSegmentationDataModified","segmentationImageData","overwrite","testOverlapRange","voxelSpacing","voxelCenter","testRange","computeOffsetIndex","insert","getBrushToolInstances","toolInstance","equalsCheck","getVoxelOverlap","voxelCornersWorld","voxelCornersIJK","processVolumes","segmentationSpacing","resetPrefetchTimeout","maxImagesToPrefetch","preserveExistingPool","prefetch","stackPrefetchData","stackPrefetch","currentImageIdIndex","indicesToRequest","removeFromList","imageIdIndex","getImageLoadObject","isLoaded","imageLoadPoolManager","clearRequestStack","nearest","nextImageIdIndex","lowerIndex","higherIndex","imageIdsToPrefetch","currentIndex","shouldLoadLower","shouldLoadHigher","requestFn","imageLoader","useNorm16Texture","preferSizeOverAccuracy","rendering","useNativeDataType","targetBuffer","preScale","requestType","addRequest","bind","onImageUpdated","target","error","enable","indexOfCurrentImage","removeEventListener","STACK_NEW_IMAGE","addEventListener","promiseRemovedHandler","IMAGE_CACHE_IMAGE_REMOVED","disable","getConfiguration","setConfiguration","minBefore","maxAfter","directionExtraImages","indicesToRequestCopy","filterRequests","then","getCachedImageBasedOnImageURI","stats","decodeTimeInMS","loadTimeInMS","sizeInBytes","usage","getMaxCacheSize","cacheFill","fillTime","fillSize","roundNumber","initialTime","initialSize","updateToolState","doneCallback","stackCount","totalBytes","positionFraction","minIndex","maxIndex","getDeltaPoints","lastPoints","curr","getMeanPoints","last","page","_subtractPoints2D","client","point0","getDeltaDistance","_getDistance2D","_getDistance3D","getDeltaRotation","getDeltaDistanceBetweenIPoints","currentDistance","_getMeanDistanceBetweenAllIPoints","lastDistance","copyPointsList","parse","copyPoints","prev","getMeanTouchPoints","touch","identifier","radiusX","radiusY","force","rotationAngle","pairedDistance","toolGroupIds","viewportInfo","getViewport","filterViewportsWithFrameOfReferenceUID","numViewports","viewportsWithFrameOfReferenceUID","vp","Active","Passive","Enabled","ToolModes","filterViewportsWithToolEnabled","viewportsWithToolEnabled","_toolGroupHasActiveEnabledOrPassiveTool","toolOptions","toolMode","mode","EPS","vpCamera","getViewportIdsWithToolToRender","requireParallelNormals","getViewports","isViewportPreScaled","targetIdTokens","scaled","currentImageIndex","_getImageSliceData","lastSliceIndex","_getImageIndexToJump","jumpToWorld","jumpWorld","normal","dotProd","projectedDelta","_applyShift","isRangeValid","isColorbarSizeValid","areColorbarRangesEqual","areColorbarSizesEqual","clamp","ColorbarCanvas","props","validateProps","colormap","imageRange","voiRange","container","showFullPixelValueRange","_colormap","_imageRange","_voiRange","_showFullImageRange","_canvas","_createRootElement","appendTo","_setCanvasSize","showFullImageRange","appendChild","dispose","parentElement","removeChild","document","createElement","pointerEvents","boxSizing","isConnected","RGBPoints","rgbPoints","colorsCount","getColorPoint","offset","canvasContext","getContext","isHorizontal","maxValue","windowWidth","previousColorPoint","currentColorPoint","incRawPixelValue","rawPixelValue","tVoiRange","normColor","tColorRange","fillStyle","fillRect","DEFAULTS","FONT","COLOR","TICK_SIZE","TICK_WIDTH","TICK_LABEL_MARGIN","MAX_NUM_TICKS","TICKS_STEPS","ColorbarTicks","ticks","ticksProps","ticksStyle","rangeTextPosition","_font","font","_color","_tickSize","tickSize","_tickWidth","tickWidth","_labelMargin","labelMargin","_maxNumTicks","maxNumTicks","_rangeTextPosition","ColorbarRangeTextPosition","Right","_showFullPixelValueRange","_createCanvasElement","showFullRange","visible","display","_getTicks","roughStep","stepPower","log10","roughtStepNormalized","step","scaleMax","scaleMin","ticksCount","_getLeftTickInfo","labelMeasure","labelPoint","tickPoints","end","_getRightTickInfo","_getTopTickInfo","_getBottomTickInfo","maxCanvasPixelValue","rangeWidth","clearRect","textBaseline","strokeStyle","tick","measureText","tickInfo","Top","Left","tickStart","tickEnd","beginPath","moveTo","lineTo","fillText","stroke","Widget","_containerResizeCallback","contentRect","contentBoxSize","inlineSize","blockSize","_containerSize","onContainerResize","_id","_rootElement","createRootElement","_containerResizeObserver","ResizeObserver","rootElement","resizeObserver","currentContainer","unobserve","observe","destroy","disconnect","containerSize","classList","MULTIPLIER","RANGE_TEXT_POSITION","TICKS_BAR_SIZE","Colorbar","_isMouseOver","_isInteracting","_mouseOverCallback","showTicks","stopPropagation","_mouseOutCallback","hideTicks","_mouseDownCallback","_addVOIEventListeners","_mouseDragCallback","initialState","multipliers","getVOIMultipliers","_getPointsFromMouseEvent","startPoints","startVOIRange","canvasDelta","local","wwDelta","wcDelta","voiLower","voiUpper","windowCenter","newVoiRange","preventDefault","_mouseUpCallback","_removeVOIEventListeners","_eventListenersManager","_colormaps","getColormapsMap","_activeColormapName","getInitialColormapName","_createCanvas","_ticksBar","_createTicksBar","_addRootElementEventListeners","activeColormapName","colormapName","currentVoiRange","onVoiChange","reset","updateTicksBar","colormaps","items","item","Name","some","cm","clientPoint","clientX","clientY","pagePoint","pageX","pageY","getBoundingClientRect","pageXOffset","pageYOffset","containerWidth","containerHeight","ticksBar","colorbarWidth","colorbarHeight","Bottom","isRangeTextPositionValid","ticksBarTop","ticksBarLeft","manager","initialDragState","defaultImageRange","ViewportColorbar","_getImageRange","_getVOIRange","autoHideTicks","_hideTicksTimeoutId","timeLeft","_hideTicksTime","_stackNewImageCallback","_element","_imageVolumeModifiedCallback","_volumeId","_viewportVOIModifiedCallback","showAndAutoHideTicks","_viewportColormapModifiedCallback","_addCornerstoneEventListener","clientWidth","clientHeight","ptMultiplier","isPreScaled","fixedPTWindowWidth","xMultiplier","setProperties","viewportsContainingVolumeUID","getRange","volumeActor","getProperty","getRGBTransferFunction","interval","IMAGE_VOLUME_MODIFIED","VOI_MODIFIED","COLORMAP_MODIFIED","getLuminanceFromRegion","luminance","pixelData","spIndex","row","column","columns","red","green","blue","calculateMinMaxMean","pixelLuminance","globalMin","globalMax","numPixels","spv","extractWindowLevelRegionToolData","minPixelValue","maxPixelValue","getVolumeId","cornerstoneImageMetaData","Rows","rows","Columns","extractImageDataVolume","getCornerstoneImage","extractImageDataStack","vtkErrorMacro","vtkDebugMacro","m","vtkImageMarchingSquares","publicAPI","model","classHierarchy","getContourValues","contourValues","ids","pixelScalars","pixelPts","edgeLocator","newInstance","getPixelScalars","dims","increments","kernelX","kernelY","ii","getPixelPoints","produceLines","cVal","slicingMode","CASE_MASK","xyz","pId","pixelLines","getCase","eid","edgeVerts","getEdge","mergePoints","isInsertedEdge","x0","insertEdge","requestData","inData","outData","getOrigin","extent","getExtent","computeIncrements","getKernels","cv","initialize","polydata","setData","Uint32Array","timeEnd","DEFAULT_VALUES","extend","initialValues","arguments","obj","algo","setGet","vtkImageMarchingSquares$1"],"sourceRoot":""}