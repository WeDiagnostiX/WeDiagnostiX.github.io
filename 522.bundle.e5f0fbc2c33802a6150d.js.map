{"version":3,"file":"522.bundle.e5f0fbc2c33802a6150d.js","mappings":";+MA0CA,MAAMA,UAAsB,WACZ,KAAAC,oBAAsB,yCAA0C,CAqE9E,WAAAC,CAAYC,GACVC,MAAM,IACDD,EACHE,OAAQF,EAAME,SAAU,QAAkBF,EAAMG,WA/D5C,KAAAC,WAAa,EACb,KAAAC,YAAc,EAEd,KAAAC,MAAO,EACP,KAAAC,MAAO,EACP,KAAAC,WAAY,EACZ,KAAAC,YAAc,EACd,KAAAC,aAAe,EAaf,KAAAC,WAA+B,CAAC,EAAG,GASnC,KAAAC,IAAM,GAKN,KAAAC,YAAmC,CACzCC,SAAU,CAAC,EAAG,GACdC,cAAe,GAmBT,KAAAC,SAAqB,CAC3BC,MAAO,EACPC,MAAO,KA2YF,KAAAC,cAAgB,KACd,CACLb,KAAMc,KAAKC,aAAaf,KACxBgB,MAAOF,KAAKC,aAAaC,MACzBZ,aAAcU,KAAKV,aACnBD,YAAaW,KAAKX,YAClBO,SAAU,IAAKI,KAAKJ,YAsUjB,KAAAO,YAAc,KACnBH,KAAKI,sBAELJ,KAAKK,cAAcC,SAAS,EAAG,EAAGN,KAAKlB,OAAOyB,MAAOP,KAAKlB,OAAO0B,SAE1C,IAAnBR,KAAKZ,WAEPY,KAAKS,eAEA,GAGF,KAAAC,kBAAoB,KACzB,MAAMC,EAAiBC,KAAKC,MACzBb,KAAKC,aAAaa,SAAWd,KAAKR,IAAOQ,KAAKX,aAEjD,OAAO0B,MAAMJ,GAAkBX,KAAKgB,eAAiBL,CAAc,EAG9D,KAAAM,uBAAyB,IAEvBjB,KAAKC,aAAaiB,IAGpB,KAAAC,OAAS,KACd,MAAMrC,EAASkB,KAAKlB,QACd,YAAEsC,EAAW,aAAEC,GAAiBvC,EAGlCA,EAAOyB,QAAUa,GAAetC,EAAO0B,SAAWa,IACpDvC,EAAOyB,MAAQa,EACftC,EAAO0B,OAASa,GAGlBrB,KAAKI,uBAEkB,IAAnBJ,KAAKZ,WAEPY,KAAKS,aACP,EASK,KAAAa,cAAgB,CACrBC,EACAC,EAAkB,CAAC,EAAG,EAAG,MAEzB,MAAMC,EAAczB,KAAKP,YAAYC,SAC/BgC,EAA6B1B,KAAK2B,wBAElCC,EAA0B,CAC9BH,EAAI,GAAKC,EACTD,EAAI,GAAKC,GAGLG,EAAuB,CAC3BN,EAAU,GAAKK,EAAgB,GAC/BL,EAAU,GAAKK,EAAgB,IAWjC,OANAJ,EAAQM,OACN,EACA,EACAD,EAAa,GAAKH,EAClBG,EAAa,GAAKH,GAEbF,CAAO,EAST,KAAAO,cAAiBC,IACtB,MAAMP,EAAczB,KAAKP,YAAYC,SAC/BgC,EAA6B1B,KAAK2B,wBAOxC,MAL0B,EACvBK,EAAS,GAAKP,EAAI,IAAMC,GACxBM,EAAS,GAAKP,EAAI,IAAMC,EAGX,EAQX,KAAAO,YAAc,IAAM,EAKjB,KAAAC,cAAiBX,IACzB,MAAMY,EAAYnC,KAAKoC,eAGvB,OAFAD,EAAUE,SAEHF,EAAUG,eACPf,EAAUgB,KAAKC,GAAOA,EAAKC,mBACpC,EAGO,KAAAC,cAAiBC,GACP3C,KAAKoC,eAEXE,eAAeK,GAAUJ,KAAKC,GAAOA,EAAKC,mBA2CjD,KAAAG,6BAA+B,KACpC5C,KAAKS,aAAa,EAwEZ,KAAAA,YAAc,KACpB,MACMoC,EADY7C,KAAKoC,eAC0BU,YAE3CC,EAAM/C,KAAKK,cAEjB0C,EAAIC,iBAGJD,EAAIZ,UACFU,EAAqB,GACrBA,EAAqB,GACrBA,EAAqB,GACrBA,EAAqB,GACrBA,EAAqB,GACrBA,EAAqB,IAGvBE,EAAIE,UACFjD,KAAKC,aACL,EACA,EACAD,KAAKhB,YAAc,KACnBgB,KAAKf,aAAe,MAGtB,IAAK,MAAMiE,KAASlD,KAAKmD,YACtBD,EAAMA,MAAuBE,OAAOpD,KAAMA,KAAKK,eAElDL,KAAKK,cAAc2C,kBAGnB,IAAAK,cAAarD,KAAKjB,QAAS,SAAOuE,gBAAiB,CACjDvE,QAASiB,KAAKjB,QACdwE,WAAYvD,KAAKwD,GACjBC,SAAUzD,KACV0D,kBAAmB1D,KAAK0D,kBACxBC,KAAM3D,KAAKC,aAAa2D,YACxB9C,SAAUd,KAAKC,aAAaa,YAE9B,IAAAuC,cAAarD,KAAKjB,QAAS,SAAO8E,eAAgB,CAChD9E,QAASiB,KAAKjB,QACdwE,WAAYvD,KAAKwD,GACjBC,SAAUzD,KACV0D,kBAAmB1D,KAAK0D,kBACxBC,KAAM3D,KAAKC,aAAa2D,YACxB9C,SAAUd,KAAKC,aAAaa,WAG9Bd,KAAK8D,kBAEL,MAAMC,EAAQ/D,KAAKgE,iBACfhE,KAAKZ,YACH2E,EAAQ/D,KAAKT,WAAW,GAC1BS,KAAKiE,eAAejE,KAAKT,WAAW,IAC3BwE,EAAQ/D,KAAKT,WAAW,KAC7BS,KAAKd,KACPc,KAAKiE,eAAejE,KAAKT,WAAW,IAEpCS,KAAKkE,SAGX,EAGM,KAAAC,oBAAsB,KAC5BnE,KAAKS,cAGDT,KAAKZ,WACPgF,sBAAsBpE,KAAKmE,oBAC7B,EA9/BAnE,KAAKK,cAAgBL,KAAKlB,OAAOuF,WAAW,MAC5CrE,KAAK0D,kBAAoB9E,EAAM8E,kBAE/B1D,KAAKjB,QAAQuF,aAAa,oBAAqBtE,KAAKwD,IACpDxD,KAAKjB,QAAQuF,aACX,4BACAtE,KAAK0D,mBAGP1D,KAAKC,aAAesE,SAASC,cAAc,SAC3CxE,KAAKC,aAAaC,MAAQF,KAAKb,KAC/Ba,KAAKC,aAAaf,KAAOc,KAAKd,KAC9Bc,KAAKC,aAAawE,UAAW,EAC7BzE,KAAKC,aAAayE,YAAc,YAEhC1E,KAAK2E,oBACL3E,KAAKmB,QACP,CAEO,qCAAWyD,GAChB,OAAO,CACT,CAEQ,iBAAAD,GACN3E,KAAKlB,OAAO+F,iBACV,SAAOC,iBACP9E,KAAK+E,uBAET,CAEQ,oBAAAC,GACNhF,KAAKlB,OAAOmG,oBACV,SAAOH,iBACP9E,KAAK+E,uBAET,CAEQ,sBAAAA,GACN/E,KAAKgF,uBACLhF,KAAKC,aAAaiF,QACpB,CAEO,oBAAAC,CAAqBC,GAC1B,MAAMC,EAA2B,iBAAVD,EAAqBA,EAAQA,EAAMC,QACpDC,EAAmB,MAAa,EAAAC,gBAAgBC,YAAaH,GAEnE,IAAII,EAAqBH,EAAiBG,WACtCC,EAAwBJ,EAAiBI,cAG3B,MAAdD,GAAuC,MAAjBC,IACxBD,EAAqB,CAAC,EAAG,EAAG,GAC5BC,EAAwB,CAAC,EAAG,EAAG,IAGjC,MAAMC,EAAe,gBACnBF,EAAW,GACXA,EAAW,GACXA,EAAW,IAEPG,EAAe,gBACnBF,EAAc,GACdA,EAAc,GACdA,EAAc,KAGV,KAAEG,EAAI,QAAEC,GAAYR,EACpBS,EAAiB,cACvB,WAAWA,EAAgBJ,EAAcC,GAEzC,IAAII,EAASV,EAAiBW,qBAEhB,MAAVD,IACFA,EAAS,CAAC,EAAG,EAAG,IAGlB,MAAME,EAAWZ,EAAiBa,oBAAsB,EAClDC,EAAWd,EAAiBe,iBAAmB,EAC/CC,EAAUhB,EAAiBQ,QAC3BS,EAAUjB,EAAiBO,KAMjC,OADA7F,KAAKwG,kBAAoBlB,EAAiBa,mBACnC,CACLM,cAAe,EACfC,SAAU,EACVV,SACAH,OACAC,UACAa,UAAW,IAAIhB,KAAiBC,KAAiBG,GACjDa,WAAY,CAACN,EAASC,EAVR,GAWdM,QAAS,CAACX,EAAUE,EAZL,GAafI,gBAAiBxG,KAAKwG,gBACtBM,UAAWR,EAAUC,EAbP,EAcdjB,mBAEJ,CAQO,UAAAyB,CAAWC,EAAoBC,GACpCjH,KAAKkH,SACHF,EAAS,GACRC,GAASE,eAAeC,YAAyB,EAEtD,CAOO,QAAAF,CAAS7B,EAAiBgC,GAC/BrH,KAAKqF,QAAUiC,MAAMC,QAAQlC,GAAWA,EAAQ,GAAKA,EACrD,MAAMmC,EAAiB,MAAa,EAAAjC,gBAAgBkC,UAAWpC,GAC/D,IAAKmC,GAAgBE,SACnB,MAAM,IAAIC,MACR,kBAAkBtC,yCAGtB,MAAM,SAAEqC,GAAaF,EACfI,EAAgB,MAAa,EAAArC,gBAAgBsC,eAAgBxC,GACnErF,KAAK8H,SAAWF,GAAeG,SAC/B/H,KAAKgI,SAAWhI,KAAKmF,qBAAqBE,GAC1C,IAAI,SAAE4C,EAAQ,eAAEjH,GAAmB,MACjC,EAAAuE,gBAAgB2C,KAChB7C,GAIF,OAFArF,KAAKgB,eAAiBA,EAEfhB,KAAKmI,YAAYT,GAAUU,MAAK,KAChCpH,GAAqC,IAAnBA,IACrBA,EAAiBJ,KAAKC,MACpBb,KAAKC,aAAaa,UAAYmH,GAAY,MAGzCA,IACHA,EAAWrH,KAAKC,MAAMG,EAAiBhB,KAAKC,aAAaa,WAE3Dd,KAAKR,IAAMyI,EACXjI,KAAKgB,eAAiBA,EAEtBhB,KAAKqI,cAAc,CAAC,EAAGrH,IAGvBhB,KAAK8D,cAAgB,KACnB9D,KAAK8D,cAAgB,KACrB9D,KAAKkE,QACLlE,KAAKiE,eAAeoD,GAAe,EAAE,EAMhC,IAAIiB,SAASC,IAClBC,OAAOC,YAAW,KAChBzI,KAAKiE,eAAeoD,GAAe,GACnCkB,EAAQvI,KAAK,GACZ,GAAG,MAGZ,CAEO,iBAAMmI,CAAYO,GACvB,OAAO,IAAIJ,SAASC,IAClBvI,KAAKC,aAAaiB,IAAMwH,EACxB1I,KAAKC,aAAa0I,QAAU,OAE5B,MAAMC,EAA6B,KACjC5I,KAAKhB,WAAagB,KAAKC,aAAajB,WACpCgB,KAAKf,YAAce,KAAKC,aAAahB,YACrCe,KAAKC,aAAagF,oBAChB,iBACA2D,GAGF5I,KAAKI,sBAELmI,GAAQ,EAAK,EAGfvI,KAAKC,aAAa4E,iBAChB,iBACA+D,EACD,GAEL,CAMO,WAAAC,GACL,MAAM7B,EAAW,IAAIM,MAActH,KAAKgB,gBAClC8H,EAAc9I,KAAKqF,QAAQ0D,QAAQ,UAAW,IACpD,IAAK,IAAIC,EAAI,EAAGA,EAAIhJ,KAAKgB,eAAgBgI,IACvChC,EAASgC,GAAK,GAAGF,IAAcE,EAAI,IAErC,OAAOhC,CACT,CAEO,eAAAiC,GACL,OAAIjJ,KAAKZ,WACPY,KAAKkE,SACE,IAEPlE,KAAKkJ,QACE,EAEX,CAEO,UAAMA,GACX,IACOlJ,KAAKZ,kBAEFY,KAAKC,aAAaiJ,OACxBlJ,KAAKZ,WAAY,EACjBY,KAAKmE,sBAET,CAAE,MAAOgF,GAGT,CACF,CAEO,WAAMjF,GACX,UACQlE,KAAKC,aAAaiE,QACxBlE,KAAKZ,WAAY,CACnB,CAAE,MAAO+J,GAET,CACF,CAEO,YAAMC,CAAOC,EAAQ,SACpBrJ,KAAKkE,QAEX,MAAMjE,EAAeD,KAAKC,aACpBQ,EAAcT,KAAKS,YAGnB6I,EADcrJ,EAAa2D,YACFyF,EAAQrJ,KAAKX,YAAeW,KAAKR,IAEhES,EAAa2D,YAAc0F,EAG3B,MAAMC,EAAqBC,IACzB/I,IAEAR,EAAagF,oBAAoB,SAAUsE,EAAkB,EAG/DtJ,EAAa4E,iBAAiB,SAAU0E,EAC1C,CAEO,WAAME,GACX,MAAMxJ,EAAeD,KAAKC,aACpBQ,EAAcT,KAAKS,YAIzB,GAFAR,EAAa2D,YAAc,EAEvB3D,EAAayJ,OAAQ,CAEvB,MAAMH,EAAqBC,IACzB/I,IAEAR,EAAagF,oBAAoB,SAAUsE,EAAkB,EAG/DtJ,EAAa4E,iBAAiB,SAAU0E,EAC1C,CACF,CAEO,SAAMI,GACX,MAAM1J,EAAeD,KAAKC,aACpBQ,EAAcT,KAAKS,YAIzB,GAFAR,EAAa2D,YAAc3D,EAAaa,SAEpCb,EAAayJ,OAAQ,CAEvB,MAAMH,EAAqBC,IACzB/I,IAEAR,EAAagF,oBAAoB,SAAUsE,EAAkB,EAG/DtJ,EAAa4E,iBAAiB,SAAU0E,EAC1C,CACF,CAEO,aAAMK,CAAQC,GACnB,MAAM5J,EAAeD,KAAKC,aACpBQ,EAAcT,KAAKS,YAIzB,GAFAR,EAAa2D,YAAciG,EAEvB5J,EAAayJ,OAAQ,CAEvB,MAAMH,EAAqBC,IACzB/I,IAEAR,EAAagF,oBAAoB,SAAUsE,EAAkB,EAG/DtJ,EAAa4E,iBAAiB,SAAU0E,EAC1C,CACF,CAGO,oBAAMtF,CAAeF,GAC1B/D,KAAK4J,SAAS7F,EAAQ,GAAK/D,KAAKR,IAClC,CAQO,aAAA6I,CAAc9I,GACdA,EAIqB,IAAtBA,EAAWuK,QAAgBvK,EAAW,KAAOA,EAAW,KAG5DS,KAAKT,WAAa,CAACA,EAAW,GAAIA,EAAW,KAN3CS,KAAKT,WAAa,CAAC,EAAGS,KAAKgB,eAO/B,CAEO,aAAA+I,GACL,OAAO/J,KAAKT,UACd,CAEO,aAAAyK,CAAcpL,QACAqL,IAAfrL,EAAMM,OACRc,KAAKC,aAAaf,KAAON,EAAMM,WAGb+K,IAAhBrL,EAAMsB,QACRF,KAAKC,aAAaC,MAAQtB,EAAMsB,YAGP+J,IAAvBrL,EAAMU,cACRU,KAAKkK,gBAAgBtL,EAAMU,mBAGH2K,IAAtBrL,EAAMS,aACRW,KAAKmK,eAAevL,EAAMS,aAGxBT,EAAMgB,UACRI,KAAKoK,OAAOxL,EAAMgB,SAEtB,CAEO,eAAAsK,CAAgBG,EAAO,GAC5BrK,KAAKV,aAAe+K,EAEhBA,EAAO,MACTrK,KAAKkE,QAGFlE,KAAKC,eAGVD,KAAKC,aAAaX,aAAe+K,EACjCrK,KAAKkJ,OACP,CAEO,cAAAiB,CACL9K,EAAc,EACdiL,EAAO,uBAA4BC,OAEnCvK,KAAKX,YACHiL,IAAS,uBAA4BE,OACjCnL,EAAcW,KAAKR,IACnBH,CACR,CAYO,eAAAoL,GACLzK,KAAKgK,cAAc,CACjB9K,MAAM,EACNgB,OAAO,GAEX,CAEU,aAAAwK,GACR,GAAI1K,KAAK2K,YAAYtD,cAAgBrH,KAAKgE,iBACxC,OAAOhE,KAAK2K,WAEd,MAAM7L,EAASyF,SAASC,cAAc,UACtC1F,EAAOyB,MAAQP,KAAKhB,WACpBF,EAAO0B,OAASR,KAAKf,YACrB,MAAM2L,EAAU9L,EAAOuF,WAAW,MAClCuG,EAAQ3H,UAAUjD,KAAKC,aAAc,EAAG,GACxC,MAMM0K,EANaC,EAAQC,aACzB,EACA,EACA7K,KAAKhB,WACLgB,KAAKf,aAEuB6L,KAI9B,OAHAH,EAAWI,SAAW,IAAM,CAAC,EAAG,KAChCJ,EAAWtD,YAAcrH,KAAKgE,iBAC9BhE,KAAK2K,WAAaA,EACXA,CACT,CAEO,YAAAE,GACL,MAAM,SAAE7C,GAAahI,KAEf6G,EAAUmB,EAASnB,QAEnBmE,EAAY,CAChBpE,WAAYoB,EAASpB,WACrBC,UACAb,OAAQgC,EAAShC,OACjBW,UAAWqB,EAASrB,UACpBqB,SAAU,CAAED,SAAU/H,KAAK8H,UAC3B4C,cAAe,IAAM1K,KAAK0K,gBAC1BM,UAAW,CACTC,aAAc,IAAMjD,EAASrB,UAC7BuE,cAAe,IAAMlD,EAASpB,WAC9BmE,SAAU,IAAM,CAAC,EAAG,KACpBL,cAAe,IAAM1K,KAAK0K,gBAC1BS,WAAY,IAAMnD,EAASnB,QAC3BuE,aAAeC,IACb,MAAMC,EAActL,KAAK+B,cAAcsJ,GACjCE,EAAavL,KAAKkC,cAAcoJ,GACtC,MAAO,CAACC,EAAW,GAAIA,EAAW,GAAI,EAAE,EAE1CC,aAAc,CAACH,EAAeI,KAC5B,MAAMH,EAActL,KAAK0C,cAAc,CAAC2I,EAAM,GAAIA,EAAM,KACxD,OAAOrL,KAAKsB,cAAcgK,EAAaG,EAAU,GAGrDjF,gBAAiBxG,KAAKwG,gBACtBkF,YAAa1L,KAAK0L,YAClBC,SAAU,CACRC,QAAQ,IAOZ,OAJAC,OAAOC,eAAed,EAAW,aAAc,CAC7Ce,IAAK,IAAM/L,KAAK0K,gBAChBsB,YAAY,IAEPhB,CACT,CAmBO,WAAAiB,CAAYC,GAEjB,MAAMC,EAAcD,EAASE,MAAM3N,EAAcC,qBAC3C2N,EAAUF,EACZD,EAASI,UAAU,EAAGH,EAAYI,OAClCL,EACJ,OAA0C,IAAnClM,KAAKqF,QAAQmH,QAAQH,EAC9B,CAEO,MAAAjC,CAAOxK,GACZI,KAAKJ,SAAWA,EAChBI,KAAKyM,mBACP,CAEO,cAAAC,CAAeC,EAAc,IAAKC,EAAe,KACtD,MAAM/M,EAAQ+M,EAAeD,EAAc,EACrC7M,EAAQ8M,EAAeD,EAAc,EAAI,EAC/C3M,KAAKoK,OAAO,CAAEvK,QAAOC,UACrBE,KAAKyM,mBACP,CAEO,eAAAI,CAAgBC,GACrB9M,KAAK8M,aAAeA,EACpB9M,KAAKyM,mBACP,CAEU,iBAAAA,GACR,IAAKzM,KAAKJ,WAAaI,KAAK8M,aAE1B,YADA9M,KAAK+M,SAAW,MAGlB,MAAMC,EAAQhN,KAAK8M,cAAgB,CAAC,IAAK,IAAK,KACxCG,EAAWrM,KAAKsM,OAAOF,GACvBG,EAAaH,EAAMzK,KAAK6K,GAAMH,EAAWG,KACzC,MAAEvN,EAAQ,EAAC,MAAEC,EAAQ,KAAQE,KAAKJ,UAAY,CAAC,EAC/CyN,GAAWvN,EAAQD,EAAQ,GAAK,IAChCyN,EAAUzN,EAAQ,IACxBG,KAAK+M,SAAW,4MAKRI,EAAW,GAAKE,WAAiBC,iBAC/BH,EAAW,GAAKE,SAAeC,mBAC7BH,EAAW,GAAKE,OAAaC,kEAKzCtN,KAAKlB,OAAOyO,MAAMC,OAASxN,KAAK+M,QAClC,CAEO,SAAAU,CAAUC,GACf,MAAM,cAAE/N,EAAa,WAAEgO,GAAeD,EAStC,GALI/N,IACFK,KAAKP,YAAYE,cACfK,KAAKjB,QAAQsC,aAAe,EAAI1B,QAGjBsK,IAAf0D,EAA0B,CAC5B,MAAMC,EAAmB5N,KAAK+B,cAAc4L,GACtCE,EAAuB,CAC3B7N,KAAKjB,QAAQqC,YAAc,EAC3BpB,KAAKjB,QAAQsC,aAAe,GAGxByM,EAAwB,EAC3BF,EAAiB,GAAKC,EAAa,IAClC7N,KAAKP,YAAYE,eAClBiO,EAAiB,GAAKC,EAAa,IAClC7N,KAAKP,YAAYE,eAGrBK,KAAKP,YAAYC,SAAW,CAC1BM,KAAKP,YAAYC,SAAS,GAAKoO,EAAc,GAC7C9N,KAAKP,YAAYC,SAAS,GAAKoO,EAAc,GAEjD,CAEA9N,KAAKK,cAAc0N,UAAY,gBAC/B/N,KAAKK,cAAcC,SAAS,EAAG,EAAGN,KAAKlB,OAAOyB,MAAOP,KAAKlB,OAAO0B,SAE1C,IAAnBR,KAAKZ,WACPY,KAAKS,aAET,CAcO,iBAAAuN,GAOL,OANgBhO,KAAKqF,QAAQ0D,QAC3B,YACA/I,KAAKZ,UACD,WAAWY,KAAKT,WAAW,MAAMS,KAAKT,WAAW,KACjD,WAAWS,KAAKgE,mBAGxB,CAKO,cAAAiK,CAAeC,EAAoC,CAAC,GACzD,MAAQ9G,WAAYA,GAAe8G,EACnC,QAAmBjE,IAAf7C,EACF,MAAO,WAAWpH,KAAKgO,sBAEzB,GAAI1G,MAAMC,QAAQH,GAEhB,MAAO,WAAWpH,KAAKqF,QAAQiH,UAAU,EAAGtM,KAAKqF,QAAQyE,OAAS,KAChE1C,EAAW,GAAK,KACdA,EAAW,GAAK,IAMtB,MAAO,WAJYpH,KAAKqF,QAAQ0D,QAC9B,YACA,WAAW,EAAI3B,MAGnB,CAKO,mBAAA+G,CACLC,EACAnH,EAAsC,CAAC,GAEvC,IAAI,SAAEiF,GAAajF,EACnB,MAAM,kBAAEoH,EAAmBjH,WAAYA,GAAegH,EACtD,IAAKvP,MAAMsP,oBAAoBC,GAC7B,OAAO,EAGT,MAAM/I,EAAUrF,KAAKgO,oBACrB,IAAK9B,EAAU,CAGb,MAAMoC,EAAajJ,EAAQmH,QAAQ,KACnCN,EAAW7G,EAAQiH,UAAUgC,EAAa,EAAGjJ,EAAQyE,OAAS,EAChE,CAEA,GAAI7C,EAAQsH,eACV,OAAO,EAET,MAAMC,EAAexO,KAAKyO,gBAC1B,GAAInH,MAAMC,QAAQH,GAChB,OAAOoH,GAAgBpH,EAAW,IAAMoH,GAAgBpH,EAAW,GAErE,QAAmB6C,IAAf7C,EACF,OAAOoH,IAAiBpH,EAE1B,IAAKiH,EACH,OAAO,EAET,MAAMjC,EAAQiC,EAAkBjC,MAAM3N,EAAcC,qBACpD,IAAK0N,IAAUA,EAAM,GACnB,OAAO,EAET,MAAMsC,EAAQtC,EAAM,GAAGuC,MAAM,KAAKpM,KAAKC,GAAOoM,OAAOpM,KAC/CuB,EAAQyK,EAAe,EAC7B,OAAOE,EAAM,IAAM3K,GAASA,IAAU2K,EAAM,IAAMA,EAAM,GAC1D,CAMO,gBAAAG,CACLC,GAEA,IAAI1H,EAAa0H,GAAkB1H,WAMnC,OALKA,IACHA,EAAapH,KAAKZ,UACd,CAACY,KAAKT,WAAW,GAAK,EAAGS,KAAKT,WAAW,GAAK,GAC9CS,KAAK+O,0BAEJ,IACFlQ,MAAMgQ,iBAAiBC,GAC1BT,kBAAmBrO,KAAKiO,eAAea,GACvC1H,WAAYA,EAEhB,CAKO,cAAApD,GAEL,OAAO,EAAIhE,KAAK+O,wBAClB,CAEO,sBAAAA,GACL,OAAOnO,KAAKC,MAAMb,KAAKC,aAAa2D,YAAc5D,KAAKR,IACzD,CAEO,aAAAiP,GACL,OAAOzO,KAAK+O,wBACd,CAEO,SAAAC,GACL,MAAM,cAAErP,GAAkBK,KAAKP,YAEzBoO,EAAuB,CAC3B7N,KAAKjB,QAAQqC,YAAc,EAC3BpB,KAAKjB,QAAQsC,aAAe,GAQ9B,MAAO,CACL4N,oBAAoB,EACpBtB,WAJwB3N,KAAKsB,cAAcuM,GAK3CqB,SAAU,CAAC,EAAG,EAAG,GACjBC,OAAQ,CAAC,GAAI,EAAG,GAChBxP,cAAeK,KAAKjB,QAAQsC,aAAe,EAAI1B,EAC/CyP,gBAAiB,CAAC,EAAG,EAAG,GAE5B,CAgGO,MAAAC,GACL,MAAM3P,EAAWM,KAAKP,YAAYC,SAClC,MAAO,CAACA,EAAS,GAAIA,EAAS,GAChC,CA2BQ,mBAAAU,GAGN,IAAIsB,EAAqB1B,KAAKlB,OAAOwQ,YAActP,KAAKhB,WAEpDgB,KAAKf,YAAcyC,EAAqB1B,KAAKlB,OAAO0B,SAGtDkB,EAAqB1B,KAAKlB,OAAOyQ,aAAevP,KAAKf,aAKvD,MAAMuQ,EAAY5O,KAAK6O,MAAMzP,KAAKhB,WAAa0C,GACzCgO,EAAa9O,KAAK6O,MAAMzP,KAAKf,YAAcyC,GAM3CiO,GAHiB3P,KAAKlB,OAAOwQ,YAAcE,GAAa,EAGzB9N,EAC/BkO,GAHiB5P,KAAKlB,OAAOyQ,aAAeG,GAAc,EAG3BhO,EAErC1B,KAAKP,YAAYC,SAAW,CAACiQ,EAAcC,GAC3C5P,KAAKP,YAAYE,cAAgB+B,CACnC,CAEQ,qBAAAC,GACN,OAAO3B,KAAKP,YAAYE,aAC1B,CAEQ,qBAAAkQ,GACN,OAAO,EAAM7P,KAAKP,YAAYE,aAChC,CASU,YAAAyC,GACR,MAAM1C,EAAmBM,KAAKP,YAAYC,SACpC+C,EAAmB+F,OAAO/F,kBAAoB,EAC9Cf,EAA6B1B,KAAK2B,wBAClCmO,EAA6B9P,KAAK6P,wBAClCE,EAAa,CACjB/P,KAAKlB,OAAOwQ,YAAc,EAC1BtP,KAAKlB,OAAOyQ,aAAe,GAEvBS,EAA6B,CACjCD,EAAW,GAAKD,EAChBC,EAAW,GAAKD,GAEZ3N,EAAY,IAAI,IAoBtB,OAjBAA,EAAU8N,MAAMxN,EAAkBA,GAIlCN,EAAU+N,UAAUH,EAAW,GAAIA,EAAW,IAG9C5N,EAAU8N,MAAMvO,EAAoBA,GAGpCS,EAAU+N,UAAUxQ,EAAS,GAAIA,EAAS,IAG1CyC,EAAU+N,WACPF,EAA2B,IAC3BA,EAA2B,IAEvB7N,CACT,CAKO,kCAAAgO,GAEP,CAEO,SAAAC,CAAUC,GACf,MAAMC,EAAStQ,KAAKmD,YACpBkN,EAAYE,SAASC,IACnB,MAAMpL,EAAQ,KAAMqL,SAASD,EAAWnL,SAElCqL,EAAa1Q,KAAK2Q,kBAAkBvL,GACtCsL,IACFJ,EAAOM,KAAK,CAAEC,IAAKL,EAAWM,SAAU5N,MAAOwN,IAC3CF,EAAWO,UACbP,EAAWO,SAAS,CAAEL,aAAYrL,QAASmL,EAAWnL,UAE1D,IAEFrF,KAAKgR,UAAUV,EACjB,CAEU,iBAAAK,CAAkBvL,GAC1B,OAAO,IAAI,IAAYpF,KAAMoF,EAC/B,EAgFF,yDCrkCA,QAhCA6L,eACEC,EACAb,EACAc,GAGA,IAAK,MAAM5N,KAAc4N,EAAa,CACpC,MAAM1N,EAAWyN,EAAgBE,YAAY7N,GAE7C,IAAKE,EACH,MAAM,IAAIkE,MAAM,oBAAoBpE,oBAItC,IAAME,EAA4B2M,UAKhC,YAJAiB,QAAQC,KACN,oBAAoB/N,6EAK1B,CAEA,MAAMgO,EAAmBJ,EAAY5O,KAAI0O,MAAO1N,GAC7B2N,EAAgBE,YAAY7N,GAE7B6M,UAAUC,WAGtB/H,QAAQkJ,IAAID,EACpB,gECMA,QAnCAN,eACEC,EACAO,EACAN,EACAO,GAAkB,EAClBC,GAAiB,GAGjB,IAAK,MAAMpO,KAAc4N,EAAa,CACpC,MAAM1N,EAAWyN,EAAgBE,YAAY7N,GAE7C,IAAKE,EACH,MAAM,IAAIkE,MAAM,oBAAoBpE,oBAItC,KAAME,aAAoB,KAKxB,YAJA4N,QAAQC,KACN,oBAAoB/N,qEAK1B,CAEA,MAAMqO,EAAoBT,EAAY5O,KAAI0O,MAAO1N,IAC/C,MAAME,EAAWyN,EAAgBE,YAAY7N,SAEvCE,EAASoO,WAAWJ,EAAcC,EAAiBC,EAAe,UAGpErJ,QAAQkJ,IAAII,EAEpB,uFC5CA,MAAME,EAA4B,CAAC,EAAG,EAAG,EAAG,GAoC5C,SAASC,EAAQC,EAAOC,GACtB,IAAIC,EAAO,EACPC,EAAQH,EAAMlI,OAAS,EAE3B,KAAOoI,GAAQC,GAAO,CACpB,MAAMC,EAAMF,EAAOtR,KAAK6O,OAAO0C,EAAQD,GAAQ,GACzCG,EAAUL,EAAMI,GAEtB,GAAIC,IAAYJ,EACd,OAAOG,EACEH,EAAOI,EAChBF,EAAQC,EAAM,EAEdF,EAAOE,EAAM,CAEjB,CAEA,OAAOF,CACT,CA4CA,SAASI,EAAiBC,EAAGzH,EAAM0H,GACjC,IAAIxJ,EACJ,MAAMyJ,EAAI,GACJC,EAAK,GACLC,EAAK,GACLC,EAAM,GAIZ,IAFAJ,EAAkB,OAAVA,EAAiB,EAAIA,EAExBxJ,EAAI,EAAGA,EAAI8B,EAAKhB,OAAQd,IAAK,CAChC,MAAMjK,EAAU+L,EAAK9B,GAErByJ,EAAE7B,MAAM2B,EAAI,GAAKxT,EAAQ,IACzB2T,EAAG9B,KAAK7R,EAAQ,IAChB4T,EAAG/B,KAAK7R,EAAQ,GAClB,CAEA,MAAM8T,EAxGR,SAAkBC,EAAWC,EAAWC,GAGtC,MAAMC,GAAaF,EAAID,KAFvBE,EAAU,OAANA,EAAa,IAAMA,GAEU,GAC3BE,EAAS,GAEf,KAAOF,KAAM,GACXE,EAAOtC,KAAKkC,GACZA,GAAKG,EAOP,OAFAC,EAAOA,EAAOpJ,OAAS,GAAKiJ,EAErBG,CACT,CAwFoBC,CAAS,EAAG,EAAGZ,GAEjC,IAAKvJ,EAAI,EAAGA,EAAIuJ,EAAGvJ,IACjB6J,EAAU7J,IAAMuJ,EAAI,GAAK3R,KAAKwS,IAAIP,EAAU7J,GAAIwJ,GAGlD,MAAMa,EAxDR,SAAsBC,EAAYC,GAChC,IAAIvK,EACJ,MAAMwK,EAAU,GACVC,EAAMF,EAAOzJ,OAMnB,IAJAwJ,EAAWI,MAAK,SAAUZ,EAAGC,GAC3B,OAAOD,EAAIC,CACb,IAEK/J,EAAI,EAAGA,EAAIyK,EAAKzK,IACnBwK,EAAQxK,GAAK+I,EAAQuB,EAAYC,EAAOvK,IAG1C,OAAOwK,CACT,CA0C2BG,CAAalB,EAAGI,GAEzC,IAAK7J,EAAI,EAAGA,EAAIuJ,EAAI,EAAGvJ,IAAK,CAC1B,MAAMuD,EAAQ8G,EAAiBrK,GACzB4K,GACHf,EAAU7J,GAAKyJ,EAAElG,EAAQ,KAAOkG,EAAElG,GAASkG,EAAElG,EAAQ,IAClDsH,EAAanB,EAAGnG,GAASoG,EAAGpG,EAAQ,GAE1CqG,EAAI5J,GAAK4K,EAAeC,EAAalB,EAAGpG,EAAQ,EAClD,CAKA,OAHAqG,EAAI,GAAKD,EAAG,GACZC,EAAIL,EAAI,GAAKG,EAAG5H,EAAKhB,OAAS,GAEvB8I,CACT,CAkFO,SAASkB,EACdtQ,EACAuQ,GAEA,IAAIC,EAAW,IAAcxQ,GAExBwQ,IACHA,EAAW,IAAcxQ,GAAMuQ,GAAgB,CAC7CE,KAAM,GACNC,OAAQ,MAIPF,EAASE,QAAUF,EAASG,gBAC/BH,EAASE,OAhFb,SAAuCC,EAAe5B,EAAGC,GACvD,IAAIxJ,EACJ,MAAM4J,EAAM,GAGZJ,EAAkB,OAAVA,EAAiB,EAAIA,EAE7B,MAAM4B,EAAS9B,EAHfC,EAAU,OAANA,EAAa,IAAMA,EAGY4B,EAAcE,IAAK7B,GAChD8B,EAAWhC,EAAiBC,EAAG4B,EAAcI,MAAO/B,GACpDgC,EAAUlC,EAAiBC,EAAG4B,EAAcM,KAAMjC,GAExD,IAAKxJ,EAAI,EAAGA,EAAIuJ,EAAGvJ,IAAK,CACtB,MAGM0L,EAAO,CAHD9T,KAAKC,MAAkB,IAAZuT,EAAOpL,IAChBpI,KAAKC,MAAoB,IAAdyT,EAAStL,IACrBpI,KAAKC,MAAmB,IAAb2T,EAAQxL,IACA,KAEhC4J,EAAIhC,KAAK8D,EACX,CAEA,OAAO9B,CACT,CA2DsB+B,CAChBX,EAASG,cACTH,EAASY,UACTZ,EAASxB,QAkGb,MA9FiD,CAC/CqC,MAAK,IACIrR,EAGTsR,mBAAkB,IACTd,EAASC,KAGlB,kBAAAc,CAAmBd,GACjBD,EAASC,KAAOA,CAClB,EAEAe,kBAAiB,IACRhB,EAASE,OAAOpK,OAGzB,iBAAAmL,CAAkBL,GAChB,KAAOZ,EAASE,OAAOpK,OAAS8K,GAC9BZ,EAASE,OAAOtD,KAAKkB,GAGvBkC,EAASE,OAAOpK,OAAS8K,CAC3B,EAEA,QAAAM,CAAS3I,GACP,OAAIvM,KAAKmV,aAAa5I,GACbyH,EAASE,OAAO3H,GAGlBuF,CACT,EAEA,iBAAAsD,CAAkB7I,GAChB,MAAMqI,EAAYZ,EAASE,OAAOpK,OAIlC,OAFAyC,EAAQqI,EAAYrI,EAAQqI,EAAY,EAEjC5U,KAAKkV,SAAS3I,EACvB,EAEA,QAAA8I,CAAS9I,EAAOmI,GACV1U,KAAKmV,aAAa5I,KACpByH,EAASE,OAAO3H,GAASmI,EAE7B,EAEA,QAAAY,CAASZ,GACPV,EAASE,OAAOtD,KAAK8D,EACvB,EAEA,WAAAa,CAAYhJ,EAAOmI,GACb1U,KAAKmV,aAAa5I,IACpByH,EAASE,OAAOpS,OAAOyK,EAAO,EAAGmI,EAErC,EAEA,WAAAc,CAAYjJ,GACNvM,KAAKmV,aAAa5I,IACpByH,EAASE,OAAOpS,OAAOyK,EAAO,EAElC,EAEA,WAAAkJ,GACEzB,EAASE,OAAS,EACpB,EAEA,gBAAAwB,CAAiB9C,GACf,IAAKA,EACH,OAGF,MAAMgC,EAAYZ,EAASE,OAAOpK,OAElC8I,EAAI+C,uBAAuBf,GAE3B,IAAK,IAAI5L,EAAI,EAAGA,EAAI4L,EAAW5L,IAC7B4J,EAAIgD,cAAc5M,EAAGgL,EAASE,OAAOlL,GAEzC,EAEA,iBAAA6M,GACE,MAAMjD,EAAM,IAAI,IAIhB,OAFA5S,KAAK0V,iBAAiB9C,GAEfA,CACT,EAEAuC,aAAa5I,GACJA,GAAS,GAAKA,EAAQyH,EAASE,OAAOpK,OAKnD,+FC1Ue,SAAS,EACtBgM,EACAC,GAEA,MAAM3Q,EAAQ0Q,EAAe1Q,MAG7B,IAAK0Q,EAAehX,SAAWgX,EAAe1Q,MAC5C,OAIF,MAAMqE,GAAQ,SAUd,GARArE,EAAM4Q,MAAQ,CACZC,sBAAuB,EACvBC,0CAA2C,EAC3CC,sBAAuB,EACvBC,gBAAiB,EACjBC,qBAAsB,GAGpBjR,EAAO,CACT,IAAIhC,EAASgC,EAAMhC,OAEdA,IAEDA,EADE0S,EAAerS,SAASuQ,SACjB,IACA5O,EAAMkR,MACN,IAEA,KAIblT,EAAO0S,EAAgBC,EACzB,CAGA,MAAMQ,GAAiB,SAAQ9M,EAE/BrE,EAAM4Q,MAAMI,eAAiBG,EAE7BT,EAAeU,SAAU,EACzBV,EAAeW,aAAc,CAC/B,gEC5Ce,SAAS,EACtBX,EACA7F,GAEA,MAAM9N,EAAY,IAAI,IAEtB,IAAK2T,EAAerS,SAASiT,cAC3B,OAAOvU,EAITA,EAAU+N,UACR4F,EAAehX,OAAOyB,MAAQ,EAC9BuV,EAAehX,OAAO0B,OAAS,GAIjC,MAAMmW,EAAQb,EAAerS,SAASmT,SAExB,IAAVD,GACFxU,EAAU0U,OAAQF,EAAQ/V,KAAKkW,GAAM,KAIvC,IAAIC,EAAajB,EAAerS,SAASwM,MACrC+G,EAAclB,EAAerS,SAASwM,MAE1C,MAAM1P,EACJuV,EAAerS,SAASiT,cAAcO,KAAKxE,GAC1CqD,EAAerS,SAASiT,cAAcQ,KAAKzE,EAAI,GAC5CjS,EACJsV,EAAerS,SAASiT,cAAcO,KAAKE,GAC1CrB,EAAerS,SAASiT,cAAcQ,KAAKC,EAAI,GAElD,GAAmE,SAA/DrB,EAAerS,SAASiT,cAAcU,qBAEtCtB,EAAe1Q,MAAMiB,gBACrByP,EAAe1Q,MAAMe,mBAErB4Q,GACEjB,EAAe1Q,MAAMe,mBACrB2P,EAAe1Q,MAAMiB,gBAEvByP,EAAe1Q,MAAMe,mBACrB2P,EAAe1Q,MAAMiB,kBAErB2Q,GACElB,EAAe1Q,MAAMiB,gBACrByP,EAAe1Q,MAAMe,yBAOzB,GAHA4Q,EAAajB,EAAerS,SAASiT,cAAcvQ,mBACnD6Q,EAAclB,EAAerS,SAASiT,cAAcrQ,gBAIlD,iBADAyP,EAAerS,SAASiT,cAAcU,qBAEtC,CAEA,MAAMC,EACJvB,EAAehX,OAAO0B,QAAUA,EAASwW,GACrCM,EACJxB,EAAehX,OAAOyB,OAASA,EAAQwW,GAGzCA,EAAaC,EAAcpW,KAAK2W,IAAID,EAAiBD,GAGnDvB,EAAerS,SAASiT,cAAcrQ,gBACtCyP,EAAerS,SAASiT,cAAcvQ,mBAEtC4Q,GACEjB,EAAerS,SAASiT,cAAcvQ,mBACtC2P,EAAerS,SAASiT,cAAcrQ,gBAExCyP,EAAerS,SAASiT,cAAcvQ,mBACtC2P,EAAerS,SAASiT,cAAcrQ,kBAEtC2Q,GACElB,EAAerS,SAASiT,cAAcrQ,gBACtCyP,EAAerS,SAASiT,cAAcvQ,mBAE5C,CAsCF,OAnCAhE,EAAU8N,MAAM8G,EAAYC,GAGd,IAAVL,GACFxU,EAAU0U,QAASF,EAAQ/V,KAAKkW,GAAM,KAIxC3U,EAAU+N,UACR4F,EAAerS,SAAS+T,YAAY/E,EACpCqD,EAAerS,SAAS+T,YAAYL,GAIxB,IAAVR,GACFxU,EAAU0U,OAAQF,EAAQ/V,KAAKkW,GAAM,UAGzB7M,IAAVgG,GAEF9N,EAAU8N,MAAMA,EAAOA,GAIrB6F,EAAerS,SAASgU,OAC1BtV,EAAU8N,OAAO,EAAG,GAGlB6F,EAAerS,SAASiU,OAC1BvV,EAAU8N,MAAM,GAAI,GAItB9N,EAAU+N,WAAW3P,EAAQ,GAAIC,EAAS,GAEnC2B,CACT,gECxHe,SAAS,EACtB2T,EACA6B,GAEA,MAAMxV,GAAY,OAAa2T,GAI/B,OAFA3T,EAAUE,SAEHF,EAAUG,eAAeqV,EAClC,gCCZe,SAAS,EACtBC,EACAC,GAEA,MAAM,MAAEJ,EAAK,MAAEC,EAAK,SAAEd,GAAaiB,EAOnC,GAJAD,EAAMnF,GAAKgF,GAAS,EAAI,EACxBG,EAAMT,GAAKO,GAAS,EAAI,EAGP,IAAbd,EAAgB,CAClB,MAAMD,EAASC,EAAWhW,KAAKkW,GAAM,IAE/BgB,EAAOlX,KAAKmX,IAAIpB,GAChBqB,EAAOpX,KAAKqX,IAAItB,GAEhBuB,EAAON,EAAMnF,EAAIqF,EAAOF,EAAMT,EAAIa,EAClCG,EAAOP,EAAMnF,EAAIuF,EAAOJ,EAAMT,EAAIW,EAExCF,EAAMnF,EAAIyF,EACVN,EAAMT,EAAIgB,CACZ,CAEA,OAAOP,CACT,2FCtBe,SAAS,EACtB9Y,EACAsG,EACA0C,EACAkM,GAEA,QAAe/J,IAAXnL,EACF,MAAM,IAAI6I,MACR,8DAIJ,QAAcsC,IAAV7E,EACF,OAAO,SAIT,MAAM6K,GAAQ,OAAiBnR,EAAQsG,EAAO,GAAGgT,YAEjD,IAAIC,EAqBJ,MAnBiB,OAAbvQ,GAAqB1C,EAAMkT,YAC7BD,EAAM,CACJ1L,YAAa,EACbC,aAAc,UAGM3C,IAAtB7E,EAAMuH,kBACiB1C,IAAvB7E,EAAMwH,eAENyL,EAAM,CACJ1L,YAAarF,MAAMC,QAAQnC,EAAMuH,aAC7BvH,EAAMuH,YAAY,GAClBvH,EAAMuH,YACVC,aAActF,MAAMC,QAAQnC,EAAMwH,cAC9BxH,EAAMwH,aAAa,GACnBxH,EAAMwH,eAIP,CACLqD,QACAuH,YAAa,CACX/E,EAAG,EACH0E,EAAG,GAELkB,MACAhW,OAAQ+C,EAAM/C,OACdkW,kBAAkB,EAClB3B,SAAU,EACVa,OAAO,EACPC,OAAO,EACPc,YAAapT,EAAMoT,YACnB1Q,WACA2Q,OAAQrT,EAAMqT,OACdzE,cAAuB/J,IAAb+J,EAAyBA,EAAW5O,EAAM4O,SACpD0C,cAAe,CACbQ,KAAM,CACJzE,EAAG,EACH0E,EAAG,GAELF,KAAM,CACJxE,EAAGrN,EAAMU,QACTqR,EAAG/R,EAAMS,MAEXQ,qBAC4B4D,IAA1B7E,EAAMiB,gBAAgC,EAAIjB,EAAMiB,gBAClDF,wBAC+B8D,IAA7B7E,EAAMe,mBAAmC,EAAIf,EAAMe,mBACrDiR,qBAAsB,QAG5B,0EC5Ee,SAAS,EACtBtY,EACAsG,EACAwR,EAA0B,OAM1B,OACE9X,EACA,0DAEF,OACEsG,EACA,wDAGF,MAAMsT,GAAY,OAAatT,EAAOwR,GAChCvQ,EAAkBjB,EAAMiB,iBAAmB,EAC3CF,EAAqBf,EAAMe,oBAAsB,EACvD,IAAIwS,EAAgB,EAChBC,EAAkB,EAElBvS,EAAkBF,EACpByS,EAAkBzS,EAAqBE,EAGvCsS,EAAgBtS,EAAkBF,EAGpC,MAAMkR,EAAgBvY,EAAO0B,OAASkY,EAAUlY,OAASmY,EACnDrB,EAAkBxY,EAAOyB,MAAQmY,EAAUnY,MAAQqY,EAGzD,MAAO,CACLvB,gBACAC,kBACAc,YAAaxX,KAAK2W,IAAID,EAAiBD,GAE3C,+DCzBe,SAAS,EACtBjS,EACAwR,EAAW,MAeX,OAbA,OACExR,EACA,wDAEF,OACEA,EAAM7E,MACN,kDAEF,OACE6E,EAAM5E,OACN,kDA/BJ,SAAmBoW,GACjB,QACEA,SAEa,IAAbA,GACa,MAAbA,EAEJ,CA2BMiC,CAAUjC,GACL,CACLpW,OAAQ4E,EAAM7E,MACdA,MAAO6E,EAAM5E,QAIV,CACLD,MAAO6E,EAAM7E,MACbC,OAAQ4E,EAAM5E,OAElB,gEChDe,SAAS,EACtBsV,GAQA,OAAO,OAAmBA,EAC5B,gECFe,SAAS,EACtBA,EACA6B,GAIA,OAFkB,OAAa7B,GAEdxT,eAAeqV,EAClC,gECde,SAAS,EACtB7B,EACAgD,GAAW,EACXC,GAAY,GAEZ,MAAM,OAAEja,EAAM,MAAEsG,EAAK,SAAE3B,GAAaqS,EAC9B7F,GAAQ,OAAiBnR,EAAQsG,EAAO,GAAGgT,YAEjD3U,EAASiU,OAAQ,EACjBjU,EAASgU,OAAQ,EAEbqB,IACFrV,EAAS+T,YAAY/E,EAAI,EACzBhP,EAAS+T,YAAYL,EAAI,GAGvB4B,IACFtV,EAASiT,cAAcQ,KAAKzE,EAAI,EAChChP,EAASiT,cAAcQ,KAAKC,EAAI,EAChC1T,EAASiT,cAAcO,KAAKxE,EAAIrN,EAAMU,QACtCrC,EAASiT,cAAcO,KAAKE,EAAI/R,EAAMS,KAEtCpC,EAASwM,MAAQA,EAErB,+ECsDe,SAAS,EACtB6F,EACAkD,GAAmB,GAEnB,MAAMC,EAAiBnD,EAAehX,OAAOyB,MACvC2Y,EAAkBpD,EAAehX,OAAO0B,QA/EhD,SAAuBsV,GACrB,MAAM,OAAEhX,GAAWgX,GACb,YAAE1U,EAAW,aAAEC,GAAiBvC,EAGlCA,EAAOyB,QAAUa,GAAetC,EAAO0B,SAAWa,IACpDvC,EAAOyB,MAAQa,EACftC,EAAO0B,OAASa,EAEpB,CAwEE8X,CAAcrD,QAEe7L,IAAzB6L,EAAe1Q,QAKjB4T,GApEJ,SACElD,EACAmD,EACAC,GAEA,MAAMjJ,EAAQ6F,EAAerS,SAASwM,MAChCyI,GAAY,EAAAU,EAAA,GAChBtD,EAAe1Q,MACf0Q,EAAerS,SAASmT,UAEpByC,EAAazY,KAAKC,MAAM6X,EAAUnY,MAAQ0P,GAC1CqJ,EAAc1Y,KAAKC,MAAM6X,EAAUlY,OAASyP,GAC5CwC,EAAIqD,EAAerS,SAAS+T,YAAY/E,EACxC0E,EAAIrB,EAAerS,SAAS+T,YAAYL,EAE9C,OACGkC,IAAeJ,GAAkBK,GAAeJ,GAChDG,GAAcJ,GACbK,IAAgBJ,GACV,IAANzG,GACM,IAAN0E,CAEN,CA+CIoC,CAAezD,EAAgBmD,EAAgBC,GC3FpC,SAAUpD,GACvB,MAAM,MAAE1Q,GAAU0Q,EAGlBA,EAAerS,SAASwM,OAAQ,EAAAuJ,EAAA,GAC9B1D,EAAehX,OACfsG,EACA0Q,EAAerS,SAASmT,UACxBwB,YAEFtC,EAAerS,SAAS+T,YAAY/E,EAAI,EACxCqD,EAAerS,SAAS+T,YAAYL,EAAI,CAC1C,CDkFIsC,CAAY3D,GAxChB,SACEA,EACAmD,EACAC,GAEA,MAAMjJ,EAAQ6F,EAAerS,SAASwM,MAGhCyJ,EAFc5D,EAAehX,OAAOyB,MAEL0Y,EAC/BU,EAFe7D,EAAehX,OAAO0B,OAEJ0Y,EACjCU,EAAYhZ,KAAKiZ,KAAKH,EAAiBC,GAE7C7D,EAAerS,SAASwM,MAAQ2J,EAAY3J,CAC9C,CA8BI6J,CAAgBhE,EAAgBmD,EAAgBC,GAEpD,sHEJA,QAzEAjI,eACErS,EACAG,EACAwE,EACAoO,GAAiB,EACjBoI,GAAoB,GAEpB,MAAM,SAAEC,EAAQ,SAAEjJ,EAAQ,UAAEkJ,GAAcrb,EAEpCsb,QAAoB,IAAAC,YAAWH,GAErC,IAAKE,EACH,MAAM,IAAIvS,MACR,wBAAwBuS,EAAYF,2BAIxC,MAAM,UAAEhP,EAAS,iBAAEoP,GAAqBF,EAElCG,GAAe,OAAmBrP,EAAWoP,GAE/CH,GACFI,EAAaC,aAAaL,GAG5B,MAAMM,EAAc,mBAsBpB,OArBAA,EAAYC,UAAUH,GAOK,IALArP,EACxByP,eACAC,aACAC,yBAGDJ,EAAYK,cAAcC,0BAAyB,SAG/C,OAAoBN,EAAaL,EAAaH,GAEhDhJ,GACFA,EAAS,CAAEwJ,cAAaP,aAGrBrI,GAOP,SACE5S,EACAwE,EACAgX,EACAP,GAEA,MAAMpa,EAAW2a,EACdK,cACAE,uBAAuB,GACvB/P,WAEGgQ,EAAiD,CACrDxX,aACAmL,MAAO,CACL7O,MAAOD,EAAS,GAChBE,MAAOF,EAAS,IAElBoa,aAGF,IAAA3W,cAAatE,EAAS,EAAAic,OAAOC,aAAcF,EAC7C,CA3BIG,CAAmBnc,EAASwE,EAAYgX,EAAaP,GAGhDO,CACT,2GCnEA,MACMY,EAAe,EAAAC,YAAYC,SA6OjC,QAjOApK,eACEsJ,EACAL,EACAH,GAEA,IAAI1B,EAwDN,SAA4B6B,GAC1B,MAAM,SAAElT,EAAQ,SAAEgB,GAAakS,EAC/B,IAAI7B,EACJ,GAAIrR,EAAS8C,OAAQ,CACnB,MACMzE,EAAU2B,EADKpG,KAAK6O,MAAMzI,EAAS8C,OAAS,IAE5CwR,EAAe,MAAa,eAAgBjW,GAClD,GAAIiW,GAAgBA,EAAa3O,aAAe2O,EAAa1O,aAAc,CACzE,MAAM,YAAED,EAAW,aAAEC,GAAiB0O,EACtCjD,EAAM,CACJ1L,YAAarF,MAAMC,QAAQoF,GAAeA,EAAY,GAAKA,EAC3DC,aAActF,MAAMC,QAAQqF,GACxBA,EAAa,GACbA,EAER,CACF,MACEyL,EAAMrQ,GAAUuT,SAAS,GAE3B,GAAIlD,EAAK,CACP,MAAM,MAAExY,EAAK,MAAEC,GAAU,EAAA0b,YAAA,eACvB5M,OAAOyJ,EAAI1L,aACXiC,OAAOyJ,EAAIzL,eAEb,MAAO,CACL/M,QACAC,QAEJ,CACF,CArFY2b,CAAmBvB,IAExB7B,GAAO6B,GAAalT,UAAU8C,SACjCuO,QA4FJpH,eACEiJ,EACAH,GAEA,MAAM,SAAE/S,GAAakT,EACfvP,EAAauP,EAAYxP,gBAGzBgR,EAAe9a,KAAK6O,MAAMzI,EAAS8C,OAAS,GAC5CzE,EAAU6U,EAAYlT,SAAS0U,GAC/BC,EACJ,MAAa,sBAAuBtW,IAAY,CAAC,GAC7C,SAAEyC,GAAa6T,EACfC,EAAoB,MAAa,oBAAqBvW,IAAY,CAAC,EAEnEwW,EAAY7U,EAAS8C,OACrBgS,EAAgBnR,EAAWoR,WAAaF,EACxCG,EAAiBrR,EAAWb,OAAS+R,EACrCI,EAAetR,EAAWuR,kBAE1BC,EAAuC,CAC3CC,aAAcR,EAAkBQ,aAChCC,iBAAkBT,EAAkBS,iBACpCvU,YAGF,IAAIwU,EACJ,GAAiB,OAAbxU,EAAmB,CACrB,MAAMyU,EAAY,MAAa,gBAAiBlX,GAE5CkX,IACFD,EAAyB,IACpBH,EACHK,MAAOD,EAAUC,OAGvB,CAEA,MAAMC,EAAaf,EAAeI,EAE5B7U,EAAU,CACdyV,aAAc,CACZC,KAAM5C,OAAoB9P,EAAY,gBAExC2S,SA7Ja,EA8JbC,YAAa1B,EACbpB,oBACApO,SAAU,CACRmR,SAAS,EACTX,kBAAmBG,IAevB,IAAIlX,EAAQ,KAAMqL,SAASpL,GAEtB6U,EAAY6C,oBAAoBjT,SAInC1E,QAAc,IAAA4X,mBAAkB3X,EAAS,IAAK4B,EAASgW,aAAa,KAGtE,MAAMC,EAAkB9X,EACpBA,EAAM+X,eAiBZ,SACEjD,EACAuC,EACAR,EACAD,GAEA,MAAM,WAAErR,GAAeuP,GACjB,OAAEkD,GAAWzS,EACfA,EAAWuR,oBAAsBD,IACnCQ,GAAc9R,EAAWuR,kBAAoBD,GAG/C,MAAMoB,EAAa1S,EAAWhM,YACxBue,EAAkB,IAAIG,EAAWrB,GAEjCsB,EAAmB,IAAID,EAAWD,EAAQX,EAAYT,GAI5D,OAFAkB,EAAgBK,IAAID,GAEbJ,CACT,CApCMM,CACEtD,EACAuC,EACAR,EACAD,IAIA,IAAEzE,EAAG,IAAErK,IAAQ,IAAAuQ,WAAUP,GAE/B,MAAO,CACLrd,MAAO0X,EACPzX,MAAOoN,EAEX,CArLgBwQ,CAAiBxD,EAAaH,GAC1C1B,EAqBJ,SAA+B6B,EAA2B7B,GACxD,MAAMrR,EAAWkT,EAAYlT,SACvB0U,EAAe9a,KAAK6O,MAAMzI,EAAS8C,OAAS,GAC5CzE,EAAU2B,EAAS0U,GAWzB,GAyKF,SAAoC5T,EAAUoS,GAC5C,GAAiB,OAAbpS,IAAsBoS,EAAY5B,YACpC,OAAO,EAGT,IAAK4B,EAAYyD,SAASC,GAAGpB,MAC3B,OAAO,EAGT,OAAO,CACT,CAnLMqB,EARF,MAAa,sBAAuBxY,IAAY,CAAC,GAQAyC,SAAUoS,GAC3D,MAAO,CACLra,MAAO,EACPC,MAAO,GAIX,OAAOuY,CACT,CA3CUyF,CAAsB5D,EAAa7B,IAQzB,IAAfA,GAAKxY,OAA8B,IAAfwY,GAAKvY,YACXmK,IAAfoO,GAAKxY,YACUoK,IAAfoO,GAAKvY,OAKPya,EACGK,cACAE,uBAAuB,GACvBiD,gBAAgB1F,EAAIxY,MAAOwY,EAAIvY,MACpC,2ECvBA,MAAMke,EAAiB,CACrBC,cAAe,MAGV,SAASC,EAAOC,EAAWC,EAAOC,EAAgB,CAAC,GACxDxS,OAAOyS,OAAOF,EAAOJ,EAAgBK,GAErC,YAAuBF,EAAWC,EAAOC,GAEzC,YAAaF,EAAWC,EAAO,CAAC,kBAzBlC,SAA+BD,EAAWC,GACxCA,EAAMG,eAAe3N,KAAK,yBAE1B,MAAM4N,EAAcL,EAAUM,OAC9BN,EAAUM,OAAS,KACjBL,EAAMH,cAAgB,KACtBO,GAAa,CAEjB,CAoBEE,CAAsBP,EAAWC,EACnC,CAIO,MAIP,GAAiBO,YAJU,iBAAkBT,EAAQ,yBAIvBA,yDC/C9B,MAAMU,EAAmBC,OAAO,mBAC1BC,EAAmBD,OAAO,mBAC1BE,EAAsBF,OAAO,qBAC7BG,EAAaH,OAAO,cAKX,MAAMI,EACnB,WAAAtgB,CAAYugB,GACV,MAAMC,EAAatT,OAAOuT,OACvBF,aAAgBD,GAAYD,KAAcE,EACvCA,EAAKF,GACL,MAENnT,OAAOwT,KACLxT,OAAOC,eAAe9L,KAAMgf,EAAY,CACtCM,MAAOH,IAGb,CAEA,GAAA5B,CAAIgC,EAAaD,GACf,OAAO/B,EAAIvd,KAAKgf,GAAaO,EAAKD,EAAO,KAC3C,CAEA,GAAAvT,CAAIwT,GACF,OA8MJ,SAAaJ,EAAqCI,GAChD,OAAOJ,EAAWI,EACpB,CAhNWxT,CAAI/L,KAAKgf,GAAaO,EAC/B,CAQA,KAAAC,CAAMD,GACJ,OA8GJ,SAAeJ,EAAqClL,GAClD,GAAIA,EAAKwL,SAAS,KAAM,CACtB,IAAIC,EAAc,EAClB,MAAMC,EAAY1L,EACZiL,EAAOS,EAAUC,MAAM,GAAI,GAC3BC,EAA4B,IAAhBX,EAAKpV,OACvB,IAAK,MAAMyV,KAAOJ,EAEdtT,OAAOiU,UAAUC,eAAeC,KAAKb,EAAYI,KAChDM,GAAaN,EAAIU,WAAWN,IAAcJ,IAAQL,YAE5CC,EAAWI,KAChBG,GAGN,OAAOA,EAAc,CACvB,CACA,cAAcP,EAAWlL,EAC3B,CAhIWuL,CAAMxf,KAAKgf,GAAaO,EAAM,GACvC,CAEA,OAAAhP,CAAQQ,GACNmP,EAAQlgB,KAAKgf,GAAajO,EAC5B,CAEA,MAAAmN,GACE,OAAO,IAAIe,EAASjf,KACtB,CAQA,MAAAmgB,CAAOC,GACDC,EAAcD,IAChBvU,OAAOyU,KAAKF,GAAM7P,SAASgP,IACzBhC,EAAIvd,KAAKgf,GAAaO,EAAKa,EAAKb,GAAM,KAAK,GAGjD,CASA,IAAAgB,GACE,MAAM3V,EAAU,CAAC,EAMjB,OALAsV,EAAQlgB,KAAKgf,IAAa,CAACO,EAAKD,UACT,IAAVA,GACTkB,EAAQ5V,EAAS2U,EAAKD,EACxB,IAEK1U,CACT,CAEA,aAAO6V,CAAOC,GACZ,OAAOA,aAAmBzB,EACtByB,EACAzB,EAAS0B,oBACf,CAEA,yBAAOC,CAAmBC,EAAW,MACnC,IAAIC,EAAkB7B,EAASL,GAQ/B,GAPMkC,aAA2B7B,IAC/B6B,EAAkB,IAAI7B,EACtBA,EAASL,GAAoBkC,GAK3BD,EAAU,CACZ,MAAME,EAAa,CAAC,EAOpB,OANAD,EAAgBvQ,SAAS0D,IACvB,GAAIA,EAAKgM,WAAWY,GAAW,CAC7B,MAAMG,EAAU/M,EAAKtF,MAAM,GAAGkS,MAAa,GAC3CE,EAAWC,GAAWF,EAAgB/U,IAAIkI,EAC5C,KAEK8M,CACT,CAEA,OAAOD,CACT,CAEA,yBAAOH,GACL,IAAIM,EAAkBhC,EAASH,GAK/B,OAJMmC,aAA2BhC,IAC/BgC,EAAkB,IAAIhC,EAASA,EAAS2B,sBACxC3B,EAASH,GAAoBmC,GAExBA,CACT,CAEA,wBAAOC,CAAkBR,EAAkBS,GACzC,IAAIC,EAAW,KACf,GAAIV,aAAmBzB,EACrBmC,EAAWV,OACN,GAAuB,iBAAZA,GAAoC,OAAZA,EAAkB,CAC1D,IAAIW,EAAoBpC,EAASF,GAC3BsC,aAA6BC,UACjCD,EAAoB,IAAIC,QACxBrC,EAASF,GAAuBsC,GAElCD,EAAWC,EAAkBtV,IAAI2U,GAC3BU,aAAoBnC,IACxBmC,EAAW,IAAInC,EACbA,EAASwB,OAAOxB,EAASiC,kBAAkBC,KAE7CE,EAAkB9D,IAAImD,EAASU,GAEnC,CACA,OAAOA,CACT,CAEA,4BAAOG,GACL,OAAOtC,EAAS0B,qBAAqBzC,QACvC,EA2BF,SAASgC,EACPf,EACApO,GAEA,IAAK,MAAMwO,KAAOJ,EAChBpO,EAASwO,EAAKJ,EAAWI,GAE7B,CAsCA,SAAShC,EACP4B,EACAI,EACAD,EACAkC,GAEA,QA8BF,SAAoBjC,GAClB,IAAIkC,EAAcC,EAAiBC,EACnC,GAAmB,iBAARpC,IAAqBkC,EAAOlC,EAAIzV,OAAS,GAAK,EACvD,OAAO,EAET6X,GAAY,EACZ,MAAQD,EAAUnC,EAAI/S,QAAQ,IAAKmV,EAAW,KAAO,GAAG,CACtD,GAAID,EAAUC,EAAW,GAAKD,IAAYD,EACxC,OAAO,EAETE,EAAWD,CACb,CACA,OAAO,CACT,CA3CME,CAAWrC,KACTc,EAAcf,GA3CtB,SACEH,EACA0C,EACAC,EACAN,GAEA,IAAIO,EACJ,GAAIP,EAAWQ,IAAIF,GACjB,OAAOvE,EAAI4B,EAAY0C,EAAQ,KAAML,GAEvCA,EAAWS,IAAIH,GACfC,EAAY,EACZ,IAAK,MAAMG,KAASJ,EACdjW,OAAOiU,UAAUC,eAAeC,KAAK8B,EAAQI,KAE1C3E,EAAI4B,EADoB,IAAjB+C,EAAMpY,OAAe+X,EAAS,GAAGA,KAAUK,IAC7BJ,EAAOI,GAAQV,MACrCO,GAKR,OADAP,EAAW/C,OAAOqD,GACG,IAAdC,CACT,CAsBaI,CACLhD,EACAI,EACAD,EACAkC,aAAsBY,QAAUZ,EAAa,IAAIY,UAGrDjD,EAAWI,GAAOD,GACX,GAGX,CAgCA,SAASe,EAAcK,GACrB,GAAuB,iBAAZA,GAAoC,OAAZA,EAAkB,CACnD,MAAMZ,EAAYjU,OAAOwW,eAAe3B,GACxC,GAAIZ,IAAcjU,OAAOiU,WAA2B,OAAdA,EACpC,OAAO,CAEX,CACA,OAAO,CACT,CAEA,SAASU,EAAQ5V,EAAS2U,EAAKD,GAC7B,MAAMgD,EAAY/C,EAAI/S,QAAQ,KAC9B,GAAI8V,GAAa,EAAG,CAClB,MAAMC,EAAShD,EAAIK,MAAM,EAAG0C,GAC5B,IAAIE,EAAa5X,EAAQ2X,GACzB,GAA0B,iBAAfC,GAA0C,OAAfA,EAAqB,CACzD,MAAMC,EAAkBD,EACxBA,EAAa,CAAC,OACiB,IAApBC,IACTD,EAAW,IAAMC,GAEnB7X,EAAQ2X,GAAUC,CACpB,CACAhC,EAAQgC,EAAYjD,EAAIK,MAAM0C,EAAY,EAAG/C,EAAIzV,QAASwV,EAC5D,MACE1U,EAAQ2U,GAAOD,CAEnB,CAKAL,EAAS2B,qBAAqBrD,IAAI,cAAc,iGCzRhD,MAAMmF,EAAS,WAw9Bf,MACA,EADc,IA78Bd,MAaE,WAAA/jB,GAXiB,KAAAgkB,YAAc,IAAIC,IAElB,KAAAC,aAAe,IAAID,IAI5B,KAAAE,gBAAkB,EAClB,KAAAC,iBAAmB,EACnB,KAAAC,cAAgB,EAAIN,EACpB,KAAAO,iBAAmB,WAgBpB,KAAAC,gBAAmBC,IACxB,IAAKA,GAA8C,iBAApBA,EAA8B,CAC3D,MAAMC,EAAe,qBAAqBpjB,KAAKgjB,0DAC/C,MAAM,IAAIrb,MAAMyb,EAClB,CAEApjB,KAAKgjB,cAAgBG,CAAe,EAa/B,KAAAE,YAAetH,IACpB,GAAIA,EAAa/b,KAAKijB,iBACpB,OAAO,EAMT,OAJyBjjB,KAAKsjB,oBACPtjB,KAAK8iB,gBAGJ/G,CAAU,EAQ7B,KAAAwH,gBAAkB,IAAcvjB,KAAKgjB,cAOrC,KAAAQ,mBAAqB,IAAcxjB,KAAKijB,iBAOxC,KAAAQ,aAAe,IACpBzjB,KAAK8iB,gBAAkB9iB,KAAK+iB,iBAgBtB,KAAAW,cAAiBre,IACvB,MAAM,gBAAEse,GAAoB3jB,KAAK2iB,YAAY5W,IAAI1G,GAG7Cse,EAAgBC,UAClBD,EAAgBC,WAGdD,EAAgBE,SAClBF,EAAgBE,UAGlB7jB,KAAK2iB,YAAYlE,OAAOpZ,EAAQ,EAS1B,KAAAye,eAAkB9J,IACxB,MAAM+J,EAAe/jB,KAAK6iB,aAAa9W,IAAIiO,IACrC,iBAAEgK,EAAgB,OAAEC,GAAWF,EAEjCE,EAAOC,eACTD,EAAOC,gBAGLD,EAAOjZ,WACTiZ,EAAOjZ,UAAUyT,SAKnBze,KAAKmkB,yBAAyBF,GAE1BD,EAAiBJ,UAEnBI,EAAiBJ,WAGfI,EAAiBH,SACnBG,EAAiBH,UAGnB7jB,KAAK6iB,aAAapE,OAAOzE,EAAS,EAa7B,KAAAoK,WAAa,KAClB,MAAMC,EAAgBrkB,KAAK2iB,YAAYrC,OAGvC,OAAa,CACX,MAAQhB,MAAOja,EAAO,KAAEif,GAASD,EAAcE,OAE/C,GAAID,EACF,MAGFtkB,KAAKwkB,sBAAsBnf,IAE3B,IAAAhC,cAAa,IAAa,IAAOohB,0BAA2B,CAAEpf,WAChE,CAEArF,KAAK0kB,kBAAkB,EAMlB,KAAAA,iBAAmB,KACxB,MAAMC,EAAiB3kB,KAAK6iB,aAAavC,OAGzC,OAAa,CACX,MAAQhB,MAAOtF,EAAQ,KAAEsK,GAASK,EAAeJ,OAEjD,GAAID,EACF,MAGFtkB,KAAK4kB,uBAAuB5K,IAE5B,IAAA3W,cAAa,IAAa,IAAOwhB,4BAA6B,CAC5D7K,YAEJ,GA0ZK,KAAA8K,oBAAuB9K,IAC5B,QAAiB/P,IAAb+P,EACF,MAAM,IAAIrS,MAAM,uDAElB,MAAMoc,EAAe/jB,KAAK6iB,aAAa9W,IAAIiO,GAE3C,QAAqB/P,IAAjB8Z,EAOJ,OAFAA,EAAagB,UAAYC,KAAKC,MAEvBlB,EAAaC,gBAAgB,EAG/B,KAAAkB,YAAeC,IACpB,GAAkB,MAAdA,EACF,MAAM,IAAIxd,MAAM,iDAGlB,MAAMyd,EAAiBplB,KAAKqlB,eAAetZ,IAAIoZ,GAE/C,QAAuBlb,IAAnBmb,EAOJ,OAFAA,EAAeL,UAAYC,KAAKC,MAEzBG,EAAeE,QAAQ,EASzB,KAAA7U,SAAYpL,IACjB,QAAgB4E,IAAZ5E,EACF,MAAM,IAAIsC,MAAM,2CAElB,MAAM4d,EAAcvlB,KAAK2iB,YAAY5W,IAAI1G,GAEzC,QAAoB4E,IAAhBsb,EAOJ,OAFAA,EAAYR,UAAYC,KAAKC,MAEtBM,EAAYngB,KAAK,EASnB,KAAAogB,UAAaxL,IAClB,QAAiB/P,IAAb+P,EACF,MAAM,IAAIrS,MAAM,6CAElB,MAAMoc,EAAe/jB,KAAK6iB,aAAa9W,IAAIiO,GAE3C,QAAqB/P,IAAjB8Z,EAOJ,OAFAA,EAAagB,UAAYC,KAAKC,MAEvBlB,EAAaE,MAAM,EAOrB,KAAAwB,WAAa,IACIne,MAAM6Z,KAAKnhB,KAAK6iB,aAAatP,UAE9BhR,KAAKwhB,GAAiBA,EAAaE,SAQnD,KAAAyB,2BACL1L,GAEsBha,KAAKylB,aAENjY,QAAQyW,GACpBA,EAAO0B,qBAAuB3L,IAalC,KAAAwK,sBAAyBnf,IAC9B,QAAgB4E,IAAZ5E,EACF,MAAM,IAAIsC,MAAM,wDAElB,MAAM4d,EAAcvlB,KAAK2iB,YAAY5W,IAAI1G,GAEzC,QAAoB4E,IAAhBsb,EACF,MAAM,IAAI5d,MACR,gEAIJ3H,KAAK4lB,yBAAyBL,EAAYM,aAE1C,MAAMC,EAAe,CACnB1gB,MAAOmgB,EACPlgB,YAGF,IAAAhC,cAAa,IAAa,IAAOohB,0BAA2BqB,GAC5D9lB,KAAK0jB,cAAcre,EAAQ,EAYtB,KAAAuf,uBAA0B5K,IAC/B,QAAiB/P,IAAb+P,EACF,MAAM,IAAIrS,MAAM,0DAElB,MAAMoc,EAAe/jB,KAAK6iB,aAAa9W,IAAIiO,GAE3C,QAAqB/P,IAAjB8Z,EACF,MAAM,IAAIpc,MACR,mEAIJ3H,KAAK+lB,0BAA0BhC,EAAa8B,aAE5C,MAAMC,EAAe,CACnB7B,OAAQF,EACR/J,aAGF,IAAA3W,cAAa,IAAa,IAAOwhB,4BAA6BiB,GAC9D9lB,KAAK8jB,eAAe9J,EAAS,EAG/B,KAAAgM,sBAAwB,CACtBb,EACAc,KAEA,GAAkBhc,MAAdkb,EACF,MAAM,IAAIxd,MACR,2DAIJ,GAAI3H,KAAKqlB,eAAerD,IAAImD,GAC1B,MAAM,IAAIxd,MACR,sEAIJ,MAAMyd,EAAkC,CACtCD,aACAc,qBACAC,QAAQ,EACRnB,UAAWC,KAAKC,MAChBY,YAAa,GAKf,OAFA7lB,KAAKqlB,eAAe9H,IAAI4H,EAAYC,GAE7Ba,EAAmBE,QACvB/d,MAAMkd,IACL,IAAKtlB,KAAKqlB,eAAerD,IAAImD,GAI3B,YAHA9T,QAAQC,KACN,oEAKJ,GAAI1C,OAAO7N,MAAMukB,EAASO,aACxB,MAAM,IAAIle,MACR,+DAMJyd,EAAec,QAAS,EACxBd,EAAeE,SAAWA,EAC1BF,EAAeS,YAAcP,EAASO,YAItC,MAAMC,EAAe,CACnBR,WACAH,eAGF,IAAA9hB,cACE,IACA,IAAO+iB,8BACPN,EAGI,IAEPO,OAAOC,IAEN,MADAtmB,KAAKqlB,eAAe5G,OAAO0G,GACrBmB,CAAK,GACX,EAQC,KAAAV,wBAA2B3S,IAChCjT,KAAK8iB,iBAAmB7P,CAAS,EAQ5B,KAAA8S,yBAA4B9S,IACjCjT,KAAK+iB,kBAAoB9P,CAAS,EAQ7B,KAAAsT,wBAA2BC,IAChCxmB,KAAK8iB,iBAAmB0D,CAAS,EAQ5B,KAAAC,yBAA4BD,IACjCxmB,KAAK+iB,kBAAoByD,CAAS,EAp1BlCxmB,KAAKqlB,eAAiB,IAAIzC,GAC5B,CAmEO,iBAAAU,GACL,OAAOtjB,KAAKujB,kBAAoBvjB,KAAKyjB,cACvC,CAmIO,qCAAAiD,CACLC,EACAC,GAEA,IAAIC,EAAiB7mB,KAAKsjB,oBAG1B,GAAIuD,GAAkBF,EACpB,OAAOE,EAGT,IAAIC,EAAexf,MAAM6Z,KAAKnhB,KAAK2iB,YAAYpP,UAe/CuT,EAAapT,MAXb,SAAiBZ,EAAGC,GAClB,OAAID,EAAEiS,UAAYhS,EAAEgS,UACX,EAELjS,EAAEiS,UAAYhS,EAAEgS,WACV,EAGH,CACT,IAGA,IAAIgC,EAAiBD,EAAavkB,KAAKykB,GAAOA,EAAG3hB,UAE7C4hB,EAAkBF,EAIlBH,IACFK,EAAkBF,EAAevZ,QAC9BhK,IAAQojB,EAAeM,SAAS1jB,MAMrC,IAAK,MAAM6B,KAAW4hB,EAMpB,GALAjnB,KAAKwkB,sBAAsBnf,IAE3B,IAAAhC,cAAa,IAAa,IAAOohB,0BAA2B,CAAEpf,YAE9DwhB,EAAiB7mB,KAAKsjB,oBAClBuD,GAAkBF,EACpB,OAAOE,EAKXC,EAAexf,MAAM6Z,KAAKnhB,KAAK2iB,YAAYpP,UAC3CwT,EAAiBD,EAAavkB,KAAKykB,GAAOA,EAAG3hB,UAI7C,IAAK,MAAMA,KAAW0hB,EAMpB,GALA/mB,KAAKwkB,sBAAsBnf,IAE3B,IAAAhC,cAAa,IAAa,IAAOohB,0BAA2B,CAAEpf,YAE9DwhB,EAAiB7mB,KAAKsjB,oBAClBuD,GAAkBF,EACpB,OAAOE,CAOb,CAmBO,kBAAAM,CACL9hB,EACAse,GAEA,QAAgB1Z,IAAZ5E,EACF,MAAM,IAAIsC,MAAM,qDAGlB,QAAgCsC,IAA5B0Z,EAAgBwC,QAClB,MAAM,IAAIxe,MACR,qEAIJ,GAAI3H,KAAK2iB,YAAYX,IAAI3c,GACvB,MAAM,IAAIsC,MAAM,gDAGlB,GACEgc,EAAgBC,UACoB,mBAA7BD,EAAgBC,SAEvB,MAAM,IAAIjc,MACR,iEAIJ,MAAM4d,EAA4B,CAChCW,QAAQ,EACR7gB,UACA+hB,oBAAgBnd,EAChB0Z,kBACAoB,UAAWC,KAAKC,MAChBY,YAAa,GAKf,OAFA7lB,KAAK2iB,YAAYpF,IAAIlY,EAASkgB,GAEvB5B,EAAgBwC,QACpB/d,MAAMhD,IACL,IAAKpF,KAAK2iB,YAAY5W,IAAI1G,GAKxB,YAHAgM,QAAQC,KACN,oEAKJ,QACwBrH,IAAtB7E,EAAMygB,aACNjX,OAAO7N,MAAMqE,EAAMygB,aAEnB,MAAM,IAAIle,MACR,+DAGJ,QAAkCsC,IAA9B7E,EAAMygB,YAAYwB,QACpB,MAAM,IAAI1f,MACR,yDAKJ,IAAK3H,KAAKqjB,YAAYje,EAAMygB,aAC1B,MAAM,IAAIle,MAAM,IAAO2f,qBAIzBtnB,KAAK0mB,sCAAsCthB,EAAMygB,aAEjDN,EAAYW,QAAS,EACrBX,EAAYngB,MAAQA,EACpBmgB,EAAYM,YAAczgB,EAAMygB,YAChC7lB,KAAK4lB,wBAAwBL,EAAYM,aACzC,MAAMC,EAA2D,CAC/D1gB,MAAOmgB,IAGT,IAAAliB,cAAa,IAAa,IAAOkkB,wBAAyBzB,GAE1DP,EAAY6B,eAAiBhiB,EAAMgiB,cAAc,IAElDf,OAAOC,IAGN,MADAtmB,KAAK2iB,YAAYlE,OAAOpZ,GAClBihB,CAAK,GAEjB,CAQO,kBAAAkB,CAAmBniB,GACxB,QAAgB4E,IAAZ5E,EACF,MAAM,IAAIsC,MAAM,qDAElB,MAAM4d,EAAcvlB,KAAK2iB,YAAY5W,IAAI1G,GAEzC,QAAoB4E,IAAhBsb,EAOJ,OAFAA,EAAYR,UAAYC,KAAKC,MAEtBM,EAAY5B,eACrB,CASO,QAAA8D,CAASpiB,GACd,MAAMkgB,EAAcvlB,KAAK2iB,YAAY5W,IAAI1G,GAEzC,QAAKkgB,GAIEA,EAAYW,MACrB,CASO,0BAAAwB,CAA2BriB,GAIhC,MAAMsiB,EAAYrgB,MAAM6Z,KAAKnhB,KAAK6iB,aAAavC,QACzCsH,GAAe,IAAAC,cAAaxiB,GAElC,IAAK,MAAM2U,KAAY2N,EAAW,CAChC,MAAM5D,EAAe/jB,KAAK6iB,aAAa9W,IAAIiO,IACrC,OAAEiK,GAAWF,EAEnB,IAAKE,GAAQjd,UAAU8C,OACrB,OAGF,MAAM4R,EAAeuI,EAAO6D,iBAAiBF,GAE7C,GAAIlM,GAAgB,EAClB,MAAO,CAAEuI,SAAQvI,eAErB,CACF,CASO,6BAAAqM,CACL1iB,GAEA,MAAM2iB,GAAgB,IAAAH,cAAaxiB,GAG7B4iB,EADiB3gB,MAAM6Z,KAAKnhB,KAAK2iB,YAAYrC,QACf4H,MAAM7iB,IACjC,IAAAwiB,cAAaxiB,KAAa2iB,IAGnC,GAAKC,EAIL,OAAOjoB,KAAK2iB,YAAY5W,IAAIkc,EAC9B,CAiBO,mBAAAE,CACLnO,EACAgK,GAEA,QAAiB/Z,IAAb+P,EACF,MAAM,IAAIrS,MAAM,uDAElB,QAAiCsC,IAA7B+Z,EAAiBmC,QACnB,MAAM,IAAIxe,MACR,uEAGJ,GAAI3H,KAAK6iB,aAAab,IAAIhI,GACxB,MAAM,IAAIrS,MACR,iCAAiCqS,sBAGrC,GACEgK,EAAiBJ,UACoB,mBAA9BI,EAAiBJ,SAExB,MAAM,IAAIjc,MACR,mEAOJ,MAAMoc,EAA8B,CAClCmC,QAAQ,EACRlM,WACAgK,mBACAe,UAAWC,KAAKC,MAChBY,YAAa,GAKf,OAFA7lB,KAAK6iB,aAAatF,IAAIvD,EAAU+J,GAEzBC,EAAiBmC,QACrB/d,MAAM6b,IACL,IAAKjkB,KAAK6iB,aAAa9W,IAAIiO,GAKzB,YAHA3I,QAAQC,KACN,oEAKJ,GAAI1C,OAAO7N,MAAMkjB,EAAO4B,aACtB,MAAM,IAAIle,MACR,iEAGJ,QAAmCsC,IAA/Bga,EAAO4B,YAAYwB,QACrB,MAAM,IAAI1f,MACR,2DAOJ3H,KAAK0mB,sCACHzC,EAAO4B,YAEP5B,EAAOjd,UAIT+c,EAAaE,OAASA,EACtBF,EAAa8B,YAAc5B,EAAO4B,YAClC7lB,KAAK+lB,yBAAyBhC,EAAa8B,aAE3C,MAAMC,EAA6D,CACjE7B,OAAQF,IAGV,IAAA1gB,cACE,IACA,IAAO+kB,0BACPtC,EACD,IAEFO,OAAOC,IAEN,MADAtmB,KAAK6iB,aAAapE,OAAOzE,GACnBsM,CAAK,GAEjB,CA8RQ,wBAAAnC,CAAyBF,GAC/B,KAAMA,aAAkB,KAItB,YAHA5S,QAAQC,KACN,oEAMJ,MAAM3G,EAAasZ,EAAOvZ,gBACpB2d,EAAsBpE,EAAOoE,oBAEnC,GAAiC,IAA7BA,EAAoBC,KAAxB,CAOA,IAAK,MAAOjjB,GAAS,OAAEkjB,MAAaF,EAAqB,CACvD,MAAMjjB,EAAQpF,KAAKyQ,SAASpL,GAE5B,IAAKD,EAAO,CACViM,QAAQC,KAAK,iBAAiBjM,yBAC9B,QACF,CAEA,MAAMmjB,EAAgBpjB,EAAM+X,eACtBrT,EAAS0e,EAAc1e,OAIvB2e,EAAY,IAAID,EAAc7pB,YAClCgM,EAAWyS,OACXmL,EACAze,GAIF1E,EAAM+X,aAAe,IAAMsL,EAEvBrjB,EAAMsjB,aACRtjB,EAAMsjB,WAAWD,UAAYA,UAGxBrjB,EAAMujB,WAGb3oB,KAAK4lB,wBAAwBxgB,EAAMygB,YACrC,CAEAxU,QAAQuX,IAAI,0CAA0C3E,EAAOjK,YAnC7D,CAoCF,kDC/7BF,MAEA,EAFgB,oDCAhB,MAAM6O,EAAqB,CACzBC,uBAAwB,IACxBC,qBAAsB,KAGxBld,OAAOmd,OAAOH,GAEd,wCCJA,IAAKzN,mBAAL,SAAKA,GAEH,4BAEA,wBAEA,sBAEA,mBACD,CATD,CAAKA,IAAAA,EAAW,KAWhB,wCCdA,IAAK6N,mBAAL,SAAKA,GAEH,mBAEA,oBAEA,yBAEA,kBAEA,qBACD,CAXD,CAAKA,IAAAA,EAAc,KAanB,+bCXA,MAAM,UAAEC,GAAc,UAStB,IAAKC,GAAL,SAAKA,GAEH,cAAYD,EAAUE,iBAAe,YAErC,4BAA0BF,EAAUG,yBAAuB,0BAE3D,4BAA0BH,EAAUI,yBAAuB,0BAE3D,4BAA0BJ,EAAUK,yBAAuB,yBAC5D,CATD,CAAKJ,IAAAA,EAAU,KAWf,cCtBKK,yBAAL,SAAKA,GACH,oBACA,mBACD,CAHD,CAAKA,IAAAA,EAAY,KAKjB,sBCDKC,cAAL,SAAKA,GAEH,YAEA,oBAEA,qBACD,CAPD,CAAKA,IAAAA,EAAmB,KASxB,UCTA,IAAYC,GAAZ,SAAYA,GAMV,oBAWA,cAOA,cASA,oBAMA,kBAMA,gBAEA,6BACD,CAhDD,CAAYA,IAAAA,EAAgB,KAkD5B,gJCrBe,SAASC,EACtB5qB,GAEA,IAAKA,EACH,OAGF,MAAM,YAAE6qB,EAAW,mBAAEC,GAAuB9qB,EAAQ+qB,QAEpD,OAAOC,EAAuBH,EAAaC,EAC7C,CAYO,SAASE,EACdxmB,EACAG,GAEA,IAAKA,IAAsBH,EACzB,OAGF,MAAM2N,GAAkB,QAAmBxN,GAE3C,IAAKwN,GAAmBA,EAAgB8Y,iBACtC,OAGF,MAAMvmB,EAAWyN,EAAgBE,YAAY7N,GAI7C,IAAKE,EACH,OAGF,MAAMwmB,EAAsBxmB,EAASxC,yBAErC,MAAO,CACLwC,WACAyN,kBACA3N,aACAG,oBACAumB,sBAEJ,CASO,SAASC,EAA8B3mB,GAC5C,MAAM4mB,GAAmB,UAEzB,IAAK,IAAInhB,EAAI,EAAGA,EAAImhB,EAAiBrgB,OAAQd,IAAK,CAChD,MAAMkI,EAAkBiZ,EAAiBnhB,GAGzC,GAFiBkI,EAAgBE,YAAY7N,GAG3C,OAAOwmB,EAAuBxmB,EAAY2N,EAAgB1N,GAE9D,CACF,CAMO,SAAS4mB,IACd,MAAMC,EAAkB,GAYxB,OAVyB,UAER9Z,SAASW,IACNA,EAAgBoZ,eAExB/Z,SAAQ,EAAGxR,cACnBsrB,EAAgBzZ,KAAK+Y,EAAkB5qB,GAAS,GAChD,IAGGsrB,CACT,0hBC5DA,MAAME,EAAe,CAAC,EACtB,IAAIC,EAaJ,SAASC,EACPplB,EACA4B,GAGA,MAAMqH,EAAajJ,EAAQmH,QAAQ,KAC7Bke,EAASrlB,EAAQiH,UAAU,EAAGgC,GAC9Bqc,EAASJ,EAAaG,GAC5B,GAAIC,QAAyC,CAC3C,QAA2B1gB,IAAvBugB,EACF,OAAOA,EAAmBnlB,GAE5B,MAAM,IAAIsC,MAAM,wDAClB,CAEA,MAAMgc,EAAkBgH,EAAOtlB,EAAS4B,GAcxC,OAZA0c,EAAgBwC,QAAQ/d,MACtB,SAAUhD,IACR,IAAA/B,cAAa,IAAa,IAAOunB,aAAc,CAAExlB,SACnD,IACA,SAAUkhB,GACR,MAAMuE,EAAuD,CAC3DxlB,UACAihB,UAEF,IAAAjjB,cAAa,IAAa,IAAOynB,kBAAmBD,EACtD,IAEKlH,CACT,CAeA,SAASoH,EACP1lB,EACA4B,GAEA,GAAIA,EAAQgW,YACV,OAAOwN,EAAyBplB,EAAS4B,GAI3C,IAAI0c,EAAkB,IAAM6D,mBAAmBniB,GAC/C,QAAwB4E,IAApB0Z,EACF,OAAOA,EAIT,MAAMqH,EAAmB,IAAMtD,2BAA2BriB,GAC1D,GAAI2lB,GAAkB/G,QAAQgH,YAAY/E,OAAQ,CAGhD,MAAM,OAAEjC,EAAM,aAAEvI,GAAiBsP,EAKjC,OAHI/G,aAAkB,OACpBN,EAAkBM,EAAOiH,0BAA0B7lB,EAASqW,IAEvDiI,CACT,CAIA,MAAM4B,EAAc,IAAMwC,8BAA8B1iB,GACxD,OAAIkgB,GACF5B,EAAkB4B,EAAY5B,gBACvBA,IAITA,EAAkB8G,EAAyBplB,EAAS4B,GAE7C0c,EACT,CAaO,SAASwH,EACd9lB,EACA4B,EAA8B,CAAE2V,SAAU,EAAGC,YAAa,aAE1D,QAAgB5S,IAAZ5E,EACF,MAAM,IAAIsC,MAAM,sDAGlB,OAAOojB,EAA2B1lB,EAAS4B,GAASkf,OACtD,CAYO,SAASnJ,EACd3X,EACA4B,EAA8B,CAAE2V,SAAU,EAAGC,YAAa,aAE1D,QAAgB5S,IAAZ5E,EACF,MAAM,IAAIsC,MACR,8DAKJ,MAAMgc,EAAkBoH,EAA2B1lB,EAAS4B,GAU5D,OANK,IAAMugB,mBAAmBniB,IAC5B,IAAM8hB,mBAAmB9hB,EAASse,GAAiB0C,OAAO+E,IACxD/Z,QAAQC,KAAK8Z,EAAI,IAIdzH,EAAgBwC,OACzB,CASO,SAASkF,EACdrkB,EACAC,EAA8B,CAAE2V,SAAU,EAAGC,YAAa,aAE1D,IAAK7V,GAAgC,IAApBA,EAAS8C,OACxB,MAAM,IAAInC,MACR,oEAQJ,OAJoBX,EAASzE,KAAK8C,GACzB2X,EAAkB3X,EAAS4B,IAItC,CAYO,SAASqkB,EACdjd,EACApH,EAA+B,CAAC,EAChCskB,GAAe,GAEf,QAA0BthB,IAAtBoE,EACF,MAAM,IAAI1G,MACR,4EAIoBsC,IAApBhD,EAAQ5B,UACV4B,EAAQ5B,QAAU,YAAW,IAAAmmB,aAG/B,MAAM,QAAEnmB,EAAO,iBAAEomB,EAAgB,WAAEC,GAAezkB,EAE5C3B,EAAmB,EAAAqmB,SAAA,IAAa,mBAAoBtd,GAEpDvE,EAASxE,EAAiBO,KAAOP,EAAiBQ,SAElD,sBAAE8lB,IAA0B,IAAAC,wBAChC5kB,EAAQ6kB,iBACRhiB,GAIIoT,EAAkB,IAAI0O,EAC1BH,EAAmB,EAAI3hB,GAEnBiiB,EAAiB1mB,EAEvB,CAAC,mBAAoB,uBAAuBkL,SAASoM,IACnD,EAAAqP,wBAAwB/J,IAAI8J,EAAgB,CAC1CpP,OACA3U,SAAU,EAAA2jB,SAAA,IAAahP,EAAMtO,IAC7B,IAGJ,MAAM4d,EAAmB,EAAAN,SAAA,IAAa,mBAAoBtd,GAE1D,EAAA2d,wBAAwB/J,IAAI8J,EAAgB,CAC1CpP,KAAM,mBACN3U,SAAU,IACLikB,EACHxlB,cAAe,EACfylB,WAAY,EACZC,QAAS,EACTC,gBAAiB,EACjBC,oBAAqB,KAIzB,MAAMC,EAAaC,EACjB,CAAE5hB,WAAYuS,EAAiBwO,aAAYD,oBAC3CpmB,GACA,GAGIse,EAAkB,CACtBwC,QAAS7d,QAAQC,QAAQ+jB,IAM3B,OAHKf,GACH,IAAMpE,mBAAmB4E,EAAgBpI,GAEpCA,EAAgBwC,OACzB,CAWO,SAASqG,EACdzP,EACA9V,EAGI,CAAC,GAEL,GAAmC,IAA/B8V,GAAoBjT,OACtB,MAAM,IAAInC,MACR,6EAIJ,MAAM8kB,EAAkB,GAClBC,EAAc3P,EAAmBxa,KAAK8L,IAC1C,MAAMse,EAAkC,CACtCtnB,QACE4B,EAAQ2lB,oBAAoBve,IAAsB,YAAW,IAAAmd,eAC5DvkB,GAGL,OADAwlB,EAAgB7b,KAAK+b,EAAWtnB,SACzBimB,EAA2Bjd,EAAmBse,EAAW,IAGlE,MAAO,CAAE3lB,SAAUylB,EAAiBI,SAAUH,EAChD,CAEO,SAASH,EACdtlB,EACA5B,EACAkmB,GAAe,GAEf,MAAMjmB,EAAmB,EAAAqmB,SAAA,IAAa,mBAAoBtmB,GAEpDyE,EAASxE,EAAiBO,KAAOP,EAAiBQ,QAElDV,EAAQ,CACZC,QAASA,EACTynB,UAAW,EACXlgB,aAAc,EACdD,YAAa,EACb2J,OAAO,EACP5P,SAAU,EACVqmB,MAAO,EACPC,cAAe,EACfC,cAAe,IACfC,oBAAgBjjB,EAChBpE,KAAMP,EAAiBO,KACvBC,QAASR,EAAiBQ,QAC1BqnB,eAAWljB,EACXzJ,OAAQ8E,EAAiBO,KACzBtF,MAAO+E,EAAiBQ,QACxB4O,UAAMzK,EACN9D,mBAAoBb,EAAiBa,mBACrCE,gBAAiBf,EAAiBe,gBAClChE,QAAQ,GAGV,GAAI4E,EAAQ0D,WAAY,CACtB,MAAMuS,EAAkBjW,EAAQ0D,WAEhC,KAEIuS,aAA2BkQ,YAC3BlQ,aAA2BmQ,cAC3BnQ,aAA2BoQ,aAC3BpQ,aAA2BqQ,YAG7B,MAAM,IAAI5lB,MACR,mHAIJvC,EAAMygB,YAAc3I,EAAgBnB,WACpC3W,EAAM+X,aAAe,IAAMD,CAC7B,MAAO,IAAiC,IAA7BjW,EAAQwkB,iBAA2B,CAC5C,MAAM,SAAE9E,EAAQ,sBAAEiF,IAA0B,IAAAC,wBAC1C5kB,EAAQ6kB,iBACRhiB,GAGIoT,EAAkB,IAAI0O,EAAsB9hB,GAElD1E,EAAMygB,YAAcc,EACpBvhB,EAAM+X,aAAe,IAAMD,CAC7B,CAKAjW,EAAQykB,aAAatmB,GAErB,MAAMue,EAAkB,CACtBwC,QAAS7d,QAAQC,QAAQnD,IAO3B,OAJKmmB,GACH,IAAMpE,mBAAmB/hB,EAAMC,QAASse,GAGnCve,CACT,CASO,SAASooB,EAAgBnoB,GAa9B,IAAqBooB,gBAZE,EAAGC,wBACpBA,EAAkBroB,SACbqoB,EAAkBroB,UAAYA,IAezC,MAAMse,EAAkB,IAAM6D,mBAAmBniB,GAE7Cse,GACFA,EAAgBC,UAEpB,CASO,SAAS+J,EAAiB3mB,GAC/BA,EAASuJ,SAASlL,GAAYmoB,EAAgBnoB,IAChD,CAOO,SAASuoB,IACd,MAAMC,EAAc,IAAqBC,iBAEzCjiB,OAAOyU,KAAKuN,GAAatd,SAASoM,IAChC,MAAMoR,EAAWF,EAAYlR,GAE7B9Q,OAAOyU,KAAKyN,GAAUxd,SAASqM,IAC7B,MACM8Q,EADiBK,EAASnR,GAAUoR,MACDN,mBACnC,QAAEroB,EAAO,SAAE2U,GAAa0T,EAE9B,IAAIO,EAEA5oB,EACF4oB,EAAa,IAAMzG,mBAAmBniB,GAC7B2U,IACTiU,EAAa,IAAMnJ,oBAAoB9K,IAErCiU,GACFA,EAAWC,QACb,IAGF,IAAqBC,kBAAkBxR,EAAK,GAIhD,CAQO,SAASyR,EACd1D,EACA2D,GAEA9D,EAAaG,GAAU2D,CACzB,CAQO,SAASC,EACdD,GAEA,MAAME,EAAiB/D,EAEvB,OADAA,EAAqB6D,EACdE,CACT,CAMO,SAASC,IACd3iB,OAAOyU,KAAKiK,GAAcha,SACvB8d,UAAuB9D,EAAa8D,KAEvC7D,OAAqBvgB,CACvB,CAYO,SAASwkB,EACd1R,EACA9V,EAA+B,CAC7B6kB,iBAAkB,eAGpB,OAAOU,EAA4BzP,EAAoB9V,EACzD,CAYO,SAASynB,EACdrgB,EACApH,EAA+B,CAC7B6kB,iBAAkB,eAGpB,OAAOR,EAA2Bjd,EAAmBpH,EACvD,shBCpeA,SAAS0nB,EACP1K,GAEA,MAAM,WAAErd,EAAU,SAAEoB,EAAQ,QAAEnB,EAAO,UAAEF,EAAS,OAAEX,GAAWie,GACvD,0BAAE2K,GAA8B5mB,EAEtC,IAAI6mB,EAAgB,EACc,QAA9BD,IACFC,EAAgB,GAGlB,MAAM7jB,EAAY,mBACZ8jB,EAAiB,CAAEC,mBAAoBF,GAQ7C,GANA7jB,EAAUgkB,cAAcpoB,GACxBoE,EAAUikB,WAAWpoB,GACrBmE,EAAUkkB,aAAavoB,GACvBqE,EAAUmkB,UAAUnpB,GAGhBie,EAAOmL,kBAAmB,EAvChC,SACEpkB,EACAqkB,EACAP,GAEAO,EAAiB9e,SAAQ,CAAC5F,EAAY3B,KACpC,MAAMsmB,EAAiB,sBAAyB,CAC9Crb,KAAM,aAAajL,IACnBuK,OAAQ5I,KACLmkB,IAGL9jB,EAAUyP,eAAe8U,SAASD,EAAe,IAInDtkB,EAAUyP,eAAe+U,iBAAiB,cAC5C,CA2BIC,CAA+BzkB,EAJgB,EAE5C0kB,sBAEyDZ,EAC9D,KAAO,EA9DT,SACE9jB,EACAL,EACAmkB,GAEA,MAAMa,EAAc,sBAAyB,CAC3C1b,KAAM,SACNV,OAAQ5I,KACLmkB,IAGL9jB,EAAUyP,eAAemV,WAAWD,EACtC,CAqDIE,CAAyB7kB,EAFNiZ,EAAOvZ,gBAEsBokB,EAClD,CAEA,OAAO9jB,CACT,CAMA,MAAM8kB,EAAgB,CAAC,EAEvB,IAAIC,EAeJ,SAASC,EACPhW,EACA/S,GAEA,MAAMqH,EAAa0L,EAASxN,QAAQ,KAC9Bke,EAAS1Q,EAAS1N,UAAU,EAAGgC,GACrC,IAAIqc,EAASmF,EAAcpF,GAE3B,GAAIC,QAAyC,CAC3C,GACyB,MAAvBoF,GAC+B,mBAAxBA,EAEP,MAAM,IAAIpoB,MACR,+BAA+B+iB,yBAInCC,EAASoF,CACX,CAEA,MAAM/L,EAAmB2G,EAAO3Q,EAAU/S,GAmB1C,OAjBA,IAAAgpB,qCAAoCjW,GAGpCgK,EAAiBmC,QAAQ/d,MACvB,SAAU6b,IACR,OAAa,IAAa,IAAOiM,cAAe,CAAEjM,UACpD,IACA,SAAUqC,GACR,MAAMuE,EAAwD,CAC5D7Q,WACAsM,UAGF,OAAa,IAAa,IAAO6J,qBAAsBtF,EACzD,IAGK7G,CACT,CAWO,SAAS7J,EACdH,EACA/S,EAA+B,CAAED,SAAU,KAE3C,QAAiBiD,IAAb+P,EACF,MAAM,IAAIrS,MAAM,wDAGlB,IAAIqc,EAAmB,IAAMc,oBAAoB9K,GAEjD,YAAyB/P,IAArB+Z,EACKA,EAAiBmC,SAG1BnC,EAAmBgM,EAA2BhW,EAAU/S,GAEjD+c,EAAiBmC,QAAQ/d,MAAM6b,IACpCA,EAAOjZ,UAAY2jB,EAAgC1K,GAC5CA,KAEX,CAWOhT,eAAemf,EACpBpW,EACA/S,GAEA,QAAiBgD,IAAb+P,EACF,MAAM,IAAIrS,MACR,kEAIJ,IAAIqc,EAAmB,IAAMc,oBAAoB9K,GAEjD,YAAyB/P,IAArB+Z,IAIJA,EAAmBgM,EAA2BhW,EAAU/S,GAExD+c,EAAiBmC,QAAQ/d,MAAM6b,IAC7BA,EAAOjZ,UAAY2jB,EAAgC1K,EAAO,IAG5D,IAAMkE,oBAAoBnO,EAAUgK,GAAkBqC,OAAO+E,IAC3D,MAAMA,CAAG,KAVFpH,EAAiBmC,OAc5B,CAcOlV,eAAeof,EACpB1K,EACA1e,GAEA,MAAMqpB,EAAmB,IAAM9K,UAAUG,GACzC,IAAK2K,EACH,MAAM,IAAI3oB,MACR,4DAA4Dge,qBAIhE,IAAI,SAAE3L,GAAa/S,EACnB,MAAM,aAAEyV,GAAiBzV,OAERgD,IAAb+P,IACFA,GAAW,IAAAwR,WAGb,MAAM,SAAExjB,EAAQ,WAAEpB,EAAU,QAAEC,EAAO,OAAEb,EAAM,UAAEW,GAAc2pB,EAEvDC,EADaD,EAAiB5lB,gBACJZ,QAE1B,iBAAE0mB,EAAgB,SAAE7J,GAAa8J,EACrC/T,EACA6T,GAIIZ,EAAc,sBAAyB,CAC3C1b,KAAM,SACN8a,mBAAoB,EACpBxb,OAAQid,IAGJE,EAAmB,mBAEzBA,EAAiB1B,cAAcpoB,GAC/B8pB,EAAiBzB,WAAWpoB,GAC5B6pB,EAAiBxB,aAAavoB,GAC9B+pB,EAAiBvB,UAAUnpB,GAC3B0qB,EAAiBjW,eAAemV,WAAWD,GAE3C,MAAMgB,EAAgB,IAAI,IAAY,CACpC3W,WACAhS,SAAU,IAAUA,GACpBpB,WAAY,CAACA,EAAW,GAAIA,EAAW,GAAIA,EAAW,IACtDC,UACAb,SACAW,YACAqE,UAAW0lB,EACX/lB,WAAY6lB,EACZ3K,YAAac,EACb3f,SAAU,GACV2e,uBAGI3B,EAAmB,CACvBmC,QAAS7d,QAAQC,QAAQooB,IAK3B,aAFM,IAAMxI,oBAAoBnO,EAAUgK,GAEnC2M,CACT,CAYO,SAASC,EACd3pB,EACA+S,EACAuR,GAAe,GAEf,MAAM,SAAEvjB,EAAQ,WAAEpB,EAAU,QAAEC,EAAO,OAAEb,EAAM,UAAEW,EAAS,aAAE+V,GACxDzV,EAEF,IAAI,WAAE0D,GAAe1D,EAGrB,MAAM4pB,EAAiB,CACrB,aACA,eACA,cACA,cAGIN,EAAe3pB,EAAW,GAAKA,EAAW,GAAKA,EAAW,GAGhE,IAAK+D,IAAekmB,EAAe3J,SAASvc,EAAWhM,YAAYsV,MAAO,CAExE,IAAKyI,GAAcC,OAASkU,EAAe3J,SAASxK,EAAaC,MAC/D,MAAM,IAAIhV,MACR,qIAKD6oB,iBAAkB7lB,GAAe8lB,EAClC/T,EACA6T,GAEJ,MAGiBtmB,IAAb+P,IACFA,GAAW,IAAAwR,WAGb,MAAMzH,EAAe,IAAMyB,UAAUxL,GAErC,GAAI+J,EACF,OAAOA,EAGT,MAAM4C,EAAWhc,EAAaA,EAAWyS,OAAOrB,WAA4B,EAAfwU,EAI7D,IADoB,IAAMlN,YAAYsD,GAEpC,MAAM,IAAIhf,MAAM,IAAO2f,qBAGzB,MAAMqI,EAAc,sBAAyB,CAC3C1b,KAAM,SACN8a,mBAAoB,EACpBxb,OAAQ5I,IAGJK,EAAY,mBAElBA,EAAUgkB,cAAcpoB,GACxBoE,EAAUikB,WAAWpoB,GACrBmE,EAAUkkB,aAAavoB,GACvBqE,EAAUmkB,UAAUnpB,GACpBgF,EAAUyP,eAAemV,WAAWD,GAEpC,MAAMgB,EAAgB,IAAI,IAAY,CACpC3W,WACAhS,SAAU,IAAUA,GACpBpB,WAAY,CAACA,EAAW,GAAIA,EAAW,GAAIA,EAAW,IACtDC,UACAb,SACAW,YACAqE,UAAWA,EACXL,aACAkb,YAAac,EACb5J,mBAAoB9V,EAAQ8V,oBAAsB,GAClD4I,mBAAoB1e,EAAQ0e,mBAC5B3e,SAAUC,EAAQD,UAAY,KAGhC,GAAIukB,EACF,OAAOoF,EAGT,MAAM3M,EAAmB,CACvBmC,QAAS7d,QAAQC,QAAQooB,IAI3B,OAFA,IAAMxI,oBAAoBnO,EAAUgK,GAE7B2M,CACT,CAEO1f,eAAe6f,EACpB9W,EACAhT,EACAC,EAGI,CAAC,GAEL,MAAM,aAAEskB,GAAe,GAAUtkB,EAEjC,QAAiBgD,IAAbjD,EACF,MAAM,IAAIW,MACR,4EAIJ,QAAiBsC,IAAb+P,EACF,MAAM,IAAIrS,MACR,4EAIJ,MAAMoc,EAAe,IAAMyB,UAAUxL,GAErC,GAAI+J,EACF,OAAOzb,QAAQC,QAAQwb,GAGzB,MAAMgN,GAAc,IAAAC,iCAAgChqB,EAAUgT,GAOxDiX,EAAgBF,EAAY/pB,SAASzE,KAAI,CAAC8C,EAASqW,IAC/B,IAAM8L,mBAAmBniB,GAE1B8gB,QAAQ/d,MAAMhD,IACnC,MAAMqjB,EAAYrjB,EAAM+X,eAClBoL,EAAS7M,EAAetW,EAAMS,KAAOT,EAAMU,QAEhDirB,EAAYpmB,WAAmC4S,IAAIkL,EAAWF,EAAO,YAIpEjgB,QAAQkJ,IAAIyf,GAElB,MAAMhN,EAAS,IAAI,IAAY,IAC1B8M,EACHhU,mBAAoB/V,KACjBC,KAML,IAAAiqB,mCAAkCjN,GAElC,MAAMD,EAAmB,CACvBmC,QAAS7d,QAAQC,QAAQ0b,IAG3B,OAAIsH,GAIJ,IAAMpD,oBAAoBnO,EAAUgK,GAH3BA,EAAiBmC,OAM5B,CAQO,SAASgL,EACdzG,EACA0G,GAEAtB,EAAcpF,GAAU0G,CAC1B,CAGO,SAASC,IACd,OAAOxlB,OAAOyU,KAAKwP,EACrB,CASO,SAASwB,EACdF,GAEA,MAAMG,EAAkBxB,EAIxB,OAFAA,EAAsBqB,EAEfG,CACT,CAEO,SAASC,IACd,OAAOzB,EAAoB9b,IAC7B,CAWOhD,eAAewgB,EACpB9L,EACA1e,EAAU,CAAC,GAEX,OAAOopB,EAA4B1K,EAAoB,IAClD1e,EACHyV,aAAc,CACZC,KAAM,eAGZ,CAUO1L,eAAeygB,EACpBzqB,EACA+S,EACAuR,GAAe,GAQf,OANKtkB,EAAQ0D,aACX1D,EAAQ0D,WAAa,IAAIyiB,WACvBnmB,EAAQL,WAAW,GAAKK,EAAQL,WAAW,GAAKK,EAAQL,WAAW,KAIhEgqB,EAAkB3pB,EAAS+S,EAAUuR,EAC9C,CAaA,SAASkF,EACP/T,EAIA6T,GAEA,MAAM,iBAAEoB,IAAqB,UAAmBC,WAE1C,sBAAEhG,EAAqB,SAAEjF,IAAa,IAAAkF,wBAC1CnP,GAAcC,KACd4T,EACA,CACEsB,gBAAiBF,EACjBG,gBAAgB,IAKpB,IADoB,IAAMzO,YAAYsD,GAEpC,MAAM,IAAIhf,MAAM,IAAO2f,qBAGzB,IAAIkJ,EACJ,GAAI9T,GAAcqV,oBAAqB,UACrC,OAAQrV,EAAaC,MACnB,IAAK,eACH6T,GAAmB,IAAAwB,0BAAyBzB,GAC5C,MACF,IAAK,aACHC,GAAmB,IAAAyB,wBAAuB1B,GAC1C,MACF,IAAK,cAGL,IAAK,aACHC,GAAmB,IAAA0B,yBAAwB3B,GAC3C,MACF,QACE,MAAM,IAAI5oB,MACR,0GAIN6oB,EAAmB,IAAI5E,EAAsB2E,GAG/C,MAAO,CAAEC,mBAAkB7J,WAC7B,2EC3nBA,MAAMwL,EAAuB,IAAI,IAAmB,iBAEpDA,EAAqBC,UAAY,EAEjCD,EAAqBE,2BAA2B,IAAYC,YAAa,KACzEH,EAAqBE,2BAA2B,IAAYE,UAAW,KACvEJ,EAAqBE,2BAA2B,IAAYhX,SAAU,KAEtE,mFC8BA,MAAMmX,EA0BJ,WAAA7zB,CAAY6E,GAtBJ,KAAAivB,YAAc,CACpBC,YAAa,EACbC,UAAW,EACXC,SAAU,EACVC,QAAS,GAmBT7yB,KAAKwD,GAAKA,IAAU,IAAAgoB,UAEpBxrB,KAAK6tB,YAAc,CACjB6E,YAAa,CAAE,EAAG,IAClBC,UAAW,CAAE,EAAG,IAChBC,SAAU,CAAE,EAAG,IACfC,QAAS,CAAE,EAAG,KAGhB7yB,KAAKoyB,UAAY,EACjBpyB,KAAK8yB,OAAQ,EAEb9yB,KAAKyyB,YAAc,CACjBC,YAAa,EACbC,UAAW,EACXC,SAAU,EACVC,QAAS,GAGX7yB,KAAK+yB,eAAiB,CACpBL,YAAa,EACbC,UAAW,EACXC,SAAU,EAOVC,QAAS,IAEb,CASO,0BAAAR,CACL1V,EACAoW,GAEA/yB,KAAK+yB,eAAepW,GAAQoW,CAC9B,CAOO,0BAAAC,CAA2BrW,GAChC,OAAO3c,KAAK+yB,eAAepW,EAC7B,CAMO,OAAAsW,GACDjzB,KAAKkzB,eACP1qB,OAAO2qB,aAAanzB,KAAKkzB,cAE7B,CAcO,UAAAE,CACLC,EACA1W,EACA+Q,EACA9Q,EAAW,GAGX,MAAM0W,EAA0C,CAC9CD,YACA1W,OACA+Q,0BAIuCzjB,IAArCjK,KAAK6tB,YAAYlR,GAAMC,KACzB5c,KAAK6tB,YAAYlR,GAAMC,GAAY,IAIrC5c,KAAK6tB,YAAYlR,GAAMC,GAAUhM,KAAK0iB,GAEtCtzB,KAAKuzB,eACP,CAQO,cAAA9F,CACL+F,GAEA3nB,OAAOyU,KAAKtgB,KAAK6tB,aAAatd,SAASoM,IACrC,MAAME,EAAc7c,KAAK6tB,YAAYlR,GACrC9Q,OAAOyU,KAAKzD,GAAatM,SAASqM,IAChCC,EAAYD,GAAYC,EAAYD,GAAUpP,QAC3C8lB,GACQE,EAAeF,IAEzB,GACD,GAEN,CASO,iBAAAnF,CAAkBxR,GACvB,IAAK3c,KAAK6tB,YAAYlR,GACpB,MAAM,IAAIhV,MAAM,4BAA4BgV,WAE9C3c,KAAK6tB,YAAYlR,GAAQ,CAAE,EAAG,GAChC,CAEQ,YAAA8W,CAAa9W,GACnB,MAAM+W,EAAiB1zB,KAAK+yB,eAAepW,GAAQ3c,KAAKyyB,YAAY9V,GACpE,IAAIgX,EAAiB,EAErB,IAAK,IAAI3qB,EAAI,EAAGA,EAAI0qB,EAAgB1qB,IAAK,CACvC,MAAMsqB,EAAiBtzB,KAAK4zB,eAAejX,GAC3C,GAAuB,OAAnB2W,EACF,OAAO,EACF,GAAIA,EAAgB,CAIzB,IAAIO,EAHJ7zB,KAAKyyB,YAAY9V,KACjB3c,KAAK8yB,OAAQ,EAGb,IACEe,EAAgBP,EAAeD,WACjC,CAAE,MAAOlqB,GAEPkI,QAAQC,KAAK,qBAAsBnI,EACrC,CACI0qB,GAAeC,QACjBD,EAAcC,SAAQ,KACpB9zB,KAAKyyB,YAAY9V,KACjB3c,KAAK+zB,YAAY,KAInB/zB,KAAKyyB,YAAY9V,KACjBgX,IAEJ,CACF,CAKA,OAJIA,GACF3zB,KAAK+zB,cAGA,CACT,CAEQ,cAAAH,CAAejX,GACrB,MAAMqX,EAAwBh0B,KAAKi0B,wBAAwBtX,GAC3D,IAAK,MAAMC,KAAYoX,EACrB,GAAIh0B,KAAK6tB,YAAYlR,GAAMC,GAAU9S,OACnC,OAAO9J,KAAK6tB,YAAYlR,GAAMC,GAAUhF,QAI5C,OAAO,IACT,CAEU,aAAA2b,GACR,MAAMW,EAAkCl0B,KAAKyzB,aAC3C,IAAYnB,aAER6B,EAAgCn0B,KAAKyzB,aACzC,IAAYlB,WAER6B,EAA+Bp0B,KAAKyzB,aACxC,IAAYpY,UAERgZ,EAA8Br0B,KAAKyzB,aAAa,IAAYa,SAG/DJ,GACAC,GACAC,GACAC,IAEDr0B,KAAK8yB,OAAQ,EAEjB,CAEU,UAAAiB,GACH/zB,KAAK8yB,aAIa7oB,IAAnBjK,KAAKoyB,UAIFpyB,KAAKkzB,gBACRlzB,KAAKkzB,cAAgB1qB,OAAOC,YAAW,KACrCzI,KAAKkzB,cAAgB,KACrBlzB,KAAKuzB,eAAe,GACnBvzB,KAAKoyB,YAGVpyB,KAAKuzB,gBAET,CAEU,uBAAAU,CAAwBtX,GAKhC,OAJmB9Q,OAAOyU,KAAKtgB,KAAK6tB,YAAYlR,IAC7Cpa,IAAIqM,QACJpB,QAAQoP,GAAa5c,KAAK6tB,YAAYlR,GAAMC,GAAU9S,SACtD4J,MAAK,CAACZ,EAAGC,IAAMD,EAAIC,GAExB,CASA,cAAA+a,GACE,OAAO9tB,KAAK6tB,WACd,kLC3UK,SAASoC,EAAoCjW,GAClD,MAAM,wBAAEua,IAA4B,UAC9BC,GAAe,UAEOD,GAA2BC,GAKvD,IAAYC,qBACV,EAAAzZ,OAAO0Z,gCACNlrB,IACC,GAAIA,EAAImrB,OAAO3a,WAAaA,EAC1B,OAKFkX,EAFe,KAAM1L,UAAUxL,GAEU,GAG/C,CAQO,SAASkX,EAAkCjN,GAChD,KAAMA,aAAkB,MACtB,OAGF,MAAMtZ,EAAasZ,EAAOvZ,gBAE1BuZ,EAAOoE,oBAAoBC,KAAO,EAcpC,SAAqCrE,EAAQtZ,GAC3CsZ,EAAOoE,oBAAoB9X,SAAQ,EAAGgY,UAAUljB,KAC9C,MAAMD,EAAQ,KAAMqL,SAASpL,GACxBD,IAILwvB,EAA+BxvB,EAAOuF,EAAY4d,GAClD,KAAMhC,wBAAwBnhB,EAAMygB,aAAY,GAEpD,CAvBMgP,CAA4B5Q,EAAQtZ,GAkC1C,SAA8BsZ,EAAQtZ,GACpC,IAAImqB,EAAuBnqB,EAE3B,MAAMoqB,EAAyB9Q,EAAOjd,SAASkhB,MAAM7iB,GACrC,KAAMoL,SAASpL,KAI/B,IAAK0vB,EACH,OAGF,MAAMC,EAAc,KAAMvkB,SAASskB,GAC7BE,EACJD,EAAYtM,YAAYD,WAAauM,EAAY7X,eAG/CxS,EAAWhM,cAAgBs2B,EAAgBt2B,cAE7Cm2B,EAAuB,IAAIG,EAAgBt2B,YAAYgM,EAAWb,QAGlEgrB,EAAqBvX,IAAI5S,IAG3BsZ,EAAOjd,SAASuJ,SAASlL,IACvB,MAAMD,EAAQ,KAAMqL,SAASpL,GAC7B,IAAKD,EACH,OAGF,MACMmjB,EADQtE,EAAOiR,gBAAgB7vB,GACdD,EAAM+X,eAAepB,WAE5C6Y,EAA+BxvB,EAAO0vB,EAAsBvM,GAC5D,KAAMhC,wBAAwBnhB,EAAMygB,YAAY,GAEpD,CAtEMsP,CAAqBlR,EAAQtZ,EACnC,CAuEA,SAASiqB,EAA+BxvB,EAAOuF,EAAY4d,GACzD,MAAME,EAAYrjB,EAAMsjB,WACpBtjB,EAAMsjB,WAAWD,UACjBrjB,EAAM+X,eAEJiY,EAAO,IAAI3M,EAAU9pB,YACzBgM,EAAWyS,OACXmL,EACAE,EAAU3e,QAGZ1E,EAAM+X,aAAe,IAAMiY,EAEvBhwB,EAAMsjB,aACRtjB,EAAMsjB,WAAWD,UAAY2M,GAG/BhwB,EAAMujB,WAAa,CACjBvL,OAAQzS,EAAWyS,OACnBmL,SAEJ,+KC1IA,MAAM8M,EAAa,IAAIzS,IAOvB,SAAS0S,EAAiBthB,GACxBqhB,EAAW9X,IAAIvJ,EAASuhB,KAAMvhB,EAChC,CAOA,SAASF,EAAYG,GACnB,OAAOohB,EAAWtpB,IAAIkI,EACxB,CAOA,SAASuhB,IACP,OAAOluB,MAAM6Z,KAAKkU,EAAW/U,OAC/B,CAQA,SAASmV,EAAqBC,EAAWxyB,GACvC,MAAMyyB,EAAe,IAAaC,eAAerzB,KAAKszB,GACpD,IAAaC,gBAAgBD,KAGzBE,EAAgBP,IAAmBjzB,KAAKyzB,GAC5CliB,EAAYkiB,KAMRC,EAHYN,EAAaO,OAAOH,GAGJ7N,MAAMlU,IACtC,MAAQmiB,UAAWC,GAAoBpiB,EAEvC,GAAIoiB,EAAgBtsB,SAAW4rB,EAAU5rB,OACvC,OAAO,EAGT,IAAK,IAAId,EAAI,EAAGA,EAAIotB,EAAgBtsB,OAAQd,GAAK,EAC/C,KACG,QACCotB,EAAgBxW,MAAM5W,EAAI,EAAGA,EAAI,GACjC0sB,EAAU9V,MAAM5W,EAAI,EAAGA,EAAI,IAG7B,OAAO,EAIX,OAAO,CAAI,IAGb,IAAKitB,EACH,OAAO,KAGT,MAAMI,EAAU,GAChB,IAAI,OAASnzB,EAAO,aAAc,CAChC,MAAMozB,EAAgBpzB,EACnB0X,cACA2b,iBAAiB,GACjBC,iBAEH,IAAKF,EACH,MAAO,CACLriB,KAAMgiB,EAAgBV,MAI1B,IAAK,IAAIvsB,EAAI,EAAGA,EAAIstB,EAAcxsB,OAAQd,GAAK,EAC7CqtB,EAAQzlB,KAAK,CACX0O,MAAOgX,EAActtB,GACrBqtB,QAASC,EAActtB,EAAI,IAGjC,CAEA,MAAO,CACLiL,KAAMgiB,EAAgBV,KACtBc,UAEJ,+DCpGe,SAASI,EACtB72B,GAEA,MAAM82B,EAAO,mBACb,IAAI72B,EAAQ,EACRC,EAAQ,KAYZ,OAVEF,QACmBqK,IAAnBrK,EAASC,YACUoK,IAAnBrK,EAASE,QAETD,EAAQD,EAASC,MACjBC,EAAQF,EAASE,OAEnB42B,EAAKC,YAAY92B,EAAO,EAAK,EAAK,GAClC62B,EAAKC,YAAY72B,EAAO,EAAK,EAAK,GAE3B42B,CACT,wNCuCA,QAlDA,SACEjzB,GAEA,MAAMiK,EAASjK,EAASuL,aAElB,yBAAE4nB,EAAwB,YAAE1c,IAChC,OAAqCzW,EAAUiK,GAEjD,IAAKwM,EACH,OAGF,MAAM,gBAAE9K,EAAe,WAAEzB,GAAeD,EAElCmpB,EAAapzB,EAChBN,YACA+kB,MACEpV,GACCA,EAAEgkB,cAAgB5c,EAAYF,UAAYlH,EAAEjC,MAAQqJ,EAAYF,WAGjE6c,GACHxlB,QAAQC,KAAK,sCAAuC4I,EAAYF,UAGlE,MAAMO,EAAcsc,EAAW3zB,MACzB6zB,GAAa,OAAcxc,EAAanL,EAAiBzB,IAEzD,IAAE4J,EAAG,IAAErK,EAAG,QAAEwU,GAAYqV,EAGxBC,EAAiBp2B,KAAKC,OAAOqM,EAAMqK,GAAOqf,GAA4B,EAG5E,IAAIK,GAAevV,EAAUnK,IAAQrK,EAAMqK,GAAQyf,EAUnD,OATAC,EAAar2B,KAAK6O,MAAMwnB,GAGpBA,EAAaD,EAAiB,EAChCC,EAAaD,EAAiB,EACrBC,EAAa,IACtBA,EAAa,GAGR,CACLD,iBACAC,aAEJ,gCC1DA,SAASC,EAAyBC,GAChC,MAAM7O,EAAO6O,EAAiBC,UACxB7jB,EAAS,GACf,IAAK,IAAIhH,EAAQ,EAAGA,EAAQ+b,EAAM/b,IAAS,CACzC,MAAM8qB,EAAa,GAEnBF,EAAiBG,aAAa/qB,EAAO8qB,GAErC9jB,EAAO3C,KAAKymB,EACd,CAEA,OAAO9jB,CACT,CAEA,SAASgkB,EAAyBJ,EAAkBK,GAC7CA,GAAO1tB,SAIZqtB,EAAiBM,kBAEjBD,EAAMjnB,SAASmnB,IACbP,EAAiBR,eAAee,EAAK,IAEzC,6GCde,SAASC,EAAsB3sB,EAAWhJ,GAIvD,OAHwBgJ,EAAUI,aAAapJ,GACjBO,IAAI3B,KAAKC,MAGzC,gFCOe,SAASwC,EACtBu0B,EAAkB,IAClBjb,EACAgY,EAAkB,MAElB,IAAKhY,EACH,MAAM,IAAIhV,MAAM,8BAGlB,MAAMkwB,EAAQ,IAAIC,YAAYnb,EAAM,CAClCgY,SACAoD,YAAY,IAGd,OAAOH,EAAGI,cAAcH,EAC1B,qFCwNA,QAzPA,MACE,WAAAl5B,GACEqB,KAAKi4B,eAAiB,CAAC,EACvBj4B,KAAKk4B,kBAAoB,IAAI,IAAmB,YAClD,CAcA,cAAAC,CAAeC,EAAYC,EAAUpxB,EAAU,CAAC,GAC9C,MAAM,mBACJqxB,EAAqB,EAAC,UACtBC,GAAY,EAAK,oBACjBC,EAAsB,CACpB1b,SAAS,EACT2b,kBAAmB,MAEnBxxB,EAEJ,GAAIjH,KAAKi4B,eAAeG,KAAgBG,EAEtC,YADAlnB,QAAQC,KAAK,gBAAgB8mB,+BAI3BG,GAAav4B,KAAKi4B,eAAeG,IAAaM,qBAChDC,cAAc34B,KAAKi4B,eAAeG,GAAYM,qBAGhD,MAAME,EAAmB,CACvBP,SAAU,KACVQ,UAAW,GACXC,aAAc,GACdC,eAAgB,GAEhBC,cAAe,GAEfR,oBAAqBA,EAAoB1b,QACzC4b,oBAAqB,KACrBD,kBAAmBD,EAAoBC,mBAGzCG,EAAiBE,aAAexxB,MAAMgxB,GAAoBW,KAAK,GAC/DL,EAAiBG,eAAiBzxB,MAAMgxB,GAAoBW,KAAK,MAEjE,IAAK,IAAIjwB,EAAI,EAAGA,EAAIsvB,EAAoBtvB,IAAK,CAC3C,MAAMkwB,EAASb,IACfO,EAAiBC,UAAUjoB,KAAK,KAAasoB,IAC7CN,EAAiBI,cAAcpoB,KAAKsoB,GACpCN,EAAiBP,SAAWA,CAC9B,CAEAr4B,KAAKi4B,eAAeG,GAAcQ,CACpC,CAEA,gBAAAO,CAAiBf,GACf,MAAMQ,EAAmB54B,KAAKi4B,eAAeG,GAE7C,IAAKQ,EAEH,OADAvnB,QAAQiV,MAAM,gBAAgB8R,yBACvB,KAIT,MAAMgB,EAAkBR,EAAiBC,UAAUrrB,QAChD6rB,GAA0B,OAAbA,IAGhB,IAAIC,EAAe,EACfC,EAAeX,EAAiBE,aAAa,IAAM,EACvD,IAAK,IAAI9vB,EAAI,EAAGA,EAAIowB,EAAgBtvB,OAAQd,IAAK,CAC/C,MAAMwwB,EAAmBZ,EAAiBE,aAAa9vB,IAAM,EACzDwwB,EAAmBD,IACrBD,EAAetwB,EACfuwB,EAAeC,EAEnB,CAGA,GAAiD,OAA7CZ,EAAiBC,UAAUS,GAAwB,CACrD,MAAMJ,EAASN,EAAiBP,WAChCO,EAAiBC,UAAUS,GAAgB,KAAaJ,GACxDN,EAAiBI,cAAcM,GAAgBJ,CACjD,CAMA,OAHAN,EAAiBE,aAAaQ,IAAiB,EAGxC,CACLG,IAAKb,EAAiBC,UAAUS,GAChC/sB,MAAO+sB,EAEX,CAkBA,WAAAI,CACEtB,EACAuB,EACAC,EAAO,CAAC,GACR,YACE/c,EAAc,EAAAzB,YAAYkZ,QAAO,SACjC1X,EAAW,EAAC,QACZ3V,EAAU,CAAC,EAAC,UACZ4yB,EAAY,IACV,CAAC,GAEL,OAAO,IAAIvxB,SAAQ,CAACC,EAASuxB,KA6D3B95B,KAAKk4B,kBAAkB9E,YA5DLniB,UAChB,MAAM,IAAEwoB,EAAG,MAAEltB,GAAUvM,KAAKm5B,iBAAiBf,GAC7C,IAAKqB,EAAK,CACR,MAAMnT,EAAQ,IAAI3e,MAChB,qCAAqCywB,MAIvC,OAFA/mB,QAAQiV,MAAMA,QACdwT,EAAOxT,EAET,CAEA,IAGE,IAAIyT,EAAiB,GACjBF,EAAU/vB,SACZiwB,EAAiBF,EAAUt3B,KAAKy3B,GACvB,KAAcA,MAGzB,MAAMpB,EAAmB54B,KAAKi4B,eAAeG,GAE7CQ,EAAiBqB,YAAa,EAE9B,MAAMC,QAAgBT,EAAIE,GAAYC,KAASG,GAE/CnB,EAAiBqB,YAAa,EAC9BrB,EAAiBG,eAAexsB,GAASyY,KAAKC,MAI5C2T,EAAiBJ,sBAChBI,EAAiBF,qBAClBE,EAAiBH,oBAEjBG,EAAiBF,oBAAsByB,aAAY,KACjDn6B,KAAKo6B,qBACHhC,EACAQ,EAAiBH,kBAClB,GACAG,EAAiBH,oBAGtBlwB,EAAQ2xB,EACV,CAAE,MAAO9O,GACP/Z,QAAQiV,MACN,2BAA2BqT,iBAA0BvB,MACrDhN,GAEF0O,EAAO1O,EACT,SACEprB,KAAKi4B,eAAeG,GAAYU,aAAavsB,IAC/C,IAUAsQ,EACA5V,EACA2V,EACD,GAEL,CAEA,oBAAAwd,CAAqBhC,EAAYK,GAC/B,MAAMG,EAAmB54B,KAAKi4B,eAAeG,GAE7C,GAAIQ,EAAiBqB,WACnB,OAGF,MAAMhV,EAAMD,KAAKC,MAEjB2T,EAAiBC,UAAUtoB,SAAQ,CAAC8pB,EAAG9tB,KACrC,MAAMwsB,EAAiBH,EAAiBG,eAAexsB,KAElC,OAAnBwsB,GAA2BH,EAAiBE,aAAavsB,GAAS,IACnD0Y,EAAM8T,EAEWN,GAChCz4B,KAAKs6B,wBAAwBlC,EAAY7rB,EAC3C,GAEJ,CAEA,SAAAguB,CAAUnC,GACR,MAAMQ,EAAmB54B,KAAKi4B,eAAeG,GACxCQ,EAKLA,EAAiBC,UAAUtoB,SAAQ,CAAC8pB,EAAG9tB,KACrCvM,KAAKs6B,wBAAwBlC,EAAY7rB,EAAM,IAL/C8E,QAAQiV,MAAM,gBAAgB8R,wBAOlC,CAGA,uBAAAkC,CAAwBlC,EAAY7rB,GAClC,MAAMqsB,EAAmB54B,KAAKi4B,eAAeG,GACvCoC,EAAiB5B,EAAiBC,UAAUtsB,GAE3B,OAAnBiuB,IACFA,EAAe,QACf5B,EAAiBI,cAAczsB,GAAOguB,YAGtC3B,EAAiBC,UAAUtsB,GAAS,KACpCqsB,EAAiBG,eAAexsB,GAAS,KAE7C,4DCpPF,MAAMkuB,EAA4B,CAChCC,YAAa,GACbC,SAAU,GACVC,QAAS,CACPnoB,EAAG,GACH0E,EAAG,IAEL0jB,WAAY,CACVpoB,EAAG,EACH0E,EAAG,GAEL2jB,wBAAyB,gHAMrBC,EAAiC,CACrCtoB,EAAG,IACH0E,EAAG,IAGC6jB,EAAa,gFAIbC,EAAY,0JAKZC,EAAe,2iBACfC,EAAiB,+HACjBC,EAAc,+MAEdC,EAAiD,CACrDC,MAAOpd,EAAOuc,EAAM,CAClBC,YAAa,uMAGbE,QAAS,CACPnoB,EAAG,KACH0E,EAAG,QAGPokB,cAAerd,EAAOuc,EAAM,CAC1BC,YAAa,+NAGbE,QAAS,CACPnoB,EAAG,GACH0E,EAAG,MAGPqkB,cAAetd,EAAOuc,EAAM,CAC1BC,YAAa,i0BAQbE,QAAS,CACPnoB,EAAG,GACH0E,EAAG,MAGPskB,UAAWvd,EAAOuc,EAAM,CACtBC,YAAa,gVAQbE,QAAS,CACPnoB,EAAG,GACH0E,EAAG,MAGPukB,UAAWxd,EAAOuc,EAAM,CACtBC,YAAa,oFACbE,QAAS,CACPnoB,EAAG,GACH0E,EAAG,MAGPwkB,cAAezd,EAAOuc,EAAM,CAC1BC,YAAa,sNAGbE,QAAS,CACPnoB,EAAG,GACH0E,EAAG,MAGPykB,YAAa1d,EAAOuc,EAAM,CACxBC,YAAa,w8EAgCbE,QAAS,CACPnoB,EAAG,GACH0E,EAAG,MAGP0kB,oBAAqB3d,EAAOuc,EAAM,CAChCC,YAAa,usFAkCbE,QAAS,CACPnoB,EAAG,GACH0E,EAAG,MAGP2kB,OAAQ5d,EAAOuc,EAAM,CACnBC,YAAa,oOAGbE,QAAS,CACPnoB,EAAG,GACH0E,EAAG,MAGP4kB,MAAO7d,EAAOuc,EAAM,CAClBC,YAAa,wXAKbE,QAAS,CACPnoB,EAAG,KACH0E,EAAG,QAGP6kB,aAAc9d,EAAOuc,EAAM,CACzBC,YAAa,ySAIbE,QAAS,CACPnoB,EAAG,KACH0E,EAAG,QAGP8kB,WAAY/d,EAAOuc,EAAM,CACvBC,YAAa,6oBASbE,QAAS,CACPnoB,EAAG,KACH0E,EAAG,QAGP+kB,WAAYhe,EAAOuc,EAAM,CACvBC,YAAa,+uBAWbE,QAAS,CACPnoB,EAAG,KACH0E,EAAG,QAGPglB,OAAQje,EAAOuc,EAAM,CACnBC,YAAa,sSAIbE,QAAS,CACPnoB,EAAG,KACH0E,EAAG,QAGPilB,QAASle,EAAOuc,EAAM,CACpBC,YAAa,4XAKbE,QAAS,CACPnoB,EAAG,IACH0E,EAAG,OAGPklB,IAAKne,EAAOuc,EAAM,CAChBC,YAAa,ggBAObE,QAAS,CACPnoB,EAAG,KACH0E,EAAG,QAGPmlB,OAAQpe,EAAOuc,EAAM,CACnBC,YAAa,+dAObE,QAAS,CACPnoB,EAAG,KACH0E,EAAG,QAGPolB,YAAare,EAAOuc,EAAM,CACxBC,YAAa,gWAKbE,QAAS,CACPnoB,EAAG,GACH0E,EAAG,MAGPqlB,kBAAmBte,EAAOuc,EAAM,CAC9BC,YAAa,0LAGbE,QAAS,CACPnoB,EAAG,KACH0E,EAAG,QAGPslB,YAAave,EAAOuc,EAAM,CACxBC,YAAa,oLAGbE,QAAS,CACPnoB,EAAG,GACH0E,EAAG,MAGPulB,KAAMxe,EAAOuc,EAAM,CACjBC,YAAa,srBAUbE,QAAS,CACPnoB,EAAG,IACH0E,EAAG,OAQPwlB,gCAAiCze,EAAOuc,EAAM,CAC5CC,YAAa,GAAGQ,KAAgBF,IAChCJ,QAASG,IAGX6B,+BAAgC1e,EAAOuc,EAAM,CAC3CC,YAAa,GAAGQ,KAAgBD,IAChCL,QAASG,IAGX8B,iCAAkC3e,EAAOuc,EAAM,CAC7CC,YAAa,GAAGQ,KAAgBF,IAChCJ,QAASG,IAGX+B,gCAAiC5e,EAAOuc,EAAM,CAC5CC,YAAa,GAAGQ,KAAgBD,IAChCL,QAASG,IAGXgC,iCAAkC7e,EAAOuc,EAAM,CAC7CC,YAAa,GAAGS,KAAkBH,IAClCJ,QAASG,IAIXiC,iBAAkB9e,EAAOuc,EAAM,CAC7BC,YAAa,GAAGS,KAAkBF,IAClCL,QAASG,IAGX,+BAAgC7c,EAAOuc,EAAM,CAC3CC,YAAa,GAAGS,KAAkBF,IAClCL,QAASG,IAGX,gCAAiC7c,EAAOuc,EAAM,CAC5CC,YAAa,GAAGS,KAAkBF,IAClCL,QAASG,IAGX,iCAAkC7c,EAAOuc,EAAM,CAC7CC,YAAa,GAAGS,KAAkBH,IAClCJ,QAASG,IAGX,gCAAiC7c,EAAOuc,EAAM,CAC5CC,YAAa,GAAGS,KAAkBH,IAClCJ,QAASG,IAGXkC,cAAe/e,EAAOuc,EAAM,CAC1BC,YAAa,GAAGU,KAAeH,IAC/BL,QAASG,IAGX,4BAA6B7c,EAAOuc,EAAM,CACxCC,YAAa,GAAGU,KAAeH,IAC/BL,QAASG,IAGX,8BAA+B7c,EAAOuc,EAAM,CAC1CC,YAAa,GAAGU,KAAeJ,IAC/BJ,QAASG,IAGX,6BAA8B7c,EAAOuc,EAAM,CACzCC,YAAa,GAAGU,KAAeH,IAC/BL,QAASG,KAQb,SAAS7c,EACPgB,EACA3L,GAEA,OAAO1H,OAAOyS,OAAOzS,OAAOuT,OAAOF,GAAO3L,EAC5C,CAqBA,SAAS2pB,EACPjpB,GAEA,OAAOonB,EAAUpnB,EACnB,CAKA,MAAMkpB,EAAiBtxB,OAAOyU,KAAK+a,4EChcnC,MAAM+B,EAAmB,mBA4CzB,SAASC,EAAWC,EAAYC,GAE9B,GAAK,KAAMC,aAAaF,GAIxB,OAAI,KAAME,aAAaF,GAAYC,GAC1B,KAAMC,aAAaF,GAAYC,GAAUE,YADlD,CAGF,CAEA,SAASC,EAAWC,EAAiBL,EAAYM,EAASL,GAExD,IAAK,KAAMC,aAAaF,GACtB,OAAO,KAGT,KAAME,aAAaF,GAAYC,GAAY,CACzCM,SAAS,EACTJ,OAAQG,GAGVD,EAAgBG,YAAYF,EAC9B,CAEA,SAASG,EAAeT,EAAYC,GAE7B,KAAMC,aAAaF,IAIpB,KAAME,aAAaF,GAAYC,KACjC,KAAMC,aAAaF,GAAYC,GAAUM,SAAU,EAEvD,CAEA,SAASG,EAAeL,EAAiBL,GAElC,KAAME,aAAaF,IAIxBzxB,OAAOyU,KAAK,KAAMkd,aAAaF,IAAa/sB,SAASgtB,IACnD,MAAMU,EAAa,KAAMT,aAAaF,GAAYC,IAE7CU,EAAWJ,SAAWI,EAAWR,SACpCE,EAAgBO,YAAYD,EAAWR,eAChC,KAAMD,aAAaF,GAAYC,GACxC,GAEJ,CAEA,QAzFA,SAA6Bx+B,GAC3B,MAAM+W,GAAiB,IAAA6T,mBAAkB5qB,IACnC,WAAEwE,EAAU,kBAAEG,GAAsBoS,EACpCwnB,EAAa,GAAG/5B,KAAcG,IAC9Bi6B,EAsBR,SAAsB5+B,GACpB,MAAMo/B,EAAkB,IAAIf,IACtBgB,EAAqBr/B,EAAQs/B,cAAcF,GAMjD,OAFiBC,EAAmBC,cAAc,sBAGpD,CA/B0BC,CAAav/B,GAOrC,OAJA8M,OAAOyU,KAAK,KAAMkd,aAAaF,IAAa/sB,SAASgtB,IACnD,KAAMC,aAAaF,GAAYC,GAAUM,SAAU,CAAK,IAGnD,CACLF,gBAAiBA,EACjBY,sBAAuB,KAAMf,aAC7BH,WAAYA,EAAWmB,KAAKx+B,KAAMs9B,GAClCI,WAAYA,EAAWc,KAAKx+B,KAAM29B,EAAiBL,GACnDS,eAAgBA,EAAeS,KAAKx+B,KAAMs9B,GAC1CU,eAAgBA,EAAeQ,KAAKx+B,KAAM29B,EAAiBL,GAE/D,ECfA,QAbA,SACEv+B,EACA0/B,GAEA,MAAMC,EAAmB,EAAoB3/B,GAG7C0/B,EAAGC,GAGHA,EAAiBV,gBACnB,gCCVA,IAAKW,yBAAL,SAAKA,GAQH,kBAMA,oBAKA,oBAKA,qBACD,CAzBD,CAAKA,IAAAA,EAAS,KA2Bd,ylBCAA,MAAM,OAAEC,EAAM,QAAEC,EAAO,QAAEC,EAAO,SAAEC,GAAa,EAAAJ,UAEzCK,EAAmB,CAAC,CAAEC,YAAa,EAAAC,cAAcC,UAcxC,MAAMC,EAYnB,WAAAzgC,CAAY6E,GAVZ,KAAA67B,cAAgB,GAChB,KAAAC,YAAc,CAAC,EACf,KAAAC,6BAA8C,KAC9C,KAAAC,0BAA2C,KAI3C,KAAAC,mBAAqB,CAAC,EACtB,KAAAC,eAAiB,CAAC,EAGhB1/B,KAAKwD,GAAKA,CACZ,CAMA,cAAAm8B,GACE,OAAO3/B,KAAKq/B,cAAc98B,KAAI,EAAGgB,gBAAiBA,GACpD,CAKA,gBAAAq8B,GACE,OAAO5/B,KAAKq/B,cAAczf,OAC5B,CAOO,eAAAigB,CAAgBC,GACrB,MAAMC,EAAe//B,KAAK0/B,eAAeI,GACzC,GAAKC,EAOL,OAAOA,EANL1uB,QAAQC,KACN,IAAIwuB,6CAA4D9/B,KAAKwD,OAM3E,CAOO,gBAAAw8B,GACL,OAAOhgC,KAAK0/B,cACd,CAOA,OAAAO,CAAQC,GACN,QAASlgC,KAAK0/B,eAAeQ,EAC/B,CAWA,OAAAC,CAAQD,EAAkBE,EAAmC,CAAC,GAC5D,MAAMC,EAAiB,KAAMC,MAAMJ,GAC7BK,OAAkC,IAAbL,GAAyC,KAAbA,EACjDM,EAAoBxgC,KAAKs/B,YAAYY,GAE3C,IAAKK,EAKH,YAJAlvB,QAAQC,KACN,uDACA8uB,GAKJ,IAAKC,EAIH,YAHAhvB,QAAQC,KACN,IAAI4uB,mGAKR,GAAIM,EAIF,YAHAnvB,QAAQC,KACN,IAAI4uB,0CAAiDlgC,KAAKwD,OAO9D,MAAQi9B,UAAWC,GAAcL,EAQ3BM,EAAmB,IAAID,EANX,CAChBzsB,KAAMisB,EACNU,YAAa5gC,KAAKwD,GAClB48B,kBAOFpgC,KAAK0/B,eAAeQ,GAAYS,CAClC,CAEO,eAAAE,CACLX,EACAY,EACAV,EAAgB,CAAC,GAEjB,IAAIW,EAAiB,KAAMT,MAAMJ,IAC7BO,UAEJ,IAAKM,EAAgB,CAEnB,MAAMC,EAAc,KAAMV,MAAMQ,GAC7BL,UAIH,MAAMQ,UAAqBD,GAE3BC,EAAaf,SAAWA,EAExBa,EAAiBE,EAEjB,KAAMX,MAAMJ,GAAY,CACtBO,UAAWQ,EAEf,CAIAjhC,KAAKmgC,QAAQY,EAAeb,SAAUE,EACxC,CAeO,WAAAc,CAAY39B,EAAoBG,GACrC,GAA0B,iBAAfH,EACT,MAAM,IAAIoE,MAAM,8CAGlB,MAAMwiB,GAAmB,IAAAgX,uBAEzB,IAAKz9B,GAAqBymB,EAAiBrgB,OAAS,EAClD,MAAM,IAAInC,MACR,mFAIJ,MAAMy5B,EAA0B19B,GAAqBymB,EAAiB,GAAG3mB,GAItExD,KAAKq/B,cAAcgC,MAAK,EAAG99B,WAAY+9B,KAAWA,IAAS/9B,KAE5DvD,KAAKq/B,cAAczuB,KAAK,CACtBrN,aACAG,kBAAmB09B,IAKvB,MAAMlB,EAAWlgC,KAAKuhC,kCAEE,EAAAtiB,SAAS0B,qBACb5U,IAAI,eACtB/L,KAAKwhC,6BAA6BtB,GAGpC,MAAMuB,EAAc,CAClBb,YAAa5gC,KAAKwD,GAClBD,aACAG,kBAAmB09B,IAGrB,IAAA/9B,cAAa,EAAAq+B,YAAa,EAAA1mB,OAAO2mB,yBAA0BF,EAC7D,CAUO,eAAAG,CAAgBl+B,EAA2BH,GAChD,MAAMs+B,EAAU,GAgBhB,GAdA7hC,KAAKq/B,cAAc9uB,SAAQ,CAACuxB,EAAQv1B,KAClC,IAAIH,GAAQ,EACR01B,EAAOp+B,oBAAsBA,IAC/B0I,GAAQ,EAEJ7I,GAAcu+B,EAAOv+B,aAAeA,IACtC6I,GAAQ,IAGRA,GACFy1B,EAAQjxB,KAAKrE,EACf,IAGEs1B,EAAQ/3B,OAGV,IAAK,IAAId,EAAI64B,EAAQ/3B,OAAS,EAAGd,GAAK,EAAGA,IACvChJ,KAAKq/B,cAAcv9B,OAAO+/B,EAAQ74B,GAAI,GAI1C,MAAMy4B,EAAc,CAClBb,YAAa5gC,KAAKwD,GAClBD,aACAG,sBAGF,IAAAL,cAAa,EAAAq+B,YAAa,EAAA1mB,OAAO+mB,2BAA4BN,EAC/D,CAEO,iBAAAO,CAAkB9B,EAAkB+B,GACzC,MAAMlC,EAAe//B,KAAK0/B,eAAeQ,QAEpBj2B,IAAjB81B,EAQJA,EAAaiC,kBAAkBC,GAP7B5wB,QAAQC,KACN,QAAQ4uB,0DAOd,CAEA,WAAAgC,CACEhC,EACAiC,EACAl7B,EAAU,CAAC,GAENi5B,EAKDiC,IAAS,EAAAxD,UAAUC,OAQnBuD,IAAS,EAAAxD,UAAUE,QAKnBsD,IAAS,EAAAxD,UAAUG,QAKnBqD,IAAS,EAAAxD,UAAUI,SAKvB1tB,QAAQC,KAAK,qCAJXtR,KAAKoiC,gBAAgBlC,GALrBlgC,KAAKqiC,eAAenC,GALpBlgC,KAAKsiC,eAAepC,GARpBlgC,KAAKuiC,cACHrC,EACAj5B,GAAWjH,KAAKy/B,mBAAmBS,IAPrC7uB,QAAQC,KAAK,wCA4BjB,CAcO,aAAAixB,CACLrC,EACAsC,EAAsB,CAAC,GAEvB,MAAMzC,EAAe//B,KAAK0/B,eAAeQ,GAEzC,QAAqBj2B,IAAjB81B,EAKF,YAJA1uB,QAAQC,KACN,QAAQ4uB,kDAMZ,IAAKH,EAIH,YAHA1uB,QAAQC,KACN,IAAI4uB,eAAsBH,iEAK9B,MA4BMT,EAA+B,CACnCmD,SAlBoB,IAXeziC,KAAKs/B,YAAYY,GAClDlgC,KAAKs/B,YAAYY,GAAUuC,SAC3B,MAEgBD,EAAoBC,SACpCD,EAAoBC,SACpB,IAKoDC,QACtD,CAACC,EAAQC,KACP,MAAMC,OAA0C54B,IAA3B24B,EAAQE,eACvBC,OAAuC94B,IAAxB24B,EAAQ3D,YAQ7B,OALG0D,EAAOtB,MAAM2B,GAAQC,EAAeD,EAAKJ,OACzCC,IAAgBE,GAEjBJ,EAAO/xB,KAAKgyB,GAEPD,CAAM,GAEf,IAMAR,KAAMvD,GAGR5+B,KAAKs/B,YAAYY,GAAYZ,EAC7Bt/B,KAAK0/B,eAAeQ,GAAUiC,KAAOvD,EAGrC,MACMsE,EADkB,EAAAjkB,SAAS0B,qBACC5U,IAAI,cAEtC,GAAI/L,KAAKmjC,8BAA8BX,IAAwBU,EAC7DljC,KAAKwhC,6BAA6BtB,OAC7B,CAGL,IAD6BlgC,KAAKuhC,mCACL2B,EAAW,CACtC,MAAME,EAAS,EAAAC,YAAYC,iBAAiB,WAC5CtjC,KAAKujC,uBAAuBH,EAC9B,CACF,CAIIpjC,KAAKmjC,8BAA8BX,KACE,OAAnCxiC,KAAKw/B,0BACPx/B,KAAKw/B,0BAA4BU,EAEjClgC,KAAKw/B,0BAA4Bx/B,KAAKu/B,6BAGxCv/B,KAAKu/B,6BAA+BW,GAGM,mBAAjCH,EAAayD,iBACtBzD,EAAayD,kBAEfxjC,KAAKyjC,mBAEL,MAAMhC,EAAwC,CAC5Cb,YAAa5gC,KAAKwD,GAClB08B,WACAsC,wBAGF,IAAAn/B,cAAa,EAAAq+B,YAAa,EAAA1mB,OAAO0oB,eAAgBjC,GACjDzhC,KAAK2jC,6BAA6BzD,EAAUtB,EAAQ4D,EACtD,CAaO,cAAAF,CACLpC,EACAj5B,GAEA,MAAM84B,EAAe//B,KAAK0/B,eAAeQ,GAEzC,QAAqBj2B,IAAjB81B,EAKF,YAJA1uB,QAAQC,KACN,QAAQ4uB,kDAQZ,MAAM0D,EAAkB5jC,KAAK6jC,eAAe3D,GACtCZ,EAAczzB,OAAOyS,OACzB,CACEmkB,SAAUmB,EAAkBA,EAAgBnB,SAAW,IAEzDmB,EACA,CACEzB,KAAMtD,IAIJiF,EAAgBx8B,MAAMC,QAAQN,GAAS88B,mBACzC98B,EAAQ88B,kBACR/jC,KAAKgkC,4BAGT1E,EAAYmD,SAAWnD,EAAYmD,SAASj1B,QACzCo1B,IACgC,IAA/B37B,GAAS88B,oBACRD,EAAczC,MAAM4C,GACnBhB,EAAeL,EAASqB,OAK9B,IAAI9B,EAAOtD,EACyB,IAAhCS,EAAYmD,SAAS34B,SACvBq4B,EAAOvD,EACPU,EAAY6C,KAAOA,GAGrBniC,KAAKs/B,YAAYY,GAAYZ,EAC7BS,EAAaoC,KAAOA,EAEyB,mBAAlCpC,EAAamE,kBACtBnE,EAAamE,mBAEflkC,KAAKyjC,mBAOLzjC,KAAK2jC,6BAA6BzD,EAAUrB,EAC9C,CASO,cAAAwD,CAAenC,GACpB,MAAMH,EAAe//B,KAAK0/B,eAAeQ,GAEzC,QAAqBj2B,IAAjB81B,EAKF,YAJA1uB,QAAQC,KACN,QAAQ4uB,kDAMZ,MAAMZ,EAAc,CAClBmD,SAAU,GACVN,KAAMrD,GAGR9+B,KAAKs/B,YAAYY,GAAYZ,EAC7BS,EAAaoC,KAAOrD,EAEyB,mBAAlCiB,EAAaoE,kBACtBpE,EAAaoE,mBAGfnkC,KAAKyjC,mBACLzjC,KAAK2jC,6BAA6BzD,EAAUpB,EAC9C,CASO,eAAAsD,CAAgBlC,GACrB,MAAMH,EAAe//B,KAAK0/B,eAAeQ,GAEzC,QAAqBj2B,IAAjB81B,EAKF,YAJA1uB,QAAQC,KACN,QAAQ4uB,kDAMZ,MAAMZ,EAAc,CAClBmD,SAAU,GACVN,KAAMpD,GAGR/+B,KAAKy/B,mBAAmBS,GAAYlgC,KAAKs/B,YAAYY,GAErDlgC,KAAKs/B,YAAYY,GAAYZ,EAC7BS,EAAaoC,KAAOpD,EAE0B,mBAAnCgB,EAAaqE,mBACtBrE,EAAaqE,oBAEfpkC,KAAKyjC,mBACLzjC,KAAK2jC,6BAA6BzD,EAAUnB,EAC9C,CAOO,cAAA8E,CAAe3D,GACpB,MAAMmE,EAAqBrkC,KAAKs/B,YAAYY,GAE5C,QAA2Bj2B,IAAvBo6B,EAIJ,OAAOA,CACT,CAQO,+BAAA9C,GACL,OAAO11B,OAAOyU,KAAKtgB,KAAKs/B,aAAapX,MAAMgY,IACzC,MAAMZ,EAAct/B,KAAKs/B,YAAYY,GACrC,OACEZ,EAAY6C,OAASvD,GACrB5+B,KAAKmjC,8BAA8B7D,EACpC,GAEL,CAEO,4BAAAkC,CACLtB,EACA+B,GAEA,MAAMmB,EAASpjC,KAAKskC,WAAWpE,EAAU+B,GAEzCjiC,KAAKujC,uBAAuBH,EAC9B,CAEQ,UAAAkB,CAAWpE,EAAkB+B,GACnC,IAAIsC,EACAnB,EAEJ,OAAInB,IAGFsC,EAAa,GAAGrE,KAAY+B,IAE5BmB,EAAS,EAAAoB,eAAelB,iBAAiBiB,GAAY,GAEjDnB,GACKA,GAKXmB,EAAa,GAAGrE,IAEhBkD,EAAS,EAAAoB,eAAelB,iBAAiBiB,GAAY,GAEjDnB,IAKJmB,EAAarE,EAEbkD,EAAS,EAAAoB,eAAelB,iBAAiBiB,GAAY,GAEjDnB,GAIG,EAAAC,YAAYC,iBAAiB,YACtC,CAEA,sBAAAC,CAAuBH,GACrBpjC,KAAKq/B,cAAc9uB,SAAQ,EAAG7M,oBAAmBH,iBAC/C,MAAMuS,GAAiB,IAAAiU,wBACrBxmB,EACAG,GAGF,IAAKoS,EACH,OAGF,MAAM,SAAErS,GAAaqS,GACrB,IAAA2uB,mBAAkBhhC,EAAS1E,QAASqkC,EAAO,GAE/C,CAMO,oBAAAsB,CACLxE,EACAE,EACA7H,GAEA,MAAMwH,EAAe//B,KAAK0/B,eAAeQ,GACzC,QAAqBj2B,IAAjB81B,EAIF,OAHA1uB,QAAQC,KACN,QAAQ4uB,iDAEH,EAGT,IAAIyE,EAmBJ,OAhBEA,EADEpM,EACe6H,EAKAv0B,OAAOyS,OAAOyhB,EAAaK,cAAeA,GAG7DL,EAAaK,cAAgBuE,EAEsB,mBAAxC5E,EAAa6E,wBACtB7E,EAAa6E,yBAGf5kC,KAAKyjC,oBAEE,CACT,CAKO,sBAAAoB,GACL,OAAO,EAAA3F,cAAcC,OACvB,CAOO,yBAAA6E,GACL,OAAOhF,CACT,CAUA,oBAAA8F,CAAqB5E,EAAkB6E,GACrC,QAAsC96B,IAAlCjK,KAAK0/B,eAAeQ,GAItB,YAHA7uB,QAAQC,KACN,QAAQ4uB,gDAKZ,MAAMyE,EACJ,IAAI3kC,KAAK0/B,eAAeQ,GAAUE,cAAe2E,IACjD/kC,KAAK0/B,eAAeQ,GAAUE,cAEhC,OAAO,IAAUuE,EACnB,CAMO,4BAAAK,GACL,OAAOhlC,KAAKw/B,yBACd,CAUO,KAAAyF,CACLC,EACAC,EAA2C,MAE3C,IAAIC,EAAY,kBAA8BF,GAE9C,OAAIE,GACF/zB,QAAQC,KAAK,aAAa4zB,oBACnBE,IAGTA,EAAY,qBAAiCF,GAC7CC,EAAeA,GAAgB,MAAO,GAEtCt5B,OAAOyU,KAAKtgB,KAAK0/B,gBACdlyB,OAAO23B,GACP50B,SAAS2vB,IACR,MAAMmF,EAAqBrlC,KAAK0/B,eAAeQ,GACzCoF,EAAoBtlC,KAAKs/B,YAAYY,GACrCqF,EAAiBF,EAAmBlD,KAE1CiD,EAAUjF,QAAQD,GAEjBkF,EAAmClD,YAClChC,EACAqF,EACA,CACE9C,SAAU6C,EAAkB7C,UAAY,IAE3C,IAGE2C,EACT,CAOQ,6BAAAjC,CAA8B7D,GACpC,MAAMkG,EAAkBxlC,KAAKgkC,4BAC7B,OAAO1E,GAAamD,UAAUpB,MAAMuB,GAClC4C,EAAgBnE,MAAMoE,GAAYxC,EAAeL,EAAS6C,MAE9D,CAKQ,gBAAAhC,GACNzjC,KAAKq/B,cAAc9uB,SAAQ,EAAG7M,oBAAmBH,kBAC/C,IAAAmiC,oBAAmBhiC,GAAmBiiC,eAAepiC,EAAW,GAEpE,CAQQ,4BAAAogC,CACNzD,EACAiC,EACAK,GAEA,MAAMf,EAA0C,CAC9Cb,YAAa5gC,KAAKwD,GAClB08B,WACAiC,OACAK,wBAGF,IAAAn/B,cAAa,EAAAq+B,YAAa,EAAA1mB,OAAO4qB,kBAAmBnE,EACtD,EAMF,SAASwB,EACP4C,EACAC,GAEA,OAAID,EAAS5G,cAAgB6G,EAAS7G,cAGlC4G,EAAS/C,iBAAmBgD,EAAShD,gBAIlC+C,EAASE,cAAgBD,EAASC,YAC3C,CC70BA,QApBA,SAAyBnF,GAMvB,GAJ8B,KAAMoF,WAAW3E,MAC5C4E,GAAOA,EAAGziC,KAAOo9B,IAKlB,YADAvvB,QAAQC,KAAK,IAAIsvB,sBAInB,MAAMwE,EAAY,IAAIhG,EAAUwB,GAMhC,OAHA,KAAMoF,WAAWp1B,KAAKw0B,GAGfA,CACT,yECPA,QAVA,WACE,MAAMY,EAAa,IAAI,KAAaA,YAEpC,IAAK,MAAMZ,KAAaY,GACtB,OAAiBZ,EAAU5hC,IAG7B,KAAawiC,WAAa,EAC5B,sFCIA,QAbA,SAA0BpF,GACxB,MAAMsF,EAAiB,KAAMF,WAAWG,WACrCF,GAAOA,EAAGziC,KAAOo9B,IAGhBsF,GAAkB,IACpB,KAA4BE,gBAAgBxF,IAE5C,IAAAyF,kCAAiCzF,GACjC,KAAMoF,WAAWlkC,OAAOokC,EAAgB,GAE5C,gECZA,QAJA,WACE,OAAO,KAAMF,UACf,gECIA,QAJA,SAAsBpF,GACpB,OAAO,KAAMoF,WAAW9d,MAAMoe,GAAMA,EAAE9iC,KAAOo9B,GAC/C,2ECPA,MAAM2F,EAAQ,CAAC,EAAA5H,UAAUC,OAAQ,EAAAD,UAAUE,QAAS,EAAAF,UAAUG,SA8B9D,QAtBA,SAAmCoB,GACjC,OAAO,KAAM8F,WAAWx4B,QAAO,EAAG8xB,kBAChC,MAAMkH,EAAqB36B,OAAOyU,KAAKgf,GAEvC,IAAK,IAAIt2B,EAAI,EAAGA,EAAIw9B,EAAmB18B,OAAQd,IAC7C,GAAIk3B,IAAasG,EAAmBx9B,IAK/Bs2B,EAAYY,IAIbqG,EAAMrf,SAASoY,EAAYY,GAAUiC,MACvC,OAAO,EAGX,OAAO,CAAK,GAEhB,2PCcA,MAAM,sBAAExK,GAA0B,YAqClC,MAAM8O,UAA0B,KAkB9B,WAAA9nC,CACE+nC,EAA6B,CAAC,EAC9BC,EAA8B,CAC5BC,0BAA2B,CAAC,QAAS,SACrCxG,cAAe,CACbyG,2BAA2B,EAC3BC,aAAcC,KAIlBloC,MAAM6nC,EAAWC,GAmHnB,KAAAK,gBAAkB,CAChBjoC,EACAkoC,EACAC,EACAC,KAEA,MAAMrxB,GAAiB,IAAA6T,mBAAkB5qB,IACnC,SAAE0E,GAAaqS,GACf,KAAEhL,GAASm8B,GACX,OAAEG,GAAWt8B,EAAKu8B,QAGxB,IAAIC,EAAe7jC,EAAS1B,cAAcqlC,EAAO,IAC7CG,EAAe9jC,EAAS1B,cAAcqlC,EAAO,IAE7CI,EAAO,CACT/9B,MAAO,CACLgJ,EAAG60B,EAAa,GAChBnwB,EAAGmwB,EAAa,IAElB39B,IAAK,CACH8I,EAAG80B,EAAa,GAChBpwB,EAAGowB,EAAa,KAIhBE,EAAkB,kBACpB,CAACD,EAAK/9B,MAAMgJ,EAAG+0B,EAAK/9B,MAAM0N,GAC1B,CAACqwB,EAAK79B,IAAI8I,EAAG+0B,EAAK79B,IAAIwN,GACtB,CAAC+vB,EAAa,GAAIA,EAAa,KAGjC,OAAIO,GAAmBN,IAKvBG,EAAe7jC,EAAS1B,cAAcqlC,EAAO,IAC7CG,EAAe9jC,EAAS1B,cAAcqlC,EAAO,IAE7CI,EAAO,CACL/9B,MAAO,CACLgJ,EAAG60B,EAAa,GAChBnwB,EAAGmwB,EAAa,IAElB39B,IAAK,CACH8I,EAAG80B,EAAa,GAChBpwB,EAAGowB,EAAa,KAIpBE,EAAkB,kBAChB,CAACD,EAAK/9B,MAAMgJ,EAAG+0B,EAAK/9B,MAAM0N,GAC1B,CAACqwB,EAAK79B,IAAI8I,EAAG+0B,EAAK79B,IAAIwN,GACtB,CAAC+vB,EAAa,GAAIA,EAAa,KAG7BO,GAAmBN,EAIX,EASd,KAAAO,qBAAuB,CACrBl+B,EACAy9B,KAEA,MAAMxF,EAAcj4B,EAAImrB,QAClB,QAAE51B,GAAY0iC,EAEpBwF,EAAWU,aAAc,EAEzB,MAAMC,GAAsB,IAAAC,gCAC1B9oC,EACAiB,KAAK8nC,eAGP9nC,KAAK+nC,SAAW,CACdd,aACAW,sBACAI,eAAe,GAGjBhoC,KAAKioC,gBAAgBlpC,GAErB,MAAM+W,GAAiB,IAAA6T,mBAAkB5qB,IACnC,gBAAEmS,GAAoB4E,GAE5B,OAAsC5E,EAAiB02B,IAEvD,IAAAM,mBAAkBnpC,GAElByK,EAAI2+B,gBAAgB,EAYtB,KAAAC,uBAAyB,CACvB5+B,EACAy9B,EACAoB,KAEA,MAAM5G,EAAcj4B,EAAImrB,QAClB,QAAE51B,GAAY0iC,EACd32B,EAAOm8B,EAAWn8B,KAExBm8B,EAAWU,aAAc,EAEzB,IACIW,EADAN,GAAgB,EAGfK,EAAyBE,cAC5BP,GAAgB,EAEhBM,EAAcx9B,EAAKu8B,QAAQD,OAAOjB,WAAWqC,GAAMA,IAAMH,IAI3D,MAAMT,GAAsB,IAAAC,gCAC1B9oC,EACAiB,KAAK8nC,gBAGP,IAAAI,mBAAkBnpC,GAElBiB,KAAK+nC,SAAW,CACdd,aACAW,sBACAU,cACAN,iBAEFhoC,KAAKioC,gBAAgBlpC,GAErB,MAAM+W,GAAiB,IAAA6T,mBAAkB5qB,IACnC,gBAAEmS,GAAoB4E,GAE5B,OAAsC5E,EAAiB02B,GAEvDp+B,EAAI2+B,gBAAgB,EAWtB,KAAAM,aAAgBj/B,IACd,MAAMi4B,EAAcj4B,EAAImrB,QAClB,QAAE51B,GAAY0iC,GAEd,WAAEwF,EAAU,oBAAEW,EAAmB,cAAEc,EAAa,SAAEC,GACtD3oC,KAAK+nC,UACD,KAAEj9B,GAASm8B,EAEjB,GAAIyB,IAAkBC,EACpB,OAGF79B,EAAKu8B,QAAQuB,kBAAoB,KAEjC5oC,KAAK6oC,kBAAkB9pC,GACvBiB,KAAK8oC,gBAAgB/pC,IAErB,IAAAgqC,oBAAmBhqC,GAEnB,MAAM,gBAAEmS,IAAoB,IAAAyY,mBAAkB5qB,GAE9C,QAAkCkL,IAA9BjK,KAAK+nC,SAASO,YAA2B,CAC3C,MAAM,OAAElB,GAAWt8B,EAAKu8B,QAClB2B,EAAyB,cAAc5B,EAAO,GAAIA,EAAO,IAG/D,GAFgC,cAAcA,EAAO,GAAIA,EAAO,IAElC4B,EAAwB,CAGpD,MAAMC,EAAW,CAAC,IAAI7B,EAAO,IAAK,IAAIA,EAAO,KAEvC8B,EAAkB,IAAI9B,EAAO,IAC7B+B,EAAkB,IAAI/B,EAAO,IAG7BgC,EAAiB,cAEvB,SACEA,EACAH,EAAS,GAAG,GAAKA,EAAS,GAAG,GAC7BA,EAAS,GAAG,GAAKA,EAAS,GAAG,IAG/B,MAAMI,EAA0C,cAEhD,SACEA,GACCD,EAAe,GAChBA,EAAe,IAGjB,MAAME,EAAyB,cAQ/B,IAAIC,EANJ,SACED,EACAH,EAAgB,GAAKD,EAAgB,GACrCC,EAAgB,GAAKD,EAAgB,IAWrCK,EALA,SACED,EACAD,GACE,EAEQ,CAACH,EAAiBC,GAElB,CAACA,EAAiBD,GAGhCp+B,EAAKu8B,QAAQD,OAAS,CACpB6B,EAAS,GACTA,EAAS,GACTM,EAAU,GACVA,EAAU,GAEd,CACF,CAGEvpC,KAAKwpC,sBACLxpC,KAAKogC,cAAcyG,4BAEnB,IAAA4C,kBAAiBxC,EAAWyC,gBAG9B,OAAsCx4B,EAAiB02B,GAEnDc,IACF,QAA2BzB,GAG7BjnC,KAAK+nC,SAAW,KAChB/nC,KAAK2pC,WAAY,CAAK,EAMxB,KAAAC,kBAAqBpgC,IACnBxJ,KAAK2pC,WAAY,EAEjB,MAAMlI,EAAcj4B,EAAImrB,QAClB,cAAEkV,EAAa,QAAE9qC,GAAY0iC,EAC7B3rB,GAAiB,IAAA6T,mBAAkB5qB,IACnC,gBAAEmS,EAAe,SAAEzN,GAAaqS,GAChC,cAAE/T,GAAkB0B,GACpB,WAAEwjC,EAAU,oBAAEW,EAAmB,YAAEU,GAAgBtoC,KAAK+nC,UACxD,KAAEj9B,GAASm8B,EAEXjlC,EAAW6nC,EAAcC,MAG/Bh/B,EAAKu8B,QAAQD,OAAOkB,GAAe,IAAItmC,GAEvC,MAAM+nC,EAAoBj/B,EAAKu8B,QAAQD,OAAO7kC,IAAIR,GAE5CmlC,EACa,CACfz9B,MAAO,CACLgJ,EAAGs3B,EAAkB,GAAG,GACxB5yB,EAAG4yB,EAAkB,GAAG,IAE1BpgC,IAAK,CACH8I,EAAGs3B,EAAkB,GAAG,GACxB5yB,EAAG4yB,EAAkB,GAAG,KAoBxBC,GAfGD,EAAkB,GAAG,GACrBA,EAAkB,GAAG,GAGrBA,EAAkB,GAAG,GACrBA,EAAkB,GAAG,GAQjB,cAAcA,EAAkB,GAAIA,EAAkB,IAE5B,GAEjCE,EACJ/C,EAA6Bz9B,MAAMgJ,EAAIy0B,EAA6Bv9B,IAAI8I,EACpEy3B,EACJhD,EAA6Bz9B,MAAM0N,EAAI+vB,EAA6Bv9B,IAAIwN,EACpErN,EAASlJ,KAAKiZ,KAAKowB,EAAKA,EAAKC,EAAKA,GAClCC,EAAUF,EAAKngC,EACfsgC,EAAUF,EAAKpgC,EAEfugC,GACHnD,EAA6Bz9B,MAAMgJ,EAClCy0B,EAA6Bv9B,IAAI8I,GACnC,EACI63B,GACHpD,EAA6Bz9B,MAAM0N,EAClC+vB,EAA6Bv9B,IAAIwN,GACnC,EAEIozB,EAASF,EAAOL,EAA0BI,EAC1CI,EAASF,EAAON,EAA0BG,EAC1CM,EAAOJ,EAAOL,EAA0BI,EACxCM,EAAOJ,EAAON,EAA0BG,EAG9Cr/B,EAAKu8B,QAAQD,OAAO,GAAK3jC,EAASnC,cAAc,CAACipC,EAAQC,IACzD1/B,EAAKu8B,QAAQD,OAAO,GAAK3jC,EAASnC,cAAc,CAACmpC,EAAMC,IAEvDzD,EAAWlxB,aAAc,GACzB,OAAsC7E,EAAiB02B,GAEvD5nC,KAAK+nC,SAASY,UAAW,CAAI,EAO/B,KAAAgC,oBAAuBnhC,IACrBxJ,KAAK2pC,WAAY,EAEjB,MAAMlI,EAAcj4B,EAAImrB,QAClB,QAAE51B,GAAY0iC,EACd3rB,GAAiB,IAAA6T,mBAAkB5qB,IACnC,gBAAEmS,GAAoB4E,GACtB,WAAEmxB,EAAU,oBAAEW,EAAmB,YAAEU,EAAW,cAAEN,GACpDhoC,KAAK+nC,UACD,KAAEj9B,GAASm8B,EACjB,GAAIe,EAAe,CACjB,MAAM,YAAE4C,GAAgBnJ,EAClBoJ,EAAgBD,EAAYd,OAE5B,QAAEgB,GAAYhgC,EAAKu8B,SACnB,cAAEkB,GAAkBuC,EAE1BvC,EAAc,IAAMsC,EAAc,GAClCtC,EAAc,IAAMsC,EAAc,GAClCtC,EAAc,IAAMsC,EAAc,GAElCC,EAAQnC,UAAW,CACrB,MAAO,QAAoB1+B,IAAhBq+B,EAA2B,CAEpC,MAAM,YAAEsC,GAAgBnJ,EAClBoJ,EAAgBD,EAAYd,MACnBh/B,EAAKu8B,QAAQD,OAErB72B,SAASlF,IACdA,EAAM,IAAMw/B,EAAc,GAC1Bx/B,EAAM,IAAMw/B,EAAc,GAC1Bx/B,EAAM,IAAMw/B,EAAc,EAAE,IAE9B5D,EAAWlxB,aAAc,CAC3B,MACE/V,KAAK+qC,kBAAkBvhC,GACvBy9B,EAAWlxB,aAAc,GAG3B,OAAsC7E,EAAiB02B,EAAoB,EAO7E,KAAAmD,kBAAqBvhC,IACnB,MAAMi4B,EAAcj4B,EAAImrB,QAClB,cAAEkV,EAAa,QAAE9qC,GAAY0iC,EAC7B3rB,GAAiB,IAAA6T,mBAAkB5qB,IACnC,SAAE0E,GAAaqS,GACf,WAAEmxB,EAAYqB,YAAa0C,GAAsBhrC,KAAK+nC,UACtD,KAAEj9B,GAASm8B,EAGXjlC,EAAW6nC,EAAcC,MACzBmB,EAA4B,CAChCxnC,EAAS1B,cAAc+I,EAAKu8B,QAAQD,OAAO,IAC3C3jC,EAAS1B,cAAc+I,EAAKu8B,QAAQD,OAAO,IAC3C3jC,EAAS1B,cAAc+I,EAAKu8B,QAAQD,OAAO,IAC3C3jC,EAAS1B,cAAc+I,EAAKu8B,QAAQD,OAAO,KAGvC8D,EAAmB,CACvBzhC,MAAO,CACLgJ,EAAGw4B,EAA0B,GAAG,GAChC9zB,EAAG8zB,EAA0B,GAAG,IAElCthC,IAAK,CACH8I,EAAGw4B,EAA0B,GAAG,GAChC9zB,EAAG8zB,EAA0B,GAAG,KAG9BE,EAAoB,CACxB1hC,MAAO,CACLgJ,EAAGw4B,EAA0B,GAAG,GAChC9zB,EAAG8zB,EAA0B,GAAG,IAElCthC,IAAK,CACH8I,EAAGw4B,EAA0B,GAAG,GAChC9zB,EAAG8zB,EAA0B,GAAG,KAK9BG,EAA8B,IAAIppC,GAClCqpC,EAAsB5nC,EAAS1B,cAAcqpC,GAEnD,GAA0B,IAAtBJ,GAAiD,IAAtBA,EAAyB,CACtD,MAEMM,EACJL,EAH6C,IAAtBD,EAA0B,EAAI,GAKjDO,EAAgC,SACpC,cACAF,EAAoB,GAAKC,EAAuB,GAChDD,EAAoB,GAAKC,EAAuB,IAG5CE,EAA2B,SAC/B,cACAP,EAA0BD,GAAmB,GAC3CM,EAAuB,GACzBL,EAA0BD,GAAmB,GAC3CM,EAAuB,IAI3B,eACEC,EACAA,GAEF,eAAeC,EAA0BA,GAGzC,MAAMC,EAA2B,CAC/BhiC,MAAO,CACLgJ,EAAG64B,EAAuB,GAC1Bn0B,EAAGm0B,EAAuB,IAE5B3hC,IAAK,CACH8I,EAAG44B,EAAoB,GACvBl0B,EAAGk0B,EAAoB,KAS3B,GACErrC,KAAK0rC,0CACHD,EACAN,GAGF,OAGF,MAAMQ,EAAmBL,EAEnB30B,EAAQ3W,KAAK4rC,gBACjBJ,EACAD,GAKF,IAAIM,EAAcZ,EAA0B,GAAG,GAC3Ca,EAAcb,EAA0B,GAAG,GAE3Cc,EAAed,EAA0B,GAAG,GAC5Ce,EAAef,EAA0B,GAAG,GAGhDY,GAAeF,EAAiB,GAChCG,GAAeH,EAAiB,GAEhCI,GAAgBJ,EAAiB,GACjCK,GAAgBL,EAAiB,GAGjC,MAAMM,EACJJ,EAAcjrC,KAAKmX,IAAIpB,GAASm1B,EAAclrC,KAAKqX,IAAItB,GACnDu1B,EACJL,EAAcjrC,KAAKqX,IAAItB,GAASm1B,EAAclrC,KAAKmX,IAAIpB,GAEnDw1B,EACJJ,EAAenrC,KAAKmX,IAAIpB,GAASq1B,EAAeprC,KAAKqX,IAAItB,GACrDy1B,EACJL,EAAenrC,KAAKqX,IAAItB,GAASq1B,EAAeprC,KAAKmX,IAAIpB,GAG3Dk1B,EAAcI,EAAoBN,EAAiB,GACnDG,EAAcI,EAAqBP,EAAiB,GAEpDI,EAAeI,EAAqBR,EAAiB,GACrDK,EAAeI,EAAsBT,EAAiB,GAGtD,MAAMU,EAAgB5oC,EAASnC,cAAc,CAACuqC,EAAaC,IACrDQ,EAAiB7oC,EAASnC,cAAc,CAC5CyqC,EACAC,IAKFlhC,EAAKu8B,QAAQD,OAAO4D,GAAqBI,EACzCtgC,EAAKu8B,QAAQD,OAAO,GAAKiF,EACzBvhC,EAAKu8B,QAAQD,OAAO,GAAKkF,CAC3B,KAAO,CAEL,MAAMC,EAA6C,IAAtBvB,EAA0B,EAAI,EAErDwB,EAAsB,CAC1BC,gBAAiB,CACfhjC,MAAOyhC,EAAiBzhC,MACxBE,IAAKuhC,EAAiBvhC,KAExB+iC,iBAAkB,CAChBjjC,MAAO0hC,EAAkB1hC,MACzBE,IAAKwhC,EAAkBxhC,MAIrBgjC,EAAqB,cACzB,cACA,CACEH,EAAoBC,gBAAgB9iC,IAAI8I,EACxC+5B,EAAoBC,gBAAgB9iC,IAAIwN,GAE1C,CACEq1B,EAAoBC,gBAAgBhjC,MAAMgJ,EAC1C+5B,EAAoBC,gBAAgBhjC,MAAM0N,IAIxCy1B,EAA+B,eACnC,cACAD,GAGIE,EAAuB,cAC3B,cACA,CAACxB,EAAoB,GAAIA,EAAoB,IAC7C,CACEJ,EAA0BD,GAAmB,GAC7CC,EAA0BD,GAAmB,KAI3C8B,EAAiB,YAAYD,GAE7Bl2B,EAAQ3W,KAAK4rC,gBACjBgB,EACAC,GAGIE,EAAiCnsC,KAAKmX,IAAIpB,GAASm2B,EAEnDE,EAAqB,iBACzB,cACA,CACE/B,EAA0BsB,GAAsB,GAChDtB,EAA0BsB,GAAsB,IAElDK,EACAG,GAIF,GACE/sC,KAAK0rC,0CACH,CACEjiC,MAAO,CACLgJ,EAAG44B,EAAoB,GACvBl0B,EAAGk0B,EAAoB,IAEzB1hC,IAAK,CACH8I,EAAGu6B,EAAmB,GACtB71B,EAAG61B,EAAmB,KAG1B,CACEvjC,MAAO,CACLgJ,EAAG+5B,EAAoBC,gBAAgBhjC,MAAMgJ,EAC7C0E,EAAGq1B,EAAoBC,gBAAgBhjC,MAAM0N,GAE/CxN,IAAK,CACH8I,EAAG+5B,EAAoBC,gBAAgB9iC,IAAI8I,EAC3C0E,EAAGq1B,EAAoBC,gBAAgB9iC,IAAIwN,KAKjD,OAWF,IAR0B,gBACxB,CAACk0B,EAAoB,GAAIA,EAAoB,IAC7C,CAAC2B,EAAmB,GAAIA,EAAmB,IAC3C,CAAC9B,EAAiBzhC,MAAMgJ,EAAGy4B,EAAiBzhC,MAAM0N,GAClD,CAAC+zB,EAAiBvhC,IAAI8I,EAAGy4B,EAAiBvhC,IAAIwN,IAK9C,OAGFrM,EAAKu8B,QAAQD,OAAOmF,GAAwB9oC,EAASnC,cACnD0rC,GAEFliC,EAAKu8B,QAAQD,OAAO4D,GAAqBI,CAC3C,GAOF,KAAAld,OAAUnvB,IAER,GAAIiB,KAAK2pC,UAAW,CAClB3pC,KAAK2pC,WAAY,EACjB3pC,KAAK8oC,gBAAgB/pC,GACrBiB,KAAK6oC,kBAAkB9pC,IACvB,IAAAgqC,oBAAmBhqC,GAEnB,MAAM,WAAEkoC,EAAU,oBAAEW,EAAmB,cAAEc,GAAkB1oC,KAAK+nC,UAC1D,KAAEj9B,GAASm8B,EAEjBA,EAAWU,aAAc,EACzB78B,EAAKu8B,QAAQuB,kBAAoB,KAEjC,MAAM,gBAAE13B,IAAoB,IAAAyY,mBAAkB5qB,GAY9C,OAVA,OACEmS,EACA02B,GAGEc,IACF,QAA2BzB,GAG7BjnC,KAAK+nC,SAAW,KACTd,EAAWyC,aACpB,GAGF,KAAAuD,cAAiBluC,IACf,KAAMmuC,uBAAwB,EAE9BnuC,EAAQ8F,iBAAiB,EAAAmW,OAAOmyB,SAAUntC,KAAKyoC,cAC/C1pC,EAAQ8F,iBAAiB,EAAAmW,OAAOoyB,WAAYptC,KAAK4pC,mBACjD7qC,EAAQ8F,iBAAiB,EAAAmW,OAAOqyB,WAAYrtC,KAAK4pC,mBACjD7qC,EAAQ8F,iBAAiB,EAAAmW,OAAOsyB,YAAattC,KAAKyoC,cAElD1pC,EAAQ8F,iBACN,EAAAmW,OAAOuyB,UACPvtC,KAAKyoC,cAEP1pC,EAAQ8F,iBACN,EAAAmW,OAAOwyB,UACPxtC,KAAKyoC,cAEP1pC,EAAQ8F,iBACN,EAAAmW,OAAOyyB,WACPztC,KAAK4pC,kBACN,EAGH,KAAAd,gBAAmB/pC,IACjB,KAAMmuC,uBAAwB,EAE9BnuC,EAAQkG,oBAAoB,EAAA+V,OAAOmyB,SAAUntC,KAAKyoC,cAClD1pC,EAAQkG,oBAAoB,EAAA+V,OAAOoyB,WAAYptC,KAAK4pC,mBACpD7qC,EAAQkG,oBAAoB,EAAA+V,OAAOqyB,WAAYrtC,KAAK4pC,mBACpD7qC,EAAQkG,oBAAoB,EAAA+V,OAAOsyB,YAAattC,KAAKyoC,cAErD1pC,EAAQkG,oBACN,EAAA+V,OAAOuyB,UACPvtC,KAAKyoC,cAEP1pC,EAAQkG,oBACN,EAAA+V,OAAOwyB,UACPxtC,KAAKyoC,cAEP1pC,EAAQkG,oBACN,EAAA+V,OAAOyyB,WACPztC,KAAK4pC,kBACN,EAGH,KAAA3B,gBAAmBlpC,IACjB,KAAMmuC,uBAAwB,EAE9BnuC,EAAQ8F,iBAAiB,EAAAmW,OAAOmyB,SAAUntC,KAAKyoC,cAC/C1pC,EAAQ8F,iBAAiB,EAAAmW,OAAOoyB,WAAYptC,KAAK2qC,qBACjD5rC,EAAQ8F,iBAAiB,EAAAmW,OAAOsyB,YAAattC,KAAKyoC,cAElD1pC,EAAQ8F,iBACN,EAAAmW,OAAOwyB,UACPxtC,KAAKyoC,cAEP1pC,EAAQ8F,iBACN,EAAAmW,OAAOyyB,WACPztC,KAAK2qC,qBAEP5rC,EAAQ8F,iBACN,EAAAmW,OAAOuyB,UACPvtC,KAAKyoC,aACN,EAGH,KAAAI,kBAAqB9pC,IACnB,KAAMmuC,uBAAwB,EAE9BnuC,EAAQkG,oBAAoB,EAAA+V,OAAOmyB,SAAUntC,KAAKyoC,cAClD1pC,EAAQkG,oBAAoB,EAAA+V,OAAOoyB,WAAYptC,KAAK2qC,qBACpD5rC,EAAQkG,oBAAoB,EAAA+V,OAAOsyB,YAAattC,KAAKyoC,cAErD1pC,EAAQkG,oBACN,EAAA+V,OAAOwyB,UACPxtC,KAAKyoC,cAEP1pC,EAAQkG,oBACN,EAAA+V,OAAOyyB,WACPztC,KAAK2qC,qBAEP5rC,EAAQkG,oBACN,EAAA+V,OAAOuyB,UACPvtC,KAAKyoC,aACN,EAWH,KAAAiF,iBAAmB,CACjB53B,EACA4oB,KAEA,IAAIiP,GAAe,EACnB,MAAM,SAAElqC,GAAaqS,GACf,QAAE/W,GAAY0E,EACpB,IAAImqC,GAAc,IAAAC,gBAAe7tC,KAAK8nC,cAAe/oC,GAErD,IAAK6uC,GAAa9jC,OAChB,OAAO6jC,EAQT,GALAC,EAAc5tC,KAAK8tC,wCACjB/uC,EACA6uC,IAGGA,GAAa9jC,OAChB,OAAO6jC,EAGT,MAAMI,EAAW/tC,KAAKguC,YAAYvqC,GAE5ByN,EAAkBzN,EAASiiC,qBAE3BuI,EAAiC,CACrCrN,YAAa5gC,KAAK4gC,YAClBV,SAAUlgC,KAAK8nC,cACfvkC,WAAYuS,EAAerS,SAASD,IAGtC,IAAK,IAAIwF,EAAI,EAAGA,EAAI4kC,EAAY9jC,OAAQd,IAAK,CAC3C,MAAMi+B,EAAa2G,EAAY5kC,IACzB,cAAE0gC,EAAa,KAAE5+B,GAASm8B,GAC1B,OAAEG,EAAM,kBAAEwB,GAAsB99B,EAAKu8B,QACrC6G,EAAoB9G,EAAO7kC,KAAKimC,GAAM/kC,EAAS1B,cAAcymC,KAEnEyF,EAAevE,cAAgBA,EAE/B,MAAM,MAAEpzB,EAAK,UAAE63B,EAAS,SAAEC,EAAQ,OAAEC,GAAWruC,KAAKsuC,mBAAmB,CACrErH,aACAgH,mBAyBF,GAnBGnjC,EAAKyjC,YAAYR,IACiB,MAAnCjjC,EAAKyjC,YAAYR,GAAUzjC,KASlB28B,EAAWlxB,aACpB/V,KAAKwuC,+BACHvH,EACA/1B,EACA4E,IAXFhL,EAAKyjC,YAAYR,GAAY,CAC3BjkC,OAAQ,KACRvJ,MAAO,KACP+J,KAAM,MAGRtK,KAAKyuC,sBAAsBxH,EAAY/1B,EAAiB4E,KAUrDrS,EAASiiC,qBAEZ,OADAr0B,QAAQC,KAAK,uCACNq8B,EAGT,IAAIe,EAEJ,KAAK,IAAAC,qBAAoBjF,GACvB,SAYF,IARG,IAAAkF,oBAAmB3H,IACnBjnC,KAAK+nC,UACgB,OAAtBa,IAGA8F,EAA2B,CAACR,EAAkBtF,KAG5C8F,EAA0B,CAC5B,MAAMG,EAAiB,KAEvB,IAAAC,aACEpQ,EACAgL,EACAmF,EACAH,EACA,CACEp4B,SAGN,CAEA,MAAMy4B,EAAU,GAAGrF,WACbsF,EAAU,GAAGtF,WAEbuF,EAAU,KAChB,IAAAC,UACExQ,EACAgL,EACAuF,EACAf,EAAkB,GAClBA,EAAkB,GAClB,CACE53B,QACA83B,WACAD,YACAE,UAEFU,GAGF,MAAMI,EAAgB,KACtB,IAAAD,UACExQ,EACAgL,EACAyF,EACAjB,EAAkB,GAClBA,EAAkB,GAClB,CACE53B,QACA83B,WACAD,YACAE,UAEFW,GAGFrB,GAAe,EAEf,MAAM1mC,EAAUjH,KAAKovC,sBAAsBnB,EAAgBhH,GAC3D,IAAKhgC,EAAQooC,WAAY,CACvBvkC,EAAKu8B,QAAQyD,QAAU,CACrBnC,UAAU,EACVJ,cAA6B,CAAC,EAAG,EAAG,GACpC+G,iBAAkB,CAChBC,QAAuB,CAAC,EAAG,EAAG,GAC9BC,SAAwB,CAAC,EAAG,EAAG,GAC/BC,WAA0B,CAAC,EAAG,EAAG,GACjCC,YAA2B,CAAC,EAAG,EAAG,KAGtC,QACF,CAEA,MAAMC,EAAY3vC,KAAKogC,cAAc0G,aAAah8B,EAAMijC,GACxD,IAAK4B,GAAkC,IAArBA,EAAU7lC,OAC1B,SAGF,IAAI8lC,EAEC9kC,EAAKu8B,QAAQyD,QAAQnC,WACxBiH,GAAsB,IAAAC,wBAAuB3B,GAE7CpjC,EAAKu8B,QAAQyD,QAAQvC,cACnB9kC,EAASnC,cAAcsuC,IAG3B,MAAME,EAAkBrsC,EAAS1B,cAC/B+I,EAAKu8B,QAAQyD,QAAQvC,eAGjBwH,EAAa,IACbC,GAAc,IAAAC,mBAClBvR,EACAgL,EACAqG,EACAJ,EACAG,EACA5B,EACA,CAAC,EACDjnC,IAGMwL,EAAGP,EAAMiF,EAAG+4B,EAAG,MAAE3vC,EAAK,OAAEC,GAAWwvC,EAE3CllC,EAAKu8B,QAAQyD,QAAQwE,iBAAmB,CACtCC,QAAS9rC,EAASnC,cAAc,CAAC4Q,EAAMg+B,IACvCV,SAAU/rC,EAASnC,cAAc,CAAC4Q,EAAO3R,EAAO2vC,IAChDT,WAAYhsC,EAASnC,cAAc,CAAC4Q,EAAMg+B,EAAM1vC,IAChDkvC,YAAajsC,EAASnC,cAAc,CAAC4Q,EAAO3R,EAAO2vC,EAAM1vC,IAE7D,CAEA,OAAOmtC,CAAY,EAGrB,KAAAjC,0CAA4C,CAC1CR,EACAC,KAEA,MAAMgF,EAA8B,cAEpC,SACEA,EACAhF,EAAkBxhC,IAAI8I,EAAI04B,EAAkB1hC,MAAMgJ,EAClD04B,EAAkBxhC,IAAIwN,EAAIg0B,EAAkB1hC,MAAM0N,GAGpD,eAAeg5B,EAA6BA,GAE5C,MAAMC,EAA4B,CAChC3mC,MAAO,CACLgJ,EAAG04B,EAAkB1hC,MAAMgJ,EAAqC,GAAjC09B,EAA4B,GAC3Dh5B,EAAGg0B,EAAkB1hC,MAAM0N,EAAqC,GAAjCg5B,EAA4B,IAE7DxmC,IAAK,CACH8I,EAAG04B,EAAkBxhC,IAAI8I,EAAqC,GAAjC09B,EAA4B,GACzDh5B,EAAGg0B,EAAkBxhC,IAAIwN,EAAqC,GAAjCg5B,EAA4B,KAgB7D,OATkC,gBAChC,CAACC,EAA0B3mC,MAAMgJ,EAAG29B,EAA0B3mC,MAAM0N,GACpE,CAACi5B,EAA0BzmC,IAAI8I,EAAG29B,EAA0BzmC,IAAIwN,GAChE,CAAC+zB,EAAiBzhC,MAAMgJ,EAAGy4B,EAAiBzhC,MAAM0N,GAClD,CAAC+zB,EAAiBvhC,IAAI8I,EAAGy4B,EAAiBvhC,IAAIwN,GAKjB,EAWjC,KAAAs3B,sBAAwB,CAACxH,EAAY/1B,EAAiB4E,KACpD,MAAM,KAAEhL,GAASm8B,GACX,QAAEloC,GAAY+W,EAAerS,SAE7B4sC,EAAYvlC,EAAKu8B,QAAQD,OAAO,GAChCkJ,EAAYxlC,EAAKu8B,QAAQD,OAAO,GAChCmJ,EAAYzlC,EAAKu8B,QAAQD,OAAO,GAChCoJ,EAAY1lC,EAAKu8B,QAAQD,OAAO,IAEhC,YAAEmH,GAAgBzjC,EAClB2lC,EAAY5kC,OAAOyU,KAAKiuB,GAE9B,IAAK,IAAIvlC,EAAI,EAAGA,EAAIynC,EAAU3mC,OAAQd,IAAK,CACzC,MAAM+kC,EAAW0C,EAAUznC,GAErB5D,EAAQpF,KAAK0wC,iBAAiB3C,EAAU78B,GAK9C,IAAK9L,EACH,SAGF,MAAM,UAAE4F,EAAS,WAAEpE,GAAexB,EAC5BurC,EAAShZ,EAAsB3sB,EAAWqlC,GAC1CO,EAASjZ,EAAsB3sB,EAAWslC,GAC1CO,EAASlZ,EAAsB3sB,EAAWulC,GAC1CO,EAASnZ,EAAsB3sB,EAAWwlC,GAE1CO,EAAW,CAACJ,EAAQC,GACpBI,EAAW,CAACH,EAAQC,IAElB7gC,MAAOghC,EAAQC,MAAOC,IAAW,QACvC/rC,EACA2rC,IAGM9gC,MAAOmhC,EAAQF,MAAOG,IAAW,QACvCjsC,EACA4rC,GAGIM,EAAQtxC,KAAKuxC,iBAAiBlB,EAAWC,GAAaW,EACtDO,EAAQxxC,KAAKuxC,iBAAiBhB,EAAWC,GAAaY,EACtDtnC,EAASwnC,EAAQE,EAAQF,EAAQE,EACjCjxC,EAAQ+wC,EAAQE,EAAQA,EAAQF,EAEhCG,EAAaH,EAAQE,EAAQL,EAASE,EACtCK,EAAYJ,EAAQE,EAAQH,EAASF,EAE3CnxC,KAAK2xC,gBAAgBhB,EAAQC,EAAQC,EAAQC,EAAQlqC,GAChD5G,KAAKwpC,sBAAuB,EAC5BxpC,KAAKwpC,sBAAuB,EAEjC+E,EAAYR,GAAY,CACtBjkC,SACAvJ,QACA+J,KAAM6mC,EACNM,aACAC,YAEJ,CAOA,OALAzK,EAAWlxB,aAAc,GAGzB,QAA0BkxB,EAAYloC,GAE/BwvC,CAAW,EAGpB,KAAAoD,gBAAkB,CAAChB,EAAQC,EAAQC,EAAQC,EAAQlqC,IAE/C,kCAA8B+pC,EAAQ/pC,IACtC,kCAA8BgqC,EAAQhqC,IACtC,kCAA8BiqC,EAAQjqC,IACtC,kCAA8BkqC,EAAQlqC,GAI1C,KAAAglC,gBAAkB,CAACgG,EAASC,IACnBjxC,KAAKkxC,MACVF,EAAQ,GAAKC,EAAQ,GAAKD,EAAQ,GAAKC,EAAQ,GAC/CD,EAAQ,GAAKC,EAAQ,GAAKD,EAAQ,GAAKC,EAAQ,IAjsCjD7xC,KAAKwuC,gCAAiC,OACpCxuC,KAAKyuC,sBACL,IACA,CAAEsD,UAAU,GAEhB,CAUA,gBAAAC,CACExoC,GAEA,MAAMi4B,EAAcj4B,EAAImrB,QAClB,cAAEkV,EAAa,QAAE9qC,GAAY0iC,EAC7Bz/B,EAAW6nC,EAAcC,MACzBh0B,GAAiB,IAAA6T,mBAAkB5qB,IACnC,SAAE0E,EAAQ,gBAAEyN,GAAoB4E,EAEtC9V,KAAK2pC,WAAY,EAEjB,MAAMj8B,EAASjK,EAASuL,aAClB,gBAAEI,EAAe,OAAED,GAAWzB,EAE9BW,EAAoBrO,KAAKiyC,qBAC7BxuC,EACAzB,EACAoN,EACAD,GAGI8a,EAAsBxmB,EAASxC,yBAE/BgmC,EAAsC,CAC1CU,aAAa,EACb5xB,aAAa,EACb/N,SAAU,CACRk4B,SAAUlgC,KAAK8nC,cACf14B,gBAA+B,IAAIA,GACnCD,OAAsB,IAAIA,GAC1B8a,sBACA5b,uBACG5K,EAASoL,iBAAiB,CAAEu4B,OAAQ,CAACplC,MAE1C8I,KAAM,CACJu8B,QAAS,CACPD,OAAQ,CAEQ,IAAIplC,GACJ,IAAIA,GAEJ,IAAIA,GACJ,IAAIA,IAEpB8oC,QAAS,CACPnC,UAAU,EACVJ,cAA6B,CAAC,EAAG,EAAG,GACpC+G,iBAAkB,CAChBC,QAAuB,CAAC,EAAG,EAAG,GAC9BC,SAAwB,CAAC,EAAG,EAAG,GAC/BC,WAA0B,CAAC,EAAG,EAAG,GACjCC,YAA2B,CAAC,EAAG,EAAG,KAGtC9G,kBAAmB,MAErBsJ,MAAO,GACP3D,YAAa,CAAC,KAIlB,IAAA4D,eAAclL,EAAYloC,GAE1B,MAAM6oC,GAAsB,IAAAC,gCAC1B9oC,EACAiB,KAAK8nC,eAmBP,OAhBA9nC,KAAK+nC,SAAW,CACdd,aACAW,sBACAU,YAAa,EACbN,eAAe,EACfU,eAAe,EACfC,UAAU,GAEZ3oC,KAAKitC,cAAcluC,IAEnB,IAAAmpC,mBAAkBnpC,GAElByK,EAAI2+B,kBAEJ,OAAsCj3B,EAAiB02B,GAEhDX,CACT,CAigCA,gBAAAsK,CAAiBa,EAAMC,GACrB,MAAMpI,EAAKmI,EAAK,GAAKC,EAAK,GACpBnI,EAAKkI,EAAK,GAAKC,EAAK,GACpBC,EAAKF,EAAK,GAAKC,EAAK,GAE1B,OAAOzxC,KAAKiZ,KAAKowB,EAAKA,EAAKC,EAAKA,EAAKoI,EAAKA,EAC5C,EA2FF,SAASvL,EAAoBj8B,EAAMijC,GACjC,MAAM,YAAEQ,EAAW,MAAE2D,GAAUpnC,GACzB,OAAEhB,EAAM,MAAEvJ,EAAK,KAAE+J,EAAI,WAAEmnC,EAAU,UAAEC,GAAcnD,EAAYR,GAE7D4B,EAAY,GAIlB,OAHIuC,GACFvC,EAAU/+B,KAAKshC,QAEFjoC,IAAXH,GAMJ6lC,EAAU/+B,KACR,OAAM,IAAA2hC,aAAYzoC,MAAW2nC,GAAcnnC,IAC3C,OAAM,IAAAioC,aAAYhyC,MAAUmxC,GAAapnC,KAPlCqlC,CAWX,CAEAlJ,EAAkBvG,SAAW,gBAC7B,0VC9xCA,MAAM,sBAAEsS,GAA0B,EAAAC,UAC5B,QAAEC,GAAY,EAAAC,UAEdC,EAAqB,EAAIF,EAgE/B,MAAMG,UAA8B,IA+DlC,WAAAl0C,CACE+nC,EAA6B,CAAC,EAC9BC,EAA8B,CAC5BC,0BAA2B,CAAC,QAAS,SACrCxG,cAAe,CACbiO,QAAQ,EACRxH,2BAA2B,EAK3BiM,+BAAgC,EAAAC,iBAAiBC,MACjDC,+BAAgC,CAG9Bn2B,SAAS,EAETo2B,OAAQ,GAEVC,mBAAmB,EAEnBC,sBAAuB,GAGvBC,iCAAkC,EAIlCC,eAAe,EAOfC,mBAAoB,EAMpBC,UAAW,CACTC,aAAa,EACbC,cAAc,EACdC,0BAA2B,GAC3BC,2BAA4B,IAS9BC,cAAe,CACb/2B,SAAS,EAGTg3B,wBAAyB,MAM3BC,SAAU,CACRj3B,SAAS,EAKTk3B,QAAS,IAEXC,6BAA6B,EAC7BC,gBAAgB,EAChBpN,aAAcC,EACdoN,gBAAiB,EAAAC,wBAIrBv1C,MAAM6nC,EAAWC,GAvInB,KAAAgD,WAAY,EACZ,KAAA0K,iBAAkB,EAClB,KAAAC,eAAgB,EA8JhB,KAAAtC,iBACExoC,IAEA,MAAMi4B,EAAcj4B,EAAImrB,QAClB,QAAE51B,GAAY0iC,EACd3rB,GAAiB,IAAA6T,mBAAkB5qB,IACnC,gBAAEmS,GAAoB4E,EAEtBmxB,EAAajnC,KAAKu0C,iBACtB/qC,GAGFxJ,KAAKmyC,cAAclL,EAAYloC,GAE/B,MAAM6oC,GAAsB,IAAAC,gCAC1B9oC,EACAiB,KAAK8nC,eASP,OANA9nC,KAAKw0C,aAAahrC,EAAKy9B,EAAYW,GAEnCp+B,EAAI2+B,kBAEJ,OAAsCj3B,EAAiB02B,GAEhDX,CAAU,EAYnB,KAAAmB,uBAAyB,CACvB5+B,EACAy9B,EACAoB,KAEA,MAAM5G,EAAcj4B,EAAImrB,QAClB,QAAE51B,GAAY0iC,EAEdmG,GAAsB,IAAAC,gCAC1B9oC,EACAiB,KAAK8nC,eAGP9nC,KAAKy0C,2BACHjrC,EACAy9B,EACAW,EACAS,EACD,EAMH,KAAAX,qBAAuB,CACrBl+B,EACAy9B,KAEA,MAAMxF,EAAcj4B,EAAImrB,QAClB,QAAE51B,GAAY0iC,EAEdmG,GAAsB,IAAAC,gCAC1B9oC,EACAiB,KAAK8nC,eAGHb,EAAWn8B,KAAK4pC,QAAQC,OAC1B30C,KAAK40C,0BAA0BprC,EAAKy9B,EAAYW,GAEhD5nC,KAAK60C,wBAAwBrrC,EAAKy9B,EAAYW,GAGhDp+B,EAAI2+B,gBAAgB,EActB,KAAAnB,gBAAkB,CAChBjoC,EACAkoC,EACAC,EACAC,KAEA,MAAMrxB,GAAiB,IAAA6T,mBAAkB5qB,IACnC,SAAE0E,GAAaqS,GAEb28B,SAAUrL,GAAWH,EAAWn8B,KAAK4pC,QAI7C,IAAII,EAAgBrxC,EAAS1B,cAAcqlC,EAAO,IAElD,IAAK,IAAIp+B,EAAI,EAAGA,EAAIo+B,EAAOt9B,OAAQd,IAAK,CACtC,MAAM+rC,EAAKD,EACLE,EAAKvxC,EAAS1B,cAAcqlC,EAAOp+B,IAGzC,GAFmBwpC,EAAsBtL,EAAc6N,EAAIC,EAAI7N,GAG7D,OAAO,EAGT2N,EAAgBE,CAClB,CAEA,IAAK/N,EAAWn8B,KAAK4pC,QAAQC,OAE3B,OAAO,EAIT,MAAMM,EAASxxC,EAAS1B,cAAcqlC,EAAO,IACvC8N,EAAOzxC,EAAS1B,cAAcqlC,EAAOA,EAAOt9B,OAAS,IAE3D,OAAO0oC,EAAsBtL,EAAc+N,EAAQC,EAAM/N,EAAU,EAG9D,KAAAjZ,OAAUnvB,IACf,MAAM4qC,EAAY3pC,KAAK2pC,UACjB2K,EAAgBt0C,KAAKs0C,cACrBD,EAAkBr0C,KAAKq0C,gBAEzB1K,EACF3pC,KAAKm1C,cAAcp2C,GACVu1C,EACTt0C,KAAKo1C,sBAAsBr2C,GAClBs1C,GACTr0C,KAAKq1C,wBAAwBt2C,EAC/B,EAgSM,KAAA0vC,sBAAwB,CAC9BxH,EACAxjC,EACAyN,EACA4E,KAEA,MAAM,KAAEhL,GAASm8B,GACX,YAAEsH,GAAgBzjC,GAChB2nC,SAAUrL,EAAM,OAAEuN,GAAW7pC,EAAK4pC,QAEpCjE,EAAY5kC,OAAOyU,KAAKiuB,GAE9B,IAAK,IAAIvlC,EAAI,EAAGA,EAAIynC,EAAU3mC,OAAQd,IAAK,CACzC,MAAM+kC,EAAW0C,EAAUznC,GACrB5D,EAAQpF,KAAK0wC,iBAAiB3C,EAAU78B,GAK9C,IAAK9L,EACH,SAGF,MAAM,UAAE4F,EAAS,SAAEhD,GAAa5C,EAC1B8oC,EAAoB9G,EAAO7kC,KAAKimC,GAAM/kC,EAAS1B,cAAcymC,KAI7Dl9B,EAAc4iC,EAAkB,GAChCoH,EAAqB7xC,EAASnC,cAAcgK,GAC5CiqC,EAAc9xC,EAASnC,cAAc,CACzCgK,EAAY,GAAK,EACjBA,EAAY,KAERkqC,EAAc/xC,EAASnC,cAAc,CACzCgK,EAAY,GACZA,EAAY,GAAK,IAGbmqC,EAAW,cAAcH,EAAoBC,GAC7CG,EAAW,cAAcJ,EAAoBE,GAE7CG,EAAgB,kCAA8B3qC,EAAWo8B,EAAO,IACtEuO,EAAc,GAAK/0C,KAAK6O,MAAMkmC,EAAc,IAC5CA,EAAc,GAAK/0C,KAAK6O,MAAMkmC,EAAc,IAC5CA,EAAc,GAAK/0C,KAAK6O,MAAMkmC,EAAc,IAE5C,IAAIC,EAAOD,EAAc,GACrBE,EAAOF,EAAc,GAErBG,EAAOH,EAAc,GACrBI,EAAOJ,EAAc,GAErBK,EAAOL,EAAc,GACrBM,EAAON,EAAc,GAEzB,IAAK,IAAIO,EAAI,EAAGA,EAAI9O,EAAOt9B,OAAQosC,IAAK,CACtC,MAAMP,EAAgB,kCACpB3qC,EACAo8B,EAAO8O,IAETP,EAAc,GAAK/0C,KAAK6O,MAAMkmC,EAAc,IAC5CA,EAAc,GAAK/0C,KAAK6O,MAAMkmC,EAAc,IAC5CA,EAAc,GAAK/0C,KAAK6O,MAAMkmC,EAAc,IAC5CC,EAAOh1C,KAAK2W,IAAIq+B,EAAMD,EAAc,IACpCE,EAAOj1C,KAAKsM,IAAI2oC,EAAMF,EAAc,IAEpCG,EAAOl1C,KAAK2W,IAAIu+B,EAAMH,EAAc,IACpCI,EAAOn1C,KAAKsM,IAAI6oC,EAAMJ,EAAc,IAEpCK,EAAOp1C,KAAK2W,IAAIy+B,EAAML,EAAc,IACpCM,EAAOr1C,KAAKsM,IAAI+oC,EAAMN,EAAc,GACtC,CAEA,MAAMQ,EAAiB,kCACrBnrC,EACAo8B,EAAO,IAET+O,EAAe,GAAKv1C,KAAK6O,MAAM0mC,EAAe,IAC9CA,EAAe,GAAKv1C,KAAK6O,MAAM0mC,EAAe,IAC9CA,EAAe,GAAKv1C,KAAK6O,MAAM0mC,EAAe,IAE9C,MAAM,MAAElmC,EAAK,UAAEmmC,IAAc,QAC3BhxC,GACA,KACE,MAAMqtC,EAAW3nC,EAAK4pC,QAAQjC,SACxB4D,EAAY5D,EAAS3oC,OACrBwsC,EAAoB,IAAIhvC,MAAM+uC,GAEpC,IAAK,IAAIrtC,EAAI,EAAGA,EAAIqtC,EAAWrtC,IAC7BstC,EAAkBttC,GAAKvF,EAAS1B,cAAc0wC,EAASzpC,IAGzD,MACEutC,KAAMC,EACNC,KAAMC,EACNC,KAAMC,EACNC,KAAMC,GACJ,EAAAC,KAAA,iBAAsBT,GAEpBU,EAAiBvzC,EAASnC,cAAc,CAC5Cs1C,EACAE,IAGIG,EAAiB,kCACrBjsC,EACAgsC,GAGIE,EAAqBzzC,EAASnC,cAAc,CAChDk1C,EACAE,IAQF,MAAO,CAACO,EALmB,kCACzBjsC,EACAksC,GAGyC,IAG/C,IAAIC,EAAO,EAAA1E,SAAA,QAAiBvE,GAAqBj+B,EAAQA,EAEzDknC,GAAQ1B,EAAWC,EAGnB,MAAM0B,EAAS,KAAQvB,EAAOD,GACxByB,EAAS,KAAQtB,EAAOD,GACxBwB,EAAS,KAAQrB,EAAOD,GAE9BJ,EAAOh1C,KAAK6O,MAAMmmC,EAAOwB,GACzBvB,EAAOj1C,KAAK22C,KAAK1B,EAAOuB,GACxBtB,EAAOl1C,KAAK6O,MAAMqmC,EAAOuB,GACzBtB,EAAOn1C,KAAK22C,KAAKxB,EAAOsB,GACxBrB,EAAOp1C,KAAK6O,MAAMumC,EAAOsB,GACzBrB,EAAOr1C,KAAK22C,KAAKtB,EAAOqB,GAExB,MAAME,EAAY,CAChB,CAAC5B,EAAMC,GACP,CAACC,EAAMC,GACP,CAACC,EAAMC,IAGHwB,EAAczsC,EAAUQ,aAAa,CAACqqC,EAAME,EAAME,IAClDyB,EAAej0C,EAAS1B,cAAc01C,GAE5C,IAAIE,EAAS,EACTC,EAAgB,GAChBC,EAAsB,EAC1B,MAAMC,GAAgB,OACpB9sC,GACA,CAAC+sC,EAAUC,KACT,IAAIC,GAAS,EACb,MAAM5sC,EAAQ5H,EAAS1B,cAAcg2C,GA4BrC,OA3BI1sC,EAAM,IAAMssC,IACdE,EAAsB,EACtBF,EAAStsC,EAAM,GACfusC,GAAgB,IAAAM,wCACdhK,EACA7iC,EACA,CAACqsC,EAAa,GAAIrsC,EAAM,KAE1BusC,EAAclkC,MAEH,SAAUZ,EAAGC,GAClB,OAAOD,EAMR,KANqBC,EAMrB,GALK,EACAD,EAIL,GAJgBC,EAIhB,IAHM,EACD,CACN,KAIF6kC,EAAc9tC,QAAUuB,EAAM,GAAKusC,EAAc,GAAG,KACtDA,EAAchgC,QACdigC,KAEEA,EAAsB,GAAM,IAC9BI,GAAS,GAEJA,CAAM,GAEfj4C,KAAKogC,cAAc+T,gBAAgBgE,cACnCX,GAGIY,EAAsB,CAC1B9/B,aAAa,OAAoB7U,EAAUsqC,GAC3CsK,YAAar4C,KAAKq4C,YAChB50C,EACAsqC,EACA9G,EAAWj/B,SAASqG,oBAIlBiqC,GAAe,OACnBtwC,EAASD,SACTk/B,EAAWj/B,SAASqG,kBACpB+pC,GAGIpiC,EAAQhW,KAAKogC,cAAc+T,gBAAgBoE,gBAEjDhK,EAAYR,GAAY,CACtBhmC,SAAUC,EAASD,SACnBovC,OACAqB,WAAW,OAAmBtK,EAAmByG,GACjD8D,KAAMziC,EAAMyiC,MAAMn5B,MAClBpS,IAAK8I,EAAM9I,KAAKoS,MAChBo5B,OAAQ1iC,EAAM0iC,QAAQp5B,MACtBq5B,WAAY3iC,EAAMhE,MAClB8lC,cAAeA,EACfc,SAAUxC,EACVkC,eAEJ,CAUA,OARA,QACErR,EACAnxB,EAAerS,SAAS1E,QACxB,EAAA85C,YAAYC,cAGd7R,EAAWlxB,aAAc,EAElBw4B,CAAW,EAGZ,KAAAwK,aAAe,CACrB9R,EACAxjC,EACAqS,EACA4oB,KAEA,MAAM,KAAE5zB,GAAsCm8B,EACxC8G,EAAW/tC,KAAKguC,YAAYvqC,GAE5BwqC,EAAiD,CACrDrN,YAAa5gC,KAAK4gC,YAClBV,SAAUlgC,KAAK8nC,cACfvkC,WAAYuS,EAAerS,SAASD,IAGhCyD,EAAUjH,KAAKovC,sBAAsBnB,EAAgBhH,GAC3D,IAAKhgC,EAAQooC,WACX,OAGF,MAAMM,EAAY3vC,KAAKogC,cAAc0G,aAAah8B,EAAMijC,GACxD,IAAK4B,GAAkC,IAArBA,EAAU7lC,OAC1B,OAGF,MAAMokC,EAAoBpjC,EAAK4pC,QAAQjC,SAASlwC,KAAKimC,GACnD/kC,EAAS1B,cAAcymC,KAEzB,IAAK19B,EAAKu8B,QAAQyD,QAAQnC,SAAU,CAClC,MAAMiH,GAAsB,IAAAC,wBAAuB3B,GAEnDpjC,EAAKu8B,QAAQyD,QAAQvC,cACnB9kC,EAASnC,cAAcsuC,EAC3B,CAEA,MAAME,EAAkBrsC,EAAS1B,cAC/B+I,EAAKu8B,QAAQyD,QAAQvC,eAIjByH,GAAc,IAAAC,mBAClBvR,EACAuI,EAAWyC,eAAiB,GAHX,IAKjBiG,EACAG,EACA5B,EACA,CAAC,EACDjnC,IAGMwL,EAAGP,EAAMiF,EAAG+4B,EAAG,MAAE3vC,EAAK,OAAEC,GAAWwvC,EAE3CllC,EAAKu8B,QAAQyD,QAAQwE,iBAAmB,CACtCC,QAAS9rC,EAASnC,cAAc,CAAC4Q,EAAMg+B,IACvCV,SAAU/rC,EAASnC,cAAc,CAAC4Q,EAAO3R,EAAO2vC,IAChDT,WAAYhsC,EAASnC,cAAc,CAAC4Q,EAAMg+B,EAAM1vC,IAChDkvC,YAAajsC,EAASnC,cAAc,CAAC4Q,EAAO3R,EAAO2vC,EAAM1vC,IAC1D,GAruBD,OAAiBR,OACjB,OAAuBA,OACvB,OAA8BA,OAC9B,OAA4BA,OAC5B,OAA+BA,OAC/B,OAAsBA,MAEtBA,KAAKwuC,gCAAiC,OACpCxuC,KAAKyuC,sBACL,IACA,CAAEsD,UAAU,GAEhB,CAgKO,uCAAAjE,CACL/uC,EACA6uC,GAEA,IAAKA,IAAgBA,EAAY9jC,OAC/B,OAGF,MAAMgM,GAAiB,IAAA6T,mBAAkB5qB,IACnC,SAAE0E,GAAaqS,EAErB,IAAIkjC,EAEJ,GAAIv1C,aAAoB,EAAAw1C,eAAgB,CACtC,MAAMvrC,EAASjK,EAASuL,aAElB,yBAAE4nB,GACN,iDAA6CnzB,EAAUiK,GAGzDsrC,EAAuBh5C,KAAKk5C,6BAC1BtL,EACAlgC,EACAkpB,EAEJ,MAGEoiB,GAAuB,IAAAG,6BAA4B11C,EAAUmqC,GAG/D,OAAOoL,CACT,CAOQ,4BAAAE,CACNtL,EACAlgC,EACAkpB,GAEA,MAAM,gBAAExnB,GAAoB1B,EAEtB0rC,EAAiCxL,EAAYpgC,QAChD6rC,IACC,MAAMC,EAA4BD,EAAGrxC,SAASoH,gBAExCmqC,EACJ34C,KAAK44C,IAAI,SAASpqC,EAAiBkqC,IACnC1G,EAEF,OAAO0G,GAA6BC,CAAU,IAKlD,IAAKH,EAA+BtvC,OAClC,MAAO,GAMT,MAAM2vC,EAA+B7iB,EAA2B,GAC1D,WAAEjpB,GAAeD,EAEjBgsC,EAAyB,GAE/B,IAAK,MAAMzS,KAAcmS,EAAgC,CACvD,MACM/tC,EADO47B,EAAWn8B,KACL4pC,QAAQjC,SAAS,GAEpC,IAAKxL,EAAW0S,UACd,SAUF,MAAMC,EAAM,cAEZ,SAASA,EAAKjsC,EAAYtC,GAE1B,MAAMwuC,EAAM,SAASD,EAAKxqC,GAEtBxO,KAAK44C,IAAIK,GAAOJ,GAClBC,EAAuB9oC,KAAKq2B,EAEhC,CAEA,OAAOyS,CACT,CAEU,yBAAAI,GAGR,OAAO,CACT,CAEU,gBAAAvF,CAAiB/qC,GACzB,MAAMxH,EAAWwH,EAAImrB,OAAOkV,cAAcC,MACpCiQ,EAAoBl7C,MAAM01C,iBAAiB/qC,GAqBjD,OAdgD,sBAC9CuwC,EACA,CACEjvC,KAAM,CACJ4pC,QAAS,CACPjC,SAAU,CAAe,IAAIzwC,KAE/BkwC,MAAO,GACP3D,YAAa,CAAC,GAEhBuF,wBAf6B7M,IAE/BA,EAAWn8B,KAAKu8B,QAAQD,OAAOt9B,OAAS,CAAC,GAkB7C,CAEU,kBAAAwkC,CAAmB1jC,GAG3B,OAAO/L,MAAMyvC,mBAAmB1jC,EAClC,CAEU,wBAAAovC,CACRC,GAEA,MAAM,eAAEnkC,EAAc,SAAEi4B,EAAQ,iBAAErP,GAAqBub,EACjDhT,EAAagT,EAAchT,WAEjC,IAAI0G,GAAe,EACnB,MAAM,SAAElqC,EAAQ,gBAAEyN,GAAoB4E,EAEhC6zB,EAAY3pC,KAAK2pC,UACjB2K,EAAgBt0C,KAAKs0C,cACrBD,EAAkBr0C,KAAKq0C,gBAE7B,GAAM1K,GAAa2K,GAAiBD,EAe7B,CAIL,MAAM6F,EAAsBl6C,KAAKm6C,WAAWlT,WAAWyC,cAEvD,GAAIzC,EAAWyC,gBAAkBwQ,EAC/B,GAAIvQ,EACF3pC,KAAKo6C,wBACHtkC,EACA4oB,EACAuI,QAEG,GAAIoN,EACTr0C,KAAKq6C,+BACHvkC,EACA4oB,EACAuI,OAEG,KAAIqN,EAOT,MAAM,IAAI3sC,MACR,WAAW3H,KAAK8nC,4CAPlB9nC,KAAKs6C,6BACHxkC,EACA4oB,EACAuI,EAMJ,MAGEjnC,KAAKogC,cAAc6T,6BACyB,IAA5ChN,EAAWn8B,KAAK4pC,QAAQjC,SAAS3oC,OAEjC9J,KAAKu6C,6BACHzkC,EACA4oB,EACAuI,GAGFjnC,KAAKw6C,cAAc1kC,EAAgB4oB,EAAkBuI,GAKzD0G,GAAe,CACjB,MA1DI3tC,KAAKogC,cAAc6T,6BACyB,IAA5ChN,EAAWn8B,KAAK4pC,QAAQjC,SAAS3oC,OAEjC9J,KAAKu6C,6BACHzkC,EACA4oB,EACAuI,GAGFjnC,KAAKw6C,cAAc1kC,EAAgB4oB,EAAkBuI,GAmDzD,GAAKjnC,KAAKogC,cAAc8T,eAcxB,OAVAl0C,KAAKy6C,wBACHxT,EACA8G,EACAtqC,EACAyN,EACA4E,GAGF9V,KAAK+4C,aAAa9R,EAAYxjC,EAAUqS,EAAgB4oB,GAEjDiP,CACT,CAEA,uBAAA8M,CACExT,EACA8G,EACAtqC,EACAyN,EACA4E,GAEA,MAAMokC,EAAsBl6C,KAAKm6C,YAAYlT,WAAWyC,cAExD,IACEzC,EAAWyC,gBAAkBwQ,GAC5Bl6C,KAAKm6C,YAAYnS,iBAKfhoC,KAAKm6C,YAAYnS,cAAe,CACnC,MAAM,KAAEl9B,GAASm8B,EAEdn8B,EAAKyjC,YAAYR,IACqB,MAAvCjjC,EAAKyjC,YAAYR,GAAU6K,SAiBlB3R,EAAWlxB,aACpB/V,KAAKwuC,+BACHvH,EACAxjC,EACAyN,EACA4E,IApBFhL,EAAKyjC,YAAYR,GAAY,CAC3BhmC,SAAU,KACVovC,KAAM,KACNjqC,IAAK,KACLurC,KAAM,KACNC,OAAQ,KACRE,SAAU,MAGZ54C,KAAKyuC,sBACHxH,EACAxjC,EACAyN,EACA4E,GAUN,CACF,EAuSF,SAASixB,EAAoBj8B,EAAMijC,GACjC,MAAM2M,EAAoB5vC,EAAKyjC,YAAYR,IACrC,KACJoJ,EAAI,KACJsB,EAAI,OACJC,EAAM,UACNF,EAAS,IACTtrC,EAAG,YACHytC,EAAW,SACX/B,EAAQ,aACRN,GACEoC,GAAqB,CAAC,EAEpB/K,EAAsB,GAE5B,GAAIwH,EAAM,CACR,MAAMyD,EAAWD,EACb,8BACA,UAAS,IAAApI,aAAY4E,MAASyB,IAClCjJ,EAAU/+B,KAAKgqC,EACjB,CAkBA,OAhBInC,GACF9I,EAAU/+B,KAAK,UAAS,IAAA2hC,aAAYkG,MAASH,KAG3C1pC,OAAOisC,SAAS3tC,IAClByiC,EAAU/+B,KAAK,SAAQ,IAAA2hC,aAAYrlC,MAAQorC,KAGzCI,GACF/I,EAAU/+B,KAAK,aAAY,IAAA2hC,aAAYmG,MAAWJ,KAGhDE,GACF7I,EAAU/+B,KAAK,eAAc,IAAA2hC,aAAYiG,MAAcF,KAGlD3I,CACT,CAEAkD,EAAsB3S,SAAW,oBACjC,iMChgCA,MAAM4a,EAAwB,IAAsC5a,SAuBpE,MAAM6a,UAAgC,KAEpC,WAAAp8C,CACE+nC,EAA6B,CAAC,EAC9BC,EAA8B,CAC5BvG,cAAe,CAAC,IAGlBvhC,MAAM6nC,EAAWC,GA0DnB,KAAAqU,mBAAsBpa,IACpB,MAAMwE,GAAY,IAAA6V,cAAara,GAE/B,IAAKwE,EACH,OAGF,MAAM8V,GACJ,IAAAC,gCAA+Bva,GAEjC,IACGsa,GAC+C,IAAhDA,EAAqCpxC,OAErC,OAIF,MAAMsxC,EAAqBhW,EAAU/F,cAAc98B,KACjD,EAAGmB,oBAAmBH,iBACpB,MAAMuS,GAAiB,IAAAiU,wBACrBxmB,EACAG,GAGF,GAAIoS,EACF,OAAOA,EAAerS,QACxB,IAKE43C,EAAyBH,EAAqC34C,KACjE+4C,IACC,MAAMC,EAASv7C,KAAKw7C,gCAAgC5a,GAE9C6a,EAAsB,GAEtBC,EAAY,CAChB,CAAC,UAAgBC,UAAW,KAC5B,CAAC,UAAgBC,SAAU,IAC3B,CAAC,UAAgBC,SAAU,KAGzBP,EAAe3+B,OAAS,UAA4Bi/B,SAGtD57C,KAAK87C,8BAA8Blb,GAGrC,MAAMmb,EAAUL,EAAUJ,EAAe3+B,MAEzC,IAAK,MAAMlZ,KAAY23C,EAAoB,CACzC,MAAMY,EAAmBD,EAAQ34C,OAC/BK,EACA63C,EACAC,GAGFE,EAAoB7qC,KAAKorC,EAC3B,CACA,OAAOP,CAAmB,IAI9BnzC,QAAQ2zC,WAAWZ,GAAwBjzC,MAAK,KAE9CgzC,EAAmB7qC,SAAS9M,IAC1BA,EAASL,QAAQ,GACjB,GACF,CA/HJ,CAEA,gBAAA+gC,GACE,MAAMvD,EAAc5gC,KAAK4gC,YACnBsa,GACJ,IAAAC,gCAA+Bva,GAG9Bsa,GAC+C,IAAhDA,EAAqCpxC,QAMvCoxC,EAAqC3qC,SAClC2rC,KACC,IAAAC,2BACEvb,EACAsb,EAA2BE,+BAC3B,EACD,GAGP,CAEA,iBAAAhY,GACE,MAAMxD,EAAc5gC,KAAK4gC,YACnBsa,GACJ,IAAAC,gCAA+Bva,GAG9Bsa,GAC+C,IAAhDA,EAAqCpxC,QAMvCoxC,EAAqC3qC,SAClC2rC,KACC,IAAAC,2BACEvb,EACAsb,EAA2BE,+BAC3B,EACD,GAGP,CAkFA,6BAAAN,CAA8Blb,GAGtBka,KAAyB,KAAMxa,QACnC,QAAQ,KAGV,MAAM8E,GAAY,IAAA6V,cAAara,GAG1BwE,EAAUnF,QAAQ6a,KACrB1V,EAAUjF,QAAQ2a,GAClB1V,EAAU9C,eAAewY,GAE7B,CAOA,+BAAAU,CACE5a,GAEA,MAAMyb,EACJ,oCAA8Czb,GAC1C0b,EAAe,2BAKrB,OAFqB,sBAAkBA,EAAcD,EAGvD,EAGFtB,EAAwB7a,SAAW,sBACnC,wpBC1LA,MAAMqc,UAAkCC,EAAA,EAatC,WAAA79C,CACE+nC,EAA6B,CAAC,EAC9BC,EAA8B,CAC5BC,0BAA2B,CAAC,QAAS,SACrCxG,cAAe,CACbiO,QAAQ,EACRxH,2BAA2B,KAI/BhoC,MAAM6nC,EAAWC,GAWnB,KAAAqL,iBAAoBxoC,IAClB,MAAMi4B,EAAcj4B,EAAImrB,QAClB,cAAEkV,EAAa,QAAE9qC,GAAY0iC,EAC7Bz/B,EAAW6nC,EAAcC,MAEzBh0B,GAAiB,IAAA6T,mBAAkB5qB,IACnC,SAAE0E,EAAQ,gBAAEyN,GAAoB4E,EAEtC9V,KAAK2pC,WAAY,EAEjB,MAAMj8B,EAASjK,EAASuL,aAClB,gBAAEI,EAAe,OAAED,GAAWzB,EAE9BqgC,EAAW/tC,KAAKguC,YAAYvqC,GAClC,IAAI4K,EAAmB2L,EAEvB,GAAIvW,aAAoB,EAAAg5C,cACtBpuC,EAAoB0/B,EAASp/B,MAAM,YAAY,OAC1C,CACLqL,EAAW,wBAAoB+zB,GAC/B,MAAM7zB,EAAc,EAAAwiC,MAAMl3B,UAAUxL,GACpC3L,EAAoB,8BAClB6L,EACAlY,EACAoN,EAEJ,CAEA,MAAM6a,EAAsBxmB,EAASxC,yBAG/BgmC,EAAa,CACjBU,aAAa,EACb5xB,aAAa,EACb/N,SAAU,CACRoH,gBAA+B,IAAIA,GACnC0G,iBACA3G,OAAsB,IAAIA,GAC1B8a,sBACA5b,oBACA6xB,SAAUlgC,KAAK8nC,cACf9tB,YAEFlP,KAAM,CACJonC,MAAO,GACP7K,QAAS,CAEPyD,QAAS,CACPnC,UAAU,EACVJ,cAAe,KACf+G,iBAAkB,MAEpBlI,OAAQ,CACQ,IAAIplC,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,IAEpB4mC,kBAAmB,MAErB+T,eAAgB,QAIpB,QAAc1V,EAAYloC,GAE1B,MAAM6oC,GAAsB,IAAAC,gCAC1B9oC,EACAiB,KAAK8nC,eAkBP,OAfA9nC,KAAK+nC,SAAW,CACdd,aACAW,sBACAU,YAAa,EACbI,eAAe,EACfC,UAAU,GAEZ3oC,KAAKitC,cAAcluC,IAEnB,IAAAmpC,mBAAkBnpC,GAElByK,EAAI2+B,kBAEJ,EAAAyU,EAAA,GAAsC1rC,EAAiB02B,GAEhDX,CAAU,EAUnB,KAAAyG,iBAAmB,CACjB53B,EACA4oB,KAEA,IAAIiP,GAAe,EACnB,MAAM,SAAElqC,GAAaqS,GACf,QAAE/W,GAAY0E,EACpB,IAAImqC,GAAc,QAAe5tC,KAAK8nC,cAAe/oC,GAErD,IAAK6uC,GAAa9jC,OAChB,OAAO6jC,EAQT,GALAC,EAAc5tC,KAAK8tC,wCACjB/uC,EACA6uC,IAGGA,GAAa9jC,OAChB,OAAO6jC,EAGT,MAAMM,EAAiC,CACrCrN,YAAa5gC,KAAK4gC,YAClBV,SAAUlgC,KAAK8nC,cACfvkC,WAAYuS,EAAerS,SAASD,IAGtC,IAAK,IAAIwF,EAAI,EAAGA,EAAI4kC,EAAY9jC,OAAQd,IAAK,CAC3C,MAAMi+B,EAAa2G,EAAY5kC,IACzB,cAAE0gC,EAAa,KAAE5+B,GAASm8B,GAC1B,OAAEG,EAAM,kBAAEwB,GAAsB99B,EAAKu8B,QACrC6G,EAAoB9G,EAAO7kC,KAAKimC,GAAM/kC,EAAS1B,cAAcymC,KAEnEyF,EAAevE,cAAgBA,EAE/B,MAAMyE,EAAYnuC,KAAK68C,SAAS,YAAa5O,EAAgBhH,GACvDmH,EAAWpuC,KAAK68C,SAAS,WAAY5O,EAAgBhH,GACrD3wB,EAAQ,qBAGd,IAAK7S,EAASiiC,qBAEZ,OADAr0B,QAAQC,KAAK,uCACNq8B,EAQT,IAAIe,EAEJ,IAJA,QAA0BzH,EAAYloC,KAIjC,IAAA4vC,qBAAoBjF,GACvB,SAYF,IARG,IAAAkF,oBAAmB3H,IACnBjnC,KAAK+nC,UACgB,OAAtBa,IAGA8F,EAA2B,CAACR,EAAkBtF,KAG5C8F,EAA0B,CAC5B,MAAMG,EAAiB,KAEvB,IAAAC,aACEpQ,EACAgL,EACAmF,EACAH,EACA,CACEp4B,SAGN,CAEA,MAAMwmC,EAAe,KACrB,IAAAC,UACEre,EACAgL,EACAoT,EACA5O,EAAkB,GAClBA,EAAkB,GAClB,CACE53B,QACA83B,WACAD,cAIJR,GAAe,CACjB,CAEA,OAAOA,CAAY,CA3MrB,EA+MF4O,EAA0Brc,SAAW,wBACrC,+CClOA,MAAM,sBAAEvI,GAA0B,YAclC,MAAMqlB,UAA0CR,EAAA,EAa9C,WAAA79C,CACE+nC,EAA6B,CAAC,EAC9BC,EAA8B,CAC5BvG,cAAe,CACb6c,qBAAsB,GACtBC,2BAA2B,KAI/Br+C,MAAM6nC,EAAWC,GAiBnB,KAAAqL,iBAAoBxoC,IAClB,MAAMi4B,EAAcj4B,EAAImrB,QAClB,cAAEkV,EAAa,QAAE9qC,GAAY0iC,EAC7Bz/B,EAAW6nC,EAAcC,MAEzBh0B,GAAiB,IAAA6T,mBAAkB5qB,IACnC,SAAE0E,EAAQ,gBAAEyN,GAAoB4E,EAEtC9V,KAAK2pC,WAAY,EAEjB,MAAMj8B,EAASjK,EAASuL,aAClB,gBAAEI,EAAe,OAAED,GAAWzB,EAEpC,IAAIW,EAAmB6L,EAAaF,EACpC,GAAIvW,aAAoB,EAAAg5C,cACtB,MAAM,IAAI90C,MAAM,kCACX,CACL,MAAMomC,EAAW/tC,KAAKguC,YAAYvqC,GAClCuW,EAAW,wBAAoB+zB,GAC/B7zB,EAAc,EAAAwiC,MAAMl3B,UAAUxL,GAC9B3L,EAAoB,8BAClB6L,EACAlY,EACAoN,EAEJ,CAEA,IAAKf,EACH,MAAM,IAAI1G,MAAM,qDAGlB,MAAMw1C,EAAa15C,EAASsL,yBACtBquC,EAAkB,wCACtBljC,EACA9K,GAOIiuC,EAAWr9C,KAAKs9C,kBACpBpjC,EACAlY,EACAo7C,EACAhuC,GAGI6a,EAAsBxmB,EAASxC,yBAE/BgmC,EAAa,CACjBU,aAAa,EACb5xB,aAAa,EACb/N,SAAU,CACRoH,gBAA+B,IAAIA,GACnC0G,iBACA3G,OAAsB,IAAIA,GAC1B8a,sBACA5b,oBACA6xB,SAAUlgC,KAAK8nC,cACf9tB,WACAojC,mBAEFtyC,KAAM,CACJonC,MAAO,GACPqL,WAAYJ,EACZK,SAAUH,EACV9O,YAAa,CACXkP,eAAgB,GAChBC,iBAAkB,GAClBC,yBAA0B,CAACtvC,IAE7Bg5B,QAAS,CAEPyD,QAAS,CACPnC,UAAU,EACVJ,cAAe,KACf+G,iBAAkB,MAEpBlI,OAAQ,CACQ,IAAIplC,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,IAEpB4mC,kBAAmB,MAErBgV,YAAa,OAOjB59C,KAAK69C,yBAAyB5W,EAAY/sB,IAE1C,QAAc+sB,EAAYloC,GAE1B,MAAM6oC,GAAsB,IAAAC,gCAC1B9oC,EACAiB,KAAK8nC,eAkBP,OAfA9nC,KAAK+nC,SAAW,CACdd,aACAW,sBACAU,YAAa,EACbI,eAAe,EACfC,UAAU,GAEZ3oC,KAAKitC,cAAcluC,IAEnB,IAAAmpC,mBAAkBnpC,GAElByK,EAAI2+B,kBAEJ,EAAAyU,EAAA,GAAsC1rC,EAAiB02B,GAEhDX,CAAU,EAGnB,KAAAwB,aAAgBj/B,IACd,MAAMi4B,EAAcj4B,EAAImrB,QAClB,QAAE51B,GAAY0iC,GAEd,WAAEwF,EAAU,oBAAEW,EAAmB,cAAEc,EAAa,SAAEC,GACtD3oC,KAAK+nC,UACD,KAAEj9B,GAASm8B,EAEjB,GAAIyB,IAAkBC,EACpB,OAGF79B,EAAKu8B,QAAQuB,kBAAoB,KAEjC5oC,KAAK6oC,kBAAkB9pC,GACvBiB,KAAK8oC,gBAAgB/pC,IAErB,IAAAgqC,oBAAmBhqC,GAEnB,MAAM+W,GAAiB,IAAA6T,mBAAkB5qB,GAEzCiB,KAAK+nC,SAAW,KAChB/nC,KAAK2pC,WAAY,EAGf3pC,KAAKwpC,sBACLxpC,KAAKogC,cAAcyG,4BAEnB,QAAiBI,EAAWyC,eAG9B,MAAMqE,EAAW/tC,KAAKguC,YAAYl4B,EAAerS,UAC3CyW,EAAc,EAAAwiC,MAAMl3B,UAAUuoB,EAASp/B,MAAM,gBAAgB,IAE/D3O,KAAKogC,cAAc0d,6BACrB99C,KAAK+9C,2BAA2B9W,EAAY/sB,EAAapE,IAG3D,EAAA8mC,EAAA,GACE9mC,EAAe5E,gBACf02B,GAGEc,IACF,QAA2BzB,EAC7B,EAkKF,KAAAyG,iBAAmB,CACjB53B,EACA4oB,KAEA,IAAIiP,GAAe,EACnB,MAAM,SAAElqC,GAAaqS,EAEf83B,GAAc,QAAe5tC,KAAK8nC,cAAerkC,EAAS1E,SAEhE,IAAK6uC,GAAa9jC,OAChB,OAAO6jC,EAGT,MAAMvmC,EAAa3D,EAASsL,yBAEtBk/B,EAAiC,CACrCrN,YAAa5gC,KAAK4gC,YAClBV,SAAUlgC,KAAK8nC,cACfvkC,WAAYuS,EAAerS,SAASD,IAGtC,IAAK,IAAIwF,EAAI,EAAGA,EAAI4kC,EAAY9jC,OAAQd,IAAK,CAC3C,MAAMi+B,EAAa2G,EACjB5kC,IAEI,cAAE0gC,EAAa,KAAE5+B,GAASm8B,GAC1B,WAAEsW,EAAU,SAAEC,GAAa1yC,GAC3B,OAAEs8B,EAAM,kBAAEwB,GAAsB99B,EAAKu8B,QAErC6G,EAAoB9G,EAAO7kC,KAAKimC,GAAM/kC,EAAS1B,cAAcymC,KAEnEyF,EAAevE,cAAgBA,EAE/B,MAAMyE,EAAYnuC,KAAK68C,SAAS,YAAa5O,EAAgBhH,GACvDmH,EAAWpuC,KAAK68C,SAAS,WAAY5O,EAAgBhH,GACrD3wB,EAAQ,qBAKd,GACElP,EAAaxG,KAAK2W,IAAIgmC,EAAYC,IAClCp2C,EAAaxG,KAAKsM,IAAIqwC,EAAYC,GAElC,SAKEvW,EAAWlxB,aACb/V,KAAKwuC,+BAA+BvH,EAAYnxB,GAKlD,IAWI44B,EAXAsP,GAAmB,EAMvB,GALI52C,IAAem2C,GAAcn2C,IAAeo2C,IAC9CQ,GAAmB,IAIhBv6C,EAASiiC,qBAEZ,OADAr0B,QAAQC,KAAK,uCACNq8B,EAKT,KAAK,IAAAgB,qBAAoBjF,GACvB,SAaF,IATG,IAAAkF,oBAAmB3H,IACnBjnC,KAAK+nC,UACgB,OAAtBa,IACAoV,IAGAtP,EAA2B,CAACR,EAAkBtF,KAG5C8F,EAA0B,CAC5B,MAAMG,EAAiB,KAEvB,IAAAC,aACEpQ,EACAgL,EACAmF,EACAH,EACA,CACEp4B,SAGN,CAEA,IAAI2nC,EAAgB7P,EAEf4P,IACHC,EAAgB,GAGlB,MAAMnB,EAAe,KACrB,IAAAC,UACEre,EACAgL,EACAoT,EACA5O,EAAkB,GAClBA,EAAkB,GAClB,CACE53B,QACA83B,SAAU6P,EACV9P,cAIJR,GAAe,CACjB,CAEA,OAAOA,CAAY,EA9cnB3tC,KAAKwuC,gCAAiC,EAAA0P,EAAA,GACpCl+C,KAAKm+C,0BACL,IACA,CAAEpM,UAAU,GAEhB,CAoLA,wBAAA8L,CACE5W,EACA/sB,GAEA,MAAM,KAAEpP,EAAI,SAAE9C,GAAai/B,GACrB,gBAAE73B,EAAe,gBAAEguC,GAAoBp1C,GACvC,UAAEgD,GAAckP,GAChB,WAAEqjC,EAAU,SAAEC,GAAa1yC,GAC3B,OAAEs8B,GAAWt8B,EAAKu8B,QAElB+W,EAAWzmB,EAAsB3sB,EAAWo8B,EAAO,IAEzD,GAAIgX,EAAS,KAAOb,EAClB,MAAM,IAAI51C,MAAM,8BAIlB,MAAM02C,EAAS,gBAAgBD,EAAS,GAAIA,EAAS,GAAIZ,GAEnDc,EAAa,cACnBtzC,EAAUuzC,iBAAiBH,EAAUE,GAErC,MAAME,EAAW,cACjBxzC,EAAUuzC,iBAAiBF,EAAQG,GAGnC,MAAMC,EAAW,cAAcH,EAAYE,GAIrCE,EAAsB,GAC5B,IAAK,IAAIC,EAAO,EAAGA,EAAOF,EAAUE,GAAQvB,EAC1CsB,EAAoB9tC,KAClBw2B,EAAO7kC,KAAK8I,IACV,MAAMuzC,EAAW,cAEjB,OADA,iBAAiBA,EAAUvzC,EAAO+D,EAAiBuvC,GAC5Cr3C,MAAM6Z,KAAKy9B,EAAS,KAKjC9zC,EAAKyjC,YAAYmP,iBAAmBgB,EAGpC,MAAMf,EAA2B,GACjC,IAAK,MAAMkB,KAAmBH,EAAqB,CACjD,MAAMr5C,EAAU,8BACd6U,EACA2kC,EAAgB,GAChBzvC,GAEFuuC,EAAyB/sC,KAAKvL,EAChC,CAEAyF,EAAKyjC,YAAYoP,yBAA2BA,CAC9C,CAGA,0BAAAI,CAA2B9W,EAAY/sB,EAAapE,GAClD,MAAM,KAAEhL,GAASm8B,EACXyW,EAAmB5yC,EAAKyjC,YAAYmP,iBAEpCoB,EAAuC,CAAC,IAE9C,IAAK,IAAI91C,EAAI,EAAGA,EAAI00C,EAAiB5zC,OAAQd,IAAK,CAIhD,IAAKkR,EACH,SAGF,MAAM6kC,EAAkBrB,EAAiB10C,GAAG,GAEtCqnC,EAAYvlC,EAAKu8B,QAAQD,OAAO,GAChCkJ,EAAYxlC,EAAKu8B,QAAQD,OAAO,IAEhC,WAAExgC,EAAU,UAAEoE,GAAckP,EAE5B8kC,EAAiBrnB,EAAsB3sB,EAAWqlC,GAElD4O,EAA4BtnB,EAChC3sB,EACA+zC,GAGFC,EAAe,GAAKp+C,KAAK6O,MAAMuvC,EAAe,IAC9CA,EAAe,GAAKp+C,KAAK6O,MAAMuvC,EAAe,IAC9CA,EAAe,GAAKp+C,KAAK6O,MAAMwvC,EAA0B,IAEzD,MAAMC,EAAiBvnB,EAAsB3sB,EAAWslC,GASxD,GAPA4O,EAAe,GAAKt+C,KAAK6O,MAAMyvC,EAAe,IAC9CA,EAAe,GAAKt+C,KAAK6O,MAAMyvC,EAAe,IAC9CA,EAAe,GAAKt+C,KAAK6O,MAAMwvC,EAA0B,IAKrDj/C,KAAK2xC,gBAAgBqN,EAAgBE,EAAgBt4C,GAAa,CACpE5G,KAAKwpC,sBAAuB,EAC5B,MASMgO,EAAY,CAChB,CAVW52C,KAAK2W,IAAIynC,EAAe,GAAIE,EAAe,IAC3Ct+C,KAAKsM,IAAI8xC,EAAe,GAAIE,EAAe,KAUtD,CARWt+C,KAAK2W,IAAIynC,EAAe,GAAIE,EAAe,IAC3Ct+C,KAAKsM,IAAI8xC,EAAe,GAAIE,EAAe,KAQtD,CANWt+C,KAAK2W,IAAIynC,EAAe,GAAIE,EAAe,IAC3Ct+C,KAAKsM,IAAI8xC,EAAe,GAAIE,EAAe,MAQlDpH,GAAgB,IAAAqH,sBACpBn0C,GACA,KAAM,GACN,KACAwsC,GAIFsH,EAAmBluC,KAAKknC,EAC1B,CACF,CACAhtC,EAAKyjC,YAAYkP,eAAiBqB,CACpC,CAEA,yBAAAX,CAA0BlX,EAAYnxB,GACpC,MAAMhL,EAAOm8B,EAAWn8B,MAClB,SAAErH,GAAaqS,GAEf,YAAEy4B,GAAgBzjC,EAClBijC,EAAW/tC,KAAKguC,YAAYvqC,GAC5ByW,EAAc,EAAAwiC,MAAMl3B,UAAUuoB,EAASp/B,MAAM,gBAAgB,IAYnE,OAPA3O,KAAK69C,yBAAyB5W,EAAY/sB,GAE1C+sB,EAAWlxB,aAAc,GAGzB,QAA0BkxB,EAAYxjC,EAAS1E,SAExCwvC,CACT,CAmIA,iBAAA+O,CACEpjC,EACAlY,EACAo7C,EACAhuC,GAEA,MAAM6tC,EAAuBj9C,KAAKogC,cAAc6c,qBAI1CmC,EAAS,cACf,iBACEA,EACAp9C,EACAoN,EACA6tC,EAAuBG,GAGzB,MAAM3D,EAA+B2D,EAAkB,GAEjD,SAAEp2C,GAAakT,EACrB,IAAIwB,EACJ,IAAK,IAAI1S,EAAI,EAAGA,EAAIhC,EAAS8C,OAAQd,IAAK,CACxC,MAAM3D,EAAU2B,EAASgC,IAEnB,qBAAE/C,GAAyB,EAAA0lB,SAAA,IAC/B,mBACAtmB,GAGIu0C,EAAM,cACZ,SAASA,EAAKwF,EAAQn5C,GAEtB,MAAM4zC,EAAM,SAASD,EAAKxqC,GAEtBxO,KAAK44C,IAAIK,GAAOJ,IAClB/9B,EAAe1S,EAEnB,CAEA,OAAO0S,CACT,EAGFshC,EAAkC9c,SAAW,gCAC7C,+6DCxhBA,MAAMqS,EAAc,EAAA8M,UAAA,ymDCpDpB,MAAM,cACJC,GACE,EAAAC,EAohBJ,MAAMvhC,EAAiB,CAErBtP,MAAO,CAAC,EAAG,GACX8wC,UAAU,EACVC,uBAAuB,GAKzB,SAASvhC,EAAOC,EAAWC,GACzB,IAAIC,EAAgBqhC,UAAU51C,OAAS,QAAsBG,IAAjBy1C,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzF7zC,OAAOyS,OAAOF,EAAOJ,EAAgBK,GAGrC,EAAAkhC,EAAMvc,IAAI7kB,EAAWC,GAGrBA,EAAMoZ,MAAQ,GAGd,EAAA+nB,EAAMI,OAAOxhC,EAAWC,EAAO,CAAC,wBAAyB,aACzD,EAAAmhC,EAAMK,SAASzhC,EAAWC,EAAO,CAAC,SAAU,GAG5C,EAAAmhC,EAAMM,SAAS1hC,EAAWC,EAAO,CAAC,UAtiBpC,SAA8BD,EAAWC,GAEvCA,EAAMG,eAAe3N,KAAK,wBAG1BuN,EAAUiZ,QAAU,IAAMhZ,EAAMoZ,MAAM1tB,OAUtCqU,EAAU2hC,QAAU,KAClB,IAAIxgC,EACAygC,EAAY,EACZC,EAAe,EACf5hC,EAAMoZ,MAAM1tB,OAAS,IACvBi2C,EAAY3hC,EAAMoZ,MAAM,GAAGrgB,GAE7B,IAAK,IAAInO,EAAI,EAAGA,EAAIoV,EAAMoZ,MAAM1tB,OAAQd,IAAK,CAI3C,GAHAsW,EAAQlB,EAAMoZ,MAAMxuB,GAAGmO,EAGnBmI,IAAUygC,EACZ,GAAIzgC,EAAQygC,EACV,OAAQC,GACN,KAAK,EACL,KAAK,EAEHA,EAAe,EACf,MAEF,QAEEA,EAAe,OAKnB,OAAQA,GACN,KAAK,EACL,KAAK,EAEHA,EAAe,EACf,MAEF,QAEEA,EAAe,EAQvB,GAHAD,EAAYzgC,EAGS,IAAjB0gC,EACF,KAEJ,CACA,OAAQA,GACN,KAAK,EACH,MAAO,WACT,KAAK,EACH,MAAO,gBACT,KAAK,EACH,MAAO,gBAET,QACE,MAAO,SACX,EAMF7hC,EAAUqY,eAAiB,KACzB,MAAMlO,EAAOlK,EAAMoZ,MAAM1tB,OAEzB,GADAsU,EAAM6hC,SAAW,KACb33B,EAAO,EAAG,CACZlK,EAAM6hC,SAAW,GACjB,IAAK,IAAIj3C,EAAI,EAAGA,EAAIsf,EAAMtf,IACxBoV,EAAM6hC,SAAS,EAAIj3C,GAAKoV,EAAMoZ,MAAMxuB,GAAGyJ,EACvC2L,EAAM6hC,SAAS,EAAIj3C,EAAI,GAAKoV,EAAMoZ,MAAMxuB,GAAGmO,CAE/C,CACA,OAAOiH,EAAM6hC,QAAQ,EAKvB9hC,EAAU+hC,qBAAuB,KAE/B,GAA2B,IAAvB9hC,EAAMoZ,MAAM1tB,OACd,OAAO,EAET,IAAIq2C,EAAU,EACV1tC,EAAI,EACJzJ,EAAI,EACR,KAAOA,EAAIoV,EAAMoZ,MAAM1tB,OAAQd,IAC7B,GAAyB,IAArBoV,EAAMoZ,MAAMxuB,GAAGmO,EAAW,CAC5BgpC,EAAU,EACV,KACF,CAmBF,OAbE1tC,EADE0tC,EACEvxC,OAAOwxC,UACFp3C,EAAI,EAGToV,EAAMoZ,MAAMxuB,EAAI,GAAGyJ,EACd2L,EAAMohC,UAIV5wC,OAAOwxC,UAERhiC,EAAMoZ,MAAM,GAAG/kB,EAEdA,CAAC,EAIV0L,EAAUmZ,aAAe,CAAC/qB,EAAO8zC,KAC/B,MAAM/3B,EAAOlK,EAAMoZ,MAAM1tB,OACzB,OAAIyC,EAAQ,GAAKA,GAAS+b,GACxBg3B,EAAc,wBACN,IAEVe,EAAI,GAAKjiC,EAAMoZ,MAAMjrB,GAAOkG,EAC5B4tC,EAAI,GAAKjiC,EAAMoZ,MAAMjrB,GAAO4K,EAC5BkpC,EAAI,GAAKjiC,EAAMoZ,MAAMjrB,GAAO+zC,SAC5BD,EAAI,GAAKjiC,EAAMoZ,MAAMjrB,GAAOg0C,UACrB,EAAC,EAIVpiC,EAAUqiC,aAAe,CAACj0C,EAAO8zC,KAC/B,MAAM/3B,EAAOlK,EAAMoZ,MAAM1tB,OACzB,GAAIyC,EAAQ,GAAKA,GAAS+b,EAExB,OADAg3B,EAAc,wBACN,EAEV,MAAMmB,EAAOriC,EAAMoZ,MAAMjrB,GAAOkG,EAchC,OAbA2L,EAAMoZ,MAAMjrB,GAAOkG,EAAI4tC,EAAI,GAC3BjiC,EAAMoZ,MAAMjrB,GAAO4K,EAAIkpC,EAAI,GAC3BjiC,EAAMoZ,MAAMjrB,GAAO+zC,SAAWD,EAAI,GAClCjiC,EAAMoZ,MAAMjrB,GAAOg0C,UAAYF,EAAI,GAC/BI,IAASJ,EAAI,GAGfliC,EAAUuiC,qBAIVviC,EAAUwiC,WAEL,CAAC,EAOVxiC,EAAUyiC,SAAW,CAACnuC,EAAG0E,IAAMgH,EAAU0iC,aAAapuC,EAAG0E,EAAG,GAAK,GAGjEgH,EAAU0iC,aAAe,CAACpuC,EAAG0E,EAAGmpC,EAAUC,KAExC,GAAID,EAAW,GAAOA,EAAW,EAE/B,OADAhB,EAAc,sCACN,EAEV,GAAIiB,EAAY,GAAOA,EAAY,EAEjC,OADAjB,EAAc,uCACN,EAILlhC,EAAMqhC,uBACTthC,EAAU2iC,YAAYruC,GAIxB,MAAMilB,EAAO,CACXjlB,IACA0E,IACAmpC,WACAC,aAQF,IAAIv3C,EACJ,IALAoV,EAAMoZ,MAAM5mB,KAAK8mB,GACjBvZ,EAAUuiC,qBAIL13C,EAAI,EAAGA,EAAIoV,EAAMoZ,MAAM1tB,QACtBsU,EAAMoZ,MAAMxuB,GAAGyJ,IAAMA,EADSzJ,KAQpC,OAAIA,EAAIoV,EAAMoZ,MAAM1tB,OACXd,GAED,CAAC,EAEXmV,EAAU4iC,SAAWvpB,IACfpZ,EAAMoZ,QAAUA,IAClBpZ,EAAMoZ,MAAQA,EACdrZ,EAAUuiC,qBACZ,EAKFviC,EAAUuiC,mBAAqB,KAC7BtiC,EAAMoZ,MAAM9jB,MAAK,CAACZ,EAAGC,IAAMD,EAAEL,EAAIM,EAAEN,IACX0L,EAAU6iC,eAGhC7iC,EAAUwiC,UACZ,EAIFxiC,EAAU6iC,YAAc,KACtB,MAAMC,EAAW7iC,EAAM1P,MAAMkR,QACvB0I,EAAOlK,EAAMoZ,MAAM1tB,OASzB,OARIwe,GACFlK,EAAM1P,MAAM,GAAK0P,EAAMoZ,MAAM,GAAG/kB,EAChC2L,EAAM1P,MAAM,GAAK0P,EAAMoZ,MAAMlP,EAAO,GAAG7V,IAEvC2L,EAAM1P,MAAM,GAAK,EACjB0P,EAAM1P,MAAM,GAAK,IAGfuyC,EAAS,KAAO7iC,EAAM1P,MAAM,IAAMuyC,EAAS,KAAO7iC,EAAM1P,MAAM,MAGlEyP,EAAUwiC,YACH,EAAI,EAKbxiC,EAAU2iC,YAAcruC,IAGtB,IAAIzJ,EACJ,IAAKA,EAAI,EAAGA,EAAIoV,EAAMoZ,MAAM1tB,QACtBsU,EAAMoZ,MAAMxuB,GAAGyJ,IAAMA,EADSzJ,KAOpC,GAAIA,GAAKoV,EAAMoZ,MAAM1tB,OACnB,OAAQ,EAEV,MAAMo3C,EAASl4C,EAIf,IAAIm4C,GAAkB,EAQtB,OAPA/iC,EAAMoZ,MAAM11B,OAAOkH,EAAG,GACZ,IAANA,GAAWA,IAAMoV,EAAMoZ,MAAM1tB,SAC/Bq3C,EAAkBhjC,EAAU6iC,eAEzBG,GACHhjC,EAAUwiC,WAELO,CAAM,EAIf/iC,EAAUsZ,gBAAkB,KAC1BrZ,EAAMoZ,MAAQ,GACdrZ,EAAUuiC,oBAAoB,EAKhCviC,EAAUijC,WAAa,CAACC,EAAI1uC,EAAI2uC,EAAIC,KAElCpjC,EAAUuiC,qBACV,IAAK,IAAI13C,EAAI,EAAGA,EAAIoV,EAAMoZ,MAAM1tB,QAC1BsU,EAAMoZ,MAAMxuB,GAAGyJ,GAAK4uC,GAAMjjC,EAAMoZ,MAAMxuB,GAAGyJ,GAAK6uC,EAChDljC,EAAMoZ,MAAM11B,OAAOkH,EAAG,GAEtBA,IAKJmV,EAAUyiC,SAASS,EAAI1uC,EAAI,GAAK,GAChCwL,EAAUyiC,SAASU,EAAIC,EAAI,GAAK,EAAI,EAItCpjC,EAAUqjC,SAAW/uC,IACnB,MAAMgvC,EAAQ,GAEd,OADAtjC,EAAUujC,SAASjvC,EAAGA,EAAG,EAAGgvC,GACrBA,EAAM,EAAE,EAMjBtjC,EAAUwjC,YAAcjzC,IACtB,GAAIA,EAAM5E,OAAS,EACjB,OAAO,EAET,MAAM83C,EAAgBzjC,EAAUpT,WAG5B62C,EAAc,GAAKlzC,EAAM,GAC3ByP,EAAUyiC,SAASlyC,EAAM,GAAIyP,EAAUqjC,SAAS9yC,EAAM,KAEtDyP,EAAUyiC,SAASlyC,EAAM,GAAIyP,EAAUqjC,SAASI,EAAc,KAE5DA,EAAc,GAAKlzC,EAAM,GAC3ByP,EAAUyiC,SAASlyC,EAAM,GAAIyP,EAAUqjC,SAAS9yC,EAAM,KAEtDyP,EAAUyiC,SAASlyC,EAAM,GAAIyP,EAAUqjC,SAASI,EAAc,KAIhEzjC,EAAUuiC,qBACV,IAAK,IAAI13C,EAAI,EAAGA,EAAIoV,EAAMoZ,MAAM1tB,QAC1BsU,EAAMoZ,MAAMxuB,GAAGyJ,GAAK/D,EAAM,IAAM0P,EAAMoZ,MAAMxuB,GAAGyJ,GAAK/D,EAAM,GAC5D0P,EAAMoZ,MAAM11B,OAAOkH,EAAG,KAEpBA,EAIN,OADAmV,EAAUuiC,qBACH,CAAC,EAIVviC,EAAU0jC,2BAA6B,CAACR,EAAIC,KAC1C,MAAMQ,EAAI3jC,EAAU4jC,uBACpB,OAAOnhD,KAAK22C,MAAM+J,EAAKD,GAAMS,EAAE,EAIjC3jC,EAAU4jC,qBAAuB,KAC/B,MAAMz5B,EAAOlK,EAAMoZ,MAAM1tB,OACzB,GAAIwe,EAAO,EACT,OAAQ,EAEV,IAAIm2B,EAAWrgC,EAAMoZ,MAAM,GAAG/kB,EAAI2L,EAAMoZ,MAAM,GAAG/kB,EACjD,IAAK,IAAIzJ,EAAI,EAAGA,EAAIsf,EAAO,EAAGtf,IAAK,CACjC,MAAMg5C,EAAc5jC,EAAMoZ,MAAMxuB,EAAI,GAAGyJ,EAAI2L,EAAMoZ,MAAMxuB,GAAGyJ,EACtDuvC,EAAcvD,IAChBA,EAAWuD,EAEf,CACA,OAAOvD,CAAQ,EAMjBtgC,EAAUujC,SAAW,SAAUO,EAAQC,EAAM55B,EAAMm5B,GACjD,IACIz4C,EADAm5C,EAASzC,UAAU51C,OAAS,QAAsBG,IAAjBy1C,UAAU,GAAmBA,UAAU,GAAK,EAE7E0C,EAAM,EACV,MAAMC,EAAWjkC,EAAMoZ,MAAM1tB,OAK7B,IAAIw4C,EAAY,EACC,IAAbD,IACFC,EAAYlkC,EAAMoZ,MAAM6qB,EAAW,GAAGlrC,GAExC,IAAI1E,EAAI,EACJ4uC,EAAK,EACLC,EAAK,EACL3uC,EAAK,EACL4uC,EAAK,EACLjB,EAAW,EACXC,EAAY,EAGhB,IAAKv3C,EAAI,EAAGA,EAAIsf,EAAMtf,IAAK,CAEzB,MAAMu5C,EAAOJ,EAASn5C,EAYtB,IANEyJ,EADE6V,EAAO,EACL25B,EAASj5C,GAAKsf,EAAO,IAAQ45B,EAAOD,GAEpC,IAAOA,EAASC,GAIfE,EAAMC,GAAY5vC,EAAI2L,EAAMoZ,MAAM4qB,GAAK3vC,GAC5C2vC,IAKIA,EAAMC,IACRhB,EAAKjjC,EAAMoZ,MAAM4qB,EAAM,GAAG3vC,EAC1B6uC,EAAKljC,EAAMoZ,MAAM4qB,GAAK3vC,EACtBE,EAAKyL,EAAMoZ,MAAM4qB,EAAM,GAAGjrC,EAC1BoqC,EAAKnjC,EAAMoZ,MAAM4qB,GAAKjrC,EAItBmpC,EAAWliC,EAAMoZ,MAAM4qB,EAAM,GAAG9B,SAChCC,EAAYniC,EAAMoZ,MAAM4qB,EAAM,GAAG7B,UAI7BD,EAAW,OACbA,EAAW,MAETA,EAAW,SACbA,EAAW,SAMjB,GAAI8B,GAAOC,EACTZ,EAAMc,GAAQnkC,EAAMohC,SAAW8C,EAAY,OACtC,GAAY,IAARF,EAETX,EAAMc,GAAQnkC,EAAMohC,SAAWphC,EAAMoZ,MAAM,GAAGrgB,EAAI,MAC7C,CAML,IAAImvB,GAAK7zB,EAAI4uC,IAAOC,EAAKD,GAWzB,GAPE/a,EADEA,EAAIga,EACF,GAAMha,EAAIga,EAEV,GAAM,IAAOha,EAAIga,IAAa,EAAMA,GAKtCC,EAAY,IAAM,CAEpB,GAAIja,EAAI,GAAK,CACXmb,EAAMc,GAAQ5vC,EACd,QACF,CAEE8uC,EAAMc,GAAQhB,EACd,QAEJ,CAIA,GAAIhB,EAAY,IAAM,CAEpBkB,EAAMc,IAAS,EAAIjc,GAAK3zB,EAAK2zB,EAAIib,EACjC,QACF,CASIjb,EAAI,GACNA,EAAI,IAAW,EAAJA,KAAW,EAAM,GAAKia,GACxBja,EAAI,KACbA,EAAI,EAAM,IAAmB,GAAX,EAAMA,MAAY,EAAI,GAAKia,IAI/C,MAAMiC,EAAKlc,EAAIA,EACTmc,EAAMD,EAAKlc,EACXoc,EAAK,EAAID,EAAM,EAAID,EAAK,EACxBG,GAAM,EAAIF,EAAM,EAAID,EACpBI,EAAKH,EAAM,EAAID,EAAKlc,EACpBuc,EAAKJ,EAAMD,EAIXM,GAAK,EAAMvC,IADHgB,EAAK5uC,GAInB8uC,EAAMc,GAAQG,EAAK/vC,EAAKgwC,EAAKpB,EAAKqB,EAAKE,EAAID,EAAKC,EAIhD,MAAMvrC,EAAM5E,EAAK4uC,EAAK5uC,EAAK4uC,EACrBr0C,EAAMyF,EAAK4uC,EAAK5uC,EAAK4uC,EAC3BE,EAAMc,GAAQd,EAAMc,GAAQhrC,EAAMA,EAAMkqC,EAAMc,GAC9Cd,EAAMc,GAAQd,EAAMc,GAAQr1C,EAAMA,EAAMu0C,EAAMc,EAChD,CACF,CACF,CACF,CAqCEQ,CAAqB5kC,EAAWC,EAClC,CAQA,IAAI4kC,EAAyB,CAC3BrkC,YALkB,EAAA4gC,EAAM5gC,YAAYT,EAAQ,wBAM5CA,+FC5jBF,MAAM,cACJ+kC,GACE,EAAA1D,EAgjBJ,MAAMvhC,EAAiB,CACrB9O,SAAU,CAAC,EAAG,EAAG,GACjBvB,WAAY,CAAC,EAAG,EAAG,GACnBwB,OAAQ,CAAC,EAAG,EAAG,GACf+zC,sBAAuB,CAAC,EAAG,GAAI,GAC/Bj0C,oBAAoB,EACpBk0C,wBAAwB,EACxBC,UAAW,GACXzjD,cAAe,EACf0jD,cAAe,CAAC,IAAM,SACtBz2C,aAAc,CAAC,EAAG,GAClBwC,gBAAiB,CAAC,EAAG,EAAG,GACxBk0C,sBAAsB,EACtBC,iBAAkB,EAAE,IAAM,IAAM,IAChCC,kBAAmB,CAAC,IAAM,IAAM,IAChCC,eAAgB,CAAC,GAAK,IAAM,IAC5BC,kBAAkB,EAClBC,iBAAkB,KAClBC,WAAY,KACZC,qBAAsB,cAEtBC,oBAAqB,CAAC,EAAG,EAAG,GAC5BC,cAAe,EACfC,eAAgB,CAAC,EAAG,EAAG,GACvBC,kBAAmB,CAAC,EAAG,GAAI,IAK7B,SAAS/lC,EAAOC,EAAWC,GACzB,IAAIC,EAAgBqhC,UAAU51C,OAAS,QAAsBG,IAAjBy1C,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzF7zC,OAAOyS,OAAOF,EAAOJ,EAAgBK,GAGrC,EAAAkhC,EAAMvc,IAAI7kB,EAAWC,GACrB,EAAAmhC,EAAMxzC,IAAIoS,EAAWC,EAAO,CAAC,aAC7B,EAAAmhC,EAAMI,OAAOxhC,EAAWC,EAAO,CAAC,qBAAsB,yBAA0B,YAAa,gBAAiB,uBAAwB,mBAAoB,kBAC1J,EAAAmhC,EAAMM,SAAS1hC,EAAWC,EAAO,CAAC,wBAAyB,kBAAmB,WAAY,eAC1F,EAAAmhC,EAAM2E,YAAY/lC,EAAWC,EAAO,CAAC,gBAAiB,gBAAiB,GACvE,EAAAmhC,EAAM2E,YAAY/lC,EAAWC,EAAO,CAAC,SAAU,mBAAoB,oBAAqB,iBAAkB,sBAAuB,iBAAkB,qBAAsB,GArkB3K,SAAmBD,EAAWC,GAE5BA,EAAMG,eAAe3N,KAAK,aAG1B,MAAM5K,EAAS,IAAIm+C,aAAa,GAC1BC,EAAW,IAAID,aAAa,CAAC,EAAK,GAAM,IACxCE,EAAU,IAAIF,aAAa,CAAC,EAAK,EAAK,IACtCG,EAAY,cAAc,IAAIH,aAAa,KAC3CI,EAAa,cAAc,IAAIJ,aAAa,KAC5CK,EAAU,IAAIL,aAAa,GAC3BM,EAAU,IAAIN,aAAa,GAC3BO,EAAU,IAAIP,aAAa,GAC3BQ,EAAe,cAAc,IAAIR,aAAa,KAC9CS,EAAQ,cAAc,IAAIT,aAAa,KACvCU,EAAc,IAAIV,aAAa,GAC/BW,EAAgB,IAAIX,aAAa,GAGvC,SAASY,IAEP3mC,EAAMhP,gBAAgB,IAAMgP,EAAM8kC,sBAAsB,GACxD9kC,EAAMhP,gBAAgB,IAAMgP,EAAM8kC,sBAAsB,GACxD9kC,EAAMhP,gBAAgB,IAAMgP,EAAM8kC,sBAAsB,EAC1D,CACA/kC,EAAU6mC,oBAAsB,KAC9B,MAAMC,EAAK9mC,EAAU+mC,gBACrB9mC,EAAMjP,OAAO,GAAK81C,EAAG,GACrB7mC,EAAMjP,OAAO,GAAK81C,EAAG,GACrB7mC,EAAMjP,OAAO,GAAK81C,EAAG,GACrB9mC,EAAUwiC,UAAU,EAEtBxiC,EAAUgnC,YAAc,CAAC1yC,EAAG0E,EAAGiuC,KACzB3yC,IAAM2L,EAAMlP,SAAS,IAAMiI,IAAMiH,EAAMlP,SAAS,IAAMk2C,IAAMhnC,EAAMlP,SAAS,KAG/EkP,EAAMlP,SAAS,GAAKuD,EACpB2L,EAAMlP,SAAS,GAAKiI,EACpBiH,EAAMlP,SAAS,GAAKk2C,EAGpBjnC,EAAUknC,kBACVlnC,EAAUwiC,WAAU,EAEtBxiC,EAAUmnC,cAAgB,CAAC7yC,EAAG0E,EAAGiuC,KAC3B3yC,IAAM2L,EAAMzQ,WAAW,IAAMwJ,IAAMiH,EAAMzQ,WAAW,IAAMy3C,IAAMhnC,EAAMzQ,WAAW,KAGrFyQ,EAAMzQ,WAAW,GAAK8E,EACtB2L,EAAMzQ,WAAW,GAAKwJ,EACtBiH,EAAMzQ,WAAW,GAAKy3C,EAGtBjnC,EAAUknC,kBACVlnC,EAAUwiC,WAAU,EAEtBxiC,EAAUonC,YAAczD,IACtB,GAAI1jC,EAAMqgC,WAAaqD,EACrB,OAEF1jC,EAAMqgC,SAAWqD,EACb1jC,EAAMqgC,SAAW,QACnBrgC,EAAMqgC,SAAW,MACjBwE,EAAc,gCAIhB,MAAMuC,EAAMpnC,EAAM8kC,sBAGlB9kC,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAAKs2C,EAAI,GAAKpnC,EAAMqgC,SACzDrgC,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAAKs2C,EAAI,GAAKpnC,EAAMqgC,SACzDrgC,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAAKs2C,EAAI,GAAKpnC,EAAMqgC,SACzDtgC,EAAUwiC,UAAU,EAKtBxiC,EAAUknC,gBAAkB,KAC1B,MAAMpb,EAAK7rB,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAC1Cg7B,EAAK9rB,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAC1CojC,EAAKl0B,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAEhD,GADAkP,EAAMqgC,SAAW79C,KAAKiZ,KAAKowB,EAAKA,EAAKC,EAAKA,EAAKoI,EAAKA,GAChDl0B,EAAMqgC,SAAW,MAAO,CAC1BrgC,EAAMqgC,SAAW,MACjBwE,EAAc,+BACd,MAAMuC,EAAMpnC,EAAM8kC,sBAGlB9kC,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAAKs2C,EAAI,GAAKpnC,EAAMqgC,SACzDrgC,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAAKs2C,EAAI,GAAKpnC,EAAMqgC,SACzDrgC,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAAKs2C,EAAI,GAAKpnC,EAAMqgC,QAC3D,CACArgC,EAAM8kC,sBAAsB,GAAKjZ,EAAK7rB,EAAMqgC,SAC5CrgC,EAAM8kC,sBAAsB,GAAKhZ,EAAK9rB,EAAMqgC,SAC5CrgC,EAAM8kC,sBAAsB,GAAK5Q,EAAKl0B,EAAMqgC,SAC5CsG,GAAwB,EAO1B5mC,EAAUsnC,MAAQC,IAChB,GAAIA,GAAU,EACZ,OAIF,MAAM5D,EAAI1jC,EAAMqgC,SAAWiH,EAC3BvnC,EAAUgnC,YAAY/mC,EAAMzQ,WAAW,GAAKm0C,EAAI1jC,EAAM8kC,sBAAsB,GAAI9kC,EAAMzQ,WAAW,GAAKm0C,EAAI1jC,EAAM8kC,sBAAsB,GAAI9kC,EAAMzQ,WAAW,GAAKm0C,EAAI1jC,EAAM8kC,sBAAsB,GAAG,EAErM/kC,EAAUwnC,KAAOhvC,IACf,MAAMivC,EAAMxnC,EAAMlP,SACZ22C,EAAKznC,EAAMzQ,WACXm4C,EAAK1nC,EAAMjP,OACX42C,EAAa,IAAI5B,aAAa,CAAC2B,EAAG,GAAIA,EAAG,GAAIA,EAAG,GAAI,IAC1D,cAAcnB,GACd,MAAMqB,EAAU,IAAI7B,aAAa,CAAC0B,EAAG,GAAKD,EAAI,GAAIC,EAAG,GAAKD,EAAI,GAAIC,EAAG,GAAKD,EAAI,KAC9E,YAAYjB,EAAcA,GAAc,IAAAsB,GAAmBtvC,GAAQqvC,GACnE,mBAAmBD,EAAYA,EAAYpB,GAC3CvmC,EAAMjP,OAAO,GAAK42C,EAAW,GAC7B3nC,EAAMjP,OAAO,GAAK42C,EAAW,GAC7B3nC,EAAMjP,OAAO,GAAK42C,EAAW,GAC7B5nC,EAAUwiC,UAAU,EAEtBxiC,EAAU+nC,QAAUvvC,IAClB,MAAMwvC,EAAK/nC,EAAMzQ,WACjB,cAAci3C,GAKd,eAAeA,EAAOA,EAAOuB,GAC7B,YAAYvB,EAAOA,GAAO,IAAAqB,GAAmBtvC,GAAQyH,EAAMjP,QAC3D,eAAey1C,EAAOA,EAAO,EAAEuB,EAAG,IAAKA,EAAG,IAAKA,EAAG,KAGlD,mBAAmBtB,EAAazmC,EAAMlP,SAAU01C,GAChDzmC,EAAUgnC,YAAYN,EAAY,GAAIA,EAAY,GAAIA,EAAY,GAAG,EAEvE1mC,EAAUioC,IAAMzvC,IACd,MAAMzH,EAAWkP,EAAMlP,SACvB,cAAc01C,GAKd,eAAeA,EAAOA,EAAO11C,GAC7B,YAAY01C,EAAOA,GAAO,IAAAqB,GAAmBtvC,GAAQyH,EAAMjP,QAC3D,eAAey1C,EAAOA,EAAO,EAAE11C,EAAS,IAAKA,EAAS,IAAKA,EAAS,KAGpE,mBAAmB41C,EAAe1mC,EAAMzQ,WAAYi3C,GACpDzmC,EAAUmnC,cAAcR,EAAc,GAAIA,EAAc,GAAIA,EAAc,GAAG,EAE/E3mC,EAAUkoC,UAAY1vC,IACpB,MAAMwvC,EAAK/nC,EAAMzQ,WAGXs3C,EAAK9mC,EAAU+mC,gBACfoB,EAAO,EAAErB,EAAG,IAAKA,EAAG,IAAKA,EAAG,IAClC,cAAcL,GAKd,eAAeA,EAAOA,EAAOuB,GAC7B,YAAYvB,EAAOA,GAAO,IAAAqB,GAAmBtvC,GAAQ2vC,GACrD,eAAe1B,EAAOA,EAAO,EAAEuB,EAAG,IAAKA,EAAG,IAAKA,EAAG,KAGlD,mBAAmBtB,EAAazmC,EAAMlP,SAAU01C,GAChDzmC,EAAUgnC,YAAYN,EAAY,GAAIA,EAAY,GAAIA,EAAY,GAAG,EAEvE1mC,EAAUooC,MAAQ5vC,IAChB,MAAMzH,EAAWkP,EAAMlP,SACjB+1C,EAAK9mC,EAAU+mC,gBACfoB,EAAO,CAACrB,EAAG,GAAIA,EAAG,GAAIA,EAAG,IAC/B,cAAcL,GAKd,eAAeA,EAAOA,EAAO11C,GAC7B,YAAY01C,EAAOA,GAAO,IAAAqB,GAAmBtvC,GAAQ2vC,GACrD,eAAe1B,EAAOA,EAAO,EAAE11C,EAAS,IAAKA,EAAS,IAAKA,EAAS,KAGpE,mBAAmB41C,EAAe1mC,EAAMzQ,WAAYi3C,GACpDzmC,EAAUmnC,iBAAiBR,EAAc,EAE3C3mC,EAAUqoC,KAAOC,IACXA,GAAU,IAGVroC,EAAMnP,mBACRmP,EAAMze,eAAiB8mD,EAEvBroC,EAAMglC,WAAaqD,EAErBtoC,EAAUwiC,WAAU,EAEtBxiC,EAAUjO,UAAY,CAACuC,EAAG0E,EAAGiuC,KAC3B,MAAM78B,EAAS,CAAC9V,EAAG0E,EAAGiuC,IACtB,OAAIhnC,EAAMlP,SAAUqZ,EAAQnK,EAAMlP,WAClC,OAAIkP,EAAMzQ,WAAY4a,EAAQnK,EAAMzQ,YACpCwQ,EAAUknC,kBACVlnC,EAAUwiC,UAAU,EAEtBxiC,EAAUuoC,eAAiBC,IACzB,MAAMC,EAAQ,IAAIxoC,EAAMjP,OAAQ,GAC1B03C,EAAS,GACTC,EAAQ,GACRC,EAAQ,GACdH,EAAM,IAAMxoC,EAAMlP,SAAS,GAC3B03C,EAAM,IAAMxoC,EAAMlP,SAAS,GAC3B03C,EAAM,IAAMxoC,EAAMlP,SAAS,GAC3B,mBAAmB23C,EAAQ,IAAIzoC,EAAMlP,SAAU,GAAMy3C,GACrD,mBAAmBG,EAAO,IAAI1oC,EAAMzQ,WAAY,GAAMg5C,GACtD,mBAAmBI,EAAOH,EAAOD,GACjCI,EAAM,IAAMF,EAAO,GACnBE,EAAM,IAAMF,EAAO,GACnBE,EAAM,IAAMF,EAAO,GACnB1oC,EAAUgnC,eAAe0B,EAAOjnC,MAAM,EAAG,IACzCzB,EAAUmnC,iBAAiBwB,EAAMlnC,MAAM,EAAG,IAC1CzB,EAAU6oC,aAAaD,EAAMnnC,MAAM,EAAG,GAAG,EAE3CzB,EAAU8oC,aAAe,IAAM7oC,EAAMilC,cAAc,GAAKjlC,EAAMilC,cAAc,GAC5EllC,EAAU+oC,aAAeC,IACvB,IAAIrE,EAAIqE,EACJrE,EAAI,QACNA,EAAI,MACJG,EAAc,iCAEhB9kC,EAAUipC,iBAAiBhpC,EAAMilC,cAAc,GAAIjlC,EAAMilC,cAAc,GAAKP,EAAE,EAEhF3kC,EAAUkpC,2BAA6BF,IACrC,IAAIrE,EAAIqE,EACJrE,EAAI,QACNA,EAAI,MACJG,EAAc,iCAEhB9kC,EAAUipC,iBAAiBhpC,EAAMqgC,SAAWqE,EAAI,EAAG1kC,EAAMqgC,SAAWqE,EAAI,EAAE,EAI5E3kC,EAAUmpC,QAAU3wC,MACpBwH,EAAUopC,QAAU,OACpBppC,EAAUqpC,iBAAmB,CAACC,EAAOC,KAAR,EAC7BvpC,EAAUwpC,eAAiB,OAC3BxpC,EAAUypC,mBAAqB,OAC/BzpC,EAAU0pC,iBAAmBC,MAG7B3pC,EAAU4pC,8BAAgCC,IACxC,UAAUA,EAAQ5pC,EAAMylC,sBACjBmE,GAET7pC,EAAU8pC,4BAA8B,KAEtC,UAAU3D,EAAWnmC,EAAU+mC,iBAC/B,YAAYZ,EAAWA,GACvB,iBAAiBC,EAAY,CAACnmC,EAAMqgC,SAAUrgC,EAAMqgC,SAAUrgC,EAAMqgC,WACpE,cAAc6F,EAAWA,EAAWC,GACpC,cAAcnmC,EAAMylC,sBACpB,eAAezlC,EAAMylC,qBAAsBS,EAAW,CAAC,EAAK,GAAM,GAAK,EAEzEnmC,EAAU+pC,SAAWC,MACrBhqC,EAAUiqC,oCAAsCC,IAE9C,MAAMC,EAAO,gBAAgBD,EAAI,GAAIA,EAAI,GAAIA,EAAI,GAAIA,EAAI,IACnDE,EAAQ,cACRC,EAAO,gBAAgB,EAAK,EAAK,EAAK,GAQ5C,OAPA,eAAeD,EAAOD,GAGtB,cAAcE,EAAMF,EAAME,GAC1B,cAAcA,EAAMA,EAAMD,GAGnB,CAACC,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAG,EAEpCrqC,EAAUsqC,yBAA2BxQ,IACnC95B,EAAUuqC,yBAAyBzQ,GACnC,YAAYA,EAAQA,EAAO,EAE7B95B,EAAUuqC,yBAA2BzQ,IACnC,cAAcA,GAGd,MAAM0Q,EAAa,CAAC,IACpB,OAAMvqC,EAAM6lC,kBAAmB7lC,EAAM4lC,eAAgB2E,GACrD1Q,EAAO,GAAK0Q,EAAW,GACvB1Q,EAAO,GAAK0Q,EAAW,GACvB1Q,EAAO,GAAK0Q,EAAW,GACvB1Q,EAAO,GAAK75B,EAAM4lC,eAAe,GACjC/L,EAAO,GAAK75B,EAAM4lC,eAAe,GACjC/L,EAAO,GAAK75B,EAAM4lC,eAAe,GACjC/L,EAAO,IAAM75B,EAAM6lC,kBAAkB,GACrChM,EAAO,IAAM75B,EAAM6lC,kBAAkB,GACrChM,EAAO,KAAO75B,EAAM6lC,kBAAkB,GACtC,eAAehM,EAAQA,GACvB,SAASuM,EAAS,EAAIpmC,EAAM2lC,cAAe,EAAI3lC,EAAM2lC,cAAe,EAAI3lC,EAAM2lC,eAC9E,WAAW9L,EAAQA,EAAQuM,GAC3B,eAAevM,EAAQA,EAAQ75B,EAAM0lC,oBAAoB,EAE3D3lC,EAAUyqC,oCAAsCC,IAE9C,YAAYvE,EAAWuE,GAYvB,mBAAmBrE,EAASx+C,EAAQs+C,GACpCnmC,EAAUknC,kBACV,MAAMyD,EAAU1qC,EAAMqgC,SACtBtgC,EAAUgnC,YAAYX,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,IAGtD,mBAAmBC,EAASL,EAAUE,GACtC,cAAcG,EAASA,EAASD,GAChC,eAAeC,EAASA,GACxBtmC,EAAU4qC,yBAAyBtE,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,IACnE,mBAAmBC,EAASL,EAASC,GACrC,cAAcI,EAASA,EAASF,GAChC,eAAeE,EAASA,GACxBvmC,EAAU6oC,UAAUtC,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,IACpDvmC,EAAUonC,YAAYuD,EAAQ,EAMhC3qC,EAAU6qC,wCAA0CC,IAElD9qC,EAAUuqC,yBAAyBpE,GAInC,cAAcA,EAAW2E,EAAK3E,GAC9BnmC,EAAUyqC,oCAAoCtE,EAAU,EAE1DnmC,EAAU+qC,cAAgBD,IACxB7qC,EAAMwlC,WAAaqF,EACf7qC,EAAMwlC,aACR,UAAUU,EAAWlmC,EAAMwlC,YAC3BzlC,EAAUyqC,oCAAoCtE,GAC9C,eAAelmC,EAAMwlC,WAAYxlC,EAAMwlC,YACzC,EAEFzlC,EAAU+mC,cAAgB,KACxB,GAAI9mC,EAAMwlC,WACR,OAAOxlC,EAAMwlC,WAEf,YAAYU,EAAWlmC,EAAMlP,SAE7BkP,EAAMzQ,WAENyQ,EAAMjP,QAGN,eAAem1C,EAAWA,GAC1B,MAAMrM,EAAS,IAAIkM,aAAa,IAEhC,OADA,UAAUlM,EAAQqM,GACXrM,CAAM,EAEf95B,EAAUgrC,oBAAsBF,IAC9B7qC,EAAMulC,iBAAmBsF,CAAG,EAE9B9qC,EAAUirC,oBAAsB,CAACtB,EAAQuB,EAAOC,KAC9C,MAAMrR,EAAS,IAAIkM,aAAa,IAEhC,GADA,cAAclM,GACV75B,EAAMulC,iBAAkB,CAC1B,MAAM1zC,EAAQ,EAAImO,EAAM2lC,cAKxB,OAJA,SAASS,EAASv0C,EAAOA,EAAOA,GAChC,UAAUgoC,EAAQ75B,EAAMulC,kBACxB,WAAW1L,EAAQA,EAAQuM,GAC3B,eAAevM,EAAQA,GAChBA,CACT,CACA,cAAcqM,GAKd,MAAMiF,EAASnrC,EAAMilC,cAAc,GAAKjlC,EAAMilC,cAAc,GACtDmG,EAAS,CAACprC,EAAMilC,cAAc,IAAMgG,EAAQ,GAAKE,EAAS,EAAKnrC,EAAMilC,cAAc,IAAMiG,EAAO,GAAKC,EAAS,GACpH,GAAInrC,EAAMnP,mBAAoB,CAE5B,MAAM1O,EAAQ6d,EAAMze,cAAgBmoD,EAC9BtnD,EAAS4d,EAAMze,cACf8pD,GAAQrrC,EAAMxR,aAAa,GAAK,GAAOrM,EACvCmpD,GAAQtrC,EAAMxR,aAAa,GAAK,GAAOrM,EACvCopD,GAAQvrC,EAAMxR,aAAa,GAAK,GAAOpM,EACvCopD,GAAQxrC,EAAMxR,aAAa,GAAK,GAAOpM,EAC7C,WAAW8jD,EAAWmF,EAAMC,EAAMC,EAAMC,EAAMJ,EAAO,GAAIA,EAAO,IAChE,eAAelF,EAAWA,EAC5B,KAAO,IAAIlmC,EAAMklC,qBACf,MAAM,IAAI37C,MAAM,qDACX,CACL,MAAMkiD,EAAMjpD,KAAKkpD,KAAI,IAAA7D,GAAmB7nC,EAAMglC,WAAa,GAC3D,IAAI7iD,EACAC,GACiC,IAAjC4d,EAAM+kC,wBACR5iD,EAAQ6d,EAAMilC,cAAc,GAAKwG,EACjCrpD,EAAS4d,EAAMilC,cAAc,GAAKwG,EAAM/B,IAExCvnD,EAAQ6d,EAAMilC,cAAc,GAAKwG,EAAM/B,EACvCtnD,EAAS4d,EAAMilC,cAAc,GAAKwG,GAEpC,MAAMJ,GAAQrrC,EAAMxR,aAAa,GAAK,GAAOrM,EACvCmpD,GAAQtrC,EAAMxR,aAAa,GAAK,GAAOrM,EACvCopD,GAAQvrC,EAAMxR,aAAa,GAAK,GAAOpM,EACvCopD,GAAQxrC,EAAMxR,aAAa,GAAK,GAAOpM,EACvCupD,EAAQP,EAAO,GACfQ,EAAOR,EAAO,GACpBlF,EAAU,GAAK,EAAMyF,GAASL,EAAOD,GACrCnF,EAAU,GAAK,EAAMyF,GAASH,EAAOD,GACrCrF,EAAU,IAAMmF,EAAOC,IAASA,EAAOD,GACvCnF,EAAU,IAAMqF,EAAOC,IAASA,EAAOD,GACvCrF,EAAU,MAAQyF,EAAQC,IAASA,EAAOD,GAC1CzF,EAAU,KAAO,EACjBA,EAAU,KAAO,EAAMyF,EAAQC,GAAQA,EAAOD,GAC9CzF,EAAU,IAAM,CAClB,EAEA,OADA,UAAUrM,EAAQqM,GACXrM,CAAM,EAEf95B,EAAU8rC,6BAA+B,CAACnC,EAAQuB,EAAOC,KACvD,MAAMY,EAAO/rC,EAAU+mC,gBACjBiF,EAAOhsC,EAAUirC,oBAAoBtB,EAAQuB,EAAOC,GAI1D,OADA,cAAca,EAAMD,EAAMC,GACnBA,CAAI,EAEbhsC,EAAU4qC,yBAA2B,CAACt2C,EAAG0E,EAAGiuC,KAC1C,GAAIhnC,EAAM8kC,sBAAsB,KAAOzwC,GAAK2L,EAAM8kC,sBAAsB,KAAO/rC,GAAKiH,EAAM8kC,sBAAsB,KAAOkC,EACrH,OAEFhnC,EAAM8kC,sBAAsB,GAAKzwC,EACjC2L,EAAM8kC,sBAAsB,GAAK/rC,EACjCiH,EAAM8kC,sBAAsB,GAAKkC,EACjC,MAAMI,EAAMpnC,EAAM8kC,sBAGlB9kC,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAAKs2C,EAAI,GAAKpnC,EAAMqgC,SACzDrgC,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAAKs2C,EAAI,GAAKpnC,EAAMqgC,SACzDrgC,EAAMzQ,WAAW,GAAKyQ,EAAMlP,SAAS,GAAKs2C,EAAI,GAAKpnC,EAAMqgC,SACzDsG,GAAwB,EAmB1B5mC,EAAUisC,gBAAkB,CAAC3C,EAAOC,EAAMl1C,EAAO63C,KAC/C,MAAM1B,EAAa,CAAC,IACpB,OAAMvqC,EAAM6lC,kBAAmB7lC,EAAM4lC,eAAgB2E,GAGrD,MAAM2B,EAAS,cAAc,IAAInG,aAAa,KAC9C,YAAYmG,EAAQA,GAAQ,IAAArE,GAAmBwB,GAAQrpC,EAAM4lC,gBAC7D,YAAYsG,EAAQA,GAAQ,IAAArE,GAAmByB,GAAOiB,GACtD,YAAY2B,EAAQA,GAAQ,IAAArE,GAAmBzzC,GAAQ4L,EAAM6lC,mBAC7D,YAAYqG,EAAQA,GAAQ,IAAArE,IAAoBoE,GAASjsC,EAAM4lC,gBAC/D,MAAMuG,EAAM,IAAIpG,aAAa,EAAE/lC,EAAM4lC,eAAe,IAAK5lC,EAAM4lC,eAAe,IAAK5lC,EAAM4lC,eAAe,KAClGwG,EAAM,IAAIrG,aAAa/lC,EAAM6lC,mBACnC,mBAAmBsG,EAAKA,EAAKD,GAC7B,mBAAmBE,EAAKA,EAAKF,GAC7BnsC,EAAU4qC,yBAAyBwB,EAAI,GAAIA,EAAI,GAAIA,EAAI,IACvDpsC,EAAU6oC,UAAUwD,EAAI,GAAIA,EAAI,GAAIA,EAAI,IACxCrsC,EAAUwiC,UAAU,EAEtBxiC,EAAUssC,mBAAqB,CAACC,EAASj4C,EAAG0E,EAAGiuC,KAC7C,MAAMuF,EAAU,cAAc,IAAIxG,aAAa,KAC/C,GAAgB,IAAZuG,IAA0B,IAANj4C,GAAmB,IAAN0E,GAAmB,IAANiuC,GAAY,CAE5D,MAAMzuC,GAAQ,IAAAsvC,GAAmByE,GAC3BE,EAAI,cACV,kBAAkBA,EAAG,CAACn4C,EAAG0E,EAAGiuC,GAAIzuC,GAChC,cAAcg0C,EAASC,EACzB,CACA,MAAMC,EAAS,IAAI1G,aAAa,GAChC,mBAAmB0G,EAAQ,CAAC,EAAK,GAAM,GAAMF,GAC7C,MAAMG,EAAS,IAAI3G,aAAa,GAChC,mBAAmB2G,EAAQ,CAAC,EAAK,EAAK,GAAMH,GAC5CxsC,EAAU4qC,4BAA4B8B,GACtC1sC,EAAU6oC,aAAa8D,GACvB3sC,EAAUwiC,UAAU,EAEtBxiC,EAAU4sC,qBAAuBC,IAC/B,IAAIC,EAAK,KACL/7C,EAAW,KACf+7C,EAAK7sC,EAAMhP,gBACXF,EAAWkP,EAAMlP,SACjB,MAAM4D,GAAKm4C,EAAG,GACRl4C,GAAKk4C,EAAG,GACR79C,GAAK69C,EAAG,GACRnJ,IAAMhvC,EAAI5D,EAAS,GAAK6D,EAAI7D,EAAS,GAAK9B,EAAI8B,EAAS,IAGvDR,EAAQ,CAACoE,EAAIk4C,EAAO,GAAKj4C,EAAIi4C,EAAO,GAAK59C,EAAI49C,EAAO,GAAKlJ,EAAG,OAGlE,IAAK,IAAIoJ,EAAI,EAAGA,EAAI,EAAGA,IACrB,IAAK,IAAIhV,EAAI,EAAGA,EAAI,EAAGA,IACrB,IAAK,IAAIltC,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,MAAM21C,EAAO7rC,EAAIk4C,EAAOhiD,GAAK+J,EAAIi4C,EAAO,EAAI9U,GAAK9oC,EAAI49C,EAAO,EAAIE,GAAKpJ,EACrEpzC,EAAM,GAAKiwC,EAAOjwC,EAAM,GAAKiwC,EAAOjwC,EAAM,GAC1CA,EAAM,GAAKiwC,EAAOjwC,EAAM,GAAKiwC,EAAOjwC,EAAM,EAC5C,CAGJ,OAAOA,CAAK,CAEhB,CAgDEy8C,CAAUhtC,EAAWC,EACvB,CAQA,IAAIgtC,EAAc,CAChBzsC,YALkB,EAAA4gC,EAAM5gC,YAAYT,EAAQ,aAM5CA,wGCtmBF,MAAM,WACJmtC,EAAU,MACVC,GACE,WACE,oBACJC,GACE,WACE,cACJtI,EAAa,cACb3D,EAAa,gBACbkM,GACE,EAAAjM,EASJ,SAASkM,EAAiCC,EAAKC,GAC7C,MAAMC,EAAIF,EAAI,GACR54C,EAAI44C,EAAI,GACR34C,EAAI24C,EAAI,GACRG,EAAIjrD,KAAKiZ,KAAK+xC,EAAIA,EAAI94C,EAAIA,EAAIC,EAAIA,GAClCuzB,EAAIulB,EAAI,KAAQjrD,KAAKkrD,KAAKF,EAAIC,GAAK,EACnCE,EAAIzlB,EAAI,KAAQ1lC,KAAKkxC,MAAM/+B,EAAGD,GAAK,EACzC64C,EAAI,GAAKE,EACTF,EAAI,GAAKrlB,EACTqlB,EAAI,GAAKI,CACX,CAYA,SAASC,EAAkCL,EAAKM,GAC9C,GAAIN,EAAI,IAAMM,EAAS,GAErB,OAAON,EAAI,GAKb,MAAMO,EAAUP,EAAI,GAAK/qD,KAAKiZ,KAAKoyC,EAASA,EAASN,EAAI,GAAKA,EAAI,KAAOA,EAAI,GAAK/qD,KAAKqX,IAAI0zC,EAAI,KAE/F,OAAIA,EAAI,IAAM,GAAM/qD,KAAKkW,GAChB60C,EAAI,GAAKO,EAEXP,EAAI,GAAKO,CAClB,CAgBA,SAASC,EAA6C7lB,EAAG8lB,EAAMC,EAAMpU,GACnE,MAAMqU,EAAO,GACPC,EAAO,IACb,OAAQH,EAAME,IACd,OAAQD,EAAME,GACd,MAAMC,EAAO,GACPC,EAAO,GACbhB,EAAiCa,EAAME,GACvCf,EAAiCc,EAAME,GAIvC,IAAIC,EAASpmB,EACb,GAAIkmB,EAAK,GAAK,KAAQC,EAAK,GAAK,KA5BlC,SAA2CE,EAAIC,GAC7C,IAAIC,EAAQF,EAAKC,EAIjB,IAHIC,EAAQ,IACVA,GAASA,GAEJA,GAAS,EAAMjsD,KAAKkW,IACzB+1C,GAAS,EAAMjsD,KAAKkW,GAKtB,OAHI+1C,EAAQjsD,KAAKkW,KACf+1C,EAAQ,EAAMjsD,KAAKkW,GAAK+1C,GAEnBA,CACT,CAgB0CC,CAAkCN,EAAK,GAAIC,EAAK,IAAM,IAAO7rD,KAAKkW,GAAI,CAG5G,IAAIi2C,EAAOnsD,KAAKsM,IAAIs/C,EAAK,GAAIC,EAAK,IAClCM,EAAOnsD,KAAKsM,IAAI,GAAM6/C,GAClBzmB,EAAI,IACNmmB,EAAK,GAAKM,EACVN,EAAK,GAAK,EACVA,EAAK,GAAK,EACVC,GAAU,IAEVF,EAAK,GAAKO,EACVP,EAAK,GAAK,EACVA,EAAK,GAAK,EACVE,EAAS,EAAMA,EAAS,EAE5B,CAKIF,EAAK,GAAK,KAAQC,EAAK,GAAK,IAC9BD,EAAK,GAAKR,EAAkCS,EAAMD,EAAK,IAC9CC,EAAK,GAAK,KAAQD,EAAK,GAAK,MACrCC,EAAK,GAAKT,EAAkCQ,EAAMC,EAAK,KAEzD,MAAMO,EAAS,GACfA,EAAO,IAAM,EAAIN,GAAUF,EAAK,GAAKE,EAASD,EAAK,GACnDO,EAAO,IAAM,EAAIN,GAAUF,EAAK,GAAKE,EAASD,EAAK,GACnDO,EAAO,IAAM,EAAIN,GAAUF,EAAK,GAAKE,EAASD,EAAK,GAGnD,MAAMQ,EAAS,IAtFjB,SAA0CtB,EAAKD,GAC7C,MAAMG,EAAIF,EAAI,GACRrlB,EAAIqlB,EAAI,GACRI,EAAIJ,EAAI,GACdD,EAAI,GAAKG,EAAIjrD,KAAKmX,IAAIuuB,GACtBolB,EAAI,GAAKG,EAAIjrD,KAAKqX,IAAIquB,GAAK1lC,KAAKmX,IAAIg0C,GACpCL,EAAI,GAAKG,EAAIjrD,KAAKqX,IAAIquB,GAAK1lC,KAAKqX,IAAI8zC,EACtC,CAgFEmB,CAAiCF,EAAQC,IACzC,OAAQA,EAAQhV,EAClB,CAogCA,MAAMj6B,EAAiB,CACrBwhC,UAAU,EACV2N,WAAY9B,EAAW+B,IACvBC,SAAS,EACTp9C,MAAOq7C,EAAMgC,OACbC,SAAU,KACVC,gBAAiB,KACjBC,gBAAiB,KACjBC,oBAAoB,EACpBC,oBAAoB,EACpBlO,uBAAuB,EACvBgC,MAAO,KACPmM,UAAW,EACXC,UAAW,KACXr2B,MAAO,KACPs2B,YAAY,EACZC,eAAgB,KAKlB,SAAS7vC,EAAOC,EAAWC,GACzB,IAAIC,EAAgBqhC,UAAU51C,OAAS,QAAsBG,IAAjBy1C,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzF7zC,OAAOyS,OAAOF,EAAOJ,EAAgBK,GAGrC,iBAA0BF,EAAWC,EAAOC,GAG5CD,EAAMqjC,MAAQ,GACdrjC,EAAMoZ,MAAQ,GACdpZ,EAAMmvC,SAAW,CAAC,GAAK,EAAK,EAAK,GACjCnvC,EAAMovC,gBAAkB,CAAC,EAAK,EAAK,EAAK,GACxCpvC,EAAMqvC,gBAAkB,CAAC,EAAK,EAAK,EAAK,GACxCrvC,EAAMyvC,UAAY,CAAC,EACnB,EAAAtO,EAAMvc,IAAI5kB,EAAMyvC,WAGhB,EAAAtO,EAAMxzC,IAAIoS,EAAWC,EAAO,CAAC,YAAa,iBAG1C,EAAAmhC,EAAMI,OAAOxhC,EAAWC,EAAO,CAAC,qBAAsB,qBAAsB,aAAc,aAAc,mBACxG,EAAAmhC,EAAMK,SAASzhC,EAAWC,EAAO,CAAC,WAAY,kBAAmB,mBAAoB,GAGrF,EAAAmhC,EAAMM,SAAS1hC,EAAWC,EAAO,CAAC,WAAY,kBAAmB,oBA3iCnE,SAAkCD,EAAWC,GAE3CA,EAAMG,eAAe3N,KAAK,4BAG1BuN,EAAUiZ,QAAU,IAAMhZ,EAAMoZ,MAAM1tB,OAItCqU,EAAUwY,YAAc,CAAClkB,EAAGwzC,EAAG+H,EAAGj7C,IAAMoL,EAAU8vC,gBAAgBx7C,EAAGwzC,EAAG+H,EAAGj7C,EAAG,GAAK,GAInFoL,EAAU8vC,gBAAkB,SAAUx7C,EAAGwzC,EAAG+H,EAAGj7C,GAC7C,IAAIutC,EAAWZ,UAAU51C,OAAS,QAAsBG,IAAjBy1C,UAAU,GAAmBA,UAAU,GAAK,GAC/Ea,EAAYb,UAAU51C,OAAS,QAAsBG,IAAjBy1C,UAAU,GAAmBA,UAAU,GAAK,EAEpF,GAAIY,EAAW,GAAOA,EAAW,EAE/B,OADAhB,EAAc,sCACN,EAEV,GAAIiB,EAAY,GAAOA,EAAY,EAEjC,OADAjB,EAAc,uCACN,EAILlhC,EAAMqhC,uBACTthC,EAAU2iC,YAAYruC,GAIxB,MAAMilB,EAAO,CACXjlB,IACAwzC,IACA+H,IACAj7C,IACAutC,WACAC,aAIFniC,EAAMoZ,MAAM5mB,KAAK8mB,GACjBvZ,EAAUuiC,qBAIV,IAAI13C,EAAI,EACR,KAAOA,EAAIoV,EAAMoZ,MAAM1tB,QACjBsU,EAAMoZ,MAAMxuB,GAAGyJ,IAAMA,EADIzJ,KAQ/B,OAAIA,EAAIoV,EAAMoZ,MAAM1tB,OACXd,GAED,CACV,EAIAmV,EAAU+vC,YAAc,CAACz7C,EAAGs5C,EAAGzlB,EAAG6nB,IAAMhwC,EAAUiwC,gBAAgB37C,EAAGs5C,EAAGzlB,EAAG6nB,EAAG,GAAK,GAInFhwC,EAAUiwC,gBAAkB,SAAU37C,EAAGs5C,EAAGzlB,EAAG6nB,GAC7C,IAAI7N,EAAWZ,UAAU51C,OAAS,QAAsBG,IAAjBy1C,UAAU,GAAmBA,UAAU,GAAK,GAC/Ea,EAAYb,UAAU51C,OAAS,QAAsBG,IAAjBy1C,UAAU,GAAmBA,UAAU,GAAK,EACpF,MAAM2O,EAAM,GACNC,EAAM,CAACvC,EAAGzlB,EAAG6nB,GAEnB,OADA,IAAApC,GAAQuC,EAAKD,GACNlwC,EAAUwY,YAAYlkB,EAAG47C,EAAI,GAAIA,EAAI,GAAIA,EAAI,GAAI/N,EAAUC,EACpE,EAIApiC,EAAU4iC,SAAWvpB,IACnB,GAAIpZ,EAAMoZ,QAAUA,EAAO,CACzB,MAAM+2B,EAASC,KAAKC,UAAUrwC,EAAMoZ,OACpCpZ,EAAMoZ,MAAQA,EACd,MAAMk3B,EAAQF,KAAKC,UAAUrwC,EAAMoZ,OACnC,GAAIrZ,EAAUuiC,sBAAwB6N,IAAWG,EAE/C,OADAvwC,EAAUwiC,YACH,CAEX,CACA,OAAO,CAAK,EAMdxiC,EAAUuiC,mBAAqB,KAC7B,MAAM6N,EAASC,KAAKC,UAAUrwC,EAAMoZ,OACpCpZ,EAAMoZ,MAAM9jB,MAAK,CAACZ,EAAGC,IAAMD,EAAEL,EAAIM,EAAEN,IACnC,MAAMi8C,EAAQF,KAAKC,UAAUrwC,EAAMoZ,OAC7B2pB,EAAkBhjC,EAAU6iC,cAElC,OAAKG,GAAmBoN,IAAWG,EAI5BvN,GAHLhjC,EAAUwiC,YACH,EAEa,EAIxBxiC,EAAU6iC,YAAc,KACtB,MAAMC,EAAW,CAAC,GAClBA,EAAS,GAAK7iC,EAAMuwC,aAAa,GACjC1N,EAAS,GAAK7iC,EAAMuwC,aAAa,GACjC,MAAMrmC,EAAOlK,EAAMoZ,MAAM1tB,OAUzB,OATIwe,GACFlK,EAAMuwC,aAAa,GAAKvwC,EAAMoZ,MAAM,GAAG/kB,EACvC2L,EAAMuwC,aAAa,GAAKvwC,EAAMoZ,MAAMlP,EAAO,GAAG7V,IAE9C2L,EAAMuwC,aAAa,GAAK,EACxBvwC,EAAMuwC,aAAa,GAAK,IAItB1N,EAAS,KAAO7iC,EAAMuwC,aAAa,IAAM1N,EAAS,KAAO7iC,EAAMuwC,aAAa,MAGhFxwC,EAAUwiC,YACH,EAAI,EAKbxiC,EAAU2iC,YAAcruC,IAGtB,IAAIzJ,EAAI,EACR,KAAOA,EAAIoV,EAAMoZ,MAAM1tB,QACjBsU,EAAMoZ,MAAMxuB,GAAGyJ,IAAMA,EADIzJ,KAK/B,MAAMk4C,EAASl4C,EAGf,GAAIA,GAAKoV,EAAMoZ,MAAM1tB,OACnB,OAAQ,EAKV,IAAIq3C,GAAkB,EAQtB,OAPA/iC,EAAMoZ,MAAM11B,OAAOkH,EAAG,GACZ,IAANA,GAAWA,IAAMoV,EAAMoZ,MAAM1tB,SAC/Bq3C,EAAkBhjC,EAAU6iC,eAEzBG,GACHhjC,EAAUwiC,WAELO,CAAM,EAIf/iC,EAAUywC,UAAY,CAACnO,EAAMvoC,KAC3B,GAAIuoC,IAASvoC,EAAb,CAIAiG,EAAU2iC,YAAY5oC,GACtB,IAAK,IAAIlP,EAAI,EAAGA,EAAIoV,EAAMoZ,MAAM1tB,OAAQd,IACtC,GAAIoV,EAAMoZ,MAAMxuB,GAAGyJ,IAAMguC,EAAM,CAC7BriC,EAAMoZ,MAAMxuB,GAAGyJ,EAAIyF,EACnBiG,EAAUuiC,qBACV,KACF,CAPF,CAQA,EAKFviC,EAAUsZ,gBAAkB,KAC1BrZ,EAAMoZ,MAAQ,GACdrZ,EAAUuiC,oBAAoB,EAKhCviC,EAAU0wC,cAAgB,CAACxN,EAAIyN,EAAIC,EAAIC,EAAI1N,EAAI2N,EAAIC,EAAIC,KAErDhxC,EAAUuiC,qBACV,IAAK,IAAI13C,EAAI,EAAGA,EAAIoV,EAAMoZ,MAAM1tB,QAC1BsU,EAAMoZ,MAAMxuB,GAAGyJ,GAAK4uC,GAAMjjC,EAAMoZ,MAAMxuB,GAAGyJ,GAAK6uC,EAChDljC,EAAMoZ,MAAM11B,OAAOkH,EAAG,GAEtBA,IAKJmV,EAAU8vC,gBAAgB5M,EAAIyN,EAAIC,EAAIC,EAAI,GAAK,GAC/C7wC,EAAU8vC,gBAAgB3M,EAAI2N,EAAIC,EAAIC,EAAI,GAAK,GAC/ChxC,EAAUwiC,UAAU,EAKtBxiC,EAAUixC,cAAgB,CAAC/N,EAAIqB,EAAI2M,EAAIC,EAAIhO,EAAIqB,EAAI4M,EAAIC,KACrD,MAAMC,EAAO,CAAC/M,EAAI2M,EAAIC,GAChBI,EAAO,CAAC/M,EAAI4M,EAAIC,GAChBpD,EAAO,GACPC,EAAO,IACb,IAAAN,GAAQ0D,EAAMrD,IACd,IAAAL,GAAQ2D,EAAMrD,GACdluC,EAAU0wC,cAAcxN,EAAI+K,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAI9K,EAAI+K,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAG,EAKvFluC,EAAUwxC,SAAWl9C,IACnB,MAAM47C,EAAM,GAEZ,OADAlwC,EAAUjJ,SAASzC,EAAG47C,GACf,CAACztD,KAAK6O,MAAM,IAAQ4+C,EAAI,GAAK,IAAMztD,KAAK6O,MAAM,IAAQ4+C,EAAI,GAAK,IAAMztD,KAAK6O,MAAM,IAAQ4+C,EAAI,GAAK,IAAM,IAAI,EAKpHlwC,EAAUjJ,SAAW,CAACzC,EAAG47C,KACvB,GAAIjwC,EAAMwxC,cAAV,CACE,MAAMvN,EAAWlkC,EAAUiZ,UAErBgrB,EAAMjkC,EAAU0xC,+BAA+Bp9C,GACrD,GAAI2vC,EAAM,GAAkB,IAAbC,EAAgB,CAC7B,MAAMkL,EAAWpvC,EAAU2xC,yBAC3BzB,EAAI,GAAKd,EAAS,GAClBc,EAAI,GAAKd,EAAS,GAClBc,EAAI,GAAKd,EAAS,EACpB,KAAO,CACL,MAAMwC,EAAU,GAChB5xC,EAAUmZ,aAAa8qB,EAAMC,EAAU0N,GAEvC1B,EAAI,GAAK0B,EAAQ,GACjB1B,EAAI,GAAK0B,EAAQ,GACjB1B,EAAI,GAAK0B,EAAQ,EACnB,CAEF,MACA5xC,EAAUujC,SAASjvC,EAAGA,EAAG,EAAG47C,EAAI,EAKlClwC,EAAU6xC,YAAcv9C,IACtB,MAAM47C,EAAM,GAEZ,OADAlwC,EAAUjJ,SAASzC,EAAG47C,GACfA,EAAI,EAAE,EAKflwC,EAAU8xC,cAAgBx9C,IACxB,MAAM47C,EAAM,GAEZ,OADAlwC,EAAUjJ,SAASzC,EAAG47C,GACfA,EAAI,EAAE,EAKflwC,EAAU+xC,aAAez9C,IACvB,MAAM47C,EAAM,GAEZ,OADAlwC,EAAUjJ,SAASzC,EAAG47C,GACfA,EAAI,EAAE,EAKflwC,EAAUujC,SAAW,CAACyO,EAASC,EAAO9nC,EAAMm5B,KAE1C,MAAMQ,EAASrzC,OAAOuhD,GAChBjO,EAAOtzC,OAAOwhD,GAKpB,IAAI,IAAApnD,GAAMi5C,KAAW,IAAAj5C,GAAMk5C,GAAO,CAChC,IAAK,IAAIl5C,EAAI,EAAGA,EAAIsf,EAAMtf,IACxBy4C,EAAU,EAAJz4C,EAAQ,GAAKoV,EAAMmvC,SAAS,GAClC9L,EAAU,EAAJz4C,EAAQ,GAAKoV,EAAMmvC,SAAS,GAClC9L,EAAU,EAAJz4C,EAAQ,GAAKoV,EAAMmvC,SAAS,GAEpC,MACF,CACA,IAAInL,EAAM,EACV,MAAMC,EAAWjkC,EAAMoZ,MAAM1tB,OAK7B,IAAIumD,EAAQ,EACRC,EAAQ,EACRC,EAAQ,EACK,IAAblO,IACFgO,EAAQjyC,EAAMoZ,MAAM6qB,EAAW,GAAG4D,EAClCqK,EAAQlyC,EAAMoZ,MAAM6qB,EAAW,GAAG2L,EAClCuC,EAAQnyC,EAAMoZ,MAAM6qB,EAAW,GAAGtvC,GAEpC,IAAIN,EAAI,EACJ4uC,EAAK,EACLC,EAAK,EACT,MAAM8K,EAAO,CAAC,EAAK,EAAK,GAClBC,EAAO,CAAC,EAAK,EAAK,GACxB,IAAI/L,EAAW,EACXC,EAAY,EAChB,MAAMiQ,EAAS,GAGf,IAAIC,EAAgBryC,EAAMnO,QAAUq7C,EAAMoF,MACtCD,IAEFA,EAAgBryC,EAAMuwC,aAAa,GAAK,GAE1C,IAAIgC,EAAW,EACXC,EAAS,EACTC,EAAO,EACPJ,IACFE,EAAW/vD,KAAKkwD,MAAM7O,GACtB2O,EAAShwD,KAAKkwD,MAAM5O,IAItB,IAAK,IAAIl5C,EAAI,EAAGA,EAAIsf,EAAMtf,IAAK,CAE7B,MAAMu5C,EAAO,EAAIv5C,EAsBjB,GAjBIsf,EAAO,EACLmoC,GACFI,EAAOF,EAAW3nD,GAAKsf,EAAO,IAAQsoC,EAASD,GAC/Cl+C,EAAI,IAAQo+C,GAEZp+C,EAAIwvC,EAASj5C,GAAKsf,EAAO,IAAQ45B,EAAOD,GAEjCwO,GACTI,EAAO,IAAOF,EAAWC,GACzBn+C,EAAI,IAAQo+C,GAEZp+C,EAAI,IAAOwvC,EAASC,GAMlB9jC,EAAM0vC,WAAY,CACpB,MAAMp/C,EAAQ0P,EAAMuwC,aACpB,GAAIl8C,GAAK/D,EAAM,IAAM+D,GAAK/D,EAAM,GAAI,CAClC,MAAMq/C,EAAiB3vC,EAAM2vC,eACvBgD,EAAariD,EAAM,GAAKA,EAAM,GACpC,GAAIq/C,GAAkB,EACpBt7C,EAAI/D,EAAM,GAAKqiD,EAAa,MACvB,CAEL,MAAMC,GAAMv+C,EAAI/D,EAAM,IAAMqiD,EAEtBE,GAAkB,OAAMlD,EAAiBiD,GAE/Cv+C,EAAI/D,EAAM,GAAKuiD,GAAmBlD,EAAiB,GAAKgD,CAC1D,CACF,CACF,CAGA,KAAO3O,EAAMC,GAAY5vC,EAAI2L,EAAMoZ,MAAM4qB,GAAK3vC,GAC5C2vC,IAKIA,EAAMC,IACRhB,EAAKjjC,EAAMoZ,MAAM4qB,EAAM,GAAG3vC,EAC1B6uC,EAAKljC,EAAMoZ,MAAM4qB,GAAK3vC,EAClBg+C,IACFpP,EAAKzgD,KAAKkwD,MAAMzP,GAChBC,EAAK1gD,KAAKkwD,MAAMxP,IAElB8K,EAAK,GAAKhuC,EAAMoZ,MAAM4qB,EAAM,GAAG6D,EAC/BoG,EAAK,GAAKjuC,EAAMoZ,MAAM4qB,GAAK6D,EAC3BmG,EAAK,GAAKhuC,EAAMoZ,MAAM4qB,EAAM,GAAG4L,EAC/B3B,EAAK,GAAKjuC,EAAMoZ,MAAM4qB,GAAK4L,EAC3B5B,EAAK,GAAKhuC,EAAMoZ,MAAM4qB,EAAM,GAAGrvC,EAC/Bs5C,EAAK,GAAKjuC,EAAMoZ,MAAM4qB,GAAKrvC,EAI3ButC,EAAWliC,EAAMoZ,MAAM4qB,EAAM,GAAG9B,SAChCC,EAAYniC,EAAMoZ,MAAM4qB,EAAM,GAAG7B,UAI7BD,EAAW,OACbA,EAAW,MAETA,EAAW,SACbA,EAAW,SAMjB,GAAI7tC,EAAI2L,EAAMuwC,aAAa,GACzBlN,EAAMc,GAAQ,EACdd,EAAMc,EAAO,GAAK,EAClBd,EAAMc,EAAO,GAAK,EACdnkC,EAAMohC,WACJrhC,EAAU+yC,yBACZzP,EAAMc,GAAQnkC,EAAMqvC,gBAAgB,GACpChM,EAAMc,EAAO,GAAKnkC,EAAMqvC,gBAAgB,GACxChM,EAAMc,EAAO,GAAKnkC,EAAMqvC,gBAAgB,KAExChM,EAAMc,GAAQ8N,EACd5O,EAAMc,EAAO,GAAK+N,EAClB7O,EAAMc,EAAO,GAAKgO,SAGjB,GAAI99C,EAAI2L,EAAMuwC,aAAa,KAAM,OAAMl8C,IAAMA,EAAI,EAGtDgvC,EAAMc,GAAQ,EACdd,EAAMc,EAAO,GAAK,EAClBd,EAAMc,EAAO,GAAK,EACdnkC,EAAMohC,WACJrhC,EAAUgzC,yBACZ1P,EAAMc,GAAQnkC,EAAMovC,gBAAgB,GACpC/L,EAAMc,EAAO,GAAKnkC,EAAMovC,gBAAgB,GACxC/L,EAAMc,EAAO,GAAKnkC,EAAMovC,gBAAgB,IAC/BnL,EAAW,IACpBZ,EAAMc,GAAQnkC,EAAMoZ,MAAM,GAAGyuB,EAC7BxE,EAAMc,EAAO,GAAKnkC,EAAMoZ,MAAM,GAAGw2B,EACjCvM,EAAMc,EAAO,GAAKnkC,EAAMoZ,MAAM,GAAGzkB,SAGhC,GAAY,IAARqvC,IAAcxhD,KAAK44C,IAAI/mC,EAAIwvC,GAAU,MAAQ7jC,EAAM0vC,YACxDzL,EAAW,GACbZ,EAAMc,GAAQnkC,EAAMoZ,MAAM,GAAGyuB,EAC7BxE,EAAMc,EAAO,GAAKnkC,EAAMoZ,MAAM,GAAGw2B,EACjCvM,EAAMc,EAAO,GAAKnkC,EAAMoZ,MAAM,GAAGzkB,IAEjC0uC,EAAMc,GAAQ,EACdd,EAAMc,EAAO,GAAK,EAClBd,EAAMc,EAAO,GAAK,OAEf,CAML,IAAIjc,EAAI,EAgBR,GAdEA,EADEmqB,GACGI,EAAOxP,IAAOC,EAAKD,IAEnB5uC,EAAI4uC,IAAOC,EAAKD,GAKrB/a,EADEA,EAAIga,EACF,GAAMha,EAAIga,EAEV,GAAM,IAAOha,EAAIga,IAAa,EAAMA,GAKtCC,EAAY,IAAM,CAEpB,GAAIja,EAAI,GAAK,CACXmb,EAAMc,GAAQ6J,EAAK,GACnB3K,EAAMc,EAAO,GAAK6J,EAAK,GACvB3K,EAAMc,EAAO,GAAK6J,EAAK,GACvB,QACF,CAEE3K,EAAMc,GAAQ8J,EAAK,GACnB5K,EAAMc,EAAO,GAAK8J,EAAK,GACvB5K,EAAMc,EAAO,GAAK8J,EAAK,GACvB,QAEJ,CAIA,GAAI9L,EAAY,IAAM,CAEpB,GAAIniC,EAAM+uC,aAAe9B,EAAW+B,IAClC3L,EAAMc,IAAS,EAAIjc,GAAK8lB,EAAK,GAAK9lB,EAAI+lB,EAAK,GAC3C5K,EAAMc,EAAO,IAAM,EAAIjc,GAAK8lB,EAAK,GAAK9lB,EAAI+lB,EAAK,GAC/C5K,EAAMc,EAAO,IAAM,EAAIjc,GAAK8lB,EAAK,GAAK9lB,EAAI+lB,EAAK,QAC1C,GAAIjuC,EAAM+uC,aAAe9B,EAAW+F,IAAK,CAC9C,MAAM3B,EAAO,GACPC,EAAO,IACb,OAAQtD,EAAMqD,IACd,OAAQpD,EAAMqD,GACVtxC,EAAMivC,UAAYoC,EAAK,GAAKC,EAAK,GAAK,IAAOA,EAAK,GAAKD,EAAK,GAAK,MAC/DA,EAAK,GAAKC,EAAK,GACjBD,EAAK,IAAM,EAEXC,EAAK,IAAM,GAGf,MAAM2B,EAAS,GACfA,EAAO,IAAM,EAAM/qB,GAAKmpB,EAAK,GAAKnpB,EAAIopB,EAAK,GACvC2B,EAAO,GAAK,IACdA,EAAO,IAAM,GAEfA,EAAO,IAAM,EAAM/qB,GAAKmpB,EAAK,GAAKnpB,EAAIopB,EAAK,GAC3C2B,EAAO,IAAM,EAAM/qB,GAAKmpB,EAAK,GAAKnpB,EAAIopB,EAAK,IAG3C,IAAA3D,GAAQsF,EAAQb,GAChB/O,EAAMc,GAAQiO,EAAO,GACrB/O,EAAMc,EAAO,GAAKiO,EAAO,GACzB/O,EAAMc,EAAO,GAAKiO,EAAO,EAC3B,MAAO,GAAIpyC,EAAM+uC,aAAe9B,EAAWiG,IAAK,CAC9C,MAAMhF,EAAO,GACPC,EAAO,IACb,OAAQH,EAAME,IACd,OAAQD,EAAME,GACd,MAAMU,EAAS,GACfA,EAAO,IAAM,EAAI3mB,GAAKgmB,EAAK,GAAKhmB,EAAIimB,EAAK,GACzCU,EAAO,IAAM,EAAI3mB,GAAKgmB,EAAK,GAAKhmB,EAAIimB,EAAK,GACzCU,EAAO,IAAM,EAAI3mB,GAAKgmB,EAAK,GAAKhmB,EAAIimB,EAAK,IAGzC,OAAQU,EAAQuD,GAChB/O,EAAMc,GAAQiO,EAAO,GACrB/O,EAAMc,EAAO,GAAKiO,EAAO,GACzB/O,EAAMc,EAAO,GAAKiO,EAAO,EAC3B,MAAWpyC,EAAM+uC,aAAe9B,EAAWkG,WACzCpF,EAA6C7lB,EAAG8lB,EAAMC,EAAMmE,GAC5D/O,EAAMc,GAAQiO,EAAO,GACrB/O,EAAMc,EAAO,GAAKiO,EAAO,GACzB/O,EAAMc,EAAO,GAAKiO,EAAO,IAEzBlR,EAAc,mCAAoClhC,EAAM+uC,YAE1D,QACF,CASI7mB,EAAI,GACNA,EAAI,IAAW,EAAJA,KAAa,EAAM,GAAOia,GAC5Bja,EAAI,KACbA,EAAI,EAAM,IAAmB,GAAX,EAAMA,MAAY,EAAI,GAAOia,IAIjD,MAAMiC,EAAKlc,EAAIA,EACTmc,EAAMD,EAAKlc,EACXoc,EAAK,EAAMD,EAAM,EAAID,EAAK,EAC1BG,GAAM,EAAIF,EAAM,EAAID,EACpBI,EAAKH,EAAM,EAAID,EAAKlc,EACpBuc,EAAKJ,EAAMD,EACjB,IAAIz1B,EACA+1B,EACJ,GAAI1kC,EAAM+uC,aAAe9B,EAAW+B,IAClC,IAAK,IAAIlX,EAAI,EAAGA,EAAI,EAAGA,IAErBnpB,EAAQs/B,EAAKnW,GAAKkW,EAAKlW,GACvB4M,GAAK,EAAMvC,GAAaxzB,EAGxB00B,EAAMc,EAAOrM,GAAKwM,EAAK0J,EAAKlW,GAAKyM,EAAK0J,EAAKnW,GAAK0M,EAAKE,EAAID,EAAKC,OAE3D,GAAI1kC,EAAM+uC,aAAe9B,EAAW+F,IAAK,CAC9C,MAAM3B,EAAO,GACPC,EAAO,IACb,OAAQtD,EAAMqD,IACd,OAAQpD,EAAMqD,GACVtxC,EAAMivC,UAAYoC,EAAK,GAAKC,EAAK,GAAK,IAAOA,EAAK,GAAKD,EAAK,GAAK,MAC/DA,EAAK,GAAKC,EAAK,GACjBD,EAAK,IAAM,EAEXC,EAAK,IAAM,GAGf,MAAM2B,EAAS,GACf,IAAK,IAAInb,EAAI,EAAGA,EAAI,EAAGA,IAErBnpB,EAAQ2iC,EAAKxZ,GAAKuZ,EAAKvZ,GACvB4M,GAAK,EAAMvC,GAAaxzB,EAGxBskC,EAAOnb,GAAKwM,EAAK+M,EAAKvZ,GAAKyM,EAAK+M,EAAKxZ,GAAK0M,EAAKE,EAAID,EAAKC,EAC9C,IAAN5M,GAAWmb,EAAOnb,GAAK,IACzBmb,EAAOnb,IAAM,IAIjB,IAAA6V,GAAQsF,EAAQb,GAChB/O,EAAMc,GAAQiO,EAAO,GACrB/O,EAAMc,EAAO,GAAKiO,EAAO,GACzB/O,EAAMc,EAAO,GAAKiO,EAAO,EAC3B,MAAO,GAAIpyC,EAAM+uC,aAAe9B,EAAWiG,IAAK,CAC9C,MAAMhF,EAAO,GACPC,EAAO,IACb,OAAQH,EAAME,IACd,OAAQD,EAAME,GACd,MAAMU,EAAS,GACf,IAAK,IAAI/W,EAAI,EAAGA,EAAI,EAAGA,IAErBnpB,EAAQw/B,EAAKrW,GAAKoW,EAAKpW,GACvB4M,GAAK,EAAMvC,GAAaxzB,EAGxBkgC,EAAO/W,GAAKwM,EAAK4J,EAAKpW,GAAKyM,EAAK4J,EAAKrW,GAAK0M,EAAKE,EAAID,EAAKC,GAG1D,OAAQmK,EAAQuD,GAChB/O,EAAMc,GAAQiO,EAAO,GACrB/O,EAAMc,EAAO,GAAKiO,EAAO,GACzB/O,EAAMc,EAAO,GAAKiO,EAAO,EAC3B,MAAWpyC,EAAM+uC,aAAe9B,EAAWkG,WAIzCpF,EAA6C7lB,EAAG8lB,EAAMC,EAAMmE,GAC5D/O,EAAMc,GAAQiO,EAAO,GACrB/O,EAAMc,EAAO,GAAKiO,EAAO,GACzB/O,EAAMc,EAAO,GAAKiO,EAAO,IAEzBlR,EAAc,oCAIhB,IAAK,IAAIpJ,EAAI,EAAGA,EAAI,EAAGA,IACrBuL,EAAMc,EAAOrM,GAAKuL,EAAMc,EAAOrM,GAAK,EAAM,EAAMuL,EAAMc,EAAOrM,GAC7DuL,EAAMc,EAAOrM,GAAKuL,EAAMc,EAAOrM,GAAK,EAAM,EAAMuL,EAAMc,EAAOrM,EAEjE,CACF,GAIF/3B,EAAUqzC,cAAgB,SAAUvP,EAAQC,EAAM55B,GAChD,IAAImpC,EAAY/R,UAAU51C,OAAS,QAAsBG,IAAjBy1C,UAAU,IAAmBA,UAAU,GAC/E,GAAIvhC,EAAUuzC,YAActzC,EAAMyvC,WAAazvC,EAAMwvC,YAActlC,GAAQlK,EAAMuzC,iBAAmBF,EAClG,OAAOrzC,EAAMqjC,MAEf,GAA2B,IAAvBrjC,EAAMoZ,MAAM1tB,OAEd,OADAw1C,EAAc,+DACPlhC,EAAMqjC,MAEf,MAAMmQ,EAAaH,EAAY,EAAI,EAC/BrzC,EAAMwvC,YAActlC,GAAQlK,EAAMuzC,iBAAmBF,IACvDrzC,EAAMqjC,MAAQ,IAAIr0B,WAAW9E,EAAOspC,GACpCxzC,EAAMwvC,UAAYtlC,EAClBlK,EAAMuzC,eAAiBF,GAEzB,MAAMI,EAAW,GACjB1zC,EAAUujC,SAASO,EAAQC,EAAM55B,EAAMupC,GACvC,IAAK,IAAI7oD,EAAI,EAAGA,EAAIsf,EAAMtf,IACxBoV,EAAMqjC,MAAMz4C,EAAI4oD,EAAa,GAAKhxD,KAAK6O,MAA4B,IAAtBoiD,EAAa,EAAJ7oD,EAAQ,GAAa,IAC3EoV,EAAMqjC,MAAMz4C,EAAI4oD,EAAa,GAAKhxD,KAAK6O,MAA4B,IAAtBoiD,EAAa,EAAJ7oD,EAAQ,GAAa,IAC3EoV,EAAMqjC,MAAMz4C,EAAI4oD,EAAa,GAAKhxD,KAAK6O,MAA4B,IAAtBoiD,EAAa,EAAJ7oD,EAAQ,GAAa,IACvEyoD,IACFrzC,EAAMqjC,MAAMz4C,EAAI4oD,EAAa,GAAK,KAItC,OADAxzC,EAAMyvC,UAAUlN,WACTviC,EAAMqjC,KACf,EACAtjC,EAAU2zC,uBAAyB9/C,IACjCmM,EAAUsZ,kBACV,MAAM5I,EAAgB7c,EAAM2I,wBAC5B,IAAK,IAAI3R,EAAI,EAAGA,EAAIgJ,EAAM+/C,oBAAqB/oD,IAC7C,OAAQ6lB,GACN,KAAK,EAEDzQ,EAAMoZ,MAAM5mB,KAAK,CACf6B,EAAGzJ,EACHi9C,EAAGj0C,EAAMggD,aAAahpD,EAAG,GACzBglD,EAAGh8C,EAAMggD,aAAahpD,EAAG,GACzB+J,EAAGf,EAAMggD,aAAahpD,EAAG,GACzBs3C,SAAU,GACVC,UAAW,IAEb,MAEJ,KAAK,EAEDniC,EAAMoZ,MAAM5mB,KAAK,CACf6B,EAAGT,EAAMggD,aAAahpD,EAAG,GACzBi9C,EAAGj0C,EAAMggD,aAAahpD,EAAG,GACzBglD,EAAGh8C,EAAMggD,aAAahpD,EAAG,GACzB+J,EAAGf,EAAMggD,aAAahpD,EAAG,GACzBs3C,SAAU,GACVC,UAAW,IAEb,MAEJ,KAAK,EAEDniC,EAAMoZ,MAAM5mB,KAAK,CACf6B,EAAGzJ,EACHi9C,EAAGj0C,EAAMggD,aAAahpD,EAAG,GACzBglD,EAAGh8C,EAAMggD,aAAahpD,EAAG,GACzB+J,EAAGf,EAAMggD,aAAahpD,EAAG,GACzBs3C,SAAUtuC,EAAMggD,aAAahpD,EAAG,GAChCu3C,UAAWvuC,EAAMggD,aAAahpD,EAAG,KAEnC,MAEJ,KAAK,EAEDoV,EAAMoZ,MAAM5mB,KAAK,CACf6B,EAAGT,EAAMggD,aAAahpD,EAAG,GACzBi9C,EAAGj0C,EAAMggD,aAAahpD,EAAG,GACzBglD,EAAGh8C,EAAMggD,aAAahpD,EAAG,GACzB+J,EAAGf,EAAMggD,aAAahpD,EAAG,GACzBs3C,SAAUtuC,EAAMggD,aAAahpD,EAAG,GAChCu3C,UAAWvuC,EAAMggD,aAAahpD,EAAG,KAM3CmV,EAAUuiC,oBAAoB,EAIhCviC,EAAU8zC,uBAAyB,CAAChQ,EAAQC,EAAM55B,EAAMm5B,KACtD,IAAIyQ,EAAM,EACV/zC,EAAUsZ,kBACNnP,EAAO,IACT4pC,GAAOhQ,EAAOD,IAAW35B,EAAO,IAElC,IAAK,IAAItf,EAAI,EAAGA,EAAIsf,EAAMtf,IAAK,CAC7B,MAAM0uB,EAAO,CACXjlB,EAAGwvC,EAASiQ,EAAMlpD,EAClBi9C,EAAGxE,EAAU,EAAJz4C,GACTglD,EAAGvM,EAAU,EAAJz4C,EAAQ,GACjB+J,EAAG0uC,EAAU,EAAJz4C,EAAQ,GACjBu3C,UAAW,EACXD,SAAU,IAEZliC,EAAMoZ,MAAM5mB,KAAK8mB,EACnB,CACAvZ,EAAUuiC,oBAAoB,EAKhCviC,EAAUmZ,aAAe,CAAC/qB,EAAO8zC,IAC3B9zC,EAAQ,GAAKA,GAAS6R,EAAMoZ,MAAM1tB,QACpCw1C,EAAc,wBACN,IAEVe,EAAI,GAAKjiC,EAAMoZ,MAAMjrB,GAAOkG,EAC5B4tC,EAAI,GAAKjiC,EAAMoZ,MAAMjrB,GAAO05C,EAC5B5F,EAAI,GAAKjiC,EAAMoZ,MAAMjrB,GAAOyhD,EAC5B3N,EAAI,GAAKjiC,EAAMoZ,MAAMjrB,GAAOwG,EAC5BstC,EAAI,GAAKjiC,EAAMoZ,MAAMjrB,GAAO+zC,SAC5BD,EAAI,GAAKjiC,EAAMoZ,MAAMjrB,GAAOg0C,UACrB,GAKTpiC,EAAUqiC,aAAe,CAACj0C,EAAO8zC,KAC/B,GAAI9zC,EAAQ,GAAKA,GAAS6R,EAAMoZ,MAAM1tB,OAEpC,OADAw1C,EAAc,wBACN,EAEV,MAAMmB,EAAOriC,EAAMoZ,MAAMjrB,GAAOkG,EAgBhC,OAfA2L,EAAMoZ,MAAMjrB,GAAOkG,EAAI4tC,EAAI,GAC3BjiC,EAAMoZ,MAAMjrB,GAAO05C,EAAI5F,EAAI,GAC3BjiC,EAAMoZ,MAAMjrB,GAAOyhD,EAAI3N,EAAI,GAC3BjiC,EAAMoZ,MAAMjrB,GAAOwG,EAAIstC,EAAI,GAC3BjiC,EAAMoZ,MAAMjrB,GAAO+zC,SAAWD,EAAI,GAClCjiC,EAAMoZ,MAAMjrB,GAAOg0C,UAAYF,EAAI,GAC/BI,IAASJ,EAAI,GAGfliC,EAAUuiC,qBAIVviC,EAAUwiC,WAEL,CAAC,EAIVxiC,EAAUg0C,2BAA6B,IACjC/zC,EAAMwxC,eAAiBzxC,EAAUiZ,UAC5BjZ,EAAUiZ,UAEfhZ,EAAMwvC,UAIDxvC,EAAMwvC,UAER,SAITzvC,EAAUi0C,gBAAkB,CAAChQ,EAAK1tC,KAChC,MAAM1B,EAAImL,EAAUiZ,UACpB,GAAIpkB,EAAI,GAAKovC,GAAO,EAAG,CACrB,MAAMiQ,EAAY,GAClBl0C,EAAUmZ,aAAa8qB,EAAMpvC,EAAGq/C,GAChC,IAAK,IAAInc,EAAI,EAAGA,EAAI,IAAKA,EACvBxhC,EAAKwhC,GAAKmc,EAAUnc,EAAI,GAG1B,YADAxhC,EAAK,GAAK,EAEZ,CACA,MAAM64C,EAAWpvC,EAAU2xC,yBAC3Bp7C,EAAK,GAAK64C,EAAS,GACnB74C,EAAK,GAAK64C,EAAS,GACnB74C,EAAK,GAAK64C,EAAS,GACnB74C,EAAK,GAAK,CAAG,EAIfyJ,EAAUm0C,oBAAsB,CAACC,EAAIC,KACnC,KAAID,GAAM,IAAMC,EAAhB,CAGAr0C,EAAUsZ,kBACV,IAAK,IAAIzuB,EAAI,EAAGA,EAAIupD,EAAIvpD,IACtBmV,EAAUwY,YAAY67B,EAAQ,EAAJxpD,GAAQwpD,EAAQ,EAAJxpD,EAAQ,GAAIwpD,EAAQ,EAAJxpD,EAAQ,GAAIwpD,EAAQ,EAAJxpD,EAAQ,GAHhF,CAIA,EAIFmV,EAAUJ,gBAAkB,CAACxG,EAAKrK,KAChC,MAAMwB,EAAQ,CAAC6I,EAAKrK,GACdulD,EAAgBt0C,EAAUpT,WAChC,GAAI0nD,EAAc,KAAO/jD,EAAM,IAAM+jD,EAAc,KAAO/jD,EAAM,GAC9D,OAEF,GAAIA,EAAM,KAAOA,EAAM,GAErB,YADA4wC,EAAc,yCAGhB,MAAMrvC,GAASvB,EAAM,GAAKA,EAAM,KAAO+jD,EAAc,GAAKA,EAAc,IAClE76C,EAAQlJ,EAAM,GAAK+jD,EAAc,GAAKxiD,EAC5C,IAAK,IAAIjH,EAAI,EAAGA,EAAIoV,EAAMoZ,MAAM1tB,SAAUd,EACxCoV,EAAMoZ,MAAMxuB,GAAGyJ,EAAI2L,EAAMoZ,MAAMxuB,GAAGyJ,EAAIxC,EAAQ2H,EAEhDwG,EAAMuwC,aAAa,GAAKjgD,EAAM,GAC9B0P,EAAMuwC,aAAa,GAAKjgD,EAAM,GAC9ByP,EAAUwiC,UAAU,EAItBxiC,EAAUwjC,YAAcjzC,IACtB,MAAMkzC,EAAgBzjC,EAAUpT,WAG1BsjD,EAAM,GACRzM,EAAc,GAAKlzC,EAAM,IAC3ByP,EAAUjJ,SAASxG,EAAM,GAAI2/C,GAC7BlwC,EAAUwY,YAAYjoB,EAAM,GAAI2/C,EAAI,GAAIA,EAAI,GAAIA,EAAI,MAEpDlwC,EAAUjJ,SAAS0sC,EAAc,GAAIyM,GACrClwC,EAAUwY,YAAYjoB,EAAM,GAAI2/C,EAAI,GAAIA,EAAI,GAAIA,EAAI,KAElDzM,EAAc,GAAKlzC,EAAM,IAC3ByP,EAAUjJ,SAASxG,EAAM,GAAI2/C,GAC7BlwC,EAAUwY,YAAYjoB,EAAM,GAAI2/C,EAAI,GAAIA,EAAI,GAAIA,EAAI,MAEpDlwC,EAAUjJ,SAAS0sC,EAAc,GAAIyM,GACrClwC,EAAUwY,YAAYjoB,EAAM,GAAI2/C,EAAI,GAAIA,EAAI,GAAIA,EAAI,KAItDlwC,EAAUuiC,qBACV,IAAK,IAAI13C,EAAI,EAAGA,EAAIoV,EAAMoZ,MAAM1tB,QAC1BsU,EAAMoZ,MAAMxuB,GAAGyJ,GAAK/D,EAAM,IAAM0P,EAAMoZ,MAAMxuB,GAAGyJ,GAAK/D,EAAM,GAC5D0P,EAAMoZ,MAAM11B,OAAOkH,EAAG,KAEpBA,EAGN,OAAO,CAAC,EAIVmV,EAAU0jC,2BAA6B,CAACR,EAAIC,KAC1C,MAAMQ,EAAI3jC,EAAU4jC,uBACpB,OAAOnhD,KAAK22C,MAAM+J,EAAKD,GAAMS,EAAE,EAIjC3jC,EAAU4jC,qBAAuB,KAC/B,GAAI3jC,EAAMoZ,MAAM1tB,OAAS,EACvB,OAAQ,EAEV,IAAI20C,EAAW7vC,OAAOwxC,UACtB,IAAK,IAAIp3C,EAAI,EAAGA,EAAIoV,EAAMoZ,MAAM1tB,OAAS,EAAGd,IAAK,CAC/C,MAAMg5C,EAAc5jC,EAAMoZ,MAAMxuB,EAAI,GAAGyJ,EAAI2L,EAAMoZ,MAAMxuB,GAAGyJ,EACtDuvC,EAAcvD,IAChBA,EAAWuD,EAEf,CACA,OAAOvD,CAAQ,EAEjBtgC,EAAUu0C,uBAAyB,CAACC,EAAOC,EAAQC,EAAWC,KAChC,IAAxB30C,EAAUiZ,UAIVhZ,EAAMwxC,cACRzxC,EAAU40C,eAAeJ,EAAOC,EAAQC,EAAWC,GAEnD30C,EAAU60C,QAAQL,EAAOC,EAAQC,EAAWC,GAN5C7P,EAAc,mCAOhB,EAIF9kC,EAAU60C,QAAU,CAACL,EAAOC,EAAQC,EAAWC,KAC7C,GAA4B,IAAxB30C,EAAUiZ,UAEZ,YADAo0B,EAAgB,oCAGlB,MAAM/D,EAAQ7mD,KAAK6O,MAA6B,IAAvB0O,EAAU80C,WAAqB,IAClDnpD,EAAS6oD,EAAMZ,oBACfmB,EAASP,EAAMh4C,wBACfw4C,EAAUP,EAAOQ,UACjBC,EAASV,EAAMS,UACf/E,EAAM,GACZ,GAAIwE,IAActH,EAAoB+H,KACpC,IAAK,IAAItqD,EAAI,EAAGA,EAAIc,EAAQd,IAAK,CAC/B,MAAMyJ,EAAI4gD,EAAOrqD,EAAIkqD,EAASJ,GAC9B30C,EAAUjJ,SAASzC,EAAG47C,GACtB8E,EAAY,EAAJnqD,GAASpI,KAAK6O,MAAe,IAAT4+C,EAAI,GAAa,IAC7C8E,EAAY,EAAJnqD,EAAQ,GAAKpI,KAAK6O,MAAe,IAAT4+C,EAAI,GAAa,IACjD8E,EAAY,EAAJnqD,EAAQ,GAAKpI,KAAK6O,MAAe,IAAT4+C,EAAI,GAAa,IACjD8E,EAAY,EAAJnqD,EAAQ,GAAKy+C,CACvB,CAEF,GAAIoL,IAActH,EAAoB6B,IACpC,IAAK,IAAIpkD,EAAI,EAAGA,EAAIc,EAAQd,IAAK,CAC/B,MAAMyJ,EAAI4gD,EAAOrqD,EAAIkqD,EAASJ,GAC9B30C,EAAUjJ,SAASzC,EAAG47C,GACtB8E,EAAY,EAAJnqD,GAASpI,KAAK6O,MAAe,IAAT4+C,EAAI,GAAa,IAC7C8E,EAAY,EAAJnqD,EAAQ,GAAKpI,KAAK6O,MAAe,IAAT4+C,EAAI,GAAa,IACjD8E,EAAY,EAAJnqD,EAAQ,GAAKpI,KAAK6O,MAAe,IAAT4+C,EAAI,GAAa,GACnD,CAEF,GAAIwE,IAActH,EAAoBgI,UACpC,IAAK,IAAIvqD,EAAI,EAAGA,EAAIc,EAAQd,IAAK,CAC/B,MAAMyJ,EAAI4gD,EAAOrqD,EAAIkqD,EAASJ,GAC9B30C,EAAUjJ,SAASzC,EAAG47C,GACtB8E,EAAQnqD,GAAKpI,KAAK6O,MAAe,KAAT4+C,EAAI,GAAqB,OAATA,EAAI,GAAuB,MAATA,EAAI,GAAa,GAC7E,CAEF,GAAIwE,IAActH,EAAoBiI,gBACpC,IAAK,IAAIxqD,EAAI,EAAGA,EAAIc,EAAQd,IAAK,CAC/B,MAAMyJ,EAAI4gD,EAAOrqD,EAAIkqD,EAASJ,GAC9B30C,EAAUjJ,SAASzC,EAAG47C,GACtB8E,EAAY,EAAJnqD,GAASpI,KAAK6O,MAAe,KAAT4+C,EAAI,GAAqB,OAATA,EAAI,GAAuB,MAATA,EAAI,GAAa,IAC/E8E,EAAY,EAAJnqD,EAAQ,GAAKy+C,CACvB,CACF,EAIFtpC,EAAUs1C,cAAgBC,IACxB,MAAMC,EAAgBnF,KAAKC,UAAUrwC,EAAM+uC,YACvCuG,EAASrI,aACXjtC,EAAM+uC,WAAa9B,EAAWqI,EAASrI,WAAWuI,oBACzB3pD,IAArBmU,EAAM+uC,aACR7N,EAAc,cAAcoU,EAASrI,+CACrCjtC,EAAM+uC,WAAa9B,EAAW+B,MAGlC,IAAIyG,EAAaF,IAAkBnF,KAAKC,UAAUrwC,EAAM+uC,YACxD,MAAM2G,EAAcD,GAAcrF,KAAKC,UAAUrwC,EAAMmvC,UACvD,GAAImG,EAASK,SAEX,IADA31C,EAAMmvC,SAAW,GAAGr3B,OAAOw9B,EAASK,UAC7B31C,EAAMmvC,SAASzjD,OAAS,GAC7BsU,EAAMmvC,SAAS38C,KAAK,GAGxBijD,EAAaA,GAAcC,IAAgBtF,KAAKC,UAAUrwC,EAAMmvC,UAChE,MAAMyG,EAAWH,GAAcrF,KAAKC,UAAUrwC,EAAMoZ,OACpD,GAAIk8B,EAASv9B,UAAW,CACtB,MAAM7N,EAAOorC,EAASv9B,UAAUrsB,OAChCsU,EAAMoZ,MAAQ,GACd,MAAM8oB,EAAW,GACXC,EAAY,EAClB,IAAK,IAAIv3C,EAAI,EAAGA,EAAIsf,EAAMtf,GAAK,EAC7BoV,EAAMoZ,MAAM5mB,KAAK,CACf6B,EAAGihD,EAASv9B,UAAUntB,GACtBi9C,EAAGyN,EAASv9B,UAAUntB,EAAI,GAC1BglD,EAAG0F,EAASv9B,UAAUntB,EAAI,GAC1B+J,EAAG2gD,EAASv9B,UAAUntB,EAAI,GAC1Bs3C,WACAC,aAGN,CACA,MAAMY,EAAkBhjC,EAAUuiC,qBAC5BuT,GAAgB9S,IAAoB0S,GAAcG,IAAaxF,KAAKC,UAAUrwC,EAAMoZ,QAE1F,OADIy8B,GAAc91C,EAAUwiC,WACrBQ,GAAmB8S,CAAY,CAE1C,CAwDEC,CAAyB/1C,EAAWC,EACtC,CAQA,IAAI+1C,EAA6B,CAC/Bx1C,YALkB,EAAA4gC,EAAM5gC,YAAYT,EAAQ,4BAM5CA,YACG,yEC7rCL,MAAMk2C,EAAYvoD,OAAOuT,OAAO,MAChC,EAAA+uC,EAAe3gD,QAAOg7B,GAAKA,EAAErS,YAAW3oB,QAAOg7B,GAAsB,WAAjBA,EAAE6iB,aAAyB96C,SAAQi4B,IACrF4rB,EAAU5rB,EAAEjT,MAAQiT,CAAC,IAKvB,MAAM5S,EAAiB/pB,OAAOyU,KAAK8zC,GACnCx+B,EAAeliB,OAiCf,IAAI2gD,EAAe,CACjBC,UAxBF,SAAmBC,GACZA,EAAOp+B,WAAmC,WAAtBo+B,EAAOlJ,aAG3B+I,EAAUG,EAAOh/B,QACpBK,EAAehlB,KAAK2jD,EAAOh/B,MAC3BK,EAAeliB,QAEjB0gD,EAAUG,EAAOh/B,MAAQg/B,EAC3B,EAgBEC,mBAZF,SAA4BvgD,GAC1B,MAAM1H,EAAQqpB,EAAeppB,QAAQyH,GACjC1H,GAAS,GACXqpB,EAAe9zB,OAAOyK,EAAO,UAExB6nD,EAAUngD,EACnB,EAOE6hB,gBAhCF,SAAyB7hB,GACvB,OAAOmgD,EAAUngD,EACnB,EA+BE2hB,wICxCF,MAAM,gBACJ6+B,EAAe,mBACfC,GACE,WACE,YACJC,GACE,UAyPJ,MAAM32C,EAAiB,CACrB42C,YAAaD,EAAYE,KACzBC,eAAgB,CACdC,QAASJ,EAAYE,KACrBG,MAAM,GAERC,mBAAmB,EACnBC,mBAAmB,EACnBC,wBAAwB,GAK1B,SAASj3C,EAAOC,EAAWC,GACzB,IAAIC,EAAgBqhC,UAAU51C,OAAS,QAAsBG,IAAjBy1C,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzF7zC,OAAOyS,OAAOF,EAAOJ,EAAgBK,GAGrC,WAA8BF,EAAWC,EAAOC,GAChD,EAAAkhC,EAAMxzC,IAAIoS,EAAWC,EAAO,CAAC,gBAC7B,EAAAmhC,EAAMI,OAAOxhC,EAAWC,EAAO,CAAC,iBAAkB,oBAAqB,oBAAqB,2BAC5F,UAAyBg3C,mCAAmCj3C,EAAWC,GAxQzE,SAAwBD,EAAWC,GAmHjC,SAASi3C,IACP,IAAIC,EACJ,OAAQl3C,EAAMw2C,aACZ,KAAKD,EAAYY,EACfD,EAAU,EACV,MACF,KAAKX,EAAYa,EACfF,EAAU,EACV,MACF,KAAKX,EAAYc,EACfH,EAAU,EACV,MACF,QAKE,YAJAl3C,EAAM02C,eAAiB,CACrBC,QAAS32C,EAAMw2C,YACfI,MAAM,IAOZ,MAAMruD,EAAYwX,EAAUu3C,kBAAkBzqD,eACxC0qD,GAAY,OAA0BhvD,GAG5C,IAAIouD,EAAU,EACd,KAAOA,EAAU,GAC0B,IAArCY,EAAUL,EAAU,EAAIP,KADRA,GAKtB,MAAMC,EAAOW,EAAUL,EAAU,EAAIP,GAAW,EAChD32C,EAAM02C,eAAiB,CACrBC,UACAC,OAEJ,CAtJA52C,EAAMG,eAAe3N,KAAK,kBAC1BuN,EAAUy3C,mBAAqBC,IAC7B,MAAMzwD,EAAQ+Y,EAAUu3C,kBACxB,IAAII,EACJ,GAAmB,IAAfD,EAAI/rD,OACNgsD,EAAOD,OACF,GAAIjnD,OAAOisC,SAASgb,GAAM,CAC/B,MAAME,EAAM3wD,EAAM4wD,YAClB,OAAQ53C,EAAMw2C,aACZ,KAAKD,EAAYY,EACfO,EAAO,CAACD,GAAME,EAAI,GAAKA,EAAI,IAAM,GAAIA,EAAI,GAAKA,EAAI,IAAM,GACxD,MACF,KAAKpB,EAAYa,EACfM,EAAO,EAAEC,EAAI,GAAKA,EAAI,IAAM,EAAGF,GAAME,EAAI,GAAKA,EAAI,IAAM,GACxD,MACF,KAAKpB,EAAYc,EACfK,EAAO,EAAEC,EAAI,GAAKA,EAAI,IAAM,GAAIA,EAAI,GAAKA,EAAI,IAAM,EAAGF,GAG5D,CACA,MAAMI,EAAM,CAAC,EAAG,EAAG,GACnB7wD,EAAMgG,aAAa0qD,EAAMG,GACzB,MAAMC,EAAK9wD,EAAM+wD,aACX,QACJpB,GACE52C,EAAUi4C,oBACd,IAAIx2C,EAAQ,EACZ,OAAQm1C,GACN,KAAKJ,EAAY0B,EACfz2C,GAAQ,OAAWq2C,EAAI,GAAIC,EAAG,GAAIA,EAAG,IACrC,MACF,KAAKvB,EAAY2B,EACf12C,GAAQ,OAAWq2C,EAAI,GAAIC,EAAG,GAAIA,EAAG,IACrC,MACF,KAAKvB,EAAY4B,EACf32C,GAAQ,OAAWq2C,EAAI,GAAIC,EAAG,GAAIA,EAAG,IACrC,MACF,QACE,OAAO,EAEX,OAAOt2C,CAAK,EAEdzB,EAAUq4C,mBAAqBC,IAC7B,MAAMtQ,EAAKsQ,EAAIC,gBACf,OAAQt4C,EAAMw2C,aACZ,KAAKD,EAAY0B,EACjB,KAAK1B,EAAY2B,EACjB,KAAK3B,EAAY4B,EACf,CACE,MAAM32C,EAAQzB,EAAUy3C,mBAAmBzP,GAC3ChoC,EAAUw4C,SAAS/2C,EACrB,CACA,MACF,KAAK+0C,EAAYY,EACfp3C,EAAUw4C,SAASxQ,EAAG,IACtB,MACF,KAAKwO,EAAYa,EACfr3C,EAAUw4C,SAASxQ,EAAG,IACtB,MACF,KAAKwO,EAAYc,EACft3C,EAAUw4C,SAASxQ,EAAG,IAE1B,EAEFhoC,EAAUy4C,UAAYpzD,IACpB2a,EAAU04C,eAAelC,EAAYY,GACrCp3C,EAAUw4C,SAASnzD,EAAG,EAExB2a,EAAU24C,UAAYtzD,IACpB2a,EAAU04C,eAAelC,EAAYa,GACrCr3C,EAAUw4C,SAASnzD,EAAG,EAExB2a,EAAU44C,UAAYvzD,IACpB2a,EAAU04C,eAAelC,EAAYc,GACrCt3C,EAAUw4C,SAASnzD,EAAG,EAExB2a,EAAU64C,UAAYxzD,IACpB2a,EAAU04C,eAAelC,EAAY0B,GACrCl4C,EAAUw4C,SAASnzD,EAAG,EAExB2a,EAAU84C,UAAYzzD,IACpB2a,EAAU04C,eAAelC,EAAY2B,GACrCn4C,EAAUw4C,SAASnzD,EAAG,EAExB2a,EAAU+4C,UAAY1zD,IACpB2a,EAAU04C,eAAelC,EAAY4B,GACrCp4C,EAAUw4C,SAASnzD,EAAG,EAExB2a,EAAUg5C,qBAAuB,KAC/B,MAAMC,EAAM,CAAC,EAAG,EAAG,GACbC,EAAOl5C,EAAUu3C,kBAAkBzqD,eACzC,OAAQmT,EAAMw2C,aACZ,KAAKD,EAAYY,EACf6B,EAAI,GAAK,EACT,MACF,KAAKzC,EAAYa,EACf4B,EAAI,GAAK,EACT,MACF,KAAKzC,EAAYc,EACf2B,EAAI,GAAK,EACT,MACF,KAAKzC,EAAY0B,GACf,OAAkBgB,EAAM,CAAC,EAAG,EAAG,GAAID,GACnC,MACF,KAAKzC,EAAY2B,GACf,OAAkBe,EAAM,CAAC,EAAG,EAAG,GAAID,GACnC,MACF,KAAKzC,EAAY4B,GACf,OAAkBc,EAAM,CAAC,EAAG,EAAG,GAAID,GAGvC,OAAOA,CAAG,EAwCZj5C,EAAU04C,eAAiB10B,IACrB/jB,EAAMw2C,cAAgBzyB,IAG1B/jB,EAAMw2C,YAAczyB,EAChBhkB,EAAUu3C,mBACZL,IAEFl3C,EAAUwiC,WAAU,EAEtBxiC,EAAUi4C,kBAAoB,UACEnsD,IAAzBmU,EAAM02C,gBAAgC12C,EAAM02C,eAAeC,UAAYJ,EAAYE,OAAS12C,EAAUu3C,mBACzGL,IAEKj3C,EAAM02C,gBAEf32C,EAAU63C,UAAY,KACpB,MAAM5wD,EAAQ+Y,EAAUu3C,kBACxB,IAAKtwD,EACH,OAAO,SAET,IAAKgZ,EAAMk5C,iBACT,OAAOlyD,EAAM4wD,YAEf,MAAME,EAAK93C,EAAMm5C,oBAAoB33C,SAC/B,QACJm1C,GACE52C,EAAUi4C,oBACd,IAAIoB,EAASp5C,EAAMwB,MAKnB,OAJIm1C,IAAY32C,EAAMw2C,cAEpB4C,EAASr5C,EAAUy3C,mBAAmBx3C,EAAMwB,QAEtCm1C,GACN,KAAKJ,EAAY0B,EACfH,EAAG,GAAKsB,EACRtB,EAAG,GAAKsB,EACR,MACF,KAAK7C,EAAY2B,EACfJ,EAAG,GAAKsB,EACRtB,EAAG,GAAKsB,EACR,MACF,KAAK7C,EAAY4B,EACfL,EAAG,GAAKsB,EACRtB,EAAG,GAAKsB,EAGZ,OAAOpyD,EAAMqyD,eAAevB,EAAG,EAEjC/3C,EAAUu5C,kBAAoB,WAC5B,IAAI93C,EAAQ8/B,UAAU51C,OAAS,QAAsBG,IAAjBy1C,UAAU,GAAmBA,UAAU,GAAKthC,EAAMwB,MAClF+3C,EAAgBjY,UAAU51C,OAAS,QAAsBG,IAAjBy1C,UAAU,GAAmBA,UAAU,GAAK,EACxF,MAAMt6C,EAAQ+Y,EAAUu3C,kBACxB,IAAKtwD,EACH,OAAO,SAET,MAAMwyD,EAASxyD,EAAMyyD,oBACf,QACJ9C,GACE52C,EAAUi4C,oBACd,IAAIoB,EAAS53C,EAKb,OAJIm1C,IAAY32C,EAAMw2C,cAEpB4C,EAASr5C,EAAUy3C,mBAAmBh2C,IAEhCm1C,GACN,KAAKJ,EAAY0B,EACfuB,EAAO,GAAKJ,EAASG,EACrBC,EAAO,GAAKJ,EAASG,EACrB,MACF,KAAKhD,EAAY2B,EACfsB,EAAO,GAAKJ,EAASG,EACrBC,EAAO,GAAKJ,EAASG,EACrB,MACF,KAAKhD,EAAY4B,EACfqB,EAAO,GAAKJ,EAASG,EACrBC,EAAO,GAAKJ,EAASG,EAGzB,OAAOvyD,EAAMqyD,eAAeG,EAC9B,EACAz5C,EAAU25C,iCAAmC,CAAC/iB,EAAIC,KAAO,OAAiCD,EAAIC,EAAI72B,GAClGA,EAAU45C,gCAAkC,CAAChjB,EAAIC,KAAO,OAAgCD,EAAIC,EAAI72B,GAChGA,EAAUu3C,gBAAkB,IAAMv3C,EAAU65C,cAC9C,CA8BEC,CAAe95C,EAAWC,EAC5B,CAQA,IAAI85C,EAAmB,CACrBv5C,YALkB,EAAA4gC,EAAM5gC,YAAYT,EAAQ,kBAM5CA,YACGu2C,KACAC,KACA,oHCtSL,MAAM,cACJzR,GACE,EAAA1D,EAoJJ,MAAMvhC,EAAiB,CACrBm6C,OAAQ,KACRC,SAAU,KACVpN,OAAQ,IAAI,KAAeqN,cAK7B,SAASn6C,EAAOC,EAAWC,GACzB,IAAIC,EAAgBqhC,UAAU51C,OAAS,QAAsBG,IAAjBy1C,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzF7zC,OAAOyS,OAAOF,EAAOJ,EAAgBK,GAGrC,YAAiBF,EAAWC,EAAOC,GAGnCD,EAAMk6C,YAAc,CAAC,EACrB,EAAA/Y,EAAMvc,IAAI5kB,EAAMk6C,aAGhB,EAAA/Y,EAAMhiC,IAAIY,EAAWC,EAAO,CAAC,aAC7B,EAAAmhC,EAAMI,OAAOxhC,EAAWC,EAAO,CAAC,WAChC,EAAAmhC,EAAMM,SAAS1hC,EAAWC,EAAO,CAAC,UAAW,GApK/C,SAAuBD,EAAWC,GAEhCA,EAAMG,eAAe3N,KAAK,iBAC1BuN,EAAUhb,UAAY,IAAMgb,EAC5BA,EAAUo6C,UAAY,IAAMp6C,EAC5BA,EAAUq6C,YAAc,KACtB,GAAIp6C,EAAMq6C,YACR,OAAO,EAET,GAAIr6C,EAAMs6C,iBACR,OAAO,EAGJt6C,EAAMg6C,UAETj6C,EAAUvD,cAEZ,IAAI+9C,EAAWv6C,EAAMg6C,SAASQ,cAAgB,EAI9C,OADAD,EAAWA,KAAcv6C,EAAM+5C,QAAU/5C,EAAM+5C,OAAOK,eAC/CG,CAAQ,EAQjBx6C,EAAU06C,gCAAkC,KAAM,EAClD16C,EAAU26C,aAAe,iBACzB36C,EAAUvD,YAAc,KACC,OAAnBwD,EAAMg6C,WACRh6C,EAAMg6C,SAAWj6C,EAAU26C,gBAEtB16C,EAAMg6C,UAEfj6C,EAAU63C,UAAY,KACpB,GAAqB,OAAjB53C,EAAM+5C,OACR,OAAO/5C,EAAM4sC,OAIf,MAAM+K,EAAM33C,EAAM+5C,OAAOnC,YACzB,IAAKD,GAAsB,IAAfA,EAAIjsD,OACd,OAAOisD,EAIT,GAAIA,EAAI,GAAKA,EAAI,GAIf,OAHA33C,EAAM26C,aAAehD,EAAI7/B,SACzB9X,EAAM4sC,OAAS,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,GAClC5sC,EAAMk6C,YAAY3X,WACXoV,EAST,IAAK33C,EAAM26C,gBADClzD,EACoB,CAACkwD,EAAK33C,EAAM26C,cADxBlzD,EAAK,GAAGtD,KAAI,CAAC83B,EAAGjtB,IAAMvH,EAAKtD,KAAIy2D,GAAOA,EAAI5rD,QACHs1B,QAAO,CAAC5vB,EAAGC,IAAMD,GAAKC,EAAE,KAAOA,EAAE,KAAI,IAASoL,EAAUuzC,WAAatzC,EAAMk6C,YAAY5G,WAAY,CAC5JzO,EAAc,yBACd7kC,EAAM26C,aAAehD,EAAIxzD,KAAIkQ,GAAKA,IAClC0L,EAAU86C,gBACV,MAAMC,EAAO,IAAI/U,aAAa,IAC9B,eAAe+U,EAAM96C,EAAM4pC,QAC3B,qBAA+B+N,EAAKmD,EAAM96C,EAAM4sC,QAChD5sC,EAAMk6C,YAAY3X,UACpB,CATY96C,MAUZ,OAAOuY,EAAM4sC,MAAM,EAErB7sC,EAAUu5C,kBAAoB,CAAC93C,EAAOunC,KAEpC,MAAM4O,EAAM33C,EAAM+5C,OAAOT,kBAAkB93C,EAAOunC,GAElD,IAAK,aAAuB4O,GAC1B,OAAOA,EAET53C,EAAU86C,gBACV,MAAMC,EAAO,IAAI/U,aAAa,IAG9B,OAFA,eAAe+U,EAAM96C,EAAM4pC,QACT,qBAA+B+N,EAAKmD,EACtC,EAKlB/6C,EAAUg7C,aAAe,IAAMh7C,EAAU63C,YAAY,GAGrD73C,EAAUi7C,aAAe,IAAMj7C,EAAU63C,YAAY,GAGrD73C,EAAUk7C,aAAe,IAAMl7C,EAAU63C,YAAY,GAGrD73C,EAAUm7C,aAAe,IAAMn7C,EAAU63C,YAAY,GAGrD73C,EAAUo7C,aAAe,IAAMp7C,EAAU63C,YAAY,GAGrD73C,EAAUq7C,aAAe,IAAMr7C,EAAU63C,YAAY,GACrD73C,EAAUuzC,SAAW,KACnB,IAAI+H,EAAKr7C,EAAMs7C,MACf,GAAuB,OAAnBt7C,EAAMg6C,SAAmB,CAC3B,MAAMz0D,EAAOya,EAAMg6C,SAAS1G,WAC5B+H,EAAK91D,EAAO81D,EAAK91D,EAAO81D,CAC1B,CACA,OAAOA,CAAE,EAEXt7C,EAAUw7C,eAAiB,KACzB,IAAIF,EAAKr7C,EAAMs7C,MACf,GAAqB,OAAjBt7C,EAAM+5C,OAAiB,CACzB,IAAIx0D,EAAOya,EAAM+5C,OAAOzG,WACxB+H,EAAK91D,EAAO81D,EAAK91D,EAAO81D,EACQ,OAA5Br7C,EAAM+5C,OAAOyB,aAEfx7C,EAAM+5C,OAAO0B,oBAAoBC,SACjCn2D,EAAOya,EAAM+5C,OAAOyB,WAAWlI,WAC/B+H,EAAK91D,EAAO81D,EAAK91D,EAAO81D,EAE5B,CACA,GAAuB,OAAnBr7C,EAAMg6C,SAAmB,CAC3B,IAAIz0D,EAAOya,EAAMg6C,SAAS1G,WAC1B+H,EAAK91D,EAAO81D,EAAK91D,EAAO81D,EACwB,OAA5Cr7C,EAAMg6C,SAASt9C,2BACjBnX,EAAOya,EAAMg6C,SAASt9C,yBAAyB42C,WAC/C+H,EAAK91D,EAAO81D,EAAK91D,EAAO81D,EAE5B,CACA,OAAOA,CAAE,EAEXt7C,EAAU47C,qBAAuB,MAAM37C,EAAM+5C,QAAS/5C,EAAM+5C,OAAO4B,sBACrE,CA+BEC,CAAc77C,EAAWC,EAC3B,CAQA,IAAI67C,EAAkB,CACpBt7C,YALkB,EAAA4gC,EAAM5gC,YAAYT,EAAQ,iBAM5CA,oHC1LF,MAAM,cACJ+kC,GACE,EAAA1D,EAyFJ,MAAMvhC,EAAiB,CACrBm6C,OAAQ,KACRC,SAAU,KACVpN,OAAQ,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,IAK7B,SAAS9sC,EAAOC,EAAWC,GACzB,IAAIC,EAAgBqhC,UAAU51C,OAAS,QAAsBG,IAAjBy1C,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzF7zC,OAAOyS,OAAOF,EAAOJ,EAAgBK,GAGrC,YAAiBF,EAAWC,EAAOC,GAGnCD,EAAMk6C,YAAc,CAAC,EACrB,EAAA/Y,EAAMvc,IAAI5kB,EAAMk6C,aAGhB,EAAA/Y,EAAMhiC,IAAIY,EAAWC,EAAO,CAAC,aAC7B,EAAAmhC,EAAMI,OAAOxhC,EAAWC,EAAO,CAAC,WAChC,EAAAmhC,EAAMM,SAAS1hC,EAAWC,EAAO,CAAC,UAAW,GAzG/C,SAAmBD,EAAWC,GAE5BA,EAAMG,eAAe3N,KAAK,aAC1BuN,EAAUsH,WAAa,IAAMtH,EAC7BA,EAAU26C,aAAe,iBACzB36C,EAAUvD,YAAc,KACC,OAAnBwD,EAAMg6C,WACRh6C,EAAMg6C,SAAWj6C,EAAU26C,gBAEtB16C,EAAMg6C,UAEfj6C,EAAU63C,UAAY,KACpB,GAAqB,OAAjB53C,EAAM+5C,OACR,OAAO/5C,EAAM4sC,OAIf,MAAM+K,EAAM33C,EAAM+5C,OAAOnC,YACzB,IAAKD,GAAsB,IAAfA,EAAIjsD,OACd,OAAOisD,EAIT,GAAIA,EAAI,GAAKA,EAAI,GAIf,OAHA33C,EAAM26C,aAAehD,EAAI7/B,SACzB9X,EAAM4sC,OAAS,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,GAClC5sC,EAAMk6C,YAAY3X,WACXoV,EAST,IAAK33C,EAAM26C,gBADClzD,EACoB,CAACkwD,EAAK33C,EAAM26C,cADxBlzD,EAAK,GAAGtD,KAAI,CAAC83B,EAAGjtB,IAAMvH,EAAKtD,KAAIy2D,GAAOA,EAAI5rD,QACHs1B,QAAO,CAAC5vB,EAAGC,IAAMD,GAAKC,EAAE,KAAOA,EAAE,KAAI,IAASoL,EAAUuzC,WAAatzC,EAAMk6C,YAAY5G,WAAY,CAC5JzO,EAAc,yBACd7kC,EAAM26C,aAAehD,EAAIxzD,KAAIkQ,GAAKA,IAClC,MAAMynD,EAAO,GACb,gBAA0BnE,EAAKmE,GAC/B/7C,EAAU86C,gBACV,MAAMC,EAAO,IAAI/U,aAAa,IAC9B,eAAe+U,EAAM96C,EAAM4pC,QAC3BkS,EAAK3pD,SAAQoH,GAAM,mBAAmBA,EAAIA,EAAIuhD,KAG9C96C,EAAM4sC,OAAO,GAAK5sC,EAAM4sC,OAAO,GAAK5sC,EAAM4sC,OAAO,GAAKp8C,OAAOwxC,UAC7DhiC,EAAM4sC,OAAO,GAAK5sC,EAAM4sC,OAAO,GAAK5sC,EAAM4sC,OAAO,IAAMp8C,OAAOwxC,UAE9DhiC,EAAM4sC,OAAS5sC,EAAM4sC,OAAOzoD,KAAI,CAACu/C,EAAG94C,IAAMA,EAAI,GAAM,EAAIkxD,EAAKx3B,QAAO,CAAC5vB,EAAGC,IAAMD,EAAIC,EAAE/J,EAAI,GAAK+J,EAAE/J,EAAI,GAAK8J,GAAGgvC,GAAKoY,EAAKx3B,QAAO,CAAC5vB,EAAGC,IAAMD,EAAIC,GAAG/J,EAAI,GAAK,GAAK+J,GAAG/J,EAAI,GAAK,GAAK8J,GAAGgvC,KAC/K1jC,EAAMk6C,YAAY3X,UACpB,CAjBY96C,MAkBZ,OAAOuY,EAAM4sC,MAAM,EAErB7sC,EAAUuzC,SAAW,KACnB,IAAI+H,EAAKr7C,EAAMs7C,MACf,GAAuB,OAAnBt7C,EAAMg6C,SAAmB,CAC3B,MAAMz0D,EAAOya,EAAMg6C,SAAS1G,WAC5B+H,EAAK91D,EAAO81D,EAAK91D,EAAO81D,CAC1B,CACA,OAAOA,CAAE,EAEXt7C,EAAUw7C,eAAiB,KACzB,IAAIF,EAAKr7C,EAAMs7C,MACf,GAAqB,OAAjBt7C,EAAM+5C,OAAiB,CACzB,IAAIx0D,EAAOya,EAAM+5C,OAAOzG,WACxB+H,EAAK91D,EAAO81D,EAAK91D,EAAO81D,EACQ,OAA5Br7C,EAAM+5C,OAAOyB,aAEfx7C,EAAM+5C,OAAO0B,oBAAoBC,SACjCn2D,EAAOya,EAAM+5C,OAAOyB,WAAWlI,WAC/B+H,EAAK91D,EAAO81D,EAAK91D,EAAO81D,EAE5B,CACA,OAAOA,CAAE,CAEb,CA+BEU,CAAUh8C,EAAWC,EACvB,CAQA,IAAIg8C,EAAc,CAChBz7C,YALkB,EAAA4gC,EAAM5gC,YAAYT,EAAQ,aAM5CA,2BC3HF,IAGIm8C,EAAiB,4BAMjBC,EAAU,oBACVC,EAAS,6BAITC,EAAe,mDACfC,EAAgB,QAChBC,EAAe,MACfC,EAAa,mGASbC,EAAe,WAGfC,EAAe,8BAGfC,EAA8B,iBAAV,EAAA9M,GAAsB,EAAAA,GAAU,EAAAA,EAAOniD,SAAWA,QAAU,EAAAmiD,EAGhF+M,EAA0B,iBAARC,MAAoBA,MAAQA,KAAKnvD,SAAWA,QAAUmvD,KAGxE56C,EAAO06C,GAAcC,GAAYE,SAAS,cAATA,GAkCrC,IASMpqD,EATFqqD,EAAa5zD,MAAMwY,UACnBq7C,EAAYF,SAASn7C,UACrBs7C,EAAcvvD,OAAOiU,UAGrBu7C,EAAaj7C,EAAK,sBAGlBk7C,GACEzqD,EAAM,SAAS0qD,KAAKF,GAAcA,EAAW/6C,MAAQ+6C,EAAW/6C,KAAKk7C,UAAY,KACvE,iBAAmB3qD,EAAO,GAItC4qD,EAAeN,EAAUO,SAGzB37C,EAAiBq7C,EAAYr7C,eAO7B47C,EAAiBP,EAAYM,SAG7BE,EAAaC,OAAO,IACtBJ,EAAaz7C,KAAKD,GAAgBhX,QA7EjB,sBA6EuC,QACvDA,QAAQ,yDAA0D,SAAW,KAI5E8V,EAASuB,EAAKvB,OACd/c,EAASo5D,EAAWp5D,OAGpB8gB,EAAMk5C,EAAU17C,EAAM,OACtB27C,EAAeD,EAAUjwD,OAAQ,UAGjCmwD,EAAcn9C,EAASA,EAAOiB,eAAY7V,EAC1CgyD,EAAiBD,EAAcA,EAAYN,cAAWzxD,EAS1D,SAASiyD,EAAKC,GACZ,IAAI5vD,GAAS,EACTzC,EAASqyD,EAAUA,EAAQryD,OAAS,EAGxC,IADA9J,KAAKo8D,UACI7vD,EAAQzC,GAAQ,CACvB,IAAIuyD,EAAQF,EAAQ5vD,GACpBvM,KAAKud,IAAI8+C,EAAM,GAAIA,EAAM,GAC3B,CACF,CAyFA,SAASC,EAAUH,GACjB,IAAI5vD,GAAS,EACTzC,EAASqyD,EAAUA,EAAQryD,OAAS,EAGxC,IADA9J,KAAKo8D,UACI7vD,EAAQzC,GAAQ,CACvB,IAAIuyD,EAAQF,EAAQ5vD,GACpBvM,KAAKud,IAAI8+C,EAAM,GAAIA,EAAM,GAC3B,CACF,CAuGA,SAASE,EAASJ,GAChB,IAAI5vD,GAAS,EACTzC,EAASqyD,EAAUA,EAAQryD,OAAS,EAGxC,IADA9J,KAAKo8D,UACI7vD,EAAQzC,GAAQ,CACvB,IAAIuyD,EAAQF,EAAQ5vD,GACpBvM,KAAKud,IAAI8+C,EAAM,GAAIA,EAAM,GAC3B,CACF,CAsFA,SAASG,EAAaxqD,EAAOuN,GAE3B,IADA,IA+SUD,EAAOm9C,EA/Sb3yD,EAASkI,EAAMlI,OACZA,KACL,IA6SQwV,EA7SDtN,EAAMlI,GAAQ,OA6SN2yD,EA7SUl9C,IA8SAD,GAAUA,GAASm9C,GAAUA,EA7SpD,OAAO3yD,EAGX,OAAQ,CACV,CAUA,SAAS4yD,EAAQC,EAAQC,GAuDzB,IAAkBt9C,EAtDhBs9C,EA8FF,SAAet9C,EAAOq9C,GACpB,GAAIp1D,EAAQ+X,GACV,OAAO,EAET,IAAI3C,SAAc2C,EAClB,GAAY,UAAR3C,GAA4B,UAARA,GAA4B,WAARA,GAC/B,MAAT2C,GAAiBu9C,EAASv9C,GAC5B,OAAO,EAET,OAAOm7C,EAAcqC,KAAKx9C,KAAWk7C,EAAasC,KAAKx9C,IAC1C,MAAVq9C,GAAkBr9C,KAASzT,OAAO8wD,EACvC,CAzGSI,CAAMH,EAAMD,GAAU,CAACC,GAuDvBr1D,EADS+X,EAtD+Bs9C,GAuDvBt9C,EAAQ09C,EAAa19C,GAlD7C,IAHA,IAAI/S,EAAQ,EACRzC,EAAS8yD,EAAK9yD,OAED,MAAV6yD,GAAkBpwD,EAAQzC,GAC/B6yD,EAASA,EAAOM,EAAML,EAAKrwD,OAE7B,OAAQA,GAASA,GAASzC,EAAU6yD,OAAS1yD,CAC/C,CAUA,SAASizD,EAAa59C,GACpB,IAAK69C,EAAS79C,KA4GE89C,EA5GiB99C,EA6GxBg8C,GAAeA,KAAc8B,GA5GpC,OAAO,EA2GX,IAAkBA,EAzGZC,EAoTN,SAAoB/9C,GAGlB,IAAIg+C,EAAMH,EAAS79C,GAASq8C,EAAe37C,KAAKV,GAAS,GACzD,OAAOg+C,GAAOhD,GAAWgD,GAAO/C,CAClC,CAzTiBgD,CAAWj+C,IA3Z5B,SAAsBA,GAGpB,IAAI24B,GAAS,EACb,GAAa,MAAT34B,GAA0C,mBAAlBA,EAAMo8C,SAChC,IACEzjB,KAAY34B,EAAQ,GACtB,CAAE,MAAOnW,GAAI,CAEf,OAAO8uC,CACT,CAiZsCulB,CAAal+C,GAAUs8C,EAAaf,EACxE,OAAOwC,EAAQP,KAsJjB,SAAkBM,GAChB,GAAY,MAARA,EAAc,CAChB,IACE,OAAO3B,EAAaz7C,KAAKo9C,EAC3B,CAAE,MAAOj0D,GAAI,CACb,IACE,OAAQi0D,EAAO,EACjB,CAAE,MAAOj0D,GAAI,CACf,CACA,MAAO,EACT,CAhKsBs0D,CAASn+C,GAC/B,CAyCA,SAASo+C,EAAWn7D,EAAKgd,GACvB,IA+CiBD,EACb3C,EAhDA7R,EAAOvI,EAAIo7D,SACf,OAgDgB,WADZhhD,SADa2C,EA9CAC,KAgDmB,UAAR5C,GAA4B,UAARA,GAA4B,WAARA,EACrD,cAAV2C,EACU,OAAVA,GAjDDxU,EAAmB,iBAAPyU,EAAkB,SAAW,QACzCzU,EAAKvI,GACX,CAUA,SAASu5D,EAAUa,EAAQp9C,GACzB,IAAID,EAjeN,SAAkBq9C,EAAQp9C,GACxB,OAAiB,MAAVo9C,OAAiB1yD,EAAY0yD,EAAOp9C,EAC7C,CA+dciiC,CAASmb,EAAQp9C,GAC7B,OAAO29C,EAAa59C,GAASA,OAAQrV,CACvC,CAnUAiyD,EAAKp8C,UAAUs8C,MAnEf,WACEp8D,KAAK29D,SAAW5B,EAAeA,EAAa,MAAQ,CAAC,CACvD,EAkEAG,EAAKp8C,UAAkB,OAtDvB,SAAoBP,GAClB,OAAOvf,KAAKgiB,IAAIzC,WAAevf,KAAK29D,SAASp+C,EAC/C,EAqDA28C,EAAKp8C,UAAU/T,IA1Cf,SAAiBwT,GACf,IAAIzU,EAAO9K,KAAK29D,SAChB,GAAI5B,EAAc,CAChB,IAAI9jB,EAASntC,EAAKyU,GAClB,OAAO04B,IAAWoiB,OAAiBpwD,EAAYguC,CACjD,CACA,OAAOl4B,EAAeC,KAAKlV,EAAMyU,GAAOzU,EAAKyU,QAAOtV,CACtD,EAoCAiyD,EAAKp8C,UAAUkC,IAzBf,SAAiBzC,GACf,IAAIzU,EAAO9K,KAAK29D,SAChB,OAAO5B,OAA6B9xD,IAAda,EAAKyU,GAAqBQ,EAAeC,KAAKlV,EAAMyU,EAC5E,EAuBA28C,EAAKp8C,UAAUvC,IAXf,SAAiBgC,EAAKD,GAGpB,OAFWtf,KAAK29D,SACXp+C,GAAQw8C,QAA0B9xD,IAAVqV,EAAuB+6C,EAAiB/6C,EAC9Dtf,IACT,EAmHAs8D,EAAUx8C,UAAUs8C,MAjFpB,WACEp8D,KAAK29D,SAAW,EAClB,EAgFArB,EAAUx8C,UAAkB,OArE5B,SAAyBP,GACvB,IAAIzU,EAAO9K,KAAK29D,SACZpxD,EAAQiwD,EAAa1xD,EAAMyU,GAE/B,QAAIhT,EAAQ,KAIRA,GADYzB,EAAKhB,OAAS,EAE5BgB,EAAKkjB,MAELlsB,EAAOke,KAAKlV,EAAMyB,EAAO,IAEpB,EACT,EAwDA+vD,EAAUx8C,UAAU/T,IA7CpB,SAAsBwT,GACpB,IAAIzU,EAAO9K,KAAK29D,SACZpxD,EAAQiwD,EAAa1xD,EAAMyU,GAE/B,OAAOhT,EAAQ,OAAItC,EAAYa,EAAKyB,GAAO,EAC7C,EAyCA+vD,EAAUx8C,UAAUkC,IA9BpB,SAAsBzC,GACpB,OAAOi9C,EAAax8D,KAAK29D,SAAUp+C,IAAQ,CAC7C,EA6BA+8C,EAAUx8C,UAAUvC,IAjBpB,SAAsBgC,EAAKD,GACzB,IAAIxU,EAAO9K,KAAK29D,SACZpxD,EAAQiwD,EAAa1xD,EAAMyU,GAO/B,OALIhT,EAAQ,EACVzB,EAAK8F,KAAK,CAAC2O,EAAKD,IAEhBxU,EAAKyB,GAAO,GAAK+S,EAEZtf,IACT,EAiGAu8D,EAASz8C,UAAUs8C,MA/DnB,WACEp8D,KAAK29D,SAAW,CACd,KAAQ,IAAIzB,EACZ,IAAO,IAAKt5C,GAAO05C,GACnB,OAAU,IAAIJ,EAElB,EA0DAK,EAASz8C,UAAkB,OA/C3B,SAAwBP,GACtB,OAAOm+C,EAAW19D,KAAMuf,GAAa,OAAEA,EACzC,EA8CAg9C,EAASz8C,UAAU/T,IAnCnB,SAAqBwT,GACnB,OAAOm+C,EAAW19D,KAAMuf,GAAKxT,IAAIwT,EACnC,EAkCAg9C,EAASz8C,UAAUkC,IAvBnB,SAAqBzC,GACnB,OAAOm+C,EAAW19D,KAAMuf,GAAKyC,IAAIzC,EACnC,EAsBAg9C,EAASz8C,UAAUvC,IAVnB,SAAqBgC,EAAKD,GAExB,OADAo+C,EAAW19D,KAAMuf,GAAKhC,IAAIgC,EAAKD,GACxBtf,IACT,EA+KA,IAAIg9D,EAAeY,GAAQ,SAASC,GA4SpC,IAAkBv+C,EA3ShBu+C,EA4SgB,OADAv+C,EA3SEu+C,GA4SK,GArZzB,SAAsBv+C,GAEpB,GAAoB,iBAATA,EACT,OAAOA,EAET,GAAIu9C,EAASv9C,GACX,OAAO28C,EAAiBA,EAAej8C,KAAKV,GAAS,GAEvD,IAAI24B,EAAU34B,EAAQ,GACtB,MAAkB,KAAV24B,GAAkB,EAAI34B,IAAU,IAAa,KAAO24B,CAC9D,CA2Y8B6lB,CAAax+C,GA1SzC,IAAI24B,EAAS,GAOb,OANIyiB,EAAaoC,KAAKe,IACpB5lB,EAAOrnC,KAAK,IAEditD,EAAO90D,QAAQ4xD,GAAY,SAASvuD,EAAO2xD,EAAQC,EAAOH,GACxD5lB,EAAOrnC,KAAKotD,EAAQH,EAAO90D,QAAQ6xD,EAAc,MAASmD,GAAU3xD,EACtE,IACO6rC,CACT,IASA,SAASglB,EAAM39C,GACb,GAAoB,iBAATA,GAAqBu9C,EAASv9C,GACvC,OAAOA,EAET,IAAI24B,EAAU34B,EAAQ,GACtB,MAAkB,KAAV24B,GAAkB,EAAI34B,IAAU,IAAa,KAAO24B,CAC9D,CAiEA,SAAS2lB,EAAQR,EAAMa,GACrB,GAAmB,mBAARb,GAAuBa,GAA+B,mBAAZA,EACnD,MAAM,IAAIC,UAvqBQ,uBAyqBpB,IAAIC,EAAW,WACb,IAAIvkC,EAAO8lB,UACPngC,EAAM0+C,EAAWA,EAASG,MAAMp+D,KAAM45B,GAAQA,EAAK,GACnD8iB,EAAQyhB,EAASzhB,MAErB,GAAIA,EAAM16B,IAAIzC,GACZ,OAAOm9B,EAAM3wC,IAAIwT,GAEnB,IAAI04B,EAASmlB,EAAKgB,MAAMp+D,KAAM45B,GAE9B,OADAukC,EAASzhB,MAAQA,EAAMn/B,IAAIgC,EAAK04B,GACzBA,CACT,EAEA,OADAkmB,EAASzhB,MAAQ,IAAKkhB,EAAQS,OAAS9B,GAChC4B,CACT,CAGAP,EAAQS,MAAQ9B,EA6DhB,IAAIh1D,EAAUD,MAAMC,QAmDpB,SAAS41D,EAAS79C,GAChB,IAAI3C,SAAc2C,EAClB,QAASA,IAAkB,UAAR3C,GAA4B,YAARA,EACzC,CA+CA,SAASkgD,EAASv9C,GAChB,MAAuB,iBAATA,GAtBhB,SAAsBA,GACpB,QAASA,GAAyB,iBAATA,CAC3B,CAqBKg/C,CAAah/C,IAn1BF,mBAm1BYq8C,EAAe37C,KAAKV,EAChD,CAyDAi/C,EAAOC,QALP,SAAa7B,EAAQC,EAAM6B,GACzB,IAAIxmB,EAAmB,MAAV0kB,OAAiB1yD,EAAYyyD,EAAQC,EAAQC,GAC1D,YAAkB3yD,IAAXguC,EAAuBwmB,EAAexmB,CAC/C,6EC35BA,MAAMymB,EAAc7/C,OAAO,iBACrB8/C,EAAiB9/C,OAAO,oBACxB+/C,EAAe//C,OAAO,wBACtBggD,EAAYhgD,OAAO,qBACnBigD,EAAcjgD,OAAO,kBACrBs+C,EAAY9c,GAAwB,iBAARA,GAA4B,OAARA,GAAgC,mBAARA,EAgDxE0e,EAAmB,IAAIn8C,IAAI,CAC7B,CAAC,QA7CwB,CACzBo8C,UAAY3e,GAAQ8c,EAAS9c,IAAQA,EAAIqe,GACzC,SAAAO,CAAUj8B,GACN,MAAM,MAAEk8B,EAAK,MAAEC,GAAU,IAAIC,eAE7B,OADAC,EAAOr8B,EAAKk8B,GACL,CAACC,EAAO,CAACA,GACpB,EACAG,YAAYC,IACRA,EAAK91D,QACE+1D,EAAKD,MAqChB,CAAC,QA/BwB,CACzBP,UAAY1/C,GAAU69C,EAAS79C,IAAUw/C,KAAex/C,EACxD,SAAA2/C,EAAU,MAAE3/C,IACR,IAAImgD,EAcJ,OAZIA,EADAngD,aAAiB3X,MACJ,CACT+3D,SAAS,EACTpgD,MAAO,CACHqgD,QAASrgD,EAAMqgD,QACf1rD,KAAMqL,EAAMrL,KACZ2rD,MAAOtgD,EAAMsgD,QAKR,CAAEF,SAAS,EAAOpgD,SAE5B,CAACmgD,EAAY,GACxB,EACA,WAAAH,CAAYG,GACR,GAAIA,EAAWC,QACX,MAAM7zD,OAAOyS,OAAO,IAAI3W,MAAM83D,EAAWngD,MAAMqgD,SAAUF,EAAWngD,OAExE,MAAMmgD,EAAWngD,KACrB,MAoBJ,SAAS+/C,EAAOr8B,EAAK68B,EAAKC,WAAYC,EAAiB,CAAC,MACpDF,EAAGh7D,iBAAiB,WAAW,SAASkM,EAASivD,GAC7C,IAAKA,IAAOA,EAAGl1D,KACX,OAEJ,IAhBR,SAAyBi1D,EAAgB/5D,GACrC,IAAK,MAAMi6D,KAAiBF,EAAgB,CACxC,GAAI/5D,IAAWi6D,GAAmC,MAAlBA,EAC5B,OAAO,EAEX,GAAIA,aAAyBpE,QAAUoE,EAAcnD,KAAK92D,GACtD,OAAO,CAEf,CACA,OAAO,CACX,CAMak6D,CAAgBH,EAAgBC,EAAGh6D,QAEpC,YADAqL,QAAQC,KAAK,mBAAmB0uD,EAAGh6D,6BAGvC,MAAM,GAAExC,EAAE,KAAEmZ,EAAI,KAAEigD,GAAS/wD,OAAOyS,OAAO,CAAEs+C,KAAM,IAAMoD,EAAGl1D,MACpDq1D,GAAgBH,EAAGl1D,KAAKq1D,cAAgB,IAAI59D,IAAI69D,GACtD,IAAIC,EACJ,IACI,MAAMC,EAAS1D,EAAKh9C,MAAM,GAAI,GAAG8iB,QAAO,CAACM,EAAKu9B,IAASv9B,EAAIu9B,IAAOv9B,GAC5Dw9B,EAAW5D,EAAKl6B,QAAO,CAACM,EAAKu9B,IAASv9B,EAAIu9B,IAAOv9B,GACvD,OAAQrmB,GACJ,IAAK,MAEG0jD,EAAcG,EAElB,MACJ,IAAK,MAEGF,EAAO1D,EAAKh9C,OAAO,GAAG,IAAMwgD,EAAcJ,EAAGl1D,KAAKwU,OAClD+gD,GAAc,EAElB,MACJ,IAAK,QAEGA,EAAcG,EAASpC,MAAMkC,EAAQH,GAEzC,MACJ,IAAK,YAGGE,EAAcI,EADA,IAAID,KAAYL,IAGlC,MACJ,IAAK,WACD,CACI,MAAM,MAAEjB,EAAK,MAAEC,GAAU,IAAIC,eAC7BC,EAAOr8B,EAAKm8B,GACZkB,EAkKxB,SAAkBr9B,EAAK09B,GAEnB,OADAC,EAAcpjD,IAAIylB,EAAK09B,GAChB19B,CACX,CArKsC49B,CAAS1B,EAAO,CAACA,GACnC,CACA,MACJ,IAAK,UAEGmB,OAAcp2D,EAElB,MACJ,QACI,OAEZ,CACA,MAAOqV,GACH+gD,EAAc,CAAE/gD,QAAO,CAACw/C,GAAc,EAC1C,CACAx2D,QAAQC,QAAQ83D,GACXh6C,OAAO/G,IACD,CAAEA,QAAO,CAACw/C,GAAc,MAE9B12D,MAAMi4D,IACP,MAAOQ,EAAWC,GAAiBC,EAAYV,GAC/CR,EAAGmB,YAAYn1D,OAAOyS,OAAOzS,OAAOyS,OAAO,CAAC,EAAGuiD,GAAY,CAAEr9D,OAAOs9D,GACvD,YAATnkD,IAEAkjD,EAAG56D,oBAAoB,UAAW8L,GAClCkwD,EAAcpB,GACVhB,KAAa77B,GAAiC,mBAAnBA,EAAI67B,IAC/B77B,EAAI67B,KAEZ,IAECx4C,OAAOC,IAER,MAAOu6C,EAAWC,GAAiBC,EAAY,CAC3CzhD,MAAO,IAAI4+C,UAAU,+BACrB,CAACY,GAAc,IAEnBe,EAAGmB,YAAYn1D,OAAOyS,OAAOzS,OAAOyS,OAAO,CAAC,EAAGuiD,GAAY,CAAEr9D,OAAOs9D,EAAc,GAE1F,IACIjB,EAAGp2D,OACHo2D,EAAGp2D,OAEX,CAIA,SAASw3D,EAAcC,IAHvB,SAAuBA,GACnB,MAAqC,gBAA9BA,EAASviE,YAAYsV,IAChC,EAEQktD,CAAcD,IACdA,EAASE,OACjB,CACA,SAAS5B,EAAKK,EAAIwB,GACd,OAAOC,EAAYzB,EAAI,GAAIwB,EAC/B,CACA,SAASE,EAAqBC,GAC1B,GAAIA,EACA,MAAM,IAAI75D,MAAM,6CAExB,CACA,SAAS85D,EAAgB5B,GACrB,OAAO6B,EAAuB7B,EAAI,CAC9BljD,KAAM,YACPvU,MAAK,KACJ64D,EAAcpB,EAAG,GAEzB,CACA,MAAM8B,EAAe,IAAIrgD,QACnBsgD,EAAkB,yBAA0B9B,YAC9C,IAAI+B,sBAAsBhC,IACtB,MAAMiC,GAAYH,EAAa51D,IAAI8zD,IAAO,GAAK,EAC/C8B,EAAapkD,IAAIsiD,EAAIiC,GACJ,IAAbA,GACAL,EAAgB5B,EACpB,IAcR,SAASyB,EAAYzB,EAAIjD,EAAO,GAAIyE,EAAS,WAAc,GACvD,IAAIU,GAAkB,EACtB,MAAMtB,EAAQ,IAAIuB,MAAMX,EAAQ,CAC5B,GAAAt1D,CAAIk2D,EAAS1B,GAET,GADAgB,EAAqBQ,GACjBxB,IAAS3B,EACT,MAAO,MAXvB,SAAyB6B,GACjBmB,GACAA,EAAgBM,WAAWzB,EAEnC,CAQoB0B,CAAgB1B,GAChBgB,EAAgB5B,GAChBkC,GAAkB,CAAI,EAG9B,GAAa,SAATxB,EAAiB,CACjB,GAAoB,IAAhB3D,EAAK9yD,OACL,MAAO,CAAE1B,KAAM,IAAMq4D,GAEzB,MAAMxa,EAAIyb,EAAuB7B,EAAI,CACjCljD,KAAM,MACNigD,KAAMA,EAAKr6D,KAAKimC,GAAMA,EAAEkzB,eACzBtzD,KAAKg4D,GACR,OAAOna,EAAE79C,KAAKo2B,KAAKynB,EACvB,CACA,OAAOqb,EAAYzB,EAAI,IAAIjD,EAAM2D,GACrC,EACA,GAAAhjD,CAAI0kD,EAAS1B,EAAMC,GACfe,EAAqBQ,GAGrB,MAAOziD,EAAOwhD,GAAiBC,EAAYP,GAC3C,OAAOkB,EAAuB7B,EAAI,CAC9BljD,KAAM,MACNigD,KAAM,IAAIA,EAAM2D,GAAMh+D,KAAKimC,GAAMA,EAAEkzB,aACnCp8C,SACDwhD,GAAe14D,KAAKg4D,EAC3B,EACA,KAAAhC,CAAM6D,EAASG,EAAUC,GACrBd,EAAqBQ,GACrB,MAAMtgD,EAAOm7C,EAAKA,EAAK9yD,OAAS,GAChC,GAAI2X,IAASk9C,EACT,OAAO+C,EAAuB7B,EAAI,CAC9BljD,KAAM,aACPvU,KAAKg4D,GAGZ,GAAa,SAAT3+C,EACA,OAAO6/C,EAAYzB,EAAIjD,EAAKh9C,MAAM,GAAI,IAE1C,MAAOugD,EAAcW,GAAiBwB,EAAiBD,GACvD,OAAOX,EAAuB7B,EAAI,CAC9BljD,KAAM,QACNigD,KAAMA,EAAKr6D,KAAKimC,GAAMA,EAAEkzB,aACxByE,gBACDW,GAAe14D,KAAKg4D,EAC3B,EACA,SAAAmC,CAAUN,EAASI,GACfd,EAAqBQ,GACrB,MAAO5B,EAAcW,GAAiBwB,EAAiBD,GACvD,OAAOX,EAAuB7B,EAAI,CAC9BljD,KAAM,YACNigD,KAAMA,EAAKr6D,KAAKimC,GAAMA,EAAEkzB,aACxByE,gBACDW,GAAe14D,KAAKg4D,EAC3B,IAGJ,OA7EJ,SAAuBK,EAAOZ,GAC1B,MAAMiC,GAAYH,EAAa51D,IAAI8zD,IAAO,GAAK,EAC/C8B,EAAapkD,IAAIsiD,EAAIiC,GACjBF,GACAA,EAAgBY,SAAS/B,EAAOZ,EAAIY,EAE5C,CAsEIgC,CAAchC,EAAOZ,GACdY,CACX,CAIA,SAAS6B,EAAiBnC,GACtB,MAAMuC,EAAYvC,EAAa59D,IAAIw+D,GACnC,MAAO,CAAC2B,EAAUngE,KAAK4rD,GAAMA,EAAE,MALnBwU,EAK+BD,EAAUngE,KAAK4rD,GAAMA,EAAE,KAJ3D7mD,MAAMwY,UAAUoW,OAAOkoC,MAAM,GAAIuE,KAD5C,IAAgBA,CAMhB,CACA,MAAMhC,EAAgB,IAAIr/C,QAK1B,SAASm/C,EAAMz9B,GACX,OAAOn3B,OAAOyS,OAAO0kB,EAAK,CAAE,CAAC07B,IAAc,GAC/C,CAQA,SAASqC,EAAYzhD,GACjB,IAAK,MAAOrL,EAAM2uD,KAAY7D,EAC1B,GAAI6D,EAAQ5D,UAAU1/C,GAAQ,CAC1B,MAAOujD,EAAiB/B,GAAiB8B,EAAQ3D,UAAU3/C,GAC3D,MAAO,CACH,CACI3C,KAAM,UACN1I,OACAqL,MAAOujD,GAEX/B,EAER,CAEJ,MAAO,CACH,CACInkD,KAAM,MACN2C,SAEJqhD,EAAc50D,IAAIuT,IAAU,GAEpC,CACA,SAAS8gD,EAAc9gD,GACnB,OAAQA,EAAM3C,MACV,IAAK,UACD,OAAOoiD,EAAiBhzD,IAAIuT,EAAMrL,MAAMqrD,YAAYhgD,EAAMA,OAC9D,IAAK,MACD,OAAOA,EAAMA,MAEzB,CACA,SAASoiD,EAAuB7B,EAAIiD,EAAKpC,GACrC,OAAO,IAAIp4D,SAASC,IAChB,MAAM/E,EAeH,IAAI8D,MAAM,GACZ2xB,KAAK,GACL12B,KAAI,IAAM3B,KAAK6O,MAAM7O,KAAKmiE,SAAWn0D,OAAOo0D,kBAAkBtH,SAAS,MACvEuH,KAAK,KAjBNpD,EAAGh7D,iBAAiB,WAAW,SAASq+D,EAAElD,GACjCA,EAAGl1D,MAASk1D,EAAGl1D,KAAKtH,IAAMw8D,EAAGl1D,KAAKtH,KAAOA,IAG9Cq8D,EAAG56D,oBAAoB,UAAWi+D,GAClC36D,EAAQy3D,EAAGl1D,MACf,IACI+0D,EAAGp2D,OACHo2D,EAAGp2D,QAEPo2D,EAAGmB,YAAYn1D,OAAOyS,OAAO,CAAE9a,MAAMs/D,GAAMpC,EAAU,GAE7D,0EC7Ue,SAASyC,EAASC,GAC/B,IAAIC,EAAUC,EAAUj6D,EAiBxB,SAAS6I,EAAKY,EAAGL,EAAG8wD,EAAK,EAAGC,EAAK1wD,EAAEhJ,QACjC,GAAIy5D,EAAKC,EAAI,CACX,GAAuB,IAAnBH,EAAS5wD,EAAGA,GAAU,OAAO+wD,EACjC,EAAG,CACD,MAAMpxD,EAAOmxD,EAAKC,IAAQ,EACtBF,EAASxwD,EAAEV,GAAMK,GAAK,EAAG8wD,EAAKnxD,EAAM,EACnCoxD,EAAKpxD,CACZ,OAASmxD,EAAKC,EAChB,CACA,OAAOD,CACT,CAmBA,OAvCiB,IAAbH,EAAEt5D,QACJu5D,EAAW,IACXC,EAAW,CAACxhB,EAAGrvC,KAAM,OAAU2wD,EAAEthB,GAAIrvC,GACrCpJ,EAAQ,CAACy4C,EAAGrvC,IAAM2wD,EAAEthB,GAAKrvC,IAEzB4wD,EAAWD,IAAM,KAAaA,IAAM,IAAaA,EAAIK,EACrDH,EAAWF,EACX/5D,EAAQ+5D,GAgCH,CAAClxD,OAAMwxD,OALd,SAAgB5wD,EAAGL,EAAG8wD,EAAK,EAAGC,EAAK1wD,EAAEhJ,QACnC,MAAMd,EAAIkJ,EAAKY,EAAGL,EAAG8wD,EAAIC,EAAK,GAC9B,OAAOx6D,EAAIu6D,GAAMl6D,EAAMyJ,EAAE9J,EAAI,GAAIyJ,IAAMpJ,EAAMyJ,EAAE9J,GAAIyJ,GAAKzJ,EAAI,EAAIA,CAClE,EAEsBmJ,MAjBtB,SAAeW,EAAGL,EAAG8wD,EAAK,EAAGC,EAAK1wD,EAAEhJ,QAClC,GAAIy5D,EAAKC,EAAI,CACX,GAAuB,IAAnBH,EAAS5wD,EAAGA,GAAU,OAAO+wD,EACjC,EAAG,CACD,MAAMpxD,EAAOmxD,EAAKC,IAAQ,EACtBF,EAASxwD,EAAEV,GAAMK,IAAM,EAAG8wD,EAAKnxD,EAAM,EACpCoxD,EAAKpxD,CACZ,OAASmxD,EAAKC,EAChB,CACA,OAAOD,CACT,EAQF,CAEA,SAASE,IACP,OAAO,CACT","sources":["webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/VideoViewport.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/addImageSlicesToViewports.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/addVolumesToViewports.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/colors/colormap.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/drawImageSync.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/calculateTransform.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/canvasToPixel.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/correctShift.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/getDefaultViewport.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/getImageFitScale.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/getImageSize.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/getTransform.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/pixelToCanvas.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/resetCamera.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/resize.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/fitToWindow.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/createVolumeActor.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/setDefaultVolumeVOI.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/vtkClasses/vtkSharedVolumeMapper.js","webpack:///../../../node_modules/@cornerstonejs/core/src/Settings.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/cache/cache.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/constants/epsilon.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/constants/rendering.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/RequestType.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/ViewportStatus.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/BlendModes.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/GeometryType.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/DynamicOperatorType.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/CalibrationTypes.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/getEnabledElement.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/loaders/imageLoader.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/loaders/volumeLoader.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/requestPool/imageLoadPoolManager.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/requestPool/requestPoolManager.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/cacheUtils.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/colormap.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/createLinearRGBTransferFunction.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/getImageSliceDataForVolumeViewport.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/transferFunctionUtils.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/transformWorldToIndex.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/triggerEvent.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/webWorkerManager/webWorkerManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/SVGCursorDescriptor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/getSvgDrawingHelper.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/draw.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/ToolModes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/ToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/createToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/destroy.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/destroyToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/getAllToolGroups.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/getToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/getToolGroupsWithToolName.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/BidirectionalTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/PlanarFreehandROITool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/displayTools/SegmentationDisplayTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/RectangleROIThresholdTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/RectangleROIStartEndThresholdTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/index.ts","webpack:///../../../node_modules/@kitware/vtk.js/Common/DataModel/PiecewiseFunction.js","webpack:///../../../node_modules/@kitware/vtk.js/Rendering/Core/Camera.js","webpack:///../../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction.js","webpack:///../../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps.js","webpack:///../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageMapper.js","webpack:///../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageSlice.js","webpack:///../../../node_modules/@kitware/vtk.js/Rendering/Core/Volume.js","webpack:///../../../node_modules/lodash.get/index.js","webpack:///../../../node_modules/comlink/dist/esm/comlink.mjs","webpack:///../../../node_modules/d3-array/src/bisector.js"],"sourcesContent":["import { vec3 } from 'gl-matrix';\r\nimport {\r\n  Events as EVENTS,\r\n  VideoEnums as VideoViewportEnum,\r\n  MetadataModules,\r\n} from '../enums';\r\nimport type {\r\n  IVideoViewport,\r\n  VideoViewportProperties,\r\n  Point3,\r\n  Point2,\r\n  ICamera,\r\n  InternalVideoCamera,\r\n  VideoViewportInput,\r\n  VOIRange,\r\n  ICanvasActor,\r\n  IImage,\r\n  ViewReferenceSpecifier,\r\n  ViewReference,\r\n  ReferenceCompatibleOptions,\r\n  ImageSetOptions,\r\n} from '../types';\r\nimport * as metaData from '../metaData';\r\nimport { Transform } from './helpers/cpuFallback/rendering/transform';\r\nimport { triggerEvent } from '../utilities';\r\nimport Viewport from './Viewport';\r\nimport { getOrCreateCanvas } from './helpers';\r\nimport CanvasActor from './CanvasActor';\r\nimport cache from '../cache';\r\n\r\n/**\r\n * A data type for the scalar data for video data.\r\n */\r\nexport type CanvasScalarData = Uint8ClampedArray & {\r\n  frameNumber?: number;\r\n  getRange?: () => [number, number];\r\n};\r\n\r\n/**\r\n * An object representing a single stack viewport, which is a camera\r\n * looking into an internal scene, and an associated target output `canvas`.\r\n */\r\nclass VideoViewport extends Viewport implements IVideoViewport {\r\n  public static frameRangeExtractor = /(\\/frames\\/|[&?]frameNumber=)([^/&?]*)/i;\r\n\r\n  public modality;\r\n  // Viewport Data\r\n  protected imageId: string;\r\n  readonly uid;\r\n  readonly renderingEngineId: string;\r\n  readonly canvasContext: CanvasRenderingContext2D;\r\n  private videoElement?: HTMLVideoElement;\r\n  private videoWidth = 0;\r\n  private videoHeight = 0;\r\n\r\n  private loop = true;\r\n  private mute = true;\r\n  private isPlaying = false;\r\n  private scrollSpeed = 1;\r\n  private playbackRate = 1;\r\n  private scalarData: CanvasScalarData;\r\n\r\n  /**\r\n   * This is used to pause initially so that we get at least one render to allow\r\n   * navigating frames.  Otherwise the viewport is blank initially until the user\r\n   * hits play manually.\r\n   */\r\n  private initialRender: () => void;\r\n\r\n  /**\r\n   * The range is the set of frames to play\r\n   */\r\n  private frameRange: [number, number] = [0, 0];\r\n\r\n  protected metadata;\r\n\r\n  /**\r\n   * The fps, frames per second is used to calculate time/frame mapping values.\r\n   * It is provided by the CINE Module in the metadata, defaulting to 30 if not\r\n   * provided.\r\n   */\r\n  private fps = 30;\r\n\r\n  /** The number of frames in the video */\r\n  private numberOfFrames: number;\r\n\r\n  private videoCamera: InternalVideoCamera = {\r\n    panWorld: [0, 0],\r\n    parallelScale: 1,\r\n  };\r\n\r\n  /**\r\n   * feFilter is an inline string value for the CSS filter on the video\r\n   * CSS filters can reference SVG filters, so for the typical use case here\r\n   * the CSS filter is actually an link link to a SVG filter.\r\n   */\r\n  private feFilter: string;\r\n\r\n  /**\r\n   * An average white point value, used to color balance the image so that\r\n   * the given white is mapped to [255,255,255] via multiplication per channel.\r\n   */\r\n  private averageWhite: [number, number, number];\r\n\r\n  /**\r\n   * The VOI Range is used to apply contrast/brightness adjustments to the image.\r\n   */\r\n  private voiRange: VOIRange = {\r\n    lower: 0,\r\n    upper: 255,\r\n  };\r\n\r\n  constructor(props: VideoViewportInput) {\r\n    super({\r\n      ...props,\r\n      canvas: props.canvas || getOrCreateCanvas(props.element),\r\n    });\r\n    this.canvasContext = this.canvas.getContext('2d');\r\n    this.renderingEngineId = props.renderingEngineId;\r\n\r\n    this.element.setAttribute('data-viewport-uid', this.id);\r\n    this.element.setAttribute(\r\n      'data-rendering-engine-uid',\r\n      this.renderingEngineId\r\n    );\r\n\r\n    this.videoElement = document.createElement('video');\r\n    this.videoElement.muted = this.mute;\r\n    this.videoElement.loop = this.loop;\r\n    this.videoElement.autoplay = true;\r\n    this.videoElement.crossOrigin = 'anonymous';\r\n\r\n    this.addEventListeners();\r\n    this.resize();\r\n  }\r\n\r\n  public static get useCustomRenderingPipeline() {\r\n    return true;\r\n  }\r\n\r\n  private addEventListeners() {\r\n    this.canvas.addEventListener(\r\n      EVENTS.ELEMENT_DISABLED,\r\n      this.elementDisabledHandler\r\n    );\r\n  }\r\n\r\n  private removeEventListeners() {\r\n    this.canvas.removeEventListener(\r\n      EVENTS.ELEMENT_DISABLED,\r\n      this.elementDisabledHandler\r\n    );\r\n  }\r\n\r\n  private elementDisabledHandler() {\r\n    this.removeEventListeners();\r\n    this.videoElement.remove();\r\n  }\r\n\r\n  public getImageDataMetadata(image: IImage | string) {\r\n    const imageId = typeof image === 'string' ? image : image.imageId;\r\n    const imagePlaneModule = metaData.get(MetadataModules.IMAGE_PLANE, imageId);\r\n\r\n    let rowCosines = <Point3>imagePlaneModule.rowCosines;\r\n    let columnCosines = <Point3>imagePlaneModule.columnCosines;\r\n\r\n    // if null or undefined\r\n    if (rowCosines == null || columnCosines == null) {\r\n      rowCosines = <Point3>[1, 0, 0];\r\n      columnCosines = <Point3>[0, 1, 0];\r\n    }\r\n\r\n    const rowCosineVec = vec3.fromValues(\r\n      rowCosines[0],\r\n      rowCosines[1],\r\n      rowCosines[2]\r\n    );\r\n    const colCosineVec = vec3.fromValues(\r\n      columnCosines[0],\r\n      columnCosines[1],\r\n      columnCosines[2]\r\n    );\r\n\r\n    const { rows, columns } = imagePlaneModule;\r\n    const scanAxisNormal = vec3.create();\r\n    vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);\r\n\r\n    let origin = imagePlaneModule.imagePositionPatient;\r\n    // if null or undefined\r\n    if (origin == null) {\r\n      origin = [0, 0, 0];\r\n    }\r\n\r\n    const xSpacing = imagePlaneModule.columnPixelSpacing || 1;\r\n    const ySpacing = imagePlaneModule.rowPixelSpacing || 1;\r\n    const xVoxels = imagePlaneModule.columns;\r\n    const yVoxels = imagePlaneModule.rows;\r\n\r\n    const zSpacing = 1;\r\n    const zVoxels = 1;\r\n\r\n    this.hasPixelSpacing = !!imagePlaneModule.columnPixelSpacing;\r\n    return {\r\n      bitsAllocated: 8,\r\n      numComps: 3,\r\n      origin,\r\n      rows,\r\n      columns,\r\n      direction: [...rowCosineVec, ...colCosineVec, ...scanAxisNormal],\r\n      dimensions: [xVoxels, yVoxels, zVoxels],\r\n      spacing: [xSpacing, ySpacing, zSpacing],\r\n      hasPixelSpacing: this.hasPixelSpacing,\r\n      numVoxels: xVoxels * yVoxels * zVoxels,\r\n      imagePlaneModule,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * This is a wrapper for setVideo to allow generic behaviour\r\n   *\r\n   * @param _groupId - the id for the overall set of image ids.  Unused for video viewport.\r\n   * @param imageIds - a singleton list containing the imageId of a video.\r\n   */\r\n  public setDataIds(imageIds: string[], options?: ImageSetOptions) {\r\n    this.setVideo(\r\n      imageIds[0],\r\n      (options?.viewReference?.sliceIndex as number) || 1\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Sets the video image id to show and hte frame number.\r\n   * Requirements are to have the imageUrlModule in the metadata\r\n   * with the rendered endpoint being the raw video in video/mp4 format.\r\n   */\r\n  public setVideo(imageId: string, frameNumber?: number): Promise<unknown> {\r\n    this.imageId = Array.isArray(imageId) ? imageId[0] : imageId;\r\n    const imageUrlModule = metaData.get(MetadataModules.IMAGE_URL, imageId);\r\n    if (!imageUrlModule?.rendered) {\r\n      throw new Error(\r\n        `Video Image ID ${imageId} does not have a rendered video view`\r\n      );\r\n    }\r\n    const { rendered } = imageUrlModule;\r\n    const generalSeries = metaData.get(MetadataModules.GENERAL_SERIES, imageId);\r\n    this.modality = generalSeries?.Modality;\r\n    this.metadata = this.getImageDataMetadata(imageId);\r\n    let { cineRate, numberOfFrames } = metaData.get(\r\n      MetadataModules.CINE,\r\n      imageId\r\n    );\r\n    this.numberOfFrames = numberOfFrames;\r\n\r\n    return this.setVideoURL(rendered).then(() => {\r\n      if (!numberOfFrames || numberOfFrames === 1) {\r\n        numberOfFrames = Math.round(\r\n          this.videoElement.duration * (cineRate || 30)\r\n        );\r\n      }\r\n      if (!cineRate) {\r\n        cineRate = Math.round(numberOfFrames / this.videoElement.duration);\r\n      }\r\n      this.fps = cineRate;\r\n      this.numberOfFrames = numberOfFrames;\r\n      // 1 based range setting\r\n      this.setFrameRange([1, numberOfFrames]);\r\n      // The initial render allows us to set the frame position - rendering needs\r\n      // to start already playing\r\n      this.initialRender = () => {\r\n        this.initialRender = null;\r\n        this.pause();\r\n        this.setFrameNumber(frameNumber || 1);\r\n      };\r\n\r\n      // This is ugly, but without it, the video often fails to render initially\r\n      // so having a play, followed by a pause fixes things.\r\n      // 25 ms is a tested value that seems to work to prevent exceptions\r\n      return new Promise((resolve) => {\r\n        window.setTimeout(() => {\r\n          this.setFrameNumber(frameNumber || 1);\r\n          resolve(this);\r\n        }, 25);\r\n      });\r\n    });\r\n  }\r\n\r\n  public async setVideoURL(videoURL: string) {\r\n    return new Promise((resolve) => {\r\n      this.videoElement.src = videoURL;\r\n      this.videoElement.preload = 'auto';\r\n\r\n      const loadedMetadataEventHandler = () => {\r\n        this.videoWidth = this.videoElement.videoWidth;\r\n        this.videoHeight = this.videoElement.videoHeight;\r\n        this.videoElement.removeEventListener(\r\n          'loadedmetadata',\r\n          loadedMetadataEventHandler\r\n        );\r\n\r\n        this.refreshRenderValues();\r\n\r\n        resolve(true);\r\n      };\r\n\r\n      this.videoElement.addEventListener(\r\n        'loadedmetadata',\r\n        loadedMetadataEventHandler\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Gets all the image ids associated with this video element.  This will\r\n   * have # of frames elements.\r\n   */\r\n  public getImageIds(): string[] {\r\n    const imageIds = new Array<string>(this.numberOfFrames);\r\n    const baseImageId = this.imageId.replace(/[0-9]+$/, '');\r\n    for (let i = 0; i < this.numberOfFrames; i++) {\r\n      imageIds[i] = `${baseImageId}${i + 1}`;\r\n    }\r\n    return imageIds;\r\n  }\r\n\r\n  public togglePlayPause(): boolean {\r\n    if (this.isPlaying) {\r\n      this.pause();\r\n      return false;\r\n    } else {\r\n      this.play();\r\n      return true;\r\n    }\r\n  }\r\n\r\n  public async play() {\r\n    try {\r\n      if (!this.isPlaying) {\r\n        // Play returns a promise that is true when playing completes.\r\n        await this.videoElement.play();\r\n        this.isPlaying = true;\r\n        this.renderWhilstPlaying();\r\n      }\r\n    } catch (e) {\r\n      // No-op, an exception sometimes gets thrown on the initial play, not\r\n      // quite sure why.  Catching it prevents displaying an error\r\n    }\r\n  }\r\n\r\n  public async pause() {\r\n    try {\r\n      await this.videoElement.pause();\r\n      this.isPlaying = false;\r\n    } catch (e) {\r\n      // No-op - sometimes this happens on startup\r\n    }\r\n  }\r\n\r\n  public async scroll(delta = 1) {\r\n    await this.pause();\r\n\r\n    const videoElement = this.videoElement;\r\n    const renderFrame = this.renderFrame;\r\n\r\n    const currentTime = videoElement.currentTime;\r\n    const newTime = currentTime + (delta * this.scrollSpeed) / this.fps;\r\n\r\n    videoElement.currentTime = newTime;\r\n\r\n    // Need to wait for seek update\r\n    const seekEventListener = (evt) => {\r\n      renderFrame();\r\n\r\n      videoElement.removeEventListener('seeked', seekEventListener);\r\n    };\r\n\r\n    videoElement.addEventListener('seeked', seekEventListener);\r\n  }\r\n\r\n  public async start() {\r\n    const videoElement = this.videoElement;\r\n    const renderFrame = this.renderFrame;\r\n\r\n    videoElement.currentTime = 0;\r\n\r\n    if (videoElement.paused) {\r\n      // Need to wait for seek update\r\n      const seekEventListener = (evt) => {\r\n        renderFrame();\r\n\r\n        videoElement.removeEventListener('seeked', seekEventListener);\r\n      };\r\n\r\n      videoElement.addEventListener('seeked', seekEventListener);\r\n    }\r\n  }\r\n\r\n  public async end() {\r\n    const videoElement = this.videoElement;\r\n    const renderFrame = this.renderFrame;\r\n\r\n    videoElement.currentTime = videoElement.duration;\r\n\r\n    if (videoElement.paused) {\r\n      // Need to wait for seek update\r\n      const seekEventListener = (evt) => {\r\n        renderFrame();\r\n\r\n        videoElement.removeEventListener('seeked', seekEventListener);\r\n      };\r\n\r\n      videoElement.addEventListener('seeked', seekEventListener);\r\n    }\r\n  }\r\n\r\n  public async setTime(timeInSeconds: number) {\r\n    const videoElement = this.videoElement;\r\n    const renderFrame = this.renderFrame;\r\n\r\n    videoElement.currentTime = timeInSeconds;\r\n\r\n    if (videoElement.paused) {\r\n      // Need to wait for seek update\r\n      const seekEventListener = (evt) => {\r\n        renderFrame();\r\n\r\n        videoElement.removeEventListener('seeked', seekEventListener);\r\n      };\r\n\r\n      videoElement.addEventListener('seeked', seekEventListener);\r\n    }\r\n  }\r\n\r\n  // Sets the frame number - note according to DICOM, this is 1 based\r\n  public async setFrameNumber(frame: number) {\r\n    this.setTime((frame - 1) / this.fps);\r\n  }\r\n\r\n  /**\r\n   * Sets the playback frame range.  The video will play over the given set\r\n   * of frames (assuming it is playing).\r\n   * @param frameRange - the minimum to maximum (inclusive) frames to play over\r\n   * @returns\r\n   */\r\n  public setFrameRange(frameRange: number[]) {\r\n    if (!frameRange) {\r\n      this.frameRange = [1, this.numberOfFrames];\r\n      return;\r\n    }\r\n    if (frameRange.length !== 2 || frameRange[0] === frameRange[1]) {\r\n      return;\r\n    }\r\n    this.frameRange = [frameRange[0], frameRange[1]];\r\n  }\r\n\r\n  public getFrameRange(): [number, number] {\r\n    return this.frameRange;\r\n  }\r\n\r\n  public setProperties(props: VideoViewportProperties) {\r\n    if (props.loop !== undefined) {\r\n      this.videoElement.loop = props.loop;\r\n    }\r\n\r\n    if (props.muted !== undefined) {\r\n      this.videoElement.muted = props.muted;\r\n    }\r\n\r\n    if (props.playbackRate !== undefined) {\r\n      this.setPlaybackRate(props.playbackRate);\r\n    }\r\n\r\n    if (props.scrollSpeed !== undefined) {\r\n      this.setScrollSpeed(props.scrollSpeed);\r\n    }\r\n\r\n    if (props.voiRange) {\r\n      this.setVOI(props.voiRange);\r\n    }\r\n  }\r\n\r\n  public setPlaybackRate(rate = 1) {\r\n    this.playbackRate = rate;\r\n    // Minimum playback speed in chrome is 0.0625 compared to normal\r\n    if (rate < 0.0625) {\r\n      this.pause();\r\n      return;\r\n    }\r\n    if (!this.videoElement) {\r\n      return;\r\n    }\r\n    this.videoElement.playbackRate = rate;\r\n    this.play();\r\n  }\r\n\r\n  public setScrollSpeed(\r\n    scrollSpeed = 1,\r\n    unit = VideoViewportEnum.SpeedUnit.FRAME\r\n  ) {\r\n    this.scrollSpeed =\r\n      unit === VideoViewportEnum.SpeedUnit.SECOND\r\n        ? scrollSpeed * this.fps\r\n        : scrollSpeed;\r\n  }\r\n\r\n  public getProperties = (): VideoViewportProperties => {\r\n    return {\r\n      loop: this.videoElement.loop,\r\n      muted: this.videoElement.muted,\r\n      playbackRate: this.playbackRate,\r\n      scrollSpeed: this.scrollSpeed,\r\n      voiRange: { ...this.voiRange },\r\n    };\r\n  };\r\n\r\n  public resetProperties() {\r\n    this.setProperties({\r\n      loop: false,\r\n      muted: true,\r\n    });\r\n  }\r\n\r\n  protected getScalarData(): CanvasScalarData {\r\n    if (this.scalarData?.frameNumber === this.getFrameNumber()) {\r\n      return this.scalarData;\r\n    }\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = this.videoWidth;\r\n    canvas.height = this.videoHeight;\r\n    const context = canvas.getContext('2d');\r\n    context.drawImage(this.videoElement, 0, 0);\r\n    const canvasData = context.getImageData(\r\n      0,\r\n      0,\r\n      this.videoWidth,\r\n      this.videoHeight\r\n    );\r\n    const scalarData = canvasData.data as CanvasScalarData;\r\n    scalarData.getRange = () => [0, 255];\r\n    scalarData.frameNumber = this.getFrameNumber();\r\n    this.scalarData = scalarData;\r\n    return scalarData;\r\n  }\r\n\r\n  public getImageData() {\r\n    const { metadata } = this;\r\n\r\n    const spacing = metadata.spacing;\r\n\r\n    const imageData = {\r\n      dimensions: metadata.dimensions,\r\n      spacing,\r\n      origin: metadata.origin,\r\n      direction: metadata.direction,\r\n      metadata: { Modality: this.modality },\r\n      getScalarData: () => this.getScalarData(),\r\n      imageData: {\r\n        getDirection: () => metadata.direction,\r\n        getDimensions: () => metadata.dimensions,\r\n        getRange: () => [0, 255],\r\n        getScalarData: () => this.getScalarData(),\r\n        getSpacing: () => metadata.spacing,\r\n        worldToIndex: (point: Point3) => {\r\n          const canvasPoint = this.worldToCanvas(point);\r\n          const pixelCoord = this.canvasToIndex(canvasPoint);\r\n          return [pixelCoord[0], pixelCoord[1], 0];\r\n        },\r\n        indexToWorld: (point: Point2, destPoint?: Point3) => {\r\n          const canvasPoint = this.indexToCanvas([point[0], point[1]]);\r\n          return this.canvasToWorld(canvasPoint, destPoint);\r\n        },\r\n      },\r\n      hasPixelSpacing: this.hasPixelSpacing,\r\n      calibration: this.calibration,\r\n      preScale: {\r\n        scaled: false,\r\n      },\r\n    };\r\n    Object.defineProperty(imageData, 'scalarData', {\r\n      get: () => this.getScalarData(),\r\n      enumerable: true,\r\n    });\r\n    return imageData;\r\n  }\r\n\r\n  /**\r\n   * Checks to see if the imageURI is currently being displayed.  The imageURI\r\n   * may contain frame numbers according to the DICOM standard format, which\r\n   * will be stripped to compare the base image URI, and then the values used\r\n   * to check if that frame is currently being displayed.\r\n   *\r\n   * The DICOM standard allows for comma separated values as well, however,\r\n   * this is not supported here, with only a single range or single value\r\n   * being tested.\r\n   *\r\n   * For a single value, the time range +/- 5 frames is permitted to allow\r\n   * the detection to actually succeed when nearby without requiring an exact\r\n   * time frame to be matched.\r\n   *\r\n   * @param imageURI - containing frame number or range.\r\n   * @returns\r\n   */\r\n  public hasImageURI(imageURI: string): boolean {\r\n    // TODO - move annotationFrameRange into core so it can be used here.\r\n    const framesMatch = imageURI.match(VideoViewport.frameRangeExtractor);\r\n    const testURI = framesMatch\r\n      ? imageURI.substring(0, framesMatch.index)\r\n      : imageURI;\r\n    return this.imageId.indexOf(testURI) !== -1;\r\n  }\r\n\r\n  public setVOI(voiRange: VOIRange): void {\r\n    this.voiRange = voiRange;\r\n    this.setColorTransform();\r\n  }\r\n\r\n  public setWindowLevel(windowWidth = 256, windowCenter = 128) {\r\n    const lower = windowCenter - windowWidth / 2;\r\n    const upper = windowCenter + windowWidth / 2 - 1;\r\n    this.setVOI({ lower, upper });\r\n    this.setColorTransform();\r\n  }\r\n\r\n  public setAverageWhite(averageWhite: [number, number, number]) {\r\n    this.averageWhite = averageWhite;\r\n    this.setColorTransform();\r\n  }\r\n\r\n  protected setColorTransform() {\r\n    if (!this.voiRange && !this.averageWhite) {\r\n      this.feFilter = null;\r\n      return;\r\n    }\r\n    const white = this.averageWhite || [255, 255, 255];\r\n    const maxWhite = Math.max(...white);\r\n    const scaleWhite = white.map((c) => maxWhite / c);\r\n    const { lower = 0, upper = 255 } = this.voiRange || {};\r\n    const wlScale = (upper - lower + 1) / 255;\r\n    const wlDelta = lower / 255;\r\n    this.feFilter = `url('data:image/svg+xml,\\\r\n      <svg xmlns=\"http://www.w3.org/2000/svg\">\\\r\n        <filter id=\"colour\" color-interpolation-filters=\"linearRGB\">\\\r\n        <feColorMatrix type=\"matrix\" \\\r\n        values=\"\\\r\n          ${scaleWhite[0] * wlScale} 0 0 0 ${wlDelta} \\\r\n          0 ${scaleWhite[1] * wlScale} 0 0 ${wlDelta} \\\r\n          0 0 ${scaleWhite[2] * wlScale} 0 ${wlDelta} \\\r\n          0 0 0 1 0\" />\\\r\n        </filter>\\\r\n      </svg>#colour')`;\r\n\r\n    this.canvas.style.filter = this.feFilter;\r\n  }\r\n\r\n  public setCamera(camera: ICamera): void {\r\n    const { parallelScale, focalPoint } = camera;\r\n\r\n    // NOTE: the parallel scale should be done first\r\n    // because it affects the focal point later\r\n    if (parallelScale) {\r\n      this.videoCamera.parallelScale =\r\n        this.element.clientHeight / 2 / parallelScale;\r\n    }\r\n\r\n    if (focalPoint !== undefined) {\r\n      const focalPointCanvas = this.worldToCanvas(focalPoint);\r\n      const canvasCenter: Point2 = [\r\n        this.element.clientWidth / 2,\r\n        this.element.clientHeight / 2,\r\n      ];\r\n\r\n      const panWorldDelta: Point2 = [\r\n        (focalPointCanvas[0] - canvasCenter[0]) /\r\n          this.videoCamera.parallelScale,\r\n        (focalPointCanvas[1] - canvasCenter[1]) /\r\n          this.videoCamera.parallelScale,\r\n      ];\r\n\r\n      this.videoCamera.panWorld = [\r\n        this.videoCamera.panWorld[0] - panWorldDelta[0],\r\n        this.videoCamera.panWorld[1] - panWorldDelta[1],\r\n      ];\r\n    }\r\n\r\n    this.canvasContext.fillStyle = 'rgba(0,0,0,1)';\r\n    this.canvasContext.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n    if (this.isPlaying === false) {\r\n      this.renderFrame();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This function returns the imageID associated with either the current\r\n   * frame being displayed, or the range of frames being played.  This may not\r\n   * correspond to any particular imageId that has imageId metadata, as the\r\n   * format is one of:\r\n   * `<DICOMweb URI>/frames/<Start Frame>(-<End Frame>)?`\r\n   * or\r\n   * `<Other URI>[?&]frameNumber=<Start Frame>(-<EndFrame>)?`\r\n   * for a URL parameter.\r\n   *\r\n   * @returns an imageID for video\r\n   */\r\n  public getCurrentImageId() {\r\n    const current = this.imageId.replace(\r\n      '/frames/1',\r\n      this.isPlaying\r\n        ? `/frames/${this.frameRange[0]}-${this.frameRange[1]}`\r\n        : `/frames/${this.getFrameNumber()}`\r\n    );\r\n    return current;\r\n  }\r\n\r\n  /**\r\n   *  Gets a target id that can be used to specify how to show this\r\n   */\r\n  public getReferenceId(specifier: ViewReferenceSpecifier = {}): string {\r\n    const { sliceIndex: sliceIndex } = specifier;\r\n    if (sliceIndex === undefined) {\r\n      return `videoId:${this.getCurrentImageId()}`;\r\n    }\r\n    if (Array.isArray(sliceIndex)) {\r\n      // Just remove the 1 from the end of the base URL - TODO, handle other types\r\n      return `videoId:${this.imageId.substring(0, this.imageId.length - 1)}${\r\n        sliceIndex[0] + 1\r\n      }-${sliceIndex[1] + 1}`;\r\n    }\r\n    const baseTarget = this.imageId.replace(\r\n      '/frames/1',\r\n      `/frames/${1 + sliceIndex}`\r\n    );\r\n    return `videoId:${baseTarget}`;\r\n  }\r\n\r\n  /**\r\n   * Figure out if a given view can be shown in the current viewport.\r\n   */\r\n  public isReferenceViewable(\r\n    viewRef: ViewReference,\r\n    options: ReferenceCompatibleOptions = {}\r\n  ): boolean {\r\n    let { imageURI } = options;\r\n    const { referencedImageId, sliceIndex: sliceIndex } = viewRef;\r\n    if (!super.isReferenceViewable(viewRef)) {\r\n      return false;\r\n    }\r\n\r\n    const imageId = this.getCurrentImageId();\r\n    if (!imageURI) {\r\n      // Remove the dataLoader scheme and frame number\r\n      // TODO - handle more imageURI types.\r\n      const colonIndex = imageId.indexOf(':');\r\n      imageURI = imageId.substring(colonIndex + 1, imageId.length - 1);\r\n    }\r\n\r\n    if (options.withNavigation) {\r\n      return true;\r\n    }\r\n    const currentIndex = this.getSliceIndex();\r\n    if (Array.isArray(sliceIndex)) {\r\n      return currentIndex >= sliceIndex[0] && currentIndex <= sliceIndex[1];\r\n    }\r\n    if (sliceIndex !== undefined) {\r\n      return currentIndex === sliceIndex;\r\n    }\r\n    if (!referencedImageId) {\r\n      return false;\r\n    }\r\n    const match = referencedImageId.match(VideoViewport.frameRangeExtractor);\r\n    if (!match || !match[2]) {\r\n      return true;\r\n    }\r\n    const range = match[2].split('-').map((it) => Number(it));\r\n    const frame = currentIndex + 1;\r\n    return range[0] <= frame && frame <= (range[1] ?? range[0]);\r\n  }\r\n\r\n  /**\r\n   * Gets a view target that species what type of view is required to show\r\n   * the current view, or the one specified in the forTarget modifiers.\r\n   */\r\n  public getViewReference(\r\n    viewRefSpecifier?: ViewReferenceSpecifier\r\n  ): ViewReference {\r\n    let sliceIndex = viewRefSpecifier?.sliceIndex;\r\n    if (!sliceIndex) {\r\n      sliceIndex = this.isPlaying\r\n        ? [this.frameRange[0] - 1, this.frameRange[1] - 1]\r\n        : this.getCurrentImageIdIndex();\r\n    }\r\n    return {\r\n      ...super.getViewReference(viewRefSpecifier),\r\n      referencedImageId: this.getReferenceId(viewRefSpecifier),\r\n      sliceIndex: sliceIndex,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Gets the 1 based frame number (ala DICOM value), eg `1+ currentImageIdIndex`\r\n   */\r\n  public getFrameNumber() {\r\n    // Need to round this as the fps/time isn't exact\r\n    return 1 + this.getCurrentImageIdIndex();\r\n  }\r\n\r\n  public getCurrentImageIdIndex() {\r\n    return Math.round(this.videoElement.currentTime * this.fps);\r\n  }\r\n\r\n  public getSliceIndex() {\r\n    return this.getCurrentImageIdIndex();\r\n  }\r\n\r\n  public getCamera(): ICamera {\r\n    const { parallelScale } = this.videoCamera;\r\n\r\n    const canvasCenter: Point2 = [\r\n      this.element.clientWidth / 2,\r\n      this.element.clientHeight / 2,\r\n    ];\r\n\r\n    // All other viewports have the focal point in canvas coordinates in the center\r\n    // of the canvas, so to make tools work the same, we need to do the same here\r\n    // and convert to the world coordinate system since focal point is in world coordinates.\r\n    const canvasCenterWorld = this.canvasToWorld(canvasCenter);\r\n\r\n    return {\r\n      parallelProjection: true,\r\n      focalPoint: canvasCenterWorld,\r\n      position: [0, 0, 0],\r\n      viewUp: [0, -1, 0],\r\n      parallelScale: this.element.clientHeight / 2 / parallelScale, // Reverse zoom direction back\r\n      viewPlaneNormal: [0, 0, 1],\r\n    };\r\n  }\r\n\r\n  public resetCamera = (): boolean => {\r\n    this.refreshRenderValues();\r\n\r\n    this.canvasContext.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n    if (this.isPlaying === false) {\r\n      // If its not replaying, just re-render the frame on move.\r\n      this.renderFrame();\r\n    }\r\n    return true;\r\n  };\r\n\r\n  public getNumberOfSlices = (): number => {\r\n    const computedSlices = Math.round(\r\n      (this.videoElement.duration * this.fps) / this.scrollSpeed\r\n    );\r\n    return isNaN(computedSlices) ? this.numberOfFrames : computedSlices;\r\n  };\r\n\r\n  public getFrameOfReferenceUID = (): string => {\r\n    // The video itself is the frame of reference.\r\n    return this.videoElement.src;\r\n  };\r\n\r\n  public resize = (): void => {\r\n    const canvas = this.canvas;\r\n    const { clientWidth, clientHeight } = canvas;\r\n\r\n    // Set the canvas to be same resolution as the client.\r\n    if (canvas.width !== clientWidth || canvas.height !== clientHeight) {\r\n      canvas.width = clientWidth;\r\n      canvas.height = clientHeight;\r\n    }\r\n\r\n    this.refreshRenderValues();\r\n\r\n    if (this.isPlaying === false) {\r\n      // If its not playing, just re-render on resize.\r\n      this.renderFrame();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Converts a VideoViewport canvas coordinate to a video coordinate.\r\n   *\r\n   * @param canvasPos - to convert to world\r\n   * @returns World position\r\n   */\r\n  public canvasToWorld = (\r\n    canvasPos: Point2,\r\n    destPos: Point3 = [0, 0, 0]\r\n  ): Point3 => {\r\n    const pan: Point2 = this.videoCamera.panWorld; // In world coordinates\r\n    const worldToCanvasRatio: number = this.getWorldToCanvasRatio();\r\n\r\n    const panOffsetCanvas: Point2 = [\r\n      pan[0] * worldToCanvasRatio,\r\n      pan[1] * worldToCanvasRatio,\r\n    ];\r\n\r\n    const subCanvasPos: Point2 = [\r\n      canvasPos[0] - panOffsetCanvas[0],\r\n      canvasPos[1] - panOffsetCanvas[1],\r\n    ];\r\n\r\n    // Replace the x,y values only in place in the world position\r\n    // as the z is unchanging for video display\r\n    destPos.splice(\r\n      0,\r\n      2,\r\n      subCanvasPos[0] / worldToCanvasRatio,\r\n      subCanvasPos[1] / worldToCanvasRatio\r\n    );\r\n    return destPos;\r\n  };\r\n\r\n  /**\r\n   * Converts `[x, y, 0]` world video coordinate to canvas CSS coordinates.\r\n   *\r\n   * @param  worldPos - world coord to convert to canvas\r\n   * @returns Canvas position\r\n   */\r\n  public worldToCanvas = (worldPos: Point3): Point2 => {\r\n    const pan: Point2 = this.videoCamera.panWorld;\r\n    const worldToCanvasRatio: number = this.getWorldToCanvasRatio();\r\n\r\n    const canvasPos: Point2 = [\r\n      (worldPos[0] + pan[0]) * worldToCanvasRatio,\r\n      (worldPos[1] + pan[1]) * worldToCanvasRatio,\r\n    ];\r\n\r\n    return canvasPos;\r\n  };\r\n\r\n  public getPan(): Point2 {\r\n    const panWorld = this.videoCamera.panWorld;\r\n    return [panWorld[0], panWorld[1]];\r\n  }\r\n\r\n  public getRotation = () => 0;\r\n\r\n  /**\r\n   * Uses the transform to convert canvas coordinates into index coordinates.\r\n   */\r\n  protected canvasToIndex = (canvasPos: Point2): Point2 => {\r\n    const transform = this.getTransform();\r\n    transform.invert();\r\n\r\n    return transform.transformPoint(\r\n      <Point2>canvasPos.map((it) => it * devicePixelRatio)\r\n    );\r\n  };\r\n\r\n  protected indexToCanvas = (indexPos: Point2): Point2 => {\r\n    const transform = this.getTransform();\r\n    return <Point2>(\r\n      transform.transformPoint(indexPos).map((it) => it / devicePixelRatio)\r\n    );\r\n  };\r\n\r\n  /**\r\n   * Sets  initial video camera to center the image area.  The values\r\n   * are set in canvas CSS pixel units and NOT in canvas index units.\r\n   */\r\n  private refreshRenderValues() {\r\n    // this means that each unit (pixel) in the world (video) would be\r\n    // represented by n pixels in the canvas, measured in css pixels\r\n    let worldToCanvasRatio = this.canvas.offsetWidth / this.videoWidth;\r\n\r\n    if (this.videoHeight * worldToCanvasRatio > this.canvas.height) {\r\n      // If by fitting the width, we exceed the height of the viewport, then we need to decrease the\r\n      // size of the viewport further by considering its verticality.\r\n      worldToCanvasRatio = this.canvas.offsetHeight / this.videoHeight;\r\n    }\r\n\r\n    // Set the width as big as possible, this is the portion of the canvas\r\n    // that the video will occupy.\r\n    const drawWidth = Math.floor(this.videoWidth * worldToCanvasRatio);\r\n    const drawHeight = Math.floor(this.videoHeight * worldToCanvasRatio);\r\n\r\n    // calculate x and y offset in order to center the image\r\n    const xOffsetCanvas = (this.canvas.offsetWidth - drawWidth) / 2;\r\n    const yOffsetCanvas = (this.canvas.offsetHeight - drawHeight) / 2;\r\n\r\n    const xOffsetWorld = xOffsetCanvas / worldToCanvasRatio;\r\n    const yOffsetWorld = yOffsetCanvas / worldToCanvasRatio;\r\n\r\n    this.videoCamera.panWorld = [xOffsetWorld, yOffsetWorld];\r\n    this.videoCamera.parallelScale = worldToCanvasRatio;\r\n  }\r\n\r\n  private getWorldToCanvasRatio() {\r\n    return this.videoCamera.parallelScale;\r\n  }\r\n\r\n  private getCanvasToWorldRatio() {\r\n    return 1.0 / this.videoCamera.parallelScale;\r\n  }\r\n\r\n  public customRenderViewportToCanvas = () => {\r\n    this.renderFrame();\r\n  };\r\n\r\n  /**\r\n   * Creates a transform from video index coordinates to canvas coordinates.\r\n   */\r\n  protected getTransform() {\r\n    const panWorld: Point2 = this.videoCamera.panWorld;\r\n    const devicePixelRatio = window.devicePixelRatio || 1;\r\n    const worldToCanvasRatio: number = this.getWorldToCanvasRatio();\r\n    const canvasToWorldRatio: number = this.getCanvasToWorldRatio();\r\n    const halfCanvas = [\r\n      this.canvas.offsetWidth / 2,\r\n      this.canvas.offsetHeight / 2,\r\n    ];\r\n    const halfCanvasWorldCoordinates = [\r\n      halfCanvas[0] * canvasToWorldRatio,\r\n      halfCanvas[1] * canvasToWorldRatio,\r\n    ];\r\n    const transform = new Transform();\r\n\r\n    // Start by converting into canvas index coordinates FROM canvas css pixel coordinates\r\n    transform.scale(devicePixelRatio, devicePixelRatio);\r\n\r\n    // Translate to the center of the canvas (move origin of the transform\r\n    // to the center of the canvas)\r\n    transform.translate(halfCanvas[0], halfCanvas[1]);\r\n\r\n    // Scale\r\n    transform.scale(worldToCanvasRatio, worldToCanvasRatio);\r\n\r\n    // Apply the translation\r\n    transform.translate(panWorld[0], panWorld[1]);\r\n\r\n    // Translate back\r\n    transform.translate(\r\n      -halfCanvasWorldCoordinates[0],\r\n      -halfCanvasWorldCoordinates[1]\r\n    );\r\n    return transform;\r\n  }\r\n\r\n  /**\r\n   * Nothing to do for the clipping planes for video as they don't exist.\r\n   */\r\n  public updateCameraClippingPlanesAndRange() {\r\n    // No-op\r\n  }\r\n\r\n  public addImages(stackInputs: Array<any>) {\r\n    const actors = this.getActors();\r\n    stackInputs.forEach((stackInput) => {\r\n      const image = cache.getImage(stackInput.imageId);\r\n\r\n      const imageActor = this.createActorMapper(image);\r\n      if (imageActor) {\r\n        actors.push({ uid: stackInput.actorUID, actor: imageActor });\r\n        if (stackInput.callback) {\r\n          stackInput.callback({ imageActor, imageId: stackInput.imageId });\r\n        }\r\n      }\r\n    });\r\n    this.setActors(actors);\r\n  }\r\n\r\n  protected createActorMapper(image) {\r\n    return new CanvasActor(this, image);\r\n  }\r\n\r\n  /**\r\n   * Renders the video frame to the viewport.\r\n   */\r\n  private renderFrame = () => {\r\n    const transform = this.getTransform();\r\n    const transformationMatrix: number[] = transform.getMatrix();\r\n\r\n    const ctx = this.canvasContext;\r\n\r\n    ctx.resetTransform();\r\n\r\n    // Need to correct the transform for device pixel ratio scaling.\r\n    ctx.transform(\r\n      transformationMatrix[0],\r\n      transformationMatrix[1],\r\n      transformationMatrix[2],\r\n      transformationMatrix[3],\r\n      transformationMatrix[4],\r\n      transformationMatrix[5]\r\n    );\r\n\r\n    ctx.drawImage(\r\n      this.videoElement,\r\n      0,\r\n      0,\r\n      this.videoWidth || 1024,\r\n      this.videoHeight || 1024\r\n    );\r\n\r\n    for (const actor of this.getActors()) {\r\n      (actor.actor as ICanvasActor).render(this, this.canvasContext);\r\n    }\r\n    this.canvasContext.resetTransform();\r\n\r\n    // This is stack new image to agree with stack/non-volume viewports\r\n    triggerEvent(this.element, EVENTS.STACK_NEW_IMAGE, {\r\n      element: this.element,\r\n      viewportId: this.id,\r\n      viewport: this,\r\n      renderingEngineId: this.renderingEngineId,\r\n      time: this.videoElement.currentTime,\r\n      duration: this.videoElement.duration,\r\n    });\r\n    triggerEvent(this.element, EVENTS.IMAGE_RENDERED, {\r\n      element: this.element,\r\n      viewportId: this.id,\r\n      viewport: this,\r\n      renderingEngineId: this.renderingEngineId,\r\n      time: this.videoElement.currentTime,\r\n      duration: this.videoElement.duration,\r\n    });\r\n\r\n    this.initialRender?.();\r\n\r\n    const frame = this.getFrameNumber();\r\n    if (this.isPlaying) {\r\n      if (frame < this.frameRange[0]) {\r\n        this.setFrameNumber(this.frameRange[0]);\r\n      } else if (frame > this.frameRange[1]) {\r\n        if (this.loop) {\r\n          this.setFrameNumber(this.frameRange[0]);\r\n        } else {\r\n          this.pause();\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  private renderWhilstPlaying = () => {\r\n    this.renderFrame();\r\n\r\n    //wait approximately 16ms and run again\r\n    if (this.isPlaying) {\r\n      requestAnimationFrame(this.renderWhilstPlaying);\r\n    }\r\n  };\r\n}\r\n\r\nexport default VideoViewport;\r\n","import type {\r\n  IStackViewport,\r\n  IStackInput,\r\n  IRenderingEngine,\r\n} from '../../types';\r\n\r\n/**\r\n * For each provided viewport it adds a volume to the viewport using the\r\n * provided renderingEngine\r\n *\r\n *\r\n * @param renderingEngine - The rendering engine to use to get viewports from\r\n * @param volumeInputs - Array of volume inputs including volumeId. Other properties\r\n * such as visibility, callback, blendMode, slabThickness are optional\r\n * @param viewportIds - Array of viewport IDs to add the volume to\r\n * @param immediateRender - If true, the volumes will be rendered immediately\r\n * @returns A promise that resolves when all volumes have been added\r\n */\r\nasync function addImageSlicesToViewports(\r\n  renderingEngine: IRenderingEngine,\r\n  stackInputs: Array<IStackInput>,\r\n  viewportIds: Array<string>\r\n): Promise<void> {\r\n  // Check if all viewports are volumeViewports\r\n  for (const viewportId of viewportIds) {\r\n    const viewport = renderingEngine.getViewport(viewportId);\r\n\r\n    if (!viewport) {\r\n      throw new Error(`Viewport with Id ${viewportId} does not exist`);\r\n    }\r\n\r\n    // if not instance of BaseVolumeViewport, throw\r\n    if (!(viewport as IStackViewport).addImages) {\r\n      console.warn(\r\n        `Viewport with Id ${viewportId} does not have addImages. Cannot add image segmentation to this viewport.`\r\n      );\r\n\r\n      return;\r\n    }\r\n  }\r\n\r\n  const addStackPromises = viewportIds.map(async (viewportId) => {\r\n    const viewport = renderingEngine.getViewport(viewportId) as IStackViewport;\r\n\r\n    return viewport.addImages(stackInputs);\r\n  });\r\n\r\n  await Promise.all(addStackPromises);\r\n}\r\n\r\nexport default addImageSlicesToViewports;\r\n","import BaseVolumeViewport from '../BaseVolumeViewport';\r\nimport type {\r\n  IVolumeViewport,\r\n  IVolumeInput,\r\n  IRenderingEngine,\r\n} from '../../types';\r\n\r\n/**\r\n * For each provided viewport it adds a volume to the viewport using the\r\n * provided renderingEngine\r\n *\r\n *\r\n * @param renderingEngine - The rendering engine to use to get viewports from\r\n * @param volumeInputs - Array of volume inputs including volumeId. Other properties\r\n * such as visibility, callback, blendMode, slabThickness are optional\r\n * @param viewportIds - Array of viewport IDs to add the volume to\r\n * @param immediateRender - If true, the volumes will be rendered immediately\r\n * @returns A promise that resolves when all volumes have been added\r\n */\r\nasync function addVolumesToViewports(\r\n  renderingEngine: IRenderingEngine,\r\n  volumeInputs: Array<IVolumeInput>,\r\n  viewportIds: Array<string>,\r\n  immediateRender = false,\r\n  suppressEvents = false\r\n): Promise<void> {\r\n  // Check if all viewports are volumeViewports\r\n  for (const viewportId of viewportIds) {\r\n    const viewport = renderingEngine.getViewport(viewportId);\r\n\r\n    if (!viewport) {\r\n      throw new Error(`Viewport with Id ${viewportId} does not exist`);\r\n    }\r\n\r\n    // if not instance of BaseVolumeViewport, throw\r\n    if (!(viewport instanceof BaseVolumeViewport)) {\r\n      console.warn(\r\n        `Viewport with Id ${viewportId} is not a BaseVolumeViewport. Cannot add volume to this viewport.`\r\n      );\r\n\r\n      return;\r\n    }\r\n  }\r\n\r\n  const addVolumePromises = viewportIds.map(async (viewportId) => {\r\n    const viewport = renderingEngine.getViewport(viewportId) as IVolumeViewport;\r\n\r\n    await viewport.addVolumes(volumeInputs, immediateRender, suppressEvents);\r\n  });\r\n\r\n  await Promise.all(addVolumePromises);\r\n  return;\r\n}\r\n\r\nexport default addVolumesToViewports;\r\n","import LookupTable from './lookupTable';\r\nimport CPU_COLORMAPS from '../../../../constants/cpuColormaps';\r\nimport {\r\n  CPUFallbackColormap,\r\n  CPUFallbackColormapData,\r\n  Point4,\r\n} from '../../../../types';\r\n\r\nconst COLOR_TRANSPARENT: Point4 = [0, 0, 0, 0];\r\n\r\n/**\r\n *  Generate linearly spaced vectors\r\n *  http://cens.ioc.ee/local/man/matlab/techdoc/ref/linspace.html\r\n * @param {Number} a A number representing the first vector\r\n * @param {Number} b A number representing the second vector\r\n * @param {Number} n The number of linear spaced vectors to generate\r\n * @returns {Array} An array of points representing linear spaced vectors.\r\n * @memberof Colors\r\n */\r\nfunction linspace(a: number, b: number, n: number): number[] {\r\n  n = n === null ? 100 : n;\r\n\r\n  const increment = (b - a) / (n - 1);\r\n  const vector = [];\r\n\r\n  while (n-- > 0) {\r\n    vector.push(a);\r\n    a += increment;\r\n  }\r\n\r\n  // Make sure the last item will always be \"b\" because most of the\r\n  // Time we'll get numbers like 1.0000000000000002 instead of 1.\r\n  vector[vector.length - 1] = b;\r\n\r\n  return vector;\r\n}\r\n\r\n/**\r\n * Returns the \"rank/index\" of the element in a sorted array if found or the highest index if not. Uses (binary search)\r\n * @param {Array} array A sorted array to search in\r\n * @param {any} elem the element in the array to search for\r\n * @returns {number} The rank/index of the element in the given array\r\n * @memberof Colors\r\n */\r\nfunction getRank(array, elem) {\r\n  let left = 0;\r\n  let right = array.length - 1;\r\n\r\n  while (left <= right) {\r\n    const mid = left + Math.floor((right - left) / 2);\r\n    const midElem = array[mid];\r\n\r\n    if (midElem === elem) {\r\n      return mid;\r\n    } else if (elem < midElem) {\r\n      right = mid - 1;\r\n    } else {\r\n      left = mid + 1;\r\n    }\r\n  }\r\n\r\n  return left;\r\n}\r\n\r\n/**\r\n * Find the indices into a sorted array a such that, if the corresponding elements\r\n * In v were inserted before the indices, the order of a would be preserved.\r\n *  http://lagrange.univ-lyon1.fr/docs/numpy/1.11.0/reference/generated/numpy.searchsorted.html\r\n * @param {Array} inputArray The array where the values will be inserted\r\n * @param {Array} values An array of the values to be inserted into the inputArray\r\n * @returns {Array} The indices where elements should be inserted to maintain order.\r\n * @memberof Colors\r\n */\r\nfunction searchSorted(inputArray, values) {\r\n  let i;\r\n  const indexes = [];\r\n  const len = values.length;\r\n\r\n  inputArray.sort(function (a, b) {\r\n    return a - b;\r\n  });\r\n\r\n  for (i = 0; i < len; i++) {\r\n    indexes[i] = getRank(inputArray, values[i]);\r\n  }\r\n\r\n  return indexes;\r\n}\r\n\r\n/**\r\n * Creates an *N* -element 1-d lookup table\r\n * @param {Number} N The number of elements in the result lookup table\r\n * @param {Array} data represented by a list of x,y0,y1 mapping correspondences. Each element in this\r\n * List represents how a value between 0 and 1 (inclusive) represented by x is mapped to\r\n * A corresponding value between 0 and 1 (inclusive). The two values of y are to allow for\r\n * Discontinuous mapping functions (say as might be found in a sawtooth) where y0 represents\r\n * The value of y for values of x <= to that given, and y1 is the value to be used for x >\r\n * Than that given). The list must start with x=0, end with x=1, and all values of x must be\r\n * In increasing order. Values between the given mapping points are determined by simple linear\r\n * Interpolation.\r\n * @param {any} gamma value denotes a \"gamma curve\" value which adjusts the brightness\r\n * at the bottom and top of the map.\r\n * @returns {any[]} an array \"result\" where result[x*(N-1)] gives the closest value for\r\n * Values of x between 0 and 1.\r\n * @memberof Colors\r\n */\r\nfunction makeMappingArray(N, data, gamma) {\r\n  let i;\r\n  const x = [];\r\n  const y0 = [];\r\n  const y1 = [];\r\n  const lut = [];\r\n\r\n  gamma = gamma === null ? 1 : gamma;\r\n\r\n  for (i = 0; i < data.length; i++) {\r\n    const element = data[i];\r\n\r\n    x.push((N - 1) * element[0]);\r\n    y0.push(element[1]);\r\n    y1.push(element[1]);\r\n  }\r\n\r\n  const xLinSpace = linspace(0, 1, N);\r\n\r\n  for (i = 0; i < N; i++) {\r\n    xLinSpace[i] = (N - 1) * Math.pow(xLinSpace[i], gamma);\r\n  }\r\n\r\n  const xLinSpaceIndexes = searchSorted(x, xLinSpace);\r\n\r\n  for (i = 1; i < N - 1; i++) {\r\n    const index = xLinSpaceIndexes[i];\r\n    const colorPercent =\r\n      (xLinSpace[i] - x[index - 1]) / (x[index] - x[index - 1]);\r\n    const colorDelta = y0[index] - y1[index - 1];\r\n\r\n    lut[i] = colorPercent * colorDelta + y1[index - 1];\r\n  }\r\n\r\n  lut[0] = y1[0];\r\n  lut[N - 1] = y0[data.length - 1];\r\n\r\n  return lut;\r\n}\r\n\r\n/**\r\n * Creates a Colormap based on lookup tables using linear segments.\r\n * @param {{red:Array, green:Array, blue:Array}} segmentedData An object with a red, green and blue entries.\r\n * Each entry should be a list of x, y0, y1 tuples, forming rows in a table.\r\n * @param {Number} N The number of elements in the result Colormap\r\n * @param {any} gamma value denotes a \"gamma curve\" value which adjusts the brightness\r\n * at the bottom and top of the Colormap.\r\n * @returns {Array} The created Colormap object\r\n * @description The lookup table is generated using linear interpolation for each\r\n *  Primary color, with the 0-1 domain divided into any number of\r\n * Segments.\r\n * https://github.com/stefanv/matplotlib/blob/3f1a23755e86fef97d51e30e106195f34425c9e3/lib/matplotlib/colors.py#L663\r\n * @memberof Colors\r\n */\r\nfunction createLinearSegmentedColormap(segmentedData, N, gamma) {\r\n  let i;\r\n  const lut = [];\r\n\r\n  N = N === null ? 256 : N;\r\n  gamma = gamma === null ? 1 : gamma;\r\n\r\n  const redLut = makeMappingArray(N, segmentedData.red, gamma);\r\n  const greenLut = makeMappingArray(N, segmentedData.green, gamma);\r\n  const blueLut = makeMappingArray(N, segmentedData.blue, gamma);\r\n\r\n  for (i = 0; i < N; i++) {\r\n    const red = Math.round(redLut[i] * 255);\r\n    const green = Math.round(greenLut[i] * 255);\r\n    const blue = Math.round(blueLut[i] * 255);\r\n    const rgba = [red, green, blue, 255];\r\n\r\n    lut.push(rgba);\r\n  }\r\n\r\n  return lut;\r\n}\r\n\r\n/**\r\n * Return all available colormaps (id and name)\r\n * @returns {Array<{id,key}>} An array of colormaps with an object containing the \"id\" and display \"name\"\r\n * @memberof Colors\r\n */\r\nexport function getColormapsList() {\r\n  const colormaps = [];\r\n  const keys = Object.keys(CPU_COLORMAPS);\r\n\r\n  keys.forEach(function (key) {\r\n    if (CPU_COLORMAPS.hasOwnProperty(key)) {\r\n      const colormap = CPU_COLORMAPS[key];\r\n\r\n      colormaps.push({\r\n        id: key,\r\n        name: colormap.name,\r\n      });\r\n    }\r\n  });\r\n\r\n  colormaps.sort(function (a, b) {\r\n    const aName = a.name.toLowerCase();\r\n    const bName = b.name.toLowerCase();\r\n\r\n    if (aName === bName) {\r\n      return 0;\r\n    }\r\n\r\n    return aName < bName ? -1 : 1;\r\n  });\r\n\r\n  return colormaps;\r\n}\r\n\r\n/**\r\n * Return a colorMap object with the provided id and colormapData\r\n * if the Id matches existent colorMap objects (check colormapsData) the colormapData is ignored.\r\n * if the colormapData is not empty, the colorMap will be added to the colormapsData list. Otherwise, an empty colorMap object is returned.\r\n * @param {string} id The ID of the colormap\r\n * @param {Object} colormapData - An object that can contain a name, numColors, gama, segmentedData and/or colors\r\n * @returns {*} The Colormap Object\r\n * @memberof Colors\r\n */\r\nexport function getColormap(\r\n  id: string,\r\n  colormapData?: CPUFallbackColormapData\r\n): CPUFallbackColormap {\r\n  let colormap = CPU_COLORMAPS[id];\r\n\r\n  if (!colormap) {\r\n    colormap = CPU_COLORMAPS[id] = colormapData || {\r\n      name: '',\r\n      colors: [],\r\n    };\r\n  }\r\n\r\n  if (!colormap.colors && colormap.segmentedData) {\r\n    colormap.colors = createLinearSegmentedColormap(\r\n      colormap.segmentedData,\r\n      colormap.numColors,\r\n      colormap.gamma\r\n    );\r\n  }\r\n\r\n  const cpuFallbackColormap: CPUFallbackColormap = {\r\n    getId() {\r\n      return id;\r\n    },\r\n\r\n    getColorSchemeName() {\r\n      return colormap.name;\r\n    },\r\n\r\n    setColorSchemeName(name) {\r\n      colormap.name = name;\r\n    },\r\n\r\n    getNumberOfColors() {\r\n      return colormap.colors.length;\r\n    },\r\n\r\n    setNumberOfColors(numColors) {\r\n      while (colormap.colors.length < numColors) {\r\n        colormap.colors.push(COLOR_TRANSPARENT);\r\n      }\r\n\r\n      colormap.colors.length = numColors;\r\n    },\r\n\r\n    getColor(index) {\r\n      if (this.isValidIndex(index)) {\r\n        return colormap.colors[index];\r\n      }\r\n\r\n      return COLOR_TRANSPARENT;\r\n    },\r\n\r\n    getColorRepeating(index) {\r\n      const numColors = colormap.colors.length;\r\n\r\n      index = numColors ? index % numColors : 0;\r\n\r\n      return this.getColor(index);\r\n    },\r\n\r\n    setColor(index, rgba) {\r\n      if (this.isValidIndex(index)) {\r\n        colormap.colors[index] = rgba;\r\n      }\r\n    },\r\n\r\n    addColor(rgba) {\r\n      colormap.colors.push(rgba);\r\n    },\r\n\r\n    insertColor(index, rgba) {\r\n      if (this.isValidIndex(index)) {\r\n        colormap.colors.splice(index, 1, rgba);\r\n      }\r\n    },\r\n\r\n    removeColor(index) {\r\n      if (this.isValidIndex(index)) {\r\n        colormap.colors.splice(index, 1);\r\n      }\r\n    },\r\n\r\n    clearColors() {\r\n      colormap.colors = [];\r\n    },\r\n\r\n    buildLookupTable(lut) {\r\n      if (!lut) {\r\n        return;\r\n      }\r\n\r\n      const numColors = colormap.colors.length;\r\n\r\n      lut.setNumberOfTableValues(numColors);\r\n\r\n      for (let i = 0; i < numColors; i++) {\r\n        lut.setTableValue(i, colormap.colors[i]);\r\n      }\r\n    },\r\n\r\n    createLookupTable() {\r\n      const lut = new LookupTable();\r\n\r\n      this.buildLookupTable(lut);\r\n\r\n      return lut;\r\n    },\r\n\r\n    isValidIndex(index) {\r\n      return index >= 0 && index < colormap.colors.length;\r\n    },\r\n  };\r\n\r\n  return cpuFallbackColormap;\r\n}\r\n","import now from './rendering/now';\r\nimport { renderColorImage } from './rendering/renderColorImage';\r\nimport { renderGrayscaleImage } from './rendering/renderGrayscaleImage';\r\nimport { renderPseudoColorImage } from './rendering/renderPseudoColorImage';\r\nimport { CPUFallbackEnabledElement } from '../../../types';\r\n\r\n/**\r\n * Draw an image to a given enabled element synchronously\r\n *\r\n * @param enabledElement - An enabled element to draw into\r\n * @param invalidated - true if pixel data has been invalidated and cached rendering should not be used\r\n */\r\nexport default function (\r\n  enabledElement: CPUFallbackEnabledElement,\r\n  invalidated: boolean\r\n): void {\r\n  const image = enabledElement.image;\r\n\r\n  // Check if enabledElement can be redrawn\r\n  if (!enabledElement.canvas || !enabledElement.image) {\r\n    return;\r\n  }\r\n\r\n  // Start measuring the time needed to draw the image.\r\n  const start = now();\r\n\r\n  image.stats = {\r\n    lastGetPixelDataTime: -1.0,\r\n    lastStoredPixelDataToCanvasImageDataTime: -1.0,\r\n    lastPutImageDataTime: -1.0,\r\n    lastRenderTime: -1.0,\r\n    lastLutGenerateTime: -1.0,\r\n  };\r\n\r\n  if (image) {\r\n    let render = image.render;\r\n\r\n    if (!render) {\r\n      if (enabledElement.viewport.colormap) {\r\n        render = renderPseudoColorImage;\r\n      } else if (image.color) {\r\n        render = renderColorImage;\r\n      } else {\r\n        render = renderGrayscaleImage;\r\n      }\r\n    }\r\n\r\n    render(enabledElement, invalidated);\r\n  }\r\n\r\n  // Calculate how long it took to draw the image/layers\r\n  const renderTimeInMs = now() - start;\r\n\r\n  image.stats.lastRenderTime = renderTimeInMs;\r\n\r\n  enabledElement.invalid = false;\r\n  enabledElement.needsRedraw = false;\r\n}\r\n","import { Transform } from './transform';\r\nimport {\r\n  CPUFallbackEnabledElement,\r\n  CPUFallbackTransform,\r\n} from '../../../../types';\r\n\r\n/**\r\n * Calculate the transform for a Cornerstone enabled element\r\n *\r\n * @param enabledElement - The Cornerstone Enabled Element\r\n * @param scale - The viewport scale\r\n * @returns The current transform\r\n */\r\nexport default function (\r\n  enabledElement: CPUFallbackEnabledElement,\r\n  scale?: number\r\n): CPUFallbackTransform {\r\n  const transform = new Transform();\r\n\r\n  if (!enabledElement.viewport.displayedArea) {\r\n    return transform;\r\n  }\r\n\r\n  // Move to center of canvas\r\n  transform.translate(\r\n    enabledElement.canvas.width / 2,\r\n    enabledElement.canvas.height / 2\r\n  );\r\n\r\n  // Apply the rotation before scaling for non square pixels\r\n  const angle = enabledElement.viewport.rotation;\r\n\r\n  if (angle !== 0) {\r\n    transform.rotate((angle * Math.PI) / 180);\r\n  }\r\n\r\n  // Apply the scale\r\n  let widthScale = enabledElement.viewport.scale;\r\n  let heightScale = enabledElement.viewport.scale;\r\n\r\n  const width =\r\n    enabledElement.viewport.displayedArea.brhc.x -\r\n    (enabledElement.viewport.displayedArea.tlhc.x - 1);\r\n  const height =\r\n    enabledElement.viewport.displayedArea.brhc.y -\r\n    (enabledElement.viewport.displayedArea.tlhc.y - 1);\r\n\r\n  if (enabledElement.viewport.displayedArea.presentationSizeMode === 'NONE') {\r\n    if (\r\n      enabledElement.image.rowPixelSpacing <\r\n      enabledElement.image.columnPixelSpacing\r\n    ) {\r\n      widthScale *=\r\n        enabledElement.image.columnPixelSpacing /\r\n        enabledElement.image.rowPixelSpacing;\r\n    } else if (\r\n      enabledElement.image.columnPixelSpacing <\r\n      enabledElement.image.rowPixelSpacing\r\n    ) {\r\n      heightScale *=\r\n        enabledElement.image.rowPixelSpacing /\r\n        enabledElement.image.columnPixelSpacing;\r\n    }\r\n  } else {\r\n    // These should be good for \"TRUE SIZE\" and \"MAGNIFY\"\r\n    widthScale = enabledElement.viewport.displayedArea.columnPixelSpacing;\r\n    heightScale = enabledElement.viewport.displayedArea.rowPixelSpacing;\r\n\r\n    if (\r\n      enabledElement.viewport.displayedArea.presentationSizeMode ===\r\n      'SCALE TO FIT'\r\n    ) {\r\n      // Fit TRUE IMAGE image (width/height) to window\r\n      const verticalScale =\r\n        enabledElement.canvas.height / (height * heightScale);\r\n      const horizontalScale =\r\n        enabledElement.canvas.width / (width * widthScale);\r\n\r\n      // Apply new scale\r\n      widthScale = heightScale = Math.min(horizontalScale, verticalScale);\r\n\r\n      if (\r\n        enabledElement.viewport.displayedArea.rowPixelSpacing <\r\n        enabledElement.viewport.displayedArea.columnPixelSpacing\r\n      ) {\r\n        widthScale *=\r\n          enabledElement.viewport.displayedArea.columnPixelSpacing /\r\n          enabledElement.viewport.displayedArea.rowPixelSpacing;\r\n      } else if (\r\n        enabledElement.viewport.displayedArea.columnPixelSpacing <\r\n        enabledElement.viewport.displayedArea.rowPixelSpacing\r\n      ) {\r\n        heightScale *=\r\n          enabledElement.viewport.displayedArea.rowPixelSpacing /\r\n          enabledElement.viewport.displayedArea.columnPixelSpacing;\r\n      }\r\n    }\r\n  }\r\n\r\n  transform.scale(widthScale, heightScale);\r\n\r\n  // Unrotate to so we can translate unrotated\r\n  if (angle !== 0) {\r\n    transform.rotate((-angle * Math.PI) / 180);\r\n  }\r\n\r\n  // Apply the pan offset\r\n  transform.translate(\r\n    enabledElement.viewport.translation.x,\r\n    enabledElement.viewport.translation.y\r\n  );\r\n\r\n  // Rotate again so we can apply general scale\r\n  if (angle !== 0) {\r\n    transform.rotate((angle * Math.PI) / 180);\r\n  }\r\n\r\n  if (scale !== undefined) {\r\n    // Apply the font scale\r\n    transform.scale(scale, scale);\r\n  }\r\n\r\n  // Apply Flip if required\r\n  if (enabledElement.viewport.hflip) {\r\n    transform.scale(-1, 1);\r\n  }\r\n\r\n  if (enabledElement.viewport.vflip) {\r\n    transform.scale(1, -1);\r\n  }\r\n\r\n  // Move back from center of image\r\n  transform.translate(-width / 2, -height / 2);\r\n\r\n  return transform;\r\n}\r\n","import getTransform from './getTransform';\r\n\r\nimport { Point2, CPUFallbackEnabledElement } from '../../../../types';\r\n\r\n/**\r\n * Converts a point in the canvas coordinate system to the pixel coordinate system\r\n * system.  This can be used to reset tools' image coordinates after modifications\r\n * have been made in canvas space (e.g. moving a tool by a few cm, independent of\r\n * image resolution).\r\n *\r\n * @param element - The Cornerstone element within which the input point lies\r\n * @param pt - The input point in the canvas coordinate system\r\n *\r\n * @returns The transformed point in the pixel coordinate system\r\n */\r\nexport default function (\r\n  enabledElement: CPUFallbackEnabledElement,\r\n  pt: Point2\r\n): Point2 {\r\n  const transform = getTransform(enabledElement);\r\n\r\n  transform.invert();\r\n\r\n  return transform.transformPoint(pt);\r\n}\r\n","import { CPUFallbackViewport, Point2 } from '../../../../types';\r\n\r\ntype Shift = {\r\n  x: number;\r\n  y: number;\r\n};\r\n/**\r\n * Corrects the shift by accounting for viewport rotation and flips.\r\n *\r\n * @param shift - The shift to correct.\r\n * @param viewportOrientation - Object containing information on the viewport orientation.\r\n */\r\nexport default function (\r\n  shift: Shift,\r\n  viewportOrientation: CPUFallbackViewport\r\n): Shift {\r\n  const { hflip, vflip, rotation } = viewportOrientation;\r\n\r\n  // Apply Flips\r\n  shift.x *= hflip ? -1 : 1;\r\n  shift.y *= vflip ? -1 : 1;\r\n\r\n  // Apply rotations\r\n  if (rotation !== 0) {\r\n    const angle = (rotation * Math.PI) / 180;\r\n\r\n    const cosA = Math.cos(angle);\r\n    const sinA = Math.sin(angle);\r\n\r\n    const newX = shift.x * cosA - shift.y * sinA;\r\n    const newY = shift.x * sinA + shift.y * cosA;\r\n\r\n    shift.x = newX;\r\n    shift.y = newY;\r\n  }\r\n\r\n  return shift;\r\n}\r\n","import createViewport from './createViewport';\r\nimport getImageFitScale from './getImageFitScale';\r\nimport {\r\n  IImage,\r\n  CPUFallbackColormap,\r\n  CPUFallbackViewport,\r\n} from '../../../../types';\r\n\r\n/**\r\n * Creates a new viewport object containing default values for the image and canvas\r\n *\r\n * @param canvas - A Canvas DOM element\r\n * @param image - A Cornerstone Image Object\r\n * @returns viewport - object\r\n */\r\nexport default function (\r\n  canvas: HTMLCanvasElement,\r\n  image: IImage,\r\n  modality?: string,\r\n  colormap?: CPUFallbackColormap\r\n): CPUFallbackViewport {\r\n  if (canvas === undefined) {\r\n    throw new Error(\r\n      'getDefaultViewport: parameter canvas must not be undefined'\r\n    );\r\n  }\r\n\r\n  if (image === undefined) {\r\n    return createViewport();\r\n  }\r\n\r\n  // Fit image to window\r\n  const scale = getImageFitScale(canvas, image, 0).scaleFactor;\r\n\r\n  let voi;\r\n\r\n  if (modality === 'PT' && image.isPreScaled) {\r\n    voi = {\r\n      windowWidth: 5,\r\n      windowCenter: 2.5,\r\n    };\r\n  } else if (\r\n    image.windowWidth !== undefined &&\r\n    image.windowCenter !== undefined\r\n  ) {\r\n    voi = {\r\n      windowWidth: Array.isArray(image.windowWidth)\r\n        ? image.windowWidth[0]\r\n        : image.windowWidth,\r\n      windowCenter: Array.isArray(image.windowCenter)\r\n        ? image.windowCenter[0]\r\n        : image.windowCenter,\r\n    };\r\n  }\r\n\r\n  return {\r\n    scale,\r\n    translation: {\r\n      x: 0,\r\n      y: 0,\r\n    },\r\n    voi,\r\n    invert: image.invert,\r\n    pixelReplication: false,\r\n    rotation: 0,\r\n    hflip: false,\r\n    vflip: false,\r\n    modalityLUT: image.modalityLUT,\r\n    modality,\r\n    voiLUT: image.voiLUT,\r\n    colormap: colormap !== undefined ? colormap : image.colormap,\r\n    displayedArea: {\r\n      tlhc: {\r\n        x: 1,\r\n        y: 1,\r\n      },\r\n      brhc: {\r\n        x: image.columns,\r\n        y: image.rows,\r\n      },\r\n      rowPixelSpacing:\r\n        image.rowPixelSpacing === undefined ? 1 : image.rowPixelSpacing,\r\n      columnPixelSpacing:\r\n        image.columnPixelSpacing === undefined ? 1 : image.columnPixelSpacing,\r\n      presentationSizeMode: 'NONE',\r\n    },\r\n  };\r\n}\r\n","import { validateParameterUndefinedOrNull } from './validator';\r\nimport getImageSize from './getImageSize';\r\nimport { IImage } from '../../../../types';\r\n\r\n/**\r\n * Calculates the horizontal, vertical and minimum scale factor for an image\r\n   @param canvas - The window size where the image is displayed. This can be any HTML element or structure with a width, height fields (e.g. canvas).\r\n * @param image - The cornerstone image object\r\n * @param rotation - The rotation angle of the image.\r\n * @returns The calculated horizontal, vertical and minimum scale factor\r\n */\r\nexport default function (\r\n  canvas: HTMLCanvasElement,\r\n  image: IImage,\r\n  rotation: number | null = null\r\n): {\r\n  verticalScale: number;\r\n  horizontalScale: number;\r\n  scaleFactor: number;\r\n} {\r\n  validateParameterUndefinedOrNull(\r\n    canvas,\r\n    'getImageScale: parameter canvas must not be undefined'\r\n  );\r\n  validateParameterUndefinedOrNull(\r\n    image,\r\n    'getImageScale: parameter image must not be undefined'\r\n  );\r\n\r\n  const imageSize = getImageSize(image, rotation);\r\n  const rowPixelSpacing = image.rowPixelSpacing || 1;\r\n  const columnPixelSpacing = image.columnPixelSpacing || 1;\r\n  let verticalRatio = 1;\r\n  let horizontalRatio = 1;\r\n\r\n  if (rowPixelSpacing < columnPixelSpacing) {\r\n    horizontalRatio = columnPixelSpacing / rowPixelSpacing;\r\n  } else {\r\n    // even if they are equal we want to calculate this ratio (the ration might be 0.5)\r\n    verticalRatio = rowPixelSpacing / columnPixelSpacing;\r\n  }\r\n\r\n  const verticalScale = canvas.height / imageSize.height / verticalRatio;\r\n  const horizontalScale = canvas.width / imageSize.width / horizontalRatio;\r\n\r\n  // Fit image to window\r\n  return {\r\n    verticalScale,\r\n    horizontalScale,\r\n    scaleFactor: Math.min(horizontalScale, verticalScale),\r\n  };\r\n}\r\n","import { validateParameterUndefinedOrNull } from './validator';\r\nimport { IImage } from '../../../../types';\r\n\r\n/**\r\n * Check if the angle is rotated\r\n * @param {Number} rotation the rotation angle\r\n * @returns {Boolean} true if the angle is rotated; Otherwise, false.\r\n * @memberof Internal\r\n */\r\nfunction isRotated(rotation?: number | null): boolean {\r\n  return !(\r\n    rotation === null ||\r\n    rotation === undefined ||\r\n    rotation === 0 ||\r\n    rotation === 180\r\n  );\r\n}\r\n\r\n/**\r\n * Retrieves the current image dimensions given an enabled element\r\n *\r\n * @param {any} image The Cornerstone image.\r\n * @param {Number} rotation Optional. The rotation angle of the image.\r\n * @return {{width:Number, height:Number}} The Image dimensions\r\n * @memberof Internal\r\n */\r\nexport default function (\r\n  image: IImage,\r\n  rotation = null\r\n): { height: number; width: number } {\r\n  validateParameterUndefinedOrNull(\r\n    image,\r\n    'getImageSize: parameter image must not be undefined'\r\n  );\r\n  validateParameterUndefinedOrNull(\r\n    image.width,\r\n    'getImageSize: parameter image must have width'\r\n  );\r\n  validateParameterUndefinedOrNull(\r\n    image.height,\r\n    'getImageSize: parameter image must have height'\r\n  );\r\n\r\n  if (isRotated(rotation)) {\r\n    return {\r\n      height: image.width,\r\n      width: image.height,\r\n    };\r\n  }\r\n\r\n  return {\r\n    width: image.width,\r\n    height: image.height,\r\n  };\r\n}\r\n","import calculateTransform from './calculateTransform';\r\nimport {\r\n  CPUFallbackEnabledElement,\r\n  CPUFallbackTransform,\r\n} from '../../../../types';\r\n\r\nexport default function (\r\n  enabledElement: CPUFallbackEnabledElement\r\n): CPUFallbackTransform {\r\n  // Todo: for some reason using the cached transfer after the first call\r\n  // does not give correct transform.\r\n  // if (enabledElement.transform) {\r\n  //   return enabledElement.transform;\r\n  // }\r\n\r\n  return calculateTransform(enabledElement);\r\n}\r\n","import getTransform from './getTransform';\r\nimport { CPUFallbackEnabledElement, Point2 } from '../../../../types';\r\n\r\n/**\r\n * Converts a point in the pixel coordinate system to the canvas coordinate system\r\n * system.  This can be used to render using canvas context without having the weird\r\n * side effects that come from scaling and non square pixels\r\n *\r\n * @param {HTMLDivElement} element An HTML Element enabled for Cornerstone\r\n * @param {{x: Number, y: Number}} pt The transformed point in the pixel coordinate system\r\n *\r\n * @returns {{x: Number, y: Number}} The input point in the canvas coordinate system\r\n * @memberof PixelCoordinateSystem\r\n */\r\nexport default function (\r\n  enabledElement: CPUFallbackEnabledElement,\r\n  pt: Point2\r\n): Point2 {\r\n  const transform = getTransform(enabledElement);\r\n\r\n  return transform.transformPoint(pt);\r\n}\r\n","import getImageFitScale from './getImageFitScale';\r\nimport { CPUFallbackEnabledElement } from '../../../../types';\r\n\r\n/**\r\n * Resets the camera to the default position. which would be the center of the image.\r\n * with no translation, no flipping, no zoom and proper scale.\r\n */\r\nexport default function (\r\n  enabledElement: CPUFallbackEnabledElement,\r\n  resetPan = true,\r\n  resetZoom = true\r\n): void {\r\n  const { canvas, image, viewport } = enabledElement;\r\n  const scale = getImageFitScale(canvas, image, 0).scaleFactor;\r\n\r\n  viewport.vflip = false;\r\n  viewport.hflip = false;\r\n\r\n  if (resetPan) {\r\n    viewport.translation.x = 0;\r\n    viewport.translation.y = 0;\r\n  }\r\n\r\n  if (resetZoom) {\r\n    viewport.displayedArea.tlhc.x = 1;\r\n    viewport.displayedArea.tlhc.y = 1;\r\n    viewport.displayedArea.brhc.x = image.columns;\r\n    viewport.displayedArea.brhc.y = image.rows;\r\n\r\n    viewport.scale = scale;\r\n  }\r\n}\r\n","import fitToWindow from './fitToWindow';\r\nimport getImageSize from './getImageSize';\r\nimport { CPUFallbackEnabledElement } from '../../../../types';\r\n\r\n/**\r\n * This module is responsible for enabling an element to display images with cornerstone\r\n *\r\n * @param {HTMLDivElement} element The DOM element enabled for Cornerstone\r\n * @param {HTMLDivElement} canvas The Canvas DOM element within the DOM element enabled for Cornerstone\r\n * @returns {void}\r\n */\r\nfunction setCanvasSize(enabledElement: CPUFallbackEnabledElement) {\r\n  const { canvas } = enabledElement;\r\n  const { clientWidth, clientHeight } = canvas;\r\n\r\n  // Set the canvas to be same resolution as the client.\r\n  if (canvas.width !== clientWidth || canvas.height !== clientHeight) {\r\n    canvas.width = clientWidth;\r\n    canvas.height = clientHeight;\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if the image of a given enabled element fitted the window\r\n * before the resize\r\n *\r\n * @param {EnabledElement} enabledElement The Cornerstone Enabled Element\r\n * @param {number} oldCanvasWidth The width of the canvas before the resize\r\n * @param {number} oldCanvasHeight The height of the canvas before the resize\r\n * @return {Boolean} true if it fitted the windows, false otherwise\r\n */\r\nfunction wasFitToWindow(\r\n  enabledElement: CPUFallbackEnabledElement,\r\n  oldCanvasWidth: number,\r\n  oldCanvasHeight: number\r\n): boolean {\r\n  const scale = enabledElement.viewport.scale;\r\n  const imageSize = getImageSize(\r\n    enabledElement.image,\r\n    enabledElement.viewport.rotation\r\n  );\r\n  const imageWidth = Math.round(imageSize.width * scale);\r\n  const imageHeight = Math.round(imageSize.height * scale);\r\n  const x = enabledElement.viewport.translation.x;\r\n  const y = enabledElement.viewport.translation.y;\r\n\r\n  return (\r\n    (imageWidth === oldCanvasWidth && imageHeight <= oldCanvasHeight) ||\r\n    (imageWidth <= oldCanvasWidth &&\r\n      imageHeight === oldCanvasHeight &&\r\n      x === 0 &&\r\n      y === 0)\r\n  );\r\n}\r\n\r\n/**\r\n * Rescale the image relative to the changed size of the canvas\r\n *\r\n * @param {EnabledElement} enabledElement The Cornerstone Enabled Element\r\n * @param {number} oldCanvasWidth The width of the canvas before the resize\r\n * @param {number} oldCanvasHeight The height of the canvas before the resize\r\n * @return {void}\r\n */\r\nfunction relativeRescale(\r\n  enabledElement: CPUFallbackEnabledElement,\r\n  oldCanvasWidth: number,\r\n  oldCanvasHeight: number\r\n): void {\r\n  const scale = enabledElement.viewport.scale;\r\n  const canvasWidth = enabledElement.canvas.width;\r\n  const canvasHeight = enabledElement.canvas.height;\r\n  const relWidthChange = canvasWidth / oldCanvasWidth;\r\n  const relHeightChange = canvasHeight / oldCanvasHeight;\r\n  const relChange = Math.sqrt(relWidthChange * relHeightChange);\r\n\r\n  enabledElement.viewport.scale = relChange * scale;\r\n}\r\n\r\n/**\r\n * Resizes an enabled element and optionally fits the image to window\r\n *\r\n * @param {HTMLDivElement} element The DOM element enabled for Cornerstone\r\n * @param {Boolean} forceFitToWindow true to to force a refit, false to rescale accordingly\r\n * @returns {void}\r\n */\r\nexport default function (\r\n  enabledElement: CPUFallbackEnabledElement,\r\n  forceFitToWindow = false\r\n): void {\r\n  const oldCanvasWidth = enabledElement.canvas.width;\r\n  const oldCanvasHeight = enabledElement.canvas.height;\r\n\r\n  setCanvasSize(enabledElement);\r\n\r\n  if (enabledElement.image === undefined) {\r\n    return;\r\n  }\r\n\r\n  if (\r\n    forceFitToWindow ||\r\n    wasFitToWindow(enabledElement, oldCanvasWidth, oldCanvasHeight)\r\n  ) {\r\n    // Fit the image to the window again if it fitted before the resize\r\n    fitToWindow(enabledElement);\r\n  } else {\r\n    // Adapt the scale of a zoomed or panned image relative to the size change\r\n    relativeRescale(enabledElement, oldCanvasWidth, oldCanvasHeight);\r\n  }\r\n}\r\n","import getImageFitScale from './getImageFitScale';\r\nimport { CPUFallbackEnabledElement } from '../../../../types';\r\n\r\n/**\r\n * Adjusts an image's scale and translation so the image is centered and all pixels\r\n * in the image are viewable.\r\n *\r\n * @param element - The Cornerstone element to update\r\n */\r\nexport default function (enabledElement: CPUFallbackEnabledElement): void {\r\n  const { image } = enabledElement;\r\n\r\n  // The new scale is the minimum of the horizontal and vertical scale values\r\n  enabledElement.viewport.scale = getImageFitScale(\r\n    enabledElement.canvas,\r\n    image,\r\n    enabledElement.viewport.rotation\r\n  ).scaleFactor;\r\n\r\n  enabledElement.viewport.translation.x = 0;\r\n  enabledElement.viewport.translation.y = 0;\r\n}\r\n","import vtkVolume from '@kitware/vtk.js/Rendering/Core/Volume';\r\n\r\nimport { VolumeActor } from './../../types/IActor';\r\nimport { VoiModifiedEventDetail } from './../../types/EventTypes';\r\nimport { loadVolume } from '../../loaders/volumeLoader';\r\nimport createVolumeMapper from './createVolumeMapper';\r\nimport BlendModes from '../../enums/BlendModes';\r\nimport { triggerEvent } from '../../utilities';\r\nimport { Events } from '../../enums';\r\nimport setDefaultVolumeVOI from './setDefaultVolumeVOI';\r\n\r\ninterface createVolumeActorInterface {\r\n  volumeId: string;\r\n  callback?: ({\r\n    volumeActor,\r\n    volumeId,\r\n  }: {\r\n    volumeActor: VolumeActor;\r\n    volumeId: string;\r\n  }) => void;\r\n  blendMode?: BlendModes;\r\n}\r\n\r\n/**\r\n * Given a volumeId, it creates a vtk volume actor and returns it. If\r\n * callback is provided, it will be called with the volume actor and the\r\n * volumeId. If blendMode is provided, it will be set on the volume actor.\r\n *\r\n * @param props - createVolumeActorInterface\r\n * @returns A promise that resolves to a VolumeActor.\r\n */\r\nasync function createVolumeActor(\r\n  props: createVolumeActorInterface,\r\n  element: HTMLDivElement,\r\n  viewportId: string,\r\n  suppressEvents = false,\r\n  useNativeDataType = false\r\n): Promise<VolumeActor> {\r\n  const { volumeId, callback, blendMode } = props;\r\n\r\n  const imageVolume = await loadVolume(volumeId);\r\n\r\n  if (!imageVolume) {\r\n    throw new Error(\r\n      `imageVolume with id: ${imageVolume.volumeId} does not exist`\r\n    );\r\n  }\r\n\r\n  const { imageData, vtkOpenGLTexture } = imageVolume;\r\n\r\n  const volumeMapper = createVolumeMapper(imageData, vtkOpenGLTexture);\r\n\r\n  if (blendMode) {\r\n    volumeMapper.setBlendMode(blendMode);\r\n  }\r\n\r\n  const volumeActor = vtkVolume.newInstance();\r\n  volumeActor.setMapper(volumeMapper);\r\n\r\n  const numberOfComponents = imageData\r\n    .getPointData()\r\n    .getScalars()\r\n    .getNumberOfComponents();\r\n\r\n  if (numberOfComponents === 3) {\r\n    volumeActor.getProperty().setIndependentComponents(false);\r\n  }\r\n\r\n  await setDefaultVolumeVOI(volumeActor, imageVolume, useNativeDataType);\r\n\r\n  if (callback) {\r\n    callback({ volumeActor, volumeId });\r\n  }\r\n\r\n  if (!suppressEvents) {\r\n    triggerVOIModified(element, viewportId, volumeActor, volumeId);\r\n  }\r\n\r\n  return volumeActor;\r\n}\r\n\r\nfunction triggerVOIModified(\r\n  element: HTMLDivElement,\r\n  viewportId: string,\r\n  volumeActor: VolumeActor,\r\n  volumeId: string\r\n) {\r\n  const voiRange = volumeActor\r\n    .getProperty()\r\n    .getRGBTransferFunction(0)\r\n    .getRange();\r\n\r\n  const voiModifiedEventDetail: VoiModifiedEventDetail = {\r\n    viewportId,\r\n    range: {\r\n      lower: voiRange[0],\r\n      upper: voiRange[1],\r\n    },\r\n    volumeId,\r\n  };\r\n\r\n  triggerEvent(element, Events.VOI_MODIFIED, voiModifiedEventDetail);\r\n}\r\n\r\nexport default createVolumeActor;\r\n","import {\r\n  VolumeActor,\r\n  IImageVolume,\r\n  VOIRange,\r\n  ScalingParameters,\r\n} from '../../types';\r\nimport { loadAndCacheImage } from '../../loaders/imageLoader';\r\nimport * as metaData from '../../metaData';\r\nimport { getMinMax, windowLevel } from '../../utilities';\r\nimport { RequestType } from '../../enums';\r\nimport cache from '../../cache';\r\n\r\nconst PRIORITY = 0;\r\nconst REQUEST_TYPE = RequestType.Prefetch;\r\n\r\n/**\r\n * It sets the default window level of an image volume based on the VOI.\r\n * It first look for the VOI in the metadata and if it is not found, it\r\n * loads the middle slice image (middle imageId) and based on its min\r\n * and max pixel values, it calculates the VOI.\r\n * Finally it sets the VOI on the volumeActor transferFunction\r\n * @param volumeActor - The volume actor\r\n * @param imageVolume - The image volume that we want to set the VOI for.\r\n * @param useNativeDataType -  The image data type is native or Float32Array\r\n */\r\nasync function setDefaultVolumeVOI(\r\n  volumeActor: VolumeActor,\r\n  imageVolume: IImageVolume,\r\n  useNativeDataType: boolean\r\n): Promise<void> {\r\n  let voi = getVOIFromMetadata(imageVolume);\r\n\r\n  if (!voi && imageVolume?.imageIds?.length) {\r\n    voi = await getVOIFromMinMax(imageVolume, useNativeDataType);\r\n    voi = handlePreScaledVolume(imageVolume, voi);\r\n  }\r\n  // if (!voi || voi.lower === undefined || voi.upper === undefined) {\r\n  //   throw new Error(\r\n  //     'Could not get VOI from metadata, nor from the min max of the image middle slice'\r\n  //   );\r\n  // }\r\n  if (\r\n    (voi?.lower === 0 && voi?.upper === 0) ||\r\n    voi?.lower === undefined ||\r\n    voi?.upper === undefined\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  volumeActor\r\n    .getProperty()\r\n    .getRGBTransferFunction(0)\r\n    .setMappingRange(voi.lower, voi.upper);\r\n}\r\n\r\nfunction handlePreScaledVolume(imageVolume: IImageVolume, voi: VOIRange) {\r\n  const imageIds = imageVolume.imageIds;\r\n  const imageIdIndex = Math.floor(imageIds.length / 2);\r\n  const imageId = imageIds[imageIdIndex];\r\n\r\n  const generalSeriesModule =\r\n    metaData.get('generalSeriesModule', imageId) || {};\r\n\r\n  /**\r\n   * If the volume is prescaled and the modality is PT Sometimes you get super high\r\n   * values at the peak and it skews the min/max so nothing useful is displayed\r\n   * Therefore, we follow the majority of other viewers and we set the min/max\r\n   * for the scaled PT to be 0, 5\r\n   */\r\n  if (_isCurrentImagePTPrescaled(generalSeriesModule.modality, imageVolume)) {\r\n    return {\r\n      lower: 0,\r\n      upper: 5,\r\n    };\r\n  }\r\n\r\n  return voi;\r\n}\r\n\r\n/**\r\n * Get the VOI from the metadata of the middle slice of the image volume or the metadata of the image volume\r\n * It checks the metadata for the VOI and if it is not found, it returns null\r\n *\r\n * @param imageVolume - The image volume that we want to get the VOI from.\r\n * @returns VOIRange with lower and upper values\r\n */\r\nfunction getVOIFromMetadata(imageVolume: IImageVolume): VOIRange {\r\n  const { imageIds, metadata } = imageVolume;\r\n  let voi;\r\n  if (imageIds.length) {\r\n    const imageIdIndex = Math.floor(imageIds.length / 2);\r\n    const imageId = imageIds[imageIdIndex];\r\n    const voiLutModule = metaData.get('voiLutModule', imageId);\r\n    if (voiLutModule && voiLutModule.windowWidth && voiLutModule.windowCenter) {\r\n      const { windowWidth, windowCenter } = voiLutModule;\r\n      voi = {\r\n        windowWidth: Array.isArray(windowWidth) ? windowWidth[0] : windowWidth,\r\n        windowCenter: Array.isArray(windowCenter)\r\n          ? windowCenter[0]\r\n          : windowCenter,\r\n      };\r\n    }\r\n  } else {\r\n    voi = metadata?.voiLut?.[0];\r\n  }\r\n  if (voi) {\r\n    const { lower, upper } = windowLevel.toLowHighRange(\r\n      Number(voi.windowWidth),\r\n      Number(voi.windowCenter)\r\n    );\r\n    return {\r\n      lower,\r\n      upper,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * It loads the middle slice image (middle imageId) and based on its min\r\n * and max pixel values, it calculates the VOI.\r\n *\r\n * @param imageVolume - The image volume that we want to get the VOI from.\r\n * @param useNativeDataType -  The image data type is native or Float32Array\r\n * @returns The VOIRange with lower and upper values\r\n */\r\nasync function getVOIFromMinMax(\r\n  imageVolume: IImageVolume,\r\n  useNativeDataType: boolean\r\n): Promise<VOIRange> {\r\n  const { imageIds } = imageVolume;\r\n  const scalarData = imageVolume.getScalarData();\r\n\r\n  // Get the middle image from the list of imageIds\r\n  const imageIdIndex = Math.floor(imageIds.length / 2);\r\n  const imageId = imageVolume.imageIds[imageIdIndex];\r\n  const generalSeriesModule =\r\n    metaData.get('generalSeriesModule', imageId) || {};\r\n  const { modality } = generalSeriesModule;\r\n  const modalityLutModule = metaData.get('modalityLutModule', imageId) || {};\r\n\r\n  const numImages = imageIds.length;\r\n  const bytesPerImage = scalarData.byteLength / numImages;\r\n  const voxelsPerImage = scalarData.length / numImages;\r\n  const bytePerPixel = scalarData.BYTES_PER_ELEMENT;\r\n\r\n  const scalingParameters: ScalingParameters = {\r\n    rescaleSlope: modalityLutModule.rescaleSlope,\r\n    rescaleIntercept: modalityLutModule.rescaleIntercept,\r\n    modality,\r\n  };\r\n\r\n  let scalingParametersToUse;\r\n  if (modality === 'PT') {\r\n    const suvFactor = metaData.get('scalingModule', imageId);\r\n\r\n    if (suvFactor) {\r\n      scalingParametersToUse = {\r\n        ...scalingParameters,\r\n        suvbw: suvFactor.suvbw,\r\n      };\r\n    }\r\n  }\r\n\r\n  const byteOffset = imageIdIndex * bytesPerImage;\r\n\r\n  const options = {\r\n    targetBuffer: {\r\n      type: useNativeDataType ? undefined : 'Float32Array',\r\n    },\r\n    priority: PRIORITY,\r\n    requestType: REQUEST_TYPE,\r\n    useNativeDataType,\r\n    preScale: {\r\n      enabled: true,\r\n      scalingParameters: scalingParametersToUse,\r\n    },\r\n  };\r\n\r\n  // Loading the middle slice image for a volume has two scenarios, the first one is that\r\n  // uses the same volumeLoader which might not resolve to an image (since for performance\r\n  // reasons volumes' pixelData is set via offset and length on the volume arrayBuffer\r\n  // when each slice is loaded). The second scenario is that the image might not reach\r\n  // to the volumeLoader, and an already cached image (with Image object) is used\r\n  // instead. For the first scenario, we use the arrayBuffer of the volume to get the correct\r\n  // slice for the imageScalarData, and for the second scenario we use the getPixelData\r\n  // on the Cornerstone IImage object to get the pixel data.\r\n  // Note: we don't want to use the derived or generated images for setting the\r\n  // default VOI, because they are not the original. This is ugly but don't\r\n  // know how to do it better.\r\n  let image = cache.getImage(imageId);\r\n\r\n  if (!imageVolume.referencedImageIds?.length) {\r\n    // we should ignore the cache here,\r\n    // since we want to load the image from with the most\r\n    // recent prescale settings\r\n    image = await loadAndCacheImage(imageId, { ...options, ignoreCache: true });\r\n  }\r\n\r\n  const imageScalarData = image\r\n    ? image.getPixelData()\r\n    : _getImageScalarDataFromImageVolume(\r\n        imageVolume,\r\n        byteOffset,\r\n        bytePerPixel,\r\n        voxelsPerImage\r\n      );\r\n\r\n  // Get the min and max pixel values of the middle slice\r\n  const { min, max } = getMinMax(imageScalarData);\r\n\r\n  return {\r\n    lower: min,\r\n    upper: max,\r\n  };\r\n}\r\n\r\nfunction _getImageScalarDataFromImageVolume(\r\n  imageVolume,\r\n  byteOffset,\r\n  bytePerPixel,\r\n  voxelsPerImage\r\n) {\r\n  const { scalarData } = imageVolume;\r\n  const { buffer } = scalarData;\r\n  if (scalarData.BYTES_PER_ELEMENT !== bytePerPixel) {\r\n    byteOffset *= scalarData.BYTES_PER_ELEMENT / bytePerPixel;\r\n  }\r\n\r\n  const TypedArray = scalarData.constructor;\r\n  const imageScalarData = new TypedArray(voxelsPerImage);\r\n\r\n  const volumeBufferView = new TypedArray(buffer, byteOffset, voxelsPerImage);\r\n\r\n  imageScalarData.set(volumeBufferView);\r\n\r\n  return imageScalarData;\r\n}\r\n\r\nfunction _isCurrentImagePTPrescaled(modality, imageVolume) {\r\n  if (modality !== 'PT' || !imageVolume.isPreScaled) {\r\n    return false;\r\n  }\r\n\r\n  if (!imageVolume.scaling?.PT.suvbw) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport default setDefaultVolumeVOI;\r\n","import macro from '@kitware/vtk.js/macros';\r\nimport vtkVolumeMapper from '@kitware/vtk.js/Rendering/Core/VolumeMapper';\r\n\r\n/**\r\n * vtkSharedVolumeMapper - A derived class of the core vtkVolumeMapper class\r\n * the scalar texture in as an argument. This is so we can share the same texture\r\n * memory across different mappers/actors, so we don't duplicate memory usage.\r\n *\r\n *\r\n *\r\n * @param {*} publicAPI The public API to extend\r\n * @param {*} model The private model to extend.\r\n * @hidden\r\n */\r\nfunction vtkSharedVolumeMapper(publicAPI, model) {\r\n  model.classHierarchy.push('vtkSharedVolumeMapper');\r\n\r\n  const superDelete = publicAPI.delete;\r\n  publicAPI.delete = () => {\r\n    model.scalarTexture = null;\r\n    superDelete();\r\n  };\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Object factory\r\n// ----------------------------------------------------------------------------\r\n\r\n// ----------------------------------------------------------------------------\r\n\r\nconst DEFAULT_VALUES = {\r\n  scalarTexture: null,\r\n};\r\n\r\nexport function extend(publicAPI, model, initialValues = {}) {\r\n  Object.assign(model, DEFAULT_VALUES, initialValues);\r\n\r\n  vtkVolumeMapper.extend(publicAPI, model, initialValues);\r\n\r\n  macro.setGet(publicAPI, model, ['scalarTexture']);\r\n\r\n  // Object methods\r\n  vtkSharedVolumeMapper(publicAPI, model);\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n\r\nexport const newInstance = macro.newInstance(extend, 'vtkSharedVolumeMapper');\r\n\r\n// ----------------------------------------------------------------------------\r\n\r\nexport default { newInstance, extend };\r\n","/*\r\n * Constants\r\n */\r\n\r\nconst DEFAULT_SETTINGS = Symbol('DefaultSettings');\r\nconst RUNTIME_SETTINGS = Symbol('RuntimeSettings');\r\nconst OBJECT_SETTINGS_MAP = Symbol('ObjectSettingsMap');\r\nconst DICTIONARY = Symbol('Dictionary');\r\n\r\n/**\r\n * Settings\r\n */\r\nexport default class Settings {\r\n  constructor(base?: Settings) {\r\n    const dictionary = Object.create(\r\n      (base instanceof Settings && DICTIONARY in base\r\n        ? base[DICTIONARY]\r\n        : null) as object\r\n    );\r\n    Object.seal(\r\n      Object.defineProperty(this, DICTIONARY, {\r\n        value: dictionary,\r\n      })\r\n    );\r\n  }\r\n\r\n  set(key: string, value: unknown): boolean {\r\n    return set(this[DICTIONARY], key, value, null);\r\n  }\r\n\r\n  get(key: string): unknown {\r\n    return get(this[DICTIONARY], key);\r\n  }\r\n\r\n  /**\r\n   * Unset a specific key or a set of keys within a namespace when the key ends with a dot (ASCII #46).\r\n   * If the key is \".\", all keys will be removed and this command works as a reset.\r\n   * @param key - name The key to be unset or a namespace.\r\n   * @returns boolean\r\n   */\r\n  unset(key: string): boolean {\r\n    return unset(this[DICTIONARY], key + '');\r\n  }\r\n\r\n  forEach(callback: (key: string, value: unknown) => void): void {\r\n    iterate(this[DICTIONARY], callback);\r\n  }\r\n\r\n  extend(): Settings {\r\n    return new Settings(this);\r\n  }\r\n\r\n  /**\r\n   * Recursively import all properties from the given plain JavaScript object.\r\n   * This method has the opposite effect of the `dump` method.\r\n   * @param root - The root object whose properties will\r\n   * be imported.\r\n   */\r\n  import(root: Record<string, unknown>): void {\r\n    if (isPlainObject(root)) {\r\n      Object.keys(root).forEach((key) => {\r\n        set(this[DICTIONARY], key, root[key], null);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Build a JSON representation of the current internal state of this settings\r\n   * object. The returned object can be safely passed to `JSON.stringify`\r\n   * function.\r\n   * @returns The JSON representation of the current\r\n   * state of this settings instance\r\n   */\r\n  dump(): Record<string, unknown> {\r\n    const context = {};\r\n    iterate(this[DICTIONARY], (key, value) => {\r\n      if (typeof value !== 'undefined') {\r\n        deepSet(context, key, value);\r\n      }\r\n    });\r\n    return context;\r\n  }\r\n\r\n  static assert(subject: Settings): Settings {\r\n    return subject instanceof Settings\r\n      ? subject\r\n      : Settings.getRuntimeSettings();\r\n  }\r\n\r\n  static getDefaultSettings(subfield = null): Settings | any {\r\n    let defaultSettings = Settings[DEFAULT_SETTINGS];\r\n    if (!(defaultSettings instanceof Settings)) {\r\n      defaultSettings = new Settings();\r\n      Settings[DEFAULT_SETTINGS] = defaultSettings;\r\n    }\r\n\r\n    // Given subfield of 'segmentation' it will return all settings\r\n    // that starts with segmentation.*\r\n    if (subfield) {\r\n      const settingObj = {};\r\n      defaultSettings.forEach((name: string) => {\r\n        if (name.startsWith(subfield)) {\r\n          const setting = name.split(`${subfield}.`)[1];\r\n          settingObj[setting] = defaultSettings.get(name);\r\n        }\r\n      });\r\n      return settingObj;\r\n    }\r\n\r\n    return defaultSettings;\r\n  }\r\n\r\n  static getRuntimeSettings(): Settings {\r\n    let runtimeSettings = Settings[RUNTIME_SETTINGS];\r\n    if (!(runtimeSettings instanceof Settings)) {\r\n      runtimeSettings = new Settings(Settings.getDefaultSettings());\r\n      Settings[RUNTIME_SETTINGS] = runtimeSettings;\r\n    }\r\n    return runtimeSettings;\r\n  }\r\n\r\n  static getObjectSettings(subject: unknown, from?: unknown): Settings {\r\n    let settings = null;\r\n    if (subject instanceof Settings) {\r\n      settings = subject;\r\n    } else if (typeof subject === 'object' && subject !== null) {\r\n      let objectSettingsMap = Settings[OBJECT_SETTINGS_MAP];\r\n      if (!(objectSettingsMap instanceof WeakMap)) {\r\n        objectSettingsMap = new WeakMap();\r\n        Settings[OBJECT_SETTINGS_MAP] = objectSettingsMap;\r\n      }\r\n      settings = objectSettingsMap.get(subject);\r\n      if (!(settings instanceof Settings)) {\r\n        settings = new Settings(\r\n          Settings.assert(Settings.getObjectSettings(from))\r\n        );\r\n        objectSettingsMap.set(subject, settings);\r\n      }\r\n    }\r\n    return settings;\r\n  }\r\n\r\n  static extendRuntimeSettings(): Settings {\r\n    return Settings.getRuntimeSettings().extend();\r\n  }\r\n}\r\n\r\n/*\r\n * Local Helpers\r\n */\r\n\r\nfunction unset(dictionary: Record<string, unknown>, name: string): boolean {\r\n  if (name.endsWith('.')) {\r\n    let deleteCount = 0;\r\n    const namespace = name;\r\n    const base = namespace.slice(0, -1);\r\n    const deleteAll = base.length === 0;\r\n    for (const key in dictionary) {\r\n      if (\r\n        Object.prototype.hasOwnProperty.call(dictionary, key) &&\r\n        (deleteAll || key.startsWith(namespace) || key === base)\r\n      ) {\r\n        delete dictionary[key];\r\n        ++deleteCount;\r\n      }\r\n    }\r\n    return deleteCount > 0;\r\n  }\r\n  return delete dictionary[name];\r\n}\r\n\r\nfunction iterate(\r\n  dictionary: Record<string, unknown>,\r\n  callback: (key: string, value: unknown) => void\r\n): void {\r\n  for (const key in dictionary) {\r\n    callback(key, dictionary[key]);\r\n  }\r\n}\r\n\r\nfunction setAll(\r\n  dictionary: Record<string, unknown>,\r\n  prefix: string,\r\n  record: Record<string, unknown>,\r\n  references: WeakSet<Record<string, unknown>>\r\n): boolean {\r\n  let failCount: number;\r\n  if (references.has(record)) {\r\n    return set(dictionary, prefix, null, references);\r\n  }\r\n  references.add(record);\r\n  failCount = 0;\r\n  for (const field in record) {\r\n    if (Object.prototype.hasOwnProperty.call(record, field)) {\r\n      const key = field.length === 0 ? prefix : `${prefix}.${field}`;\r\n      if (!set(dictionary, key, record[field], references)) {\r\n        ++failCount;\r\n      }\r\n    }\r\n  }\r\n  references.delete(record);\r\n  return failCount === 0;\r\n}\r\n\r\n/**\r\n * Set the key-value pair on a given dictionary. If the given value is a\r\n * plain javascript object, every property of that object will also be set.\r\n * @param dictionary {Record<string, unknown>} The target dictionary\r\n * @param key {string} The given key\r\n * @param value {unknown} The given value\r\n * @param references {WeakSet<Record<string, unknown>>} references is a WeakSet\r\n *  instance used to keep track of which objects have already been iterated\r\n *  through preventing thus possible stack overflows caused by cyclic references\r\n * @returns {boolean} Returns true if every given key-value pair has been\r\n * successfully set\r\n */\r\nfunction set(\r\n  dictionary: Record<string, unknown>,\r\n  key: string,\r\n  value: unknown,\r\n  references: WeakSet<Record<string, unknown>>\r\n): boolean {\r\n  if (isValidKey(key)) {\r\n    if (isPlainObject(value)) {\r\n      return setAll(\r\n        dictionary,\r\n        key,\r\n        value as Record<string, unknown>,\r\n        references instanceof WeakSet ? references : new WeakSet()\r\n      );\r\n    }\r\n    dictionary[key] = value;\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction get(dictionary: Record<string, unknown>, key: string): unknown {\r\n  return dictionary[key];\r\n}\r\n\r\n/**\r\n * Make sure the -provided key correctly formatted.\r\n * e.g.:\r\n *  \"my.cool.property\" (valid)\r\n *  \"my.cool.property.\" (invalid)\r\n *  \".my.cool.property\" (invalid)\r\n *  \"my.cool..property\" (invalid)\r\n * @param key {string} The property name to be used as key within the internal\r\n *  dictionary\r\n * @returns {boolean} True on success, false otherwise\r\n */\r\nfunction isValidKey(key: string): boolean {\r\n  let last: number, current: number, previous: number;\r\n  if (typeof key !== 'string' || (last = key.length - 1) < 0) {\r\n    return false;\r\n  }\r\n  previous = -1;\r\n  while ((current = key.indexOf('.', previous + 1)) >= 0) {\r\n    if (current - previous < 2 || current === last) {\r\n      return false;\r\n    }\r\n    previous = current;\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction isPlainObject(subject: unknown) {\r\n  if (typeof subject === 'object' && subject !== null) {\r\n    const prototype = Object.getPrototypeOf(subject);\r\n    if (prototype === Object.prototype || prototype === null) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction deepSet(context, key, value) {\r\n  const separator = key.indexOf('.');\r\n  if (separator >= 0) {\r\n    const subKey = key.slice(0, separator);\r\n    let subContext = context[subKey];\r\n    if (typeof subContext !== 'object' || subContext === null) {\r\n      const subContextValue = subContext;\r\n      subContext = {};\r\n      if (typeof subContextValue !== 'undefined') {\r\n        subContext[''] = subContextValue;\r\n      }\r\n      context[subKey] = subContext;\r\n    }\r\n    deepSet(subContext, key.slice(separator + 1, key.length), value);\r\n  } else {\r\n    context[key] = value;\r\n  }\r\n}\r\n\r\n/**\r\n * Initial Settings for the repository\r\n */\r\nSettings.getDefaultSettings().set('useCursors', true);\r\n","import {\r\n  ICache,\r\n  IImage,\r\n  IGeometry,\r\n  IImageLoadObject,\r\n  IVolumeLoadObject,\r\n  IGeometryLoadObject,\r\n  ICachedImage,\r\n  ICachedVolume,\r\n  ICachedGeometry,\r\n  EventTypes,\r\n  IImageVolume,\r\n} from '../types';\r\nimport { triggerEvent, imageIdToURI } from '../utilities';\r\nimport eventTarget from '../eventTarget';\r\nimport Events from '../enums/Events';\r\nimport { ImageVolume } from './classes/ImageVolume';\r\n\r\nconst ONE_GB = 1073741824;\r\n\r\n/**\r\n * Stores images, volumes and geometry.\r\n * There are two sizes - the max cache size, that controls the overal maximum\r\n * size, and the instance size, which controls how big any single object can\r\n * be.  Defaults are 3 GB and 2 GB - 8 bytes (just enough to allow allocating it\r\n * without crashing).\r\n * The 3 gb is tuned to the chromium garbage collection cycle to allow image volumes\r\n * to be used/discarded.\r\n */\r\nclass Cache implements ICache {\r\n  // used to store image data (2d)\r\n  private readonly _imageCache = new Map<string, ICachedImage>(); // volatile space\r\n  // used to store volume data (3d)\r\n  private readonly _volumeCache = new Map<string, ICachedVolume>(); // non-volatile space\r\n  // Todo: contour for now, but will be used for surface, etc.\r\n  private readonly _geometryCache: Map<string, ICachedGeometry>;\r\n\r\n  private _imageCacheSize = 0;\r\n  private _volumeCacheSize = 0;\r\n  private _maxCacheSize = 3 * ONE_GB;\r\n  private _maxInstanceSize = 4 * ONE_GB - 8;\r\n\r\n  constructor() {\r\n    // used to store object data (contour, surface, etc.)\r\n    this._geometryCache = new Map();\r\n  }\r\n\r\n  /**\r\n   * Set the maximum cache Size\r\n   *\r\n   * Maximum cache size should be set before adding the data.  If set after,\r\n   * and it is smaller than the current size, will cause issues.\r\n   *\r\n   * @param newMaxCacheSize -  new maximum cache size\r\n   *\r\n   */\r\n  public setMaxCacheSize = (newMaxCacheSize: number): void => {\r\n    if (!newMaxCacheSize || typeof newMaxCacheSize !== 'number') {\r\n      const errorMessage = `New max cacheSize ${this._maxCacheSize} should be defined and should be a number.`;\r\n      throw new Error(errorMessage);\r\n    }\r\n\r\n    this._maxCacheSize = newMaxCacheSize;\r\n  };\r\n\r\n  /**\r\n   * Checks if there is enough space in the cache for requested byte size\r\n   *\r\n   * It returns false, if the sum of volatile (image) cache and unallocated cache\r\n   * is less than the requested byteLength\r\n   *\r\n   * @param byteLength - byte length of requested byte size\r\n   *\r\n   * @returns - boolean indicating if there is enough space in the cache\r\n   */\r\n  public isCacheable = (byteLength: number): boolean => {\r\n    if (byteLength > this._maxInstanceSize) {\r\n      return false;\r\n    }\r\n    const unallocatedSpace = this.getBytesAvailable();\r\n    const imageCacheSize = this._imageCacheSize;\r\n    const availableSpace = unallocatedSpace + imageCacheSize;\r\n\r\n    return availableSpace > byteLength;\r\n  };\r\n\r\n  /**\r\n   * Returns maximum CacheSize allowed\r\n   *\r\n   * @returns maximum allowed cache size\r\n   */\r\n  public getMaxCacheSize = (): number => this._maxCacheSize;\r\n\r\n  /**\r\n   * Returns maximum size of a single instance (volume or single image)\r\n   *\r\n   * @returns maximum instance size\r\n   */\r\n  public getMaxInstanceSize = (): number => this._maxInstanceSize;\r\n\r\n  /**\r\n   * Returns current size of the cache\r\n   *\r\n   * @returns current size of the cache\r\n   */\r\n  public getCacheSize = (): number =>\r\n    this._imageCacheSize + this._volumeCacheSize;\r\n\r\n  /**\r\n   * Returns the unallocated size of the cache\r\n   *\r\n   */\r\n  public getBytesAvailable(): number {\r\n    return this.getMaxCacheSize() - this.getCacheSize();\r\n  }\r\n\r\n  /**\r\n   * Deletes the imageId from the image cache\r\n   *\r\n   * @param imageId - imageId\r\n   *\r\n   */\r\n  private _decacheImage = (imageId: string) => {\r\n    const { imageLoadObject } = this._imageCache.get(imageId);\r\n\r\n    // Cancel any in-progress loading\r\n    if (imageLoadObject.cancelFn) {\r\n      imageLoadObject.cancelFn();\r\n    }\r\n\r\n    if (imageLoadObject.decache) {\r\n      imageLoadObject.decache();\r\n    }\r\n\r\n    this._imageCache.delete(imageId);\r\n  };\r\n\r\n  /**\r\n   * Deletes the volumeId from the volume cache\r\n   *\r\n   * @param volumeId - volumeId\r\n   *\r\n   */\r\n  private _decacheVolume = (volumeId: string) => {\r\n    const cachedVolume = this._volumeCache.get(volumeId);\r\n    const { volumeLoadObject, volume } = cachedVolume;\r\n\r\n    if (volume.cancelLoading) {\r\n      volume.cancelLoading();\r\n    }\r\n\r\n    if (volume.imageData) {\r\n      volume.imageData.delete();\r\n    }\r\n\r\n    // if we had views for the images of the volume, we need to restore them\r\n    // to avoid memory leaks\r\n    this._restoreImagesFromBuffer(volume);\r\n\r\n    if (volumeLoadObject.cancelFn) {\r\n      // Cancel any in-progress loading\r\n      volumeLoadObject.cancelFn();\r\n    }\r\n\r\n    if (volumeLoadObject.decache) {\r\n      volumeLoadObject.decache();\r\n    }\r\n\r\n    this._volumeCache.delete(volumeId);\r\n  };\r\n\r\n  /**\r\n   * Deletes all the images and volumes in the cache\r\n   *\r\n   * Relevant events are fired for each decached image (IMAGE_CACHE_IMAGE_REMOVED) and\r\n   * the decached volume (VOLUME_CACHE_VOLUME_REMOVED).\r\n   *\r\n   * @fires Events.IMAGE_CACHE_IMAGE_REMOVED\r\n   * @fires Events.VOLUME_CACHE_VOLUME_REMOVED\r\n   *\r\n   */\r\n  public purgeCache = (): void => {\r\n    const imageIterator = this._imageCache.keys();\r\n\r\n    /* eslint-disable no-constant-condition */\r\n    while (true) {\r\n      const { value: imageId, done } = imageIterator.next();\r\n\r\n      if (done) {\r\n        break;\r\n      }\r\n\r\n      this.removeImageLoadObject(imageId);\r\n\r\n      triggerEvent(eventTarget, Events.IMAGE_CACHE_IMAGE_REMOVED, { imageId });\r\n    }\r\n\r\n    this.purgeVolumeCache();\r\n  };\r\n\r\n  /**\r\n   * Deletes all the volumes in the cache\r\n   */\r\n  public purgeVolumeCache = (): void => {\r\n    const volumeIterator = this._volumeCache.keys();\r\n\r\n    /* eslint-disable no-constant-condition */\r\n    while (true) {\r\n      const { value: volumeId, done } = volumeIterator.next();\r\n\r\n      if (done) {\r\n        break;\r\n      }\r\n\r\n      this.removeVolumeLoadObject(volumeId);\r\n\r\n      triggerEvent(eventTarget, Events.VOLUME_CACHE_VOLUME_REMOVED, {\r\n        volumeId,\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Purges the cache if necessary based on the requested number of bytes\r\n   *\r\n   * 1) it sorts the volatile (image) cache based on the most recent used images\r\n   * and starts purging from the oldest ones.\r\n   * Note: for a volume, if the volume-related image Ids is provided, it starts\r\n   * by purging the none-related image Ids (those that are not related to the\r\n   * current volume)\r\n   * 2) For a volume, if we purge all images that won't be included in this volume and still\r\n   * don't have enough unallocated space, purge images that will be included\r\n   * in this volume until we have enough space. These will need to be\r\n   * re-fetched, but we must do this not to straddle over the given memory\r\n   * limit, even for a short time, as this may crash the application.\r\n   *\r\n   * @fires Events.IMAGE_CACHE_IMAGE_REMOVED\r\n   *\r\n   * @param numBytes - Number of bytes for the image/volume that is\r\n   * going to be stored inside the cache\r\n   * @param volumeImageIds - list of imageIds that correspond to the\r\n   * volume whose numberOfBytes we want to store in the cache.\r\n   * @returns bytesAvailable or undefined in purging cache\r\n   * does not successfully make enough space for the requested number of bytes\r\n   */\r\n  public decacheIfNecessaryUntilBytesAvailable(\r\n    numBytes: number,\r\n    volumeImageIds?: Array<string>\r\n  ): number | undefined {\r\n    let bytesAvailable = this.getBytesAvailable();\r\n\r\n    // If max cache size has not been exceeded, do nothing\r\n    if (bytesAvailable >= numBytes) {\r\n      return bytesAvailable;\r\n    }\r\n\r\n    let cachedImages = Array.from(this._imageCache.values());\r\n\r\n    // Cache size has been exceeded, create list of images sorted by timeStamp\r\n    // So we can purge the least recently used image\r\n    function compare(a, b) {\r\n      if (a.timeStamp > b.timeStamp) {\r\n        return 1;\r\n      }\r\n      if (a.timeStamp < b.timeStamp) {\r\n        return -1;\r\n      }\r\n\r\n      return 0;\r\n    }\r\n\r\n    cachedImages.sort(compare);\r\n    let cachedImageIds = cachedImages.map((im) => im.imageId);\r\n\r\n    let imageIdsToPurge = cachedImageIds;\r\n\r\n    // if we are making space for a volume, we start by purging the imageIds\r\n    // that are not related to the volume\r\n    if (volumeImageIds) {\r\n      imageIdsToPurge = cachedImageIds.filter(\r\n        (id) => !volumeImageIds.includes(id)\r\n      );\r\n    }\r\n\r\n    // Remove images (that are not related to the volume) from volatile cache\r\n    // until the requested number of bytes become available\r\n    for (const imageId of imageIdsToPurge) {\r\n      this.removeImageLoadObject(imageId);\r\n\r\n      triggerEvent(eventTarget, Events.IMAGE_CACHE_IMAGE_REMOVED, { imageId });\r\n\r\n      bytesAvailable = this.getBytesAvailable();\r\n      if (bytesAvailable >= numBytes) {\r\n        return bytesAvailable;\r\n      }\r\n    }\r\n\r\n    // Remove the imageIds (both volume related and not related)\r\n    cachedImages = Array.from(this._imageCache.values());\r\n    cachedImageIds = cachedImages.map((im) => im.imageId);\r\n\r\n    // Remove volume-image Ids from volatile cache until the requested number of bytes\r\n    // become available\r\n    for (const imageId of cachedImageIds) {\r\n      this.removeImageLoadObject(imageId);\r\n\r\n      triggerEvent(eventTarget, Events.IMAGE_CACHE_IMAGE_REMOVED, { imageId });\r\n\r\n      bytesAvailable = this.getBytesAvailable();\r\n      if (bytesAvailable >= numBytes) {\r\n        return bytesAvailable;\r\n      }\r\n    }\r\n\r\n    // Technically we should not reach here, since isCacheable will throw an\r\n    // error if unallocated + volatile (image) cache cannot fit the upcoming\r\n    // number of bytes\r\n  }\r\n\r\n  /**\r\n   * Puts a new image load object into the cache\r\n   *\r\n   * First, it creates a CachedImage object and put it inside the imageCache for\r\n   * the imageId. After the imageLoadObject promise resolves to an image,\r\n   * it: 1) adds the image into the correct CachedImage object 2) increments the\r\n   * cache size, 3) triggers IMAGE_CACHE_IMAGE_ADDED  4) Purge the cache if\r\n   * necessary -- if the cache size is greater than the maximum cache size, it\r\n   * iterates over the imageCache and decache them one by one until the cache\r\n   * size becomes less than the maximum allowed cache size\r\n   *\r\n   * @fires Events.IMAGE_CACHE_IMAGE_ADDED\r\n   * @fires Events.CACHE_SIZE_EXCEEDED if the cache size exceeds the maximum\r\n   *\r\n   * @param imageId - ImageId for the image\r\n   * @param imageLoadObject - The object that is loading or loaded the image\r\n   */\r\n  public putImageLoadObject(\r\n    imageId: string,\r\n    imageLoadObject: IImageLoadObject\r\n  ): Promise<any> {\r\n    if (imageId === undefined) {\r\n      throw new Error('putImageLoadObject: imageId must not be undefined');\r\n    }\r\n\r\n    if (imageLoadObject.promise === undefined) {\r\n      throw new Error(\r\n        'putImageLoadObject: imageLoadObject.promise must not be undefined'\r\n      );\r\n    }\r\n\r\n    if (this._imageCache.has(imageId)) {\r\n      throw new Error('putImageLoadObject: imageId already in cache');\r\n    }\r\n\r\n    if (\r\n      imageLoadObject.cancelFn &&\r\n      typeof imageLoadObject.cancelFn !== 'function'\r\n    ) {\r\n      throw new Error(\r\n        'putImageLoadObject: imageLoadObject.cancel must be a function'\r\n      );\r\n    }\r\n\r\n    const cachedImage: ICachedImage = {\r\n      loaded: false,\r\n      imageId,\r\n      sharedCacheKey: undefined, // The sharedCacheKey for this imageId.  undefined by default\r\n      imageLoadObject,\r\n      timeStamp: Date.now(),\r\n      sizeInBytes: 0,\r\n    };\r\n\r\n    this._imageCache.set(imageId, cachedImage);\r\n\r\n    return imageLoadObject.promise\r\n      .then((image: IImage) => {\r\n        if (!this._imageCache.get(imageId)) {\r\n          // If the image has been purged before being loaded, we stop here.\r\n          console.warn(\r\n            'The image was purged from the cache before it completed loading.'\r\n          );\r\n          return;\r\n        }\r\n\r\n        if (\r\n          image.sizeInBytes === undefined ||\r\n          Number.isNaN(image.sizeInBytes)\r\n        ) {\r\n          throw new Error(\r\n            'putImageLoadObject: image.sizeInBytes must not be undefined'\r\n          );\r\n        }\r\n        if (image.sizeInBytes.toFixed === undefined) {\r\n          throw new Error(\r\n            'putImageLoadObject: image.sizeInBytes is not a number'\r\n          );\r\n        }\r\n\r\n        // check if there is enough space in unallocated + image Cache\r\n        if (!this.isCacheable(image.sizeInBytes)) {\r\n          throw new Error(Events.CACHE_SIZE_EXCEEDED);\r\n        }\r\n\r\n        // if there is, decache if necessary\r\n        this.decacheIfNecessaryUntilBytesAvailable(image.sizeInBytes);\r\n\r\n        cachedImage.loaded = true;\r\n        cachedImage.image = image;\r\n        cachedImage.sizeInBytes = image.sizeInBytes;\r\n        this.incrementImageCacheSize(cachedImage.sizeInBytes);\r\n        const eventDetails: EventTypes.ImageCacheImageAddedEventDetail = {\r\n          image: cachedImage,\r\n        };\r\n\r\n        triggerEvent(eventTarget, Events.IMAGE_CACHE_IMAGE_ADDED, eventDetails);\r\n\r\n        cachedImage.sharedCacheKey = image.sharedCacheKey;\r\n      })\r\n      .catch((error) => {\r\n        // console.warn(error)\r\n        this._imageCache.delete(imageId);\r\n        throw error;\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Returns the object that is loading a given imageId\r\n   *\r\n   * @param imageId - Image ID\r\n   * @returns IImageLoadObject\r\n   */\r\n  public getImageLoadObject(imageId: string): IImageLoadObject {\r\n    if (imageId === undefined) {\r\n      throw new Error('getImageLoadObject: imageId must not be undefined');\r\n    }\r\n    const cachedImage = this._imageCache.get(imageId);\r\n\r\n    if (cachedImage === undefined) {\r\n      return;\r\n    }\r\n\r\n    // Bump time stamp for cached image\r\n    cachedImage.timeStamp = Date.now();\r\n\r\n    return cachedImage.imageLoadObject;\r\n  }\r\n\r\n  /**\r\n   * It checks the imageCache for the provided imageId, and returns true\r\n   * if the image is loaded, false otherwise. Note, this only checks the imageCache\r\n   * and does not check the volume cache.\r\n   * @param imageId - image Id to check\r\n   * @returns boolean\r\n   */\r\n  public isLoaded(imageId: string): boolean {\r\n    const cachedImage = this._imageCache.get(imageId);\r\n\r\n    if (!cachedImage) {\r\n      return false;\r\n    }\r\n\r\n    return cachedImage.loaded;\r\n  }\r\n\r\n  /**\r\n   * Returns the volume that contains the requested imageId. It will check the\r\n   * imageIds inside the volume to find a match.\r\n   *\r\n   * @param imageId - ImageId\r\n   * @returns - Volume object\r\n   */\r\n  public getVolumeContainingImageId(imageId: string): {\r\n    volume: IImageVolume;\r\n    imageIdIndex: number;\r\n  } {\r\n    const volumeIds = Array.from(this._volumeCache.keys());\r\n    const imageIdToUse = imageIdToURI(imageId);\r\n\r\n    for (const volumeId of volumeIds) {\r\n      const cachedVolume = this._volumeCache.get(volumeId);\r\n      const { volume } = cachedVolume;\r\n\r\n      if (!volume?.imageIds?.length) {\r\n        return;\r\n      }\r\n\r\n      const imageIdIndex = volume.getImageURIIndex(imageIdToUse);\r\n\r\n      if (imageIdIndex > -1) {\r\n        return { volume, imageIdIndex };\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the cached image from the imageCache for the requested imageId.\r\n   * It first strips the imageId to remove the data loading scheme.\r\n   *\r\n   * @param imageId - Image ID\r\n   * @returns cached image\r\n   */\r\n  public getCachedImageBasedOnImageURI(\r\n    imageId: string\r\n  ): ICachedImage | undefined {\r\n    const imageURIToUse = imageIdToURI(imageId);\r\n\r\n    const cachedImageIds = Array.from(this._imageCache.keys());\r\n    const foundImageId = cachedImageIds.find((imageId) => {\r\n      return imageIdToURI(imageId) === imageURIToUse;\r\n    });\r\n\r\n    if (!foundImageId) {\r\n      return;\r\n    }\r\n\r\n    return this._imageCache.get(foundImageId);\r\n  }\r\n  /**\r\n   * Puts a new image load object into the cache\r\n   *\r\n   * First, it creates a CachedVolume object and put it inside the volumeCache for\r\n   * the volumeId. After the volumeLoadObject promise resolves to a volume,\r\n   * it: 1) adds the volume into the correct CachedVolume object inside volumeCache\r\n   * 2) increments the cache size, 3) triggers VOLUME_CACHE_VOLUME_ADDED  4) Purge\r\n   * the cache if necessary -- if the cache size is greater than the maximum cache size, it\r\n   * iterates over the imageCache (not volumeCache) and decache them one by one\r\n   * until the cache size becomes less than the maximum allowed cache size\r\n   *\r\n   * @fires Events.VOLUME_CACHE_VOLUME_ADDED\r\n   *\r\n   * @param volumeId - volumeId of the volume\r\n   * @param volumeLoadObject - The object that is loading or loaded the volume\r\n   */\r\n  public putVolumeLoadObject(\r\n    volumeId: string,\r\n    volumeLoadObject: IVolumeLoadObject\r\n  ): Promise<any> {\r\n    if (volumeId === undefined) {\r\n      throw new Error('putVolumeLoadObject: volumeId must not be undefined');\r\n    }\r\n    if (volumeLoadObject.promise === undefined) {\r\n      throw new Error(\r\n        'putVolumeLoadObject: volumeLoadObject.promise must not be undefined'\r\n      );\r\n    }\r\n    if (this._volumeCache.has(volumeId)) {\r\n      throw new Error(\r\n        `putVolumeLoadObject: volumeId:${volumeId} already in cache`\r\n      );\r\n    }\r\n    if (\r\n      volumeLoadObject.cancelFn &&\r\n      typeof volumeLoadObject.cancelFn !== 'function'\r\n    ) {\r\n      throw new Error(\r\n        'putVolumeLoadObject: volumeLoadObject.cancel must be a function'\r\n      );\r\n    }\r\n\r\n    // todo: @Erik there are two loaded flags, one inside cachedVolume and the other\r\n    // inside the volume.loadStatus.loaded, the actual all pixelData loaded is the\r\n    // loadStatus one. This causes confusion\r\n    const cachedVolume: ICachedVolume = {\r\n      loaded: false,\r\n      volumeId,\r\n      volumeLoadObject,\r\n      timeStamp: Date.now(),\r\n      sizeInBytes: 0,\r\n    };\r\n\r\n    this._volumeCache.set(volumeId, cachedVolume);\r\n\r\n    return volumeLoadObject.promise\r\n      .then((volume: IImageVolume) => {\r\n        if (!this._volumeCache.get(volumeId)) {\r\n          // If the image has been purged before being loaded, we stop here.\r\n          console.warn(\r\n            'The image was purged from the cache before it completed loading.'\r\n          );\r\n          return;\r\n        }\r\n\r\n        if (Number.isNaN(volume.sizeInBytes)) {\r\n          throw new Error(\r\n            'putVolumeLoadObject: volume.sizeInBytes must not be undefined'\r\n          );\r\n        }\r\n        if (volume.sizeInBytes.toFixed === undefined) {\r\n          throw new Error(\r\n            'putVolumeLoadObject: volume.sizeInBytes is not a number'\r\n          );\r\n        }\r\n\r\n        // this.isCacheable is called at the volume loader, before requesting\r\n        // the images of the volume\r\n\r\n        this.decacheIfNecessaryUntilBytesAvailable(\r\n          volume.sizeInBytes,\r\n          // @ts-ignore: // todo ImageVolume does not have imageIds\r\n          volume.imageIds\r\n        );\r\n\r\n        // cachedVolume.loaded = true\r\n        cachedVolume.volume = volume;\r\n        cachedVolume.sizeInBytes = volume.sizeInBytes;\r\n        this.incrementVolumeCacheSize(cachedVolume.sizeInBytes);\r\n\r\n        const eventDetails: EventTypes.VolumeCacheVolumeAddedEventDetail = {\r\n          volume: cachedVolume,\r\n        };\r\n\r\n        triggerEvent(\r\n          eventTarget,\r\n          Events.VOLUME_CACHE_VOLUME_ADDED,\r\n          eventDetails\r\n        );\r\n      })\r\n      .catch((error) => {\r\n        this._volumeCache.delete(volumeId);\r\n        throw error;\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Returns the object that is loading a given volumeId\r\n   *\r\n   * @param volumeId - Volume ID\r\n   * @returns IVolumeLoadObject\r\n   */\r\n  public getVolumeLoadObject = (volumeId: string): IVolumeLoadObject => {\r\n    if (volumeId === undefined) {\r\n      throw new Error('getVolumeLoadObject: volumeId must not be undefined');\r\n    }\r\n    const cachedVolume = this._volumeCache.get(volumeId);\r\n\r\n    if (cachedVolume === undefined) {\r\n      return;\r\n    }\r\n\r\n    // Bump time stamp for cached volume (not used for anything for now)\r\n    cachedVolume.timeStamp = Date.now();\r\n\r\n    return cachedVolume.volumeLoadObject;\r\n  };\r\n\r\n  public getGeometry = (geometryId: string): IGeometry => {\r\n    if (geometryId == null) {\r\n      throw new Error('getGeometry: geometryId must not be undefined');\r\n    }\r\n\r\n    const cachedGeometry = this._geometryCache.get(geometryId);\r\n\r\n    if (cachedGeometry === undefined) {\r\n      return;\r\n    }\r\n\r\n    // Bump time stamp for cached geometry (not used for anything for now)\r\n    cachedGeometry.timeStamp = Date.now();\r\n\r\n    return cachedGeometry.geometry;\r\n  };\r\n\r\n  /**\r\n   * Returns the image associated with the imageId\r\n   *\r\n   * @param imageId - image ID\r\n   * @returns Image\r\n   */\r\n  public getImage = (imageId: string): IImage => {\r\n    if (imageId === undefined) {\r\n      throw new Error('getImage: imageId must not be undefined');\r\n    }\r\n    const cachedImage = this._imageCache.get(imageId);\r\n\r\n    if (cachedImage === undefined) {\r\n      return;\r\n    }\r\n\r\n    // Bump time stamp for cached volume (not used for anything for now)\r\n    cachedImage.timeStamp = Date.now();\r\n\r\n    return cachedImage.image;\r\n  };\r\n\r\n  /**\r\n   * Returns the volume associated with the volumeId\r\n   *\r\n   * @param volumeId - Volume ID\r\n   * @returns Volume\r\n   */\r\n  public getVolume = (volumeId: string): IImageVolume => {\r\n    if (volumeId === undefined) {\r\n      throw new Error('getVolume: volumeId must not be undefined');\r\n    }\r\n    const cachedVolume = this._volumeCache.get(volumeId);\r\n\r\n    if (cachedVolume === undefined) {\r\n      return;\r\n    }\r\n\r\n    // Bump time stamp for cached volume (not used for anything for now)\r\n    cachedVolume.timeStamp = Date.now();\r\n\r\n    return cachedVolume.volume;\r\n  };\r\n\r\n  /**\r\n   * Retrieves an array of image volumes from the cache.\r\n   * @returns An array of image volumes.\r\n   */\r\n  public getVolumes = (): Array<IImageVolume> => {\r\n    const cachedVolumes = Array.from(this._volumeCache.values());\r\n\r\n    return cachedVolumes.map((cachedVolume) => cachedVolume.volume);\r\n  };\r\n\r\n  /**\r\n   * Filters the cached volumes by the specified reference volume ID.\r\n   * @param volumeId - The ID of the reference volume.\r\n   * @returns An array of image volumes that have the specified reference volume ID.\r\n   */\r\n  public filterVolumesByReferenceId = (\r\n    volumeId: string\r\n  ): Array<IImageVolume> => {\r\n    const cachedVolumes = this.getVolumes();\r\n\r\n    return cachedVolumes.filter((volume) => {\r\n      return volume.referencedVolumeId === volumeId;\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Removes the image loader associated with a given Id from the cache\r\n   *\r\n   * It increases the cache size after removing the image.\r\n   *\r\n   * @fires Events.IMAGE_CACHE_IMAGE_REMOVED\r\n   *\r\n   * @param imageId - Image ID\r\n   */\r\n  public removeImageLoadObject = (imageId: string): void => {\r\n    if (imageId === undefined) {\r\n      throw new Error('removeImageLoadObject: imageId must not be undefined');\r\n    }\r\n    const cachedImage = this._imageCache.get(imageId);\r\n\r\n    if (cachedImage === undefined) {\r\n      throw new Error(\r\n        'removeImageLoadObject: imageId was not present in imageCache'\r\n      );\r\n    }\r\n\r\n    this.incrementImageCacheSize(-cachedImage.sizeInBytes);\r\n\r\n    const eventDetails = {\r\n      image: cachedImage,\r\n      imageId,\r\n    };\r\n\r\n    triggerEvent(eventTarget, Events.IMAGE_CACHE_IMAGE_REMOVED, eventDetails);\r\n    this._decacheImage(imageId);\r\n  };\r\n\r\n  /**\r\n   * Removes the volume loader associated with a given Id from the cache\r\n   *\r\n   * It increases the cache size after removing the image.\r\n   *\r\n   * @fires Events.VOLUME_CACHE_VOLUME_REMOVED\r\n   *\r\n   * @param imageId - ImageId\r\n   */\r\n  public removeVolumeLoadObject = (volumeId: string): void => {\r\n    if (volumeId === undefined) {\r\n      throw new Error('removeVolumeLoadObject: volumeId must not be undefined');\r\n    }\r\n    const cachedVolume = this._volumeCache.get(volumeId);\r\n\r\n    if (cachedVolume === undefined) {\r\n      throw new Error(\r\n        'removeVolumeLoadObject: volumeId was not present in volumeCache'\r\n      );\r\n    }\r\n\r\n    this.incrementVolumeCacheSize(-cachedVolume.sizeInBytes);\r\n\r\n    const eventDetails = {\r\n      volume: cachedVolume,\r\n      volumeId,\r\n    };\r\n\r\n    triggerEvent(eventTarget, Events.VOLUME_CACHE_VOLUME_REMOVED, eventDetails);\r\n    this._decacheVolume(volumeId);\r\n  };\r\n\r\n  putGeometryLoadObject = (\r\n    geometryId: string,\r\n    geometryLoadObject: IGeometryLoadObject\r\n  ): Promise<void> => {\r\n    if (geometryId == undefined) {\r\n      throw new Error(\r\n        'putGeometryLoadObject: geometryId must not be undefined'\r\n      );\r\n    }\r\n\r\n    if (this._geometryCache.has(geometryId)) {\r\n      throw new Error(\r\n        'putGeometryLoadObject: geometryId already present in geometryCache'\r\n      );\r\n    }\r\n\r\n    const cachedGeometry: ICachedGeometry = {\r\n      geometryId,\r\n      geometryLoadObject,\r\n      loaded: false,\r\n      timeStamp: Date.now(),\r\n      sizeInBytes: 0,\r\n    };\r\n\r\n    this._geometryCache.set(geometryId, cachedGeometry);\r\n\r\n    return geometryLoadObject.promise\r\n      .then((geometry: IGeometry) => {\r\n        if (!this._geometryCache.has(geometryId)) {\r\n          console.warn(\r\n            'putGeometryLoadObject: geometryId was removed from geometryCache'\r\n          );\r\n          return;\r\n        }\r\n\r\n        if (Number.isNaN(geometry.sizeInBytes)) {\r\n          throw new Error(\r\n            'putGeometryLoadObject: geometry.sizeInBytes is not a number'\r\n          );\r\n        }\r\n\r\n        // Todo: fix is cacheable\r\n\r\n        cachedGeometry.loaded = true;\r\n        cachedGeometry.geometry = geometry;\r\n        cachedGeometry.sizeInBytes = geometry.sizeInBytes;\r\n\r\n        // this._incrementGeometryCacheSize(geometry.sizeInBytes);\r\n\r\n        const eventDetails = {\r\n          geometry,\r\n          geometryId,\r\n        };\r\n\r\n        triggerEvent(\r\n          eventTarget,\r\n          Events.GEOMETRY_CACHE_GEOMETRY_ADDED,\r\n          eventDetails\r\n        );\r\n\r\n        return;\r\n      })\r\n      .catch((error) => {\r\n        this._geometryCache.delete(geometryId);\r\n        throw error;\r\n      });\r\n  };\r\n\r\n  /**\r\n   * Increases the image cache size with the provided increment\r\n   *\r\n   * @param increment - bytes length\r\n   */\r\n  public incrementImageCacheSize = (increment: number) => {\r\n    this._imageCacheSize += increment;\r\n  };\r\n\r\n  /**\r\n   * Increases the cache size with the provided increment\r\n   *\r\n   * @param increment - bytes length\r\n   */\r\n  public incrementVolumeCacheSize = (increment: number) => {\r\n    this._volumeCacheSize += increment;\r\n  };\r\n\r\n  /**\r\n   * Decreases the image cache size with the provided decrement\r\n   *\r\n   * @param decrement - bytes length\r\n   */\r\n  public decrementImageCacheSize = (decrement: number) => {\r\n    this._imageCacheSize -= decrement;\r\n  };\r\n\r\n  /**\r\n   * Decreases the cache size with the provided decrement\r\n   *\r\n   * @param decrement - bytes length\r\n   */\r\n  public decrementVolumeCacheSize = (decrement: number) => {\r\n    this._volumeCacheSize -= decrement;\r\n  };\r\n\r\n  /**\r\n   * This function will restore the images' pixel data from the shared array buffer\r\n   * back to the individual images when the volume is purged from cache. It ensures\r\n   * that each image retrieves its correct portion of data from the buffer based on\r\n   * the previously stored offset and length information.\r\n   *\r\n   * @param volumeId - The volumeId whose images need to be restored.\r\n   */\r\n  private _restoreImagesFromBuffer(volume: IImageVolume) {\r\n    if (!(volume instanceof ImageVolume)) {\r\n      console.warn(\r\n        'Volume is not an ImageVolume. Cannot restore images from buffer.'\r\n      );\r\n      return;\r\n    }\r\n\r\n    // Retrieve the scalar data and the offset map from the volume\r\n    const scalarData = volume.getScalarData();\r\n    const imageCacheOffsetMap = volume.imageCacheOffsetMap;\r\n\r\n    if (imageCacheOffsetMap.size === 0) {\r\n      // This happens during testing and isn't an issue\r\n      // console.warn('No cached images to restore for this volume.');\r\n      return;\r\n    }\r\n\r\n    // Iterate over each image and restore its pixel data from the shared buffer\r\n    for (const [imageId, { offset }] of imageCacheOffsetMap) {\r\n      const image = this.getImage(imageId);\r\n\r\n      if (!image) {\r\n        console.warn(`Image with id ${imageId} not found in cache.`);\r\n        continue;\r\n      }\r\n\r\n      const viewPixelData = image.getPixelData();\r\n      const length = viewPixelData.length;\r\n\r\n      // Create a new view of the buffer for this specific image\r\n      // @ts-ignore\r\n      const pixelData = new viewPixelData.constructor(\r\n        scalarData.buffer,\r\n        offset,\r\n        length\r\n      );\r\n\r\n      // Restore the original getPixelData function and pixelData\r\n      image.getPixelData = () => pixelData;\r\n\r\n      if (image.imageFrame) {\r\n        image.imageFrame.pixelData = pixelData;\r\n      }\r\n\r\n      delete image.bufferView;\r\n\r\n      // Optionally, increment the image cache size again if needed\r\n      this.incrementImageCacheSize(image.sizeInBytes);\r\n    }\r\n\r\n    console.log(`Images restored from buffer for volume ${volume.volumeId}.`);\r\n  }\r\n}\r\n\r\n/**\r\n * This module deals with Caching of images and volumes\r\n * The cache has two main components: a volatile portion for images and a\r\n * non-volatile portion for volumes. Individual 2D images are volatile and\r\n * will be replaced by new images hitting the cache. When you allocate volumes,\r\n * these are non-volatile and reserve a block of memory from the cache.\r\n * Volumes must be released manually.\r\n * We will have a shared block of memory allocated for the entire cache, e.g. 1GB\r\n * which will be shared for images and volumes.\r\n *\r\n * **When a new image is added:**\r\n * We check if there is enough unallocated + volatile space for the single image\r\n *\r\n * if so\r\n * - We allocate the image in image cache, and if necessary oldest images\r\n * are decached to match the maximumCacheSize criteria\r\n * - If a volume contains that imageId, copy it over using TypedArray's set method.\r\n * If no volumes contain the imageId, the image is fetched by image loaders\r\n *\r\n * If not (cache is mostly/completely full with volumes)\r\n * - throw that the cache does not have enough working space to allocate the image\r\n *\r\n *\r\n * **When a new volume is added:**\r\n * Check if there is enough unallocated + volatile space to allocate the volume:\r\n *\r\n * If so:\r\n * - Decache oldest images which won't be included in this volume until\r\n * we have enough free space for the volume\r\n * - If not enough space from previous space, decache images that will be included\r\n * in the volume until we have enough free space (These will need to be re-fetched,\r\n * but we must do this not to straddle over the given memory limit, even for a\r\n * short time, as this may crash the app)\r\n * - At this point, if any of the frames (indexed by imageId) are present in the volatile\r\n * image cache, copy these over to the volume now\r\n *\r\n * If not (cache is mostly/completely full with volumes),\r\n * - throw that the cache does not have enough working space to allocate the volume.\r\n *\r\n */\r\nconst cache = new Cache();\r\nexport default cache;\r\nexport { Cache }; // for documentation\r\n","const EPSILON = 1e-3;\r\n\r\nexport default EPSILON;\r\n","const RENDERING_DEFAULTS = {\r\n  MINIMUM_SLAB_THICKNESS: 5e-2,\r\n  MAXIMUM_RAY_DISTANCE: 1e6,\r\n};\r\n\r\nObject.freeze(RENDERING_DEFAULTS);\r\n\r\nexport default RENDERING_DEFAULTS;\r\n","/**\r\n * Request types for requesting images from the imageLoadPoolManager\r\n */\r\nenum RequestType {\r\n  /** Highest priority for loading*/\r\n  Interaction = 'interaction',\r\n  /** Second highest priority for loading*/\r\n  Thumbnail = 'thumbnail',\r\n  /** Third highest priority for loading, usually used for image loading in the background*/\r\n  Prefetch = 'prefetch',\r\n  /** Lower priority, often used for background computations in the worker */\r\n  Compute = 'compute',\r\n}\r\n\r\nexport default RequestType;\r\n","enum ViewportStatus {\r\n  /** Initial state before any volumes or stacks are available*/\r\n  NO_DATA = 'noData',\r\n  /** Stack/volumes are available but are in progress */\r\n  LOADING = 'loading',\r\n  /** Ready to be rendered */\r\n  PRE_RENDER = 'preRender',\r\n  /** In the midst of a resize */\r\n  RESIZE = 'resize',\r\n  /** Rendered image data */\r\n  RENDERED = 'rendered',\r\n}\r\n\r\nexport default ViewportStatus;\r\n","import vtkConstants from '@kitware/vtk.js/Rendering/Core/VolumeMapper/Constants';\r\n\r\nconst { BlendMode } = vtkConstants;\r\n\r\n/**\r\n * Enums for blendModes for viewport images based on vtk.js\r\n *\r\n * It should be noted that if crosshairs are enabled and can modify the slab thickness,\r\n * then it will not show any difference unless MAXIMUM_INTENSITY_BLEND is set on the viewport\r\n * as the blend.\r\n */\r\nenum BlendModes {\r\n  /** composite blending - suitable for compositing multiple images */\r\n  COMPOSITE = BlendMode.COMPOSITE_BLEND,\r\n  /** maximum intensity projection */\r\n  MAXIMUM_INTENSITY_BLEND = BlendMode.MAXIMUM_INTENSITY_BLEND,\r\n  /** minimum intensity projection */\r\n  MINIMUM_INTENSITY_BLEND = BlendMode.MINIMUM_INTENSITY_BLEND,\r\n  /** average intensity projection */\r\n  AVERAGE_INTENSITY_BLEND = BlendMode.AVERAGE_INTENSITY_BLEND,\r\n}\r\n\r\nexport default BlendModes;\r\n","enum GeometryType {\r\n  CONTOUR = 'contour',\r\n  SURFACE = 'Surface',\r\n}\r\n\r\nexport default GeometryType;\r\n","/**\r\n * DynamicOperatorType enum for cornerstone-render which defines the operator to use for generateImageFromTimeData.\r\n * It can be either SUM, AVERAGE or SUBTRACT.\r\n */\r\nenum DynamicOperatorType {\r\n  /** For summing the time frames. */\r\n  SUM = 'SUM',\r\n  /** For averaging the time frames. */\r\n  AVERAGE = 'AVERAGE',\r\n  /** For subtracting two time frames */\r\n  SUBTRACT = 'SUBTRACT',\r\n}\r\n\r\nexport default DynamicOperatorType;\r\n","/**\r\n * Defines the calibration types available.  These define how the units\r\n * for measurements are specified.\r\n */\r\nexport enum CalibrationTypes {\r\n  /**\r\n   * Not applicable means the units are directly defind by the underlying\r\n   * hardware, such as CT and MR volumetric displays, so no special handling\r\n   * or notification is required.\r\n   */\r\n  NOT_APPLICABLE = '',\r\n  /**\r\n   * ERMF is estimated radiographic magnification factor.  This defines how\r\n   * much the image is magnified at the detector as opposed to the location in\r\n   * the body of interest.  This occurs because the radiation beam is expanding\r\n   * and effectively magnifies the image on the detector compared to where the\r\n   * point of interest in the body is.\r\n   * This suggests that measurements can be partially trusted, but the user\r\n   * still needs to be aware that different depths within the body have differing\r\n   * ERMF values, so precise measurements would still need to be manually calibrated.\r\n   */\r\n  ERMF = 'ERMF',\r\n  /**\r\n   * User calibration means that the user has provided a custom calibration\r\n   * specifying how large the image data is.  This type can occur on\r\n   * volumetric images, eg for scout images that might have invalid spacing\r\n   * tags.\r\n   */\r\n  USER = 'User',\r\n  /**\r\n   * A projection calibration means the raw detector size, without any\r\n   * ERMF applied, meaning that the size in the body cannot be trusted and\r\n   * that a calibration should be applied.\r\n   * This is different from Error in that there is simply no magnification\r\n   * factor applied as opposed to having multiple, inconsistent magnification\r\n   * factors.\r\n   */\r\n  PROJECTION = 'Proj',\r\n  /**\r\n   * A region calibration is used for other types of images, typically\r\n   * ultrasouunds where the distance in the image may mean something other than\r\n   * physical distance, such as mV or Hz or some other measurement values.\r\n   */\r\n  REGION = 'Region',\r\n  /**\r\n   * Error is used to define mismatches between various units, such as when\r\n   * there are two different ERMF values specified.  This is an indication to\r\n   * NOT trust the measurement values but to manually calibrate.\r\n   */\r\n  ERROR = 'Error',\r\n  /** Uncalibrated image */\r\n  UNCALIBRATED = 'Uncalibrated',\r\n}\r\n\r\nexport default CalibrationTypes;\r\n","import getRenderingEngine, {\r\n  getRenderingEngines,\r\n} from './RenderingEngine/getRenderingEngine';\r\nimport { IEnabledElement, IStackViewport, IVolumeViewport } from './types';\r\n\r\n/**\r\n * A convenience method to find an EnabledElement given a reference to its\r\n * associated element. Commonly used in code that's handling a custom\r\n * event emitted by this library.\r\n *\r\n * @example\r\n * Using the renderingEngine to find the enabled element:\r\n * ```javascript\r\n * const element = getRenderingEngine(renderingEngineId)\r\n *    .getViewport(viewportId)\r\n *    .element\r\n *\r\n * const enabledElement = getEnabledElement(element)\r\n * ```\r\n *\r\n * @example\r\n * Using a cornerstone event's \"element\"\r\n * ```javascript\r\n * // Our \"cornerstone events\" contain the source element, which is\r\n * // raised on the viewport's div element\r\n * const { element } = evt.detail\r\n * const enabledElement = getEnabledElement(element)\r\n * ```\r\n *\r\n * @param element - a reference to an EnabledElement/Viewport's div element\r\n * @returns the associated EnabledElement, or undefined if no matching EnabledElement\r\n * can be found\r\n */\r\nexport default function getEnabledElement(\r\n  element: HTMLDivElement | undefined\r\n): IEnabledElement | undefined {\r\n  if (!element) {\r\n    return;\r\n  }\r\n\r\n  const { viewportUid, renderingEngineUid } = element.dataset;\r\n\r\n  return getEnabledElementByIds(viewportUid, renderingEngineUid);\r\n}\r\n\r\n/**\r\n * Similar to {@link getEnabledElement}, but takes the IDs of the\r\n * renderingEngine and viewport as parameters to return the associated\r\n * EnabledElement.\r\n *\r\n * @param viewportId - The Id of the viewport\r\n * @param renderingEngineId - The Id of the rendering engine.\r\n * @returns The enabled element which is an object that contains the viewport, rendering\r\n * engine, viewport Id, rendering engine Id, and the Frame of Reference UID.\r\n */\r\nexport function getEnabledElementByIds(\r\n  viewportId: string,\r\n  renderingEngineId: string\r\n): IEnabledElement {\r\n  if (!renderingEngineId || !viewportId) {\r\n    return;\r\n  }\r\n\r\n  const renderingEngine = getRenderingEngine(renderingEngineId);\r\n\r\n  if (!renderingEngine || renderingEngine.hasBeenDestroyed) {\r\n    return;\r\n  }\r\n\r\n  const viewport = renderingEngine.getViewport(viewportId) as\r\n    | IStackViewport\r\n    | IVolumeViewport;\r\n\r\n  if (!viewport) {\r\n    return;\r\n  }\r\n\r\n  const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n\r\n  return {\r\n    viewport,\r\n    renderingEngine,\r\n    viewportId,\r\n    renderingEngineId,\r\n    FrameOfReferenceUID,\r\n  };\r\n}\r\n\r\n/**\r\n * Retrieves the enabled element by the specified viewport ID. it searches\r\n * through all the rendering engines to find the viewport with the specified\r\n *\r\n * @param viewportId - The ID of the viewport.\r\n * @returns The enabled element associated with the specified viewport ID.\r\n */\r\nexport function getEnabledElementByViewportId(viewportId: string) {\r\n  const renderingEngines = getRenderingEngines();\r\n\r\n  for (let i = 0; i < renderingEngines.length; i++) {\r\n    const renderingEngine = renderingEngines[i];\r\n    const viewport = renderingEngine.getViewport(viewportId);\r\n\r\n    if (viewport) {\r\n      return getEnabledElementByIds(viewportId, renderingEngine.id);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get all the enabled elements from all the rendering engines\r\n * @returns An array of enabled elements.\r\n */\r\nexport function getEnabledElements(): IEnabledElement[] {\r\n  const enabledElements = [];\r\n\r\n  const renderingEngines = getRenderingEngines();\r\n\r\n  renderingEngines.forEach((renderingEngine) => {\r\n    const viewports = renderingEngine.getViewports();\r\n\r\n    viewports.forEach(({ element }) => {\r\n      enabledElements.push(getEnabledElement(element));\r\n    });\r\n  });\r\n\r\n  return enabledElements;\r\n}\r\n","import cache from '../cache/cache';\r\nimport { ImageVolume } from '../cache';\r\nimport Events from '../enums/Events';\r\nimport eventTarget from '../eventTarget';\r\nimport {\r\n  genericMetadataProvider,\r\n  getBufferConfiguration,\r\n  triggerEvent,\r\n  uuidv4,\r\n} from '../utilities';\r\nimport {\r\n  IImage,\r\n  ImageLoaderFn,\r\n  IImageLoadObject,\r\n  EventTypes,\r\n  Point2,\r\n  Point3,\r\n  Mat3,\r\n  PixelDataTypedArrayString,\r\n  PixelDataTypedArray,\r\n} from '../types';\r\nimport imageLoadPoolManager from '../requestPool/imageLoadPoolManager';\r\nimport { metaData } from '../';\r\n\r\nexport interface ImageLoaderOptions {\r\n  priority: number;\r\n  requestType: string;\r\n  additionalDetails?: Record<string, unknown>;\r\n  ignoreCache?: boolean;\r\n}\r\n\r\ninterface DerivedImages {\r\n  imageIds: Array<string>;\r\n  promises: Array<Promise<IImage>>;\r\n}\r\n\r\ntype LocalImageOptions = {\r\n  scalarData?: PixelDataTypedArray;\r\n  targetBufferType?: PixelDataTypedArrayString;\r\n  dimensions?: Point2;\r\n  spacing?: Point3;\r\n  origin?: Point3;\r\n  direction?: Mat3;\r\n  /**\r\n   * Skip creation of the actual buffer object.\r\n   * In fact, this creates a very short buffer, as there are lots of places\r\n   * assuming a buffer exists.\r\n   * This can be used when there are alternative representations of the image data.\r\n   */\r\n  skipCreateBuffer?: boolean;\r\n  /**\r\n   * A method to call to update the image object when it gets added to the cache.\r\n   * This can be used to create alternative representations of the image data,\r\n   * such as a VoxelManager.\r\n   */\r\n  onCacheAdd?: (image: IImage) => void;\r\n};\r\n\r\ntype DerivedImageOptions = LocalImageOptions & {\r\n  imageId?: string;\r\n  targetBufferType?: PixelDataTypedArrayString;\r\n};\r\n\r\n/**\r\n * This module deals with ImageLoaders, loading images and caching images\r\n */\r\nconst imageLoaders = {};\r\nlet unknownImageLoader;\r\n\r\n/**\r\n * Loads an image using a registered Cornerstone Image Loader.\r\n *\r\n * The image loader that is used will be\r\n * determined by the image loader scheme matching against the imageId.\r\n *\r\n * @param imageId - A Cornerstone Image Object's imageId\r\n * @param Options - to be passed to the Image Loader\r\n *\r\n * @returns - An Object which can be used to act after an image is loaded or loading fails\r\n */\r\nfunction loadImageFromImageLoader(\r\n  imageId: string,\r\n  options: ImageLoaderOptions\r\n): IImageLoadObject {\r\n  // Extract the image loader scheme: wadors:https://image1 => wadors\r\n  const colonIndex = imageId.indexOf(':');\r\n  const scheme = imageId.substring(0, colonIndex);\r\n  const loader = imageLoaders[scheme];\r\n  if (loader === undefined || loader === null) {\r\n    if (unknownImageLoader !== undefined) {\r\n      return unknownImageLoader(imageId);\r\n    }\r\n    throw new Error('loadImageFromImageLoader: no image loader for imageId');\r\n  }\r\n  // Load using the registered loader\r\n  const imageLoadObject = loader(imageId, options);\r\n  // Broadcast an image loaded event once the image is loaded\r\n  imageLoadObject.promise.then(\r\n    function (image) {\r\n      triggerEvent(eventTarget, Events.IMAGE_LOADED, { image });\r\n    },\r\n    function (error) {\r\n      const errorObject: EventTypes.ImageLoadedFailedEventDetail = {\r\n        imageId,\r\n        error,\r\n      };\r\n      triggerEvent(eventTarget, Events.IMAGE_LOAD_FAILED, errorObject);\r\n    }\r\n  );\r\n  return imageLoadObject;\r\n}\r\n\r\n/**\r\n * Gets the imageLoadObject by 1) Looking in to the cache to see if the\r\n * imageLoadObject has already been cached, 2) Checks inside the volume cache\r\n * to see if there is a volume that contains the same imageURI for the requested\r\n * imageID 3) Checks inside the imageCache for similar imageURI that might have\r\n * been stored as a result of decaching a volume 4) Finally if none were found\r\n * it request it from the registered imageLoaders.\r\n *\r\n * @param imageId - A Cornerstone Image Object's imageId\r\n * @param options - Options to be passed to the Image Loader\r\n *\r\n * @returns An Object which can be used to act after an image is loaded or loading fails\r\n */\r\nfunction loadImageFromCacheOrVolume(\r\n  imageId: string,\r\n  options: ImageLoaderOptions\r\n): IImageLoadObject {\r\n  if (options.ignoreCache) {\r\n    return loadImageFromImageLoader(imageId, options);\r\n  }\r\n\r\n  // 1. Check inside the image cache for imageId\r\n  let imageLoadObject = cache.getImageLoadObject(imageId);\r\n  if (imageLoadObject !== undefined) {\r\n    return imageLoadObject;\r\n  }\r\n  // 2. Check if there exists a volume in the cache containing the imageId,\r\n  // we copy the pixelData over.\r\n  const cachedVolumeInfo = cache.getVolumeContainingImageId(imageId);\r\n  if (cachedVolumeInfo?.volume?.loadStatus?.loaded) {\r\n    // 2.1 Convert the volume at the specific slice to a cornerstoneImage object.\r\n    // this will copy the pixel data over.\r\n    const { volume, imageIdIndex } = cachedVolumeInfo;\r\n\r\n    if (volume instanceof ImageVolume) {\r\n      imageLoadObject = volume.convertToCornerstoneImage(imageId, imageIdIndex);\r\n    }\r\n    return imageLoadObject;\r\n  }\r\n  // 3. If no volume found, we search inside the imageCache for the imageId\r\n  // that has the same URI which had been cached if the volume was converted\r\n  // to an image\r\n  const cachedImage = cache.getCachedImageBasedOnImageURI(imageId);\r\n  if (cachedImage) {\r\n    imageLoadObject = cachedImage.imageLoadObject;\r\n    return imageLoadObject;\r\n  }\r\n  // 4. if not in image cache nor inside the volume cache, we request the\r\n  // image loaders to load it\r\n  imageLoadObject = loadImageFromImageLoader(imageId, options);\r\n\r\n  return imageLoadObject;\r\n}\r\n\r\n/**\r\n * Loads an image given an imageId and optional priority and returns a promise\r\n * which will resolve to the loaded image object or fail if an error occurred.\r\n * The loaded image is not stored in the cache.\r\n *\r\n *\r\n * @param imageId - A Cornerstone Image Object's imageId\r\n * @param options - Options to be passed to the Image Loader\r\n *\r\n * @returns An Object which can be used to act after an image is loaded or loading fails\r\n */\r\nexport function loadImage(\r\n  imageId: string,\r\n  options: ImageLoaderOptions = { priority: 0, requestType: 'prefetch' }\r\n): Promise<IImage> {\r\n  if (imageId === undefined) {\r\n    throw new Error('loadImage: parameter imageId must not be undefined');\r\n  }\r\n\r\n  return loadImageFromCacheOrVolume(imageId, options).promise;\r\n}\r\n\r\n/**\r\n * Loads an image given an imageId and optional priority and returns a promise\r\n * which will resolve to the loaded image object or fail if an error occurred.\r\n * The image is stored in the cache.\r\n *\r\n * @param imageId -  A Cornerstone Image Object's imageId\r\n * @param options - Options to be passed to the Image Loader\r\n *\r\n * @returns Image Loader Object\r\n */\r\nexport function loadAndCacheImage(\r\n  imageId: string,\r\n  options: ImageLoaderOptions = { priority: 0, requestType: 'prefetch' }\r\n): Promise<IImage> {\r\n  if (imageId === undefined) {\r\n    throw new Error(\r\n      'loadAndCacheImage: parameter imageId must not be undefined'\r\n    );\r\n  }\r\n\r\n  // console.log('LOAD AND CACHE IMAGE', imageId, options)\r\n  const imageLoadObject = loadImageFromCacheOrVolume(imageId, options);\r\n  // if(imageId.includes('pngfile')) console.log(`IMAGE LOAD OBJECT ${imageId} :`, imageLoadObject)\r\n\r\n  // if not inside cache, store it\r\n  if (!cache.getImageLoadObject(imageId)) {\r\n    cache.putImageLoadObject(imageId, imageLoadObject).catch((err) => {\r\n      console.warn(err);\r\n    });\r\n  }\r\n\r\n  return imageLoadObject.promise;\r\n}\r\n\r\n/**\r\n * Load and cache a list of imageIds\r\n *\r\n * @param imageIds - list of imageIds\r\n * @param options - options for loader\r\n *\r\n */\r\nexport function loadAndCacheImages(\r\n  imageIds: Array<string>,\r\n  options: ImageLoaderOptions = { priority: 0, requestType: 'prefetch' }\r\n): Promise<IImage>[] {\r\n  if (!imageIds || imageIds.length === 0) {\r\n    throw new Error(\r\n      'loadAndCacheImages: parameter imageIds must be list of image Ids'\r\n    );\r\n  }\r\n\r\n  const allPromises = imageIds.map((imageId) => {\r\n    return loadAndCacheImage(imageId, options);\r\n  });\r\n\r\n  return allPromises;\r\n}\r\n\r\n/**\r\n * Loads an image given an imageId and optional priority and returns a promise\r\n * which will resolve to the loaded image object or fail if an error occurred.\r\n * The image is stored in the cache.\r\n *\r\n * @param referencedImageId -  A Cornerstone Image Object's imageId\r\n * @param options - Options to be passed to the Image Loader\r\n *\r\n * @returns Image Loader Object\r\n */\r\nexport function createAndCacheDerivedImage(\r\n  referencedImageId: string,\r\n  options: DerivedImageOptions = {},\r\n  preventCache = false\r\n): Promise<IImage> {\r\n  if (referencedImageId === undefined) {\r\n    throw new Error(\r\n      'createAndCacheDerivedImage: parameter imageId must not be undefined'\r\n    );\r\n  }\r\n\r\n  if (options.imageId === undefined) {\r\n    options.imageId = `derived:${uuidv4()}`;\r\n  }\r\n\r\n  const { imageId, skipCreateBuffer, onCacheAdd } = options;\r\n\r\n  const imagePlaneModule = metaData.get('imagePlaneModule', referencedImageId);\r\n\r\n  const length = imagePlaneModule.rows * imagePlaneModule.columns;\r\n\r\n  const { TypedArrayConstructor } = getBufferConfiguration(\r\n    options.targetBufferType,\r\n    length\r\n  );\r\n\r\n  // Use a buffer of size 1 for no data\r\n  const imageScalarData = new TypedArrayConstructor(\r\n    skipCreateBuffer ? 1 : length\r\n  );\r\n  const derivedImageId = imageId;\r\n\r\n  ['imagePlaneModule', 'generalSeriesModule'].forEach((type) => {\r\n    genericMetadataProvider.add(derivedImageId, {\r\n      type,\r\n      metadata: metaData.get(type, referencedImageId),\r\n    });\r\n  });\r\n\r\n  const imagePixelModule = metaData.get('imagePixelModule', referencedImageId);\r\n  // TODO - add a general way to specify this\r\n  genericMetadataProvider.add(derivedImageId, {\r\n    type: 'imagePixelModule',\r\n    metadata: {\r\n      ...imagePixelModule,\r\n      bitsAllocated: 8,\r\n      bitsStored: 8,\r\n      highBit: 7,\r\n      samplesPerPixel: 1,\r\n      pixelRepresentation: 0,\r\n    },\r\n  });\r\n\r\n  const localImage = createAndCacheLocalImage(\r\n    { scalarData: imageScalarData, onCacheAdd, skipCreateBuffer },\r\n    imageId,\r\n    true\r\n  );\r\n\r\n  const imageLoadObject = {\r\n    promise: Promise.resolve(localImage),\r\n  };\r\n\r\n  if (!preventCache) {\r\n    cache.putImageLoadObject(derivedImageId, imageLoadObject);\r\n  }\r\n  return imageLoadObject.promise;\r\n}\r\n\r\n/**\r\n * Load and cache a list of imageIds\r\n *\r\n * @param referencedImageIds - list of imageIds\r\n * @param options\r\n * @param options.getDerivedImageId - function to get the derived imageId\r\n * @param options.targetBufferType - target buffer type\r\n * @param options.skipBufferCreate - avoid creating the buffer\r\n */\r\nexport function createAndCacheDerivedImages(\r\n  referencedImageIds: Array<string>,\r\n  options: DerivedImageOptions & {\r\n    getDerivedImageId?: (referencedImageId: string) => string;\r\n    targetBufferType?: PixelDataTypedArrayString;\r\n  } = {}\r\n): DerivedImages {\r\n  if (referencedImageIds?.length === 0) {\r\n    throw new Error(\r\n      'createAndCacheDerivedImages: parameter imageIds must be list of image Ids'\r\n    );\r\n  }\r\n\r\n  const derivedImageIds = [];\r\n  const allPromises = referencedImageIds.map((referencedImageId) => {\r\n    const newOptions: DerivedImageOptions = {\r\n      imageId:\r\n        options.getDerivedImageId?.(referencedImageId) || `derived:${uuidv4()}`,\r\n      ...options,\r\n    };\r\n    derivedImageIds.push(newOptions.imageId);\r\n    return createAndCacheDerivedImage(referencedImageId, newOptions);\r\n  });\r\n\r\n  return { imageIds: derivedImageIds, promises: allPromises };\r\n}\r\n\r\nexport function createAndCacheLocalImage(\r\n  options: LocalImageOptions,\r\n  imageId: string,\r\n  preventCache = false\r\n): IImage {\r\n  const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\r\n\r\n  const length = imagePlaneModule.rows * imagePlaneModule.columns;\r\n\r\n  const image = {\r\n    imageId: imageId,\r\n    intercept: 0,\r\n    windowCenter: 0,\r\n    windowWidth: 0,\r\n    color: false,\r\n    numComps: 1,\r\n    slope: 1,\r\n    minPixelValue: 0,\r\n    maxPixelValue: 255,\r\n    voiLUTFunction: undefined,\r\n    rows: imagePlaneModule.rows,\r\n    columns: imagePlaneModule.columns,\r\n    getCanvas: undefined, // todo: which canvas?\r\n    height: imagePlaneModule.rows,\r\n    width: imagePlaneModule.columns,\r\n    rgba: undefined, // todo: how\r\n    columnPixelSpacing: imagePlaneModule.columnPixelSpacing,\r\n    rowPixelSpacing: imagePlaneModule.rowPixelSpacing,\r\n    invert: false,\r\n  } as IImage;\r\n\r\n  if (options.scalarData) {\r\n    const imageScalarData = options.scalarData;\r\n\r\n    if (\r\n      !(\r\n        imageScalarData instanceof Uint8Array ||\r\n        imageScalarData instanceof Float32Array ||\r\n        imageScalarData instanceof Uint16Array ||\r\n        imageScalarData instanceof Int16Array\r\n      )\r\n    ) {\r\n      throw new Error(\r\n        'To use createLocalVolume you should pass scalarData of type Uint8Array, Uint16Array, Int16Array or Float32Array'\r\n      );\r\n    }\r\n\r\n    image.sizeInBytes = imageScalarData.byteLength;\r\n    image.getPixelData = () => imageScalarData;\r\n  } else if (options.skipCreateBuffer !== true) {\r\n    const { numBytes, TypedArrayConstructor } = getBufferConfiguration(\r\n      options.targetBufferType,\r\n      length\r\n    );\r\n\r\n    const imageScalarData = new TypedArrayConstructor(length);\r\n\r\n    image.sizeInBytes = numBytes;\r\n    image.getPixelData = () => imageScalarData;\r\n  }\r\n\r\n  // The onCacheAdd may modify the size in bytes for this image, which is ok,\r\n  // as this is used after resolution for cache storage.  It may also do\r\n  // thinks like adding alternative representations such as VoxelManager\r\n  options.onCacheAdd?.(image);\r\n\r\n  const imageLoadObject = {\r\n    promise: Promise.resolve(image),\r\n  };\r\n\r\n  if (!preventCache) {\r\n    cache.putImageLoadObject(image.imageId, imageLoadObject);\r\n  }\r\n\r\n  return image;\r\n}\r\n\r\n/**\r\n * Removes the imageId from the request pool manager and executes the `cancel`\r\n * function if it exists.\r\n *\r\n * @param imageId - A Cornerstone Image Object's imageId\r\n *\r\n */\r\nexport function cancelLoadImage(imageId: string): void {\r\n  const filterFunction = ({ additionalDetails }) => {\r\n    if (additionalDetails.imageId) {\r\n      return additionalDetails.imageId !== imageId;\r\n    }\r\n\r\n    // for volumes\r\n    return true;\r\n  };\r\n\r\n  // Instruct the request pool manager to filter queued\r\n  // requests to ensure requests we no longer need are\r\n  // no longer sent.\r\n  imageLoadPoolManager.filterRequests(filterFunction);\r\n\r\n  // TODO: Cancel decoding and retrieval as well (somehow?)\r\n\r\n  // cancel image loading if in progress\r\n  const imageLoadObject = cache.getImageLoadObject(imageId);\r\n\r\n  if (imageLoadObject) {\r\n    imageLoadObject.cancelFn();\r\n  }\r\n}\r\n\r\n/**\r\n * Removes the imageIds from the request pool manager and calls the `cancel`\r\n * function if it exists.\r\n *\r\n * @param imageIds - Array of Cornerstone Image Object's imageIds\r\n *\r\n */\r\nexport function cancelLoadImages(imageIds: Array<string>): void {\r\n  imageIds.forEach((imageId) => cancelLoadImage(imageId));\r\n}\r\n\r\n/**\r\n * Removes all the ongoing image loads by calling the `cancel` method on each\r\n * imageLoadObject. If no `cancel` method is available, it will be ignored.\r\n *\r\n */\r\nexport function cancelLoadAll(): void {\r\n  const requestPool = imageLoadPoolManager.getRequestPool();\r\n\r\n  Object.keys(requestPool).forEach((type: string) => {\r\n    const requests = requestPool[type];\r\n\r\n    Object.keys(requests).forEach((priority) => {\r\n      const requestDetails = requests[priority].pop();\r\n      const additionalDetails = requestDetails.additionalDetails as any;\r\n      const { imageId, volumeId } = additionalDetails;\r\n\r\n      let loadObject;\r\n\r\n      if (imageId) {\r\n        loadObject = cache.getImageLoadObject(imageId);\r\n      } else if (volumeId) {\r\n        loadObject = cache.getVolumeLoadObject(volumeId);\r\n      }\r\n      if (loadObject) {\r\n        loadObject.cancel();\r\n      }\r\n    });\r\n    // resetting the pool types to be empty\r\n    imageLoadPoolManager.clearRequestStack(type);\r\n\r\n    // TODO: Clear retrieval and decoding queues as well\r\n  });\r\n}\r\n\r\n/**\r\n * Registers an imageLoader plugin with cornerstone for the specified scheme\r\n *\r\n * @param scheme - The scheme to use for this image loader (e.g. 'dicomweb', 'wadouri', 'http')\r\n * @param imageLoader - A Cornerstone Image Loader function\r\n */\r\nexport function registerImageLoader(\r\n  scheme: string,\r\n  imageLoader: ImageLoaderFn\r\n): void {\r\n  imageLoaders[scheme] = imageLoader;\r\n}\r\n/**\r\n * Registers a new unknownImageLoader and returns the previous one\r\n *\r\n * @param imageLoader - A Cornerstone Image Loader\r\n *\r\n * @returns The previous Unknown Image Loader\r\n */\r\nexport function registerUnknownImageLoader(\r\n  imageLoader: ImageLoaderFn\r\n): ImageLoaderFn {\r\n  const oldImageLoader = unknownImageLoader;\r\n  unknownImageLoader = imageLoader;\r\n  return oldImageLoader;\r\n}\r\n/**\r\n * Removes all registered and unknown image loaders. This should be called\r\n * when the application is unmounted to prevent memory leaks.\r\n *\r\n */\r\nexport function unregisterAllImageLoaders(): void {\r\n  Object.keys(imageLoaders).forEach(\r\n    (imageLoader) => delete imageLoaders[imageLoader]\r\n  );\r\n  unknownImageLoader = undefined;\r\n}\r\n\r\n/**\r\n * Creates and caches derived segmentation images based on the referenced imageIds, this\r\n * is a helper function, we don't have segmentation concept in the cornerstone core; however,\r\n * this helper would make it clear that the segmentation images SHOULD be Uint8Array type\r\n * always until we have a better solution.\r\n *\r\n * @param referencedImageIds - An array of referenced image IDs.\r\n * @param options - The options for creating the derived images (default: { targetBufferType: 'Uint8Array' }).\r\n * @returns The derived images.\r\n */\r\nexport function createAndCacheDerivedSegmentationImages(\r\n  referencedImageIds: Array<string>,\r\n  options: DerivedImageOptions = {\r\n    targetBufferType: 'Uint8Array',\r\n  }\r\n): DerivedImages {\r\n  return createAndCacheDerivedImages(referencedImageIds, options);\r\n}\r\n\r\n/**\r\n * Creates and caches a derived segmentation image based on the referenced image ID.\r\n * this is a helper function, we don't have segmentation concept in the cornerstone core; however,\r\n * this helper would make it clear that the segmentation images SHOULD be Uint8Array type\r\n * always until we have a better solution.\r\n *\r\n * @param referencedImageId The ID of the referenced image.\r\n * @param options The options for creating the derived image (default: { targetBufferType: 'Uint8Array' }).\r\n * @returns A promise that resolves to the created derived segmentation image.\r\n */\r\nexport function createAndCacheDerivedSegmentationImage(\r\n  referencedImageId: string,\r\n  options: DerivedImageOptions = {\r\n    targetBufferType: 'Uint8Array',\r\n  }\r\n): Promise<IImage> {\r\n  return createAndCacheDerivedImage(referencedImageId, options);\r\n}\r\n","import '@kitware/vtk.js/Rendering/Profiles/Volume';\r\n\r\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\r\nimport type { vtkImageData as vtkImageDataType } from '@kitware/vtk.js/Common/DataModel/ImageData';\r\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\r\n\r\nimport { ImageVolume } from '../cache/classes/ImageVolume';\r\nimport cache from '../cache/cache';\r\nimport Events from '../enums/Events';\r\nimport eventTarget from '../eventTarget';\r\nimport triggerEvent from '../utilities/triggerEvent';\r\nimport cloneDeep from 'lodash.clonedeep';\r\n\r\nimport {\r\n  createUint16SharedArray,\r\n  createUint8SharedArray,\r\n  createFloat32SharedArray,\r\n  generateVolumePropsFromImageIds,\r\n  getBufferConfiguration,\r\n  uuidv4,\r\n} from '../utilities';\r\nimport {\r\n  Point3,\r\n  Metadata,\r\n  EventTypes,\r\n  Mat3,\r\n  IImageVolume,\r\n  VolumeLoaderFn,\r\n  IDynamicImageVolume,\r\n  PixelDataTypedArray,\r\n  IVolumeLoadObject,\r\n  PixelDataTypedArrayString,\r\n} from '../types';\r\nimport { getConfiguration, getShouldUseSharedArrayBuffer } from '../init';\r\nimport {\r\n  performCacheOptimizationForVolume,\r\n  setupCacheOptimizationEventListener,\r\n} from '../utilities/cacheUtils';\r\n\r\ninterface VolumeLoaderOptions {\r\n  imageIds: Array<string>;\r\n}\r\n\r\ninterface DerivedVolumeOptions {\r\n  volumeId: string;\r\n  targetBuffer?: {\r\n    type: PixelDataTypedArrayString;\r\n    sharedArrayBuffer?: boolean;\r\n  };\r\n}\r\ninterface LocalVolumeOptions {\r\n  metadata: Metadata;\r\n  dimensions: Point3;\r\n  spacing: Point3;\r\n  origin: Point3;\r\n  direction: Mat3;\r\n  scalarData?: PixelDataTypedArray;\r\n  imageIds?: Array<string>;\r\n  referencedImageIds?: Array<string>;\r\n  referencedVolumeId?: string;\r\n  targetBuffer?: {\r\n    type: PixelDataTypedArrayString;\r\n    sharedArrayBuffer?: boolean;\r\n  };\r\n}\r\n\r\n/**\r\n * Adds a single scalar data to a 3D volume\r\n */\r\nfunction addScalarDataToImageData(\r\n  imageData: vtkImageDataType,\r\n  scalarData: PixelDataTypedArray,\r\n  dataArrayAttrs\r\n) {\r\n  const scalarArray = vtkDataArray.newInstance({\r\n    name: `Pixels`,\r\n    values: scalarData,\r\n    ...dataArrayAttrs,\r\n  });\r\n\r\n  imageData.getPointData().setScalars(scalarArray);\r\n}\r\n\r\n/**\r\n * Adds multiple scalar data (time points) to a 4D volume\r\n */\r\nfunction addScalarDataArraysToImageData(\r\n  imageData: vtkImageDataType,\r\n  scalarDataArrays: PixelDataTypedArray[],\r\n  dataArrayAttrs\r\n) {\r\n  scalarDataArrays.forEach((scalarData, i) => {\r\n    const vtkScalarArray = vtkDataArray.newInstance({\r\n      name: `timePoint-${i}`,\r\n      values: scalarData,\r\n      ...dataArrayAttrs,\r\n    });\r\n\r\n    imageData.getPointData().addArray(vtkScalarArray);\r\n  });\r\n\r\n  // Set the first as active otherwise nothing is displayed on the screen\r\n  imageData.getPointData().setActiveScalars('timePoint-0');\r\n}\r\n\r\nfunction createInternalVTKRepresentation(\r\n  volume: IImageVolume\r\n): vtkImageDataType {\r\n  const { dimensions, metadata, spacing, direction, origin } = volume;\r\n  const { PhotometricInterpretation } = metadata;\r\n\r\n  let numComponents = 1;\r\n  if (PhotometricInterpretation === 'RGB') {\r\n    numComponents = 3;\r\n  }\r\n\r\n  const imageData = vtkImageData.newInstance();\r\n  const dataArrayAttrs = { numberOfComponents: numComponents };\r\n\r\n  imageData.setDimensions(dimensions);\r\n  imageData.setSpacing(spacing);\r\n  imageData.setDirection(direction);\r\n  imageData.setOrigin(origin);\r\n\r\n  // Add scalar data to 3D or 4D volume\r\n  if (volume.isDynamicVolume()) {\r\n    const scalarDataArrays = (<IDynamicImageVolume>(\r\n      volume\r\n    )).getScalarDataArrays();\r\n\r\n    addScalarDataArraysToImageData(imageData, scalarDataArrays, dataArrayAttrs);\r\n  } else {\r\n    const scalarData = volume.getScalarData();\r\n\r\n    addScalarDataToImageData(imageData, scalarData, dataArrayAttrs);\r\n  }\r\n\r\n  return imageData;\r\n}\r\n\r\n/**\r\n * This module deals with VolumeLoaders and loading volumes\r\n */\r\n\r\nconst volumeLoaders = {};\r\n\r\nlet unknownVolumeLoader;\r\n\r\n/**\r\n * Load a volume using a registered Cornerstone Volume Loader.\r\n *\r\n * The volume loader that is used will be\r\n * determined by the volume loader scheme matching against the volumeId.\r\n *\r\n * @param volumeId - A Cornerstone Volume Object's volumeId\r\n * @param options - Options to be passed to the Volume Loader. Options\r\n * contain the ImageIds that is passed to the loader\r\n *\r\n * @returns An Object which can be used to act after a volume is loaded or loading fails\r\n *\r\n */\r\nfunction loadVolumeFromVolumeLoader(\r\n  volumeId: string,\r\n  options?: VolumeLoaderOptions\r\n): IVolumeLoadObject {\r\n  const colonIndex = volumeId.indexOf(':');\r\n  const scheme = volumeId.substring(0, colonIndex);\r\n  let loader = volumeLoaders[scheme];\r\n\r\n  if (loader === undefined || loader === null) {\r\n    if (\r\n      unknownVolumeLoader == null ||\r\n      typeof unknownVolumeLoader !== 'function'\r\n    ) {\r\n      throw new Error(\r\n        `No volume loader for scheme ${scheme} has been registered`\r\n      );\r\n    }\r\n\r\n    loader = unknownVolumeLoader;\r\n  }\r\n\r\n  const volumeLoadObject = loader(volumeId, options);\r\n\r\n  setupCacheOptimizationEventListener(volumeId);\r\n\r\n  // Broadcast a volume loaded event once the image is loaded\r\n  volumeLoadObject.promise.then(\r\n    function (volume) {\r\n      triggerEvent(eventTarget, Events.VOLUME_LOADED, { volume });\r\n    },\r\n    function (error) {\r\n      const errorObject: EventTypes.VolumeLoadedFailedEventDetail = {\r\n        volumeId,\r\n        error,\r\n      };\r\n\r\n      triggerEvent(eventTarget, Events.VOLUME_LOADED_FAILED, errorObject);\r\n    }\r\n  );\r\n\r\n  return volumeLoadObject;\r\n}\r\n\r\n/**\r\n * Loads a volume given a volumeId and optional priority and returns a promise which will resolve to\r\n * the loaded image object or fail if an error occurred.  The loaded image is not stored in the cache.\r\n *\r\n * @param volumeId - A Cornerstone Image Object's volumeId\r\n * @param options - Options to be passed to the Volume Loader\r\n *\r\n * @returns An Object which can be used to act after an image is loaded or loading fails\r\n */\r\nexport function loadVolume(\r\n  volumeId: string,\r\n  options: VolumeLoaderOptions = { imageIds: [] }\r\n): Promise<IImageVolume> {\r\n  if (volumeId === undefined) {\r\n    throw new Error('loadVolume: parameter volumeId must not be undefined');\r\n  }\r\n\r\n  let volumeLoadObject = cache.getVolumeLoadObject(volumeId);\r\n\r\n  if (volumeLoadObject !== undefined) {\r\n    return volumeLoadObject.promise;\r\n  }\r\n\r\n  volumeLoadObject = loadVolumeFromVolumeLoader(volumeId, options);\r\n\r\n  return volumeLoadObject.promise.then((volume: IImageVolume) => {\r\n    volume.imageData = createInternalVTKRepresentation(volume);\r\n    return volume;\r\n  });\r\n}\r\n\r\n/**\r\n * Loads an image given an volumeId and optional priority and returns a promise which will resolve to\r\n * the loaded image object or fail if an error occurred. The image is stored in the cache.\r\n *\r\n * @param volumeId - A Cornerstone Image Object's volumeId\r\n * @param options - Options to be passed to the Volume Loader\r\n *\r\n * @returns Volume Loader Object\r\n */\r\nexport async function createAndCacheVolume(\r\n  volumeId: string,\r\n  options?: VolumeLoaderOptions\r\n): Promise<Record<string, any>> {\r\n  if (volumeId === undefined) {\r\n    throw new Error(\r\n      'createAndCacheVolume: parameter volumeId must not be undefined'\r\n    );\r\n  }\r\n\r\n  let volumeLoadObject = cache.getVolumeLoadObject(volumeId);\r\n\r\n  if (volumeLoadObject !== undefined) {\r\n    return volumeLoadObject.promise;\r\n  }\r\n\r\n  volumeLoadObject = loadVolumeFromVolumeLoader(volumeId, options);\r\n\r\n  volumeLoadObject.promise.then((volume: IImageVolume) => {\r\n    volume.imageData = createInternalVTKRepresentation(volume);\r\n  });\r\n\r\n  cache.putVolumeLoadObject(volumeId, volumeLoadObject).catch((err) => {\r\n    throw err;\r\n  });\r\n\r\n  return volumeLoadObject.promise;\r\n}\r\n\r\n/**\r\n * Based on a referencedVolumeId, it will build and cache a new volume. If\r\n * no scalarData is specified in the options, an empty derived volume will be\r\n * created that matches the image metadata of the referenceVolume. If scalarData\r\n * is given, it will be used to generate the intensity values for the derivedVolume.\r\n * Finally, it will save the volume in the cache.\r\n * @param referencedVolumeId - the volumeId from which the new volume will get its metadata\r\n * @param options - DerivedVolumeOptions {uid: derivedVolumeUID, targetBuffer: { type: Float32Array | Uint8Array |\r\n * Uint16Array | Uint32Array  }, scalarData: if provided}\r\n *\r\n * @returns ImageVolume\r\n */\r\nexport async function createAndCacheDerivedVolume(\r\n  referencedVolumeId: string,\r\n  options: DerivedVolumeOptions\r\n): Promise<IImageVolume> {\r\n  const referencedVolume = cache.getVolume(referencedVolumeId);\r\n  if (!referencedVolume) {\r\n    throw new Error(\r\n      `Cannot created derived volume: Referenced volume with id ${referencedVolumeId} does not exist.`\r\n    );\r\n  }\r\n\r\n  let { volumeId } = options;\r\n  const { targetBuffer } = options;\r\n\r\n  if (volumeId === undefined) {\r\n    volumeId = uuidv4();\r\n  }\r\n\r\n  const { metadata, dimensions, spacing, origin, direction } = referencedVolume;\r\n  const scalarData = referencedVolume.getScalarData();\r\n  const scalarLength = scalarData.length;\r\n\r\n  const { volumeScalarData, numBytes } = generateVolumeScalarData(\r\n    targetBuffer,\r\n    scalarLength\r\n  );\r\n\r\n  // Todo: handle more than one component for segmentation (RGB)\r\n  const scalarArray = vtkDataArray.newInstance({\r\n    name: 'Pixels',\r\n    numberOfComponents: 1,\r\n    values: volumeScalarData,\r\n  });\r\n\r\n  const derivedImageData = vtkImageData.newInstance();\r\n\r\n  derivedImageData.setDimensions(dimensions);\r\n  derivedImageData.setSpacing(spacing);\r\n  derivedImageData.setDirection(direction);\r\n  derivedImageData.setOrigin(origin);\r\n  derivedImageData.getPointData().setScalars(scalarArray);\r\n\r\n  const derivedVolume = new ImageVolume({\r\n    volumeId,\r\n    metadata: cloneDeep(metadata),\r\n    dimensions: [dimensions[0], dimensions[1], dimensions[2]],\r\n    spacing,\r\n    origin,\r\n    direction,\r\n    imageData: derivedImageData,\r\n    scalarData: volumeScalarData,\r\n    sizeInBytes: numBytes,\r\n    imageIds: [],\r\n    referencedVolumeId,\r\n  });\r\n\r\n  const volumeLoadObject = {\r\n    promise: Promise.resolve(derivedVolume),\r\n  };\r\n\r\n  await cache.putVolumeLoadObject(volumeId, volumeLoadObject);\r\n\r\n  return derivedVolume;\r\n}\r\n\r\n/**\r\n * Creates and cache a volume based on a set of provided properties including\r\n * dimensions, spacing, origin, direction, metadata, scalarData. It should be noted that\r\n * scalarData should be provided for this function to work. If a volume with the same\r\n * Id exists in the cache it returns it immediately.\r\n * @param options -  { scalarData, metadata, dimensions, spacing, origin, direction }\r\n * @param volumeId - Id of the generated volume\r\n *\r\n * @returns ImageVolume\r\n */\r\nexport function createLocalVolume(\r\n  options: LocalVolumeOptions,\r\n  volumeId: string,\r\n  preventCache = false\r\n): IImageVolume {\r\n  const { metadata, dimensions, spacing, origin, direction, targetBuffer } =\r\n    options;\r\n\r\n  let { scalarData } = options;\r\n\r\n  // Define the valid data types for scalarData\r\n  const validDataTypes = [\r\n    'Uint8Array',\r\n    'Float32Array',\r\n    'Uint16Array',\r\n    'Int16Array',\r\n  ];\r\n\r\n  const scalarLength = dimensions[0] * dimensions[1] * dimensions[2];\r\n\r\n  // Check if scalarData is provided and is of a valid type\r\n  if (!scalarData || !validDataTypes.includes(scalarData.constructor.name)) {\r\n    // Check if targetBuffer is provided and has a valid type\r\n    if (!targetBuffer?.type || !validDataTypes.includes(targetBuffer.type)) {\r\n      throw new Error(\r\n        'createLocalVolume: parameter scalarData must be provided and must be either Uint8Array, Float32Array, Uint16Array or Int16Array'\r\n      );\r\n    }\r\n\r\n    // Generate volume scalar data if scalarData is not provided or invalid\r\n    ({ volumeScalarData: scalarData } = generateVolumeScalarData(\r\n      targetBuffer,\r\n      scalarLength\r\n    ));\r\n  }\r\n\r\n  // Todo: handle default values for spacing, origin, direction if not provided\r\n  if (volumeId === undefined) {\r\n    volumeId = uuidv4();\r\n  }\r\n\r\n  const cachedVolume = cache.getVolume(volumeId);\r\n\r\n  if (cachedVolume) {\r\n    return cachedVolume as IImageVolume;\r\n  }\r\n\r\n  const numBytes = scalarData ? scalarData.buffer.byteLength : scalarLength * 4;\r\n\r\n  // check if there is enough space in unallocated + image Cache\r\n  const isCacheable = cache.isCacheable(numBytes);\r\n  if (!isCacheable) {\r\n    throw new Error(Events.CACHE_SIZE_EXCEEDED);\r\n  }\r\n\r\n  const scalarArray = vtkDataArray.newInstance({\r\n    name: 'Pixels',\r\n    numberOfComponents: 1,\r\n    values: scalarData,\r\n  });\r\n\r\n  const imageData = vtkImageData.newInstance();\r\n\r\n  imageData.setDimensions(dimensions);\r\n  imageData.setSpacing(spacing);\r\n  imageData.setDirection(direction);\r\n  imageData.setOrigin(origin);\r\n  imageData.getPointData().setScalars(scalarArray);\r\n\r\n  const derivedVolume = new ImageVolume({\r\n    volumeId,\r\n    metadata: cloneDeep(metadata),\r\n    dimensions: [dimensions[0], dimensions[1], dimensions[2]],\r\n    spacing,\r\n    origin,\r\n    direction,\r\n    imageData: imageData,\r\n    scalarData,\r\n    sizeInBytes: numBytes,\r\n    referencedImageIds: options.referencedImageIds || [],\r\n    referencedVolumeId: options.referencedVolumeId,\r\n    imageIds: options.imageIds || [],\r\n  });\r\n\r\n  if (preventCache) {\r\n    return derivedVolume;\r\n  }\r\n\r\n  const volumeLoadObject = {\r\n    promise: Promise.resolve(derivedVolume),\r\n  };\r\n  cache.putVolumeLoadObject(volumeId, volumeLoadObject);\r\n\r\n  return derivedVolume;\r\n}\r\n\r\nexport async function createAndCacheVolumeFromImages(\r\n  volumeId: string,\r\n  imageIds: string[],\r\n  options: {\r\n    preventCache?: boolean;\r\n    additionalDetails?: Record<string, any>;\r\n  } = {}\r\n): Promise<IImageVolume> {\r\n  const { preventCache = false } = options;\r\n\r\n  if (imageIds === undefined) {\r\n    throw new Error(\r\n      'createAndCacheVolumeFromImages: parameter imageIds must not be undefined'\r\n    );\r\n  }\r\n\r\n  if (volumeId === undefined) {\r\n    throw new Error(\r\n      'createAndCacheVolumeFromImages: parameter volumeId must not be undefined'\r\n    );\r\n  }\r\n\r\n  const cachedVolume = cache.getVolume(volumeId);\r\n\r\n  if (cachedVolume) {\r\n    return Promise.resolve(cachedVolume);\r\n  }\r\n\r\n  const volumeProps = generateVolumePropsFromImageIds(imageIds, volumeId);\r\n\r\n  // volume is an empty volume, we need to load the data from the imageIds\r\n  // into the volume scalarData\r\n\r\n  // it is important to get the imageIds from the volumeProps\r\n  // since they are sorted\r\n  const imagePromises = volumeProps.imageIds.map((imageId, imageIdIndex) => {\r\n    const imageLoadObject = cache.getImageLoadObject(imageId);\r\n\r\n    return imageLoadObject.promise.then((image) => {\r\n      const pixelData = image.getPixelData();\r\n      const offset = imageIdIndex * image.rows * image.columns;\r\n\r\n      (volumeProps.scalarData as PixelDataTypedArray).set(pixelData, offset);\r\n    });\r\n  });\r\n\r\n  await Promise.all(imagePromises);\r\n\r\n  const volume = new ImageVolume({\r\n    ...volumeProps,\r\n    referencedImageIds: imageIds,\r\n    ...options,\r\n  });\r\n\r\n  // since we generated the volume from images, we can optimize the cache\r\n  // by replacing the pixelData of the images with a view of the volume's\r\n  // scalarData\r\n  performCacheOptimizationForVolume(volume);\r\n\r\n  const volumeLoadObject = {\r\n    promise: Promise.resolve(volume),\r\n  };\r\n\r\n  if (preventCache) {\r\n    return volumeLoadObject.promise;\r\n  }\r\n\r\n  cache.putVolumeLoadObject(volumeId, volumeLoadObject);\r\n\r\n  return volumeLoadObject.promise;\r\n}\r\n\r\n/**\r\n * Registers an volumeLoader plugin with cornerstone for the specified scheme\r\n *\r\n * @param scheme - The scheme to use for this volume loader (e.g. 'dicomweb', 'wadouri', 'http')\r\n * @param volumeLoader - A Cornerstone Volume Loader function\r\n */\r\nexport function registerVolumeLoader(\r\n  scheme: string,\r\n  volumeLoader: VolumeLoaderFn\r\n): void {\r\n  volumeLoaders[scheme] = volumeLoader;\r\n}\r\n\r\n/** Gets the array of volume loader schemes */\r\nexport function getVolumeLoaderSchemes(): string[] {\r\n  return Object.keys(volumeLoaders);\r\n}\r\n\r\n/**\r\n * Registers a new unknownVolumeLoader and returns the previous one\r\n *\r\n * @param volumeLoader - A Cornerstone Volume Loader\r\n *\r\n * @returns The previous Unknown Volume Loader\r\n */\r\nexport function registerUnknownVolumeLoader(\r\n  volumeLoader: VolumeLoaderFn\r\n): VolumeLoaderFn | undefined {\r\n  const oldVolumeLoader = unknownVolumeLoader;\r\n\r\n  unknownVolumeLoader = volumeLoader;\r\n\r\n  return oldVolumeLoader;\r\n}\r\n\r\nexport function getUnknownVolumeLoaderSchema(): string {\r\n  return unknownVolumeLoader.name;\r\n}\r\n\r\n/**\r\n * Creates and caches a derived segmentation volume based on a referenced volume.\r\n * This is basically a utility method since for the segmentations we have to specify\r\n * Uint8Array as the targetBuffer type for now until we support other types.\r\n *\r\n * @param referencedVolumeId - The ID of the referenced volume.\r\n * @param options - The options for creating the derived volume.\r\n * @returns A promise that resolves to the created derived segmentation volume.\r\n */\r\nexport async function createAndCacheDerivedSegmentationVolume(\r\n  referencedVolumeId: string,\r\n  options = {} as DerivedVolumeOptions\r\n): Promise<IImageVolume> {\r\n  return createAndCacheDerivedVolume(referencedVolumeId, {\r\n    ...options,\r\n    targetBuffer: {\r\n      type: 'Uint8Array',\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Creates a local segmentation volume.\r\n *\r\n * @param options - The options for creating the volume.\r\n * @param volumeId - The ID of the volume.\r\n * @param preventCache - Whether to prevent caching the volume.\r\n * @returns A promise that resolves to the created image volume.\r\n */\r\nexport async function createLocalSegmentationVolume(\r\n  options: LocalVolumeOptions,\r\n  volumeId: string,\r\n  preventCache = false\r\n): Promise<IImageVolume> {\r\n  if (!options.scalarData) {\r\n    options.scalarData = new Uint8Array(\r\n      options.dimensions[0] * options.dimensions[1] * options.dimensions[2]\r\n    );\r\n  }\r\n\r\n  return createLocalVolume(options, volumeId, preventCache);\r\n}\r\n\r\n/**\r\n * This function generates volume scalar data based on the provided target buffer and scalar length.\r\n * It checks if the cache can accommodate the data size and throws an error if it exceeds the cache size.\r\n * If a shared array buffer is available in the target buffer, it uses that to create the typed array.\r\n * Otherwise, it creates a typed array based on the scalar length.\r\n *\r\n * @param targetBuffer - The target buffer object which may contain a type and a shared array buffer.\r\n * @param scalarLength - The scalar length for creating the typed array.\r\n * @param useNorm16Texture - A flag to specify whether to use a 16-bit texture or not.\r\n * @returns The volume scalar data as a typed array.\r\n */\r\nfunction generateVolumeScalarData(\r\n  targetBuffer: {\r\n    type: PixelDataTypedArrayString;\r\n    sharedArrayBuffer?: boolean;\r\n  },\r\n  scalarLength: number\r\n) {\r\n  const { useNorm16Texture } = getConfiguration().rendering;\r\n\r\n  const { TypedArrayConstructor, numBytes } = getBufferConfiguration(\r\n    targetBuffer?.type,\r\n    scalarLength,\r\n    {\r\n      use16BitTexture: useNorm16Texture,\r\n      isVolumeBuffer: true,\r\n    }\r\n  );\r\n\r\n  const isCacheable = cache.isCacheable(numBytes);\r\n  if (!isCacheable) {\r\n    throw new Error(Events.CACHE_SIZE_EXCEEDED);\r\n  }\r\n\r\n  let volumeScalarData;\r\n  if (targetBuffer?.sharedArrayBuffer ?? getShouldUseSharedArrayBuffer()) {\r\n    switch (targetBuffer.type) {\r\n      case 'Float32Array':\r\n        volumeScalarData = createFloat32SharedArray(scalarLength);\r\n        break;\r\n      case 'Uint8Array':\r\n        volumeScalarData = createUint8SharedArray(scalarLength);\r\n        break;\r\n      case 'Uint16Array':\r\n        volumeScalarData = createUint16SharedArray(scalarLength);\r\n        break;\r\n      case 'Int16Array':\r\n        volumeScalarData = createUint16SharedArray(scalarLength);\r\n        break;\r\n      default:\r\n        throw new Error(\r\n          'generateVolumeScalarData: SharedArrayBuffer is not supported for the specified target buffer type'\r\n        );\r\n    }\r\n  } else {\r\n    volumeScalarData = new TypedArrayConstructor(scalarLength);\r\n  }\r\n\r\n  return { volumeScalarData, numBytes };\r\n}\r\n","import { RequestPoolManager } from './requestPoolManager';\r\nimport RequestType from '../enums/RequestType';\r\n\r\n/**\r\n * You can use the imageLoadPoolManager to load images, by providing a `requestFn`\r\n * that returns a promise for the image. You can provide a `type` to specify the type of\r\n * request (interaction, thumbnail, prefetch), and you can provide additional details\r\n * that will be passed to the requestFn. Below is an example of a requestFn that loads\r\n * an image from an imageId:\r\n *\r\n * ```javascript\r\n *\r\n * const priority = -5\r\n * const requestType = RequestType.Interaction\r\n * const additionalDetails = { imageId }\r\n * const options = {\r\n *   targetBuffer: {\r\n *     type: 'Float32Array',\r\n *     offset: null,\r\n *     length: null,\r\n *   },\r\n *   preScale: {\r\n *     enabled: true,\r\n *   },\r\n * }\r\n *\r\n * imageLoadPoolManager.addRequest(\r\n *   loadAndCacheImage(imageId, options).then(() => { // set on viewport}),\r\n *   requestType,\r\n *   additionalDetails,\r\n *   priority\r\n * )\r\n * ```\r\n */\r\nconst imageLoadPoolManager = new RequestPoolManager('imageLoadPool');\r\n\r\nimageLoadPoolManager.grabDelay = 0;\r\n\r\nimageLoadPoolManager.setMaxSimultaneousRequests(RequestType.Interaction, 1000);\r\nimageLoadPoolManager.setMaxSimultaneousRequests(RequestType.Thumbnail, 1000);\r\nimageLoadPoolManager.setMaxSimultaneousRequests(RequestType.Prefetch, 1000);\r\n\r\nexport default imageLoadPoolManager;\r\n","import RequestType from '../enums/RequestType';\r\nimport { IImage } from '../types';\r\nimport { uuidv4 } from '../utilities';\r\n\r\ntype AdditionalDetails = {\r\n  imageId?: string;\r\n  volumeId?: string;\r\n};\r\n\r\ntype RequestDetailsInterface = {\r\n  requestFn: () => Promise<IImage | void>;\r\n  type: RequestType;\r\n  additionalDetails: AdditionalDetails;\r\n};\r\n\r\ntype RequestPool = {\r\n  [name in RequestType]: { [key: number]: RequestDetailsInterface[] };\r\n};\r\n\r\n/**\r\n * RequestPool manager class is a base class that manages the request pools.\r\n * It is used imageRetrievalPoolManager, and imageLoadPoolManager to retrieve and load images.\r\n * Previously requestPoolManager was used to manage the retrieval and loading and decoding\r\n * of the images in a way that new requests were sent after the image was both loaded and decoded\r\n * which was not performant since it was waiting for the image to be loaded and decoded before\r\n * sending the next request which is a network request and can be done in parallel.\r\n * Now, we use separate imageRetrievalPoolManager and imageLoadPoolManager\r\n * to improve performance and both are extending the RequestPoolManager class which\r\n * is a basic queueing pool.\r\n *\r\n * A new requestPool can be created by instantiating a new RequestPoolManager class.\r\n *\r\n * ```javascript\r\n * const requestPoolManager = new RequestPoolManager()\r\n * ```\r\n *\r\n * ## ImageLoadPoolManager\r\n *\r\n * You can use the imageLoadPoolManager to load images, by providing a `requestFn`\r\n * that returns a promise for the image. You can provide a `type` to specify the type of\r\n * request (interaction, thumbnail, prefetch), and you can provide additional details\r\n * that will be passed to the requestFn. Below is an example of a requestFn that loads\r\n * an image from an imageId:\r\n *\r\n * ```javascript\r\n *\r\n * const priority = -5\r\n * const requestType = RequestType.Interaction\r\n * const additionalDetails = { imageId }\r\n * const options = {\r\n *   targetBuffer: {\r\n *     type: 'Float32Array',\r\n *     offset: null,\r\n *     length: null,\r\n *   },\r\n *   preScale: {\r\n *      enabled: true,\r\n *    },\r\n * }\r\n *\r\n * imageLoadPoolManager.addRequest(\r\n *   loadAndCacheImage(imageId, options).then(() => { // set on viewport}),\r\n *   requestType,\r\n *   additionalDetails,\r\n *   priority\r\n * )\r\n * ```\r\n * ### ImageRetrievalPoolManager\r\n * You don't need to directly use the imageRetrievalPoolManager to load images\r\n * since the imageLoadPoolManager will automatically use it for retrieval. However,\r\n * maximum number of concurrent requests can be set by calling `setMaxConcurrentRequests`.\r\n */\r\nclass RequestPoolManager {\r\n  private id: string;\r\n  private awake: boolean;\r\n  private requestPool: RequestPool;\r\n  private numRequests = {\r\n    interaction: 0,\r\n    thumbnail: 0,\r\n    prefetch: 0,\r\n    compute: 0,\r\n  };\r\n  /* maximum number of requests of each type. */\r\n  public maxNumRequests: {\r\n    interaction: number;\r\n    thumbnail: number;\r\n    prefetch: number;\r\n    compute: number;\r\n  };\r\n  /* A public property that is used to set the delay between requests. */\r\n  public grabDelay: number;\r\n  private timeoutHandle: number;\r\n\r\n  /**\r\n   * By default a request pool containing three priority groups, one for each\r\n   * of the request types, is created. Maximum number of requests of each type\r\n   * is set to 6.\r\n   */\r\n  constructor(id?: string) {\r\n    this.id = id ? id : uuidv4();\r\n\r\n    this.requestPool = {\r\n      interaction: { 0: [] },\r\n      thumbnail: { 0: [] },\r\n      prefetch: { 0: [] },\r\n      compute: { 0: [] },\r\n    };\r\n\r\n    this.grabDelay = 5;\r\n    this.awake = false;\r\n\r\n    this.numRequests = {\r\n      interaction: 0,\r\n      thumbnail: 0,\r\n      prefetch: 0,\r\n      compute: 0,\r\n    };\r\n\r\n    this.maxNumRequests = {\r\n      interaction: 6,\r\n      thumbnail: 6,\r\n      prefetch: 5,\r\n      // I believe there is a bug right now, where if there are two workers\r\n      // and one wants to run a compute job 6 times and the limit is just 5, then\r\n      // the other worker will never get a chance to run its compute job.\r\n      // we should probably have a separate limit for compute jobs per worker\r\n      // context as there is another layer of parallelism there. For this reason\r\n      // I'm setting the limit to 1000 for now.\r\n      compute: 1000,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * This function sets the maximum number of requests for a given request type.\r\n   * @param type - The type of request you want to set the max number\r\n   * of requests for it can be either of interaction, prefetch, or thumbnail.\r\n   * @param maxNumRequests - The maximum number of requests that can be\r\n   * made at a time.\r\n   */\r\n  public setMaxSimultaneousRequests(\r\n    type: RequestType,\r\n    maxNumRequests: number\r\n  ): void {\r\n    this.maxNumRequests[type] = maxNumRequests;\r\n  }\r\n\r\n  /**\r\n   * It returns the maximum number of requests of a given type that can be made\r\n   * @param type - The type of request.\r\n   * @returns The maximum number of requests of a given type.\r\n   */\r\n  public getMaxSimultaneousRequests(type: RequestType): number {\r\n    return this.maxNumRequests[type];\r\n  }\r\n\r\n  /**\r\n   * Stops further fetching of the requests, all the ongoing requests will still\r\n   * be retrieved\r\n   */\r\n  public destroy(): void {\r\n    if (this.timeoutHandle) {\r\n      window.clearTimeout(this.timeoutHandle);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds the requests to the pool of requests.\r\n   *\r\n   * @param requestFn - A function that returns a promise which resolves in the image\r\n   * @param type - Priority category, it can be either of interaction, prefetch,\r\n   * or thumbnail.\r\n   * @param additionalDetails - Additional details that requests can contain.\r\n   * For instance the volumeId for the volume requests\r\n   * @param priority - Priority number for each category of requests. Its default\r\n   * value is priority 0. The lower the priority number, the higher the priority number\r\n   *\r\n   */\r\n  public addRequest(\r\n    requestFn: () => Promise<IImage | void>,\r\n    type: RequestType,\r\n    additionalDetails: Record<string, unknown>,\r\n    priority = 0\r\n  ): void {\r\n    // Describe the request\r\n    const requestDetails: RequestDetailsInterface = {\r\n      requestFn,\r\n      type,\r\n      additionalDetails,\r\n    };\r\n\r\n    // Check if the priority group exists on the request type\r\n    if (this.requestPool[type][priority] === undefined) {\r\n      this.requestPool[type][priority] = [];\r\n    }\r\n\r\n    // Adding the request to the correct priority group of the request type\r\n    this.requestPool[type][priority].push(requestDetails);\r\n\r\n    this.startGrabbing();\r\n  }\r\n\r\n  /**\r\n   * Filter the requestPoolManager's pool of request based on the result of\r\n   * provided filter function. The provided filter function needs to return false or true\r\n   *\r\n   * @param filterFunction - The filter function for filtering of the requests to keep\r\n   */\r\n  public filterRequests(\r\n    filterFunction: (requestDetails: RequestDetailsInterface) => boolean\r\n  ): void {\r\n    Object.keys(this.requestPool).forEach((type: string) => {\r\n      const requestType = this.requestPool[type];\r\n      Object.keys(requestType).forEach((priority) => {\r\n        requestType[priority] = requestType[priority].filter(\r\n          (requestDetails: RequestDetailsInterface) => {\r\n            return filterFunction(requestDetails);\r\n          }\r\n        );\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Clears the requests specific to the provided type. For instance, the\r\n   * pool of requests of type 'interaction' can be cleared via this function.\r\n   *\r\n   *\r\n   * @param type - category of the request (either interaction, prefetch or thumbnail)\r\n   */\r\n  public clearRequestStack(type: string): void {\r\n    if (!this.requestPool[type]) {\r\n      throw new Error(`No category for the type ${type} found`);\r\n    }\r\n    this.requestPool[type] = { 0: [] };\r\n  }\r\n\r\n  private sendRequests(type) {\r\n    const requestsToSend = this.maxNumRequests[type] - this.numRequests[type];\r\n    let syncImageCount = 0;\r\n\r\n    for (let i = 0; i < requestsToSend; i++) {\r\n      const requestDetails = this.getNextRequest(type);\r\n      if (requestDetails === null) {\r\n        return false;\r\n      } else if (requestDetails) {\r\n        this.numRequests[type]++;\r\n        this.awake = true;\r\n\r\n        let requestResult;\r\n        try {\r\n          requestResult = requestDetails.requestFn();\r\n        } catch (e) {\r\n          // This is the only warning one will get, so need a warn message\r\n          console.warn('sendRequest failed', e);\r\n        }\r\n        if (requestResult?.finally) {\r\n          requestResult.finally(() => {\r\n            this.numRequests[type]--;\r\n            this.startAgain();\r\n          });\r\n        } else {\r\n          // Handle non-async request functions too - typically just short circuit ones\r\n          this.numRequests[type]--;\r\n          syncImageCount++;\r\n        }\r\n      }\r\n    }\r\n    if (syncImageCount) {\r\n      this.startAgain();\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private getNextRequest(type): RequestDetailsInterface | null {\r\n    const interactionPriorities = this.getSortedPriorityGroups(type);\r\n    for (const priority of interactionPriorities) {\r\n      if (this.requestPool[type][priority].length) {\r\n        return this.requestPool[type][priority].shift();\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  protected startGrabbing(): void {\r\n    const hasRemainingInteractionRequests = this.sendRequests(\r\n      RequestType.Interaction\r\n    );\r\n    const hasRemainingThumbnailRequests = this.sendRequests(\r\n      RequestType.Thumbnail\r\n    );\r\n    const hasRemainingPrefetchRequests = this.sendRequests(\r\n      RequestType.Prefetch\r\n    );\r\n    const hasRemainingComputeRequests = this.sendRequests(RequestType.Compute);\r\n\r\n    if (\r\n      !hasRemainingInteractionRequests &&\r\n      !hasRemainingThumbnailRequests &&\r\n      !hasRemainingPrefetchRequests &&\r\n      !hasRemainingComputeRequests\r\n    ) {\r\n      this.awake = false;\r\n    }\r\n  }\r\n\r\n  protected startAgain(): void {\r\n    if (!this.awake) {\r\n      return;\r\n    }\r\n\r\n    if (this.grabDelay !== undefined) {\r\n      // Prevents calling setTimeout hundreds of times when hundreds of requests\r\n      // are added which make it slower and works in an unexpected way when\r\n      // destroy/clearTimeout is called because only the last handle is stored.\r\n      if (!this.timeoutHandle) {\r\n        this.timeoutHandle = window.setTimeout(() => {\r\n          this.timeoutHandle = null;\r\n          this.startGrabbing();\r\n        }, this.grabDelay);\r\n      }\r\n    } else {\r\n      this.startGrabbing();\r\n    }\r\n  }\r\n\r\n  protected getSortedPriorityGroups(type: string): Array<number> {\r\n    const priorities = Object.keys(this.requestPool[type])\r\n      .map(Number)\r\n      .filter((priority) => this.requestPool[type][priority].length)\r\n      .sort((a, b) => a - b);\r\n    return priorities;\r\n  }\r\n\r\n  /**\r\n   * Returns the request pool containing different categories, their priority and\r\n   * the added request details.\r\n   *\r\n   * @returns the request pool which contains different categories, their priority and\r\n   * the added request details\r\n   */\r\n  getRequestPool(): RequestPool {\r\n    return this.requestPool;\r\n  }\r\n}\r\n\r\nexport { RequestPoolManager };\r\n","import cache, { ImageVolume } from '../cache';\r\nimport { Events } from '../enums';\r\nimport eventTarget from '../eventTarget';\r\nimport { getConfiguration, getShouldUseSharedArrayBuffer } from '../init';\r\n\r\n/**\r\n * This function will check if the cache optimization is enabled and if it is\r\n * it will check if the created volume was derived from an already cached stack\r\n * of images, if so it will go back to the image cache and create a view at the\r\n * correct offset of the bigger volume array buffer, this will save memory.\r\n *\r\n * @param volumeId - The volumeId that will be checked for cache optimization\r\n */\r\nexport function setupCacheOptimizationEventListener(volumeId) {\r\n  const { enableCacheOptimization } = getConfiguration();\r\n  const shouldUseSAB = getShouldUseSharedArrayBuffer();\r\n\r\n  const performOptimization = enableCacheOptimization && shouldUseSAB;\r\n  if (!performOptimization) {\r\n    return;\r\n  }\r\n\r\n  eventTarget.addEventListenerOnce(\r\n    Events.IMAGE_VOLUME_LOADING_COMPLETED,\r\n    (evt) => {\r\n      if (evt.detail.volumeId !== volumeId) {\r\n        return;\r\n      }\r\n\r\n      const volume = cache.getVolume(volumeId);\r\n\r\n      performCacheOptimizationForVolume(volume);\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Performs cache optimization for a volume by replacing the pixel data of each image\r\n * in the image cache (if found) with a view of the volume's scalar data.\r\n * @param options - The options for cache optimization.\r\n * @param options.volumeId - The ID of the volume.\r\n */\r\nexport function performCacheOptimizationForVolume(volume) {\r\n  if (!(volume instanceof ImageVolume)) {\r\n    return;\r\n  }\r\n\r\n  const scalarData = volume.getScalarData();\r\n\r\n  volume.imageCacheOffsetMap.size > 0\r\n    ? _processImageCacheOffsetMap(volume, scalarData)\r\n    : _processVolumeImages(volume, scalarData);\r\n}\r\n\r\n/**\r\n * This function will process the volume images and replace the pixel data of each\r\n * image in the image cache (if found) with a view of the volume's scalar data.\r\n * This function is used when the volume is derived from an already cached stack\r\n * of images.\r\n *\r\n * @param volume - The volume to process.\r\n * @param scalarData - The scalar data to use for the volume.\r\n */\r\nfunction _processImageCacheOffsetMap(volume, scalarData) {\r\n  volume.imageCacheOffsetMap.forEach(({ offset }, imageId) => {\r\n    const image = cache.getImage(imageId);\r\n    if (!image) {\r\n      return;\r\n    }\r\n\r\n    _updateImageWithScalarDataView(image, scalarData, offset);\r\n    cache.decrementImageCacheSize(image.sizeInBytes);\r\n  });\r\n}\r\n\r\n/**\r\n * This function will process the volume images and replace the pixel data of each\r\n * image in the image cache (if found) with a view of the volume's scalar data.\r\n * This function is used when the volume is not derived from an already cached stack\r\n * of images.\r\n *\r\n * @param volume - The volume to process.\r\n * @param scalarData - The scalar data to use for the volume.\r\n */\r\nfunction _processVolumeImages(volume, scalarData) {\r\n  let compatibleScalarData = scalarData;\r\n\r\n  const sampleImageIdWithImage = volume.imageIds.find((imageId) => {\r\n    const image = cache.getImage(imageId);\r\n    return image;\r\n  });\r\n\r\n  if (!sampleImageIdWithImage) {\r\n    return;\r\n  }\r\n\r\n  const sampleImage = cache.getImage(sampleImageIdWithImage);\r\n  const samplePixelData =\r\n    sampleImage.imageFrame?.pixelData || sampleImage.getPixelData();\r\n\r\n  // Check if the types of scalarData and pixelData are different.\r\n  if (scalarData.constructor !== samplePixelData.constructor) {\r\n    // If so, create a new typed array of the same type as pixelData and copy the values from scalarData.\r\n    compatibleScalarData = new samplePixelData.constructor(scalarData.length);\r\n\r\n    // Copy values from scalarData to compatibleScalarData.\r\n    compatibleScalarData.set(scalarData);\r\n  }\r\n\r\n  volume.imageIds.forEach((imageId) => {\r\n    const image = cache.getImage(imageId);\r\n    if (!image) {\r\n      return;\r\n    }\r\n\r\n    const index = volume.getImageIdIndex(imageId);\r\n    const offset = index * image.getPixelData().byteLength;\r\n\r\n    _updateImageWithScalarDataView(image, compatibleScalarData, offset);\r\n    cache.decrementImageCacheSize(image.sizeInBytes);\r\n  });\r\n}\r\n\r\nfunction _updateImageWithScalarDataView(image, scalarData, offset) {\r\n  const pixelData = image.imageFrame\r\n    ? image.imageFrame.pixelData\r\n    : image.getPixelData();\r\n\r\n  const view = new pixelData.constructor(\r\n    scalarData.buffer,\r\n    offset,\r\n    pixelData.length\r\n  );\r\n\r\n  image.getPixelData = () => view;\r\n\r\n  if (image.imageFrame) {\r\n    image.imageFrame.pixelData = view;\r\n  }\r\n\r\n  image.bufferView = {\r\n    buffer: scalarData.buffer,\r\n    offset,\r\n  };\r\n}\r\n","import vtkColorMaps from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\r\n\r\nimport { ColormapPublic, ColormapRegistration } from '../types';\r\nimport isEqual from './isEqual';\r\nimport { actorIsA } from './actorCheck';\r\n\r\nconst _colormaps = new Map();\r\n\r\n/**\r\n * Register a colormap\r\n * @param name - name of the colormap\r\n * @param colormap - colormap object\r\n */\r\nfunction registerColormap(colormap: ColormapRegistration) {\r\n  _colormaps.set(colormap.Name, colormap);\r\n}\r\n\r\n/**\r\n * Get a colormap by name\r\n * @param name - name of the colormap\r\n * @returns colormap object\r\n */\r\nfunction getColormap(name) {\r\n  return _colormaps.get(name);\r\n}\r\n\r\n/**\r\n * Get all registered colormap names\r\n * @returns array of colormap names\r\n *\r\n */\r\nfunction getColormapNames() {\r\n  return Array.from(_colormaps.keys());\r\n}\r\n\r\n/**\r\n * Finds a colormap that matches the given RGB points.\r\n *\r\n * @param rgbPoints - The RGB points to match against the colormaps.\r\n * @returns  The matched colormap object or null if no match is found.\r\n */\r\nfunction findMatchingColormap(rgbPoints, actor): ColormapPublic | null {\r\n  const colormapsVTK = vtkColorMaps.rgbPresetNames.map((presetName) =>\r\n    vtkColorMaps.getPresetByName(presetName)\r\n  );\r\n\r\n  const colormapsCS3D = getColormapNames().map((colormapName) =>\r\n    getColormap(colormapName)\r\n  );\r\n\r\n  const colormaps = colormapsVTK.concat(colormapsCS3D);\r\n\r\n  // Find the colormap that matches the given RGB points\r\n  const matchedColormap = colormaps.find((colormap) => {\r\n    const { RGBPoints: presetRGBPoints } = colormap;\r\n\r\n    if (presetRGBPoints.length !== rgbPoints.length) {\r\n      return false;\r\n    }\r\n\r\n    for (let i = 0; i < presetRGBPoints.length; i += 4) {\r\n      if (\r\n        !isEqual(\r\n          presetRGBPoints.slice(i + 1, i + 4),\r\n          rgbPoints.slice(i + 1, i + 4)\r\n        )\r\n      ) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  });\r\n\r\n  if (!matchedColormap) {\r\n    return null;\r\n  }\r\n\r\n  const opacity = [];\r\n  if (actorIsA(actor, 'vtkVolume')) {\r\n    const opacityPoints = actor\r\n      .getProperty()\r\n      .getScalarOpacity(0)\r\n      .getDataPointer();\r\n\r\n    if (!opacityPoints) {\r\n      return {\r\n        name: matchedColormap.Name,\r\n      };\r\n    }\r\n\r\n    for (let i = 0; i < opacityPoints.length; i += 2) {\r\n      opacity.push({\r\n        value: opacityPoints[i],\r\n        opacity: opacityPoints[i + 1],\r\n      });\r\n    }\r\n  }\r\n\r\n  return {\r\n    name: matchedColormap.Name,\r\n    opacity,\r\n  };\r\n}\r\n\r\nexport {\r\n  getColormap,\r\n  getColormapNames,\r\n  registerColormap,\r\n  findMatchingColormap,\r\n};\r\n","import vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\r\nimport { VOIRange } from '../types';\r\n\r\nexport default function createLinearRGBTransferFunction(\r\n  voiRange: VOIRange\r\n): vtkColorTransferFunction {\r\n  const cfun = vtkColorTransferFunction.newInstance();\r\n  let lower = 0;\r\n  let upper = 1024;\r\n  if (\r\n    voiRange &&\r\n    voiRange.lower !== undefined &&\r\n    voiRange.upper !== undefined\r\n  ) {\r\n    lower = voiRange.lower;\r\n    upper = voiRange.upper;\r\n  }\r\n  cfun.addRGBPoint(lower, 0.0, 0.0, 0.0);\r\n  cfun.addRGBPoint(upper, 1.0, 1.0, 1.0);\r\n\r\n  return cfun;\r\n}\r\n","import { ImageSliceData, IVolumeViewport, VolumeActor } from '../types';\r\nimport getSliceRange from './getSliceRange';\r\nimport getTargetVolumeAndSpacingInNormalDir from './getTargetVolumeAndSpacingInNormalDir';\r\n\r\n/**\r\n * It calculates the number of slices and the current slice index for a given\r\n * Volume viewport\r\n * @param viewport - volume viewport\r\n * @returns An object with two properties: numberOfSlices and imageIndex.\r\n */\r\nfunction getImageSliceDataForVolumeViewport(\r\n  viewport: IVolumeViewport\r\n): ImageSliceData {\r\n  const camera = viewport.getCamera();\r\n\r\n  const { spacingInNormalDirection, imageVolume } =\r\n    getTargetVolumeAndSpacingInNormalDir(viewport, camera);\r\n\r\n  if (!imageVolume) {\r\n    return;\r\n  }\r\n\r\n  const { viewPlaneNormal, focalPoint } = camera;\r\n\r\n  const actorEntry = viewport\r\n    .getActors()\r\n    .find(\r\n      (a) =>\r\n        a.referenceId === imageVolume.volumeId || a.uid === imageVolume.volumeId\r\n    );\r\n\r\n  if (!actorEntry) {\r\n    console.warn('No actor found for with actorUID of', imageVolume.volumeId);\r\n  }\r\n\r\n  const volumeActor = actorEntry.actor as VolumeActor;\r\n  const sliceRange = getSliceRange(volumeActor, viewPlaneNormal, focalPoint);\r\n\r\n  const { min, max, current } = sliceRange;\r\n\r\n  // calculate number of steps from min to max with current normal spacing in direction\r\n  const numberOfSlices = Math.round((max - min) / spacingInNormalDirection) + 1;\r\n\r\n  // calculate the imageIndex based on min, max, current\r\n  let imageIndex = ((current - min) / (max - min)) * numberOfSlices;\r\n  imageIndex = Math.floor(imageIndex);\r\n\r\n  // Clamp imageIndex\r\n  if (imageIndex > numberOfSlices - 1) {\r\n    imageIndex = numberOfSlices - 1;\r\n  } else if (imageIndex < 0) {\r\n    imageIndex = 0;\r\n  }\r\n\r\n  return {\r\n    numberOfSlices,\r\n    imageIndex,\r\n  };\r\n}\r\n\r\nexport default getImageSliceDataForVolumeViewport;\r\n","function getTransferFunctionNodes(transferFunction) {\r\n  const size = transferFunction.getSize();\r\n  const values = [];\r\n  for (let index = 0; index < size; index++) {\r\n    const nodeValue1 = [];\r\n\r\n    transferFunction.getNodeValue(index, nodeValue1);\r\n\r\n    values.push(nodeValue1);\r\n  }\r\n\r\n  return values;\r\n}\r\n\r\nfunction setTransferFunctionNodes(transferFunction, nodes) {\r\n  if (!nodes?.length) {\r\n    return;\r\n  }\r\n\r\n  transferFunction.removeAllPoints();\r\n\r\n  nodes.forEach((node) => {\r\n    transferFunction.addRGBPoint(...node);\r\n  });\r\n}\r\n\r\nexport { getTransferFunctionNodes, setTransferFunctionNodes };\r\n","import type Point3 from '../types/Point3';\r\n\r\n/**\r\n * Given an imageData object and a point in physical space, return the index of the\r\n * voxel that contains the point. TODO: this should be pushed to vtk upstream.\r\n * @param imageData - The image data object.\r\n * @param physicalPoint - The point in physical space that you want to transform to\r\n * index space.\r\n * @returns An array of integers.\r\n */\r\nexport default function transformWorldToIndex(imageData, worldPos: Point3) {\r\n  const continuousIndex = imageData.worldToIndex(worldPos);\r\n  const index = continuousIndex.map(Math.round);\r\n\r\n  return index;\r\n}\r\n","import eventTarget from '../eventTarget';\r\n\r\n/**\r\n * Small utility to trigger a custom event for a given EventTarget.\r\n *\r\n * @example\r\n *\r\n * ```javascript\r\n * triggerEvent(element, Events.IMAGE_RENDERED, { element })\r\n * ```\r\n * or it can trigger event on the eventTarget itself\r\n *\r\n * ```javascript\r\n * triggerEvent(eventTarget, CSTOOLS_EVENTS.ANNOTATION_MODIFIED, { viewportId, annotationUID })\r\n * ```\r\n *\r\n * @param el - The element or EventTarget to trigger the event upon\r\n * @param type - The event type name\r\n * @param detail - The event detail to be sent\r\n * @returns false if event is cancelable and at least one of the event handlers\r\n * which received event called Event.preventDefault(). Otherwise it returns true.\r\n */\r\nexport default function triggerEvent(\r\n  el: EventTarget = eventTarget,\r\n  type: string,\r\n  detail: unknown = null\r\n): boolean {\r\n  if (!type) {\r\n    throw new Error('Event type was not defined');\r\n  }\r\n\r\n  const event = new CustomEvent(type, {\r\n    detail,\r\n    cancelable: true,\r\n  });\r\n\r\n  return el.dispatchEvent(event);\r\n}\r\n","import * as Comlink from 'comlink';\r\nimport { RequestType } from '../enums/';\r\nimport { RequestPoolManager } from '../requestPool/requestPoolManager';\r\n\r\nclass CentralizedWorkerManager {\r\n  constructor() {\r\n    this.workerRegistry = {};\r\n    this.workerPoolManager = new RequestPoolManager('webworker');\r\n  }\r\n\r\n  /**\r\n   * Registers a new worker, it doesn't mean that the function will get executed.\r\n   *\r\n   * @param workerName - The name of the worker.\r\n   * @param workerFn - The function that creates a new instance of the worker.\r\n   * @param options - Optional parameters.\r\n   * @param options.maxWorkerInstances - The maximum number of instances of this worker that can be created.\r\n   * For instance if you create a worker with maxWorkerInstances = 2, then only 2 instances of this worker will be created\r\n   * and in case there are 10 tasks that need to be executed, each will get assigned 5 tasks.\r\n   * @param options.overwrite - Whether to overwrite the worker if it's already registered.\r\n   * @param options.autoTerminateOnIdle - Whether to automatically terminate idle workers.\r\n   */\r\n  registerWorker(workerName, workerFn, options = {}) {\r\n    const {\r\n      maxWorkerInstances = 1,\r\n      overwrite = false,\r\n      autoTerminateOnIdle = {\r\n        enabled: false,\r\n        idleTimeThreshold: 3000, // 3 seconds\r\n      },\r\n    } = options;\r\n\r\n    if (this.workerRegistry[workerName] && !overwrite) {\r\n      console.warn(`Worker type '${workerName}' is already registered...`);\r\n      return;\r\n    }\r\n\r\n    if (overwrite && this.workerRegistry[workerName]?.idleCheckIntervalId) {\r\n      clearInterval(this.workerRegistry[workerName].idleCheckIntervalId);\r\n    }\r\n\r\n    const workerProperties = {\r\n      workerFn: null,\r\n      instances: [],\r\n      loadCounters: [],\r\n      lastActiveTime: [],\r\n      // used for termination\r\n      nativeWorkers: [],\r\n      // auto termination\r\n      autoTerminateOnIdle: autoTerminateOnIdle.enabled,\r\n      idleCheckIntervalId: null,\r\n      idleTimeThreshold: autoTerminateOnIdle.idleTimeThreshold,\r\n    };\r\n\r\n    workerProperties.loadCounters = Array(maxWorkerInstances).fill(0);\r\n    workerProperties.lastActiveTime = Array(maxWorkerInstances).fill(null);\r\n\r\n    for (let i = 0; i < maxWorkerInstances; i++) {\r\n      const worker = workerFn();\r\n      workerProperties.instances.push(Comlink.wrap(worker));\r\n      workerProperties.nativeWorkers.push(worker);\r\n      workerProperties.workerFn = workerFn;\r\n    }\r\n\r\n    this.workerRegistry[workerName] = workerProperties;\r\n  }\r\n\r\n  getNextWorkerAPI(workerName) {\r\n    const workerProperties = this.workerRegistry[workerName];\r\n\r\n    if (!workerProperties) {\r\n      console.error(`Worker type '${workerName}' is not registered.`);\r\n      return null;\r\n    }\r\n\r\n    // Find the worker with the minimum load.\r\n    const workerInstances = workerProperties.instances.filter(\r\n      (instance) => instance !== null\r\n    );\r\n\r\n    let minLoadIndex = 0;\r\n    let minLoadValue = workerProperties.loadCounters[0] || 0;\r\n    for (let i = 1; i < workerInstances.length; i++) {\r\n      const currentLoadValue = workerProperties.loadCounters[i] || 0;\r\n      if (currentLoadValue < minLoadValue) {\r\n        minLoadIndex = i;\r\n        minLoadValue = currentLoadValue;\r\n      }\r\n    }\r\n\r\n    // Check and recreate the worker if it was terminated.\r\n    if (workerProperties.instances[minLoadIndex] === null) {\r\n      const worker = workerProperties.workerFn();\r\n      workerProperties.instances[minLoadIndex] = Comlink.wrap(worker);\r\n      workerProperties.nativeWorkers[minLoadIndex] = worker;\r\n    }\r\n\r\n    // Update the load counter.\r\n    workerProperties.loadCounters[minLoadIndex] += 1;\r\n\r\n    // return the worker that has the minimum load.\r\n    return {\r\n      api: workerProperties.instances[minLoadIndex],\r\n      index: minLoadIndex,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Executes a task on a worker.\r\n   *\r\n   * @param workerName - The name of the worker to execute the task on.\r\n   * @param methodName - The name of the method to execute on the worker.\r\n   * @param args - The arguments to pass to the method. Default is an array\r\n   * You should put your transferable objects in the first argument as object\r\n   * and from the second argument you can put your non-transferable objects such\r\n   * as functions, classes, etc.\r\n   * @param options - An object containing options for the request. Default is an empty object.\r\n   * @param options.requestType - The type of the request. Default is RequestType.Compute.\r\n   * @param options.priority - The priority of the request. Default is 0.\r\n   * @param options.options - Additional options for the request. Default is an empty object.\r\n   *\r\n   * @returns A promise that resolves with the result of the task.\r\n   */\r\n  executeTask(\r\n    workerName,\r\n    methodName,\r\n    args = {},\r\n    {\r\n      requestType = RequestType.Compute,\r\n      priority = 0,\r\n      options = {},\r\n      callbacks = [],\r\n    } = {}\r\n  ) {\r\n    return new Promise((resolve, reject) => {\r\n      const requestFn = async () => {\r\n        const { api, index } = this.getNextWorkerAPI(workerName);\r\n        if (!api) {\r\n          const error = new Error(\r\n            `No available worker instance for '${workerName}'`\r\n          );\r\n          console.error(error);\r\n          reject(error);\r\n          return;\r\n        }\r\n\r\n        try {\r\n          // fix if any of the args keys are a function then we need to proxy it\r\n          // for the worker to be able to call it\r\n          let finalCallbacks = [];\r\n          if (callbacks.length) {\r\n            finalCallbacks = callbacks.map((cb) => {\r\n              return Comlink.proxy(cb);\r\n            });\r\n          }\r\n          const workerProperties = this.workerRegistry[workerName];\r\n\r\n          workerProperties.processing = true;\r\n\r\n          const results = await api[methodName](args, ...finalCallbacks);\r\n\r\n          workerProperties.processing = false;\r\n          workerProperties.lastActiveTime[index] = Date.now();\r\n\r\n          // If auto termination is enabled and the interval is not set, set it.\r\n          if (\r\n            workerProperties.autoTerminateOnIdle &&\r\n            !workerProperties.idleCheckIntervalId &&\r\n            workerProperties.idleTimeThreshold\r\n          ) {\r\n            workerProperties.idleCheckIntervalId = setInterval(() => {\r\n              this.terminateIdleWorkers(\r\n                workerName,\r\n                workerProperties.idleTimeThreshold\r\n              );\r\n            }, workerProperties.idleTimeThreshold);\r\n          }\r\n\r\n          resolve(results);\r\n        } catch (err) {\r\n          console.error(\r\n            `Error executing method '${methodName}' on worker '${workerName}':`,\r\n            err\r\n          );\r\n          reject(err);\r\n        } finally {\r\n          this.workerRegistry[workerName].loadCounters[index]--;\r\n        }\r\n      };\r\n\r\n      // I believe there is a bug right now, where if there are two workers\r\n      // and one wants to run a compute job 6 times and the limit is just 5, then\r\n      // the other worker will never get a chance to run its compute job.\r\n      // we should probably have a separate limit for compute jobs per worker\r\n      // context as there is another layer of parallelism there.\r\n      this.workerPoolManager.addRequest(\r\n        requestFn,\r\n        requestType,\r\n        options,\r\n        priority\r\n      );\r\n    });\r\n  }\r\n\r\n  terminateIdleWorkers(workerName, idleTimeThreshold) {\r\n    const workerProperties = this.workerRegistry[workerName];\r\n\r\n    if (workerProperties.processing) {\r\n      return;\r\n    }\r\n\r\n    const now = Date.now();\r\n\r\n    workerProperties.instances.forEach((_, index) => {\r\n      const lastActiveTime = workerProperties.lastActiveTime[index];\r\n      const isWorkerActive =\r\n        lastActiveTime !== null && workerProperties.loadCounters[index] > 0;\r\n      const idleTime = now - lastActiveTime;\r\n\r\n      if (!isWorkerActive && idleTime > idleTimeThreshold) {\r\n        this.terminateWorkerInstance(workerName, index);\r\n      }\r\n    });\r\n  }\r\n\r\n  terminate(workerName) {\r\n    const workerProperties = this.workerRegistry[workerName];\r\n    if (!workerProperties) {\r\n      console.error(`Worker type '${workerName}' is not registered.`);\r\n      return;\r\n    }\r\n\r\n    workerProperties.instances.forEach((_, index) => {\r\n      this.terminateWorkerInstance(workerName, index);\r\n    });\r\n  }\r\n\r\n  // New method to handle individual worker termination\r\n  terminateWorkerInstance(workerName, index) {\r\n    const workerProperties = this.workerRegistry[workerName];\r\n    const workerInstance = workerProperties.instances[index];\r\n\r\n    if (workerInstance !== null) {\r\n      workerInstance[Comlink.releaseProxy]();\r\n      workerProperties.nativeWorkers[index].terminate();\r\n\r\n      // Set the worker instance to null after termination\r\n      workerProperties.instances[index] = null;\r\n      workerProperties.lastActiveTime[index] = null;\r\n    }\r\n  }\r\n}\r\n\r\nexport default CentralizedWorkerManager;\r\n","import { SVGCursorDescriptor } from '../types';\r\n\r\n/*\r\n * Definitions\r\n */\r\n\r\nconst BASE: SVGCursorDescriptor = {\r\n  iconContent: '',\r\n  iconSize: 16,\r\n  viewBox: {\r\n    x: 16,\r\n    y: 16,\r\n  },\r\n  mousePoint: {\r\n    x: 8,\r\n    y: 8,\r\n  },\r\n  mousePointerGroupString: `\r\n    <path stroke=\"{{color}}\" d=\"M8 16L8 0\"></path>\r\n    <path stroke=\"{{color}}\" d=\"M16 8L0 8\"></path>\r\n  `,\r\n};\r\n\r\nconst SEGMENTATION_CURSOR_BOUNDARIES = {\r\n  x: 127,\r\n  y: 60,\r\n};\r\n\r\nconst MINUS_RECT = `\r\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\r\n`;\r\n\r\nconst PLUS_RECT = `\r\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\r\n<rect fill=\"{{color}}\" x=\"95.84\" y=\"9.38\" width=\"15.85\" height=\"47.14\"/>\r\n`;\r\n\r\nconst SCISSOR_ICON = `<path fill=\"{{color}}\" d=\"M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z\" transform=\"translate(-1.17 -0.96)\"/>`;\r\nconst RECTANGLE_ICON = `<path fill=\"{{color}}\" d=\"M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z\" transform=\"translate(-8.86 -2.25)\"/>`;\r\nconst CIRCLE_ICON = `<path fill=\"{{color}}\" d=\"M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z\" transform=\"translate(-8.86 -2.25)\"/>`;\r\n\r\nconst CursorSVG: Record<string, SVGCursorDescriptor> = {\r\n  Angle: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50\r\n    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23\r\n    10l50 50q10 10 10 23z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  ArrowAnnotate: extend(BASE, {\r\n    iconContent: `<g id=\"arrowAnnotate-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <path id=\"arrowAnnotate-arrow\" d=\"M23,7 l-15,15 M7,17 l0,6 6,0\" stroke-width=\"2\" />\r\n  </g>`,\r\n    viewBox: {\r\n      x: 24,\r\n      y: 24,\r\n    },\r\n  }),\r\n  Bidirectional: extend(BASE, {\r\n    iconContent: `<g fill=\"{{color}}\" stroke-width=\"3\" stroke=\"{{color}}\">\r\n    <path d=\"M27.63 3.21L3.12 28.81\"></path>\r\n    <path d=\"M27.63 15.75L15.27 4.43\"></path>\r\n    <path d=\"M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z\" ></path>\r\n    <path d=\"M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z\"></path>\r\n    <path d=\"M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z\"></path>\r\n    <path d=\"M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z\"></path>\r\n  </g>`,\r\n    viewBox: {\r\n      x: 48,\r\n      y: 48,\r\n    },\r\n  }),\r\n  CobbAngle: extend(BASE, {\r\n    iconContent: `<g stroke=\"{{color}}\" stroke-width=\"3\">\r\n    <path d=\"M28.59 2.34L3.82 12.32\"></path>\r\n    <path d=\"M28.59 29.66L3.82 19.68\"></path>\r\n    <path stroke-dasharray=\"2\" fill-opacity=\"0\" d=\"M12.37\r\n      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15\r\n      9.33C13.11 9.24 13.02 9 12.88 8.63\">\r\n    </path>\r\n  </g>`,\r\n    viewBox: {\r\n      x: 32,\r\n      y: 32,\r\n    },\r\n  }),\r\n  CircleROI: extend(BASE, {\r\n    iconContent: `<circle stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" cx=\"16\" cy=\"16\" r=\"14\" />`,\r\n    viewBox: {\r\n      x: 32,\r\n      y: 32,\r\n    },\r\n  }),\r\n  EllipticalROI: extend(BASE, {\r\n    iconContent: `<path stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" d=\"M30.74 15.76C30.74 20.99 24.14 25.23 16\r\n    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14\r\n    6.3 30.74 10.54 30.74 15.76Z\" />`,\r\n    viewBox: {\r\n      x: 32,\r\n      y: 32,\r\n    },\r\n  }),\r\n  FreehandROI: extend(BASE, {\r\n    iconContent: `<g fill=\"{{color}}\" stroke=\"{{color}}\" stroke-width=\"2\">\r\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_3\" cy=\"4.240343\" cx=\"14.306499\"/>\r\n    <line id=\"svg_4\" y2=\"3.58462\" x2=\"12.242186\" y1=\"3.997482\" x1=\"13.432202\"/>\r\n    <line id=\"svg_5\" y2=\"3.268901\" x2=\"10.857882\" y1=\"3.608906\" x1=\"12.387902\"/>\r\n    <line id=\"svg_6\" y2=\"3.147471\" x2=\"9.740724\" y1=\"3.293187\" x1=\"10.955026\"/>\r\n    <line id=\"svg_7\" y2=\"3.147471\" x2=\"8.089274\" y1=\"3.196043\" x1=\"9.983585\"/>\r\n    <line id=\"svg_8\" y2=\"3.268901\" x2=\"6.874972\" y1=\"3.123185\" x1=\"8.307848\"/>\r\n    <line id=\"svg_9\" y2=\"3.657478\" x2=\"5.587812\" y1=\"3.220329\" x1=\"7.020688\"/>\r\n    <line id=\"svg_10\" y2=\"4.046054\" x2=\"4.737801\" y1=\"3.560334\" x1=\"5.854959\"/>\r\n    <line id=\"svg_11\" y2=\"4.337487\" x2=\"4.300652\" y1=\"3.997482\" x1=\"4.834945\"/>\r\n    <line id=\"svg_12\" y2=\"4.726063\" x2=\"3.88779\" y1=\"4.191771\" x1=\"4.470655\"/>\r\n    <line id=\"svg_15\" y2=\"5.3575\" x2=\"3.377783\" y1=\"4.604633\" x1=\"3.960648\"/>\r\n    <line id=\"svg_16\" y2=\"6.183226\" x2=\"2.916348\" y1=\"5.138926\" x1=\"3.547785\"/>\r\n    <line id=\"svg_17\" y2=\"6.960379\" x2=\"2.770632\" y1=\"5.867507\" x1=\"3.037779\"/>\r\n    <line id=\"svg_18\" y2=\"7.713246\" x2=\"2.673488\" y1=\"6.741804\" x1=\"2.819204\"/>\r\n    <line id=\"svg_19\" y2=\"8.684687\" x2=\"2.697774\" y1=\"7.616102\" x1=\"2.673488\"/>\r\n    <line id=\"svg_20\" y2=\"9.753273\" x2=\"2.892062\" y1=\"8.611829\" x1=\"2.697774\"/>\r\n    <line id=\"svg_21\" y2=\"10.724714\" x2=\"3.134923\" y1=\"9.534698\" x1=\"2.84349\"/>\r\n    <line id=\"svg_23\" y2=\"11.647583\" x2=\"3.596357\" y1=\"10.578998\" x1=\"3.086351\"/>\r\n    <line id=\"svg_25\" y2=\"12.521881\" x2=\"4.276366\" y1=\"11.501867\" x1=\"3.499213\"/>\r\n    <line id=\"svg_26\" y2=\"13.930471\" x2=\"5.830673\" y1=\"12.376165\" x1=\"4.13065\"/>\r\n    <line id=\"svg_28\" y2=\"14.707624\" x2=\"7.263549\" y1=\"13.881899\" x1=\"5.733528\"/>\r\n    <line id=\"svg_29\" y2=\"15.339061\" x2=\"8.963571\" y1=\"14.61048\" x1=\"7.06926\"/>\r\n    <line id=\"svg_30\" y2=\"15.581921\" x2=\"10.882168\" y1=\"15.314775\" x1=\"8.817855\"/>\r\n    <line id=\"svg_31\" y2=\"15.460491\" x2=\"12.023612\" y1=\"15.581921\" x1=\"10.785024\"/>\r\n    <line id=\"svg_33\" y2=\"15.120487\" x2=\"13.092197\" y1=\"15.484777\" x1=\"11.877895\"/>\r\n    <line id=\"svg_34\" y2=\"14.586194\" x2=\"13.86935\" y1=\"15.217631\" x1=\"12.897909\"/>\r\n    <line id=\"svg_35\" y2=\"13.833327\" x2=\"14.597931\" y1=\"14.756196\" x1=\"13.699348\"/>\r\n    <line id=\"svg_37\" y2=\"12.716169\" x2=\"15.180796\" y1=\"13.881899\" x1=\"14.549359\"/>\r\n    <line id=\"svg_39\" y2=\"11.429009\" x2=\"15.520801\" y1=\"12.813313\" x1=\"15.15651\"/>\r\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_40\" cy=\"10.967574\" cx=\"15.520801\"/>\r\n  </g>`,\r\n    viewBox: {\r\n      x: 18,\r\n      y: 18,\r\n    },\r\n  }),\r\n  FreehandROISculptor: extend(BASE, {\r\n    iconContent: `<g id=\"icon-freehand-sculpt\" fill=\"none\" stroke-width=\"1.5\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <line id=\"svg_1\" y2=\"2.559367\" x2=\"10.184807\" y1=\"4.467781\" x1=\"8.81711\"/>\r\n    <line id=\"svg_4\" y2=\"1.493836\" x2=\"11.727442\" y1=\"2.766112\" x1=\"10.089386\"/>\r\n    <line id=\"svg_7\" y2=\"1.080346\" x2=\"13.047428\" y1=\"1.748291\" x1=\"11.345759\"/>\r\n    <line id=\"svg_8\" y2=\"1.000829\" x2=\"14.351511\" y1=\"1.112153\" x1=\"12.77707\"/>\r\n    <line id=\"svg_9\" y2=\"1.350705\" x2=\"15.242104\" y1=\"0.905408\" x1=\"13.969828\"/>\r\n    <line id=\"svg_10\" y2=\"2.098167\" x2=\"15.862339\" y1=\"1.14396\" x1=\"14.955842\"/>\r\n    <line id=\"svg_11\" y2=\"3.195505\" x2=\"16.41896\" y1=\"1.939133\" x1=\"15.766918\"/>\r\n    <line id=\"svg_12\" y2=\"4.292843\" x2=\"16.530284\" y1=\"2.925147\" x1=\"16.387153\"/>\r\n    <line id=\"svg_16\" y2=\"5.644637\" x2=\"16.196311\" y1=\"3.831643\" x1=\"16.593898\"/>\r\n    <line id=\"svg_18\" y2=\"7.266789\" x2=\"15.623787\" y1=\"5.19934\" x1=\"16.275829\"/>\r\n    <line id=\"svg_19\" y2=\"10.813258\" x2=\"14.526449\" y1=\"6.726071\" x1=\"15.766918\"/>\r\n    <line id=\"svg_20\" y2=\"5.056209\" x2=\"8.085552\" y1=\"4.181519\" x1=\"8.976145\"/>\r\n    <line id=\"svg_23\" y2=\"5.326568\" x2=\"7.481221\" y1=\"4.78585\" x1=\"8.403621\"/>\r\n    <line id=\"svg_24\" y2=\"5.565119\" x2=\"6.749662\" y1=\"5.294761\" x1=\"7.624352\"/>\r\n    <line id=\"svg_25\" y2=\"5.994512\" x2=\"5.429675\" y1=\"5.533312\" x1=\"6.956407\"/>\r\n    <line id=\"svg_27\" y2=\"6.551133\" x2=\"4.284627\" y1=\"5.962706\" x1=\"5.572807\"/>\r\n    <line id=\"svg_28\" y2=\"7.584858\" x2=\"3.044158\" y1=\"6.392099\" x1=\"4.427758\"/>\r\n    <line id=\"svg_29\" y2=\"8.84123\" x2=\"2.185372\" y1=\"7.489437\" x1=\"3.219096\"/>\r\n    <line id=\"svg_31\" y2=\"10.606513\" x2=\"1.644654\" y1=\"8.602678\" x1=\"2.280792\"/>\r\n    <line id=\"svg_32\" y2=\"13.214679\" x2=\"1.48562\" y1=\"10.352058\" x1=\"1.724171\"/>\r\n    <line id=\"svg_33\" y2=\"14.375631\" x2=\"1.676461\" y1=\"12.992031\" x1=\"1.453813\"/>\r\n    <line id=\"svg_34\" y2=\"15.298031\" x2=\"2.264889\" y1=\"14.152983\" x1=\"1.517427\"/>\r\n    <line id=\"svg_35\" y2=\"16.172721\" x2=\"3.521261\" y1=\"14.948155\" x1=\"1.915013\"/>\r\n    <line id=\"svg_36\" y2=\"16.824762\" x2=\"5.207027\" y1=\"15.997783\" x1=\"3.28271\"/>\r\n    <line id=\"svg_38\" y2=\"17.063314\" x2=\"7.035924\" y1=\"16.745245\" x1=\"4.968475\"/>\r\n    <line id=\"svg_39\" y2=\"16.888376\" x2=\"9.278311\" y1=\"17.047411\" x1=\"6.733758\"/>\r\n    <line id=\"svg_40\" y2=\"16.284045\" x2=\"10.661911\" y1=\"16.983797\" x1=\"8.992048\"/>\r\n    <line id=\"svg_41\" y2=\"15.313934\" x2=\"11.647925\" y1=\"16.395369\" x1=\"10.455166\"/>\r\n    <line id=\"svg_44\" y2=\"13.898527\" x2=\"12.82478\" y1=\"15.425259\" x1=\"11.504794\"/>\r\n    <line id=\"svg_45\" y2=\"12.037824\" x2=\"14.144766\" y1=\"14.312017\" x1=\"12.522614\"/>\r\n    <line id=\"svg_47\" y2=\"10.59061\" x2=\"14.605966\" y1=\"12.228665\" x1=\"13.953925\"/>\r\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_48\" cy=\"3.982726\" cx=\"13.460918\"/>\r\n  </g>`,\r\n    viewBox: {\r\n      x: 18,\r\n      y: 18,\r\n    },\r\n  }),\r\n  Length: extend(BASE, {\r\n    iconContent: `<g id=\"length-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <path id=\"length-dashes\" d=\"m22.5,6 -16.5,16.5\" stroke-width=\"3\" stroke-dasharray=\"0.6666,5\" />\r\n  </g>`,\r\n    viewBox: {\r\n      x: 24,\r\n      y: 24,\r\n    },\r\n  }),\r\n  Probe: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75\r\n    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73\r\n    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5\r\n    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5\r\n    385.5-103 385.5 103 279.5 279.5 103 385.5z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  RectangleROI: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47\r\n    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0\r\n    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119\r\n    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  TextMarker: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M789 559l-170 450q33 0 136.5 2t160.5 2q19 0\r\n    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29\r\n    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15\r\n    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5\r\n    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0\r\n    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11\r\n    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0\r\n    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58\r\n    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  Crosshairs: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26\r\n    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45\r\n    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26\r\n    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5\r\n    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32\r\n    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5\r\n    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26\r\n    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26\r\n    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161\r\n    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161\r\n    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  Eraser: extend(BASE, {\r\n    iconContent: `<path transform=\"translate(0,1792) scale(1,-1)\" fill=\"{{color}}\" d=\"M960 1408l336-384h-768l-336 384h768zm1013-1077q15\r\n    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38\r\n    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38\r\n    0 69.5 20.5t47.5 54.5z\" />`,\r\n    viewBox: {\r\n      x: 2048,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  Magnify: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\r\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\r\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\r\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\r\n    32s176 78.7 176 176-78.7 176-176 176z\" />`,\r\n    viewBox: {\r\n      x: 512,\r\n      y: 512,\r\n    },\r\n  }),\r\n  Pan: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17\r\n    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355\r\n    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59\r\n    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12\r\n    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144\r\n    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19\r\n    45v448q0 42-39 59-13 5-25 5-26 0-45-19z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  Rotate: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39\r\n    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5\r\n    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0\r\n    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109\r\n    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298\r\n    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14\r\n    39 17 39 59z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  StackScroll: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547\r\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0\r\n    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547\r\n    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547\r\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z\" />`,\r\n    viewBox: {\r\n      x: 24,\r\n      y: 28,\r\n    },\r\n  }),\r\n  WindowLevelRegion: extend(BASE, {\r\n    iconContent: `<path fill=\"{{color}}\" d=\"M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119\r\n    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5\r\n    84.5t84.5 203.5z\" />`,\r\n    viewBox: {\r\n      x: 1792,\r\n      y: 1792,\r\n    },\r\n  }),\r\n  WindowLevel: extend(BASE, {\r\n    iconContent: `\r\n    <path fill=\"{{color}}\" d=\"M14.5,3.5 a1 1 0 0 1 -11,11 Z\" stroke=\"none\" opacity=\"0.8\" />\r\n    <circle cx=\"9\" cy=\"9\" r=\"8\" fill=\"none\" stroke-width=\"2\" stroke=\"{{color}}\" />`,\r\n    viewBox: {\r\n      x: 18,\r\n      y: 18,\r\n    },\r\n  }),\r\n  Zoom: extend(BASE, {\r\n    iconContent: `\r\n  <path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\r\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\r\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\r\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\r\n    32s176 78.7 176 176-78.7 176-176 176z\" />\r\n  <path fill=\"{{color}}\" transform=\"scale(0.22,0.22) translate(1400,0)\" d=\"M1216\r\n    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19\r\n    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26\r\n    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z\" />`,\r\n    viewBox: {\r\n      x: 640,\r\n      y: 512,\r\n    },\r\n  }),\r\n\r\n  /*\r\n   * Segmentation Cursors\r\n   */\r\n\r\n  SegmentationFreeHandEraseInside: extend(BASE, {\r\n    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  SegmentationFreeHandFillInside: extend(BASE, {\r\n    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  SegmentationFreeHandEraseOutside: extend(BASE, {\r\n    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  SegmentationFreeHandFillOutside: extend(BASE, {\r\n    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  SegmentationRectangleEraseInside: extend(BASE, {\r\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  // Default Rectangle Scissors\r\n  RectangleScissor: extend(BASE, {\r\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  'RectangleScissor.FILL_INSIDE': extend(BASE, {\r\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  'RectangleScissor.FILL_OUTSIDE': extend(BASE, {\r\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  'RectangleScissor.ERASE_OUTSIDE': extend(BASE, {\r\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  'RectangleScissor.ERASE_INSIDE': extend(BASE, {\r\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  CircleScissor: extend(BASE, {\r\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  'CircleScissor.FILL_INSIDE': extend(BASE, {\r\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  'CircleScissor.ERASE_OUTSIDE': extend(BASE, {\r\n    iconContent: `${CIRCLE_ICON} ${MINUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n\r\n  'CircleScissor.FILL_OUTSIDE': extend(BASE, {\r\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\r\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\r\n  }),\r\n};\r\n\r\n/*\r\n * Utils\r\n */\r\n\r\nfunction extend(\r\n  base: SVGCursorDescriptor,\r\n  values: Record<string, unknown>\r\n): SVGCursorDescriptor {\r\n  return Object.assign(Object.create(base), values);\r\n}\r\n\r\n/**\r\n * Registers a cursor to the list, so that it will be used for the given `toolName`.\r\n * Overwrites the given cursor if it is already set.\r\n *\r\n * @param toolName - The name of the tool to assign a cursor to.\r\n * @param iconContent - The SVG icon content of the cursor.\r\n * @param viewBox - The viewBox of the cursor object.\r\n */\r\nfunction registerCursor(\r\n  toolName: string,\r\n  iconContent: string,\r\n  viewBox: { x: number; y: number }\r\n) {\r\n  CursorSVG[toolName] = extend(BASE, {\r\n    iconContent,\r\n    viewBox,\r\n  });\r\n}\r\n\r\nfunction getDefinedSVGCursorDescriptor(\r\n  name: string\r\n): SVGCursorDescriptor | undefined {\r\n  return CursorSVG[name];\r\n}\r\n\r\n/*\r\n * Exports\r\n */\r\nconst svgCursorNames = Object.keys(CursorSVG);\r\n\r\nexport {\r\n  getDefinedSVGCursorDescriptor,\r\n  registerCursor,\r\n  svgCursorNames,\r\n  CursorSVG,\r\n};\r\n","import { state } from '../store';\r\nimport { getEnabledElement } from '@cornerstonejs/core';\r\nimport { SVGDrawingHelper } from '../types';\r\n\r\nconst VIEWPORT_ELEMENT = 'viewport-element';\r\n\r\n/**\r\n * Returns the SVG drawing helper for the given HTML element.\r\n * @param element - The HTML element to get the SVG drawing helper for.\r\n * @private\r\n */\r\nfunction getSvgDrawingHelper(element: HTMLDivElement): SVGDrawingHelper {\r\n  const enabledElement = getEnabledElement(element);\r\n  const { viewportId, renderingEngineId } = enabledElement;\r\n  const canvasHash = `${viewportId}:${renderingEngineId}`;\r\n  const svgLayerElement = _getSvgLayer(element);\r\n\r\n  // Reset touched\r\n  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\r\n    state.svgNodeCache[canvasHash][cacheKey].touched = false;\r\n  });\r\n\r\n  return {\r\n    svgLayerElement: svgLayerElement,\r\n    svgNodeCacheForCanvas: state.svgNodeCache,\r\n    getSvgNode: getSvgNode.bind(this, canvasHash),\r\n    appendNode: appendNode.bind(this, svgLayerElement, canvasHash),\r\n    setNodeTouched: setNodeTouched.bind(this, canvasHash),\r\n    clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash),\r\n  };\r\n}\r\n\r\n/**\r\n *\r\n * @param element\r\n * @private\r\n */\r\nfunction _getSvgLayer(element) {\r\n  const viewportElement = `.${VIEWPORT_ELEMENT}`;\r\n  const internalDivElement = element.querySelector(viewportElement);\r\n\r\n  // Using :scope to make sure the right svg layer is selected otherwise it\r\n  // may select one from a nested viewport (eg: AdvancedMagnifyTool).\r\n  const svgLayer = internalDivElement.querySelector(':scope > .svg-layer');\r\n\r\n  return svgLayer;\r\n}\r\n\r\nfunction getSvgNode(canvasHash, cacheKey) {\r\n  // If state has been reset\r\n  if (!state.svgNodeCache[canvasHash]) {\r\n    return;\r\n  }\r\n\r\n  if (state.svgNodeCache[canvasHash][cacheKey]) {\r\n    return state.svgNodeCache[canvasHash][cacheKey].domRef;\r\n  }\r\n}\r\n\r\nfunction appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {\r\n  // If state has been reset\r\n  if (!state.svgNodeCache[canvasHash]) {\r\n    return null;\r\n  }\r\n\r\n  state.svgNodeCache[canvasHash][cacheKey] = {\r\n    touched: true,\r\n    domRef: svgNode,\r\n  };\r\n\r\n  svgLayerElement.appendChild(svgNode);\r\n}\r\n\r\nfunction setNodeTouched(canvasHash, cacheKey) {\r\n  // If state has been reset\r\n  if (!state.svgNodeCache[canvasHash]) {\r\n    return;\r\n  }\r\n\r\n  if (state.svgNodeCache[canvasHash][cacheKey]) {\r\n    state.svgNodeCache[canvasHash][cacheKey].touched = true;\r\n  }\r\n}\r\n\r\nfunction clearUntouched(svgLayerElement, canvasHash) {\r\n  // If state has been reset\r\n  if (!state.svgNodeCache[canvasHash]) {\r\n    return;\r\n  }\r\n\r\n  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\r\n    const cacheEntry = state.svgNodeCache[canvasHash][cacheKey];\r\n\r\n    if (!cacheEntry.touched && cacheEntry.domRef) {\r\n      svgLayerElement.removeChild(cacheEntry.domRef);\r\n      delete state.svgNodeCache[canvasHash][cacheKey];\r\n    }\r\n  });\r\n}\r\n\r\nexport default getSvgDrawingHelper;\r\n","import getSvgDrawingHelper from './getSvgDrawingHelper';\r\n\r\nfunction draw(\r\n  element: HTMLDivElement,\r\n  fn: (svgDrawingElement: any) => any\r\n): void {\r\n  const svgDrawingHelper = getSvgDrawingHelper(element);\r\n\r\n  // Save...\r\n  fn(svgDrawingHelper);\r\n  // Restore...\r\n\r\n  svgDrawingHelper.clearUntouched();\r\n}\r\n\r\nexport default draw;\r\n","/**\r\n * ToolModes - This enum defines the 4 tool states which are available.\r\n */\r\nenum ToolModes {\r\n  /**\r\n   * Active:\r\n   * - Can be actively used by mouse/touch events mapped to its `ToolBinding`s.\r\n   * - Can add data if an annotation tool.\r\n   * - Can be passively interacted by grabbing a tool or its handles.\r\n   * - Renders data if the tool has a `renderAnnotation` method.\r\n   */\r\n  Active = 'Active',\r\n  /**\r\n   * Passive:\r\n   * - Can be passively interacted by grabbing a tool or its handles.\r\n   * - Renders data if the tool has a `renderAnnotation` method.\r\n   */\r\n  Passive = 'Passive',\r\n  /**\r\n   * Enabled:\r\n   * - Renders data if the tool has a `renderAnnotation` method.\r\n   */\r\n  Enabled = 'Enabled',\r\n  /**\r\n   * Disabled:\r\n   * - Annotation does not render.\r\n   */\r\n  Disabled = 'Disabled',\r\n}\r\n\r\nexport default ToolModes;\r\n","import { MouseBindings, ToolModes } from '../../enums';\r\nimport get from 'lodash.get';\r\nimport cloneDeep from 'lodash.clonedeep';\r\nimport {\r\n  triggerEvent,\r\n  eventTarget,\r\n  getRenderingEngine,\r\n  getRenderingEngines,\r\n  getEnabledElementByIds,\r\n  Settings,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport { Events } from '../../enums';\r\nimport {\r\n  ToolActivatedEventDetail,\r\n  ToolModeChangedEventDetail,\r\n} from '../../types/EventTypes';\r\nimport { ToolGroupManager, state } from '../index';\r\nimport {\r\n  IToolBinding,\r\n  IToolClassReference,\r\n  IToolGroup,\r\n  SetToolBindingsType,\r\n  ToolOptionsType,\r\n  ToolConfiguration,\r\n} from '../../types';\r\n\r\nimport { MouseCursor, SVGMouseCursor } from '../../cursors';\r\nimport { initElementCursor } from '../../cursors/elementCursor';\r\n\r\nconst { Active, Passive, Enabled, Disabled } = ToolModes;\r\n\r\nconst PRIMARY_BINDINGS = [{ mouseButton: MouseBindings.Primary }];\r\n\r\n/**\r\n * ToolGroup class which is a container for tools and their modes and states.\r\n * In Cornerstone3DTools, you need to create a tool group in order to use the\r\n * tools. ToolGroup is a way to share tool configuration, state (enabled, disabled, etc.)\r\n * across a set of viewports. Tools can set to be activated, enabled or disabled\r\n * in a toolGroup. You should not directly instantiate a ToolGroup. You need to use\r\n * ToolGroupManager helpers to create a new toolGroup or get a reference to an existing toolGroup.\r\n *\r\n * ```js\r\n * const toolGroup = csTools.ToolGroupManager.createToolGroup('toolGroupId')\r\n * ```\r\n */\r\nexport default class ToolGroup implements IToolGroup {\r\n  id: string;\r\n  viewportsInfo = [];\r\n  toolOptions = {};\r\n  currentActivePrimaryToolName: string | null = null;\r\n  prevActivePrimaryToolName: string | null = null;\r\n  /**\r\n   * Options used for restoring a tool\r\n   */\r\n  restoreToolOptions = {};\r\n  _toolInstances = {};\r\n\r\n  constructor(id: string) {\r\n    this.id = id;\r\n  }\r\n\r\n  /**\r\n   * Get the viewport IDs of all the viewports in the current viewport\r\n   * @returns An array of viewport IDs.\r\n   */\r\n  getViewportIds(): string[] {\r\n    return this.viewportsInfo.map(({ viewportId }) => viewportId);\r\n  }\r\n\r\n  /**\r\n   * Returns the toolGroup viewports info which is an array of {viewportId, renderingEngineId}\r\n   */\r\n  getViewportsInfo(): Array<Types.IViewportId> {\r\n    return this.viewportsInfo.slice();\r\n  }\r\n\r\n  /**\r\n   * Get the tool instance for a given tool name in the toolGroup\r\n   * @param toolName - The name of the tool.\r\n   * @returns A tool instance.\r\n   */\r\n  public getToolInstance(toolInstanceName: string) {\r\n    const toolInstance = this._toolInstances[toolInstanceName];\r\n    if (!toolInstance) {\r\n      console.warn(\r\n        `'${toolInstanceName}' is not registered with this toolGroup (${this.id}).`\r\n      );\r\n      return;\r\n    }\r\n\r\n    return toolInstance;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the tool instances associated with this tool group.\r\n   *\r\n   * @returns A record containing the tool instances, where the keys are the tool names and the values are the tool instances.\r\n   */\r\n  public getToolInstances(): Record<string, any> {\r\n    return this._toolInstances;\r\n  }\r\n\r\n  /**\r\n   * Check if a tool is already added to the tool group\r\n   * @param toolName - Tool name\r\n   * @returns True if the tool is already added or false otherwise\r\n   */\r\n  hasTool(toolName: string): boolean {\r\n    return !!this._toolInstances[toolName];\r\n  }\r\n\r\n  /**\r\n   * Add a tool to the tool group with the given tool name and tool configuration.\r\n   * Note that adding a tool to a tool group will not automatically set the tool\r\n   * to be active. You must call setToolActive or setToolPassive and other methods\r\n   * to set the tool to be active or passive or in other states.\r\n   *\r\n   * @param toolName - string\r\n   * @param configuration - Tool configuration objects and a custom statistics calculator if needed\r\n   */\r\n  addTool(toolName: string, configuration: ToolConfiguration = {}): void {\r\n    const toolDefinition = state.tools[toolName];\r\n    const hasToolName = typeof toolName !== 'undefined' && toolName !== '';\r\n    const localToolInstance = this.toolOptions[toolName];\r\n\r\n    if (!hasToolName) {\r\n      console.warn(\r\n        'Tool with configuration did not produce a toolName: ',\r\n        configuration\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (!toolDefinition) {\r\n      console.warn(\r\n        `'${toolName}' is not registered with the library. You need to use cornerstoneTools.addTool to register it.`\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (localToolInstance) {\r\n      console.warn(\r\n        `'${toolName}' is already registered for ToolGroup ${this.id}.`\r\n      );\r\n      return;\r\n    }\r\n\r\n    // Should these be renamed higher up, so we don't have to alias?\r\n    // Wrap in try-catch so 3rd party tools don't explode?\r\n    const { toolClass: ToolClass } = toolDefinition;\r\n\r\n    const toolProps = {\r\n      name: toolName,\r\n      toolGroupId: this.id,\r\n      configuration,\r\n    };\r\n\r\n    const instantiatedTool = new ToolClass(toolProps);\r\n\r\n    // API instead of directly exposing schema?\r\n    // Maybe not here, but feels like a \"must\" for any method outside of the ToolGroup itself\r\n    this._toolInstances[toolName] = instantiatedTool;\r\n  }\r\n\r\n  public addToolInstance(\r\n    toolName: string,\r\n    parentClassName: string,\r\n    configuration = {}\r\n  ): void {\r\n    let ToolClassToUse = state.tools[toolName]\r\n      ?.toolClass as IToolClassReference;\r\n\r\n    if (!ToolClassToUse) {\r\n      // get parent class constructor\r\n      const ParentClass = state.tools[parentClassName]\r\n        .toolClass as IToolClassReference;\r\n\r\n      // Todo: could not find a way to make this work with typescript\r\n      // @ts-ignore\r\n      class ToolInstance extends ParentClass {}\r\n      // @ts-ignore\r\n      ToolInstance.toolName = toolName;\r\n      // @ts-ignore\r\n      ToolClassToUse = ToolInstance;\r\n\r\n      state.tools[toolName] = {\r\n        toolClass: ToolInstance as IToolClassReference,\r\n      };\r\n    }\r\n\r\n    // add the tool to the toolGroup\r\n    // @ts-ignore\r\n    this.addTool(ToolClassToUse.toolName, configuration);\r\n  }\r\n\r\n  //   class InstanceTool extends parentClass;\r\n  // InstanceTool.constructor.toolName = name;\r\n  // addTool(InstanceTool,configuration)\r\n  /**\r\n   * Add a viewport to the ToolGroup. It accepts viewportId and optional\r\n   * renderingEngineId parameter. If renderingEngineId is not provided,\r\n   * it checks if cornerstone-core has more than one renderingEngine; If so,\r\n   * it will throw an error. If cornerstone-core has only one renderingEngine,\r\n   * it will use that renderingEngine.\r\n   *\r\n   * @param viewportId - The unique identifier for the viewport.\r\n   * @param renderingEngineId - The rendering engine to use.\r\n   */\r\n  public addViewport(viewportId: string, renderingEngineId?: string): void {\r\n    if (typeof viewportId !== 'string') {\r\n      throw new Error('viewportId must be defined and be a string');\r\n    }\r\n\r\n    const renderingEngines = getRenderingEngines();\r\n\r\n    if (!renderingEngineId && renderingEngines.length > 1) {\r\n      throw new Error(\r\n        'You must specify a renderingEngineId when there are multiple rendering engines.'\r\n      );\r\n    }\r\n\r\n    const renderingEngineUIDToUse = renderingEngineId || renderingEngines[0].id;\r\n\r\n    // Don't overwrite if it already exists\r\n    if (\r\n      !this.viewportsInfo.some(({ viewportId: vpId }) => vpId === viewportId)\r\n    ) {\r\n      this.viewportsInfo.push({\r\n        viewportId,\r\n        renderingEngineId: renderingEngineUIDToUse,\r\n      });\r\n    }\r\n\r\n    // Handle the newly added viewport's mouse cursor\r\n    const toolName = this.getActivePrimaryMouseButtonTool();\r\n\r\n    const runtimeSettings = Settings.getRuntimeSettings();\r\n    if (runtimeSettings.get('useCursors')) {\r\n      this.setViewportsCursorByToolName(toolName);\r\n    }\r\n\r\n    const eventDetail = {\r\n      toolGroupId: this.id,\r\n      viewportId,\r\n      renderingEngineId: renderingEngineUIDToUse,\r\n    };\r\n\r\n    triggerEvent(eventTarget, Events.TOOLGROUP_VIEWPORT_ADDED, eventDetail);\r\n  }\r\n\r\n  /**\r\n   * Removes viewport from the toolGroup. If only renderingEngineId is defined\r\n   * it removes all the viewports with the same renderingEngineId, if viewportId\r\n   * is also provided, it will remove that specific viewport from the ToolGroup.\r\n   *\r\n   * @param renderingEngineId - renderingEngine id\r\n   * @param viewportId - viewport id\r\n   */\r\n  public removeViewports(renderingEngineId: string, viewportId?: string): void {\r\n    const indices = [];\r\n\r\n    this.viewportsInfo.forEach((vpInfo, index) => {\r\n      let match = false;\r\n      if (vpInfo.renderingEngineId === renderingEngineId) {\r\n        match = true;\r\n\r\n        if (viewportId && vpInfo.viewportId !== viewportId) {\r\n          match = false;\r\n        }\r\n      }\r\n      if (match) {\r\n        indices.push(index);\r\n      }\r\n    });\r\n\r\n    if (indices.length) {\r\n      // Note: Traverse the array backwards, such that when we remove items we\r\n      // do not immediately mess up our loop indicies.\r\n      for (let i = indices.length - 1; i >= 0; i--) {\r\n        this.viewportsInfo.splice(indices[i], 1);\r\n      }\r\n    }\r\n\r\n    const eventDetail = {\r\n      toolGroupId: this.id,\r\n      viewportId,\r\n      renderingEngineId,\r\n    };\r\n\r\n    triggerEvent(eventTarget, Events.TOOLGROUP_VIEWPORT_REMOVED, eventDetail);\r\n  }\r\n\r\n  public setActiveStrategy(toolName: string, strategyName: string) {\r\n    const toolInstance = this._toolInstances[toolName];\r\n\r\n    if (toolInstance === undefined) {\r\n      console.warn(\r\n        `Tool ${toolName} not added to toolGroup, can't set tool configuration.`\r\n      );\r\n\r\n      return;\r\n    }\r\n\r\n    toolInstance.setActiveStrategy(strategyName);\r\n  }\r\n\r\n  setToolMode(\r\n    toolName: string,\r\n    mode: ToolModes,\r\n    options = {} as SetToolBindingsType\r\n  ): void {\r\n    if (!toolName) {\r\n      console.warn('setToolMode: toolName must be defined');\r\n      return;\r\n    }\r\n\r\n    if (mode === ToolModes.Active) {\r\n      this.setToolActive(\r\n        toolName,\r\n        options || this.restoreToolOptions[toolName]\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (mode === ToolModes.Passive) {\r\n      this.setToolPassive(toolName);\r\n      return;\r\n    }\r\n\r\n    if (mode === ToolModes.Enabled) {\r\n      this.setToolEnabled(toolName);\r\n      return;\r\n    }\r\n\r\n    if (mode === ToolModes.Disabled) {\r\n      this.setToolDisabled(toolName);\r\n      return;\r\n    }\r\n\r\n    console.warn('setToolMode: mode must be defined');\r\n  }\r\n\r\n  /**\r\n   * Set the tool mode on the toolGroup to be Active. This means the tool\r\n   * can be actively used by the defined bindings (e.g., Mouse primary click)\r\n   *\r\n   * - Can be actively used by mouse/touch events mapped to its `ToolBinding`s.\r\n   * - Can add data if an annotation tool.\r\n   * - Can be passively interacted by grabbing a tool or its handles.\r\n   * - Renders data if the tool has a `renderAnnotation` method.\r\n   *\r\n   * @param toolName - tool name\r\n   * @param toolBindingsOptions - tool bindings\r\n   */\r\n  public setToolActive(\r\n    toolName: string,\r\n    toolBindingsOptions = {} as SetToolBindingsType\r\n  ): void {\r\n    const toolInstance = this._toolInstances[toolName];\r\n\r\n    if (toolInstance === undefined) {\r\n      console.warn(\r\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\r\n      );\r\n\r\n      return;\r\n    }\r\n\r\n    if (!toolInstance) {\r\n      console.warn(\r\n        `'${toolName}' instance ${toolInstance} is not registered with this toolGroup, can't set tool mode.`\r\n      );\r\n      return;\r\n    }\r\n\r\n    const prevBindings: IToolBinding[] = this.toolOptions[toolName]\r\n      ? this.toolOptions[toolName].bindings\r\n      : [];\r\n\r\n    const newBindings = toolBindingsOptions.bindings\r\n      ? toolBindingsOptions.bindings\r\n      : [];\r\n\r\n    // combine the new bindings with the previous bindings to avoid duplicates\r\n    // it allows duplicated mouse buttons as long as they don't have same\r\n    // modifier keys.\r\n    const bindingsToUse = [...prevBindings, ...newBindings].reduce(\r\n      (unique, binding) => {\r\n        const TouchBinding = binding.numTouchPoints !== undefined;\r\n        const MouseBinding = binding.mouseButton !== undefined;\r\n\r\n        if (\r\n          !unique.some((obj) => hasSameBinding(obj, binding)) &&\r\n          (TouchBinding || MouseBinding)\r\n        ) {\r\n          unique.push(binding);\r\n        }\r\n        return unique;\r\n      },\r\n      []\r\n    );\r\n\r\n    // We should not override the bindings if they are already set\r\n    const toolOptions: ToolOptionsType = {\r\n      bindings: bindingsToUse,\r\n      mode: Active,\r\n    };\r\n\r\n    this.toolOptions[toolName] = toolOptions;\r\n    this._toolInstances[toolName].mode = Active;\r\n\r\n    // reset the mouse cursor if tool has left click binding\r\n    const runtimeSettings = Settings.getRuntimeSettings();\r\n    const useCursor = runtimeSettings.get('useCursors');\r\n\r\n    if (this._hasMousePrimaryButtonBinding(toolBindingsOptions) && useCursor) {\r\n      this.setViewportsCursorByToolName(toolName);\r\n    } else {\r\n      // reset to default cursor only if there is no other tool with primary binding\r\n      const activeToolIdentifier = this.getActivePrimaryMouseButtonTool();\r\n      if (!activeToolIdentifier && useCursor) {\r\n        const cursor = MouseCursor.getDefinedCursor('default');\r\n        this._setCursorForViewports(cursor);\r\n      }\r\n    }\r\n\r\n    // if it is a primary tool binding, we should store it as the previous primary tool\r\n    // so that we can restore it when the tool is disabled if desired\r\n    if (this._hasMousePrimaryButtonBinding(toolBindingsOptions)) {\r\n      if (this.prevActivePrimaryToolName === null) {\r\n        this.prevActivePrimaryToolName = toolName;\r\n      } else {\r\n        this.prevActivePrimaryToolName = this.currentActivePrimaryToolName;\r\n      }\r\n\r\n      this.currentActivePrimaryToolName = toolName;\r\n    }\r\n\r\n    if (typeof toolInstance.onSetToolActive === 'function') {\r\n      toolInstance.onSetToolActive();\r\n    }\r\n    this._renderViewports();\r\n\r\n    const eventDetail: ToolActivatedEventDetail = {\r\n      toolGroupId: this.id,\r\n      toolName,\r\n      toolBindingsOptions,\r\n    };\r\n\r\n    triggerEvent(eventTarget, Events.TOOL_ACTIVATED, eventDetail);\r\n    this._triggerToolModeChangedEvent(toolName, Active, toolBindingsOptions);\r\n  }\r\n\r\n  /**\r\n   * Set the tool mode on the toolGroup to be Passive.\r\n   *\r\n   * - Can be passively interacted by grabbing a tool or its handles.\r\n   * - Renders data if the tool has a `renderAnnotation` method.\r\n   *\r\n   * @param toolName - tool name\r\n   * @param options - Options used when setting the tool as passive\r\n   *  - removeAllBindings: only the primary button bindings are removed but\r\n   *  if this parameter is set to true all bindings are removed.\r\n   */\r\n  public setToolPassive(\r\n    toolName: string,\r\n    options?: { removeAllBindings?: boolean | IToolBinding[] }\r\n  ): void {\r\n    const toolInstance = this._toolInstances[toolName];\r\n\r\n    if (toolInstance === undefined) {\r\n      console.warn(\r\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\r\n      );\r\n\r\n      return;\r\n    }\r\n\r\n    // We should only remove the primary button bindings and keep\r\n    // the other ones (Zoom on right click)\r\n    const prevToolOptions = this.getToolOptions(toolName);\r\n    const toolOptions = Object.assign(\r\n      {\r\n        bindings: prevToolOptions ? prevToolOptions.bindings : [],\r\n      },\r\n      prevToolOptions,\r\n      {\r\n        mode: Passive,\r\n      }\r\n    );\r\n\r\n    const matchBindings = Array.isArray(options?.removeAllBindings)\r\n      ? options.removeAllBindings\r\n      : this.getDefaultPrimaryBindings();\r\n\r\n    // Remove the primary button bindings without modifiers, if they exist\r\n    toolOptions.bindings = toolOptions.bindings.filter(\r\n      (binding) =>\r\n        options?.removeAllBindings !== true &&\r\n        !matchBindings.some((matchBinding) =>\r\n          hasSameBinding(binding, matchBinding)\r\n        )\r\n      //(binding.mouseButton !== defaultMousePrimary || binding.modifierKey)\r\n    );\r\n    // If there are other bindings, set the tool to be active\r\n    let mode = Passive;\r\n    if (toolOptions.bindings.length !== 0) {\r\n      mode = Active;\r\n      toolOptions.mode = mode;\r\n    }\r\n\r\n    this.toolOptions[toolName] = toolOptions;\r\n    toolInstance.mode = mode;\r\n\r\n    if (typeof toolInstance.onSetToolPassive === 'function') {\r\n      toolInstance.onSetToolPassive();\r\n    }\r\n    this._renderViewports();\r\n\r\n    // It would make sense to use `toolInstance.mode` as mode when setting a tool\r\n    // as passive because it can still be actived in the end but `Passive` must\r\n    // be used when synchronizing ToolGroups so that other ToolGroups can take the\r\n    // same action (update tool bindings). Should the event have two different modes\r\n    // to handle this special case?\r\n    this._triggerToolModeChangedEvent(toolName, Passive);\r\n  }\r\n\r\n  /**\r\n   * Set the tool mode on the toolGroup to be Enabled.\r\n   *\r\n   * - Renders data if the tool has a `renderAnnotation` method..\r\n   *\r\n   * @param toolName - tool name\r\n   */\r\n  public setToolEnabled(toolName: string): void {\r\n    const toolInstance = this._toolInstances[toolName];\r\n\r\n    if (toolInstance === undefined) {\r\n      console.warn(\r\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\r\n      );\r\n\r\n      return;\r\n    }\r\n\r\n    const toolOptions = {\r\n      bindings: [],\r\n      mode: Enabled,\r\n    };\r\n\r\n    this.toolOptions[toolName] = toolOptions;\r\n    toolInstance.mode = Enabled;\r\n\r\n    if (typeof toolInstance.onSetToolEnabled === 'function') {\r\n      toolInstance.onSetToolEnabled();\r\n    }\r\n\r\n    this._renderViewports();\r\n    this._triggerToolModeChangedEvent(toolName, Enabled);\r\n  }\r\n\r\n  /**\r\n   * Set the tool mode on the toolGroup to be Disabled.\r\n   *\r\n   * - Annotation does not render.\r\n   *\r\n   * @param toolName - tool name\r\n   */\r\n  public setToolDisabled(toolName: string): void {\r\n    const toolInstance = this._toolInstances[toolName];\r\n\r\n    if (toolInstance === undefined) {\r\n      console.warn(\r\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\r\n      );\r\n\r\n      return;\r\n    }\r\n\r\n    const toolOptions = {\r\n      bindings: [],\r\n      mode: Disabled,\r\n    };\r\n\r\n    this.restoreToolOptions[toolName] = this.toolOptions[toolName];\r\n\r\n    this.toolOptions[toolName] = toolOptions;\r\n    toolInstance.mode = Disabled;\r\n\r\n    if (typeof toolInstance.onSetToolDisabled === 'function') {\r\n      toolInstance.onSetToolDisabled();\r\n    }\r\n    this._renderViewports();\r\n    this._triggerToolModeChangedEvent(toolName, Disabled);\r\n  }\r\n\r\n  /**\r\n   * Get the options for a given tool\r\n   * @param toolName - The name of the tool.\r\n   * @returns the tool options\r\n   */\r\n  public getToolOptions(toolName: string): ToolOptionsType {\r\n    const toolOptionsForTool = this.toolOptions[toolName];\r\n\r\n    if (toolOptionsForTool === undefined) {\r\n      return;\r\n    }\r\n\r\n    return toolOptionsForTool;\r\n  }\r\n\r\n  /**\r\n   * Find the name of the tool that is Active and has a primary button binding\r\n   * (Mouse primary click)\r\n   *\r\n   * @returns The name of the tool\r\n   */\r\n  public getActivePrimaryMouseButtonTool(): string {\r\n    return Object.keys(this.toolOptions).find((toolName) => {\r\n      const toolOptions = this.toolOptions[toolName];\r\n      return (\r\n        toolOptions.mode === Active &&\r\n        this._hasMousePrimaryButtonBinding(toolOptions)\r\n      );\r\n    });\r\n  }\r\n\r\n  public setViewportsCursorByToolName(\r\n    toolName: string,\r\n    strategyName?: string\r\n  ): void {\r\n    const cursor = this._getCursor(toolName, strategyName);\r\n\r\n    this._setCursorForViewports(cursor);\r\n  }\r\n\r\n  private _getCursor(toolName: string, strategyName?: string): MouseCursor {\r\n    let cursorName;\r\n    let cursor;\r\n\r\n    if (strategyName) {\r\n      // Try combinations with strategyName first:\r\n      // Try with toolName and toolInstanceName first.\r\n      cursorName = `${toolName}.${strategyName}`;\r\n\r\n      cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\r\n\r\n      if (cursor) {\r\n        return cursor;\r\n      }\r\n    }\r\n\r\n    // Try with toolName and toolInstanceName first.\r\n    cursorName = `${toolName}`;\r\n\r\n    cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\r\n\r\n    if (cursor) {\r\n      return cursor;\r\n    }\r\n\r\n    // Try with just toolName.\r\n    cursorName = toolName;\r\n\r\n    cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\r\n\r\n    if (cursor) {\r\n      return cursor;\r\n    }\r\n\r\n    return MouseCursor.getDefinedCursor('default');\r\n  }\r\n\r\n  _setCursorForViewports(cursor: MouseCursor): void {\r\n    this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\r\n      const enabledElement = getEnabledElementByIds(\r\n        viewportId,\r\n        renderingEngineId\r\n      );\r\n\r\n      if (!enabledElement) {\r\n        return;\r\n      }\r\n\r\n      const { viewport } = enabledElement;\r\n      initElementCursor(viewport.element, cursor);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set a configuration of a tool by the given toolName.\r\n   * Use overwrite as true in case you want to overwrite any existing configuration (be careful, depending on config change it might break the annotation flow).\r\n   */\r\n  public setToolConfiguration(\r\n    toolName: string,\r\n    configuration: ToolConfiguration,\r\n    overwrite?: boolean\r\n  ): boolean {\r\n    const toolInstance = this._toolInstances[toolName];\r\n    if (toolInstance === undefined) {\r\n      console.warn(\r\n        `Tool ${toolName} not present, can't set tool configuration.`\r\n      );\r\n      return false;\r\n    }\r\n\r\n    let _configuration;\r\n\r\n    if (overwrite) {\r\n      _configuration = configuration;\r\n    } else {\r\n      // We should not deep copy here, it is the job of the application to\r\n      // deep copy the configuration before passing it to the toolGroup, otherwise\r\n      // some strange appending behaviour happens for the arrays\r\n      _configuration = Object.assign(toolInstance.configuration, configuration);\r\n    }\r\n\r\n    toolInstance.configuration = _configuration;\r\n\r\n    if (typeof toolInstance.onSetToolConfiguration === 'function') {\r\n      toolInstance.onSetToolConfiguration();\r\n    }\r\n\r\n    this._renderViewports();\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Returns the default mouse primary button.\r\n   */\r\n  public getDefaultMousePrimary(): MouseBindings {\r\n    return MouseBindings.Primary;\r\n  }\r\n\r\n  /**\r\n   * Gets an array of bindings that is the full primary binding.\r\n   * Currently this is just the primary mouse button, but may be extended in the\r\n   * future to include touch or other binding types.\r\n   */\r\n  public getDefaultPrimaryBindings(): IToolBinding[] {\r\n    return PRIMARY_BINDINGS;\r\n  }\r\n\r\n  /**\r\n   * Get the configuration of tool. It returns only the config for the given path (in case exists).\r\n   * ConfigurationPath is the the path of the property to get separated by '.'.\r\n   *\r\n   * @example\r\n   * getToolConfiguration('LengthTool', 'firstLevel.secondLevel')\r\n   * // get from LengthTool instance the configuration value as being LengthToolInstance[configuration][firstLevel][secondLevel]\r\n   */\r\n  getToolConfiguration(toolName: string, configurationPath?: string): any {\r\n    if (this._toolInstances[toolName] === undefined) {\r\n      console.warn(\r\n        `Tool ${toolName} not present, can't set tool configuration.`\r\n      );\r\n      return;\r\n    }\r\n\r\n    const _configuration =\r\n      get(this._toolInstances[toolName].configuration, configurationPath) ||\r\n      this._toolInstances[toolName].configuration;\r\n\r\n    return cloneDeep(_configuration);\r\n  }\r\n\r\n  /**\r\n   * Gets the name of the previously active tool.\r\n   * @returns The name of the previously active tool.\r\n   */\r\n  public getPrevActivePrimaryToolName(): string {\r\n    return this.prevActivePrimaryToolName;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param newToolGroupId - Id of the new (clone) tool group\r\n   * @param fnToolFilter - Function to filter which tools from this tool group\r\n   * should be added to the new (clone) one. Example: only annotations tools\r\n   * can be filtered and added to the new tool group.\r\n   * @returns A new tool group that is a clone of this one\r\n   */\r\n  public clone(\r\n    newToolGroupId,\r\n    fnToolFilter: (toolName: string) => void = null\r\n  ): IToolGroup {\r\n    let toolGroup = ToolGroupManager.getToolGroup(newToolGroupId);\r\n\r\n    if (toolGroup) {\r\n      console.warn(`ToolGroup ${newToolGroupId} already exists`);\r\n      return toolGroup;\r\n    }\r\n\r\n    toolGroup = ToolGroupManager.createToolGroup(newToolGroupId);\r\n    fnToolFilter = fnToolFilter ?? (() => true);\r\n\r\n    Object.keys(this._toolInstances)\r\n      .filter(fnToolFilter)\r\n      .forEach((toolName) => {\r\n        const sourceToolInstance = this._toolInstances[toolName];\r\n        const sourceToolOptions = this.toolOptions[toolName];\r\n        const sourceToolMode = sourceToolInstance.mode;\r\n\r\n        toolGroup.addTool(toolName);\r\n\r\n        (toolGroup as unknown as ToolGroup).setToolMode(\r\n          toolName,\r\n          sourceToolMode,\r\n          {\r\n            bindings: sourceToolOptions.bindings ?? [],\r\n          }\r\n        );\r\n      });\r\n\r\n    return toolGroup;\r\n  }\r\n\r\n  /**\r\n   * Check if the tool binding is set to be primary mouse button.\r\n   * @param toolOptions - The options for the tool mode.\r\n   * @returns A boolean value.\r\n   */\r\n  private _hasMousePrimaryButtonBinding(toolOptions) {\r\n    const primaryBindings = this.getDefaultPrimaryBindings();\r\n    return toolOptions?.bindings?.some((binding) =>\r\n      primaryBindings.some((primary) => hasSameBinding(binding, primary))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * It re-renders the viewports in the toolGroup\r\n   */\r\n  private _renderViewports(): void {\r\n    this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\r\n      getRenderingEngine(renderingEngineId).renderViewport(viewportId);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Trigger ToolModeChangedEvent when changing the tool mode\r\n   * @param toolName - Tool name\r\n   * @param mode - Tool mode\r\n   * @param toolBindingsOptions - Binding options used when a tool is activated\r\n   */\r\n  private _triggerToolModeChangedEvent(\r\n    toolName: string,\r\n    mode: ToolModes,\r\n    toolBindingsOptions?: SetToolBindingsType\r\n  ): void {\r\n    const eventDetail: ToolModeChangedEventDetail = {\r\n      toolGroupId: this.id,\r\n      toolName,\r\n      mode,\r\n      toolBindingsOptions,\r\n    };\r\n\r\n    triggerEvent(eventTarget, Events.TOOL_MODE_CHANGED, eventDetail);\r\n  }\r\n}\r\n\r\n/**\r\n * Figure out if the two bindings are the same\r\n */\r\nfunction hasSameBinding(\r\n  binding1: IToolBinding,\r\n  binding2: IToolBinding\r\n): boolean {\r\n  if (binding1.mouseButton !== binding2.mouseButton) {\r\n    return false;\r\n  }\r\n  if (binding1.numTouchPoints !== binding2.numTouchPoints) {\r\n    return false;\r\n  }\r\n\r\n  return binding1.modifierKey === binding2.modifierKey;\r\n}\r\n","import { state } from '../index';\r\nimport ToolGroup from './ToolGroup';\r\nimport { IToolGroup } from '../../types';\r\n\r\n/**\r\n * Create a new tool group with the given name. ToolGroups are the new way\r\n * in Cornerstone3DTools to share tool configuration, state (enabled, disabled, etc.)\r\n * across a set of viewports.\r\n *\r\n * @param toolGroupId - The unique ID of the tool group.\r\n * @returns A reference to the tool group that was created.\r\n */\r\nfunction createToolGroup(toolGroupId: string): IToolGroup | undefined {\r\n  // Exit early if ID conflict\r\n  const toolGroupWithIdExists = state.toolGroups.some(\r\n    (tg) => tg.id === toolGroupId\r\n  );\r\n\r\n  if (toolGroupWithIdExists) {\r\n    console.warn(`'${toolGroupId}' already exists.`);\r\n    return;\r\n  }\r\n\r\n  const toolGroup = new ToolGroup(toolGroupId);\r\n\r\n  // Update state\r\n  state.toolGroups.push(toolGroup);\r\n\r\n  // Return reference\r\n  return toolGroup;\r\n}\r\n\r\nexport default createToolGroup;\r\n","// `BaseManager` or IManager interface for duplicate API between ToolGroup/Synchronizer?\r\nimport { state as csToolsState } from '../index';\r\nimport destroyToolGroup from './destroyToolGroup';\r\n\r\n// ToolGroups function entirely by their \"state\" being queried and leveraged\r\n// removing a ToolGroup from state is equivalent to killing it. Calling\r\n// destroyToolGroup() to make sure the SegmentationDisplayTools\r\n// have been removed from the toolGroup Viewports. //Todo: this makes more sense\r\n// to be based on events, but we don't have any toolGroup created/removed events\r\n\r\n/**\r\n * Destroy all tool groups\r\n */\r\nfunction destroy(): void {\r\n  const toolGroups = [...csToolsState.toolGroups];\r\n\r\n  for (const toolGroup of toolGroups) {\r\n    destroyToolGroup(toolGroup.id);\r\n  }\r\n\r\n  csToolsState.toolGroups = [];\r\n}\r\n\r\nexport default destroy;\r\n","import { state } from '../index';\r\nimport { removeSegmentationsFromToolGroup } from '../../stateManagement/segmentation';\r\nimport { segmentationRenderingEngine } from '../../utilities/segmentation/triggerSegmentationRender';\r\n// ToolGroups function entirely by their \"state\" being queried and leveraged\r\n// removing a ToolGroup from state is equivalent to killing it\r\n\r\n/**\r\n * Given a tool group Id, destroy the toolGroup. It will also cleanup all segmentations\r\n * associated with that tool group too\r\n *\r\n * @param toolGroupId - The Id of the tool group to be destroyed.\r\n */\r\nfunction destroyToolGroup(toolGroupId: string): void {\r\n  const toolGroupIndex = state.toolGroups.findIndex(\r\n    (tg) => tg.id === toolGroupId\r\n  );\r\n\r\n  if (toolGroupIndex > -1) {\r\n    segmentationRenderingEngine.removeToolGroup(toolGroupId);\r\n    // Todo: this should not happen here)\r\n    removeSegmentationsFromToolGroup(toolGroupId);\r\n    state.toolGroups.splice(toolGroupIndex, 1);\r\n  }\r\n}\r\n\r\nexport default destroyToolGroup;\r\n","import { state } from '../index';\r\nimport { IToolGroup } from '../../types';\r\n\r\n/**\r\n * Return the array of tool groups\r\n * @returns An array of tool groups.\r\n */\r\nfunction getAllToolGroups(): Array<IToolGroup> {\r\n  return state.toolGroups;\r\n}\r\n\r\nexport default getAllToolGroups;\r\n","import { state } from '../index';\r\nimport { IToolGroup } from '../../types';\r\n\r\n/**\r\n * Given a tool group Id, return the tool group\r\n * @param toolGroupId - The Id of the tool group to be retrieved.\r\n * @returns The tool group that has the same id as the tool group id that was\r\n * passed in.\r\n */\r\nfunction getToolGroup(toolGroupId: string): IToolGroup | undefined {\r\n  return state.toolGroups.find((s) => s.id === toolGroupId);\r\n}\r\n\r\nexport default getToolGroup;\r\n","import { state } from '../index';\r\nimport { IToolGroup } from '../../types';\r\nimport { ToolModes } from '../../enums';\r\n\r\nconst MODES = [ToolModes.Active, ToolModes.Passive, ToolModes.Enabled];\r\n\r\n/**\r\n * Returns the toolGroups that has the given toolName as active, passive\r\n * or enabled.\r\n * @param toolName - The name of the tool\r\n * @returns An array of tool groups.\r\n */\r\nfunction getToolGroupsWithToolName(toolName: string): IToolGroup[] | [] {\r\n  return state.toolGroups.filter(({ toolOptions }) => {\r\n    const toolGroupToolNames = Object.keys(toolOptions);\r\n\r\n    for (let i = 0; i < toolGroupToolNames.length; i++) {\r\n      if (toolName !== toolGroupToolNames[i]) {\r\n        continue;\r\n      }\r\n\r\n      /* filter out tools that don't have options */\r\n      if (!toolOptions[toolName]) {\r\n        continue;\r\n      }\r\n\r\n      if (MODES.includes(toolOptions[toolName].mode)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  });\r\n}\r\n\r\nexport default getToolGroupsWithToolName;\r\n","import { vec2, vec3 } from 'gl-matrix';\r\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\r\nimport { roundNumber } from '../../utilities';\r\nimport { AnnotationTool } from '../base';\r\nimport throttle from '../../utilities/throttle';\r\nimport {\r\n  addAnnotation,\r\n  getAnnotations,\r\n  removeAnnotation,\r\n} from '../../stateManagement/annotation/annotationState';\r\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\r\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\r\nimport {\r\n  triggerAnnotationCompleted,\r\n  triggerAnnotationModified,\r\n} from '../../stateManagement/annotation/helpers/state';\r\nimport {\r\n  drawLine as drawLineSvg,\r\n  drawHandles as drawHandlesSvg,\r\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\r\n} from '../../drawingSvg';\r\nimport { state } from '../../store';\r\nimport { Events } from '../../enums';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport * as lineSegment from '../../utilities/math/line';\r\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\r\nimport {\r\n  resetElementCursor,\r\n  hideElementCursor,\r\n} from '../../cursors/elementCursor';\r\nimport {\r\n  EventTypes,\r\n  ToolHandle,\r\n  TextBoxHandle,\r\n  PublicToolProps,\r\n  ToolProps,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\nimport { BidirectionalAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\n\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\n\r\nconst { transformWorldToIndex } = csUtils;\r\n\r\n/**\r\n * BidirectionalTool let you draw annotations that measures the length and\r\n * width at the same time in `mm` unit. It is consisted of two perpendicular lines and\r\n * a text box. You can use the BidirectionalTool in all planes even in oblique\r\n * reconstructed planes. Note: annotation tools in cornerstone3DTools exists in the exact location\r\n * in the physical 3d space, as a result, by default, all annotations that are\r\n * drawing in the same frameOfReference will get shared between viewports that\r\n * are in the same frameOfReference.\r\n *\r\n * The resulting annotation's data (statistics) and metadata (the\r\n * state of the viewport while drawing was happening) will get added to the\r\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\r\n * or similar methods.\r\n *\r\n * ```js\r\n * cornerstoneTools.addTool(BidirectionalTool)\r\n *\r\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\r\n *\r\n * toolGroup.addTool(BidirectionalTool.toolName)\r\n *\r\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\r\n *\r\n * toolGroup.setToolActive(BidirectionalTool.toolName, {\r\n *   bindings: [\r\n *    {\r\n *       mouseButton: MouseBindings.Primary, // Left Click\r\n *     },\r\n *   ],\r\n * })\r\n * ```\r\n *\r\n * Read more in the Docs section of the website.\r\n */\r\n\r\nclass BidirectionalTool extends AnnotationTool {\r\n  static toolName;\r\n\r\n  touchDragCallback: any;\r\n  mouseDragCallback: any;\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: string[];\r\n    handleIndex?: number;\r\n    movingTextBox: boolean;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n  preventHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        preventHandleOutsideImage: false,\r\n        getTextLines: defaultGetTextLines,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n\r\n    this._throttledCalculateCachedStats = throttle(\r\n      this._calculateCachedStats,\r\n      100,\r\n      { trailing: true }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the current imageId to create\r\n   * a Bidirectional Annotation and stores it in the annotationManager\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation(\r\n    evt: EventTypes.InteractionEventType\r\n  ): BidirectionalAnnotation {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    const referencedImageId = this.getReferencedImageId(\r\n      viewport,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      viewUp\r\n    );\r\n\r\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n\r\n    const annotation: BidirectionalAnnotation = {\r\n      highlighted: true,\r\n      invalidated: true,\r\n      metadata: {\r\n        toolName: this.getToolName(),\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID,\r\n        referencedImageId,\r\n        ...viewport.getViewReference({ points: [worldPos] }),\r\n      },\r\n      data: {\r\n        handles: {\r\n          points: [\r\n            // long\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            // short\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n          ],\r\n          textBox: {\r\n            hasMoved: false,\r\n            worldPosition: <Types.Point3>[0, 0, 0],\r\n            worldBoundingBox: {\r\n              topLeft: <Types.Point3>[0, 0, 0],\r\n              topRight: <Types.Point3>[0, 0, 0],\r\n              bottomLeft: <Types.Point3>[0, 0, 0],\r\n              bottomRight: <Types.Point3>[0, 0, 0],\r\n            },\r\n          },\r\n          activeHandleIndex: null,\r\n        },\r\n        label: '',\r\n        cachedStats: {},\r\n      },\r\n    };\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex: 1,\r\n      movingTextBox: false,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n    };\r\n    this._activateDraw(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  }\r\n\r\n  /**\r\n   * It returns if the canvas point is near the provided annotation in the provided\r\n   * element or not. A proximity is passed to the function to determine the\r\n   * proximity of the point to the annotation in number of pixels.\r\n   *\r\n   * @param element - HTML Element\r\n   * @param annotation - Annotation\r\n   * @param canvasCoords - Canvas coordinates\r\n   * @param proximity - Proximity to tool to consider\r\n   * @returns Boolean, whether the canvas point is near tool\r\n   */\r\n  isPointNearTool = (\r\n    element: HTMLDivElement,\r\n    annotation: BidirectionalAnnotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): boolean => {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const { data } = annotation;\r\n    const { points } = data.handles;\r\n\r\n    // Check long axis\r\n    let canvasPoint1 = viewport.worldToCanvas(points[0]);\r\n    let canvasPoint2 = viewport.worldToCanvas(points[1]);\r\n\r\n    let line = {\r\n      start: {\r\n        x: canvasPoint1[0],\r\n        y: canvasPoint1[1],\r\n      },\r\n      end: {\r\n        x: canvasPoint2[0],\r\n        y: canvasPoint2[1],\r\n      },\r\n    };\r\n\r\n    let distanceToPoint = lineSegment.distanceToPoint(\r\n      [line.start.x, line.start.y],\r\n      [line.end.x, line.end.y],\r\n      [canvasCoords[0], canvasCoords[1]]\r\n    );\r\n\r\n    if (distanceToPoint <= proximity) {\r\n      return true;\r\n    }\r\n\r\n    // Check short axis\r\n    canvasPoint1 = viewport.worldToCanvas(points[2]);\r\n    canvasPoint2 = viewport.worldToCanvas(points[3]);\r\n\r\n    line = {\r\n      start: {\r\n        x: canvasPoint1[0],\r\n        y: canvasPoint1[1],\r\n      },\r\n      end: {\r\n        x: canvasPoint2[0],\r\n        y: canvasPoint2[1],\r\n      },\r\n    };\r\n\r\n    distanceToPoint = lineSegment.distanceToPoint(\r\n      [line.start.x, line.start.y],\r\n      [line.end.x, line.end.y],\r\n      [canvasCoords[0], canvasCoords[1]]\r\n    );\r\n\r\n    if (distanceToPoint <= proximity) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Handles the toolSelected callback for bidirectional tool\r\n   * @param evt - EventTypes.MouseDownEventType\r\n   * @param annotation - Bidirectional annotation\r\n   * @param interactionType - interaction type (mouse, touch)\r\n   */\r\n  toolSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: BidirectionalAnnotation\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      movingTextBox: false,\r\n    };\r\n\r\n    this._activateModify(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  /**\r\n   * Executes the callback for when mouse has selected a handle (anchor point) of\r\n   * the bidirectional tool or when the text box has been selected.\r\n   *\r\n   * @param evt - EventTypes.MouseDownEventType\r\n   * @param annotation - Bidirectional annotation\r\n   * @param handle - Handle index or selected textBox information\r\n   * @param interactionType - interaction type (mouse, touch)\r\n   */\r\n  handleSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: BidirectionalAnnotation,\r\n    handle: ToolHandle\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const data = annotation.data;\r\n\r\n    annotation.highlighted = true;\r\n\r\n    let movingTextBox = false;\r\n    let handleIndex;\r\n\r\n    if ((handle as TextBoxHandle).worldPosition) {\r\n      movingTextBox = true;\r\n    } else {\r\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\r\n    }\r\n\r\n    // Find viewports to render on drag.\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    hideElementCursor(element);\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex,\r\n      movingTextBox,\r\n    };\r\n    this._activateModify(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  /**\r\n   * Handles the mouse up action for the bidirectional tool. It can be at the end\r\n   * of the annotation drawing (MouseUpEventType) or when the user clicks and release\r\n   * the mouse button instantly which let to the annotation to draw without holding\r\n   * the mouse button (MouseClickEventType).\r\n   *\r\n   * @param evt - mouse up or mouse click event types\r\n   */\r\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (newAnnotation && !hasMoved) {\r\n      return;\r\n    }\r\n\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateModify(element);\r\n    this._deactivateDraw(element);\r\n\r\n    resetElementCursor(element);\r\n\r\n    const { renderingEngine } = getEnabledElement(element);\r\n\r\n    if (this.editData.handleIndex !== undefined) {\r\n      const { points } = data.handles;\r\n      const firstLineSegmentLength = vec3.distance(points[0], points[1]);\r\n      const secondLineSegmentLength = vec3.distance(points[2], points[3]);\r\n\r\n      if (secondLineSegmentLength > firstLineSegmentLength) {\r\n        // Switch points so [0,1] is the long axis and [2,3] is the short axis.\r\n\r\n        const longAxis = [[...points[2]], [...points[3]]];\r\n\r\n        const shortAxisPoint0 = [...points[0]];\r\n        const shortAxisPoint1 = [...points[1]];\r\n\r\n        // shortAxis[0->1] should be perpendicular (counter-clockwise) to longAxis[0->1]\r\n        const longAxisVector = vec2.create();\r\n\r\n        vec2.set(\r\n          longAxisVector,\r\n          longAxis[1][0] - longAxis[0][0],\r\n          longAxis[1][1] - longAxis[1][0]\r\n        );\r\n\r\n        const counterClockWisePerpendicularToLongAxis = vec2.create();\r\n\r\n        vec2.set(\r\n          counterClockWisePerpendicularToLongAxis,\r\n          -longAxisVector[1],\r\n          longAxisVector[0]\r\n        );\r\n\r\n        const currentShortAxisVector = vec2.create();\r\n\r\n        vec2.set(\r\n          currentShortAxisVector,\r\n          shortAxisPoint1[0] - shortAxisPoint0[0],\r\n          shortAxisPoint1[1] - shortAxisPoint0[0]\r\n        );\r\n\r\n        let shortAxis;\r\n\r\n        if (\r\n          vec2.dot(\r\n            currentShortAxisVector,\r\n            counterClockWisePerpendicularToLongAxis\r\n          ) > 0\r\n        ) {\r\n          shortAxis = [shortAxisPoint0, shortAxisPoint1];\r\n        } else {\r\n          shortAxis = [shortAxisPoint1, shortAxisPoint0];\r\n        }\r\n\r\n        data.handles.points = [\r\n          longAxis[0],\r\n          longAxis[1],\r\n          shortAxis[0],\r\n          shortAxis[1],\r\n        ];\r\n      }\r\n    }\r\n\r\n    if (\r\n      this.isHandleOutsideImage &&\r\n      this.configuration.preventHandleOutsideImage\r\n    ) {\r\n      removeAnnotation(annotation.annotationUID);\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    if (newAnnotation) {\r\n      triggerAnnotationCompleted(annotation);\r\n    }\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n  };\r\n\r\n  /**\r\n   * @param evt - mouse move event type or mouse drag\r\n   */\r\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    this.isDrawing = true;\r\n\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine, viewport } = enabledElement;\r\n    const { worldToCanvas } = viewport;\r\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\r\n    const { data } = annotation;\r\n\r\n    const worldPos = currentPoints.world;\r\n\r\n    // Update first move handle\r\n    data.handles.points[handleIndex] = [...worldPos];\r\n\r\n    const canvasCoordPoints = data.handles.points.map(worldToCanvas);\r\n\r\n    const canvasCoords = {\r\n      longLineSegment: {\r\n        start: {\r\n          x: canvasCoordPoints[0][0],\r\n          y: canvasCoordPoints[0][1],\r\n        },\r\n        end: {\r\n          x: canvasCoordPoints[1][0],\r\n          y: canvasCoordPoints[1][1],\r\n        },\r\n      },\r\n      shortLineSegment: {\r\n        start: {\r\n          x: canvasCoordPoints[2][0],\r\n          y: canvasCoordPoints[2][1],\r\n        },\r\n        end: {\r\n          x: canvasCoordPoints[3][0],\r\n          y: canvasCoordPoints[3][1],\r\n        },\r\n      },\r\n    };\r\n\r\n    // ~~ calculate worldPos of our short axis handles\r\n    // short axis is perpendicular to long axis, and we set its length to be 2/3 of long axis\r\n    // (meaning each)\r\n    const dist = vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);\r\n\r\n    const shortAxisDistFromCenter = dist / 3;\r\n    // Calculate long line's incline\r\n    const dx =\r\n      canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;\r\n    const dy =\r\n      canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;\r\n    const length = Math.sqrt(dx * dx + dy * dy);\r\n    const vectorX = dx / length;\r\n    const vectorY = dy / length;\r\n    // middle point between long line segment's points\r\n    const xMid =\r\n      (canvasCoords.longLineSegment.start.x +\r\n        canvasCoords.longLineSegment.end.x) /\r\n      2;\r\n    const yMid =\r\n      (canvasCoords.longLineSegment.start.y +\r\n        canvasCoords.longLineSegment.end.y) /\r\n      2;\r\n    // short points 1/3 distance from center of long points\r\n    const startX = xMid + shortAxisDistFromCenter * vectorY;\r\n    const startY = yMid - shortAxisDistFromCenter * vectorX;\r\n    const endX = xMid - shortAxisDistFromCenter * vectorY;\r\n    const endY = yMid + shortAxisDistFromCenter * vectorX;\r\n\r\n    // Update perpendicular line segment's points\r\n    data.handles.points[2] = viewport.canvasToWorld([startX, startY]);\r\n    data.handles.points[3] = viewport.canvasToWorld([endX, endY]);\r\n\r\n    annotation.invalidated = true;\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    this.editData.hasMoved = true;\r\n  };\r\n\r\n  /**\r\n   * Mouse drag to edit annotation callback\r\n   * @param evt - mouse drag event\r\n   */\r\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    this.isDrawing = true;\r\n\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n    if (movingTextBox) {\r\n      const { deltaPoints } = eventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n\r\n      const { textBox } = data.handles;\r\n      const { worldPosition } = textBox;\r\n\r\n      worldPosition[0] += worldPosDelta[0];\r\n      worldPosition[1] += worldPosDelta[1];\r\n      worldPosition[2] += worldPosDelta[2];\r\n\r\n      textBox.hasMoved = true;\r\n    } else if (handleIndex === undefined) {\r\n      // Moving tool\r\n      const { deltaPoints } = eventDetail;\r\n      const worldPosDelta = deltaPoints.world;\r\n      const points = data.handles.points;\r\n\r\n      points.forEach((point) => {\r\n        point[0] += worldPosDelta[0];\r\n        point[1] += worldPosDelta[1];\r\n        point[2] += worldPosDelta[2];\r\n      });\r\n      annotation.invalidated = true;\r\n    } else {\r\n      this._dragModifyHandle(evt);\r\n      annotation.invalidated = true;\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n  };\r\n\r\n  /**\r\n   * Mouse dragging a handle callback\r\n   * @param evt - mouse drag event\r\n   */\r\n  _dragModifyHandle = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n    const { annotation, handleIndex: movingHandleIndex } = this.editData;\r\n    const { data } = annotation;\r\n\r\n    // Moving handle\r\n    const worldPos = currentPoints.world;\r\n    const canvasCoordHandlesCurrent = [\r\n      viewport.worldToCanvas(data.handles.points[0]),\r\n      viewport.worldToCanvas(data.handles.points[1]),\r\n      viewport.worldToCanvas(data.handles.points[2]),\r\n      viewport.worldToCanvas(data.handles.points[3]),\r\n    ];\r\n\r\n    const firstLineSegment = {\r\n      start: {\r\n        x: canvasCoordHandlesCurrent[0][0],\r\n        y: canvasCoordHandlesCurrent[0][1],\r\n      },\r\n      end: {\r\n        x: canvasCoordHandlesCurrent[1][0],\r\n        y: canvasCoordHandlesCurrent[1][1],\r\n      },\r\n    };\r\n    const secondLineSegment = {\r\n      start: {\r\n        x: canvasCoordHandlesCurrent[2][0],\r\n        y: canvasCoordHandlesCurrent[2][1],\r\n      },\r\n      end: {\r\n        x: canvasCoordHandlesCurrent[3][0],\r\n        y: canvasCoordHandlesCurrent[3][1],\r\n      },\r\n    };\r\n\r\n    // Handle we've selected's proposed point\r\n    const proposedPoint = <Types.Point3>[...worldPos];\r\n    const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);\r\n\r\n    if (movingHandleIndex === 0 || movingHandleIndex === 1) {\r\n      const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;\r\n\r\n      const fixedHandleCanvasCoord =\r\n        canvasCoordHandlesCurrent[fixedHandleIndex];\r\n\r\n      const fixedHandleToProposedCoordVec = vec2.set(\r\n        vec2.create(),\r\n        proposedCanvasCoord[0] - fixedHandleCanvasCoord[0],\r\n        proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]\r\n      );\r\n\r\n      const fixedHandleToOldCoordVec = vec2.set(\r\n        vec2.create(),\r\n        canvasCoordHandlesCurrent[movingHandleIndex][0] -\r\n          fixedHandleCanvasCoord[0],\r\n        canvasCoordHandlesCurrent[movingHandleIndex][1] -\r\n          fixedHandleCanvasCoord[1]\r\n      );\r\n\r\n      // normalize vector\r\n      vec2.normalize(\r\n        fixedHandleToProposedCoordVec,\r\n        fixedHandleToProposedCoordVec\r\n      );\r\n      vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);\r\n\r\n      // Check whether this\r\n      const proposedFirstLineSegment = {\r\n        start: {\r\n          x: fixedHandleCanvasCoord[0],\r\n          y: fixedHandleCanvasCoord[1],\r\n        },\r\n        end: {\r\n          x: proposedCanvasCoord[0],\r\n          y: proposedCanvasCoord[1],\r\n        },\r\n      };\r\n\r\n      // Note: this is the case when we are modifying the long axis line segment\r\n      // and we make it shorter and shorter until its second half size becomes zero\r\n      // which basically means that any more modification would make the long axis\r\n      // second half disappear. In this case, we just bail out and do not update\r\n      // since we don't want to disrupt the bidirectional shape.\r\n      if (\r\n        this._movingLongAxisWouldPutItThroughShortAxis(\r\n          proposedFirstLineSegment,\r\n          secondLineSegment\r\n        )\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      const centerOfRotation = fixedHandleCanvasCoord;\r\n\r\n      const angle = this._getSignedAngle(\r\n        fixedHandleToOldCoordVec,\r\n        fixedHandleToProposedCoordVec\r\n      );\r\n\r\n      // rotate handles around the center of rotation, first translate to origin,\r\n      // then rotate, then translate back\r\n      let firstPointX = canvasCoordHandlesCurrent[2][0];\r\n      let firstPointY = canvasCoordHandlesCurrent[2][1];\r\n\r\n      let secondPointX = canvasCoordHandlesCurrent[3][0];\r\n      let secondPointY = canvasCoordHandlesCurrent[3][1];\r\n\r\n      // translate to origin\r\n      firstPointX -= centerOfRotation[0];\r\n      firstPointY -= centerOfRotation[1];\r\n\r\n      secondPointX -= centerOfRotation[0];\r\n      secondPointY -= centerOfRotation[1];\r\n\r\n      // rotate\r\n      const rotatedFirstPoint =\r\n        firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);\r\n      const rotatedFirstPointY =\r\n        firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);\r\n\r\n      const rotatedSecondPoint =\r\n        secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);\r\n      const rotatedSecondPointY =\r\n        secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);\r\n\r\n      // translate back\r\n      firstPointX = rotatedFirstPoint + centerOfRotation[0];\r\n      firstPointY = rotatedFirstPointY + centerOfRotation[1];\r\n\r\n      secondPointX = rotatedSecondPoint + centerOfRotation[0];\r\n      secondPointY = rotatedSecondPointY + centerOfRotation[1];\r\n\r\n      // update handles\r\n      const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);\r\n      const newSecondPoint = viewport.canvasToWorld([\r\n        secondPointX,\r\n        secondPointY,\r\n      ]);\r\n\r\n      // the fixed handle is the one that is not being moved so we\r\n      // don't need to update it\r\n      data.handles.points[movingHandleIndex] = proposedPoint;\r\n      data.handles.points[2] = newFirstPoint;\r\n      data.handles.points[3] = newSecondPoint;\r\n    } else {\r\n      // Translation manipulator\r\n      const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;\r\n\r\n      const canvasCoordsCurrent = {\r\n        longLineSegment: {\r\n          start: firstLineSegment.start,\r\n          end: firstLineSegment.end,\r\n        },\r\n        shortLineSegment: {\r\n          start: secondLineSegment.start,\r\n          end: secondLineSegment.end,\r\n        },\r\n      };\r\n\r\n      const longLineSegmentVec = vec2.subtract(\r\n        vec2.create(),\r\n        [\r\n          canvasCoordsCurrent.longLineSegment.end.x,\r\n          canvasCoordsCurrent.longLineSegment.end.y,\r\n        ],\r\n        [\r\n          canvasCoordsCurrent.longLineSegment.start.x,\r\n          canvasCoordsCurrent.longLineSegment.start.y,\r\n        ]\r\n      );\r\n\r\n      const longLineSegmentVecNormalized = vec2.normalize(\r\n        vec2.create(),\r\n        longLineSegmentVec\r\n      );\r\n\r\n      const proposedToCurrentVec = vec2.subtract(\r\n        vec2.create(),\r\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\r\n        [\r\n          canvasCoordHandlesCurrent[movingHandleIndex][0],\r\n          canvasCoordHandlesCurrent[movingHandleIndex][1],\r\n        ]\r\n      );\r\n\r\n      const movementLength = vec2.length(proposedToCurrentVec);\r\n\r\n      const angle = this._getSignedAngle(\r\n        longLineSegmentVecNormalized,\r\n        proposedToCurrentVec\r\n      );\r\n\r\n      const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;\r\n\r\n      const newTranslatedPoint = vec2.scaleAndAdd(\r\n        vec2.create(),\r\n        [\r\n          canvasCoordHandlesCurrent[translateHandleIndex][0],\r\n          canvasCoordHandlesCurrent[translateHandleIndex][1],\r\n        ],\r\n        longLineSegmentVecNormalized,\r\n        movementAlongLineSegmentLength\r\n      );\r\n\r\n      // don't update if it passes through the other line segment\r\n      if (\r\n        this._movingLongAxisWouldPutItThroughShortAxis(\r\n          {\r\n            start: {\r\n              x: proposedCanvasCoord[0],\r\n              y: proposedCanvasCoord[1],\r\n            },\r\n            end: {\r\n              x: newTranslatedPoint[0],\r\n              y: newTranslatedPoint[1],\r\n            },\r\n          },\r\n          {\r\n            start: {\r\n              x: canvasCoordsCurrent.longLineSegment.start.x,\r\n              y: canvasCoordsCurrent.longLineSegment.start.y,\r\n            },\r\n            end: {\r\n              x: canvasCoordsCurrent.longLineSegment.end.x,\r\n              y: canvasCoordsCurrent.longLineSegment.end.y,\r\n            },\r\n          }\r\n        )\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      const intersectionPoint = lineSegment.intersectLine(\r\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\r\n        [newTranslatedPoint[0], newTranslatedPoint[1]],\r\n        [firstLineSegment.start.x, firstLineSegment.start.y],\r\n        [firstLineSegment.end.x, firstLineSegment.end.y]\r\n      );\r\n\r\n      // don't update if it doesn't intersect\r\n      if (!intersectionPoint) {\r\n        return;\r\n      }\r\n\r\n      data.handles.points[translateHandleIndex] = viewport.canvasToWorld(\r\n        newTranslatedPoint as Types.Point2\r\n      );\r\n      data.handles.points[movingHandleIndex] = proposedPoint;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Cancels an ongoing drawing of a bidirectional annotation\r\n   * @param element - HTML Element\r\n   */\r\n  cancel = (element: HTMLDivElement) => {\r\n    // If it is mid-draw or mid-modify\r\n    if (this.isDrawing) {\r\n      this.isDrawing = false;\r\n      this._deactivateDraw(element);\r\n      this._deactivateModify(element);\r\n      resetElementCursor(element);\r\n\r\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\r\n      const { data } = annotation;\r\n\r\n      annotation.highlighted = false;\r\n      data.handles.activeHandleIndex = null;\r\n\r\n      const { renderingEngine } = getEnabledElement(element);\r\n\r\n      triggerAnnotationRenderForViewportIds(\r\n        renderingEngine,\r\n        viewportIdsToRender\r\n      );\r\n\r\n      if (newAnnotation) {\r\n        triggerAnnotationCompleted(annotation);\r\n      }\r\n\r\n      this.editData = null;\r\n      return annotation.annotationUID;\r\n    }\r\n  };\r\n\r\n  _activateDraw = (element) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\r\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.addEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragDrawCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _deactivateDraw = (element) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\r\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.removeEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragDrawCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _activateModify = (element) => {\r\n    state.isInteractingWithTool = true;\r\n\r\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\r\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.addEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragModifyCallback as EventListener\r\n    );\r\n    element.addEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n  };\r\n\r\n  _deactivateModify = (element) => {\r\n    state.isInteractingWithTool = false;\r\n\r\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\r\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\r\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\r\n\r\n    element.removeEventListener(\r\n      Events.TOUCH_END,\r\n      this._endCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_DRAG,\r\n      this._dragModifyCallback as EventListener\r\n    );\r\n    element.removeEventListener(\r\n      Events.TOUCH_TAP,\r\n      this._endCallback as EventListener\r\n    );\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the bidirectional annotation in each\r\n   * request animation frame. It calculates the updated cached statistics if\r\n   * data is invalidated and cache it.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = true;\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n    let annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    annotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    );\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const targetId = this.getTargetId(viewport);\r\n\r\n    const renderingEngine = viewport.getRenderingEngine();\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[i] as BidirectionalAnnotation;\r\n      const { annotationUID, data } = annotation;\r\n      const { points, activeHandleIndex } = data.handles;\r\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\r\n        annotation,\r\n        styleSpecifier,\r\n      });\r\n\r\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\r\n      // force to recalculate the stats from the points\r\n      if (\r\n        !data.cachedStats[targetId] ||\r\n        data.cachedStats[targetId].unit == null\r\n      ) {\r\n        data.cachedStats[targetId] = {\r\n          length: null,\r\n          width: null,\r\n          unit: null,\r\n        };\r\n\r\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\r\n      } else if (annotation.invalidated) {\r\n        this._throttledCalculateCachedStats(\r\n          annotation,\r\n          renderingEngine,\r\n          enabledElement\r\n        );\r\n      }\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n\r\n      let activeHandleCanvasCoords;\r\n\r\n      if (!isAnnotationVisible(annotationUID)) {\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        !isAnnotationLocked(annotation) &&\r\n        !this.editData &&\r\n        activeHandleIndex !== null\r\n      ) {\r\n        // Not locked or creating and hovering over handle, so render handle.\r\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\r\n      }\r\n\r\n      if (activeHandleCanvasCoords) {\r\n        const handleGroupUID = '0';\r\n\r\n        drawHandlesSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          handleGroupUID,\r\n          activeHandleCanvasCoords,\r\n          {\r\n            color,\r\n          }\r\n        );\r\n      }\r\n\r\n      const dataId1 = `${annotationUID}-line-1`;\r\n      const dataId2 = `${annotationUID}-line-2`;\r\n\r\n      const lineUID = '0';\r\n      drawLineSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        lineUID,\r\n        canvasCoordinates[0],\r\n        canvasCoordinates[1],\r\n        {\r\n          color,\r\n          lineDash,\r\n          lineWidth,\r\n          shadow,\r\n        },\r\n        dataId1\r\n      );\r\n\r\n      const secondLineUID = '1';\r\n      drawLineSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        secondLineUID,\r\n        canvasCoordinates[2],\r\n        canvasCoordinates[3],\r\n        {\r\n          color,\r\n          lineDash,\r\n          lineWidth,\r\n          shadow,\r\n        },\r\n        dataId2\r\n      );\r\n\r\n      renderStatus = true;\r\n\r\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\r\n      if (!options.visibility) {\r\n        data.handles.textBox = {\r\n          hasMoved: false,\r\n          worldPosition: <Types.Point3>[0, 0, 0],\r\n          worldBoundingBox: {\r\n            topLeft: <Types.Point3>[0, 0, 0],\r\n            topRight: <Types.Point3>[0, 0, 0],\r\n            bottomLeft: <Types.Point3>[0, 0, 0],\r\n            bottomRight: <Types.Point3>[0, 0, 0],\r\n          },\r\n        };\r\n        continue;\r\n      }\r\n\r\n      const textLines = this.configuration.getTextLines(data, targetId);\r\n      if (!textLines || textLines.length === 0) {\r\n        continue;\r\n      }\r\n\r\n      let canvasTextBoxCoords;\r\n\r\n      if (!data.handles.textBox.hasMoved) {\r\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\r\n\r\n        data.handles.textBox.worldPosition =\r\n          viewport.canvasToWorld(canvasTextBoxCoords);\r\n      }\r\n\r\n      const textBoxPosition = viewport.worldToCanvas(\r\n        data.handles.textBox.worldPosition\r\n      );\r\n\r\n      const textBoxUID = '1';\r\n      const boundingBox = drawLinkedTextBoxSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        textBoxUID,\r\n        textLines,\r\n        textBoxPosition,\r\n        canvasCoordinates,\r\n        {},\r\n        options\r\n      );\r\n\r\n      const { x: left, y: top, width, height } = boundingBox;\r\n\r\n      data.handles.textBox.worldBoundingBox = {\r\n        topLeft: viewport.canvasToWorld([left, top]),\r\n        topRight: viewport.canvasToWorld([left + width, top]),\r\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\r\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\r\n      };\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  _movingLongAxisWouldPutItThroughShortAxis = (\r\n    firstLineSegment,\r\n    secondLineSegment\r\n  ) => {\r\n    const vectorInSecondLineDirection = vec2.create();\r\n\r\n    vec2.set(\r\n      vectorInSecondLineDirection,\r\n      secondLineSegment.end.x - secondLineSegment.start.x,\r\n      secondLineSegment.end.y - secondLineSegment.start.y\r\n    );\r\n\r\n    vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);\r\n\r\n    const extendedSecondLineSegment = {\r\n      start: {\r\n        x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,\r\n        y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,\r\n      },\r\n      end: {\r\n        x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,\r\n        y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,\r\n      },\r\n    };\r\n\r\n    // Add some buffer in the secondLineSegment when finding the proposedIntersectionPoint\r\n    // Of points to stop us getting stack when rotating quickly.\r\n\r\n    const proposedIntersectionPoint = lineSegment.intersectLine(\r\n      [extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y],\r\n      [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y],\r\n      [firstLineSegment.start.x, firstLineSegment.start.y],\r\n      [firstLineSegment.end.x, firstLineSegment.end.y]\r\n    );\r\n\r\n    const wouldPutThroughShortAxis = !proposedIntersectionPoint;\r\n\r\n    return wouldPutThroughShortAxis;\r\n  };\r\n\r\n  _calculateLength(pos1, pos2) {\r\n    const dx = pos1[0] - pos2[0];\r\n    const dy = pos1[1] - pos2[1];\r\n    const dz = pos1[2] - pos2[2];\r\n\r\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\r\n  }\r\n\r\n  _calculateCachedStats = (annotation, renderingEngine, enabledElement) => {\r\n    const { data } = annotation;\r\n    const { element } = enabledElement.viewport;\r\n\r\n    const worldPos1 = data.handles.points[0];\r\n    const worldPos2 = data.handles.points[1];\r\n    const worldPos3 = data.handles.points[2];\r\n    const worldPos4 = data.handles.points[3];\r\n\r\n    const { cachedStats } = data;\r\n    const targetIds = Object.keys(cachedStats);\r\n\r\n    for (let i = 0; i < targetIds.length; i++) {\r\n      const targetId = targetIds[i];\r\n\r\n      const image = this.getTargetIdImage(targetId, renderingEngine);\r\n\r\n      // If image does not exists for the targetId, skip. This can be due\r\n      // to various reasons such as if the target was a volumeViewport, and\r\n      // the volumeViewport has been decached in the meantime.\r\n      if (!image) {\r\n        continue;\r\n      }\r\n\r\n      const { imageData, dimensions } = image;\r\n      const index1 = transformWorldToIndex(imageData, worldPos1);\r\n      const index2 = transformWorldToIndex(imageData, worldPos2);\r\n      const index3 = transformWorldToIndex(imageData, worldPos3);\r\n      const index4 = transformWorldToIndex(imageData, worldPos4);\r\n\r\n      const handles1 = [index1, index2];\r\n      const handles2 = [index3, index4];\r\n\r\n      const { scale: scale1, units: units1 } = getCalibratedLengthUnitsAndScale(\r\n        image,\r\n        handles1\r\n      );\r\n\r\n      const { scale: scale2, units: units2 } = getCalibratedLengthUnitsAndScale(\r\n        image,\r\n        handles2\r\n      );\r\n\r\n      const dist1 = this._calculateLength(worldPos1, worldPos2) / scale1;\r\n      const dist2 = this._calculateLength(worldPos3, worldPos4) / scale2;\r\n      const length = dist1 > dist2 ? dist1 : dist2;\r\n      const width = dist1 > dist2 ? dist2 : dist1;\r\n\r\n      const lengthUnit = dist1 > dist2 ? units1 : units2;\r\n      const widthUnit = dist1 > dist2 ? units2 : units1;\r\n\r\n      this._isInsideVolume(index1, index2, index3, index4, dimensions)\r\n        ? (this.isHandleOutsideImage = false)\r\n        : (this.isHandleOutsideImage = true);\r\n\r\n      cachedStats[targetId] = {\r\n        length,\r\n        width,\r\n        unit: units1,\r\n        lengthUnit,\r\n        widthUnit,\r\n      };\r\n    }\r\n\r\n    annotation.invalidated = false;\r\n\r\n    // Dispatching annotation modified\r\n    triggerAnnotationModified(annotation, element);\r\n\r\n    return cachedStats;\r\n  };\r\n\r\n  _isInsideVolume = (index1, index2, index3, index4, dimensions): boolean => {\r\n    return (\r\n      csUtils.indexWithinDimensions(index1, dimensions) &&\r\n      csUtils.indexWithinDimensions(index2, dimensions) &&\r\n      csUtils.indexWithinDimensions(index3, dimensions) &&\r\n      csUtils.indexWithinDimensions(index4, dimensions)\r\n    );\r\n  };\r\n\r\n  _getSignedAngle = (vector1, vector2) => {\r\n    return Math.atan2(\r\n      vector1[0] * vector2[1] - vector1[1] * vector2[0],\r\n      vector1[0] * vector2[0] + vector1[1] * vector2[1]\r\n    );\r\n  };\r\n}\r\n\r\nfunction defaultGetTextLines(data, targetId): string[] {\r\n  const { cachedStats, label } = data;\r\n  const { length, width, unit, lengthUnit, widthUnit } = cachedStats[targetId];\r\n\r\n  const textLines = [];\r\n  if (label) {\r\n    textLines.push(label);\r\n  }\r\n  if (length === undefined) {\r\n    return textLines;\r\n  }\r\n\r\n  // spaceBetweenSlices & pixelSpacing &\r\n  // magnitude in each direction? Otherwise, this is \"px\"?\r\n  textLines.push(\r\n    `L: ${roundNumber(length)} ${lengthUnit || unit}`,\r\n    `W: ${roundNumber(width)} ${widthUnit || unit}`\r\n  );\r\n\r\n  return textLines;\r\n}\r\n\r\nBidirectionalTool.toolName = 'Bidirectional';\r\nexport default BidirectionalTool;\r\n","import {\r\n  CONSTANTS,\r\n  getEnabledElement,\r\n  VolumeViewport,\r\n  utilities as csUtils,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport { vec3 } from 'gl-matrix';\r\n\r\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\r\nimport { math, roundNumber } from '../../utilities';\r\nimport { polyline } from '../../utilities/math';\r\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\r\nimport throttle from '../../utilities/throttle';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\nimport registerDrawLoop from './planarFreehandROITool/drawLoop';\r\nimport registerEditLoopCommon from './planarFreehandROITool/editLoopCommon';\r\nimport registerClosedContourEditLoop from './planarFreehandROITool/closedContourEditLoop';\r\nimport registerOpenContourEditLoop from './planarFreehandROITool/openContourEditLoop';\r\nimport registerOpenContourEndEditLoop from './planarFreehandROITool/openContourEndEditLoop';\r\nimport registerRenderMethods from './planarFreehandROITool/renderMethods';\r\nimport type {\r\n  EventTypes,\r\n  ToolHandle,\r\n  Annotation,\r\n  Annotations,\r\n  AnnotationStyle,\r\n  PublicToolProps,\r\n  ToolProps,\r\n  SVGDrawingHelper,\r\n  AnnotationRenderContext,\r\n} from '../../types';\r\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\r\nimport { drawLinkedTextBox } from '../../drawingSvg';\r\nimport { PlanarFreehandROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\r\nimport { PlanarFreehandROICommonData } from '../../utilities/math/polyline/planarFreehandROIInternalTypes';\r\n\r\nimport { getLineSegmentIntersectionsCoordinates } from '../../utilities/math/polyline';\r\nimport pointInShapeCallback from '../../utilities/pointInShapeCallback';\r\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\r\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\r\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\r\nimport calculatePerimeter from '../../utilities/contours/calculatePerimeter';\r\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\r\nimport { KeyboardBindings, ChangeTypes } from '../../enums';\r\n\r\nconst { pointCanProjectOnLine } = polyline;\r\nconst { EPSILON } = CONSTANTS;\r\n\r\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\r\n\r\n/**\r\n * PlanarFreehandROITool lets you draw annotations that define an arbitrarily drawn region.\r\n * You can use the PlanarFreehandROITool in all perpendicular views (axial, sagittal, coronal),\r\n * support for oblique views is possible, but not yet supported, due to the implementation of\r\n * `getSubPixelSpacingAndXYDirections`.\r\n *\r\n * The resulting annotation's data and metadata (the\r\n * state of the viewport while drawing was happening) will get added to the\r\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\r\n * or similar methods.\r\n *\r\n * PlanarFreehandROITool annotation can be smoothed on drawing completion. This is a configured based approach.\r\n * The smoothing process uses b-spline algorithm and consider 4 configurations properties:\r\n * - smoothing.smoothOnAdd: to tell whether it should be smoothed or not (for editing it is considered the property smoothOnEdit) (default: false)\r\n * - smoothing.smoothOnEdit: to tell whether it should be smoothed or not when editing (default: false)\r\n * - smoothing.knotsRatioPercentageOnAdd: percentage of points from Segment that are likely to be considered knots during smoothing (for editing it is considered the property knotsRatioPercentageOnEdit) ( default: 40)\r\n * - smoothing.knotsRatioPercentageOnEdit: same as knotsRatioPercentageOnAdd but applicable only when editing the tool (default: 40)\r\n *\r\n * So, with that said the smoothing might occur when:\r\n * - drawing is done (i.e mouse is released) and smoothing.smoothOnAdd is true. smoothing algorithm uses knotsRatioPercentageOnAdd\r\n * - edit drawing is done (i.e mouse is released) and smoothing.smoothOnEdit is true. smoothing algorithm uses knotsRatioPercentageOnEdit and its only applied to changed segment\r\n * smoothing does not occur when:\r\n * - smoothing.smoothOnAdd is false and drawing is completed\r\n * - smoothing.smoothOnEdit is false and edit is completed\r\n * - drawing still happening (editing or not)\r\n *\r\n * The result of smoothing will be removal of some of the outliers\r\n * Changing tool configuration (see below) you can fine-tune the smoothing process by changing knotsRatioPercentageOnAdd and knotsRatioPercentageOnEdit value, which smaller values produces a more agressive smoothing.\r\n * A smaller value of knotsRatioPercentageOnAdd/knotsRatioPercentageOnEdit produces a more aggressive smoothing.\r\n *\r\n * ```js\r\n * cornerstoneTools.addTool(PlanarFreehandROITool)\r\n *\r\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\r\n *\r\n * toolGroup.addTool(PlanarFreehandROITool.toolName)\r\n *\r\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\r\n *\r\n * toolGroup.setToolActive(PlanarFreehandROITool.toolName, {\r\n *   bindings: [\r\n *    {\r\n *       mouseButton: MouseBindings.Primary, // Left Click\r\n *     },\r\n *   ],\r\n * })\r\n *\r\n * // set smoothing aggressiveness while adding new annotation (ps: this does not change if smoothing is ON or OFF)\r\n * toolGroup.setToolConfiguration(PlanarFreehandROITool.toolName, {\r\n *   smoothing: { knotsRatioPercentageOnAdd: 30 },\r\n * });\r\n *\r\n * // set smoothing to be ON while editing only\r\n * toolGroup.setToolConfiguration(PlanarFreehandROITool.toolName, {\r\n *   smoothing: { smoothOnAdd: false, smoothOnEdit: true  },\r\n * });\r\n * ```\r\n *\r\n *\r\n * Read more in the Docs section of the website.\r\n */\r\n\r\nclass PlanarFreehandROITool extends ContourSegmentationBaseTool {\r\n  static toolName;\r\n\r\n  public touchDragCallback: any;\r\n  public mouseDragCallback: any;\r\n  _throttledCalculateCachedStats: any;\r\n  private commonData?: PlanarFreehandROICommonData;\r\n  isDrawing = false;\r\n  isEditingClosed = false;\r\n  isEditingOpen = false;\r\n\r\n  protected activateDraw: (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: PlanarFreehandROIAnnotation,\r\n    viewportIdsToRender: string[]\r\n  ) => void;\r\n  private activateClosedContourEdit: (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: PlanarFreehandROIAnnotation,\r\n    viewportIdsToRender: string[]\r\n  ) => void;\r\n  private activateOpenContourEdit: (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: PlanarFreehandROIAnnotation,\r\n    viewportIdsToRender: string[]\r\n  ) => void;\r\n  private activateOpenContourEndEdit: (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: PlanarFreehandROIAnnotation,\r\n    viewportIdsToRender: string[],\r\n    handle: ToolHandle | null\r\n  ) => void;\r\n  private cancelDrawing: (element: HTMLDivElement) => void;\r\n  private cancelClosedContourEdit: (element: HTMLDivElement) => void;\r\n  private cancelOpenContourEdit: (element: HTMLDivElement) => void;\r\n\r\n  private renderContour: (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper,\r\n    annotation: PlanarFreehandROIAnnotation\r\n  ) => void;\r\n  private renderContourBeingDrawn: (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper,\r\n    annotation: PlanarFreehandROIAnnotation\r\n  ) => void;\r\n  private renderClosedContourBeingEdited: (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper,\r\n    annotation: PlanarFreehandROIAnnotation\r\n  ) => void;\r\n  private renderOpenContourBeingEdited: (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper,\r\n    annotation: PlanarFreehandROIAnnotation\r\n  ) => void;\r\n\r\n  private renderPointContourWithMarker: (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper,\r\n    annotation: PlanarFreehandROIAnnotation\r\n  ) => void;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        shadow: true,\r\n        preventHandleOutsideImage: false,\r\n        /**\r\n         * Specify which modifier key is used to add a hole to a contour. The\r\n         * modifier must be pressed when the first point of a new contour is added.\r\n         */\r\n        contourHoleAdditionModifierKey: KeyboardBindings.Shift,\r\n        alwaysRenderOpenContourHandles: {\r\n          // When true, always render end points when you have an open contour, rather\r\n          // than just rendering a line.\r\n          enabled: false,\r\n          // When enabled, use this radius to draw the endpoints whilst not hovering.\r\n          radius: 2,\r\n        },\r\n        allowOpenContours: true,\r\n        // Proximity in canvas coordinates used to join contours.\r\n        closeContourProximity: 10,\r\n        // The proximity at which we fallback to the simplest grabbing logic for\r\n        // determining what index of the contour to start editing.\r\n        checkCanvasEditFallbackProximity: 6,\r\n        // For closed contours, make them clockwise\r\n        // This can be useful if contours are compared between slices, eg for\r\n        // interpolation, and does not cause problems otherwise so defaulting to true.\r\n        makeClockWise: true,\r\n        // The relative distance that points should be dropped along the polyline\r\n        // in units of the image pixel spacing. A value of 1 means that nodes must\r\n        // be placed no closed than the image spacing apart. A value of 4 means that 4\r\n        // nodes should be placed within the space of one image pixel size. A higher\r\n        // value gives more finesse to the tool/smoother lines, but the value cannot\r\n        // be infinite as the lines become very computationally expensive to draw.\r\n        subPixelResolution: 4,\r\n        /**\r\n         * Smoothing is used to remove jagged irregularities in the polyline,\r\n         * as opposed to interpolation, which is used to create new polylines\r\n         * between existing polylines.\r\n         */\r\n        smoothing: {\r\n          smoothOnAdd: false,\r\n          smoothOnEdit: false, // used for edit only\r\n          knotsRatioPercentageOnAdd: 40,\r\n          knotsRatioPercentageOnEdit: 40,\r\n        },\r\n        /**\r\n         * Interpolation is the creation of new segmentations in between the\r\n         * existing segmentations/indices.  Note that this does not apply to\r\n         * ROI values, since those annotations are individual annotations, not\r\n         * connected in any way to each other, whereas segmentations are intended\r\n         * to be connected 2d + 1 dimension (time or space or other) volumes.\r\n         */\r\n        interpolation: {\r\n          enabled: false,\r\n          // Callback to update the annotation or perform other action when the\r\n          // interpolation is complete.\r\n          onInterpolationComplete: null,\r\n        },\r\n        /**\r\n         * The polyline may get processed in order to reduce the number of points\r\n         * for better performance and storage.\r\n         */\r\n        decimate: {\r\n          enabled: false,\r\n          /** A maximum given distance 'epsilon' to decide if a point should or\r\n           * shouldn't be added the resulting polyline which will have a lower\r\n           * number of points for higher `epsilon` values.\r\n           */\r\n          epsilon: 0.1,\r\n        },\r\n        displayOnePointAsCrosshairs: false,\r\n        calculateStats: true,\r\n        getTextLines: defaultGetTextLines,\r\n        statsCalculator: BasicStatsCalculator,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n\r\n    // Register event loops and rendering logic, which are stored in different\r\n    // Files due to their complexity/size.\r\n    registerDrawLoop(this);\r\n    registerEditLoopCommon(this);\r\n    registerClosedContourEditLoop(this);\r\n    registerOpenContourEditLoop(this);\r\n    registerOpenContourEndEditLoop(this);\r\n    registerRenderMethods(this);\r\n\r\n    this._throttledCalculateCachedStats = throttle(\r\n      this._calculateCachedStats,\r\n      100,\r\n      { trailing: true }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the current image, creates\r\n   * a `PlanarFreehandROIAnnotation` and stores it in the annotationManager.\r\n   *\r\n   * @param evt - `EventTypes.NormalizedMouseEventType`\r\n   * @returns The `PlanarFreehandROIAnnotation` object.\r\n   */\r\n  addNewAnnotation = (\r\n    evt: EventTypes.InteractionEventType\r\n  ): PlanarFreehandROIAnnotation => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    const annotation = this.createAnnotation(\r\n      evt\r\n    ) as PlanarFreehandROIAnnotation;\r\n\r\n    this.addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.activateDraw(evt, annotation, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  };\r\n\r\n  /**\r\n   * Begins an edit of an open contour, when the mouse has selected a handle\r\n   * (end) of the open contour.\r\n   *\r\n   * @param evt - `EventTypes.MouseDownEventType`\r\n   * @param annotation - `PlanarFreehandROIAnnotation` annotation.\r\n   * @param handle - The handle index, 0 for the start and 1 for the end.\r\n   * @param interactionType - interaction type (mouse, touch)\r\n   */\r\n  handleSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: PlanarFreehandROIAnnotation,\r\n    handle: ToolHandle\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.activateOpenContourEndEdit(\r\n      evt,\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handle\r\n    );\r\n  };\r\n\r\n  /**\r\n   * Edits the open or closed contour when the line is grabbed and dragged.\r\n   */\r\n  toolSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: PlanarFreehandROIAnnotation\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    if (annotation.data.contour.closed) {\r\n      this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\r\n    } else {\r\n      this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);\r\n    }\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  /**\r\n   * Returns if the canvas point is near the line of the given annotation in the\r\n   * provided element or not. A proximity is passed to the function to determine the\r\n   * proximity of the point to the annotation in number of pixels.\r\n   *\r\n   * @param element - HTML Element\r\n   * @param annotation - The `PlanarFreehandROIAnnotation`.\r\n   * @param canvasCoords - Canvas coordinates\r\n   * @param proximity - Proximity to tool to consider\r\n   * @returns Boolean, whether the canvas point is near tool\r\n   */\r\n  isPointNearTool = (\r\n    element: HTMLDivElement,\r\n    annotation: PlanarFreehandROIAnnotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): boolean => {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    const { polyline: points } = annotation.data.contour;\r\n\r\n    // NOTE: It is implemented this way so that we do not double calculate\r\n    // points when number crunching adjacent line segments.\r\n    let previousPoint = viewport.worldToCanvas(points[0]);\r\n\r\n    for (let i = 1; i < points.length; i++) {\r\n      const p1 = previousPoint;\r\n      const p2 = viewport.worldToCanvas(points[i]);\r\n      const canProject = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);\r\n\r\n      if (canProject) {\r\n        return true;\r\n      }\r\n\r\n      previousPoint = p2;\r\n    }\r\n\r\n    if (!annotation.data.contour.closed) {\r\n      // Contour is open, don't check last point to first point.\r\n      return false;\r\n    }\r\n\r\n    // check last point to first point\r\n    const pStart = viewport.worldToCanvas(points[0]);\r\n    const pEnd = viewport.worldToCanvas(points[points.length - 1]);\r\n\r\n    return pointCanProjectOnLine(canvasCoords, pStart, pEnd, proximity);\r\n  };\r\n\r\n  public cancel = (element: HTMLDivElement): void => {\r\n    const isDrawing = this.isDrawing;\r\n    const isEditingOpen = this.isEditingOpen;\r\n    const isEditingClosed = this.isEditingClosed;\r\n\r\n    if (isDrawing) {\r\n      this.cancelDrawing(element);\r\n    } else if (isEditingOpen) {\r\n      this.cancelOpenContourEdit(element);\r\n    } else if (isEditingClosed) {\r\n      this.cancelClosedContourEdit(element);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @override We need to override this method as the tool doesn't always have\r\n   * `handles`, which means `filterAnnotationsForDisplay` fails inside\r\n   * `filterAnnotationsWithinSlice`.\r\n   */\r\n  public filterInteractableAnnotationsForElement(\r\n    element: HTMLDivElement,\r\n    annotations: Annotations\r\n  ): Annotations | undefined {\r\n    if (!annotations || !annotations.length) {\r\n      return;\r\n    }\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    let annotationsToDisplay;\r\n\r\n    if (viewport instanceof VolumeViewport) {\r\n      const camera = viewport.getCamera();\r\n\r\n      const { spacingInNormalDirection } =\r\n        csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\r\n\r\n      // Get data with same normal and within the same slice\r\n      annotationsToDisplay = this.filterAnnotationsWithinSlice(\r\n        annotations,\r\n        camera,\r\n        spacingInNormalDirection\r\n      );\r\n    } else {\r\n      // Use the default `filterAnnotationsForDisplay` utility, as the stack\r\n      // path doesn't require handles.\r\n      annotationsToDisplay = filterAnnotationsForDisplay(viewport, annotations);\r\n    }\r\n\r\n    return annotationsToDisplay;\r\n  }\r\n\r\n  /**\r\n   * Altered version of the `utilities.planar.filterAnnotationsWithinSlice`,\r\n   * which uses the polyline position rather than the handle. As the polyline is\r\n   * always present.\r\n   */\r\n  private filterAnnotationsWithinSlice(\r\n    annotations: Annotations,\r\n    camera: Types.ICamera,\r\n    spacingInNormalDirection: number\r\n  ): Annotations {\r\n    const { viewPlaneNormal } = camera;\r\n\r\n    const annotationsWithParallelNormals = annotations.filter(\r\n      (td: Annotation) => {\r\n        const annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\r\n\r\n        const isParallel =\r\n          Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\r\n          PARALLEL_THRESHOLD;\r\n\r\n        return annotationViewPlaneNormal && isParallel;\r\n      }\r\n    ) as PlanarFreehandROIAnnotation[];\r\n\r\n    // No in plane annotations.\r\n    if (!annotationsWithParallelNormals.length) {\r\n      return [];\r\n    }\r\n\r\n    // Annotation should be within the slice, which means that it should be between\r\n    // camera's focalPoint +/- spacingInNormalDirection.\r\n\r\n    const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\r\n    const { focalPoint } = camera;\r\n\r\n    const annotationsWithinSlice = [];\r\n\r\n    for (const annotation of annotationsWithParallelNormals) {\r\n      const data = annotation.data;\r\n      const point = data.contour.polyline[0];\r\n\r\n      if (!annotation.isVisible) {\r\n        continue;\r\n      }\r\n\r\n      // A = point\r\n      // B = focal point\r\n      // P = normal\r\n\r\n      // B-A dot P  => Distance in the view direction.\r\n      // this should be less than half the slice distance.\r\n\r\n      const dir = vec3.create();\r\n\r\n      vec3.sub(dir, focalPoint, point);\r\n\r\n      const dot = vec3.dot(dir, viewPlaneNormal);\r\n\r\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\r\n        annotationsWithinSlice.push(annotation);\r\n      }\r\n    }\r\n\r\n    return annotationsWithinSlice;\r\n  }\r\n\r\n  protected isContourSegmentationTool(): boolean {\r\n    // Disable contour segmentation behavior because it shall be activated only\r\n    // for PlanarFreehandContourSegmentationTool\r\n    return false;\r\n  }\r\n\r\n  protected createAnnotation(evt: EventTypes.InteractionEventType): Annotation {\r\n    const worldPos = evt.detail.currentPoints.world;\r\n    const contourAnnotation = super.createAnnotation(evt);\r\n\r\n    const onInterpolationComplete = (annotation) => {\r\n      // Clear out the handles because they aren't used for straight freeform\r\n      annotation.data.handles.points.length = 0;\r\n    };\r\n\r\n    const annotation = <PlanarFreehandROIAnnotation>csUtils.deepMerge(\r\n      contourAnnotation,\r\n      {\r\n        data: {\r\n          contour: {\r\n            polyline: [<Types.Point3>[...worldPos]],\r\n          },\r\n          label: '',\r\n          cachedStats: {},\r\n        },\r\n        onInterpolationComplete,\r\n      }\r\n    );\r\n\r\n    return annotation;\r\n  }\r\n\r\n  protected getAnnotationStyle(context) {\r\n    // This method exists only because `super` cannot be called from\r\n    // _getRenderingOptions() which is in an external file.\r\n    return super.getAnnotationStyle(context);\r\n  }\r\n\r\n  protected renderAnnotationInstance(\r\n    renderContext: AnnotationRenderContext\r\n  ): boolean {\r\n    const { enabledElement, targetId, svgDrawingHelper } = renderContext;\r\n    const annotation = renderContext.annotation as PlanarFreehandROIAnnotation;\r\n\r\n    let renderStatus = false;\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    const isDrawing = this.isDrawing;\r\n    const isEditingOpen = this.isEditingOpen;\r\n    const isEditingClosed = this.isEditingClosed;\r\n\r\n    if (!(isDrawing || isEditingOpen || isEditingClosed)) {\r\n      // No annotations are currently being modified, so we can just use the\r\n      // render contour method to render all of them\r\n      if (\r\n        this.configuration.displayOnePointAsCrosshairs &&\r\n        annotation.data.contour.polyline.length === 1\r\n      ) {\r\n        this.renderPointContourWithMarker(\r\n          enabledElement,\r\n          svgDrawingHelper,\r\n          annotation\r\n        );\r\n      } else {\r\n        this.renderContour(enabledElement, svgDrawingHelper, annotation);\r\n      }\r\n    } else {\r\n      // The active annotation will need special rendering treatment. Render all\r\n      // other annotations not being interacted with using the standard renderContour\r\n      // rendering path.\r\n      const activeAnnotationUID = this.commonData.annotation.annotationUID;\r\n\r\n      if (annotation.annotationUID === activeAnnotationUID) {\r\n        if (isDrawing) {\r\n          this.renderContourBeingDrawn(\r\n            enabledElement,\r\n            svgDrawingHelper,\r\n            annotation\r\n          );\r\n        } else if (isEditingClosed) {\r\n          this.renderClosedContourBeingEdited(\r\n            enabledElement,\r\n            svgDrawingHelper,\r\n            annotation\r\n          );\r\n        } else if (isEditingOpen) {\r\n          this.renderOpenContourBeingEdited(\r\n            enabledElement,\r\n            svgDrawingHelper,\r\n            annotation\r\n          );\r\n        } else {\r\n          throw new Error(\r\n            `Unknown ${this.getToolName()} annotation rendering state`\r\n          );\r\n        }\r\n      } else {\r\n        if (\r\n          this.configuration.displayOnePointAsCrosshairs &&\r\n          annotation.data.contour.polyline.length === 1\r\n        ) {\r\n          this.renderPointContourWithMarker(\r\n            enabledElement,\r\n            svgDrawingHelper,\r\n            annotation\r\n          );\r\n        } else {\r\n          this.renderContour(enabledElement, svgDrawingHelper, annotation);\r\n        }\r\n      }\r\n\r\n      // Todo: return boolean flag for each rendering route in the planar tool.\r\n      renderStatus = true;\r\n    }\r\n\r\n    if (!this.configuration.calculateStats) {\r\n      return;\r\n    }\r\n\r\n    this._calculateStatsIfActive(\r\n      annotation,\r\n      targetId,\r\n      viewport,\r\n      renderingEngine,\r\n      enabledElement\r\n    );\r\n\r\n    this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);\r\n\r\n    return renderStatus;\r\n  }\r\n\r\n  _calculateStatsIfActive(\r\n    annotation: PlanarFreehandROIAnnotation,\r\n    targetId: string,\r\n    viewport,\r\n    renderingEngine,\r\n    enabledElement\r\n  ) {\r\n    const activeAnnotationUID = this.commonData?.annotation.annotationUID;\r\n\r\n    if (\r\n      annotation.annotationUID === activeAnnotationUID &&\r\n      !this.commonData?.movingTextBox\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    if (!this.commonData?.movingTextBox) {\r\n      const { data } = annotation;\r\n      if (\r\n        !data.cachedStats[targetId] ||\r\n        data.cachedStats[targetId].areaUnit == null\r\n      ) {\r\n        data.cachedStats[targetId] = {\r\n          Modality: null,\r\n          area: null,\r\n          max: null,\r\n          mean: null,\r\n          stdDev: null,\r\n          areaUnit: null,\r\n        };\r\n\r\n        this._calculateCachedStats(\r\n          annotation,\r\n          viewport,\r\n          renderingEngine,\r\n          enabledElement\r\n        );\r\n      } else if (annotation.invalidated) {\r\n        this._throttledCalculateCachedStats(\r\n          annotation,\r\n          viewport,\r\n          renderingEngine,\r\n          enabledElement\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  private _calculateCachedStats = (\r\n    annotation,\r\n    viewport,\r\n    renderingEngine,\r\n    enabledElement\r\n  ) => {\r\n    const { data } = annotation;\r\n    const { cachedStats } = data;\r\n    const { polyline: points, closed } = data.contour;\r\n\r\n    const targetIds = Object.keys(cachedStats);\r\n\r\n    for (let i = 0; i < targetIds.length; i++) {\r\n      const targetId = targetIds[i];\r\n      const image = this.getTargetIdImage(targetId, renderingEngine);\r\n\r\n      // If image does not exists for the targetId, skip. This can be due\r\n      // to various reasons such as if the target was a volumeViewport, and\r\n      // the volumeViewport has been decached in the meantime.\r\n      if (!image) {\r\n        continue;\r\n      }\r\n\r\n      const { imageData, metadata } = image;\r\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n      // Using an arbitrary start point (canvasPoint), calculate the\r\n      // mm spacing for the canvas in the X and Y directions.\r\n      const canvasPoint = canvasCoordinates[0];\r\n      const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\r\n      const deltaXPoint = viewport.canvasToWorld([\r\n        canvasPoint[0] + 1,\r\n        canvasPoint[1],\r\n      ]);\r\n      const deltaYPoint = viewport.canvasToWorld([\r\n        canvasPoint[0],\r\n        canvasPoint[1] + 1,\r\n      ]);\r\n\r\n      const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\r\n      const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\r\n\r\n      const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[0]);\r\n      worldPosIndex[0] = Math.floor(worldPosIndex[0]);\r\n      worldPosIndex[1] = Math.floor(worldPosIndex[1]);\r\n      worldPosIndex[2] = Math.floor(worldPosIndex[2]);\r\n\r\n      let iMin = worldPosIndex[0];\r\n      let iMax = worldPosIndex[0];\r\n\r\n      let jMin = worldPosIndex[1];\r\n      let jMax = worldPosIndex[1];\r\n\r\n      let kMin = worldPosIndex[2];\r\n      let kMax = worldPosIndex[2];\r\n\r\n      for (let j = 1; j < points.length; j++) {\r\n        const worldPosIndex = csUtils.transformWorldToIndex(\r\n          imageData,\r\n          points[j]\r\n        );\r\n        worldPosIndex[0] = Math.floor(worldPosIndex[0]);\r\n        worldPosIndex[1] = Math.floor(worldPosIndex[1]);\r\n        worldPosIndex[2] = Math.floor(worldPosIndex[2]);\r\n        iMin = Math.min(iMin, worldPosIndex[0]);\r\n        iMax = Math.max(iMax, worldPosIndex[0]);\r\n\r\n        jMin = Math.min(jMin, worldPosIndex[1]);\r\n        jMax = Math.max(jMax, worldPosIndex[1]);\r\n\r\n        kMin = Math.min(kMin, worldPosIndex[2]);\r\n        kMax = Math.max(kMax, worldPosIndex[2]);\r\n      }\r\n\r\n      const worldPosIndex2 = csUtils.transformWorldToIndex(\r\n        imageData,\r\n        points[1]\r\n      );\r\n      worldPosIndex2[0] = Math.floor(worldPosIndex2[0]);\r\n      worldPosIndex2[1] = Math.floor(worldPosIndex2[1]);\r\n      worldPosIndex2[2] = Math.floor(worldPosIndex2[2]);\r\n\r\n      const { scale, areaUnits } = getCalibratedLengthUnitsAndScale(\r\n        image,\r\n        () => {\r\n          const polyline = data.contour.polyline;\r\n          const numPoints = polyline.length;\r\n          const projectedPolyline = new Array(numPoints);\r\n\r\n          for (let i = 0; i < numPoints; i++) {\r\n            projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\r\n          }\r\n\r\n          const {\r\n            maxX: canvasMaxX,\r\n            maxY: canvasMaxY,\r\n            minX: canvasMinX,\r\n            minY: canvasMinY,\r\n          } = math.polyline.getAABB(projectedPolyline);\r\n\r\n          const topLeftBBWorld = viewport.canvasToWorld([\r\n            canvasMinX,\r\n            canvasMinY,\r\n          ]);\r\n\r\n          const topLeftBBIndex = csUtils.transformWorldToIndex(\r\n            imageData,\r\n            topLeftBBWorld\r\n          );\r\n\r\n          const bottomRightBBWorld = viewport.canvasToWorld([\r\n            canvasMaxX,\r\n            canvasMaxY,\r\n          ]);\r\n\r\n          const bottomRightBBIndex = csUtils.transformWorldToIndex(\r\n            imageData,\r\n            bottomRightBBWorld\r\n          );\r\n\r\n          return [topLeftBBIndex, bottomRightBBIndex];\r\n        }\r\n      );\r\n      let area = polyline.getArea(canvasCoordinates) / scale / scale;\r\n      // Convert from canvas_pixels ^2 to mm^2\r\n      area *= deltaInX * deltaInY;\r\n\r\n      // Expand bounding box\r\n      const iDelta = 0.01 * (iMax - iMin);\r\n      const jDelta = 0.01 * (jMax - jMin);\r\n      const kDelta = 0.01 * (kMax - kMin);\r\n\r\n      iMin = Math.floor(iMin - iDelta);\r\n      iMax = Math.ceil(iMax + iDelta);\r\n      jMin = Math.floor(jMin - jDelta);\r\n      jMax = Math.ceil(jMax + jDelta);\r\n      kMin = Math.floor(kMin - kDelta);\r\n      kMax = Math.ceil(kMax + kDelta);\r\n\r\n      const boundsIJK = [\r\n        [iMin, iMax],\r\n        [jMin, jMax],\r\n        [kMin, kMax],\r\n      ] as [Types.Point2, Types.Point2, Types.Point2];\r\n\r\n      const worldPosEnd = imageData.indexToWorld([iMax, jMax, kMax]);\r\n      const canvasPosEnd = viewport.worldToCanvas(worldPosEnd);\r\n\r\n      let curRow = 0;\r\n      let intersections = [];\r\n      let intersectionCounter = 0;\r\n      const pointsInShape = pointInShapeCallback(\r\n        imageData,\r\n        (pointLPS, pointIJK) => {\r\n          let result = true;\r\n          const point = viewport.worldToCanvas(pointLPS);\r\n          if (point[1] != curRow) {\r\n            intersectionCounter = 0;\r\n            curRow = point[1];\r\n            intersections = getLineSegmentIntersectionsCoordinates(\r\n              canvasCoordinates,\r\n              point,\r\n              [canvasPosEnd[0], point[1]]\r\n            );\r\n            intersections.sort(\r\n              (function (index) {\r\n                return function (a, b) {\r\n                  return a[index] === b[index]\r\n                    ? 0\r\n                    : a[index] < b[index]\r\n                    ? -1\r\n                    : 1;\r\n                };\r\n              })(0)\r\n            );\r\n          }\r\n          if (intersections.length && point[0] > intersections[0][0]) {\r\n            intersections.shift();\r\n            intersectionCounter++;\r\n          }\r\n          if (intersectionCounter % 2 === 0) {\r\n            result = false;\r\n          }\r\n          return result;\r\n        },\r\n        this.configuration.statsCalculator.statsCallback,\r\n        boundsIJK\r\n      );\r\n\r\n      const modalityUnitOptions = {\r\n        isPreScaled: isViewportPreScaled(viewport, targetId),\r\n        isSuvScaled: this.isSuvScaled(\r\n          viewport,\r\n          targetId,\r\n          annotation.metadata.referencedImageId\r\n        ),\r\n      };\r\n\r\n      const modalityUnit = getModalityUnit(\r\n        metadata.Modality,\r\n        annotation.metadata.referencedImageId,\r\n        modalityUnitOptions\r\n      );\r\n\r\n      const stats = this.configuration.statsCalculator.getStatistics();\r\n\r\n      cachedStats[targetId] = {\r\n        Modality: metadata.Modality,\r\n        area,\r\n        perimeter: calculatePerimeter(canvasCoordinates, closed),\r\n        mean: stats.mean?.value,\r\n        max: stats.max?.value,\r\n        stdDev: stats.stdDev?.value,\r\n        statsArray: stats.array,\r\n        pointsInShape: pointsInShape,\r\n        areaUnit: areaUnits,\r\n        modalityUnit,\r\n      };\r\n    }\r\n\r\n    triggerAnnotationModified(\r\n      annotation,\r\n      enabledElement.viewport.element,\r\n      ChangeTypes.StatsUpdated\r\n    );\r\n\r\n    annotation.invalidated = false;\r\n\r\n    return cachedStats;\r\n  };\r\n\r\n  private _renderStats = (\r\n    annotation,\r\n    viewport,\r\n    enabledElement,\r\n    svgDrawingHelper\r\n  ) => {\r\n    const { data } = <PlanarFreehandROIAnnotation>annotation;\r\n    const targetId = this.getTargetId(viewport);\r\n\r\n    const styleSpecifier: AnnotationStyle.StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\r\n    if (!options.visibility) {\r\n      return;\r\n    }\r\n\r\n    const textLines = this.configuration.getTextLines(data, targetId);\r\n    if (!textLines || textLines.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const canvasCoordinates = data.contour.polyline.map((p) =>\r\n      viewport.worldToCanvas(p)\r\n    );\r\n    if (!data.handles.textBox.hasMoved) {\r\n      const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\r\n\r\n      data.handles.textBox.worldPosition =\r\n        viewport.canvasToWorld(canvasTextBoxCoords);\r\n    }\r\n\r\n    const textBoxPosition = viewport.worldToCanvas(\r\n      data.handles.textBox.worldPosition\r\n    );\r\n\r\n    const textBoxUID = '1';\r\n    const boundingBox = drawLinkedTextBox(\r\n      svgDrawingHelper,\r\n      annotation.annotationUID ?? '',\r\n      textBoxUID,\r\n      textLines,\r\n      textBoxPosition,\r\n      canvasCoordinates,\r\n      {},\r\n      options\r\n    );\r\n\r\n    const { x: left, y: top, width, height } = boundingBox;\r\n\r\n    data.handles.textBox.worldBoundingBox = {\r\n      topLeft: viewport.canvasToWorld([left, top]),\r\n      topRight: viewport.canvasToWorld([left + width, top]),\r\n      bottomLeft: viewport.canvasToWorld([left, top + height]),\r\n      bottomRight: viewport.canvasToWorld([left + width, top + height]),\r\n    };\r\n  };\r\n}\r\n\r\nfunction defaultGetTextLines(data, targetId): string[] {\r\n  const cachedVolumeStats = data.cachedStats[targetId];\r\n  const {\r\n    area,\r\n    mean,\r\n    stdDev,\r\n    perimeter,\r\n    max,\r\n    isEmptyArea,\r\n    areaUnit,\r\n    modalityUnit,\r\n  } = cachedVolumeStats || {};\r\n\r\n  const textLines: string[] = [];\r\n\r\n  if (area) {\r\n    const areaLine = isEmptyArea\r\n      ? `Area: Oblique not supported`\r\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\r\n    textLines.push(areaLine);\r\n  }\r\n\r\n  if (mean) {\r\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\r\n  }\r\n\r\n  if (Number.isFinite(max)) {\r\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\r\n  }\r\n\r\n  if (stdDev) {\r\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\r\n  }\r\n\r\n  if (perimeter) {\r\n    textLines.push(`Perimeter: ${roundNumber(perimeter)} ${modalityUnit}`);\r\n  }\r\n\r\n  return textLines;\r\n}\r\n\r\nPlanarFreehandROITool.toolName = 'PlanarFreehandROI';\r\nexport default PlanarFreehandROITool;\r\n","import {\r\n  getEnabledElementByIds,\r\n  Types,\r\n  utilities as csUtils,\r\n} from '@cornerstonejs/core';\r\nimport Representations from '../../enums/SegmentationRepresentations';\r\nimport { config as segmentationConfig } from '../../stateManagement/segmentation';\r\nimport { setSegmentationVisibility } from '../../stateManagement/segmentation/config/segmentationVisibility';\r\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/segmentationState';\r\nimport { getToolGroup } from '../../store/ToolGroupManager';\r\nimport { PublicToolProps, ToolProps } from '../../types';\r\nimport { BaseTool } from '../base';\r\n\r\nimport {\r\n  SegmentationRepresentationConfig,\r\n  ToolGroupSpecificRepresentation,\r\n} from '../../types/SegmentationStateTypes';\r\nimport { surfaceDisplay } from './Surface';\r\nimport { contourDisplay } from './Contour';\r\nimport { labelmapDisplay } from './Labelmap';\r\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\r\nimport { addTool, state } from '../../store';\r\nimport PlanarFreehandContourSegmentationTool from '../annotation/PlanarFreehandContourSegmentationTool';\r\n\r\nconst planarContourToolName = PlanarFreehandContourSegmentationTool.toolName;\r\n/**\r\n * In Cornerstone3DTools, displaying of segmentations are handled by the SegmentationDisplayTool.\r\n * Generally, any Segmentation can be viewed in various representations such as\r\n * labelmap (3d), contours, surface etc. As of now, Cornerstone3DTools only implements\r\n * Labelmap representation.\r\n *\r\n * SegmentationDisplayTool works at ToolGroup level, and is responsible for displaying the\r\n * segmentation representation for ALL viewports of a toolGroup, this way we can support complex\r\n * scenarios for displaying segmentations.\r\n *\r\n * Current Limitations:\r\n * - Only supports rendering of the volumetric segmentations in 3D space. (StackViewport segmentations are not supported yet)\r\n * - Labelmap representation is the only supported representation for now.\r\n *\r\n * Similar to other tools in Cornerstone3DTools, the SegmentationDisplayTool should\r\n * be added to the CornerstoneTools by calling cornerstoneTools.addTool(SegmentationDisplayTool)\r\n * and a toolGroup should be created for it using the ToolGroupManager API, finally\r\n * viewports information such as viewportId and renderingEngineId should be provided\r\n * to the toolGroup and the SegmentationDisplayTool should be set to be activated.\r\n *\r\n *\r\n */\r\nclass SegmentationDisplayTool extends BaseTool {\r\n  static toolName;\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      configuration: {},\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  onSetToolEnabled(): void {\r\n    const toolGroupId = this.toolGroupId;\r\n    const toolGroupSegmentationRepresentations =\r\n      getSegmentationRepresentations(toolGroupId);\r\n\r\n    if (\r\n      !toolGroupSegmentationRepresentations ||\r\n      toolGroupSegmentationRepresentations.length === 0\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    // for each segmentationData, make the visibility true\r\n    toolGroupSegmentationRepresentations.forEach(\r\n      (segmentationRepresentation) => {\r\n        setSegmentationVisibility(\r\n          toolGroupId,\r\n          segmentationRepresentation.segmentationRepresentationUID,\r\n          true\r\n        );\r\n      }\r\n    );\r\n  }\r\n\r\n  onSetToolDisabled(): void {\r\n    const toolGroupId = this.toolGroupId;\r\n    const toolGroupSegmentationRepresentations =\r\n      getSegmentationRepresentations(toolGroupId);\r\n\r\n    if (\r\n      !toolGroupSegmentationRepresentations ||\r\n      toolGroupSegmentationRepresentations.length === 0\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    // for each segmentationData, make the visibility false\r\n    toolGroupSegmentationRepresentations.forEach(\r\n      (segmentationRepresentation) => {\r\n        setSegmentationVisibility(\r\n          toolGroupId,\r\n          segmentationRepresentation.segmentationRepresentationUID,\r\n          false\r\n        );\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * It is used to trigger the render for each segmentations in the toolGroup.\r\n   * Based on the segmentation representation type, it will call the corresponding\r\n   * render function.\r\n   *\r\n   * @param toolGroupId - the toolGroupId\r\n   */\r\n  renderSegmentation = (toolGroupId: string): void => {\r\n    const toolGroup = getToolGroup(toolGroupId);\r\n\r\n    if (!toolGroup) {\r\n      return;\r\n    }\r\n\r\n    const toolGroupSegmentationRepresentations =\r\n      getSegmentationRepresentations(toolGroupId);\r\n\r\n    if (\r\n      !toolGroupSegmentationRepresentations ||\r\n      toolGroupSegmentationRepresentations.length === 0\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    // toolGroup Viewports\r\n    const toolGroupViewports = toolGroup.viewportsInfo.map(\r\n      ({ renderingEngineId, viewportId }) => {\r\n        const enabledElement = getEnabledElementByIds(\r\n          viewportId,\r\n          renderingEngineId\r\n        );\r\n\r\n        if (enabledElement) {\r\n          return enabledElement.viewport;\r\n        }\r\n      }\r\n    );\r\n\r\n    // Render each segmentationData, in each viewport in the toolGroup\r\n    const segmentationRenderList = toolGroupSegmentationRepresentations.map(\r\n      (representation: ToolGroupSpecificRepresentation) => {\r\n        const config = this._getMergedRepresentationsConfig(toolGroupId);\r\n\r\n        const viewportsRenderList = [];\r\n\r\n        const renderers = {\r\n          [Representations.Labelmap]: labelmapDisplay,\r\n          [Representations.Contour]: contourDisplay,\r\n          [Representations.Surface]: surfaceDisplay,\r\n        };\r\n\r\n        if (representation.type === SegmentationRepresentations.Contour) {\r\n          // if the representation is contour we need to make sure\r\n          // that the planarFreeHandTool is added to the toolGroup\r\n          this.addPlanarFreeHandToolIfAbsent(toolGroupId);\r\n        }\r\n\r\n        const display = renderers[representation.type];\r\n\r\n        for (const viewport of toolGroupViewports) {\r\n          const renderedViewport = display.render(\r\n            viewport as Types.IVolumeViewport,\r\n            representation,\r\n            config\r\n          );\r\n\r\n          viewportsRenderList.push(renderedViewport);\r\n        }\r\n        return viewportsRenderList;\r\n      }\r\n    );\r\n\r\n    Promise.allSettled(segmentationRenderList).then(() => {\r\n      // for all viewports in the toolGroup trigger a re-render\r\n      toolGroupViewports.forEach((viewport) => {\r\n        viewport.render();\r\n      });\r\n    });\r\n  };\r\n\r\n  addPlanarFreeHandToolIfAbsent(toolGroupId) {\r\n    // if it is contour we should check if the toolGroup and more importantly\r\n    // the cornerstoneTools have the planarFreeHandTool added\r\n    if (!(planarContourToolName in state.tools)) {\r\n      addTool(PlanarFreehandContourSegmentationTool);\r\n    }\r\n\r\n    const toolGroup = getToolGroup(toolGroupId);\r\n\r\n    // check if toolGroup has this tool\r\n    if (!toolGroup.hasTool(planarContourToolName)) {\r\n      toolGroup.addTool(planarContourToolName);\r\n      toolGroup.setToolPassive(planarContourToolName);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Merge the toolGroup specific configuration with the default global configuration\r\n   * @param toolGroupId\r\n   * @returns\r\n   */\r\n  _getMergedRepresentationsConfig(\r\n    toolGroupId: string\r\n  ): SegmentationRepresentationConfig {\r\n    const toolGroupConfig =\r\n      segmentationConfig.getToolGroupSpecificConfig(toolGroupId);\r\n    const globalConfig = segmentationConfig.getGlobalConfig();\r\n\r\n    // merge two configurations and override the global config\r\n    const mergedConfig = csUtils.deepMerge(globalConfig, toolGroupConfig);\r\n\r\n    return mergedConfig;\r\n  }\r\n}\r\n\r\nSegmentationDisplayTool.toolName = 'SegmentationDisplay';\r\nexport default SegmentationDisplayTool;\r\n","import {\r\n  getEnabledElement,\r\n  cache,\r\n  StackViewport,\r\n  utilities as csUtils,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\r\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\r\n\r\nimport {\r\n  drawHandles as drawHandlesSvg,\r\n  drawRect as drawRectSvg,\r\n} from '../../drawingSvg';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport { hideElementCursor } from '../../cursors/elementCursor';\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\r\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\r\nimport {\r\n  PublicToolProps,\r\n  ToolProps,\r\n  EventTypes,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\nimport { RectangleROIThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\nimport RectangleROITool from '../annotation/RectangleROITool';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\n\r\n/**\r\n * This tool is exactly the RectangleROITool but only draws a rectangle on the image,\r\n * and by using utility functions such as thresholdByRange and thresholdByROIStat it can be used to\r\n * create a segmentation. This tool, however, does not calculate the statistics\r\n * as RectangleROITool does.\r\n */\r\nclass RectangleROIThresholdTool extends RectangleROITool {\r\n  static toolName;\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: string[];\r\n    handleIndex?: number;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        shadow: true,\r\n        preventHandleOutsideImage: false,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the enabledElement it creates\r\n   * the edit data for the tool.\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    const targetId = this.getTargetId(viewport);\r\n    let referencedImageId, volumeId;\r\n\r\n    if (viewport instanceof StackViewport) {\r\n      referencedImageId = targetId.split('imageId:')[1];\r\n    } else {\r\n      volumeId = csUtils.getVolumeId(targetId);\r\n      const imageVolume = cache.getVolume(volumeId);\r\n      referencedImageId = csUtils.getClosestImageId(\r\n        imageVolume,\r\n        worldPos,\r\n        viewPlaneNormal\r\n      );\r\n    }\r\n\r\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n    // Todo: how not to store enabledElement on the annotation, segmentationModule needs the element to\r\n    // decide on the active segmentIndex, active segmentationIndex etc.\r\n    const annotation = {\r\n      highlighted: true,\r\n      invalidated: true,\r\n      metadata: {\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        enabledElement,\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID,\r\n        referencedImageId,\r\n        toolName: this.getToolName(),\r\n        volumeId,\r\n      },\r\n      data: {\r\n        label: '',\r\n        handles: {\r\n          // No need a textBox\r\n          textBox: {\r\n            hasMoved: false,\r\n            worldPosition: null,\r\n            worldBoundingBox: null,\r\n          },\r\n          points: [\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n          ],\r\n          activeHandleIndex: null,\r\n        },\r\n        segmentationId: null,\r\n      },\r\n    };\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex: 3,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n    };\r\n    this._activateDraw(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  };\r\n\r\n  /**\r\n   * it is used to draw the RectangleROI Threshold annotation in each\r\n   * request animation frame.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n    let annotations = getAnnotations(this.getToolName(), element);\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    annotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    );\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[i] as RectangleROIThresholdAnnotation;\r\n      const { annotationUID, data } = annotation;\r\n      const { points, activeHandleIndex } = data.handles;\r\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\r\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\r\n      const color = 'rgb(255, 255, 255)'\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n\r\n      // Todo: This is not correct way to add the event trigger,\r\n      // this will trigger on all mouse hover too. Problem is that we don't\r\n      // have a cached stats mechanism for this tool yet?\r\n      triggerAnnotationModified(annotation, element);\r\n\r\n      let activeHandleCanvasCoords;\r\n\r\n      if (!isAnnotationVisible(annotationUID)) {\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        !isAnnotationLocked(annotation) &&\r\n        !this.editData &&\r\n        activeHandleIndex !== null\r\n      ) {\r\n        // Not locked or creating and hovering over handle, so render handle.\r\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\r\n      }\r\n\r\n      if (activeHandleCanvasCoords) {\r\n        const handleGroupUID = '0';\r\n\r\n        drawHandlesSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          handleGroupUID,\r\n          activeHandleCanvasCoords,\r\n          {\r\n            color,\r\n          }\r\n        );\r\n      }\r\n\r\n      const rectangleUID = '0';\r\n      drawRectSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        rectangleUID,\r\n        canvasCoordinates[0],\r\n        canvasCoordinates[3],\r\n        {\r\n          color,\r\n          lineDash,\r\n          lineWidth,\r\n        }\r\n      );\r\n\r\n      renderStatus = true;\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n}\r\n\r\nRectangleROIThresholdTool.toolName = 'RectangleROIThreshold';\r\nexport default RectangleROIThresholdTool;\r\n","import {\r\n  getEnabledElement,\r\n  cache,\r\n  StackViewport,\r\n  metaData,\r\n  utilities as csUtils,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\n\r\nimport { vec3 } from 'gl-matrix';\r\nimport {\r\n  addAnnotation,\r\n  getAnnotations,\r\n  removeAnnotation,\r\n} from '../../stateManagement';\r\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\r\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\r\nimport {\r\n  drawHandles as drawHandlesSvg,\r\n  drawRect as drawRectSvg,\r\n} from '../../drawingSvg';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport throttle from '../../utilities/throttle';\r\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\r\nimport {\r\n  hideElementCursor,\r\n  resetElementCursor,\r\n} from '../../cursors/elementCursor';\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\nimport { triggerAnnotationCompleted } from '../../stateManagement/annotation/helpers/state';\r\n\r\nimport {\r\n  PublicToolProps,\r\n  ToolProps,\r\n  EventTypes,\r\n  SVGDrawingHelper,\r\n} from '../../types';\r\nimport { RectangleROIStartEndThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\nimport RectangleROITool from '../annotation/RectangleROITool';\r\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\r\nimport { pointInShapeCallback } from '../../utilities/';\r\n\r\nconst { transformWorldToIndex } = csUtils;\r\n\r\n/**\r\n * This tool is similar to the RectangleROIThresholdTool which\r\n * only draws a rectangle on the image, and by using utility functions\r\n * such as thresholdByRange and thresholdByROIStat it can be used to\r\n * create a segmentation. The only difference is that it only acts on the\r\n * acquisition plane and not the 3D volume, and accepts a start and end\r\n * slice, and renders a dashed rectangle on the image between the start and end\r\n * but a solid rectangle on start and end slice. Utility functions should be used\r\n * to modify the start and end slice.\r\n * // Todo: right now only the first slice has grabbable handles, need to make\r\n * // it so that the handles are grabbable on all slices.\r\n */\r\nclass RectangleROIStartEndThresholdTool extends RectangleROITool {\r\n  static toolName;\r\n  _throttledCalculateCachedStats: any;\r\n  editData: {\r\n    annotation: any;\r\n    viewportIdsToRender: string[];\r\n    handleIndex?: number;\r\n    newAnnotation?: boolean;\r\n    hasMoved?: boolean;\r\n  } | null;\r\n  isDrawing: boolean;\r\n  isHandleOutsideImage: boolean;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      configuration: {\r\n        numSlicesToPropagate: 10,\r\n        computePointsInsideVolume: false,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n\r\n    this._throttledCalculateCachedStats = throttle(\r\n      this._calculateCachedStatsTool,\r\n      100,\r\n      { trailing: true }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the enabledElement it creates\r\n   * the edit data for the tool.\r\n   *\r\n   * @param evt -  EventTypes.NormalizedMouseEventType\r\n   * @returns The annotation object.\r\n   *\r\n   */\r\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\r\n    const eventDetail = evt.detail;\r\n    const { currentPoints, element } = eventDetail;\r\n    const worldPos = currentPoints.world;\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    this.isDrawing = true;\r\n\r\n    const camera = viewport.getCamera();\r\n    const { viewPlaneNormal, viewUp } = camera;\r\n\r\n    let referencedImageId, imageVolume, volumeId;\r\n    if (viewport instanceof StackViewport) {\r\n      throw new Error('Stack Viewport Not implemented');\r\n    } else {\r\n      const targetId = this.getTargetId(viewport);\r\n      volumeId = csUtils.getVolumeId(targetId);\r\n      imageVolume = cache.getVolume(volumeId);\r\n      referencedImageId = csUtils.getClosestImageId(\r\n        imageVolume,\r\n        worldPos,\r\n        viewPlaneNormal\r\n      );\r\n    }\r\n\r\n    if (!referencedImageId) {\r\n      throw new Error('This tool does not work on non-acquisition planes');\r\n    }\r\n\r\n    const startIndex = viewport.getCurrentImageIdIndex();\r\n    const spacingInNormal = csUtils.getSpacingInNormalDirection(\r\n      imageVolume,\r\n      viewPlaneNormal\r\n    );\r\n\r\n    // We cannot simply add numSlicesToPropagate to startIndex because\r\n    // the order of imageIds can be from top to bottom or bottom to top and\r\n    // we want to make sure it is always propagated in the direction of the\r\n    // view and also to make sure we don't go out of bounds.\r\n    const endIndex = this._getEndSliceIndex(\r\n      imageVolume,\r\n      worldPos,\r\n      spacingInNormal,\r\n      viewPlaneNormal\r\n    );\r\n\r\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\r\n\r\n    const annotation = {\r\n      highlighted: true,\r\n      invalidated: true,\r\n      metadata: {\r\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\r\n        enabledElement,\r\n        viewUp: <Types.Point3>[...viewUp],\r\n        FrameOfReferenceUID,\r\n        referencedImageId,\r\n        toolName: this.getToolName(),\r\n        volumeId,\r\n        spacingInNormal,\r\n      },\r\n      data: {\r\n        label: '',\r\n        startSlice: startIndex,\r\n        endSlice: endIndex,\r\n        cachedStats: {\r\n          pointsInVolume: [],\r\n          projectionPoints: [],\r\n          projectionPointsImageIds: [referencedImageId],\r\n        },\r\n        handles: {\r\n          // No need a textBox\r\n          textBox: {\r\n            hasMoved: false,\r\n            worldPosition: null,\r\n            worldBoundingBox: null,\r\n          },\r\n          points: [\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n            <Types.Point3>[...worldPos],\r\n          ],\r\n          activeHandleIndex: null,\r\n        },\r\n        labelmapUID: null,\r\n      },\r\n    };\r\n\r\n    // update the projection points in 3D space, since we are projecting\r\n    // the points to the slice plane, we need to make sure the points are\r\n    // computed for later export\r\n    this._computeProjectionPoints(annotation, imageVolume);\r\n\r\n    addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.editData = {\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handleIndex: 3,\r\n      newAnnotation: true,\r\n      hasMoved: false,\r\n    };\r\n    this._activateDraw(element);\r\n\r\n    hideElementCursor(element);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  };\r\n\r\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\r\n      this.editData;\r\n    const { data } = annotation;\r\n\r\n    if (newAnnotation && !hasMoved) {\r\n      return;\r\n    }\r\n\r\n    data.handles.activeHandleIndex = null;\r\n\r\n    this._deactivateModify(element);\r\n    this._deactivateDraw(element);\r\n\r\n    resetElementCursor(element);\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n\r\n    this.editData = null;\r\n    this.isDrawing = false;\r\n\r\n    if (\r\n      this.isHandleOutsideImage &&\r\n      this.configuration.preventHandleOutsideImage\r\n    ) {\r\n      removeAnnotation(annotation.annotationUID);\r\n    }\r\n\r\n    const targetId = this.getTargetId(enabledElement.viewport);\r\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\r\n\r\n    if (this.configuration.calculatePointsInsideVolume) {\r\n      this._computePointsInsideVolume(annotation, imageVolume, enabledElement);\r\n    }\r\n\r\n    triggerAnnotationRenderForViewportIds(\r\n      enabledElement.renderingEngine,\r\n      viewportIdsToRender\r\n    );\r\n\r\n    if (newAnnotation) {\r\n      triggerAnnotationCompleted(annotation);\r\n    }\r\n  };\r\n\r\n  // Todo: make it work for planes other than acquisition planes\r\n  _computeProjectionPoints(\r\n    annotation: RectangleROIStartEndThresholdAnnotation,\r\n    imageVolume: Types.IImageVolume\r\n  ): void {\r\n    const { data, metadata } = annotation;\r\n    const { viewPlaneNormal, spacingInNormal } = metadata;\r\n    const { imageData } = imageVolume;\r\n    const { startSlice, endSlice } = data;\r\n    const { points } = data.handles;\r\n\r\n    const startIJK = transformWorldToIndex(imageData, points[0]);\r\n\r\n    if (startIJK[2] !== startSlice) {\r\n      throw new Error('Start slice does not match');\r\n    }\r\n\r\n    // substitute the end slice index 2 with startIJK index 2\r\n    const endIJK = vec3.fromValues(startIJK[0], startIJK[1], endSlice);\r\n\r\n    const startWorld = vec3.create();\r\n    imageData.indexToWorldVec3(startIJK, startWorld);\r\n\r\n    const endWorld = vec3.create();\r\n    imageData.indexToWorldVec3(endIJK, endWorld);\r\n\r\n    // distance between start and end slice in the world coordinate\r\n    const distance = vec3.distance(startWorld, endWorld);\r\n\r\n    // for each point inside points, navigate in the direction of the viewPlaneNormal\r\n    // with amount of spacingInNormal, and calculate the next slice until we reach the distance\r\n    const newProjectionPoints = [];\r\n    for (let dist = 0; dist < distance; dist += spacingInNormal) {\r\n      newProjectionPoints.push(\r\n        points.map((point) => {\r\n          const newPoint = vec3.create();\r\n          vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);\r\n          return Array.from(newPoint);\r\n        })\r\n      );\r\n    }\r\n\r\n    data.cachedStats.projectionPoints = newProjectionPoints;\r\n\r\n    // Find the imageIds for the projection points\r\n    const projectionPointsImageIds = [];\r\n    for (const RectanglePoints of newProjectionPoints) {\r\n      const imageId = csUtils.getClosestImageId(\r\n        imageVolume,\r\n        RectanglePoints[0],\r\n        viewPlaneNormal\r\n      );\r\n      projectionPointsImageIds.push(imageId);\r\n    }\r\n\r\n    data.cachedStats.projectionPointsImageIds = projectionPointsImageIds;\r\n  }\r\n\r\n  //This function return all the points inside the ROI for every slices between startSlice and endSlice\r\n  _computePointsInsideVolume(annotation, imageVolume, enabledElement) {\r\n    const { data } = annotation;\r\n    const projectionPoints = data.cachedStats.projectionPoints;\r\n\r\n    const pointsInsideVolume: Types.Point3[][] = [[]];\r\n\r\n    for (let i = 0; i < projectionPoints.length; i++) {\r\n      // If image does not exists for the targetId, skip. This can be due\r\n      // to various reasons such as if the target was a volumeViewport, and\r\n      // the volumeViewport has been decached in the meantime.\r\n      if (!imageVolume) {\r\n        continue;\r\n      }\r\n\r\n      const projectionPoint = projectionPoints[i][0];\r\n\r\n      const worldPos1 = data.handles.points[0];\r\n      const worldPos2 = data.handles.points[3];\r\n\r\n      const { dimensions, imageData } = imageVolume;\r\n\r\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\r\n      //We only need to change the Z of our bounds so we are getting the Z from the current projection point\r\n      const worldProjectionPointIndex = transformWorldToIndex(\r\n        imageData,\r\n        projectionPoint\r\n      );\r\n\r\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\r\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\r\n      worldPos1Index[2] = Math.floor(worldProjectionPointIndex[2]);\r\n\r\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\r\n\r\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\r\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\r\n      worldPos2Index[2] = Math.floor(worldProjectionPointIndex[2]);\r\n\r\n      // Check if one of the indexes are inside the volume, this then gives us\r\n      // Some area to do stats over.\r\n\r\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\r\n        this.isHandleOutsideImage = false;\r\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\r\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\r\n\r\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\r\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\r\n\r\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\r\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\r\n\r\n        const boundsIJK = [\r\n          [iMin, iMax],\r\n          [jMin, jMax],\r\n          [kMin, kMax],\r\n        ] as [Types.Point2, Types.Point2, Types.Point2];\r\n\r\n        const pointsInShape = pointInShapeCallback(\r\n          imageData,\r\n          () => true,\r\n          null,\r\n          boundsIJK\r\n        );\r\n\r\n        //@ts-ignore\r\n        pointsInsideVolume.push(pointsInShape);\r\n      }\r\n    }\r\n    data.cachedStats.pointsInVolume = pointsInsideVolume;\r\n  }\r\n\r\n  _calculateCachedStatsTool(annotation, enabledElement) {\r\n    const data = annotation.data;\r\n    const { viewport } = enabledElement;\r\n\r\n    const { cachedStats } = data;\r\n    const targetId = this.getTargetId(viewport);\r\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\r\n\r\n    // Todo: this shouldn't be here, this is a performance issue\r\n    // Since we are extending the RectangleROI class, we need to\r\n    // bring the logic for handle to some cachedStats calculation\r\n    this._computeProjectionPoints(annotation, imageVolume);\r\n\r\n    annotation.invalidated = false;\r\n\r\n    // Dispatching annotation modified\r\n    triggerAnnotationModified(annotation, viewport.element);\r\n\r\n    return cachedStats;\r\n  }\r\n\r\n  /**\r\n   * it is used to draw the rectangleROIStartEnd annotation in each\r\n   * request animation frame.\r\n   *\r\n   * @param enabledElement - The Cornerstone's enabledElement.\r\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\r\n   */\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper\r\n  ): boolean => {\r\n    let renderStatus = false;\r\n    const { viewport } = enabledElement;\r\n\r\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\r\n\r\n    if (!annotations?.length) {\r\n      return renderStatus;\r\n    }\r\n\r\n    const sliceIndex = viewport.getCurrentImageIdIndex();\r\n\r\n    const styleSpecifier: StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    for (let i = 0; i < annotations.length; i++) {\r\n      const annotation = annotations[\r\n        i\r\n      ] as RectangleROIStartEndThresholdAnnotation;\r\n      const { annotationUID, data } = annotation;\r\n      const { startSlice, endSlice } = data;\r\n      const { points, activeHandleIndex } = data.handles;\r\n\r\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\r\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\r\n      const color = 'rgb(255, 255, 255)'\r\n      // range of slices to render based on the start and end slice, like\r\n      // np.arange\r\n\r\n      // if indexIJK is outside the start/end slice, we don't render\r\n      if (\r\n        sliceIndex < Math.min(startSlice, endSlice) ||\r\n        sliceIndex > Math.max(startSlice, endSlice)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\r\n\r\n      if (annotation.invalidated) {\r\n        this._throttledCalculateCachedStats(annotation, enabledElement);\r\n      }\r\n\r\n      // if it is inside the start/end slice, but not exactly the first or\r\n      // last slice, we render the line in dash, but not the handles\r\n      let firstOrLastSlice = false;\r\n      if (sliceIndex === startSlice || sliceIndex === endSlice) {\r\n        firstOrLastSlice = true;\r\n      }\r\n\r\n      // If rendering engine has been destroyed while rendering\r\n      if (!viewport.getRenderingEngine()) {\r\n        console.warn('Rendering Engine has been destroyed');\r\n        return renderStatus;\r\n      }\r\n\r\n      let activeHandleCanvasCoords;\r\n\r\n      if (!isAnnotationVisible(annotationUID)) {\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        !isAnnotationLocked(annotation) &&\r\n        !this.editData &&\r\n        activeHandleIndex !== null &&\r\n        firstOrLastSlice\r\n      ) {\r\n        // Not locked or creating and hovering over handle, so render handle.\r\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\r\n      }\r\n\r\n      if (activeHandleCanvasCoords) {\r\n        const handleGroupUID = '0';\r\n\r\n        drawHandlesSvg(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          handleGroupUID,\r\n          activeHandleCanvasCoords,\r\n          {\r\n            color,\r\n          }\r\n        );\r\n      }\r\n\r\n      let lineDashToUse = lineDash;\r\n\r\n      if (!firstOrLastSlice) {\r\n        lineDashToUse = 2;\r\n      }\r\n\r\n      const rectangleUID = '0';\r\n      drawRectSvg(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        rectangleUID,\r\n        canvasCoordinates[0],\r\n        canvasCoordinates[3],\r\n        {\r\n          color,\r\n          lineDash: lineDashToUse,\r\n          lineWidth,\r\n        }\r\n      );\r\n\r\n      renderStatus = true;\r\n    }\r\n\r\n    return renderStatus;\r\n  };\r\n\r\n  _getEndSliceIndex(\r\n    imageVolume: Types.IImageVolume,\r\n    worldPos: Types.Point3,\r\n    spacingInNormal: number,\r\n    viewPlaneNormal: Types.Point3\r\n  ): number | undefined {\r\n    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\r\n\r\n    // get end position by moving from worldPos in the direction of viewplaneNormal\r\n    // with amount of numSlicesToPropagate * spacingInNormal\r\n    const endPos = vec3.create();\r\n    vec3.scaleAndAdd(\r\n      endPos,\r\n      worldPos,\r\n      viewPlaneNormal,\r\n      numSlicesToPropagate * spacingInNormal\r\n    );\r\n\r\n    const halfSpacingInNormalDirection = spacingInNormal / 2;\r\n    // Loop through imageIds of the imageVolume and find the one that is closest to endPos\r\n    const { imageIds } = imageVolume;\r\n    let imageIdIndex;\r\n    for (let i = 0; i < imageIds.length; i++) {\r\n      const imageId = imageIds[i];\r\n\r\n      const { imagePositionPatient } = metaData.get(\r\n        'imagePlaneModule',\r\n        imageId\r\n      );\r\n\r\n      const dir = vec3.create();\r\n      vec3.sub(dir, endPos, imagePositionPatient);\r\n\r\n      const dot = vec3.dot(dir, viewPlaneNormal);\r\n\r\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\r\n        imageIdIndex = i;\r\n      }\r\n    }\r\n\r\n    return imageIdIndex;\r\n  }\r\n}\r\n\r\nRectangleROIStartEndThresholdTool.toolName = 'RectangleROIStartEndThreshold';\r\nexport default RectangleROIStartEndThresholdTool;\r\n","import { utilities } from '@cornerstonejs/core';\r\n\r\nimport {\r\n  getAnnotationNearPoint,\r\n  getAnnotationNearPointOnEnabledElement,\r\n} from './getAnnotationNearPoint';\r\n\r\n// Lodash/common JS functionality\r\nimport debounce from './debounce';\r\nimport throttle from './throttle';\r\nimport isObject from './isObject';\r\nimport clip from './clip';\r\nimport calibrateImageSpacing from './calibrateImageSpacing';\r\nimport {\r\n  getCalibratedLengthUnitsAndScale,\r\n  getCalibratedProbeUnitsAndValue,\r\n  getCalibratedAspect,\r\n} from './getCalibratedUnits';\r\nimport triggerAnnotationRenderForViewportIds from './triggerAnnotationRenderForViewportIds';\r\nimport triggerAnnotationRenderForToolGroupIds from './triggerAnnotationRenderForToolGroupIds';\r\nimport triggerAnnotationRender from './triggerAnnotationRender';\r\nimport jumpToSlice from './viewport/jumpToSlice';\r\n\r\nimport pointInShapeCallback from './pointInShapeCallback';\r\nimport { getSphereBoundsInfo } from './getSphereBoundsInfo';\r\nimport scroll from './scroll';\r\nimport { pointToString } from './pointToString';\r\nimport annotationFrameRange from './annotationFrameRange';\r\nimport pointInSurroundingSphereCallback from './pointInSurroundingSphereCallback';\r\nimport getViewportForAnnotation from './getViewportForAnnotation';\r\nimport {\r\n  annotationHydration,\r\n  getClosestImageIdForStackViewport,\r\n} from './annotationHydration';\r\n// name spaces\r\nimport * as contours from './contours';\r\nimport * as segmentation from './segmentation';\r\nimport * as drawing from './drawing';\r\nimport * as math from './math';\r\nimport * as planar from './planar';\r\nimport * as viewportFilters from './viewportFilters';\r\nimport * as orientation from './orientation';\r\nimport * as cine from './cine';\r\nimport * as boundingBox from './boundingBox';\r\nimport * as planarFreehandROITool from './planarFreehandROITool';\r\nimport * as rectangleROITool from './rectangleROITool';\r\nimport { stackPrefetch, stackContextPrefetch } from './stackPrefetch';\r\nimport * as viewport from './viewport';\r\nimport * as touch from './touch';\r\nimport * as dynamicVolume from './dynamicVolume';\r\nimport * as polyDataUtils from './polyData/utils';\r\nimport * as voi from './voi';\r\nimport * as contourSegmentation from './contourSegmentation';\r\n\r\nconst roundNumber = utilities.roundNumber;\r\n\r\n// Events\r\nimport { triggerEvent } from '@cornerstonejs/core';\r\n\r\nexport {\r\n  math,\r\n  planar,\r\n  viewportFilters,\r\n  drawing,\r\n  debounce,\r\n  dynamicVolume,\r\n  throttle,\r\n  orientation,\r\n  isObject,\r\n  touch,\r\n  triggerEvent,\r\n  calibrateImageSpacing,\r\n  getCalibratedLengthUnitsAndScale,\r\n  getCalibratedProbeUnitsAndValue,\r\n  getCalibratedAspect,\r\n  segmentation,\r\n  contours,\r\n  triggerAnnotationRenderForViewportIds,\r\n  triggerAnnotationRenderForToolGroupIds,\r\n  triggerAnnotationRender,\r\n  pointInShapeCallback,\r\n  getSphereBoundsInfo,\r\n  getAnnotationNearPoint,\r\n  getViewportForAnnotation,\r\n  getAnnotationNearPointOnEnabledElement,\r\n  jumpToSlice,\r\n  pointInSurroundingSphereCallback,\r\n  viewport,\r\n  cine,\r\n  clip,\r\n  boundingBox,\r\n  rectangleROITool,\r\n  planarFreehandROITool,\r\n  stackPrefetch,\r\n  stackContextPrefetch,\r\n  scroll,\r\n  roundNumber,\r\n  pointToString,\r\n  polyDataUtils,\r\n  voi,\r\n  annotationFrameRange,\r\n  contourSegmentation,\r\n  annotationHydration,\r\n  getClosestImageIdForStackViewport,\r\n};\r\n","import { m as macro } from '../../macros2.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkPiecewiseFunction methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPiecewiseFunction(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPiecewiseFunction');\n\n  // Return the number of points which specify this function\n  publicAPI.getSize = () => model.nodes.length;\n\n  // Return the type of function stored in object:\n  // Function Types:\n  //    0 : Constant        (No change in slope between end points)\n  //    1 : NonDecreasing   (Always increasing or zero slope)\n  //    2 : NonIncreasing   (Always decreasing or zero slope)\n  //    3 : Varied          (Contains both decreasing and increasing slopes)\n  //    4 : Unknown         (Error condition)\n  //\n  publicAPI.getType = () => {\n    let value;\n    let prevValue = 0.0;\n    let functionType = 0;\n    if (model.nodes.length > 0) {\n      prevValue = model.nodes[0].y;\n    }\n    for (let i = 1; i < model.nodes.length; i++) {\n      value = model.nodes[i].y;\n\n      // Do not change the function type if equal\n      if (value !== prevValue) {\n        if (value > prevValue) {\n          switch (functionType) {\n            case 0:\n            case 1:\n              // NonDecreasing\n              functionType = 1;\n              break;\n            case 2:\n            default:\n              // Varied\n              functionType = 3;\n              break;\n          }\n        } else {\n          // value < prev_value\n          switch (functionType) {\n            case 0:\n            case 2:\n              // NonIncreasing\n              functionType = 2;\n              break;\n            case 1:\n            default:\n              // Varied\n              functionType = 3;\n              break;\n          }\n        }\n      }\n      prevValue = value;\n\n      // Exit loop if we find a Varied function\n      if (functionType === 3) {\n        break;\n      }\n    }\n    switch (functionType) {\n      case 0:\n        return 'Constant';\n      case 1:\n        return 'NonDecreasing';\n      case 2:\n        return 'NonIncreasing';\n      case 3:\n      default:\n        return 'Varied';\n    }\n  };\n\n  // Since we no longer store the data in an array, we must\n  // copy out of the vector into an array. No modified check -\n  // could be added if performance is a problem\n  publicAPI.getDataPointer = () => {\n    const size = model.nodes.length;\n    model.function = null;\n    if (size > 0) {\n      model.function = [];\n      for (let i = 0; i < size; i++) {\n        model.function[2 * i] = model.nodes[i].x;\n        model.function[2 * i + 1] = model.nodes[i].y;\n      }\n    }\n    return model.function;\n  };\n\n  // Returns the first point location which starts a non-zero segment of the\n  // function. Note that the value at this point may be zero.\n  publicAPI.getFirstNonZeroValue = () => {\n    // Check if no points specified\n    if (model.nodes.length === 0) {\n      return 0;\n    }\n    let allZero = 1;\n    let x = 0.0;\n    let i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].y !== 0.0) {\n        allZero = 0;\n        break;\n      }\n    }\n\n    // If every specified point has a zero value then return\n    // a large value\n    if (allZero) {\n      x = Number.MAX_VALUE;\n    } else if (i > 0) {\n      // A point was found with a non-zero value\n      // Return the value of the point that precedes this one\n      x = model.nodes[i - 1].x;\n    } else if (model.clamping) {\n      // If this is the first point in the function, return its\n      // value is clamping is off, otherwise VTK_DOUBLE_MIN if\n      // clamping is on.\n      x = -Number.MAX_VALUE;\n    } else {\n      x = model.nodes[0].x;\n    }\n    return x;\n  };\n\n  // For a specified index value, get the node parameters\n  publicAPI.getNodeValue = (index, val) => {\n    const size = model.nodes.length;\n    if (index < 0 || index >= size) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    val[0] = model.nodes[index].x;\n    val[1] = model.nodes[index].y;\n    val[2] = model.nodes[index].midpoint;\n    val[3] = model.nodes[index].sharpness;\n    return 1;\n  };\n\n  // For a specified index value, get the node parameters\n  publicAPI.setNodeValue = (index, val) => {\n    const size = model.nodes.length;\n    if (index < 0 || index >= size) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    const oldX = model.nodes[index].x;\n    model.nodes[index].x = val[0];\n    model.nodes[index].y = val[1];\n    model.nodes[index].midpoint = val[2];\n    model.nodes[index].sharpness = val[3];\n    if (oldX !== val[0]) {\n      // The point has been moved, the order of points or the range might have\n      // been modified.\n      publicAPI.sortAndUpdateRange();\n      // No need to call Modified() here because SortAndUpdateRange() has done it\n      // already.\n    } else {\n      publicAPI.modified();\n    }\n    return 1;\n  };\n\n  // Adds a point to the function. If a duplicate point is inserted\n  // then the function value at that location is set to the new value.\n  // This is the legacy version that assumes midpoint = 0.5 and\n  // sharpness = 0.0\n  publicAPI.addPoint = (x, y) => publicAPI.addPointLong(x, y, 0.5, 0.0);\n\n  // Adds a point to the function and returns the array index of the point.\n  publicAPI.addPointLong = (x, y, midpoint, sharpness) => {\n    // Error check\n    if (midpoint < 0.0 || midpoint > 1.0) {\n      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');\n      return -1;\n    }\n    if (sharpness < 0.0 || sharpness > 1.0) {\n      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');\n      return -1;\n    }\n\n    // remove any node already at this X location\n    if (!model.allowDuplicateScalars) {\n      publicAPI.removePoint(x);\n    }\n\n    // Create the new node\n    const node = {\n      x,\n      y,\n      midpoint,\n      sharpness\n    };\n\n    // Add it, then sort to get everything in order\n    model.nodes.push(node);\n    publicAPI.sortAndUpdateRange();\n\n    // Now find this node so we can return the index\n    let i;\n    for (i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    // If we didn't find it, something went horribly wrong so\n    // return -1\n    if (i < model.nodes.length) {\n      return i;\n    }\n    return -1;\n  };\n  publicAPI.setNodes = nodes => {\n    if (model.nodes !== nodes) {\n      model.nodes = nodes;\n      publicAPI.sortAndUpdateRange();\n    }\n  };\n\n  // Sort the vector in increasing order, then fill in\n  // the Range\n  publicAPI.sortAndUpdateRange = () => {\n    model.nodes.sort((a, b) => a.x - b.x);\n    const modifiedInvoked = publicAPI.updateRange();\n    // If range is updated, Modified() has been called, don't call it again.\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.updateRange = () => {\n    const oldRange = model.range.slice();\n    const size = model.nodes.length;\n    if (size) {\n      model.range[0] = model.nodes[0].x;\n      model.range[1] = model.nodes[size - 1].x;\n    } else {\n      model.range[0] = 0;\n      model.range[1] = 0;\n    }\n    // If the rage is the same, then no need to call Modified()\n    if (oldRange[0] === model.range[0] && oldRange[1] === model.range[1]) {\n      return false;\n    }\n    publicAPI.modified();\n    return true;\n  };\n\n  // Removes a point from the function. If no point is found then function\n  // remains the same.\n  publicAPI.removePoint = x => {\n    // First find the node since we need to know its\n    // index as our return value\n    let i;\n    for (i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    // If the node doesn't exist, we return -1\n    if (i >= model.nodes.length) {\n      return -1;\n    }\n    const retVal = i;\n\n    // If the first or last point has been removed, then we update the range\n    // No need to sort here as the order of points hasn't changed.\n    let modifiedInvoked = false;\n    model.nodes.splice(i, 1);\n    if (i === 0 || i === model.nodes.length) {\n      modifiedInvoked = publicAPI.updateRange();\n    }\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n    return retVal;\n  };\n\n  // Removes all points from the function.\n  publicAPI.removeAllPoints = () => {\n    model.nodes = [];\n    publicAPI.sortAndUpdateRange();\n  };\n\n  // Add in end points of line and remove any points between them\n  // Legacy method with no way to specify midpoint and sharpness\n  publicAPI.addSegment = (x1, y1, x2, y2) => {\n    // First, find all points in this range and remove them\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {\n        model.nodes.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n\n    // Now add the points\n    publicAPI.addPoint(x1, y1, 0.5, 0.0);\n    publicAPI.addPoint(x2, y2, 0.5, 0.0);\n  };\n\n  // Return the value of the function at a position\n  publicAPI.getValue = x => {\n    const table = [];\n    publicAPI.getTable(x, x, 1, table);\n    return table[0];\n  };\n\n  // Remove all points outside the range, and make sure a point\n  // exists at each end of the range. Used as a convenience method\n  // for transfer function editors\n  publicAPI.adjustRange = range => {\n    if (range.length < 2) {\n      return 0;\n    }\n    const functionRange = publicAPI.getRange();\n\n    // Make sure we have points at each end of the range\n    if (functionRange[0] < range[0]) {\n      publicAPI.addPoint(range[0], publicAPI.getValue(range[0]));\n    } else {\n      publicAPI.addPoint(range[0], publicAPI.getValue(functionRange[0]));\n    }\n    if (functionRange[1] > range[1]) {\n      publicAPI.addPoint(range[1], publicAPI.getValue(range[1]));\n    } else {\n      publicAPI.addPoint(range[1], publicAPI.getValue(functionRange[1]));\n    }\n\n    // Remove all points out-of-range\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {\n        model.nodes.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n    publicAPI.sortAndUpdateRange();\n    return 1;\n  };\n\n  //--------------------------------------------------------------------------\n  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {\n    const d = publicAPI.findMinimumXDistance();\n    return Math.ceil((x2 - x1) / d);\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.findMinimumXDistance = () => {\n    const size = model.nodes.length;\n    if (size < 2) {\n      return -1.0;\n    }\n    let distance = model.nodes[1].x - model.nodes[0].x;\n    for (let i = 0; i < size - 1; i++) {\n      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;\n      if (currentDist < distance) {\n        distance = currentDist;\n      }\n    }\n    return distance;\n  };\n\n  // Returns a table of function values evaluated at regular intervals\n  /* eslint-disable prefer-destructuring */\n  /* eslint-disable no-continue */\n  publicAPI.getTable = function (xStart, xEnd, size, table) {\n    let stride = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    let i;\n    let idx = 0;\n    const numNodes = model.nodes.length;\n\n    // Need to keep track of the last value so that\n    // we can fill in table locations past this with\n    // this value if Clamping is On.\n    let lastValue = 0.0;\n    if (numNodes !== 0) {\n      lastValue = model.nodes[numNodes - 1].y;\n    }\n    let x = 0.0;\n    let x1 = 0.0;\n    let x2 = 0.0;\n    let y1 = 0.0;\n    let y2 = 0.0;\n    let midpoint = 0.0;\n    let sharpness = 0.0;\n\n    // For each table entry\n    for (i = 0; i < size; i++) {\n      // Find our location in the table\n      const tidx = stride * i;\n\n      // Find our X location. If we are taking only 1 sample, make\n      // it halfway between start and end (usually start and end will\n      // be the same in this case)\n      if (size > 1) {\n        x = xStart + i / (size - 1.0) * (xEnd - xStart);\n      } else {\n        x = 0.5 * (xStart + xEnd);\n      }\n\n      // Do we need to move to the next node?\n      while (idx < numNodes && x > model.nodes[idx].x) {\n        idx++;\n        // If we are at a valid point index, fill in\n        // the value at this node, and the one before (the\n        // two that surround our current sample location)\n        // idx cannot be 0 since we just incremented it.\n        if (idx < numNodes) {\n          x1 = model.nodes[idx - 1].x;\n          x2 = model.nodes[idx].x;\n          y1 = model.nodes[idx - 1].y;\n          y2 = model.nodes[idx].y;\n\n          // We only need the previous midpoint and sharpness\n          // since these control this region\n          midpoint = model.nodes[idx - 1].midpoint;\n          sharpness = model.nodes[idx - 1].sharpness;\n\n          // Move midpoint away from extreme ends of range to avoid\n          // degenerate math\n          if (midpoint < 0.00001) {\n            midpoint = 0.00001;\n          }\n          if (midpoint > 0.99999) {\n            midpoint = 0.99999;\n          }\n        }\n      }\n\n      // Are we at the end? If so, just use the last value\n      if (idx >= numNodes) {\n        table[tidx] = model.clamping ? lastValue : 0.0;\n      } else if (idx === 0) {\n        // Are we before the first node? If so, duplicate this nodes values\n        table[tidx] = model.clamping ? model.nodes[0].y : 0.0;\n      } else {\n        // Otherwise, we are between two nodes - interpolate\n        // Our first attempt at a normalized location [0,1] -\n        // we will be modifying this based on midpoint and\n        // sharpness to get the curve shape we want and to have\n        // it pass through (y1+y2)/2 at the midpoint.\n        let s = (x - x1) / (x2 - x1);\n\n        // Readjust based on the midpoint - linear adjustment\n        if (s < midpoint) {\n          s = 0.5 * s / midpoint;\n        } else {\n          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);\n        }\n\n        // override for sharpness > 0.99\n        // In this case we just want piecewise constant\n        if (sharpness > 0.99) {\n          // Use the first value since we are below the midpoint\n          if (s < 0.5) {\n            table[tidx] = y1;\n            continue;\n          } else {\n            // Use the second value at or above the midpoint\n            table[tidx] = y2;\n            continue;\n          }\n        }\n\n        // Override for sharpness < 0.01\n        // In this case we want piecewise linear\n        if (sharpness < 0.01) {\n          // Simple linear interpolation\n          table[tidx] = (1 - s) * y1 + s * y2;\n          continue;\n        }\n\n        // We have a sharpness between [0.01, 0.99] - we will\n        // used a modified hermite curve interpolation where we\n        // derive the slope based on the sharpness, and we compress\n        // the curve non-linearly based on the sharpness\n\n        // First, we will adjust our position based on sharpness in\n        // order to make the curve sharper (closer to piecewise constant)\n        if (s < 0.5) {\n          s = 0.5 * (s * 2) ** (1.0 + 10 * sharpness);\n        } else if (s > 0.5) {\n          s = 1.0 - 0.5 * ((1.0 - s) * 2) ** (1 + 10 * sharpness);\n        }\n\n        // Compute some coefficients we will need for the hermite curve\n        const ss = s * s;\n        const sss = ss * s;\n        const h1 = 2 * sss - 3 * ss + 1;\n        const h2 = -2 * sss + 3 * ss;\n        const h3 = sss - 2 * ss + s;\n        const h4 = sss - ss;\n\n        // Use one slope for both end points\n        const slope = y2 - y1;\n        const t = (1.0 - sharpness) * slope;\n\n        // Compute the value\n        table[tidx] = h1 * y1 + h2 * y2 + h3 * t + h4 * t;\n\n        // Final error check to make sure we don't go outside\n        // the Y range\n        const min = y1 < y2 ? y1 : y2;\n        const max = y1 > y2 ? y1 : y2;\n        table[tidx] = table[tidx] < min ? min : table[tidx];\n        table[tidx] = table[tidx] > max ? max : table[tidx];\n      }\n    }\n  };\n}\n/* eslint-enable prefer-destructuring */\n/* eslint-enable no-continue */\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // model.function = NULL;\n  range: [0, 0],\n  clamping: true,\n  allowDuplicateScalars: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n\n  // Internal objects initialization\n  model.nodes = [];\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['allowDuplicateScalars', 'clamping']);\n  macro.setArray(publicAPI, model, ['range'], 2);\n\n  // Create get macros for array\n  macro.getArray(publicAPI, model, ['range']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkPiecewiseFunction(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPiecewiseFunction');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPiecewiseFunction$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkPiecewiseFunction$1 as default, extend, newInstance };\n","import { mat4, vec4, vec3, quat } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport { r as radiansFromDegrees, k as add, j as cross } from '../../Common/Core/Math/index.js';\n\nconst {\n  vtkDebugMacro\n} = macro;\n\n/* eslint-disable new-cap */\n\n/*\n * Convenience function to access elements of a gl-matrix.  If it turns\n * out I have rows and columns swapped everywhere, then I'll just change\n * the order of 'row' and 'col' parameters in this function\n */\n// function getMatrixElement(matrix, row, col) {\n//   const idx = (row * 4) + col;\n//   return matrix[idx];\n// }\n\n// ----------------------------------------------------------------------------\n// vtkCamera methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCamera(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCamera');\n\n  // Set up private variables and methods\n  const origin = new Float64Array(3);\n  const dopbasis = new Float64Array([0.0, 0.0, -1.0]);\n  const upbasis = new Float64Array([0.0, 1.0, 0.0]);\n  const tmpMatrix = mat4.identity(new Float64Array(16));\n  const tmpMatrix2 = mat4.identity(new Float64Array(16));\n  const tmpvec1 = new Float64Array(3);\n  const tmpvec2 = new Float64Array(3);\n  const tmpvec3 = new Float64Array(3);\n  const rotateMatrix = mat4.identity(new Float64Array(16));\n  const trans = mat4.identity(new Float64Array(16));\n  const newPosition = new Float64Array(3);\n  const newFocalPoint = new Float64Array(3);\n\n  // Internal Functions that don't need to be public\n  function computeViewPlaneNormal() {\n    // VPN is -DOP\n    model.viewPlaneNormal[0] = -model.directionOfProjection[0];\n    model.viewPlaneNormal[1] = -model.directionOfProjection[1];\n    model.viewPlaneNormal[2] = -model.directionOfProjection[2];\n  }\n  publicAPI.orthogonalizeViewUp = () => {\n    const vt = publicAPI.getViewMatrix();\n    model.viewUp[0] = vt[4];\n    model.viewUp[1] = vt[5];\n    model.viewUp[2] = vt[6];\n    publicAPI.modified();\n  };\n  publicAPI.setPosition = (x, y, z) => {\n    if (x === model.position[0] && y === model.position[1] && z === model.position[2]) {\n      return;\n    }\n    model.position[0] = x;\n    model.position[1] = y;\n    model.position[2] = z;\n\n    // recompute the focal distance\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n  publicAPI.setFocalPoint = (x, y, z) => {\n    if (x === model.focalPoint[0] && y === model.focalPoint[1] && z === model.focalPoint[2]) {\n      return;\n    }\n    model.focalPoint[0] = x;\n    model.focalPoint[1] = y;\n    model.focalPoint[2] = z;\n\n    // recompute the focal distance\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n  publicAPI.setDistance = d => {\n    if (model.distance === d) {\n      return;\n    }\n    model.distance = d;\n    if (model.distance < 1e-20) {\n      model.distance = 1e-20;\n      vtkDebugMacro('Distance is set to minimum.');\n    }\n\n    // we want to keep the camera pointing in the same direction\n    const vec = model.directionOfProjection;\n\n    // recalculate FocalPoint\n    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  // This method must be called when the focal point or camera position changes\n  publicAPI.computeDistance = () => {\n    const dx = model.focalPoint[0] - model.position[0];\n    const dy = model.focalPoint[1] - model.position[1];\n    const dz = model.focalPoint[2] - model.position[2];\n    model.distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n    if (model.distance < 1e-20) {\n      model.distance = 1e-20;\n      vtkDebugMacro('Distance is set to minimum.');\n      const vec = model.directionOfProjection;\n\n      // recalculate FocalPoint\n      model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n      model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n      model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    }\n    model.directionOfProjection[0] = dx / model.distance;\n    model.directionOfProjection[1] = dy / model.distance;\n    model.directionOfProjection[2] = dz / model.distance;\n    computeViewPlaneNormal();\n  };\n\n  //----------------------------------------------------------------------------\n  // Move the position of the camera along the view plane normal. Moving\n  // towards the focal point (e.g., > 1) is a dolly-in, moving away\n  // from the focal point (e.g., < 1) is a dolly-out.\n  publicAPI.dolly = amount => {\n    if (amount <= 0.0) {\n      return;\n    }\n\n    // dolly moves the camera towards the focus\n    const d = model.distance / amount;\n    publicAPI.setPosition(model.focalPoint[0] - d * model.directionOfProjection[0], model.focalPoint[1] - d * model.directionOfProjection[1], model.focalPoint[2] - d * model.directionOfProjection[2]);\n  };\n  publicAPI.roll = angle => {\n    const eye = model.position;\n    const at = model.focalPoint;\n    const up = model.viewUp;\n    const viewUpVec4 = new Float64Array([up[0], up[1], up[2], 0.0]);\n    mat4.identity(rotateMatrix);\n    const viewDir = new Float64Array([at[0] - eye[0], at[1] - eye[1], at[2] - eye[2]]);\n    mat4.rotate(rotateMatrix, rotateMatrix, radiansFromDegrees(angle), viewDir);\n    vec4.transformMat4(viewUpVec4, viewUpVec4, rotateMatrix);\n    model.viewUp[0] = viewUpVec4[0];\n    model.viewUp[1] = viewUpVec4[1];\n    model.viewUp[2] = viewUpVec4[2];\n    publicAPI.modified();\n  };\n  publicAPI.azimuth = angle => {\n    const fp = model.focalPoint;\n    mat4.identity(trans);\n\n    // translate the focal point to the origin,\n    // rotate about view up,\n    // translate back again\n    mat4.translate(trans, trans, fp);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), model.viewUp);\n    mat4.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);\n\n    // apply the transform to the position\n    vec3.transformMat4(newPosition, model.position, trans);\n    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);\n  };\n  publicAPI.yaw = angle => {\n    const position = model.position;\n    mat4.identity(trans);\n\n    // translate the camera to the origin,\n    // rotate about axis,\n    // translate back again\n    mat4.translate(trans, trans, position);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), model.viewUp);\n    mat4.translate(trans, trans, [-position[0], -position[1], -position[2]]);\n\n    // apply the transform to the position\n    vec3.transformMat4(newFocalPoint, model.focalPoint, trans);\n    publicAPI.setFocalPoint(newFocalPoint[0], newFocalPoint[1], newFocalPoint[2]);\n  };\n  publicAPI.elevation = angle => {\n    const fp = model.focalPoint;\n\n    // get the eye / camera position from the viewMatrix\n    const vt = publicAPI.getViewMatrix();\n    const axis = [-vt[0], -vt[1], -vt[2]];\n    mat4.identity(trans);\n\n    // translate the focal point to the origin,\n    // rotate about view up,\n    // translate back again\n    mat4.translate(trans, trans, fp);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), axis);\n    mat4.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);\n\n    // apply the transform to the position\n    vec3.transformMat4(newPosition, model.position, trans);\n    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);\n  };\n  publicAPI.pitch = angle => {\n    const position = model.position;\n    const vt = publicAPI.getViewMatrix();\n    const axis = [vt[0], vt[1], vt[2]];\n    mat4.identity(trans);\n\n    // translate the camera to the origin,\n    // rotate about axis,\n    // translate back again\n    mat4.translate(trans, trans, position);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), axis);\n    mat4.translate(trans, trans, [-position[0], -position[1], -position[2]]);\n\n    // apply the transform to the focal point\n    vec3.transformMat4(newFocalPoint, model.focalPoint, trans);\n    publicAPI.setFocalPoint(...newFocalPoint);\n  };\n  publicAPI.zoom = factor => {\n    if (factor <= 0) {\n      return;\n    }\n    if (model.parallelProjection) {\n      model.parallelScale /= factor;\n    } else {\n      model.viewAngle /= factor;\n    }\n    publicAPI.modified();\n  };\n  publicAPI.translate = (x, y, z) => {\n    const offset = [x, y, z];\n    add(model.position, offset, model.position);\n    add(model.focalPoint, offset, model.focalPoint);\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n  publicAPI.applyTransform = transformMat4 => {\n    const vuOld = [...model.viewUp, 1.0];\n    const posNew = [];\n    const fpNew = [];\n    const vuNew = [];\n    vuOld[0] += model.position[0];\n    vuOld[1] += model.position[1];\n    vuOld[2] += model.position[2];\n    vec4.transformMat4(posNew, [...model.position, 1.0], transformMat4);\n    vec4.transformMat4(fpNew, [...model.focalPoint, 1.0], transformMat4);\n    vec4.transformMat4(vuNew, vuOld, transformMat4);\n    vuNew[0] -= posNew[0];\n    vuNew[1] -= posNew[1];\n    vuNew[2] -= posNew[2];\n    publicAPI.setPosition(...posNew.slice(0, 3));\n    publicAPI.setFocalPoint(...fpNew.slice(0, 3));\n    publicAPI.setViewUp(...vuNew.slice(0, 3));\n  };\n  publicAPI.getThickness = () => model.clippingRange[1] - model.clippingRange[0];\n  publicAPI.setThickness = thickness => {\n    let t = thickness;\n    if (t < 1e-20) {\n      t = 1e-20;\n      vtkDebugMacro('Thickness is set to minimum.');\n    }\n    publicAPI.setClippingRange(model.clippingRange[0], model.clippingRange[0] + t);\n  };\n  publicAPI.setThicknessFromFocalPoint = thickness => {\n    let t = thickness;\n    if (t < 1e-20) {\n      t = 1e-20;\n      vtkDebugMacro('Thickness is set to minimum.');\n    }\n    publicAPI.setClippingRange(model.distance - t / 2, model.distance + t / 2);\n  };\n\n  // Unimplemented functions\n  publicAPI.setRoll = angle => {}; // dependency on GetOrientation() and a model.ViewTransform object, see https://github.com/Kitware/VTK/blob/master/Common/Transforms/vtkTransform.cxx and https://vtk.org/doc/nightly/html/classvtkTransform.html\n  publicAPI.getRoll = () => {};\n  publicAPI.setObliqueAngles = (alpha, beta) => {};\n  publicAPI.getOrientation = () => {};\n  publicAPI.getOrientationWXYZ = () => {};\n  publicAPI.getFrustumPlanes = aspect => {\n    // Return array of 24 params (4 params for each of 6 plane equations)\n  };\n  publicAPI.getCameraLightTransformMatrix = matrix => {\n    mat4.copy(matrix, model.cameraLightTransform);\n    return matrix;\n  };\n  publicAPI.computeCameraLightTransform = () => {\n    // not sure if this is the correct transformation, based on the same funciton in VTK\n    mat4.copy(tmpMatrix, publicAPI.getViewMatrix());\n    mat4.invert(tmpMatrix, tmpMatrix);\n    mat4.fromScaling(tmpMatrix2, [model.distance, model.distance, model.distance]);\n    mat4.multiply(tmpMatrix, tmpMatrix, tmpMatrix2);\n    mat4.identity(model.cameraLightTransform);\n    mat4.translate(model.cameraLightTransform, tmpMatrix, [0.0, 0.0, -1.0]);\n  };\n  publicAPI.deepCopy = sourceCamera => {};\n  publicAPI.physicalOrientationToWorldDirection = ori => {\n    // push the x axis through the orientation quat\n    const oriq = quat.fromValues(ori[0], ori[1], ori[2], ori[3]);\n    const coriq = quat.create();\n    const qdir = quat.fromValues(0.0, 0.0, 1.0, 0.0);\n    quat.conjugate(coriq, oriq);\n\n    // rotate the z axis by the quat\n    quat.multiply(qdir, oriq, qdir);\n    quat.multiply(qdir, qdir, coriq);\n\n    // return the z axis in world coords\n    return [qdir[0], qdir[1], qdir[2]];\n  };\n  publicAPI.getPhysicalToWorldMatrix = result => {\n    publicAPI.getWorldToPhysicalMatrix(result);\n    mat4.invert(result, result);\n  };\n  publicAPI.getWorldToPhysicalMatrix = result => {\n    mat4.identity(result);\n\n    // now the physical to vtk world rotation tform\n    const physVRight = [3];\n    cross(model.physicalViewNorth, model.physicalViewUp, physVRight);\n    result[0] = physVRight[0];\n    result[1] = physVRight[1];\n    result[2] = physVRight[2];\n    result[4] = model.physicalViewUp[0];\n    result[5] = model.physicalViewUp[1];\n    result[6] = model.physicalViewUp[2];\n    result[8] = -model.physicalViewNorth[0];\n    result[9] = -model.physicalViewNorth[1];\n    result[10] = -model.physicalViewNorth[2];\n    mat4.transpose(result, result);\n    vec3.set(tmpvec1, 1 / model.physicalScale, 1 / model.physicalScale, 1 / model.physicalScale);\n    mat4.scale(result, result, tmpvec1);\n    mat4.translate(result, result, model.physicalTranslation);\n  };\n  publicAPI.computeViewParametersFromViewMatrix = vmat => {\n    // invert to get view to world\n    mat4.invert(tmpMatrix, vmat);\n\n    // note with glmatrix operations happen in\n    // the reverse order\n    // mat.scale\n    // mat.translate\n    // will result in the translation then the scale\n    // mat.mult(a,b)\n    // results in perform the B transformation then A\n\n    // then extract the params position, orientation\n    // push 0,0,0 through to get a translation\n    vec3.transformMat4(tmpvec1, origin, tmpMatrix);\n    publicAPI.computeDistance();\n    const oldDist = model.distance;\n    publicAPI.setPosition(tmpvec1[0], tmpvec1[1], tmpvec1[2]);\n\n    // push basis vectors to get orientation\n    vec3.transformMat4(tmpvec2, dopbasis, tmpMatrix);\n    vec3.subtract(tmpvec2, tmpvec2, tmpvec1);\n    vec3.normalize(tmpvec2, tmpvec2);\n    publicAPI.setDirectionOfProjection(tmpvec2[0], tmpvec2[1], tmpvec2[2]);\n    vec3.transformMat4(tmpvec3, upbasis, tmpMatrix);\n    vec3.subtract(tmpvec3, tmpvec3, tmpvec1);\n    vec3.normalize(tmpvec3, tmpvec3);\n    publicAPI.setViewUp(tmpvec3[0], tmpvec3[1], tmpvec3[2]);\n    publicAPI.setDistance(oldDist);\n  };\n\n  // the provided matrix should include\n  // translation and orientation only\n  // mat is physical to view\n  publicAPI.computeViewParametersFromPhysicalMatrix = mat => {\n    // get the WorldToPhysicalMatrix\n    publicAPI.getWorldToPhysicalMatrix(tmpMatrix);\n\n    // first convert the physical -> view matrix to be\n    // world -> view\n    mat4.multiply(tmpMatrix, mat, tmpMatrix);\n    publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);\n  };\n  publicAPI.setViewMatrix = mat => {\n    model.viewMatrix = mat;\n    if (model.viewMatrix) {\n      mat4.copy(tmpMatrix, model.viewMatrix);\n      publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);\n      mat4.transpose(model.viewMatrix, model.viewMatrix);\n    }\n  };\n  publicAPI.getViewMatrix = () => {\n    if (model.viewMatrix) {\n      return model.viewMatrix;\n    }\n    mat4.lookAt(tmpMatrix, model.position,\n    // eye\n    model.focalPoint,\n    // at\n    model.viewUp // up\n    );\n\n    mat4.transpose(tmpMatrix, tmpMatrix);\n    const result = new Float64Array(16);\n    mat4.copy(result, tmpMatrix);\n    return result;\n  };\n  publicAPI.setProjectionMatrix = mat => {\n    model.projectionMatrix = mat;\n  };\n  publicAPI.getProjectionMatrix = (aspect, nearz, farz) => {\n    const result = new Float64Array(16);\n    mat4.identity(result);\n    if (model.projectionMatrix) {\n      const scale = 1 / model.physicalScale;\n      vec3.set(tmpvec1, scale, scale, scale);\n      mat4.copy(result, model.projectionMatrix);\n      mat4.scale(result, result, tmpvec1);\n      mat4.transpose(result, result);\n      return result;\n    }\n    mat4.identity(tmpMatrix);\n\n    // FIXME: Not sure what to do about adjust z buffer here\n    // adjust Z-buffer range\n    // this->ProjectionTransform->AdjustZBuffer( -1, +1, nearz, farz );\n    const cWidth = model.clippingRange[1] - model.clippingRange[0];\n    const cRange = [model.clippingRange[0] + (nearz + 1) * cWidth / 2.0, model.clippingRange[0] + (farz + 1) * cWidth / 2.0];\n    if (model.parallelProjection) {\n      // set up a rectangular parallelipiped\n      const width = model.parallelScale * aspect;\n      const height = model.parallelScale;\n      const xmin = (model.windowCenter[0] - 1.0) * width;\n      const xmax = (model.windowCenter[0] + 1.0) * width;\n      const ymin = (model.windowCenter[1] - 1.0) * height;\n      const ymax = (model.windowCenter[1] + 1.0) * height;\n      mat4.ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);\n      mat4.transpose(tmpMatrix, tmpMatrix);\n    } else if (model.useOffAxisProjection) {\n      throw new Error('Off-Axis projection is not supported at this time');\n    } else {\n      const tmp = Math.tan(radiansFromDegrees(model.viewAngle) / 2.0);\n      let width;\n      let height;\n      if (model.useHorizontalViewAngle === true) {\n        width = model.clippingRange[0] * tmp;\n        height = model.clippingRange[0] * tmp / aspect;\n      } else {\n        width = model.clippingRange[0] * tmp * aspect;\n        height = model.clippingRange[0] * tmp;\n      }\n      const xmin = (model.windowCenter[0] - 1.0) * width;\n      const xmax = (model.windowCenter[0] + 1.0) * width;\n      const ymin = (model.windowCenter[1] - 1.0) * height;\n      const ymax = (model.windowCenter[1] + 1.0) * height;\n      const znear = cRange[0];\n      const zfar = cRange[1];\n      tmpMatrix[0] = 2.0 * znear / (xmax - xmin);\n      tmpMatrix[5] = 2.0 * znear / (ymax - ymin);\n      tmpMatrix[2] = (xmin + xmax) / (xmax - xmin);\n      tmpMatrix[6] = (ymin + ymax) / (ymax - ymin);\n      tmpMatrix[10] = -(znear + zfar) / (zfar - znear);\n      tmpMatrix[14] = -1.0;\n      tmpMatrix[11] = -2.0 * znear * zfar / (zfar - znear);\n      tmpMatrix[15] = 0.0;\n    }\n    mat4.copy(result, tmpMatrix);\n    return result;\n  };\n  publicAPI.getCompositeProjectionMatrix = (aspect, nearz, farz) => {\n    const vMat = publicAPI.getViewMatrix();\n    const pMat = publicAPI.getProjectionMatrix(aspect, nearz, farz);\n    // mats are transposed so the order is A then B\n    // we reuse pMat as it is a copy so we can do what we want with it\n    mat4.multiply(pMat, vMat, pMat);\n    return pMat;\n  };\n  publicAPI.setDirectionOfProjection = (x, y, z) => {\n    if (model.directionOfProjection[0] === x && model.directionOfProjection[1] === y && model.directionOfProjection[2] === z) {\n      return;\n    }\n    model.directionOfProjection[0] = x;\n    model.directionOfProjection[1] = y;\n    model.directionOfProjection[2] = z;\n    const vec = model.directionOfProjection;\n\n    // recalculate FocalPoint\n    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    computeViewPlaneNormal();\n  };\n\n  // used to handle convert js device orientation angles\n  // when you use this method the camera will adjust to the\n  // device orientation such that the physicalViewUp you set\n  // in world coordinates looks up, and the physicalViewNorth\n  // you set in world coorindates will (maybe) point north\n  //\n  // NOTE WARNING - much of the documentation out there on how\n  // orientation works is seriously wrong. Even worse the Chrome\n  // device orientation simulator is completely wrong and should\n  // never be used. OMG it is so messed up.\n  //\n  // how it seems to work on iOS is that the device orientation\n  // is specified in extrinsic angles with a alpha, beta, gamma\n  // convention with axes of Z, X, Y (the code below substitutes\n  // the physical coordinate system for these axes to get the right\n  // modified coordinate system.\n  publicAPI.setDeviceAngles = (alpha, beta, gamma, screen) => {\n    const physVRight = [3];\n    cross(model.physicalViewNorth, model.physicalViewUp, physVRight);\n\n    // phone to physical coordinates\n    const rotmat = mat4.identity(new Float64Array(16));\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(alpha), model.physicalViewUp);\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(beta), physVRight);\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(gamma), model.physicalViewNorth);\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(-screen), model.physicalViewUp);\n    const dop = new Float64Array([-model.physicalViewUp[0], -model.physicalViewUp[1], -model.physicalViewUp[2]]);\n    const vup = new Float64Array(model.physicalViewNorth);\n    vec3.transformMat4(dop, dop, rotmat);\n    vec3.transformMat4(vup, vup, rotmat);\n    publicAPI.setDirectionOfProjection(dop[0], dop[1], dop[2]);\n    publicAPI.setViewUp(vup[0], vup[1], vup[2]);\n    publicAPI.modified();\n  };\n  publicAPI.setOrientationWXYZ = (degrees, x, y, z) => {\n    const quatMat = mat4.identity(new Float64Array(16));\n    if (degrees !== 0.0 && (x !== 0.0 || y !== 0.0 || z !== 0.0)) {\n      // convert to radians\n      const angle = radiansFromDegrees(degrees);\n      const q = quat.create();\n      quat.setAxisAngle(q, [x, y, z], angle);\n      mat4.fromQuat(quatMat, q);\n    }\n    const newdop = new Float64Array(3);\n    vec3.transformMat4(newdop, [0.0, 0.0, -1.0], quatMat);\n    const newvup = new Float64Array(3);\n    vec3.transformMat4(newvup, [0.0, 1.0, 0.0], quatMat);\n    publicAPI.setDirectionOfProjection(...newdop);\n    publicAPI.setViewUp(...newvup);\n    publicAPI.modified();\n  };\n  publicAPI.computeClippingRange = bounds => {\n    let vn = null;\n    let position = null;\n    vn = model.viewPlaneNormal;\n    position = model.position;\n    const a = -vn[0];\n    const b = -vn[1];\n    const c = -vn[2];\n    const d = -(a * position[0] + b * position[1] + c * position[2]);\n\n    // Set the max near clipping plane and the min far clipping plane\n    const range = [a * bounds[0] + b * bounds[2] + c * bounds[4] + d, 1e-18];\n\n    // Find the closest / farthest bounding box vertex\n    for (let k = 0; k < 2; k++) {\n      for (let j = 0; j < 2; j++) {\n        for (let i = 0; i < 2; i++) {\n          const dist = a * bounds[i] + b * bounds[2 + j] + c * bounds[4 + k] + d;\n          range[0] = dist < range[0] ? dist : range[0];\n          range[1] = dist > range[1] ? dist : range[1];\n        }\n      }\n    }\n    return range;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  position: [0, 0, 1],\n  focalPoint: [0, 0, 0],\n  viewUp: [0, 1, 0],\n  directionOfProjection: [0, 0, -1],\n  parallelProjection: false,\n  useHorizontalViewAngle: false,\n  viewAngle: 30,\n  parallelScale: 1,\n  clippingRange: [0.01, 1000.01],\n  windowCenter: [0, 0],\n  viewPlaneNormal: [0, 0, 1],\n  useOffAxisProjection: false,\n  screenBottomLeft: [-0.5, -0.5, -0.5],\n  screenBottomRight: [0.5, -0.5, -0.5],\n  screenTopRight: [0.5, 0.5, -0.5],\n  freezeFocalPoint: false,\n  projectionMatrix: null,\n  viewMatrix: null,\n  cameraLightTransform: mat4.create(),\n  // used for world to physical transformations\n  physicalTranslation: [0, 0, 0],\n  physicalScale: 1.0,\n  physicalViewUp: [0, 1, 0],\n  physicalViewNorth: [0, 0, -1]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['distance']);\n  macro.setGet(publicAPI, model, ['parallelProjection', 'useHorizontalViewAngle', 'viewAngle', 'parallelScale', 'useOffAxisProjection', 'freezeFocalPoint', 'physicalScale']);\n  macro.getArray(publicAPI, model, ['directionOfProjection', 'viewPlaneNormal', 'position', 'focalPoint']);\n  macro.setGetArray(publicAPI, model, ['clippingRange', 'windowCenter'], 2);\n  macro.setGetArray(publicAPI, model, ['viewUp', 'screenBottomLeft', 'screenBottomRight', 'screenTopRight', 'physicalTranslation', 'physicalViewUp', 'physicalViewNorth'], 3);\n\n  // Object methods\n  vtkCamera(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCamera');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCamera$1 = {\n  newInstance,\n  extend\n};\n\nexport { DEFAULT_VALUES, vtkCamera$1 as default, extend, newInstance };\n","import { m as macro } from '../../macros2.js';\nimport { h as hsv2rgb, i as isNan, J as floor, K as isInf, L as rgb2hsv, M as rgb2lab, N as lab2rgb } from '../../Common/Core/Math/index.js';\nimport vtkScalarsToColors from '../../Common/Core/ScalarsToColors.js';\nimport Constants from './ColorTransferFunction/Constants.js';\n\nconst {\n  ColorSpace,\n  Scale\n} = Constants;\nconst {\n  ScalarMappingTarget\n} = vtkScalarsToColors;\nconst {\n  vtkDebugMacro,\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n/* eslint-disable no-continue                                                */\n\n// Convert to and from a special polar version of CIELAB (useful for creating\n// continuous diverging color maps).\nfunction vtkColorTransferFunctionLabToMsh(lab, msh) {\n  const L = lab[0];\n  const a = lab[1];\n  const b = lab[2];\n  const M = Math.sqrt(L * L + a * a + b * b);\n  const s = M > 0.001 ? Math.acos(L / M) : 0.0;\n  const h = s > 0.001 ? Math.atan2(b, a) : 0.0;\n  msh[0] = M;\n  msh[1] = s;\n  msh[2] = h;\n}\nfunction vtkColorTransferFunctionMshToLab(msh, lab) {\n  const M = msh[0];\n  const s = msh[1];\n  const h = msh[2];\n  lab[0] = M * Math.cos(s);\n  lab[1] = M * Math.sin(s) * Math.cos(h);\n  lab[2] = M * Math.sin(s) * Math.sin(h);\n}\n\n// For the case when interpolating from a saturated color to an unsaturated\n// color, find a hue for the unsaturated color that makes sense.\nfunction vtkColorTransferFunctionAdjustHue(msh, unsatM) {\n  if (msh[0] >= unsatM - 0.1) {\n    // The best we can do is hold hue constant.\n    return msh[2];\n  }\n\n  // This equation is designed to make the perceptual change of the\n  // interpolation to be close to constant.\n  const hueSpin = msh[1] * Math.sqrt(unsatM * unsatM - msh[0] * msh[0]) / (msh[0] * Math.sin(msh[1]));\n  // Spin hue away from 0 except in purple hues.\n  if (msh[2] > -0.3 * Math.PI) {\n    return msh[2] + hueSpin;\n  }\n  return msh[2] - hueSpin;\n}\nfunction vtkColorTransferFunctionAngleDiff(a1, a2) {\n  let adiff = a1 - a2;\n  if (adiff < 0.0) {\n    adiff = -adiff;\n  }\n  while (adiff >= 2.0 * Math.PI) {\n    adiff -= 2.0 * Math.PI;\n  }\n  if (adiff > Math.PI) {\n    adiff = 2.0 * Math.PI - adiff;\n  }\n  return adiff;\n}\n\n// Interpolate a diverging color map.\nfunction vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, result) {\n  const lab1 = [];\n  const lab2 = [];\n  rgb2lab(rgb1, lab1);\n  rgb2lab(rgb2, lab2);\n  const msh1 = [];\n  const msh2 = [];\n  vtkColorTransferFunctionLabToMsh(lab1, msh1);\n  vtkColorTransferFunctionLabToMsh(lab2, msh2);\n\n  // If the endpoints are distinct saturated colors, then place white in between\n  // them.\n  let localS = s;\n  if (msh1[1] > 0.05 && msh2[1] > 0.05 && vtkColorTransferFunctionAngleDiff(msh1[2], msh2[2]) > 0.33 * Math.PI) {\n    // Insert the white midpoint by setting one end to white and adjusting the\n    // scalar value.\n    let Mmid = Math.max(msh1[0], msh2[0]);\n    Mmid = Math.max(88.0, Mmid);\n    if (s < 0.5) {\n      msh2[0] = Mmid;\n      msh2[1] = 0.0;\n      msh2[2] = 0.0;\n      localS *= 2.0;\n    } else {\n      msh1[0] = Mmid;\n      msh1[1] = 0.0;\n      msh1[2] = 0.0;\n      localS = 2.0 * localS - 1.0;\n    }\n  }\n\n  // If one color has no saturation, then its hue value is invalid.  In this\n  // case, we want to set it to something logical so that the interpolation of\n  // hue makes sense.\n  if (msh1[1] < 0.05 && msh2[1] > 0.05) {\n    msh1[2] = vtkColorTransferFunctionAdjustHue(msh2, msh1[0]);\n  } else if (msh2[1] < 0.05 && msh1[1] > 0.05) {\n    msh2[2] = vtkColorTransferFunctionAdjustHue(msh1, msh2[0]);\n  }\n  const mshTmp = [];\n  mshTmp[0] = (1 - localS) * msh1[0] + localS * msh2[0];\n  mshTmp[1] = (1 - localS) * msh1[1] + localS * msh2[1];\n  mshTmp[2] = (1 - localS) * msh1[2] + localS * msh2[2];\n\n  // Now convert back to RGB\n  const labTmp = [];\n  vtkColorTransferFunctionMshToLab(mshTmp, labTmp);\n  lab2rgb(labTmp, result);\n}\n\n// ----------------------------------------------------------------------------\n// vtkColorTransferFunction methods\n// ----------------------------------------------------------------------------\n\nfunction vtkColorTransferFunction(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkColorTransferFunction');\n\n  // Return the number of points which specify this function\n  publicAPI.getSize = () => model.nodes.length;\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n  publicAPI.addRGBPoint = (x, r, g, b) => publicAPI.addRGBPointLong(x, r, g, b, 0.5, 0.0);\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n  publicAPI.addRGBPointLong = function (x, r, g, b) {\n    let midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    let sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;\n    // Error check\n    if (midpoint < 0.0 || midpoint > 1.0) {\n      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');\n      return -1;\n    }\n    if (sharpness < 0.0 || sharpness > 1.0) {\n      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');\n      return -1;\n    }\n\n    // remove any node already at this X location\n    if (!model.allowDuplicateScalars) {\n      publicAPI.removePoint(x);\n    }\n\n    // Create the new node\n    const node = {\n      x,\n      r,\n      g,\n      b,\n      midpoint,\n      sharpness\n    };\n\n    // Add it, then sort to get everything in order\n    model.nodes.push(node);\n    publicAPI.sortAndUpdateRange();\n\n    // We need to find the index of the node we just added in order\n    // to return this value\n    let i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    // If we didn't find it, something went horribly wrong so\n    // return -1\n    if (i < model.nodes.length) {\n      return i;\n    }\n    return -1;\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n  publicAPI.addHSVPoint = (x, h, s, v) => publicAPI.addHSVPointLong(x, h, s, v, 0.5, 0.0);\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n  publicAPI.addHSVPointLong = function (x, h, s, v) {\n    let midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    let sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;\n    const rgb = [];\n    const hsv = [h, s, v];\n    hsv2rgb(hsv, rgb);\n    return publicAPI.addRGBPoint(x, rgb[0], rgb[1], rgb[2], midpoint, sharpness);\n  };\n\n  //----------------------------------------------------------------------------\n  // Set nodes directly\n  publicAPI.setNodes = nodes => {\n    if (model.nodes !== nodes) {\n      const before = JSON.stringify(model.nodes);\n      model.nodes = nodes;\n      const after = JSON.stringify(model.nodes);\n      if (publicAPI.sortAndUpdateRange() || before !== after) {\n        publicAPI.modified();\n        return true;\n      }\n    }\n    return false;\n  };\n\n  //----------------------------------------------------------------------------\n  // Sort the vector in increasing order, then fill in\n  // the Range\n  publicAPI.sortAndUpdateRange = () => {\n    const before = JSON.stringify(model.nodes);\n    model.nodes.sort((a, b) => a.x - b.x);\n    const after = JSON.stringify(model.nodes);\n    const modifiedInvoked = publicAPI.updateRange();\n    // If range is updated, Modified() has been called, don't call it again.\n    if (!modifiedInvoked && before !== after) {\n      publicAPI.modified();\n      return true;\n    }\n    return modifiedInvoked;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.updateRange = () => {\n    const oldRange = [2];\n    oldRange[0] = model.mappingRange[0];\n    oldRange[1] = model.mappingRange[1];\n    const size = model.nodes.length;\n    if (size) {\n      model.mappingRange[0] = model.nodes[0].x;\n      model.mappingRange[1] = model.nodes[size - 1].x;\n    } else {\n      model.mappingRange[0] = 0;\n      model.mappingRange[1] = 0;\n    }\n\n    // If the range is the same, then no need to call Modified()\n    if (oldRange[0] === model.mappingRange[0] && oldRange[1] === model.mappingRange[1]) {\n      return false;\n    }\n    publicAPI.modified();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  // Remove a point\n  publicAPI.removePoint = x => {\n    // First find the node since we need to know its\n    // index as our return value\n    let i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n    const retVal = i;\n\n    // If the node doesn't exist, we return -1\n    if (i >= model.nodes.length) {\n      return -1;\n    }\n\n    // If the first or last point has been removed, then we update the range\n    // No need to sort here as the order of points hasn't changed.\n    let modifiedInvoked = false;\n    model.nodes.splice(i, 1);\n    if (i === 0 || i === model.nodes.length) {\n      modifiedInvoked = publicAPI.updateRange();\n    }\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n    return retVal;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.movePoint = (oldX, newX) => {\n    if (oldX === newX) {\n      // Nothing to do.\n      return;\n    }\n    publicAPI.removePoint(newX);\n    for (let i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === oldX) {\n        model.nodes[i].x = newX;\n        publicAPI.sortAndUpdateRange();\n        break;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  // Remove all points\n  publicAPI.removeAllPoints = () => {\n    model.nodes = [];\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a line defined in RGB\n  publicAPI.addRGBSegment = (x1, r1, g1, b1, x2, r2, g2, b2) => {\n    // First, find all points in this range and remove them\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {\n        model.nodes.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n\n    // Now add the points\n    publicAPI.addRGBPointLong(x1, r1, g1, b1, 0.5, 0.0);\n    publicAPI.addRGBPointLong(x2, r2, g2, b2, 0.5, 0.0);\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a line defined in HSV\n  publicAPI.addHSVSegment = (x1, h1, s1, v1, x2, h2, s2, v2) => {\n    const hsv1 = [h1, s1, v1];\n    const hsv2 = [h2, s2, v2];\n    const rgb1 = [];\n    const rgb2 = [];\n    hsv2rgb(hsv1, rgb1);\n    hsv2rgb(hsv2, rgb2);\n    publicAPI.addRGBSegment(x1, rgb1[0], rgb1[1], rgb1[2], x2, rgb2[0], rgb2[1], rgb2[2]);\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the RGBA color evaluated at the specified location\n  publicAPI.mapValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return [Math.floor(255.0 * rgb[0] + 0.5), Math.floor(255.0 * rgb[1] + 0.5), Math.floor(255.0 * rgb[2] + 0.5), 255];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the RGB color evaluated at the specified location\n  publicAPI.getColor = (x, rgb) => {\n    if (model.indexedLookup) {\n      const numNodes = publicAPI.getSize();\n      // todo\n      const idx = publicAPI.getAnnotatedValueIndexInternal(x);\n      if (idx < 0 || numNodes === 0) {\n        const nanColor = publicAPI.getNanColorByReference();\n        rgb[0] = nanColor[0];\n        rgb[1] = nanColor[1];\n        rgb[2] = nanColor[2];\n      } else {\n        const nodeVal = [];\n        publicAPI.getNodeValue(idx % numNodes, nodeVal);\n        // nodeVal[0] is the x value. nodeVal[1...3] is rgb.\n        rgb[0] = nodeVal[1];\n        rgb[1] = nodeVal[2];\n        rgb[2] = nodeVal[3];\n      }\n      return;\n    }\n    publicAPI.getTable(x, x, 1, rgb);\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the red color evaluated at the specified location\n  publicAPI.getRedValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[0];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the green color evaluated at the specified location\n  publicAPI.getGreenValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[1];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the blue color evaluated at the specified location\n  publicAPI.getBlueValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[2];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns a table of RGB colors at regular intervals along the function\n  publicAPI.getTable = (xStart_, xEnd_, size, table) => {\n    // To handle BigInt limitation\n    const xStart = Number(xStart_);\n    const xEnd = Number(xEnd_);\n\n    // Special case: If either the start or end is a NaN, then all any\n    // interpolation done on them is also a NaN.  Therefore, fill the table with\n    // the NaN color.\n    if (isNan(xStart) || isNan(xEnd)) {\n      for (let i = 0; i < size; i++) {\n        table[i * 3 + 0] = model.nanColor[0];\n        table[i * 3 + 1] = model.nanColor[1];\n        table[i * 3 + 2] = model.nanColor[2];\n      }\n      return;\n    }\n    let idx = 0;\n    const numNodes = model.nodes.length;\n\n    // Need to keep track of the last value so that\n    // we can fill in table locations past this with\n    // this value if Clamping is On.\n    let lastR = 0.0;\n    let lastG = 0.0;\n    let lastB = 0.0;\n    if (numNodes !== 0) {\n      lastR = model.nodes[numNodes - 1].r;\n      lastG = model.nodes[numNodes - 1].g;\n      lastB = model.nodes[numNodes - 1].b;\n    }\n    let x = 0.0;\n    let x1 = 0.0;\n    let x2 = 0.0;\n    const rgb1 = [0.0, 0.0, 0.0];\n    const rgb2 = [0.0, 0.0, 0.0];\n    let midpoint = 0.0;\n    let sharpness = 0.0;\n    const tmpVec = [];\n\n    // If the scale is logarithmic, make sure the range is valid.\n    let usingLogScale = model.scale === Scale.LOG10;\n    if (usingLogScale) {\n      // Note: This requires range[0] <= range[1].\n      usingLogScale = model.mappingRange[0] > 0.0;\n    }\n    let logStart = 0.0;\n    let logEnd = 0.0;\n    let logX = 0.0;\n    if (usingLogScale) {\n      logStart = Math.log10(xStart);\n      logEnd = Math.log10(xEnd);\n    }\n\n    // For each table entry\n    for (let i = 0; i < size; i++) {\n      // Find our location in the table\n      const tidx = 3 * i;\n\n      // Find our X location. If we are taking only 1 sample, make\n      // it halfway between start and end (usually start and end will\n      // be the same in this case)\n      if (size > 1) {\n        if (usingLogScale) {\n          logX = logStart + i / (size - 1.0) * (logEnd - logStart);\n          x = 10.0 ** logX;\n        } else {\n          x = xStart + i / (size - 1.0) * (xEnd - xStart);\n        }\n      } else if (usingLogScale) {\n        logX = 0.5 * (logStart + logEnd);\n        x = 10.0 ** logX;\n      } else {\n        x = 0.5 * (xStart + xEnd);\n      }\n\n      // Linearly map x from mappingRange to [0, numberOfValues-1],\n      // discretize (round down to the closest integer),\n      // then map back to mappingRange\n      if (model.discretize) {\n        const range = model.mappingRange;\n        if (x >= range[0] && x <= range[1]) {\n          const numberOfValues = model.numberOfValues;\n          const deltaRange = range[1] - range[0];\n          if (numberOfValues <= 1) {\n            x = range[0] + deltaRange / 2.0;\n          } else {\n            // normalize x\n            const xn = (x - range[0]) / deltaRange;\n            // discretize\n            const discretizeIndex = floor(numberOfValues * xn);\n            // get discretized x\n            x = range[0] + discretizeIndex / (numberOfValues - 1) * deltaRange;\n          }\n        }\n      }\n\n      // Do we need to move to the next node?\n      while (idx < numNodes && x > model.nodes[idx].x) {\n        idx++;\n        // If we are at a valid point index, fill in\n        // the value at this node, and the one before (the\n        // two that surround our current sample location)\n        // idx cannot be 0 since we just incremented it.\n        if (idx < numNodes) {\n          x1 = model.nodes[idx - 1].x;\n          x2 = model.nodes[idx].x;\n          if (usingLogScale) {\n            x1 = Math.log10(x1);\n            x2 = Math.log10(x2);\n          }\n          rgb1[0] = model.nodes[idx - 1].r;\n          rgb2[0] = model.nodes[idx].r;\n          rgb1[1] = model.nodes[idx - 1].g;\n          rgb2[1] = model.nodes[idx].g;\n          rgb1[2] = model.nodes[idx - 1].b;\n          rgb2[2] = model.nodes[idx].b;\n\n          // We only need the previous midpoint and sharpness\n          // since these control this region\n          midpoint = model.nodes[idx - 1].midpoint;\n          sharpness = model.nodes[idx - 1].sharpness;\n\n          // Move midpoint away from extreme ends of range to avoid\n          // degenerate math\n          if (midpoint < 0.00001) {\n            midpoint = 0.00001;\n          }\n          if (midpoint > 0.99999) {\n            midpoint = 0.99999;\n          }\n        }\n      }\n\n      // Are we at or past the end? If so, just use the last value\n      if (x > model.mappingRange[1]) {\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n        if (model.clamping) {\n          if (publicAPI.getUseAboveRangeColor()) {\n            table[tidx] = model.aboveRangeColor[0];\n            table[tidx + 1] = model.aboveRangeColor[1];\n            table[tidx + 2] = model.aboveRangeColor[2];\n          } else {\n            table[tidx] = lastR;\n            table[tidx + 1] = lastG;\n            table[tidx + 2] = lastB;\n          }\n        }\n      } else if (x < model.mappingRange[0] || isInf(x) && x < 0) {\n        // we are before the first node? If so, duplicate this node's values.\n        // We have to deal with -inf here\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n        if (model.clamping) {\n          if (publicAPI.getUseBelowRangeColor()) {\n            table[tidx] = model.belowRangeColor[0];\n            table[tidx + 1] = model.belowRangeColor[1];\n            table[tidx + 2] = model.belowRangeColor[2];\n          } else if (numNodes > 0) {\n            table[tidx] = model.nodes[0].r;\n            table[tidx + 1] = model.nodes[0].g;\n            table[tidx + 2] = model.nodes[0].b;\n          }\n        }\n      } else if (idx === 0 && (Math.abs(x - xStart) < 1e-6 || model.discretize)) {\n        if (numNodes > 0) {\n          table[tidx] = model.nodes[0].r;\n          table[tidx + 1] = model.nodes[0].g;\n          table[tidx + 2] = model.nodes[0].b;\n        } else {\n          table[tidx] = 0.0;\n          table[tidx + 1] = 0.0;\n          table[tidx + 2] = 0.0;\n        }\n      } else {\n        // OK, we are between two nodes - interpolate\n        // Our first attempt at a normalized location [0,1] -\n        // we will be modifying this based on midpoint and\n        // sharpness to get the curve shape we want and to have\n        // it pass through (y1+y2)/2 at the midpoint.\n        let s = 0.0;\n        if (usingLogScale) {\n          s = (logX - x1) / (x2 - x1);\n        } else {\n          s = (x - x1) / (x2 - x1);\n        }\n\n        // Readjust based on the midpoint - linear adjustment\n        if (s < midpoint) {\n          s = 0.5 * s / midpoint;\n        } else {\n          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);\n        }\n\n        // override for sharpness > 0.99\n        // In this case we just want piecewise constant\n        if (sharpness > 0.99) {\n          // Use the first value since we are below the midpoint\n          if (s < 0.5) {\n            table[tidx] = rgb1[0];\n            table[tidx + 1] = rgb1[1];\n            table[tidx + 2] = rgb1[2];\n            continue;\n          } else {\n            // Use the second value at or above the midpoint\n            table[tidx] = rgb2[0];\n            table[tidx + 1] = rgb2[1];\n            table[tidx + 2] = rgb2[2];\n            continue;\n          }\n        }\n\n        // Override for sharpness < 0.01\n        // In this case we want piecewise linear\n        if (sharpness < 0.01) {\n          // Simple linear interpolation\n          if (model.colorSpace === ColorSpace.RGB) {\n            table[tidx] = (1 - s) * rgb1[0] + s * rgb2[0];\n            table[tidx + 1] = (1 - s) * rgb1[1] + s * rgb2[1];\n            table[tidx + 2] = (1 - s) * rgb1[2] + s * rgb2[2];\n          } else if (model.colorSpace === ColorSpace.HSV) {\n            const hsv1 = [];\n            const hsv2 = [];\n            rgb2hsv(rgb1, hsv1);\n            rgb2hsv(rgb2, hsv2);\n            if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {\n              if (hsv1[0] > hsv2[0]) {\n                hsv1[0] -= 1.0;\n              } else {\n                hsv2[0] -= 1.0;\n              }\n            }\n            const hsvTmp = [];\n            hsvTmp[0] = (1.0 - s) * hsv1[0] + s * hsv2[0];\n            if (hsvTmp[0] < 0.0) {\n              hsvTmp[0] += 1.0;\n            }\n            hsvTmp[1] = (1.0 - s) * hsv1[1] + s * hsv2[1];\n            hsvTmp[2] = (1.0 - s) * hsv1[2] + s * hsv2[2];\n\n            // Now convert this back to RGB\n            hsv2rgb(hsvTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.LAB) {\n            const lab1 = [];\n            const lab2 = [];\n            rgb2lab(rgb1, lab1);\n            rgb2lab(rgb2, lab2);\n            const labTmp = [];\n            labTmp[0] = (1 - s) * lab1[0] + s * lab2[0];\n            labTmp[1] = (1 - s) * lab1[1] + s * lab2[1];\n            labTmp[2] = (1 - s) * lab1[2] + s * lab2[2];\n\n            // Now convert back to RGB\n            lab2rgb(labTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.DIVERGING) {\n            vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else {\n            vtkErrorMacro('ColorSpace set to invalid value.', model.colorSpace);\n          }\n          continue;\n        }\n\n        // We have a sharpness between [0.01, 0.99] - we will\n        // used a modified hermite curve interpolation where we\n        // derive the slope based on the sharpness, and we compress\n        // the curve non-linearly based on the sharpness\n\n        // First, we will adjust our position based on sharpness in\n        // order to make the curve sharper (closer to piecewise constant)\n        if (s < 0.5) {\n          s = 0.5 * (s * 2.0) ** (1.0 + 10.0 * sharpness);\n        } else if (s > 0.5) {\n          s = 1.0 - 0.5 * ((1.0 - s) * 2) ** (1 + 10.0 * sharpness);\n        }\n\n        // Compute some coefficients we will need for the hermite curve\n        const ss = s * s;\n        const sss = ss * s;\n        const h1 = 2.0 * sss - 3 * ss + 1;\n        const h2 = -2 * sss + 3 * ss;\n        const h3 = sss - 2 * ss + s;\n        const h4 = sss - ss;\n        let slope;\n        let t;\n        if (model.colorSpace === ColorSpace.RGB) {\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = rgb2[j] - rgb1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            table[tidx + j] = h1 * rgb1[j] + h2 * rgb2[j] + h3 * t + h4 * t;\n          }\n        } else if (model.colorSpace === ColorSpace.HSV) {\n          const hsv1 = [];\n          const hsv2 = [];\n          rgb2hsv(rgb1, hsv1);\n          rgb2hsv(rgb2, hsv2);\n          if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {\n            if (hsv1[0] > hsv2[0]) {\n              hsv1[0] -= 1.0;\n            } else {\n              hsv2[0] -= 1.0;\n            }\n          }\n          const hsvTmp = [];\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = hsv2[j] - hsv1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            hsvTmp[j] = h1 * hsv1[j] + h2 * hsv2[j] + h3 * t + h4 * t;\n            if (j === 0 && hsvTmp[j] < 0.0) {\n              hsvTmp[j] += 1.0;\n            }\n          }\n          // Now convert this back to RGB\n          hsv2rgb(hsvTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.LAB) {\n          const lab1 = [];\n          const lab2 = [];\n          rgb2lab(rgb1, lab1);\n          rgb2lab(rgb2, lab2);\n          const labTmp = [];\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = lab2[j] - lab1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            labTmp[j] = h1 * lab1[j] + h2 * lab2[j] + h3 * t + h4 * t;\n          }\n          // Now convert this back to RGB\n          lab2rgb(labTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.DIVERGING) {\n          // I have not implemented proper interpolation by a hermite curve for\n          // the diverging color map, but I cannot think of a good use case for\n          // that anyway.\n          vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else {\n          vtkErrorMacro('ColorSpace set to invalid value.');\n        }\n\n        // Final error check to make sure we don't go outside [0,1]\n        for (let j = 0; j < 3; j++) {\n          table[tidx + j] = table[tidx + j] < 0.0 ? 0.0 : table[tidx + j];\n          table[tidx + j] = table[tidx + j] > 1.0 ? 1.0 : table[tidx + j];\n        }\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getUint8Table = function (xStart, xEnd, size) {\n    let withAlpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (publicAPI.getMTime() <= model.buildTime && model.tableSize === size && model.tableWithAlpha !== withAlpha) {\n      return model.table;\n    }\n    if (model.nodes.length === 0) {\n      vtkErrorMacro('Attempting to lookup a value with no points in the function');\n      return model.table;\n    }\n    const nbChannels = withAlpha ? 4 : 3;\n    if (model.tableSize !== size || model.tableWithAlpha !== withAlpha) {\n      model.table = new Uint8Array(size * nbChannels);\n      model.tableSize = size;\n      model.tableWithAlpha = withAlpha;\n    }\n    const tmpTable = [];\n    publicAPI.getTable(xStart, xEnd, size, tmpTable);\n    for (let i = 0; i < size; i++) {\n      model.table[i * nbChannels + 0] = Math.floor(tmpTable[i * 3 + 0] * 255.0 + 0.5);\n      model.table[i * nbChannels + 1] = Math.floor(tmpTable[i * 3 + 1] * 255.0 + 0.5);\n      model.table[i * nbChannels + 2] = Math.floor(tmpTable[i * 3 + 2] * 255.0 + 0.5);\n      if (withAlpha) {\n        model.table[i * nbChannels + 3] = 255;\n      }\n    }\n    model.buildTime.modified();\n    return model.table;\n  };\n  publicAPI.buildFunctionFromArray = array => {\n    publicAPI.removeAllPoints();\n    const numComponents = array.getNumberOfComponents();\n    for (let i = 0; i < array.getNumberOfTuples(); i++) {\n      switch (numComponents) {\n        case 3:\n          {\n            model.nodes.push({\n              x: i,\n              r: array.getComponent(i, 0),\n              g: array.getComponent(i, 1),\n              b: array.getComponent(i, 2),\n              midpoint: 0.5,\n              sharpness: 0.0\n            });\n            break;\n          }\n        case 4:\n          {\n            model.nodes.push({\n              x: array.getComponent(i, 0),\n              r: array.getComponent(i, 1),\n              g: array.getComponent(i, 2),\n              b: array.getComponent(i, 3),\n              midpoint: 0.5,\n              sharpness: 0.0\n            });\n            break;\n          }\n        case 5:\n          {\n            model.nodes.push({\n              x: i,\n              r: array.getComponent(i, 0),\n              g: array.getComponent(i, 1),\n              b: array.getComponent(i, 2),\n              midpoint: array.getComponent(i, 4),\n              sharpness: array.getComponent(i, 5)\n            });\n            break;\n          }\n        case 6:\n          {\n            model.nodes.push({\n              x: array.getComponent(i, 0),\n              r: array.getComponent(i, 1),\n              g: array.getComponent(i, 2),\n              b: array.getComponent(i, 3),\n              midpoint: array.getComponent(i, 4),\n              sharpness: array.getComponent(i, 5)\n            });\n            break;\n          }\n      }\n    }\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.buildFunctionFromTable = (xStart, xEnd, size, table) => {\n    let inc = 0.0;\n    publicAPI.removeAllPoints();\n    if (size > 1) {\n      inc = (xEnd - xStart) / (size - 1.0);\n    }\n    for (let i = 0; i < size; i++) {\n      const node = {\n        x: xStart + inc * i,\n        r: table[i * 3],\n        g: table[i * 3 + 1],\n        b: table[i * 3 + 2],\n        sharpness: 0.0,\n        midpoint: 0.5\n      };\n      model.nodes.push(node);\n    }\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n  publicAPI.getNodeValue = (index, val) => {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    val[0] = model.nodes[index].x;\n    val[1] = model.nodes[index].r;\n    val[2] = model.nodes[index].g;\n    val[3] = model.nodes[index].b;\n    val[4] = model.nodes[index].midpoint;\n    val[5] = model.nodes[index].sharpness;\n    return 1;\n  };\n\n  //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n  publicAPI.setNodeValue = (index, val) => {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    const oldX = model.nodes[index].x;\n    model.nodes[index].x = val[0];\n    model.nodes[index].r = val[1];\n    model.nodes[index].g = val[2];\n    model.nodes[index].b = val[3];\n    model.nodes[index].midpoint = val[4];\n    model.nodes[index].sharpness = val[5];\n    if (oldX !== val[0]) {\n      // The point has been moved, the order of points or the range might have\n      // been modified.\n      publicAPI.sortAndUpdateRange();\n      // No need to call Modified() here because SortAndUpdateRange() has done it\n      // already.\n    } else {\n      publicAPI.modified();\n    }\n    return 1;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getNumberOfAvailableColors = () => {\n    if (model.indexedLookup && publicAPI.getSize()) {\n      return publicAPI.getSize();\n    }\n    if (model.tableSize) {\n      // Not sure if this is correct since it is only set if\n      // \"const unsigned char *::GetTable(double xStart, double xEnd,int size)\"\n      // has been called.\n      return model.tableSize;\n    }\n    return 16777216; // 2^24\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getIndexedColor = (idx, rgba) => {\n    const n = publicAPI.getSize();\n    if (n > 0 && idx >= 0) {\n      const nodeValue = [];\n      publicAPI.getNodeValue(idx % n, nodeValue);\n      for (let j = 0; j < 3; ++j) {\n        rgba[j] = nodeValue[j + 1];\n      }\n      rgba[3] = 1.0; // NodeColor is RGB-only.\n      return;\n    }\n    const nanColor = publicAPI.getNanColorByReference();\n    rgba[0] = nanColor[0];\n    rgba[1] = nanColor[1];\n    rgba[2] = nanColor[2];\n    rgba[3] = 1.0; // NanColor is RGB-only.\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.fillFromDataPointer = (nb, ptr) => {\n    if (nb <= 0 || !ptr) {\n      return;\n    }\n    publicAPI.removeAllPoints();\n    for (let i = 0; i < nb; i++) {\n      publicAPI.addRGBPoint(ptr[i * 4], ptr[i * 4 + 1], ptr[i * 4 + 2], ptr[i * 4 + 3]);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.setMappingRange = (min, max) => {\n    const range = [min, max];\n    const originalRange = publicAPI.getRange();\n    if (originalRange[1] === range[1] && originalRange[0] === range[0]) {\n      return;\n    }\n    if (range[1] === range[0]) {\n      vtkErrorMacro('attempt to set zero width color range');\n      return;\n    }\n    const scale = (range[1] - range[0]) / (originalRange[1] - originalRange[0]);\n    const shift = range[0] - originalRange[0] * scale;\n    for (let i = 0; i < model.nodes.length; ++i) {\n      model.nodes[i].x = model.nodes[i].x * scale + shift;\n    }\n    model.mappingRange[0] = range[0];\n    model.mappingRange[1] = range[1];\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.adjustRange = range => {\n    const functionRange = publicAPI.getRange();\n\n    // Make sure we have points at each end of the range\n    const rgb = [];\n    if (functionRange[0] < range[0]) {\n      publicAPI.getColor(range[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    }\n    if (functionRange[1] > range[1]) {\n      publicAPI.getColor(range[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    }\n\n    // Remove all points out-of-range\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {\n        model.nodes.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n    return 1;\n  };\n\n  //--------------------------------------------------------------------------\n  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {\n    const d = publicAPI.findMinimumXDistance();\n    return Math.ceil((x2 - x1) / d);\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.findMinimumXDistance = () => {\n    if (model.nodes.length < 2) {\n      return -1.0;\n    }\n    let distance = Number.MAX_VALUE;\n    for (let i = 0; i < model.nodes.length - 1; i++) {\n      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;\n      if (currentDist < distance) {\n        distance = currentDist;\n      }\n    }\n    return distance;\n  };\n  publicAPI.mapScalarsThroughTable = (input, output, outFormat, inputOffset) => {\n    if (publicAPI.getSize() === 0) {\n      vtkDebugMacro('Transfer Function Has No Points!');\n      return;\n    }\n    if (model.indexedLookup) {\n      publicAPI.mapDataIndexed(input, output, outFormat, inputOffset);\n    } else {\n      publicAPI.mapData(input, output, outFormat, inputOffset);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.mapData = (input, output, outFormat, inputOffset) => {\n    if (publicAPI.getSize() === 0) {\n      vtkWarningMacro('Transfer Function Has No Points!');\n      return;\n    }\n    const alpha = Math.floor(publicAPI.getAlpha() * 255.0 + 0.5);\n    const length = input.getNumberOfTuples();\n    const inIncr = input.getNumberOfComponents();\n    const outputV = output.getData();\n    const inputV = input.getData();\n    const rgb = [];\n    if (outFormat === ScalarMappingTarget.RGBA) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 4] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[i * 4 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[i * 4 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n        outputV[i * 4 + 3] = alpha;\n      }\n    }\n    if (outFormat === ScalarMappingTarget.RGB) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 3] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[i * 3 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[i * 3 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n      }\n    }\n    if (outFormat === ScalarMappingTarget.LUMINANCE) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);\n      }\n    }\n    if (outFormat === ScalarMappingTarget.LUMINANCE_ALPHA) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 2] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);\n        outputV[i * 2 + 1] = alpha;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.applyColorMap = colorMap => {\n    const oldColorSpace = JSON.stringify(model.colorSpace);\n    if (colorMap.ColorSpace) {\n      model.colorSpace = ColorSpace[colorMap.ColorSpace.toUpperCase()];\n      if (model.colorSpace === undefined) {\n        vtkErrorMacro(`ColorSpace ${colorMap.ColorSpace} not supported, using RGB instead`);\n        model.colorSpace = ColorSpace.RGB;\n      }\n    }\n    let isModified = oldColorSpace !== JSON.stringify(model.colorSpace);\n    const oldNanColor = isModified || JSON.stringify(model.nanColor);\n    if (colorMap.NanColor) {\n      model.nanColor = [].concat(colorMap.NanColor);\n      while (model.nanColor.length < 4) {\n        model.nanColor.push(1.0);\n      }\n    }\n    isModified = isModified || oldNanColor !== JSON.stringify(model.nanColor);\n    const oldNodes = isModified || JSON.stringify(model.nodes);\n    if (colorMap.RGBPoints) {\n      const size = colorMap.RGBPoints.length;\n      model.nodes = [];\n      const midpoint = 0.5;\n      const sharpness = 0.0;\n      for (let i = 0; i < size; i += 4) {\n        model.nodes.push({\n          x: colorMap.RGBPoints[i],\n          r: colorMap.RGBPoints[i + 1],\n          g: colorMap.RGBPoints[i + 2],\n          b: colorMap.RGBPoints[i + 3],\n          midpoint,\n          sharpness\n        });\n      }\n    }\n    const modifiedInvoked = publicAPI.sortAndUpdateRange();\n    const callModified = !modifiedInvoked && (isModified || oldNodes !== JSON.stringify(model.nodes));\n    if (callModified) publicAPI.modified();\n    return modifiedInvoked || callModified;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  clamping: true,\n  colorSpace: ColorSpace.RGB,\n  hSVWrap: true,\n  scale: Scale.LINEAR,\n  nanColor: null,\n  belowRangeColor: null,\n  aboveRangeColor: null,\n  useAboveRangeColor: false,\n  useBelowRangeColor: false,\n  allowDuplicateScalars: false,\n  table: null,\n  tableSize: 0,\n  buildTime: null,\n  nodes: null,\n  discretize: false,\n  numberOfValues: 256\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkScalarsToColors.extend(publicAPI, model, initialValues);\n\n  // Internal objects initialization\n  model.table = [];\n  model.nodes = [];\n  model.nanColor = [0.5, 0.0, 0.0, 1.0];\n  model.belowRangeColor = [0.0, 0.0, 0.0, 1.0];\n  model.aboveRangeColor = [1.0, 1.0, 1.0, 1.0];\n  model.buildTime = {};\n  macro.obj(model.buildTime);\n\n  // Create get-only macros\n  macro.get(publicAPI, model, ['buildTime', 'mappingRange']);\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['useAboveRangeColor', 'useBelowRangeColor', 'colorSpace', 'discretize', 'numberOfValues']);\n  macro.setArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor'], 4);\n\n  // Create get macros for array\n  macro.getArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkColorTransferFunction(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkColorTransferFunction');\n\n// ----------------------------------------------------------------------------\n\nvar vtkColorTransferFunction$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\nexport { vtkColorTransferFunction$1 as default, extend, newInstance };\n","import { v as vtkColorMaps$1 } from './ColorMaps.json.js';\n\nconst presetMap = Object.create(null);\nvtkColorMaps$1.filter(p => p.RGBPoints).filter(p => p.ColorSpace !== 'CIELAB').forEach(p => {\n  presetMap[p.Name] = p;\n});\n\n// ----------------------------------------------------------------------------\n\nconst rgbPresetNames = Object.keys(presetMap);\nrgbPresetNames.sort();\n\n// ----------------------------------------------------------------------------\n\nfunction getPresetByName(name) {\n  return presetMap[name];\n}\n\n// ----------------------------------------------------------------------------\n\nfunction addPreset(preset) {\n  if (!preset.RGBPoints || preset.ColorSpace === 'CIELAB') {\n    return;\n  }\n  if (!presetMap[preset.Name]) {\n    rgbPresetNames.push(preset.Name);\n    rgbPresetNames.sort();\n  }\n  presetMap[preset.Name] = preset;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction removePresetByName(name) {\n  const index = rgbPresetNames.indexOf(name);\n  if (index > -1) {\n    rgbPresetNames.splice(index, 1);\n  }\n  delete presetMap[name];\n}\n\n// ----------------------------------------------------------------------------\n\nvar vtkColorMaps = {\n  addPreset,\n  removePresetByName,\n  getPresetByName,\n  rgbPresetNames\n};\n\nexport { vtkColorMaps as default };\n","import Constants from './ImageMapper/Constants.js';\nimport { m as macro } from '../../macros2.js';\nimport vtkAbstractImageMapper from './AbstractImageMapper.js';\nimport { intersectWithLineForPointPicking, intersectWithLineForCellPicking } from './AbstractImageMapper/helper.js';\nimport { C as clampValue, R as multiply3x3_vect3, F as createUninitializedBounds, S as getSparseOrthogonalMatrix } from '../../Common/Core/Math/index.js';\nimport CoincidentTopologyHelper from './Mapper/CoincidentTopologyHelper.js';\n\nconst {\n  staticOffsetAPI,\n  otherStaticMethods\n} = CoincidentTopologyHelper;\nconst {\n  SlicingMode\n} = Constants;\n\n// ----------------------------------------------------------------------------\n// vtkImageMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageMapper');\n  publicAPI.getSliceAtPosition = pos => {\n    const image = publicAPI.getCurrentImage();\n    let pos3;\n    if (pos.length === 3) {\n      pos3 = pos;\n    } else if (Number.isFinite(pos)) {\n      const bds = image.getBounds();\n      switch (model.slicingMode) {\n        case SlicingMode.X:\n          pos3 = [pos, (bds[3] + bds[2]) / 2, (bds[5] + bds[4]) / 2];\n          break;\n        case SlicingMode.Y:\n          pos3 = [(bds[1] + bds[0]) / 2, pos, (bds[5] + bds[4]) / 2];\n          break;\n        case SlicingMode.Z:\n          pos3 = [(bds[1] + bds[0]) / 2, (bds[3] + bds[2]) / 2, pos];\n          break;\n      }\n    }\n    const ijk = [0, 0, 0];\n    image.worldToIndex(pos3, ijk);\n    const ex = image.getExtent();\n    const {\n      ijkMode\n    } = publicAPI.getClosestIJKAxis();\n    let slice = 0;\n    switch (ijkMode) {\n      case SlicingMode.I:\n        slice = clampValue(ijk[0], ex[0], ex[1]);\n        break;\n      case SlicingMode.J:\n        slice = clampValue(ijk[1], ex[2], ex[3]);\n        break;\n      case SlicingMode.K:\n        slice = clampValue(ijk[2], ex[4], ex[5]);\n        break;\n      default:\n        return 0;\n    }\n    return slice;\n  };\n  publicAPI.setSliceFromCamera = cam => {\n    const fp = cam.getFocalPoint();\n    switch (model.slicingMode) {\n      case SlicingMode.I:\n      case SlicingMode.J:\n      case SlicingMode.K:\n        {\n          const slice = publicAPI.getSliceAtPosition(fp);\n          publicAPI.setSlice(slice);\n        }\n        break;\n      case SlicingMode.X:\n        publicAPI.setSlice(fp[0]);\n        break;\n      case SlicingMode.Y:\n        publicAPI.setSlice(fp[1]);\n        break;\n      case SlicingMode.Z:\n        publicAPI.setSlice(fp[2]);\n        break;\n    }\n  };\n  publicAPI.setXSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.X);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setYSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.Y);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setZSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.Z);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setISlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.I);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setJSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.J);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setKSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.K);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.getSlicingModeNormal = () => {\n    const out = [0, 0, 0];\n    const mat3 = publicAPI.getCurrentImage().getDirection();\n    switch (model.slicingMode) {\n      case SlicingMode.X:\n        out[0] = 1;\n        break;\n      case SlicingMode.Y:\n        out[1] = 1;\n        break;\n      case SlicingMode.Z:\n        out[2] = 1;\n        break;\n      case SlicingMode.I:\n        multiply3x3_vect3(mat3, [1, 0, 0], out);\n        break;\n      case SlicingMode.J:\n        multiply3x3_vect3(mat3, [0, 1, 0], out);\n        break;\n      case SlicingMode.K:\n        multiply3x3_vect3(mat3, [0, 0, 1], out);\n        break;\n    }\n    return out;\n  };\n  function computeClosestIJKAxis() {\n    let xyzMode;\n    switch (model.slicingMode) {\n      case SlicingMode.X:\n        xyzMode = 0;\n        break;\n      case SlicingMode.Y:\n        xyzMode = 1;\n        break;\n      case SlicingMode.Z:\n        xyzMode = 2;\n        break;\n      default:\n        model.closestIJKAxis = {\n          ijkMode: model.slicingMode,\n          flip: false\n        };\n        return;\n    }\n\n    // The direction matrix in vtkImageData is the indexToWorld rotation matrix\n    // with a column-major data layout since it is stored as a WebGL matrix.\n    const direction = publicAPI.getCurrentImage().getDirection();\n    const newMatrix = getSparseOrthogonalMatrix(direction);\n    // With {foo}Vector filled with 0s except at {foo}Mode position where it is 1\n    // We have xyzVector = (+/-) newMatrix * ijkVector\n    let ijkMode = 0;\n    for (; ijkMode < 3; ++ijkMode) {\n      if (newMatrix[xyzMode + 3 * ijkMode] !== 0) {\n        break;\n      }\n    }\n    const flip = newMatrix[xyzMode + 3 * ijkMode] < 0;\n    model.closestIJKAxis = {\n      ijkMode,\n      flip\n    };\n  }\n  publicAPI.setSlicingMode = mode => {\n    if (model.slicingMode === mode) {\n      return;\n    }\n    model.slicingMode = mode;\n    if (publicAPI.getCurrentImage()) {\n      computeClosestIJKAxis();\n    }\n    publicAPI.modified();\n  };\n  publicAPI.getClosestIJKAxis = () => {\n    if ((model.closestIJKAxis === undefined || model.closestIJKAxis.ijkMode === SlicingMode.NONE) && publicAPI.getCurrentImage()) {\n      computeClosestIJKAxis();\n    }\n    return model.closestIJKAxis;\n  };\n  publicAPI.getBounds = () => {\n    const image = publicAPI.getCurrentImage();\n    if (!image) {\n      return createUninitializedBounds();\n    }\n    if (!model.useCustomExtents) {\n      return image.getBounds();\n    }\n    const ex = model.customDisplayExtent.slice();\n    const {\n      ijkMode\n    } = publicAPI.getClosestIJKAxis();\n    let nSlice = model.slice;\n    if (ijkMode !== model.slicingMode) {\n      // If not IJK slicing, get the IJK slice from the XYZ position/slice\n      nSlice = publicAPI.getSliceAtPosition(model.slice);\n    }\n    switch (ijkMode) {\n      case SlicingMode.I:\n        ex[0] = nSlice;\n        ex[1] = nSlice;\n        break;\n      case SlicingMode.J:\n        ex[2] = nSlice;\n        ex[3] = nSlice;\n        break;\n      case SlicingMode.K:\n        ex[4] = nSlice;\n        ex[5] = nSlice;\n        break;\n    }\n    return image.extentToBounds(ex);\n  };\n  publicAPI.getBoundsForSlice = function () {\n    let slice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : model.slice;\n    let halfThickness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const image = publicAPI.getCurrentImage();\n    if (!image) {\n      return createUninitializedBounds();\n    }\n    const extent = image.getSpatialExtent();\n    const {\n      ijkMode\n    } = publicAPI.getClosestIJKAxis();\n    let nSlice = slice;\n    if (ijkMode !== model.slicingMode) {\n      // If not IJK slicing, get the IJK slice from the XYZ position/slice\n      nSlice = publicAPI.getSliceAtPosition(slice);\n    }\n    switch (ijkMode) {\n      case SlicingMode.I:\n        extent[0] = nSlice - halfThickness;\n        extent[1] = nSlice + halfThickness;\n        break;\n      case SlicingMode.J:\n        extent[2] = nSlice - halfThickness;\n        extent[3] = nSlice + halfThickness;\n        break;\n      case SlicingMode.K:\n        extent[4] = nSlice - halfThickness;\n        extent[5] = nSlice + halfThickness;\n        break;\n    }\n    return image.extentToBounds(extent);\n  };\n  publicAPI.intersectWithLineForPointPicking = (p1, p2) => intersectWithLineForPointPicking(p1, p2, publicAPI);\n  publicAPI.intersectWithLineForCellPicking = (p1, p2) => intersectWithLineForCellPicking(p1, p2, publicAPI);\n  publicAPI.getCurrentImage = () => publicAPI.getInputData();\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  slicingMode: SlicingMode.NONE,\n  closestIJKAxis: {\n    ijkMode: SlicingMode.NONE,\n    flip: false\n  },\n  renderToRectangle: false,\n  sliceAtFocalPoint: false,\n  preferSizeOverAccuracy: false // Whether to use halfFloat representation of float, when it is inaccurate\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  vtkAbstractImageMapper.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['slicingMode']);\n  macro.setGet(publicAPI, model, ['closestIJKAxis', 'renderToRectangle', 'sliceAtFocalPoint', 'preferSizeOverAccuracy']);\n  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);\n\n  // Object methods\n  vtkImageMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageMapper$1 = {\n  newInstance,\n  extend,\n  ...staticOffsetAPI,\n  ...otherStaticMethods,\n  ...Constants\n};\n\nexport { vtkImageMapper$1 as default, extend, newInstance };\n","import { mat4 } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport vtkProp3D from './Prop3D.js';\nimport vtkImageProperty from './ImageProperty.js';\n\nconst {\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageSlice methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageSlice(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageSlice');\n  publicAPI.getActors = () => publicAPI;\n  publicAPI.getImages = () => publicAPI;\n  publicAPI.getIsOpaque = () => {\n    if (model.forceOpaque) {\n      return true;\n    }\n    if (model.forceTranslucent) {\n      return false;\n    }\n    // make sure we have a property\n    if (!model.property) {\n      // force creation of a property\n      publicAPI.getProperty();\n    }\n    let isOpaque = model.property.getOpacity() >= 1.0;\n\n    // are we using an opaque scalar array, if any?\n    isOpaque = isOpaque && (!model.mapper || model.mapper.getIsOpaque());\n    return isOpaque;\n  };\n\n  // Always render during opaque pass, to keep the behavior\n  // predictable and because depth-peeling kills alpha-blending.\n  // In the future, the Renderer should render images in layers,\n  // i.e. where each image will have a layer number assigned to it,\n  // and the Renderer will do the images in their own pass.\n  publicAPI.hasTranslucentPolygonalGeometry = () => false;\n  publicAPI.makeProperty = vtkImageProperty.newInstance;\n  publicAPI.getProperty = () => {\n    if (model.property === null) {\n      model.property = publicAPI.makeProperty();\n    }\n    return model.property;\n  };\n  publicAPI.getBounds = () => {\n    if (model.mapper === null) {\n      return model.bounds;\n    }\n\n    // Check for the special case when the mapper's bounds are unknown\n    const bds = model.mapper.getBounds();\n    if (!bds || bds.length !== 6) {\n      return bds;\n    }\n\n    // Check for the special case when the actor is empty.\n    if (bds[0] > bds[1]) {\n      model.mapperBounds = bds.concat(); // copy the mapper's bounds\n      model.bounds = [1, -1, 1, -1, 1, -1];\n      model.boundsMTime.modified();\n      return bds;\n    }\n\n    // Check if we have cached values for these bounds - we cache the\n    // values returned by model.mapper.getBounds() and we store the time\n    // of caching. If the values returned this time are different, or\n    // the modified time of this class is newer than the cached time,\n    // then we need to rebuild.\n    const zip = rows => rows[0].map((_, c) => rows.map(row => row[c]));\n    if (!model.mapperBounds || !zip([bds, model.mapperBounds]).reduce((a, b) => a && b[0] === b[1], true) || publicAPI.getMTime() > model.boundsMTime.getMTime()) {\n      vtkDebugMacro('Recomputing bounds...');\n      model.mapperBounds = bds.map(x => x);\n      publicAPI.computeMatrix();\n      const tmp4 = new Float64Array(16);\n      mat4.transpose(tmp4, model.matrix);\n      vtkBoundingBox.transformBounds(bds, tmp4, model.bounds);\n      model.boundsMTime.modified();\n    }\n    return model.bounds;\n  };\n  publicAPI.getBoundsForSlice = (slice, thickness) => {\n    // Check for the special case when the mapper's bounds are unknown\n    const bds = model.mapper.getBoundsForSlice(slice, thickness);\n    // Check for the special case when the actor is empty.\n    if (!vtkBoundingBox.isValid(bds)) {\n      return bds;\n    }\n    publicAPI.computeMatrix();\n    const tmp4 = new Float64Array(16);\n    mat4.transpose(tmp4, model.matrix);\n    const newBounds = vtkBoundingBox.transformBounds(bds, tmp4);\n    return newBounds;\n  };\n\n  //----------------------------------------------------------------------------\n  // Get the minimum X bound\n  publicAPI.getMinXBound = () => publicAPI.getBounds()[0];\n\n  // Get the maximum X bound\n  publicAPI.getMaxXBound = () => publicAPI.getBounds()[1];\n\n  // Get the minimum Y bound\n  publicAPI.getMinYBound = () => publicAPI.getBounds()[2];\n\n  // Get the maximum Y bound\n  publicAPI.getMaxYBound = () => publicAPI.getBounds()[3];\n\n  // Get the minimum Z bound\n  publicAPI.getMinZBound = () => publicAPI.getBounds()[4];\n\n  // Get the maximum Z bound\n  publicAPI.getMaxZBound = () => publicAPI.getBounds()[5];\n  publicAPI.getMTime = () => {\n    let mt = model.mtime;\n    if (model.property !== null) {\n      const time = model.property.getMTime();\n      mt = time > mt ? time : mt;\n    }\n    return mt;\n  };\n  publicAPI.getRedrawMTime = () => {\n    let mt = model.mtime;\n    if (model.mapper !== null) {\n      let time = model.mapper.getMTime();\n      mt = time > mt ? time : mt;\n      if (model.mapper.getInput() !== null) {\n        // FIXME !!! getInputAlgorithm / getInput\n        model.mapper.getInputAlgorithm().update();\n        time = model.mapper.getInput().getMTime();\n        mt = time > mt ? time : mt;\n      }\n    }\n    if (model.property !== null) {\n      let time = model.property.getMTime();\n      mt = time > mt ? time : mt;\n      if (model.property.getRGBTransferFunction() !== null) {\n        time = model.property.getRGBTransferFunction().getMTime();\n        mt = time > mt ? time : mt;\n      }\n    }\n    return mt;\n  };\n  publicAPI.getSupportsSelection = () => model.mapper ? model.mapper.getSupportsSelection() : false;\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  mapper: null,\n  property: null,\n  bounds: [...vtkBoundingBox.INIT_BOUNDS]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkProp3D.extend(publicAPI, model, initialValues);\n\n  // vtkTimeStamp\n  model.boundsMTime = {};\n  macro.obj(model.boundsMTime);\n\n  // Build VTK API\n  macro.set(publicAPI, model, ['property']);\n  macro.setGet(publicAPI, model, ['mapper']);\n  macro.getArray(publicAPI, model, ['bounds'], 6);\n\n  // Object methods\n  vtkImageSlice(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageSlice');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageSlice$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageSlice$1 as default, extend, newInstance };\n","import { mat4, vec3 } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport vtkProp3D from './Prop3D.js';\nimport vtkVolumeProperty from './VolumeProperty.js';\n\nconst {\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkVolume methods\n// ----------------------------------------------------------------------------\n\nfunction vtkVolume(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkVolume');\n  publicAPI.getVolumes = () => publicAPI;\n  publicAPI.makeProperty = vtkVolumeProperty.newInstance;\n  publicAPI.getProperty = () => {\n    if (model.property === null) {\n      model.property = publicAPI.makeProperty();\n    }\n    return model.property;\n  };\n  publicAPI.getBounds = () => {\n    if (model.mapper === null) {\n      return model.bounds;\n    }\n\n    // Check for the special case when the mapper's bounds are unknown\n    const bds = model.mapper.getBounds();\n    if (!bds || bds.length !== 6) {\n      return bds;\n    }\n\n    // Check for the special case when the actor is empty.\n    if (bds[0] > bds[1]) {\n      model.mapperBounds = bds.concat(); // copy the mapper's bounds\n      model.bounds = [1, -1, 1, -1, 1, -1];\n      model.boundsMTime.modified();\n      return bds;\n    }\n\n    // Check if we have cached values for these bounds - we cache the\n    // values returned by model.mapper.getBounds() and we store the time\n    // of caching. If the values returned this time are different, or\n    // the modified time of this class is newer than the cached time,\n    // then we need to rebuild.\n    const zip = rows => rows[0].map((_, c) => rows.map(row => row[c]));\n    if (!model.mapperBounds || !zip([bds, model.mapperBounds]).reduce((a, b) => a && b[0] === b[1], true) || publicAPI.getMTime() > model.boundsMTime.getMTime()) {\n      vtkDebugMacro('Recomputing bounds...');\n      model.mapperBounds = bds.map(x => x);\n      const bbox = [];\n      vtkBoundingBox.getCorners(bds, bbox);\n      publicAPI.computeMatrix();\n      const tmp4 = new Float64Array(16);\n      mat4.transpose(tmp4, model.matrix);\n      bbox.forEach(pt => vec3.transformMat4(pt, pt, tmp4));\n\n      /* eslint-disable no-multi-assign */\n      model.bounds[0] = model.bounds[2] = model.bounds[4] = Number.MAX_VALUE;\n      model.bounds[1] = model.bounds[3] = model.bounds[5] = -Number.MAX_VALUE;\n      /* eslint-enable no-multi-assign */\n      model.bounds = model.bounds.map((d, i) => i % 2 === 0 ? bbox.reduce((a, b) => a > b[i / 2] ? b[i / 2] : a, d) : bbox.reduce((a, b) => a < b[(i - 1) / 2] ? b[(i - 1) / 2] : a, d));\n      model.boundsMTime.modified();\n    }\n    return model.bounds;\n  };\n  publicAPI.getMTime = () => {\n    let mt = model.mtime;\n    if (model.property !== null) {\n      const time = model.property.getMTime();\n      mt = time > mt ? time : mt;\n    }\n    return mt;\n  };\n  publicAPI.getRedrawMTime = () => {\n    let mt = model.mtime;\n    if (model.mapper !== null) {\n      let time = model.mapper.getMTime();\n      mt = time > mt ? time : mt;\n      if (model.mapper.getInput() !== null) {\n        // FIXME !!! getInputAlgorithm / getInput\n        model.mapper.getInputAlgorithm().update();\n        time = model.mapper.getInput().getMTime();\n        mt = time > mt ? time : mt;\n      }\n    }\n    return mt;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  mapper: null,\n  property: null,\n  bounds: [1, -1, 1, -1, 1, -1]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkProp3D.extend(publicAPI, model, initialValues);\n\n  // vtkTimeStamp\n  model.boundsMTime = {};\n  macro.obj(model.boundsMTime);\n\n  // Build VTK API\n  macro.set(publicAPI, model, ['property']);\n  macro.setGet(publicAPI, model, ['mapper']);\n  macro.getArray(publicAPI, model, ['bounds'], 6);\n\n  // Object methods\n  vtkVolume(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkVolume');\n\n// ----------------------------------------------------------------------------\n\nvar vtkVolume$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkVolume$1 as default, extend, newInstance };\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    return createProxy(ep, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        ep.addEventListener(\"message\", function l(ev) {\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\n                return;\n            }\n            ep.removeEventListener(\"message\", l);\n            resolve(ev.data);\n        });\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","import ascending from \"./ascending.js\";\nimport descending from \"./descending.js\";\n\nexport default function bisector(f) {\n  let compare1, compare2, delta;\n\n  // If an accessor is specified, promote it to a comparator. In this case we\n  // can test whether the search value is (self-) comparable. We can’t do this\n  // for a comparator (except for specific, known comparators) because we can’t\n  // tell if the comparator is symmetric, and an asymmetric comparator can’t be\n  // used to test whether a single value is comparable.\n  if (f.length !== 2) {\n    compare1 = ascending;\n    compare2 = (d, x) => ascending(f(d), x);\n    delta = (d, x) => f(d) - x;\n  } else {\n    compare1 = f === ascending || f === descending ? f : zero;\n    compare2 = f;\n    delta = f;\n  }\n\n  function left(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function right(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) <= 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function center(a, x, lo = 0, hi = a.length) {\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {left, center, right};\n}\n\nfunction zero() {\n  return 0;\n}\n"],"names":["VideoViewport","frameRangeExtractor","constructor","props","super","canvas","element","videoWidth","videoHeight","loop","mute","isPlaying","scrollSpeed","playbackRate","frameRange","fps","videoCamera","panWorld","parallelScale","voiRange","lower","upper","getProperties","this","videoElement","muted","resetCamera","refreshRenderValues","canvasContext","fillRect","width","height","renderFrame","getNumberOfSlices","computedSlices","Math","round","duration","isNaN","numberOfFrames","getFrameOfReferenceUID","src","resize","clientWidth","clientHeight","canvasToWorld","canvasPos","destPos","pan","worldToCanvasRatio","getWorldToCanvasRatio","panOffsetCanvas","subCanvasPos","splice","worldToCanvas","worldPos","getRotation","canvasToIndex","transform","getTransform","invert","transformPoint","map","it","devicePixelRatio","indexToCanvas","indexPos","customRenderViewportToCanvas","transformationMatrix","getMatrix","ctx","resetTransform","drawImage","actor","getActors","render","triggerEvent","STACK_NEW_IMAGE","viewportId","id","viewport","renderingEngineId","time","currentTime","IMAGE_RENDERED","initialRender","frame","getFrameNumber","setFrameNumber","pause","renderWhilstPlaying","requestAnimationFrame","getContext","setAttribute","document","createElement","autoplay","crossOrigin","addEventListeners","useCustomRenderingPipeline","addEventListener","ELEMENT_DISABLED","elementDisabledHandler","removeEventListeners","removeEventListener","remove","getImageDataMetadata","image","imageId","imagePlaneModule","MetadataModules","IMAGE_PLANE","rowCosines","columnCosines","rowCosineVec","colCosineVec","rows","columns","scanAxisNormal","origin","imagePositionPatient","xSpacing","columnPixelSpacing","ySpacing","rowPixelSpacing","xVoxels","yVoxels","hasPixelSpacing","bitsAllocated","numComps","direction","dimensions","spacing","numVoxels","setDataIds","imageIds","options","setVideo","viewReference","sliceIndex","frameNumber","Array","isArray","imageUrlModule","IMAGE_URL","rendered","Error","generalSeries","GENERAL_SERIES","modality","Modality","metadata","cineRate","CINE","setVideoURL","then","setFrameRange","Promise","resolve","window","setTimeout","videoURL","preload","loadedMetadataEventHandler","getImageIds","baseImageId","replace","i","togglePlayPause","play","e","scroll","delta","newTime","seekEventListener","evt","start","paused","end","setTime","timeInSeconds","length","getFrameRange","setProperties","undefined","setPlaybackRate","setScrollSpeed","setVOI","rate","unit","FRAME","SECOND","resetProperties","getScalarData","scalarData","context","getImageData","data","getRange","imageData","getDirection","getDimensions","getSpacing","worldToIndex","point","canvasPoint","pixelCoord","indexToWorld","destPoint","calibration","preScale","scaled","Object","defineProperty","get","enumerable","hasImageURI","imageURI","framesMatch","match","testURI","substring","index","indexOf","setColorTransform","setWindowLevel","windowWidth","windowCenter","setAverageWhite","averageWhite","feFilter","white","maxWhite","max","scaleWhite","c","wlScale","wlDelta","style","filter","setCamera","camera","focalPoint","focalPointCanvas","canvasCenter","panWorldDelta","fillStyle","getCurrentImageId","getReferenceId","specifier","isReferenceViewable","viewRef","referencedImageId","colonIndex","withNavigation","currentIndex","getSliceIndex","range","split","Number","getViewReference","viewRefSpecifier","getCurrentImageIdIndex","getCamera","parallelProjection","position","viewUp","viewPlaneNormal","getPan","offsetWidth","offsetHeight","drawWidth","floor","drawHeight","xOffsetWorld","yOffsetWorld","getCanvasToWorldRatio","canvasToWorldRatio","halfCanvas","halfCanvasWorldCoordinates","scale","translate","updateCameraClippingPlanesAndRange","addImages","stackInputs","actors","forEach","stackInput","getImage","imageActor","createActorMapper","push","uid","actorUID","callback","setActors","async","renderingEngine","viewportIds","getViewport","console","warn","addStackPromises","all","volumeInputs","immediateRender","suppressEvents","addVolumePromises","addVolumes","COLOR_TRANSPARENT","getRank","array","elem","left","right","mid","midElem","makeMappingArray","N","gamma","x","y0","y1","lut","xLinSpace","a","b","n","increment","vector","linspace","pow","xLinSpaceIndexes","inputArray","values","indexes","len","sort","searchSorted","colorPercent","colorDelta","getColormap","colormapData","colormap","name","colors","segmentedData","redLut","red","greenLut","green","blueLut","blue","rgba","createLinearSegmentedColormap","numColors","getId","getColorSchemeName","setColorSchemeName","getNumberOfColors","setNumberOfColors","getColor","isValidIndex","getColorRepeating","setColor","addColor","insertColor","removeColor","clearColors","buildLookupTable","setNumberOfTableValues","setTableValue","createLookupTable","enabledElement","invalidated","stats","lastGetPixelDataTime","lastStoredPixelDataToCanvasImageDataTime","lastPutImageDataTime","lastRenderTime","lastLutGenerateTime","color","renderTimeInMs","invalid","needsRedraw","displayedArea","angle","rotation","rotate","PI","widthScale","heightScale","brhc","tlhc","y","presentationSizeMode","verticalScale","horizontalScale","min","translation","hflip","vflip","pt","shift","viewportOrientation","cosA","cos","sinA","sin","newX","newY","scaleFactor","voi","isPreScaled","pixelReplication","modalityLUT","voiLUT","imageSize","verticalRatio","horizontalRatio","isRotated","resetPan","resetZoom","forceFitToWindow","oldCanvasWidth","oldCanvasHeight","setCanvasSize","getImageSize","imageWidth","imageHeight","wasFitToWindow","getImageFitScale","fitToWindow","relWidthChange","relHeightChange","relChange","sqrt","relativeRescale","useNativeDataType","volumeId","blendMode","imageVolume","loadVolume","vtkOpenGLTexture","volumeMapper","setBlendMode","volumeActor","setMapper","getPointData","getScalars","getNumberOfComponents","getProperty","setIndependentComponents","getRGBTransferFunction","voiModifiedEventDetail","Events","VOI_MODIFIED","triggerVOIModified","REQUEST_TYPE","RequestType","Prefetch","voiLutModule","voiLut","windowLevel","getVOIFromMetadata","imageIdIndex","generalSeriesModule","modalityLutModule","numImages","bytesPerImage","byteLength","voxelsPerImage","bytePerPixel","BYTES_PER_ELEMENT","scalingParameters","rescaleSlope","rescaleIntercept","scalingParametersToUse","suvFactor","suvbw","byteOffset","targetBuffer","type","priority","requestType","enabled","referencedImageIds","loadAndCacheImage","ignoreCache","imageScalarData","getPixelData","buffer","TypedArray","volumeBufferView","set","_getImageScalarDataFromImageVolume","getMinMax","getVOIFromMinMax","scaling","PT","_isCurrentImagePTPrescaled","handlePreScaledVolume","setMappingRange","DEFAULT_VALUES","scalarTexture","extend","publicAPI","model","initialValues","assign","classHierarchy","superDelete","delete","vtkSharedVolumeMapper","newInstance","DEFAULT_SETTINGS","Symbol","RUNTIME_SETTINGS","OBJECT_SETTINGS_MAP","DICTIONARY","Settings","base","dictionary","create","seal","value","key","unset","endsWith","deleteCount","namespace","slice","deleteAll","prototype","hasOwnProperty","call","startsWith","iterate","import","root","isPlainObject","keys","dump","deepSet","assert","subject","getRuntimeSettings","getDefaultSettings","subfield","defaultSettings","settingObj","setting","runtimeSettings","getObjectSettings","from","settings","objectSettingsMap","WeakMap","extendRuntimeSettings","references","last","current","previous","isValidKey","prefix","record","failCount","has","add","field","setAll","WeakSet","getPrototypeOf","separator","subKey","subContext","subContextValue","ONE_GB","_imageCache","Map","_volumeCache","_imageCacheSize","_volumeCacheSize","_maxCacheSize","_maxInstanceSize","setMaxCacheSize","newMaxCacheSize","errorMessage","isCacheable","getBytesAvailable","getMaxCacheSize","getMaxInstanceSize","getCacheSize","_decacheImage","imageLoadObject","cancelFn","decache","_decacheVolume","cachedVolume","volumeLoadObject","volume","cancelLoading","_restoreImagesFromBuffer","purgeCache","imageIterator","done","next","removeImageLoadObject","IMAGE_CACHE_IMAGE_REMOVED","purgeVolumeCache","volumeIterator","removeVolumeLoadObject","VOLUME_CACHE_VOLUME_REMOVED","getVolumeLoadObject","timeStamp","Date","now","getGeometry","geometryId","cachedGeometry","_geometryCache","geometry","cachedImage","getVolume","getVolumes","filterVolumesByReferenceId","referencedVolumeId","incrementImageCacheSize","sizeInBytes","eventDetails","incrementVolumeCacheSize","putGeometryLoadObject","geometryLoadObject","loaded","promise","GEOMETRY_CACHE_GEOMETRY_ADDED","catch","error","decrementImageCacheSize","decrement","decrementVolumeCacheSize","decacheIfNecessaryUntilBytesAvailable","numBytes","volumeImageIds","bytesAvailable","cachedImages","cachedImageIds","im","imageIdsToPurge","includes","putImageLoadObject","sharedCacheKey","toFixed","CACHE_SIZE_EXCEEDED","IMAGE_CACHE_IMAGE_ADDED","getImageLoadObject","isLoaded","getVolumeContainingImageId","volumeIds","imageIdToUse","imageIdToURI","getImageURIIndex","getCachedImageBasedOnImageURI","imageURIToUse","foundImageId","find","putVolumeLoadObject","VOLUME_CACHE_VOLUME_ADDED","imageCacheOffsetMap","size","offset","viewPixelData","pixelData","imageFrame","bufferView","log","RENDERING_DEFAULTS","MINIMUM_SLAB_THICKNESS","MAXIMUM_RAY_DISTANCE","freeze","ViewportStatus","BlendMode","BlendModes","COMPOSITE_BLEND","MAXIMUM_INTENSITY_BLEND","MINIMUM_INTENSITY_BLEND","AVERAGE_INTENSITY_BLEND","GeometryType","DynamicOperatorType","CalibrationTypes","getEnabledElement","viewportUid","renderingEngineUid","dataset","getEnabledElementByIds","hasBeenDestroyed","FrameOfReferenceUID","getEnabledElementByViewportId","renderingEngines","getEnabledElements","enabledElements","getViewports","imageLoaders","unknownImageLoader","loadImageFromImageLoader","scheme","loader","IMAGE_LOADED","errorObject","IMAGE_LOAD_FAILED","loadImageFromCacheOrVolume","cachedVolumeInfo","loadStatus","convertToCornerstoneImage","loadImage","err","loadAndCacheImages","createAndCacheDerivedImage","preventCache","uuidv4","skipCreateBuffer","onCacheAdd","metaData","TypedArrayConstructor","getBufferConfiguration","targetBufferType","derivedImageId","genericMetadataProvider","imagePixelModule","bitsStored","highBit","samplesPerPixel","pixelRepresentation","localImage","createAndCacheLocalImage","createAndCacheDerivedImages","derivedImageIds","allPromises","newOptions","getDerivedImageId","promises","intercept","slope","minPixelValue","maxPixelValue","voiLUTFunction","getCanvas","Uint8Array","Float32Array","Uint16Array","Int16Array","cancelLoadImage","filterRequests","additionalDetails","cancelLoadImages","cancelLoadAll","requestPool","getRequestPool","requests","pop","loadObject","cancel","clearRequestStack","registerImageLoader","imageLoader","registerUnknownImageLoader","oldImageLoader","unregisterAllImageLoaders","createAndCacheDerivedSegmentationImages","createAndCacheDerivedSegmentationImage","createInternalVTKRepresentation","PhotometricInterpretation","numComponents","dataArrayAttrs","numberOfComponents","setDimensions","setSpacing","setDirection","setOrigin","isDynamicVolume","scalarDataArrays","vtkScalarArray","addArray","setActiveScalars","addScalarDataArraysToImageData","getScalarDataArrays","scalarArray","setScalars","addScalarDataToImageData","volumeLoaders","unknownVolumeLoader","loadVolumeFromVolumeLoader","setupCacheOptimizationEventListener","VOLUME_LOADED","VOLUME_LOADED_FAILED","createAndCacheVolume","createAndCacheDerivedVolume","referencedVolume","scalarLength","volumeScalarData","generateVolumeScalarData","derivedImageData","derivedVolume","createLocalVolume","validDataTypes","createAndCacheVolumeFromImages","volumeProps","generateVolumePropsFromImageIds","imagePromises","performCacheOptimizationForVolume","registerVolumeLoader","volumeLoader","getVolumeLoaderSchemes","registerUnknownVolumeLoader","oldVolumeLoader","getUnknownVolumeLoaderSchema","createAndCacheDerivedSegmentationVolume","createLocalSegmentationVolume","useNorm16Texture","rendering","use16BitTexture","isVolumeBuffer","sharedArrayBuffer","createFloat32SharedArray","createUint8SharedArray","createUint16SharedArray","imageLoadPoolManager","grabDelay","setMaxSimultaneousRequests","Interaction","Thumbnail","RequestPoolManager","numRequests","interaction","thumbnail","prefetch","compute","awake","maxNumRequests","getMaxSimultaneousRequests","destroy","timeoutHandle","clearTimeout","addRequest","requestFn","requestDetails","startGrabbing","filterFunction","sendRequests","requestsToSend","syncImageCount","getNextRequest","requestResult","finally","startAgain","interactionPriorities","getSortedPriorityGroups","hasRemainingInteractionRequests","hasRemainingThumbnailRequests","hasRemainingPrefetchRequests","hasRemainingComputeRequests","Compute","enableCacheOptimization","shouldUseSAB","addEventListenerOnce","IMAGE_VOLUME_LOADING_COMPLETED","detail","_updateImageWithScalarDataView","_processImageCacheOffsetMap","compatibleScalarData","sampleImageIdWithImage","sampleImage","samplePixelData","getImageIdIndex","_processVolumeImages","view","_colormaps","registerColormap","Name","getColormapNames","findMatchingColormap","rgbPoints","colormapsVTK","rgbPresetNames","presetName","getPresetByName","colormapsCS3D","colormapName","matchedColormap","concat","RGBPoints","presetRGBPoints","opacity","opacityPoints","getScalarOpacity","getDataPointer","createLinearRGBTransferFunction","cfun","addRGBPoint","spacingInNormalDirection","actorEntry","referenceId","sliceRange","numberOfSlices","imageIndex","getTransferFunctionNodes","transferFunction","getSize","nodeValue1","getNodeValue","setTransferFunctionNodes","nodes","removeAllPoints","node","transformWorldToIndex","el","event","CustomEvent","cancelable","dispatchEvent","workerRegistry","workerPoolManager","registerWorker","workerName","workerFn","maxWorkerInstances","overwrite","autoTerminateOnIdle","idleTimeThreshold","idleCheckIntervalId","clearInterval","workerProperties","instances","loadCounters","lastActiveTime","nativeWorkers","fill","worker","getNextWorkerAPI","workerInstances","instance","minLoadIndex","minLoadValue","currentLoadValue","api","executeTask","methodName","args","callbacks","reject","finalCallbacks","cb","processing","results","setInterval","terminateIdleWorkers","_","terminateWorkerInstance","terminate","workerInstance","BASE","iconContent","iconSize","viewBox","mousePoint","mousePointerGroupString","SEGMENTATION_CURSOR_BOUNDARIES","MINUS_RECT","PLUS_RECT","SCISSOR_ICON","RECTANGLE_ICON","CIRCLE_ICON","CursorSVG","Angle","ArrowAnnotate","Bidirectional","CobbAngle","CircleROI","EllipticalROI","FreehandROI","FreehandROISculptor","Length","Probe","RectangleROI","TextMarker","Crosshairs","Eraser","Magnify","Pan","Rotate","StackScroll","WindowLevelRegion","WindowLevel","Zoom","SegmentationFreeHandEraseInside","SegmentationFreeHandFillInside","SegmentationFreeHandEraseOutside","SegmentationFreeHandFillOutside","SegmentationRectangleEraseInside","RectangleScissor","CircleScissor","getDefinedSVGCursorDescriptor","svgCursorNames","VIEWPORT_ELEMENT","getSvgNode","canvasHash","cacheKey","svgNodeCache","domRef","appendNode","svgLayerElement","svgNode","touched","appendChild","setNodeTouched","clearUntouched","cacheEntry","removeChild","viewportElement","internalDivElement","querySelector","_getSvgLayer","svgNodeCacheForCanvas","bind","fn","svgDrawingHelper","ToolModes","Active","Passive","Enabled","Disabled","PRIMARY_BINDINGS","mouseButton","MouseBindings","Primary","ToolGroup","viewportsInfo","toolOptions","currentActivePrimaryToolName","prevActivePrimaryToolName","restoreToolOptions","_toolInstances","getViewportIds","getViewportsInfo","getToolInstance","toolInstanceName","toolInstance","getToolInstances","hasTool","toolName","addTool","configuration","toolDefinition","tools","hasToolName","localToolInstance","toolClass","ToolClass","instantiatedTool","toolGroupId","addToolInstance","parentClassName","ToolClassToUse","ParentClass","ToolInstance","addViewport","getRenderingEngines","renderingEngineUIDToUse","some","vpId","getActivePrimaryMouseButtonTool","setViewportsCursorByToolName","eventDetail","eventTarget","TOOLGROUP_VIEWPORT_ADDED","removeViewports","indices","vpInfo","TOOLGROUP_VIEWPORT_REMOVED","setActiveStrategy","strategyName","setToolMode","mode","setToolDisabled","setToolEnabled","setToolPassive","setToolActive","toolBindingsOptions","bindings","reduce","unique","binding","TouchBinding","numTouchPoints","MouseBinding","obj","hasSameBinding","useCursor","_hasMousePrimaryButtonBinding","cursor","MouseCursor","getDefinedCursor","_setCursorForViewports","onSetToolActive","_renderViewports","TOOL_ACTIVATED","_triggerToolModeChangedEvent","prevToolOptions","getToolOptions","matchBindings","removeAllBindings","getDefaultPrimaryBindings","matchBinding","onSetToolPassive","onSetToolEnabled","onSetToolDisabled","toolOptionsForTool","_getCursor","cursorName","SVGMouseCursor","initElementCursor","setToolConfiguration","_configuration","onSetToolConfiguration","getDefaultMousePrimary","getToolConfiguration","configurationPath","getPrevActivePrimaryToolName","clone","newToolGroupId","fnToolFilter","toolGroup","sourceToolInstance","sourceToolOptions","sourceToolMode","primaryBindings","primary","getRenderingEngine","renderViewport","TOOL_MODE_CHANGED","binding1","binding2","modifierKey","toolGroups","tg","toolGroupIndex","findIndex","removeToolGroup","removeSegmentationsFromToolGroup","s","MODES","toolGroupToolNames","BidirectionalTool","toolProps","defaultToolProps","supportedInteractionTypes","preventHandleOutsideImage","getTextLines","defaultGetTextLines","isPointNearTool","annotation","canvasCoords","proximity","points","handles","canvasPoint1","canvasPoint2","line","distanceToPoint","toolSelectedCallback","highlighted","viewportIdsToRender","getViewportIdsWithToolToRender","getToolName","editData","movingTextBox","_activateModify","hideElementCursor","preventDefault","handleSelectedCallback","handle","handleIndex","worldPosition","p","_endCallback","newAnnotation","hasMoved","activeHandleIndex","_deactivateModify","_deactivateDraw","resetElementCursor","firstLineSegmentLength","longAxis","shortAxisPoint0","shortAxisPoint1","longAxisVector","counterClockWisePerpendicularToLongAxis","currentShortAxisVector","shortAxis","isHandleOutsideImage","removeAnnotation","annotationUID","isDrawing","_dragDrawCallback","currentPoints","world","canvasCoordPoints","shortAxisDistFromCenter","dx","dy","vectorX","vectorY","xMid","yMid","startX","startY","endX","endY","_dragModifyCallback","deltaPoints","worldPosDelta","textBox","_dragModifyHandle","movingHandleIndex","canvasCoordHandlesCurrent","firstLineSegment","secondLineSegment","proposedPoint","proposedCanvasCoord","fixedHandleCanvasCoord","fixedHandleToProposedCoordVec","fixedHandleToOldCoordVec","proposedFirstLineSegment","_movingLongAxisWouldPutItThroughShortAxis","centerOfRotation","_getSignedAngle","firstPointX","firstPointY","secondPointX","secondPointY","rotatedFirstPoint","rotatedFirstPointY","rotatedSecondPoint","rotatedSecondPointY","newFirstPoint","newSecondPoint","translateHandleIndex","canvasCoordsCurrent","longLineSegment","shortLineSegment","longLineSegmentVec","longLineSegmentVecNormalized","proposedToCurrentVec","movementLength","movementAlongLineSegmentLength","newTranslatedPoint","_activateDraw","isInteractingWithTool","MOUSE_UP","MOUSE_DRAG","MOUSE_MOVE","MOUSE_CLICK","TOUCH_TAP","TOUCH_END","TOUCH_DRAG","renderAnnotation","renderStatus","annotations","getAnnotations","filterInteractableAnnotationsForElement","targetId","getTargetId","styleSpecifier","canvasCoordinates","lineWidth","lineDash","shadow","getAnnotationStyle","cachedStats","_throttledCalculateCachedStats","_calculateCachedStats","activeHandleCanvasCoords","isAnnotationVisible","isAnnotationLocked","handleGroupUID","drawHandles","dataId1","dataId2","lineUID","drawLine","secondLineUID","getLinkedTextBoxStyle","visibility","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","textLines","canvasTextBoxCoords","getTextBoxCoordsCanvas","textBoxPosition","textBoxUID","boundingBox","drawLinkedTextBox","top","vectorInSecondLineDirection","extendedSecondLineSegment","worldPos1","worldPos2","worldPos3","worldPos4","targetIds","getTargetIdImage","index1","index2","index3","index4","handles1","handles2","scale1","units","units1","scale2","units2","dist1","_calculateLength","dist2","lengthUnit","widthUnit","_isInsideVolume","vector1","vector2","atan2","trailing","addNewAnnotation","getReferencedImageId","label","addAnnotation","pos1","pos2","dz","roundNumber","pointCanProjectOnLine","polyline","EPSILON","CONSTANTS","PARALLEL_THRESHOLD","PlanarFreehandROITool","contourHoleAdditionModifierKey","KeyboardBindings","Shift","alwaysRenderOpenContourHandles","radius","allowOpenContours","closeContourProximity","checkCanvasEditFallbackProximity","makeClockWise","subPixelResolution","smoothing","smoothOnAdd","smoothOnEdit","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","interpolation","onInterpolationComplete","decimate","epsilon","displayOnePointAsCrosshairs","calculateStats","statsCalculator","BasicStatsCalculator","isEditingClosed","isEditingOpen","createAnnotation","activateDraw","activateOpenContourEndEdit","contour","closed","activateClosedContourEdit","activateOpenContourEdit","previousPoint","p1","p2","pStart","pEnd","cancelDrawing","cancelOpenContourEdit","cancelClosedContourEdit","originalWorldPoint","deltaXPoint","deltaYPoint","deltaInX","deltaInY","worldPosIndex","iMin","iMax","jMin","jMax","kMin","kMax","j","worldPosIndex2","areaUnits","numPoints","projectedPolyline","maxX","canvasMaxX","maxY","canvasMaxY","minX","canvasMinX","minY","canvasMinY","math","topLeftBBWorld","topLeftBBIndex","bottomRightBBWorld","area","iDelta","jDelta","kDelta","ceil","boundsIJK","worldPosEnd","canvasPosEnd","curRow","intersections","intersectionCounter","pointsInShape","pointLPS","pointIJK","result","getLineSegmentIntersectionsCoordinates","statsCallback","modalityUnitOptions","isSuvScaled","modalityUnit","getStatistics","perimeter","mean","stdDev","statsArray","areaUnit","ChangeTypes","StatsUpdated","_renderStats","annotationsToDisplay","VolumeViewport","filterAnnotationsWithinSlice","filterAnnotationsForDisplay","annotationsWithParallelNormals","td","annotationViewPlaneNormal","isParallel","abs","halfSpacingInNormalDirection","annotationsWithinSlice","isVisible","dir","dot","isContourSegmentationTool","contourAnnotation","renderAnnotationInstance","renderContext","activeAnnotationUID","commonData","renderContourBeingDrawn","renderClosedContourBeingEdited","renderOpenContourBeingEdited","renderPointContourWithMarker","renderContour","_calculateStatsIfActive","cachedVolumeStats","isEmptyArea","areaLine","isFinite","planarContourToolName","SegmentationDisplayTool","renderSegmentation","getToolGroup","toolGroupSegmentationRepresentations","getSegmentationRepresentations","toolGroupViewports","segmentationRenderList","representation","config","_getMergedRepresentationsConfig","viewportsRenderList","renderers","Labelmap","Contour","Surface","addPlanarFreeHandToolIfAbsent","display","renderedViewport","allSettled","segmentationRepresentation","setSegmentationVisibility","segmentationRepresentationUID","toolGroupConfig","globalConfig","RectangleROIThresholdTool","RectangleROITool","StackViewport","cache","segmentationId","triggerAnnotationRenderForViewportIds","getStyle","rectangleUID","drawRect","RectangleROIStartEndThresholdTool","numSlicesToPropagate","computePointsInsideVolume","startIndex","spacingInNormal","endIndex","_getEndSliceIndex","startSlice","endSlice","pointsInVolume","projectionPoints","projectionPointsImageIds","labelmapUID","_computeProjectionPoints","calculatePointsInsideVolume","_computePointsInsideVolume","firstOrLastSlice","lineDashToUse","throttle","_calculateCachedStatsTool","startIJK","endIJK","startWorld","indexToWorldVec3","endWorld","distance","newProjectionPoints","dist","newPoint","RectanglePoints","pointsInsideVolume","projectionPoint","worldPos1Index","worldProjectionPointIndex","worldPos2Index","pointInShapeCallback","endPos","utilities","vtkErrorMacro","m","clamping","allowDuplicateScalars","arguments","setGet","setArray","getArray","getType","prevValue","functionType","function","getFirstNonZeroValue","allZero","MAX_VALUE","val","midpoint","sharpness","setNodeValue","oldX","sortAndUpdateRange","modified","addPoint","addPointLong","removePoint","setNodes","updateRange","oldRange","retVal","modifiedInvoked","addSegment","x1","x2","y2","getValue","table","getTable","adjustRange","functionRange","estimateMinNumberOfSamples","d","findMinimumXDistance","currentDist","xStart","xEnd","stride","idx","numNodes","lastValue","tidx","ss","sss","h1","h2","h3","h4","t","vtkPiecewiseFunction","vtkPiecewiseFunction$1","vtkDebugMacro","directionOfProjection","useHorizontalViewAngle","viewAngle","clippingRange","useOffAxisProjection","screenBottomLeft","screenBottomRight","screenTopRight","freezeFocalPoint","projectionMatrix","viewMatrix","cameraLightTransform","physicalTranslation","physicalScale","physicalViewUp","physicalViewNorth","setGetArray","Float64Array","dopbasis","upbasis","tmpMatrix","tmpMatrix2","tmpvec1","tmpvec2","tmpvec3","rotateMatrix","trans","newPosition","newFocalPoint","computeViewPlaneNormal","orthogonalizeViewUp","vt","getViewMatrix","setPosition","z","computeDistance","setFocalPoint","setDistance","vec","dolly","amount","roll","eye","at","up","viewUpVec4","viewDir","r","azimuth","fp","yaw","elevation","axis","pitch","zoom","factor","applyTransform","transformMat4","vuOld","posNew","fpNew","vuNew","setViewUp","getThickness","setThickness","thickness","setClippingRange","setThicknessFromFocalPoint","setRoll","getRoll","setObliqueAngles","alpha","beta","getOrientation","getOrientationWXYZ","getFrustumPlanes","aspect","getCameraLightTransformMatrix","matrix","computeCameraLightTransform","deepCopy","sourceCamera","physicalOrientationToWorldDirection","ori","oriq","coriq","qdir","getPhysicalToWorldMatrix","getWorldToPhysicalMatrix","physVRight","computeViewParametersFromViewMatrix","vmat","oldDist","setDirectionOfProjection","computeViewParametersFromPhysicalMatrix","mat","setViewMatrix","setProjectionMatrix","getProjectionMatrix","nearz","farz","cWidth","cRange","xmin","xmax","ymin","ymax","tmp","tan","znear","zfar","getCompositeProjectionMatrix","vMat","pMat","setDeviceAngles","screen","rotmat","dop","vup","setOrientationWXYZ","degrees","quatMat","q","newdop","newvup","computeClippingRange","bounds","vn","k","vtkCamera","vtkCamera$1","ColorSpace","Scale","ScalarMappingTarget","vtkWarningMacro","vtkColorTransferFunctionLabToMsh","lab","msh","L","M","acos","h","vtkColorTransferFunctionAdjustHue","unsatM","hueSpin","vtkColorTransferFunctionInterpolateDiverging","rgb1","rgb2","lab1","lab2","msh1","msh2","localS","a1","a2","adiff","vtkColorTransferFunctionAngleDiff","Mmid","mshTmp","labTmp","vtkColorTransferFunctionMshToLab","colorSpace","RGB","hSVWrap","LINEAR","nanColor","belowRangeColor","aboveRangeColor","useAboveRangeColor","useBelowRangeColor","tableSize","buildTime","discretize","numberOfValues","g","addRGBPointLong","addHSVPoint","v","addHSVPointLong","rgb","hsv","before","JSON","stringify","after","mappingRange","movePoint","addRGBSegment","r1","g1","b1","r2","g2","b2","addHSVSegment","s1","v1","s2","v2","hsv1","hsv2","mapValue","indexedLookup","getAnnotatedValueIndexInternal","getNanColorByReference","nodeVal","getRedValue","getGreenValue","getBlueValue","xStart_","xEnd_","lastR","lastG","lastB","tmpVec","usingLogScale","LOG10","logStart","logEnd","logX","log10","deltaRange","xn","discretizeIndex","getUseAboveRangeColor","getUseBelowRangeColor","HSV","hsvTmp","LAB","DIVERGING","getUint8Table","withAlpha","getMTime","tableWithAlpha","nbChannels","tmpTable","buildFunctionFromArray","getNumberOfTuples","getComponent","buildFunctionFromTable","inc","getNumberOfAvailableColors","getIndexedColor","nodeValue","fillFromDataPointer","nb","ptr","originalRange","mapScalarsThroughTable","input","output","outFormat","inputOffset","mapDataIndexed","mapData","getAlpha","inIncr","outputV","getData","inputV","RGBA","LUMINANCE","LUMINANCE_ALPHA","applyColorMap","colorMap","oldColorSpace","toUpperCase","isModified","oldNanColor","NanColor","oldNodes","callModified","vtkColorTransferFunction","vtkColorTransferFunction$1","presetMap","vtkColorMaps","addPreset","preset","removePresetByName","staticOffsetAPI","otherStaticMethods","SlicingMode","slicingMode","NONE","closestIJKAxis","ijkMode","flip","renderToRectangle","sliceAtFocalPoint","preferSizeOverAccuracy","implementCoincidentTopologyMethods","computeClosestIJKAxis","xyzMode","X","Y","Z","getCurrentImage","newMatrix","getSliceAtPosition","pos","pos3","bds","getBounds","ijk","ex","getExtent","getClosestIJKAxis","I","J","K","setSliceFromCamera","cam","getFocalPoint","setSlice","setXSlice","setSlicingMode","setYSlice","setZSlice","setISlice","setJSlice","setKSlice","getSlicingModeNormal","out","mat3","useCustomExtents","customDisplayExtent","nSlice","extentToBounds","getBoundsForSlice","halfThickness","extent","getSpatialExtent","intersectWithLineForPointPicking","intersectWithLineForCellPicking","getInputData","vtkImageMapper","vtkImageMapper$1","mapper","property","INIT_BOUNDS","boundsMTime","getImages","getIsOpaque","forceOpaque","forceTranslucent","isOpaque","getOpacity","hasTranslucentPolygonalGeometry","makeProperty","mapperBounds","row","computeMatrix","tmp4","getMinXBound","getMaxXBound","getMinYBound","getMaxYBound","getMinZBound","getMaxZBound","mt","mtime","getRedrawMTime","getInput","getInputAlgorithm","update","getSupportsSelection","vtkImageSlice","vtkImageSlice$1","bbox","vtkVolume","vtkVolume$1","HASH_UNDEFINED","funcTag","genTag","reIsDeepProp","reIsPlainProp","reLeadingDot","rePropName","reEscapeChar","reIsHostCtor","freeGlobal","freeSelf","self","Function","arrayProto","funcProto","objectProto","coreJsData","maskSrcKey","exec","IE_PROTO","funcToString","toString","objectToString","reIsNative","RegExp","getNative","nativeCreate","symbolProto","symbolToString","Hash","entries","clear","entry","ListCache","MapCache","assocIndexOf","other","baseGet","object","path","isSymbol","test","isKey","stringToPath","toKey","baseIsNative","isObject","func","pattern","tag","isFunction","isHostObject","toSource","getMapData","__data__","memoize","string","baseToString","number","quote","resolver","TypeError","memoized","apply","Cache","isObjectLike","module","exports","defaultValue","proxyMarker","createEndpoint","releaseProxy","finalizer","throwMarker","transferHandlers","canHandle","serialize","port1","port2","MessageChannel","expose","deserialize","port","wrap","serialized","isError","message","stack","ep","globalThis","allowedOrigins","ev","allowedOrigin","isAllowedOrigin","argumentList","fromWireValue","returnValue","parent","prop","rawValue","proxy","transfers","transferCache","transfer","wireValue","transferables","toWireValue","postMessage","closeEndPoint","endpoint","isMessagePort","close","target","createProxy","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","proxyFinalizers","FinalizationRegistry","newCount","isProxyReleased","Proxy","_target","unregister","unregisterProxy","_thisArg","rawArgumentList","processArguments","construct","register","registerProxy","processed","arr","handler","serializedValue","msg","random","MAX_SAFE_INTEGER","join","l","bisector","f","compare1","compare2","lo","hi","zero","center"],"sourceRoot":""}