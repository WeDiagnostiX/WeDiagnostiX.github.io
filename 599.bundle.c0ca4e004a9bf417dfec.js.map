{"version":3,"file":"599.bundle.c0ca4e004a9bf417dfec.js","mappings":"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","sources":["webpack:///../../../extensions/default/src/DicomWebDataSource/qido.js","webpack:///../../../extensions/default/src/DicomWebDataSource/utils/getImageId.js","webpack:///../../../extensions/default/src/DicomWebDataSource/utils/getWADORSImageId.js","webpack:///../../../extensions/default/src/DicomWebDataSource/wado/retrieveMetadataLoader.js","webpack:///../../../extensions/default/src/DicomWebDataSource/wado/retrieveMetadataLoaderSync.js","webpack:///../../../extensions/default/src/DicomWebDataSource/wado/retrieveMetadataLoaderAsync.js","webpack:///../../../extensions/default/src/DicomWebDataSource/wado/retrieveMetadata.js","webpack:///../../../extensions/default/src/DicomWebDataSource/retrieveStudyMetadata.js","webpack:///../../../extensions/default/src/DicomWebDataSource/utils/StaticWadoClient.ts","webpack:///../../../extensions/default/src/utils/getDirectURL.js","webpack:///../../../extensions/default/src/DicomWebDataSource/utils/fixBulkDataURI.ts","webpack:///../../../extensions/default/src/DicomWebDataSource/index.js","webpack:///../../../extensions/default/src/DicomWebDataSource/dcm4cheeReject.js","webpack:///../../../extensions/default/src/DicomJSONDataSource/index.js","webpack:///../../../extensions/default/src/DicomLocalDataSource/index.js","webpack:///../../../extensions/default/src/DicomWebProxyDataSource/index.js","webpack:///../../../extensions/default/src/getDataSourcesModule.js","webpack:///../../../extensions/default/src/Toolbar/Toolbar.tsx","webpack:///../../../extensions/default/src/ViewerLayout/index.tsx","webpack:///../../../extensions/default/src/Panels/PanelStudyBrowser.tsx","webpack:///../../../extensions/default/src/Panels/getImageSrcFromImageId.js","webpack:///../../../extensions/default/src/Panels/getStudiesForPatientByMRN.js","webpack:///../../../extensions/default/src/Panels/requestDisplaySetCreationForStudy.js","webpack:///../../../extensions/default/src/Panels/WrappedPanelStudyBrowser.tsx","webpack:///../../../extensions/default/src/Panels/ActionButtons.tsx","webpack:///../../../extensions/default/src/Panels/createReportDialogPrompt.tsx","webpack:///../../../extensions/default/src/Actions/createReportAsync.tsx","webpack:///../../../extensions/default/src/utils/getNextSRSeriesNumber.js","webpack:///../../../extensions/default/src/utils/findSRWithSameSeriesDescription.ts","webpack:///../../../extensions/default/src/Panels/PanelMeasurementTable.tsx","webpack:///../../../extensions/default/src/Panels/Edition3DUtils/extractCellGroupsFromPolydata.js","webpack:///../../../extensions/default/src/Panels/Edition3DUtils/quadricDecimation.js","webpack:///../../../extensions/default/src/Panels/Edition3DUtils/ImageMarchingCubes.js","webpack:///../../../extensions/default/src/Panels/Edition3DPanel.tsx","webpack:///../../../extensions/default/src/Panels/PanoramicUtils/dcmbufferToPng.js","webpack:///../../../extensions/default/src/Panels/PanoramicUtils/computeDentalCurveUtils.js","webpack:///../../../extensions/default/src/Panels/PanoramicGenerationPanel.tsx","webpack:///../../../extensions/default/src/Panels/PanoramicUtils/computePanoramicUtils.js","webpack:///../../../extensions/default/src/getPanelModule.tsx","webpack:///../../../extensions/default/src/id.js","webpack:///../../../extensions/default/src/getSopClassHandlerModule.js","webpack:///../../../extensions/default/src/Toolbar/ToolbarDivider.tsx","webpack:///../../../extensions/default/src/Toolbar/ToolbarLayoutSelector.tsx","webpack:///../../../extensions/default/src/Toolbar/ToolbarSplitButton.tsx","webpack:///../../../extensions/default/src/CustomizableContextMenu/ContextMenuItemsBuilder.ts","webpack:///../../../extensions/default/src/CustomizableContextMenu/ContextMenuController.tsx","webpack:///../../../extensions/default/src/CustomizableContextMenu/defaultContextMenu.ts","webpack:///../../../extensions/default/src/DicomTagBrowser/DicomTagTable.tsx","webpack:///../../../extensions/default/src/DicomTagBrowser/DicomTagBrowser.tsx","webpack:///../../../extensions/default/src/utils/reuseCachedLayouts.ts","webpack:///../../../extensions/default/src/findViewportsByPosition.ts","webpack:///../../../extensions/default/src/commandsModule.ts","webpack:///../../../extensions/default/src/hpMNGrid.ts","webpack:///../../../extensions/default/src/getHangingProtocolModule.js","webpack:///../../../extensions/default/src/Panels/DataSourceSelector.tsx","webpack:///../../../extensions/default/src/getPTImageIdInstanceMetadata.ts","webpack:///../../../extensions/default/src/init.ts","webpack:///../../../extensions/default/src/index.ts","webpack:///../../../extensions/default/src/getLayoutTemplateModule.js","webpack:///../../../extensions/default/src/getToolbarModule.tsx","webpack:///../../../extensions/default/src/getCustomizationModule.tsx"],"sourcesContent":["/**\n * QIDO - Query based on ID for DICOM Objects\n * search for studies, series and instances by patient ID, and receive their\n * unique identifiers for further usage.\n *\n * Quick: https://www.dicomstandard.org/dicomweb/query-qido-rs/\n * Standard: http://dicom.nema.org/medical/dicom/current/output/html/part18.html#sect_10.6\n *\n * Routes:\n * ==========\n * /studies?\n * /studies/{studyInstanceUid}/series?\n * /studies/{studyInstanceUid}/series/{seriesInstanceUid}/instances?\n *\n * Query Parameters:\n * ================\n * | KEY              | VALUE              |\n * |------------------|--------------------|\n * | {attributeId}    | {value}            |\n * | includeField     | {attribute} or all |\n * | fuzzymatching    | true OR false      |\n * | limit            | {number}           |\n * | offset           | {number}           |\n */\nimport { DICOMWeb, utils } from '@ohif/core';\nimport { sortStudySeries } from '@ohif/core/src/utils/sortStudy';\n\nconst { getString, getName, getModalities } = DICOMWeb;\n\n/**\n * Parses resulting data from a QIDO call into a set of Study MetaData\n *\n * @param {Array} qidoStudies - An array of study objects. Each object contains a keys for DICOM tags.\n * @param {object} qidoStudies[0].qidoStudy - An object where each key is the DICOM Tag group+element\n * @param {object} qidoStudies[0].qidoStudy[dicomTag] - Optional object that represents DICOM Tag\n * @param {string} qidoStudies[0].qidoStudy[dicomTag].vr - Value Representation\n * @param {string[]} qidoStudies[0].qidoStudy[dicomTag].Value - Optional string array representation of the DICOM Tag's value\n * @returns {Array} An array of Study MetaData objects\n */\nfunction processResults(qidoStudies) {\n  if (!qidoStudies || !qidoStudies.length) {\n    return [];\n  }\n\n  const studies = [];\n\n  qidoStudies.forEach(qidoStudy =>\n    studies.push({\n      studyInstanceUid: getString(qidoStudy['0020000D']),\n      date: getString(qidoStudy['00080020']), // YYYYMMDD\n      time: getString(qidoStudy['00080030']), // HHmmss.SSS (24-hour, minutes, seconds, fractional seconds)\n      accession: getString(qidoStudy['00080050']) || '', // short string, probably a number?\n      mrn: getString(qidoStudy['00100020']) || '', // medicalRecordNumber\n      patientName: utils.formatPN(getName(qidoStudy['00100010'])) || '',\n      instances: Number(getString(qidoStudy['00201208'])) || 0, // number\n      description: getString(qidoStudy['00081030']) || '',\n      modalities:\n        getString(\n          getModalities(qidoStudy['00080060'], qidoStudy['00080061'])\n        ) || '',\n    })\n  );\n\n  return studies;\n}\n\n/**\n * Parses resulting data from a QIDO call into a set of Study MetaData\n *\n * @param {Array} qidoSeries - An array of study objects. Each object contains a keys for DICOM tags.\n * @param {object} qidoSeries[0].qidoSeries - An object where each key is the DICOM Tag group+element\n * @param {object} qidoSeries[0].qidoSeries[dicomTag] - Optional object that represents DICOM Tag\n * @param {string} qidoSeries[0].qidoSeries[dicomTag].vr - Value Representation\n * @param {string[]} qidoSeries[0].qidoSeries[dicomTag].Value - Optional string array representation of the DICOM Tag's value\n * @returns {Array} An array of Study MetaData objects\n */\nexport function processSeriesResults(qidoSeries) {\n  const series = [];\n\n  if (qidoSeries && qidoSeries.length) {\n    qidoSeries.forEach(qidoSeries =>\n      series.push({\n        studyInstanceUid: getString(qidoSeries['0020000D']),\n        seriesInstanceUid: getString(qidoSeries['0020000E']),\n        modality: getString(qidoSeries['00080060']),\n        seriesNumber: getString(qidoSeries['00200011']),\n        seriesDate: utils.formatDate(getString(qidoSeries['00080021'])),\n        numSeriesInstances: Number(getString(qidoSeries['00201209'])),\n        description: getString(qidoSeries['0008103E']),\n      })\n    );\n  }\n\n  sortStudySeries(series);\n\n  return series;\n}\n\n/**\n *\n * @param {object} dicomWebClient - Client similar to what's provided by `dicomweb-client` library\n * @param {function} dicomWebClient.searchForStudies -\n * @param {string} [studyInstanceUid]\n * @param {string} [seriesInstanceUid]\n * @param {string} [queryParamaters]\n * @returns {Promise<results>} - Promise that resolves results\n */\nasync function search(\n  dicomWebClient,\n  studyInstanceUid,\n  seriesInstanceUid,\n  queryParameters\n) {\n  let searchResult = await dicomWebClient.searchForStudies({\n    studyInstanceUid: undefined,\n    queryParams: queryParameters,\n  });\n\n  return searchResult;\n}\n\n/**\n *\n * @param {string} studyInstanceUID - ID of study to return a list of series for\n * @returns {Promise} - Resolves SeriesMetadata[] in study\n */\nexport function seriesInStudy(dicomWebClient, studyInstanceUID) {\n  // Series Description\n  // Already included?\n  const commaSeparatedFields = ['0008103E', '00080021'].join(',');\n  const queryParams = {\n    includefield: commaSeparatedFields,\n  };\n\n  return dicomWebClient.searchForSeries({ studyInstanceUID, queryParams });\n}\n\nexport default function searchStudies(server, filter) {\n  const queryParams = getQIDOQueryParams(\n    filter,\n    server.qidoSupportsIncludeField\n  );\n  const options = {\n    queryParams,\n  };\n\n  return dicomWeb.searchForStudies(options).then(resultDataToStudies);\n}\n\n/**\n * Produces a QIDO URL given server details and a set of specified search filter\n * items\n *\n * @param filter\n * @param serverSupportsQIDOIncludeField\n * @returns {string} The URL with encoded filter query data\n */\nfunction mapParams(params, options = {}) {\n  if (!params) {\n    return;\n  }\n  const commaSeparatedFields = [\n    '00081030', // Study Description\n    '00080060', // Modality\n    // Add more fields here if you want them in the result\n  ].join(',');\n\n  const { supportsWildcard } = options;\n  const withWildcard = value => {\n    return supportsWildcard && value ? `*${value}*` : value;\n  };\n\n  const parameters = {\n    // Named\n    PatientName: withWildcard(params.patientName),\n    //PatientID: withWildcard(params.patientId),\n    '00100020': withWildcard(params.patientId), // Temporarily to make the tests pass with dicomweb-server.. Apparently it's broken?\n    AccessionNumber: withWildcard(params.accessionNumber),\n    StudyDescription: withWildcard(params.studyDescription),\n    ModalitiesInStudy: params.modalitiesInStudy,\n    // Other\n    limit: params.limit || 101,\n    offset: params.offset || 0,\n    fuzzymatching: options.supportsFuzzyMatching === true,\n    includefield: commaSeparatedFields, // serverSupportsQIDOIncludeField ? commaSeparatedFields : 'all',\n  };\n\n  // build the StudyDate range parameter\n  if (params.startDate && params.endDate) {\n    parameters.StudyDate = `${params.startDate}-${params.endDate}`;\n  } else if (params.startDate) {\n    const today = new Date();\n    const DD = String(today.getDate()).padStart(2, '0');\n    const MM = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!\n    const YYYY = today.getFullYear();\n    const todayStr = `${YYYY}${MM}${DD}`;\n\n    parameters.StudyDate = `${params.startDate}-${todayStr}`;\n  } else if (params.endDate) {\n    const oldDateStr = `19700102`;\n\n    parameters.StudyDate = `${oldDateStr}-${params.endDate}`;\n  }\n\n  // Build the StudyInstanceUID parameter\n  if (params.studyInstanceUid) {\n    let studyUids = params.studyInstanceUid;\n    studyUids = Array.isArray(studyUids) ? studyUids.join() : studyUids;\n    studyUids = studyUids.replace(/[^0-9.]+/g, '\\\\');\n    parameters.StudyInstanceUID = studyUids;\n  }\n\n  // Clean query params of undefined values.\n  const final = {};\n  Object.keys(parameters).forEach(key => {\n    if (parameters[key] !== undefined && parameters[key] !== '') {\n      final[key] = parameters[key];\n    }\n  });\n\n  return final;\n}\n\nexport { mapParams, search, processResults };\n","import getWADORSImageId from './getWADORSImageId';\n\nfunction buildInstanceWadoUrl(config, instance) {\n  const { StudyInstanceUID, SeriesInstanceUID, SOPInstanceUID } = instance;\n  const params = [];\n\n  params.push('requestType=WADO');\n  params.push(`studyUID=${StudyInstanceUID}`);\n  params.push(`seriesUID=${SeriesInstanceUID}`);\n  params.push(`objectUID=${SOPInstanceUID}`);\n  params.push('contentType=application/dicom');\n  params.push('transferSyntax=*');\n\n  const paramString = params.join('&');\n\n  return `${config.wadoUriRoot}?${paramString}`;\n}\n\n/**\n * Obtain an imageId for Cornerstone from an image instance\n *\n * @param instance\n * @param frame\n * @param thumbnail\n * @returns {string} The imageId to be used by Cornerstone\n */\nexport default function getImageId({\n  instance,\n  frame,\n  config,\n  thumbnail = false,\n}) {\n  if (!instance) {\n    return;\n  }\n\n  if (instance.url) {\n    return instance.url;\n  }\n\n  const renderingAttr = thumbnail ? 'thumbnailRendering' : 'imageRendering';\n\n  if (!config[renderingAttr] || config[renderingAttr] === 'wadouri') {\n    const wadouri = buildInstanceWadoUrl(config, instance);\n\n    let imageId = 'dicomweb:' + wadouri;\n    if (frame !== undefined) {\n      imageId += '&frame=' + frame;\n    }\n\n    return imageId;\n  } else {\n    return getWADORSImageId(instance, config, frame); // WADO-RS Retrieve Frame\n  }\n}\n","function buildInstanceWadoRsUri(instance, config) {\n  const { StudyInstanceUID, SeriesInstanceUID, SOPInstanceUID } = instance;\n  return `${config.wadoRoot}/studies/${StudyInstanceUID}/series/${SeriesInstanceUID}/instances/${SOPInstanceUID}`;\n}\n\nfunction buildInstanceFrameWadoRsUri(instance, config, frame) {\n  const baseWadoRsUri = buildInstanceWadoRsUri(instance, config);\n\n  frame = frame || 1;\n\n  return `${baseWadoRsUri}/frames/${frame}`;\n}\n\n// function getWADORSImageUrl(instance, frame) {\n//   const wadorsuri = buildInstanceFrameWadoRsUri(instance, config, frame);\n\n//   if (!wadorsuri) {\n//     return;\n//   }\n\n//   // Use null to obtain an imageId which represents the instance\n//   if (frame === null) {\n//     wadorsuri = wadorsuri.replace(/frames\\/(\\d+)/, '');\n//   } else {\n//     // We need to sum 1 because WADO-RS frame number is 1-based\n//     frame = frame ? parseInt(frame) + 1 : 1;\n\n//     // Replaces /frame/1 by /frame/{frame}\n//     wadorsuri = wadorsuri.replace(/frames\\/(\\d+)/, `frames/${frame}`);\n//   }\n\n//   return wadorsuri;\n// }\n\n/**\n * Obtain an imageId for Cornerstone based on the WADO-RS scheme\n *\n * @param {object} instanceMetada metadata object (InstanceMetadata)\n * @param {(string\\|number)} [frame] the frame number\n * @returns {string} The imageId to be used by Cornerstone\n */\nexport default function getWADORSImageId(instance, config, frame) {\n  //const uri = getWADORSImageUrl(instance, frame);\n  const uri = buildInstanceFrameWadoRsUri(instance, config, frame);\n\n  if (!uri) {\n    return;\n  }\n\n  return `wadors:${uri}`;\n}\n","/**\n * Class to define inheritance of load retrieve strategy.\n * The process can be async load (lazy) or sync load\n *\n * There are methods that must be implemented at consumer level\n * To retrieve study call execLoad\n */\nexport default class RetrieveMetadataLoader {\n  /**\n   * @constructor\n   * @param {Object} client The dicomweb-client.\n   * @param {Array} studyInstanceUID Study instance ui to be retrieved\n   * @param {Object} [filters] - Object containing filters to be applied on retrieve metadata process\n   * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n   * @param {Function} [sortSeries] - Custom sort function for series\n   */\n  constructor(\n    client,\n    studyInstanceUID,\n    filters = {},\n    sortCriteria,\n    sortFunction\n  ) {\n    this.client = client;\n    this.studyInstanceUID = studyInstanceUID;\n    this.filters = filters;\n    this.sortCriteria = sortCriteria;\n    this.sortFunction = sortFunction;\n  }\n\n  async execLoad() {\n    const preLoadData = await this.preLoad();\n    const loadData = await this.load(preLoadData);\n    const postLoadData = await this.posLoad(loadData);\n\n    return postLoadData;\n  }\n\n  /**\n   * It iterates over given loaders running each one. Loaders parameters must be bind when getting it.\n   * @param {Array} loaders - array of loader to retrieve data.\n   */\n  async runLoaders(loaders) {\n    let result;\n    for (const loader of loaders) {\n      try {\n        result = await loader();\n        if (result && result.length) {\n          break; // closes iterator in case data is retrieved successfully\n        }\n      } catch (e) {\n        throw e;\n      }\n    }\n\n    if (loaders.next().done && !result) {\n      throw new Error('RetrieveMetadataLoader failed');\n    }\n\n    return result;\n  }\n\n  // Methods to be overwrite\n  async configLoad() {}\n  async preLoad() {}\n  async load(preLoadData) {}\n  async posLoad(loadData) {}\n}\n","// import { api } from 'dicomweb-client';\n// import DICOMWeb from '../../../DICOMWeb/';\nimport { createStudyFromSOPInstanceList } from './studyInstanceHelpers';\nimport RetrieveMetadataLoader from './retrieveMetadataLoader';\n\n/**\n * Class for sync load of study metadata.\n * It inherits from RetrieveMetadataLoader\n *\n * A list of loaders (getLoaders) can be created so, it will be applied a fallback load strategy.\n * I.e Retrieve metadata using all loaders possibilities.\n */\nexport default class RetrieveMetadataLoaderSync extends RetrieveMetadataLoader {\n  getOptions() {\n    const { studyInstanceUID, filters } = this;\n\n    const options = {\n      studyInstanceUID,\n    };\n\n    const { seriesInstanceUID } = filters;\n    if (seriesInstanceUID) {\n      options['seriesInstanceUID'] = seriesInstanceUID;\n    }\n\n    return options;\n  }\n\n  /**\n   * @returns {Array} Array of loaders. To be consumed as queue\n   */\n  *getLoaders() {\n    const loaders = [];\n    const {\n      studyInstanceUID,\n      filters: { seriesInstanceUID } = {},\n      client,\n    } = this;\n\n    if (seriesInstanceUID) {\n      loaders.push(\n        client.retrieveSeriesMetadata.bind(client, {\n          studyInstanceUID,\n          seriesInstanceUID,\n        })\n      );\n    }\n\n    loaders.push(\n      client.retrieveStudyMetadata.bind(client, { studyInstanceUID })\n    );\n\n    yield* loaders;\n  }\n\n  async load(preLoadData) {\n    const loaders = this.getLoaders();\n    const result = this.runLoaders(loaders);\n    return result;\n  }\n\n  async posLoad(loadData) {\n    return loadData;\n  }\n}\n","import dcmjs from 'dcmjs';\nimport {\n  sortStudySeries,\n  sortingCriteria,\n} from '@ohif/core/src/utils/sortStudy';\nimport RetrieveMetadataLoader from './retrieveMetadataLoader';\n\n/**\n * Creates an immutable series loader object which loads each series sequentially using the iterator interface\n * @param {DICOMWebClient} dicomWebClient The DICOMWebClient instance to be used for series load\n * @param {string} studyInstanceUID The Study Instance UID from which series will be loaded\n * @param {Array} seriesInstanceUIDList A list of Series Instance UIDs\n * @returns {Object} Returns an object which supports loading of instances from each of given Series Instance UID\n */\nfunction makeSeriesAsyncLoader(\n  client,\n  studyInstanceUID,\n  seriesInstanceUIDList\n) {\n  return Object.freeze({\n    hasNext() {\n      return seriesInstanceUIDList.length > 0;\n    },\n    async next() {\n      const seriesInstanceUID = seriesInstanceUIDList.shift();\n      return client.retrieveSeriesMetadata({\n        studyInstanceUID,\n        seriesInstanceUID,\n      });\n    },\n  });\n}\n\n/**\n * Class for async load of study metadata.\n * It inherits from RetrieveMetadataLoader\n *\n * It loads the one series and then append to seriesLoader the others to be consumed/loaded\n */\nexport default class RetrieveMetadataLoaderAsync extends RetrieveMetadataLoader {\n  /**\n   * @returns {Array} Array of preLoaders. To be consumed as queue\n   */\n  *getPreLoaders() {\n    const preLoaders = [];\n    const {\n      studyInstanceUID,\n      filters: { seriesInstanceUID } = {},\n      client,\n    } = this;\n\n    if (seriesInstanceUID) {\n      const options = {\n        studyInstanceUID,\n        queryParams: { SeriesInstanceUID: seriesInstanceUID },\n      };\n      preLoaders.push(client.searchForSeries.bind(client, options));\n    }\n    // Fallback preloader\n    preLoaders.push(client.searchForSeries.bind(client, { studyInstanceUID }));\n\n    yield* preLoaders;\n  }\n\n  async preLoad() {\n    const preLoaders = this.getPreLoaders();\n    const result = await this.runLoaders(preLoaders);\n    const sortCriteria = this.sortCriteria;\n    const sortFunction = this.sortFunction;\n\n    const { naturalizeDataset } = dcmjs.data.DicomMetaDictionary;\n    const naturalized = result.map(naturalizeDataset);\n\n    return sortStudySeries(\n      naturalized,\n      sortCriteria ||\n        sortingCriteria.seriesSortCriteria.seriesInfoSortingCriteria,\n      sortFunction\n    );\n  }\n\n  async load(preLoadData) {\n    const { client, studyInstanceUID } = this;\n\n    const seriesInstanceUIDs = preLoadData.map(s => s.SeriesInstanceUID);\n\n    const seriesAsyncLoader = makeSeriesAsyncLoader(\n      client,\n      studyInstanceUID,\n      seriesInstanceUIDs\n    );\n\n    const promises = [];\n\n    while (seriesAsyncLoader.hasNext()) {\n      promises.push(seriesAsyncLoader.next());\n    }\n\n    return {\n      preLoadData,\n      promises,\n    };\n  }\n\n  async posLoad({ preLoadData, promises }) {\n    return {\n      preLoadData,\n      promises,\n    };\n  }\n}\n","import RetrieveMetadataLoaderSync from './retrieveMetadataLoaderSync';\nimport RetrieveMetadataLoaderAsync from './retrieveMetadataLoaderAsync';\n\n/**\n * Retrieve Study metadata from a DICOM server. If the server is configured to use lazy load, only the first series\n * will be loaded and the property \"studyLoader\" will be set to let consumer load remaining series as needed.\n *\n * @param {Object} dicomWebClient The dicomweb-client.\n * @param {string} studyInstanceUid The Study Instance UID of the study which needs to be loaded\n * @param {Object} [filters] - Object containing filters to be applied on retrieve metadata process\n * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n * @returns {Object} A study descriptor object\n */\nasync function RetrieveMetadata(\n  dicomWebClient,\n  studyInstanceUid,\n  enableStudyLazyLoad,\n  filters = {},\n  sortCriteria,\n  sortFunction\n) {\n  const RetrieveMetadataLoader =\n    enableStudyLazyLoad !== false\n      ? RetrieveMetadataLoaderAsync\n      : RetrieveMetadataLoaderSync;\n\n  const retrieveMetadataLoader = new RetrieveMetadataLoader(\n    dicomWebClient,\n    studyInstanceUid,\n    filters,\n    sortCriteria,\n    sortFunction\n  );\n  const data = await retrieveMetadataLoader.execLoad();\n\n  return data;\n}\n\nexport default RetrieveMetadata;\n","import RetrieveMetadata from './wado/retrieveMetadata.js';\n\nconst moduleName = 'RetrieveStudyMetadata';\n// Cache for promises. Prevents unnecessary subsequent calls to the server\nconst StudyMetaDataPromises = new Map();\n\n/**\n * Retrieves study metadata\n *\n * @param {Object} server Object with server configuration parameters\n * @param {string} StudyInstanceUID The UID of the Study to be retrieved\n * @param {boolean} enabledStudyLazyLoad Whether the study metadata should be loaded asynchronusly.\n * @param {function} storeInstancesCallback A callback used to store the retrieved instance metadata.\n * @param {Object} [filters] - Object containing filters to be applied on retrieve metadata process\n * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n * @returns {Promise} that will be resolved with the metadata or rejected with the error\n */\nexport function retrieveStudyMetadata(\n  dicomWebClient,\n  StudyInstanceUID,\n  enableStudyLazyLoad,\n  filters,\n  sortCriteria,\n  sortFunction\n) {\n  // @TODO: Whenever a study metadata request has failed, its related promise will be rejected once and for all\n  // and further requests for that metadata will always fail. On failure, we probably need to remove the\n  // corresponding promise from the \"StudyMetaDataPromises\" map...\n\n  if (!dicomWebClient) {\n    throw new Error(\n      `${moduleName}: Required 'dicomWebClient' parameter not provided.`\n    );\n  }\n  if (!StudyInstanceUID) {\n    throw new Error(\n      `${moduleName}: Required 'StudyInstanceUID' parameter not provided.`\n    );\n  }\n\n  // Already waiting on result? Return cached promise\n  if (StudyMetaDataPromises.has(StudyInstanceUID)) {\n    return StudyMetaDataPromises.get(StudyInstanceUID);\n  }\n\n  // Create a promise to handle the data retrieval\n  const promise = new Promise((resolve, reject) => {\n    RetrieveMetadata(\n      dicomWebClient,\n      StudyInstanceUID,\n      enableStudyLazyLoad,\n      filters,\n      sortCriteria,\n      sortFunction\n    ).then(function(data) {\n      resolve(data);\n    }, reject);\n  });\n\n  // Store the promise in cache\n  StudyMetaDataPromises.set(StudyInstanceUID, promise);\n\n  return promise;\n}\n\n/**\n * Delete the cached study metadata retrieval promise to ensure that the browser will\n * re-retrieve the study metadata when it is next requested\n *\n * @param {String} StudyInstanceUID The UID of the Study to be removed from cache\n *\n */\nexport function deleteStudyMetadataPromise(StudyInstanceUID) {\n  if (StudyMetaDataPromises.has(StudyInstanceUID)) {\n    StudyMetaDataPromises.delete(StudyInstanceUID);\n  }\n}\n","import { api } from 'dicomweb-client';\n\n/**\n * An implementation of the static wado client, that fetches data from\n * a static response rather than actually doing real queries.  This allows\n * fast encoding of test data, but because it is static, anything actually\n * performing searches doesn't work.  This version fixes the query issue\n * by manually implementing a query option.\n */\nexport default class StaticWadoClient extends api.DICOMwebClient {\n  static studyFilterKeys = {\n    studyinstanceuid: '0020000D',\n    patientname: '00100010',\n    '00100020': 'mrn',\n    studydescription: '00081030',\n    studydate: '00080020',\n    modalitiesinstudy: '00080061',\n    accessionnumber: '00080050',\n  };\n\n  static seriesFilterKeys = {\n    seriesinstanceuid: '0020000E',\n    seriesnumber: '00200011',\n    modality: '00080060',\n  };\n\n  constructor(qidoConfig) {\n    super(qidoConfig);\n    this.staticWado = qidoConfig.staticWado;\n  }\n\n  /**\n   * Replace the search for studies remote query with a local version which\n   * retrieves a complete query list and then sub-selects from it locally.\n   * @param {*} options\n   * @returns\n   */\n  async searchForStudies(options) {\n    if (!this.staticWado) return super.searchForStudies(options);\n\n    const searchResult = await super.searchForStudies(options);\n    const { queryParams } = options;\n\n    if (!queryParams) return searchResult;\n\n    const lowerParams = this.toLowerParams(queryParams);\n    const filtered = searchResult.filter(study => {\n      for (const key of Object.keys(StaticWadoClient.studyFilterKeys)) {\n        if (\n          !this.filterItem(\n            key,\n            lowerParams,\n            study,\n            StaticWadoClient.studyFilterKeys\n          )\n        ) {\n          return false;\n        }\n      }\n      return true;\n    });\n    return filtered;\n  }\n\n  async searchForSeries(options) {\n    if (!this.staticWado) return super.searchForSeries(options);\n\n    const searchResult = await super.searchForSeries(options);\n    const { queryParams } = options;\n    if (!queryParams) return searchResult;\n    const lowerParams = this.toLowerParams(queryParams);\n\n    const filtered = searchResult.filter(series => {\n      for (const key of Object.keys(StaticWadoClient.seriesFilterKeys)) {\n        if (\n          !this.filterItem(\n            key,\n            lowerParams,\n            series,\n            StaticWadoClient.seriesFilterKeys\n          )\n        ) {\n          return false;\n        }\n      }\n      return true;\n    });\n\n    return filtered;\n  }\n\n  /**\n   * Compares values, matching any instance of desired to any instance of\n   * actual by recursively go through the paired set of values.  That is,\n   * this is O(m*n) where m is how many items in desired and n is the length of actual\n   * Then, at the individual item node, compares the Alphabetic name if present,\n   * and does a sub-string matching on string values, and otherwise does an\n   * exact match comparison.\n   *\n   * @param {*} desired\n   * @param {*} actual\n   * @returns true if the values match\n   */\n  compareValues(desired, actual) {\n    if (Array.isArray(desired)) {\n      return desired.find(item => this.compareValues(item, actual));\n    }\n    if (Array.isArray(actual)) {\n      return actual.find(actualItem => this.compareValues(desired, actualItem));\n    }\n    if (actual?.Alphabetic) {\n      actual = actual.Alphabetic;\n    }\n    if (typeof actual == 'string') {\n      if (actual.length === 0) return true;\n      if (desired.length === 0 || desired === '*') return true;\n      if (desired[0] === '*' && desired[desired.length - 1] === '*') {\n        // console.log(`Comparing ${actual} to ${desired.substring(1, desired.length - 1)}`)\n        return actual.indexOf(desired.substring(1, desired.length - 1)) != -1;\n      } else if (desired[desired.length - 1] === '*') {\n        return actual.indexOf(desired.substring(0, desired.length - 1)) != -1;\n      } else if (desired[0] === '*') {\n        return (\n          actual.indexOf(desired.substring(1)) ===\n          actual.length - desired.length + 1\n        );\n      }\n    }\n    return desired === actual;\n  }\n\n  /** Compares a pair of dates to see if the value is within the range */\n  compareDateRange(range, value) {\n    if (!value) return true;\n    const dash = range.indexOf('-');\n    if (dash === -1) return this.compareValues(range, value);\n    const start = range.substring(0, dash);\n    const end = range.substring(dash + 1);\n    return (!start || value >= start) && (!end || value <= end);\n  }\n\n  /**\n   * Filters the return list by the query parameters.\n   *\n   * @param anyCaseKey - a possible search key\n   * @param queryParams -\n   * @param {*} study\n   * @param {*} sourceFilterMap\n   * @returns\n   */\n  filterItem(key: string, queryParams, study, sourceFilterMap) {\n    const altKey = sourceFilterMap[key] || key;\n    if (!queryParams) return true;\n    const testValue = queryParams[key] || queryParams[altKey];\n    if (!testValue) return true;\n    const valueElem = study[key] || study[altKey];\n    if (!valueElem) return false;\n    if (valueElem.vr == 'DA') {\n      return this.compareDateRange(testValue, valueElem.Value[0]);\n    }\n    const value = valueElem.Value;\n    return this.compareValues(testValue, value);\n  }\n\n  /** Converts the query parameters to lower case query parameters */\n  toLowerParams(queryParams: Record<string, unknown>): Record<string, unknown> {\n    const lowerParams = {};\n    Object.entries(queryParams).forEach(([key, value]) => {\n      lowerParams[key.toLowerCase()] = value;\n    });\n    return lowerParams;\n  }\n}\n","import { utils } from '@ohif/core';\n\n/**\n * Generates a URL that can be used for direct retrieve of the bulkdata\n *\n * @param {object} params\n * @param {string} params.tag is the tag name of the URL to retrieve\n * @param {string} params.defaultPath path for the pixel data url\n * @param {object} params.instance is the instance object that the tag is in\n * @param {string} params.defaultType is the mime type of the response\n * @param {string} params.singlepart is the type of the part to retrieve\n * @param {string} params.fetchPart unknown?\n * @returns an absolute URL to the resource, if the absolute URL can be retrieved as singlepart,\n *    or is already retrieved, or a promise to a URL for such use if a BulkDataURI\n */\nconst getDirectURL = (config, params) => {\n  const { wadoRoot, singlepart } = config;\n  const {\n    instance,\n    tag = 'PixelData',\n    defaultPath = '/pixeldata',\n    defaultType = 'video/mp4',\n    singlepart: fetchPart = 'video',\n  } = params;\n  const value = instance[tag];\n  if (!value) return undefined;\n\n  if (value.DirectRetrieveURL) return value.DirectRetrieveURL;\n  if (value.InlineBinary) {\n    const blob = utils.b64toBlob(value.InlineBinary, defaultType);\n    value.DirectRetrieveURL = URL.createObjectURL(blob);\n    return value.DirectRetrieveURL;\n  }\n  if (\n    !singlepart ||\n    (singlepart !== true && singlepart.indexOf(fetchPart) === -1)\n  ) {\n    if (value.retrieveBulkData) {\n      return value.retrieveBulkData().then(arr => {\n        value.DirectRetrieveURL = URL.createObjectURL(\n          new Blob([arr], { type: defaultType })\n        );\n        return value.DirectRetrieveURL;\n      });\n    }\n    console.warn('Unable to retrieve', tag, 'from', instance);\n    return undefined;\n  }\n\n  const { StudyInstanceUID, SeriesInstanceUID, SOPInstanceUID } = instance;\n  const BulkDataURI =\n    (value && value.BulkDataURI) ||\n    `series/${SeriesInstanceUID}/instances/${SOPInstanceUID}${defaultPath}`;\n  const hasQuery = BulkDataURI.indexOf('?') !== -1;\n  const hasAccept = BulkDataURI.indexOf('accept=') !== -1;\n  const acceptUri =\n    BulkDataURI +\n    (hasAccept ? '' : (hasQuery ? '&' : '?') + `accept=${defaultType}`);\n\n  if (tag === 'PixelData' || tag === 'EncapsulatedDocument') {\n    return `${wadoRoot}/studies/${StudyInstanceUID}/series/${SeriesInstanceUID}/instances/${SOPInstanceUID}/rendered`;\n  }\n\n  // The DICOMweb standard states that the default is multipart related, and then\n  // separately states that the accept parameter is the URL parameter equivalent of the accept header.\n  return acceptUri;\n};\n\nexport default getDirectURL;\n","/**\n * Modifies a bulkDataURI to ensure it is absolute based on the DICOMWeb configuration and\n * instance data. The modification is in-place.\n *\n * If the bulkDataURI is relative to the series or study (according to the DICOM standard),\n * it is made absolute by prepending the relevant paths.\n *\n * In scenarios where the bulkDataURI is a server-relative path (starting with '/'), the function\n * handles two cases:\n *\n * 1. If the wado root is absolute (starts with 'http'), it prepends the wado root to the bulkDataURI.\n * 2. If the wado root is relative, no changes are needed as the bulkDataURI is already correctly relative to the server root.\n *\n * @param value - The object containing BulkDataURI to be fixed.\n * @param instance - The object (DICOM instance data) containing StudyInstanceUID and SeriesInstanceUID.\n * @param dicomWebConfig - The DICOMWeb configuration object, containing wadoRoot and potentially bulkDataURI.relativeResolution.\n * @returns The function modifies `value` in-place, it does not return a value.\n */\nfunction fixBulkDataURI(value, instance, dicomWebConfig) {\n  // in case of the relative path, make it absolute. The current DICOM standard says\n  // the bulkdataURI is relative to the series. However, there are situations where\n  // it can be relative to the study too\n  if (\n    !value.BulkDataURI.startsWith('http') &&\n    !value.BulkDataURI.startsWith('/')\n  ) {\n    if (dicomWebConfig.bulkDataURI?.relativeResolution === 'studies') {\n      value.BulkDataURI = `${dicomWebConfig.wadoRoot}/studies/${instance.StudyInstanceUID}/${value.BulkDataURI}`;\n    } else if (\n      dicomWebConfig.bulkDataURI?.relativeResolution === 'series' ||\n      !dicomWebConfig.bulkDataURI?.relativeResolution\n    ) {\n      value.BulkDataURI = `${dicomWebConfig.wadoRoot}/studies/${instance.StudyInstanceUID}/series/${instance.SeriesInstanceUID}/${value.BulkDataURI}`;\n    }\n\n    return;\n  }\n\n  // in case it is relative path but starts at the server (e.g., /bulk/1e, note the missing http\n  // in the beginning and the first character is /) There are two scenarios, whether the wado root\n  // is absolute or relative. In case of absolute, we need to prepend the wado root to the bulkdata\n  // uri (e.g., bulkData: /bulk/1e, wado root: http://myserver.com/dicomweb, output: http://myserver.com/bulk/1e)\n  // and in case of relative wado root, we need to prepend the bulkdata uri to the wado root (e.g,. bulkData: /bulk/1e\n  // wado root: /dicomweb, output: /bulk/1e)\n  if (value.BulkDataURI[0] === '/') {\n    if (dicomWebConfig.wadoRoot.startsWith('http')) {\n      // Absolute wado root\n      const url = new URL(dicomWebConfig.wadoRoot);\n      value.BulkDataURI = `${url.origin}${value.BulkDataURI}`;\n    } else {\n      // Relative wado root, we don't need to do anything, bulkdata uri is already correct\n    }\n  }\n}\n\nexport { fixBulkDataURI };\n","import { api } from 'dicomweb-client';\nimport {\n  DicomMetadataStore,\n  IWebApiDataSource,\n  utils,\n  errorHandler,\n  classes,\n} from '@ohif/core';\n\nimport {\n  mapParams,\n  search as qidoSearch,\n  seriesInStudy,\n  processResults,\n  processSeriesResults,\n} from './qido.js';\nimport dcm4cheeReject from './dcm4cheeReject';\n\nimport getImageId from './utils/getImageId';\nimport dcmjs from 'dcmjs';\nimport {\n  retrieveStudyMetadata,\n  deleteStudyMetadataPromise,\n} from './retrieveStudyMetadata.js';\nimport StaticWadoClient from './utils/StaticWadoClient';\nimport getDirectURL from '../utils/getDirectURL';\nimport { fixBulkDataURI } from './utils/fixBulkDataURI';\n\nconst { DicomMetaDictionary, DicomDict } = dcmjs.data;\n\nconst { naturalizeDataset, denaturalizeDataset } = DicomMetaDictionary;\n\nconst ImplementationClassUID =\n  '2.25.270695996825855179949881587723571202391.2.0.0';\nconst ImplementationVersionName = 'OHIF-VIEWER-2.0.0';\nconst EXPLICIT_VR_LITTLE_ENDIAN = '1.2.840.10008.1.2.1';\n\nconst metadataProvider = classes.MetadataProvider;\n\n/**\n *\n * @param {string} name - Data source name\n * @param {string} wadoUriRoot - Legacy? (potentially unused/replaced)\n * @param {string} qidoRoot - Base URL to use for QIDO requests\n * @param {string} wadoRoot - Base URL to use for WADO requests\n * @param {boolean} qidoSupportsIncludeField - Whether QIDO supports the \"Include\" option to request additional fields in response\n * @param {string} imageRengering - wadors | ? (unsure of where/how this is used)\n * @param {string} thumbnailRendering - wadors | ? (unsure of where/how this is used)\n * @param {bool} supportsReject - Whether the server supports reject calls (i.e. DCM4CHEE)\n * @param {bool} lazyLoadStudy - \"enableStudyLazyLoad\"; Request series meta async instead of blocking\n * @param {string|bool} singlepart - indicates of the retrieves can fetch singlepart.  Options are bulkdata, video, image or boolean true\n */\nfunction createDicomWebApi(dicomWebConfig, userAuthenticationService) {\n  const {\n    qidoRoot,\n    wadoRoot,\n    enableStudyLazyLoad,\n    supportsFuzzyMatching,\n    supportsWildcard,\n    supportsReject,\n    staticWado,\n    singlepart,\n  } = dicomWebConfig;\n\n  const dicomWebConfigCopy = JSON.parse(JSON.stringify(dicomWebConfig));\n\n  const qidoConfig = {\n    url: qidoRoot,\n    staticWado,\n    singlepart,\n    headers: userAuthenticationService.getAuthorizationHeader(),\n    errorInterceptor: errorHandler.getHTTPErrorHandler(),\n  };\n\n  const wadoConfig = {\n    url: wadoRoot,\n    staticWado,\n    singlepart,\n    headers: userAuthenticationService.getAuthorizationHeader(),\n    errorInterceptor: errorHandler.getHTTPErrorHandler(),\n  };\n\n  // TODO -> Two clients sucks, but its better than 1000.\n  // TODO -> We'll need to merge auth later.\n  const qidoDicomWebClient = staticWado\n    ? new StaticWadoClient(qidoConfig)\n    : new api.DICOMwebClient(qidoConfig);\n\n  const wadoDicomWebClient = staticWado\n    ? new StaticWadoClient(wadoConfig)\n    : new api.DICOMwebClient(wadoConfig);\n\n  const implementation = {\n    initialize: ({ params, query }) => {\n      const { StudyInstanceUIDs: paramsStudyInstanceUIDs } = params;\n      const queryStudyInstanceUIDs = utils.splitComma(\n        query.getAll('StudyInstanceUIDs')\n      );\n\n      const StudyInstanceUIDs =\n        (queryStudyInstanceUIDs.length && queryStudyInstanceUIDs) ||\n        paramsStudyInstanceUIDs;\n      const StudyInstanceUIDsAsArray =\n        StudyInstanceUIDs && Array.isArray(StudyInstanceUIDs)\n          ? StudyInstanceUIDs\n          : [StudyInstanceUIDs];\n      return StudyInstanceUIDsAsArray;\n    },\n    query: {\n      studies: {\n        mapParams: mapParams.bind(),\n        search: async function(origParams) {\n          const headers = userAuthenticationService.getAuthorizationHeader();\n          if (headers) {\n            qidoDicomWebClient.headers = headers;\n          }\n\n          const { studyInstanceUid, seriesInstanceUid, ...mappedParams } =\n            mapParams(origParams, {\n              supportsFuzzyMatching,\n              supportsWildcard,\n            }) || {};\n\n          const results = await qidoSearch(\n            qidoDicomWebClient,\n            undefined,\n            undefined,\n            mappedParams\n          );\n\n          return processResults(results);\n        },\n        processResults: processResults.bind(),\n      },\n      series: {\n        // mapParams: mapParams.bind(),\n        search: async function(studyInstanceUid) {\n          const headers = userAuthenticationService.getAuthorizationHeader();\n          if (headers) {\n            qidoDicomWebClient.headers = headers;\n          }\n\n          const results = await seriesInStudy(\n            qidoDicomWebClient,\n            studyInstanceUid\n          );\n\n          return processSeriesResults(results);\n        },\n        // processResults: processResults.bind(),\n      },\n      instances: {\n        search: (studyInstanceUid, queryParameters) => {\n          const headers = userAuthenticationService.getAuthorizationHeader();\n          if (headers) {\n            qidoDicomWebClient.headers = headers;\n          }\n\n          qidoSearch.call(\n            undefined,\n            qidoDicomWebClient,\n            studyInstanceUid,\n            null,\n            queryParameters\n          );\n        },\n      },\n    },\n    retrieve: {\n      /**\n       * Generates a URL that can be used for direct retrieve of the bulkdata\n       *\n       * @param {object} params\n       * @param {string} params.tag is the tag name of the URL to retrieve\n       * @param {object} params.instance is the instance object that the tag is in\n       * @param {string} params.defaultType is the mime type of the response\n       * @param {string} params.singlepart is the type of the part to retrieve\n       * @returns an absolute URL to the resource, if the absolute URL can be retrieved as singlepart,\n       *    or is already retrieved, or a promise to a URL for such use if a BulkDataURI\n       */\n      directURL: params => {\n        return getDirectURL({ wadoRoot, singlepart }, params);\n      },\n      bulkDataURI: async ({ StudyInstanceUID, BulkDataURI }) => {\n        const options = {\n          multipart: false,\n          BulkDataURI,\n          StudyInstanceUID,\n        };\n        return qidoDicomWebClient.retrieveBulkData(options).then(val => {\n          const ret = (val && val[0]) || undefined;\n          return ret;\n        });\n      },\n      series: {\n        metadata: async ({\n          StudyInstanceUID,\n          filters,\n          sortCriteria,\n          sortFunction,\n          madeInClient = false,\n        } = {}) => {\n          const headers = userAuthenticationService.getAuthorizationHeader();\n          if (headers) {\n            wadoDicomWebClient.headers = headers;\n          }\n\n          if (!StudyInstanceUID) {\n            throw new Error(\n              'Unable to query for SeriesMetadata without StudyInstanceUID'\n            );\n          }\n\n          if (enableStudyLazyLoad) {\n            return implementation._retrieveSeriesMetadataAsync(\n              StudyInstanceUID,\n              filters,\n              sortCriteria,\n              sortFunction,\n              madeInClient\n            );\n          }\n\n          return implementation._retrieveSeriesMetadataSync(\n            StudyInstanceUID,\n            filters,\n            sortCriteria,\n            sortFunction,\n            madeInClient\n          );\n        },\n      },\n    },\n\n    store: {\n      dicom: async (dataset, request) => {\n        const headers = userAuthenticationService.getAuthorizationHeader();\n        if (headers) {\n          wadoDicomWebClient.headers = headers;\n        }\n\n        if (dataset instanceof ArrayBuffer) {\n          const options = {\n            datasets: [dataset],\n            request,\n          };\n\n          await wadoDicomWebClient.storeInstances(options);\n        } else {\n          const meta = {\n            FileMetaInformationVersion:\n              dataset._meta.FileMetaInformationVersion.Value,\n            MediaStorageSOPClassUID: dataset.SOPClassUID,\n            MediaStorageSOPInstanceUID: dataset.SOPInstanceUID,\n            TransferSyntaxUID: EXPLICIT_VR_LITTLE_ENDIAN,\n            ImplementationClassUID,\n            ImplementationVersionName,\n          };\n\n          const denaturalized = denaturalizeDataset(meta);\n          const dicomDict = new DicomDict(denaturalized);\n\n          dicomDict.dict = denaturalizeDataset(dataset);\n\n          const part10Buffer = dicomDict.write();\n\n          const options = {\n            datasets: [part10Buffer],\n            request,\n          };\n\n          await wadoDicomWebClient.storeInstances(options);\n        }\n      },\n    },\n\n    _retrieveSeriesMetadataSync: async (\n      StudyInstanceUID,\n      filters,\n      sortCriteria,\n      sortFunction,\n      madeInClient\n    ) => {\n      const enableStudyLazyLoad = false;\n\n      // data is all SOPInstanceUIDs\n      const data = await retrieveStudyMetadata(\n        wadoDicomWebClient,\n        StudyInstanceUID,\n        enableStudyLazyLoad,\n        filters,\n        sortCriteria,\n        sortFunction\n      );\n\n      // first naturalize the data\n      const naturalizedInstancesMetadata = data.map(naturalizeDataset);\n\n      const seriesSummaryMetadata = {};\n      const instancesPerSeries = {};\n\n      naturalizedInstancesMetadata.forEach(instance => {\n        if (!seriesSummaryMetadata[instance.SeriesInstanceUID]) {\n          seriesSummaryMetadata[instance.SeriesInstanceUID] = {\n            StudyInstanceUID: instance.StudyInstanceUID,\n            StudyDescription: instance.StudyDescription,\n            SeriesInstanceUID: instance.SeriesInstanceUID,\n            SeriesDescription: instance.SeriesDescription,\n            SeriesNumber: instance.SeriesNumber,\n            SeriesTime: instance.SeriesTime,\n            SOPClassUID: instance.SOPClassUID,\n            ProtocolName: instance.ProtocolName,\n            Modality: instance.Modality,\n          };\n        }\n\n        if (!instancesPerSeries[instance.SeriesInstanceUID]) {\n          instancesPerSeries[instance.SeriesInstanceUID] = [];\n        }\n\n        const imageId = implementation.getImageIdsForInstance({\n          instance,\n        });\n\n        instance.imageId = imageId;\n\n        metadataProvider.addImageIdToUIDs(imageId, {\n          StudyInstanceUID,\n          SeriesInstanceUID: instance.SeriesInstanceUID,\n          SOPInstanceUID: instance.SOPInstanceUID,\n        });\n\n        instancesPerSeries[instance.SeriesInstanceUID].push(instance);\n      });\n\n      // grab all the series metadata\n      const seriesMetadata = Object.values(seriesSummaryMetadata);\n      DicomMetadataStore.addSeriesMetadata(seriesMetadata, madeInClient);\n\n      Object.keys(instancesPerSeries).forEach(seriesInstanceUID =>\n        DicomMetadataStore.addInstances(\n          instancesPerSeries[seriesInstanceUID],\n          madeInClient\n        )\n      );\n    },\n\n    _retrieveSeriesMetadataAsync: async (\n      StudyInstanceUID,\n      filters,\n      sortCriteria,\n      sortFunction,\n      madeInClient = false\n    ) => {\n      const enableStudyLazyLoad = true;\n      // Get Series\n      const {\n        preLoadData: seriesSummaryMetadata,\n        promises: seriesPromises,\n      } = await retrieveStudyMetadata(\n        wadoDicomWebClient,\n        StudyInstanceUID,\n        enableStudyLazyLoad,\n        filters,\n        sortCriteria,\n        sortFunction\n      );\n\n      /**\n       * naturalizes the dataset, and adds a retrieve bulkdata method\n       * to any values containing BulkDataURI.\n       * @param {*} instance\n       * @returns naturalized dataset, with retrieveBulkData methods\n       */\n      const addRetrieveBulkData = instance => {\n        const naturalized = naturalizeDataset(instance);\n\n        // if we konw the server doesn't use bulkDataURI, then don't\n        if (!dicomWebConfig.bulkDataURI?.enabled) {\n          return naturalized;\n        }\n\n        Object.keys(naturalized).forEach(key => {\n          const value = naturalized[key];\n\n          // The value.Value will be set with the bulkdata read value\n          // in which case it isn't necessary to re-read this.\n          if (value && value.BulkDataURI && !value.Value) {\n            // Provide a method to fetch bulkdata\n            value.retrieveBulkData = () => {\n              // handle the scenarios where bulkDataURI is relative path\n              fixBulkDataURI(value, naturalized, dicomWebConfig);\n\n              const options = {\n                // The bulkdata fetches work with either multipart or\n                // singlepart, so set multipart to false to let the server\n                // decide which type to respond with.\n                multipart: false,\n                BulkDataURI: value.BulkDataURI,\n                // The study instance UID is required if the bulkdata uri\n                // is relative - that isn't disallowed by DICOMweb, but\n                // isn't well specified in the standard, but is needed in\n                // any implementation that stores static copies of the metadata\n                StudyInstanceUID: naturalized.StudyInstanceUID,\n              };\n              // Todo: this needs to be from wado dicom web client\n              return qidoDicomWebClient.retrieveBulkData(options).then(val => {\n                // There are DICOM PDF cases where the first ArrayBuffer in the array is\n                // the bulk data and DICOM video cases where the second ArrayBuffer is\n                // the bulk data. Here we play it safe and do a find.\n                const ret =\n                  (val instanceof Array &&\n                    val.find(arrayBuffer => arrayBuffer?.byteLength)) ||\n                  undefined;\n                value.Value = ret;\n                return ret;\n              });\n            };\n          }\n        });\n        return naturalized;\n      };\n\n      // Async load series, store as retrieved\n      function storeInstances(instances) {\n        const naturalizedInstances = instances.map(addRetrieveBulkData);\n\n        // Adding instanceMetadata to OHIF MetadataProvider\n        naturalizedInstances.forEach((instance, index) => {\n          instance.wadoRoot = dicomWebConfig.wadoRoot;\n          instance.wadoUri = dicomWebConfig.wadoUri;\n\n          const imageId = implementation.getImageIdsForInstance({\n            instance,\n          });\n\n          // Adding imageId to each instance\n          // Todo: This is not the best way I can think of to let external\n          // metadata handlers know about the imageId that is stored in the store\n          instance.imageId = imageId;\n\n          // Adding UIDs to metadataProvider\n          // Note: storing imageURI in metadataProvider since stack viewports\n          // will use the same imageURI\n          metadataProvider.addImageIdToUIDs(imageId, {\n            StudyInstanceUID,\n            SeriesInstanceUID: instance.SeriesInstanceUID,\n            SOPInstanceUID: instance.SOPInstanceUID,\n          });\n        });\n\n        DicomMetadataStore.addInstances(naturalizedInstances, madeInClient);\n      }\n\n      function setSuccessFlag() {\n        const study = DicomMetadataStore.getStudy(\n          StudyInstanceUID,\n          madeInClient\n        );\n        study.isLoaded = true;\n      }\n\n      // Google Cloud Healthcare doesn't return StudyInstanceUID, so we need to add\n      // it manually here\n      seriesSummaryMetadata.forEach(aSeries => {\n        aSeries.StudyInstanceUID = StudyInstanceUID;\n      });\n\n      DicomMetadataStore.addSeriesMetadata(seriesSummaryMetadata, madeInClient);\n\n      const seriesDeliveredPromises = seriesPromises.map(promise =>\n        promise.then(instances => {\n          storeInstances(instances);\n        })\n      );\n      await Promise.all(seriesDeliveredPromises);\n      setSuccessFlag();\n    },\n    deleteStudyMetadataPromise,\n    getImageIdsForDisplaySet(displaySet) {\n      const images = displaySet.images;\n      const imageIds = [];\n\n      if (!images) {\n        return imageIds;\n      }\n\n      displaySet.images.forEach(instance => {\n        const NumberOfFrames = instance.NumberOfFrames;\n\n        if (NumberOfFrames > 1) {\n          for (let frame = 1; frame <= NumberOfFrames; frame++) {\n            const imageId = this.getImageIdsForInstance({\n              instance,\n              frame,\n            });\n            imageIds.push(imageId);\n          }\n        } else {\n          const imageId = this.getImageIdsForInstance({ instance });\n          imageIds.push(imageId);\n        }\n      });\n\n      return imageIds;\n    },\n    getImageIdsForInstance({ instance, frame }) {\n      const imageIds = getImageId({\n        instance,\n        frame,\n        config: dicomWebConfig,\n      });\n      return imageIds;\n    },\n    getConfig() {\n      return dicomWebConfigCopy;\n    },\n  };\n\n  if (supportsReject) {\n    implementation.reject = dcm4cheeReject(wadoRoot);\n  }\n\n  return IWebApiDataSource.create(implementation);\n}\n\nexport { createDicomWebApi };\n","export default function (wadoRoot) {\n  return {\n    series: (StudyInstanceUID, SeriesInstanceUID) => {\n      return new Promise((resolve, reject) => {\n        // Reject because of Quality. (Seems the most sensible out of the options)\n        const CodeValueAndCodeSchemeDesignator = `113001%5EDCM`;\n\n        const url = `${wadoRoot}/studies/${StudyInstanceUID}/series/${SeriesInstanceUID}/reject/${CodeValueAndCodeSchemeDesignator}`;\n\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', url, true);\n\n        //Send the proper header information along with the request\n        // TODO -> Auth when we re-add authorization.\n\n        console.log(xhr);\n\n        xhr.onreadystatechange = function () {\n          //Call a function when the state changes.\n          if (xhr.readyState == 4) {\n            switch (xhr.status) {\n              case 204:\n                resolve(xhr.responseText);\n\n                break;\n              case 404:\n                reject('Your dataSource does not support reject functionality');\n            }\n          }\n        };\n        xhr.send();\n      });\n    },\n  };\n}\n","import { DicomMetadataStore, IWebApiDataSource } from '@ohif/core';\nimport OHIF from '@ohif/core';\n\nimport getImageId from '../DicomWebDataSource/utils/getImageId';\nimport getDirectURL from '../utils/getDirectURL';\n\nconst metadataProvider = OHIF.classes.MetadataProvider;\n\nconst mappings = {\n  studyInstanceUid: 'StudyInstanceUID',\n  patientId: 'PatientID',\n};\n\nlet _store = {\n  urls: [],\n  // {\n  //   url: url1\n  //   studies: [Study1, Study2], // if multiple studies\n  // }\n  // {\n  //   url: url2\n  //   studies: [Study1],\n  // }\n  // }\n};\n\nconst getMetaDataByURL = url => {\n  return _store.urls.find(metaData => metaData.url === url);\n};\n\nconst findStudies = (key, value) => {\n  let studies = [];\n  _store.urls.map(metaData => {\n    metaData.studies.map(aStudy => {\n      if (aStudy[key] === value) {\n        studies.push(aStudy);\n      }\n    });\n  });\n  return studies;\n};\n\nfunction createDicomJSONApi(dicomJsonConfig) {\n  const { name, wadoRoot } = dicomJsonConfig;\n\n  const implementation = {\n    initialize: async ({ params, query, url }) => {\n      if (!url) url = query.get('url');\n      let metaData = getMetaDataByURL(url);\n\n      // if we have already cached the data from this specific url\n      // We are only handling one StudyInstanceUID to run; however,\n      // all studies for patientID will be put in the correct tab\n      if (metaData) {\n        return metaData.studies.map(aStudy => {\n          return aStudy.StudyInstanceUID;\n        });\n      }\n\n      const response = await fetch(url);\n      let data = await response.json();\n\n      const studyInstanceUIDs = data.studies.map(\n        study => study.StudyInstanceUID\n      );\n\n      let StudyInstanceUID;\n      let SeriesInstanceUID;\n      data.studies.forEach(study => {\n        StudyInstanceUID = study.StudyInstanceUID;\n\n        study.series.forEach(series => {\n          SeriesInstanceUID = series.SeriesInstanceUID;\n\n          series.instances.forEach(instance => {\n            const { url: imageId, metadata: naturalizedDicom } = instance;\n\n            // Add imageId specific mapping to this data as the URL isn't necessarliy WADO-URI.\n            metadataProvider.addImageIdToUIDs(imageId, {\n              StudyInstanceUID,\n              SeriesInstanceUID,\n              SOPInstanceUID: naturalizedDicom.SOPInstanceUID,\n            });\n          });\n        });\n      });\n\n      _store.urls.push({\n        url,\n        studies: [...data.studies],\n      });\n\n      return studyInstanceUIDs;\n    },\n    query: {\n      studies: {\n        mapParams: () => { },\n        search: async param => {\n          const [key, value] = Object.entries(param)[0];\n          const mappedParam = mappings[key];\n\n          // todo: should fetch from dicomMetadataStore\n          const studies = findStudies(mappedParam, value);\n\n          return studies.map(aStudy => {\n            return {\n              accession: aStudy.AccessionNumber,\n              date: aStudy.StudyDate,\n              description: aStudy.StudyDescription,\n              instances: aStudy.NumInstances,\n              modalities: aStudy.Modalities,\n              mrn: aStudy.PatientID,\n              patientName: aStudy.PatientName,\n              studyInstanceUid: aStudy.StudyInstanceUID,\n              NumInstances: aStudy.NumInstances,\n              time: aStudy.StudyTime,\n            };\n          });\n        },\n        processResults: () => {\n          console.debug(' DICOMJson QUERY processResults');\n        },\n      },\n      series: {\n        // mapParams: mapParams.bind(),\n        search: () => {\n          console.debug(' DICOMJson QUERY SERIES SEARCH');\n        },\n      },\n      instances: {\n        search: () => {\n          console.debug(' DICOMJson QUERY instances SEARCH');\n        },\n      },\n    },\n    retrieve: {\n      /**\n       * Generates a URL that can be used for direct retrieve of the bulkdata\n       *\n       * @param {object} params\n       * @param {string} params.tag is the tag name of the URL to retrieve\n       * @param {string} params.defaultPath path for the pixel data url\n       * @param {object} params.instance is the instance object that the tag is in\n       * @param {string} params.defaultType is the mime type of the response\n       * @param {string} params.singlepart is the type of the part to retrieve\n       * @param {string} params.fetchPart unknown?\n       * @returns an absolute URL to the resource, if the absolute URL can be retrieved as singlepart,\n       *    or is already retrieved, or a promise to a URL for such use if a BulkDataURI\n       */\n      directURL: params => {\n        return getDirectURL(wadoRoot, params);\n      },\n      series: {\n        metadata: ({\n          StudyInstanceUID,\n          madeInClient = false,\n          customSort,\n        } = {}) => {\n          if (!StudyInstanceUID) {\n            throw new Error(\n              'Unable to query for SeriesMetadata without StudyInstanceUID'\n            );\n          }\n\n          const study = findStudies('StudyInstanceUID', StudyInstanceUID)[0];\n          let series;\n\n          if (customSort) {\n            series = customSort(study.series);\n          } else {\n            series = study.series;\n          }\n\n          const seriesSummaryMetadata = series.map(series => {\n            const seriesSummary = {\n              StudyInstanceUID: study.StudyInstanceUID,\n              ...series,\n            };\n            delete seriesSummary.instances;\n            return seriesSummary;\n          });\n\n          // Async load series, store as retrieved\n          function storeInstances(naturalizedInstances) {\n            DicomMetadataStore.addInstances(naturalizedInstances, madeInClient);\n          }\n\n          DicomMetadataStore.addSeriesMetadata(\n            seriesSummaryMetadata,\n            madeInClient\n          );\n\n          function setSuccessFlag() {\n            const study = DicomMetadataStore.getStudy(\n              StudyInstanceUID,\n              madeInClient\n            );\n            study.isLoaded = true;\n          }\n\n          const numberOfSeries = series.length;\n          series.forEach((series, index) => {\n            const instances = series.instances.map(instance => {\n              const obj = {\n                ...instance.metadata,\n                url: instance.url,\n                imageId: instance.url,\n                ...series,\n                ...study,\n              };\n              delete obj.instances;\n              delete obj.series;\n              return obj;\n            });\n            storeInstances(instances);\n            if (index === numberOfSeries - 1) setSuccessFlag();\n          });\n        },\n      },\n    },\n    store: {\n      dicom: () => {\n        console.debug(' DICOMJson store dicom');\n      },\n    },\n    getImageIdsForDisplaySet(displaySet) {\n      const images = displaySet.images;\n      const imageIds = [];\n\n      if (!images) {\n        return imageIds;\n      }\n\n      displaySet.images.forEach(instance => {\n        const NumberOfFrames = instance.NumberOfFrames;\n\n        if (NumberOfFrames > 1) {\n          for (let i = 0; i < NumberOfFrames; i++) {\n            const imageId = getImageId({\n              instance,\n              frame: i,\n              config: dicomJsonConfig,\n            });\n            imageIds.push(imageId);\n          }\n        } else {\n          const imageId = getImageId({ instance, config: dicomJsonConfig });\n          imageIds.push(imageId);\n        }\n      });\n\n      return imageIds;\n    },\n    getImageIdsForInstance({ instance, frame }) {\n      const imageIds = getImageId({\n        instance,\n        frame,\n      });\n      return imageIds;\n    },\n  };\n  return IWebApiDataSource.create(implementation);\n}\n\nexport { createDicomJSONApi };\n","import { DicomMetadataStore, IWebApiDataSource, utils } from '@ohif/core';\nimport OHIF from '@ohif/core';\nimport dcmjs from 'dcmjs';\n\nconst metadataProvider = OHIF.classes.MetadataProvider;\nconst { EVENTS } = DicomMetadataStore;\n\nconst END_MODALITIES = {\n  SR: true,\n  SEG: true,\n  DOC: true,\n};\n\nconst compareValue = (v1, v2, def = 0) => {\n  if (v1 === v2) return def;\n  if (v1 < v2) return -1;\n  return 1;\n};\n\n// Sorting SR modalities to be at the end of series list\nconst customSort = (seriesA, seriesB) => {\n  const instanceA = seriesA.instances[0];\n  const instanceB = seriesB.instances[0];\n  const modalityA = instanceA.Modality;\n  const modalityB = instanceB.Modality;\n\n  const isEndA = END_MODALITIES[modalityA];\n  const isEndB = END_MODALITIES[modalityB];\n\n  if (isEndA && isEndB) {\n    // Compare by series date\n    return compareValue(instanceA.SeriesNumber, instanceB.SeriesNumber);\n  }\n  if (!isEndA && !isEndB) {\n    return compareValue(instanceB.SeriesNumber, instanceA.SeriesNumber);\n  }\n  return isEndA ? -1 : 1;\n};\n\nfunction createDicomLocalApi(dicomLocalConfig) {\n  const { name } = dicomLocalConfig;\n\n  const implementation = {\n    initialize: ({ params, query }) => {\n      const { StudyInstanceUIDs: paramsStudyInstanceUIDs } = params;\n      const queryStudyInstanceUIDs = query.getAll('StudyInstanceUIDs');\n\n      const StudyInstanceUIDs =\n        queryStudyInstanceUIDs || paramsStudyInstanceUIDs;\n      const StudyInstanceUIDsAsArray =\n        StudyInstanceUIDs && Array.isArray(StudyInstanceUIDs)\n          ? StudyInstanceUIDs\n          : [StudyInstanceUIDs];\n\n      // Put SRs at the end of series list to make sure images are loaded first\n      StudyInstanceUIDsAsArray.forEach(StudyInstanceUID => {\n        const study = DicomMetadataStore.getStudy(StudyInstanceUID);\n        study.series = study.series.sort(customSort);\n      });\n\n      return StudyInstanceUIDsAsArray;\n    },\n    query: {\n      studies: {\n        mapParams: () => {},\n        search: params => {\n          const studyUIDs = DicomMetadataStore.getStudyInstanceUIDs();\n\n          return studyUIDs.map(StudyInstanceUID => {\n            let numInstances = 0;\n            const modalities = new Set();\n\n            // Calculating the number of instances in the study and modalities\n            // present in the study\n            const study = DicomMetadataStore.getStudy(StudyInstanceUID);\n            study.series.forEach(aSeries => {\n              numInstances += aSeries.instances.length;\n              modalities.add(aSeries.instances[0].Modality);\n            });\n\n            // first instance in the first series\n            const firstInstance = study?.series[0]?.instances[0];\n\n            if (firstInstance) {\n              return {\n                accession: firstInstance.AccessionNumber,\n                date: firstInstance.StudyDate,\n                description: firstInstance.StudyDescription,\n                mrn: firstInstance.PatientID,\n                patientName: utils.formatPN(firstInstance.PatientName),\n                studyInstanceUid: firstInstance.StudyInstanceUID,\n                time: firstInstance.StudyTime,\n                //\n                instances: numInstances,\n                modalities: Array.from(modalities).join('/'),\n                NumInstances: numInstances,\n              };\n            }\n          });\n        },\n        processResults: () => {\n          console.debug(' DICOMLocal QUERY processResults');\n        },\n      },\n      series: {\n        search: studyInstanceUID => {\n          const study = DicomMetadataStore.getStudy(studyInstanceUID);\n          return study.series.map(aSeries => {\n            const firstInstance = aSeries?.instances[0];\n            return {\n              studyInstanceUid: studyInstanceUID,\n              seriesInstanceUid: firstInstance.SeriesInstanceUID,\n              modality: firstInstance.Modality,\n              seriesNumber: firstInstance.SeriesNumber,\n              seriesDate: firstInstance.SeriesDate,\n              numSeriesInstances: aSeries.instances.length,\n              description: firstInstance.SeriesDescription,\n            };\n          });\n        },\n      },\n      instances: {\n        search: () => {\n          console.debug(' DICOMLocal QUERY instances SEARCH');\n        },\n      },\n    },\n    retrieve: {\n      directURL: params => {\n        const { instance, tag, defaultType } = params;\n\n        const value = instance[tag];\n        if (value instanceof Array && value[0] instanceof ArrayBuffer) {\n          return URL.createObjectURL(\n            new Blob([value[0]], {\n              type: defaultType,\n            })\n          );\n        }\n      },\n      series: {\n        metadata: async ({ StudyInstanceUID, madeInClient = false } = {}) => {\n          if (!StudyInstanceUID) {\n            throw new Error(\n              'Unable to query for SeriesMetadata without StudyInstanceUID'\n            );\n          }\n\n          // Instances metadata already added via local upload\n          const study = DicomMetadataStore.getStudy(\n            StudyInstanceUID,\n            madeInClient\n          );\n\n          // Series metadata already added via local upload\n          DicomMetadataStore._broadcastEvent(EVENTS.SERIES_ADDED, {\n            StudyInstanceUID,\n            madeInClient,\n          });\n\n          study.series.forEach(aSeries => {\n            const { SeriesInstanceUID } = aSeries;\n\n            const isMultiframe = aSeries.instances[0].NumberOfFrames > 1;\n\n            aSeries.instances.forEach((instance, index) => {\n              const {\n                url: imageId,\n                StudyInstanceUID,\n                SeriesInstanceUID,\n                SOPInstanceUID,\n              } = instance;\n\n              instance.imageId = imageId;\n\n              // Add imageId specific mapping to this data as the URL isn't necessarily WADO-URI.\n              metadataProvider.addImageIdToUIDs(imageId, {\n                StudyInstanceUID,\n                SeriesInstanceUID,\n                SOPInstanceUID,\n                frameIndex: isMultiframe ? index : 1,\n              });\n            });\n\n            DicomMetadataStore._broadcastEvent(EVENTS.INSTANCES_ADDED, {\n              StudyInstanceUID,\n              SeriesInstanceUID,\n              madeInClient,\n            });\n          });\n        },\n      },\n    },\n    store: {\n      dicom: naturalizedReport => {\n        const reportBlob = dcmjs.data.datasetToBlob(naturalizedReport);\n\n        //Create a URL for the binary.\n        var objectUrl = URL.createObjectURL(reportBlob);\n        window.location.assign(objectUrl);\n      },\n    },\n    getImageIdsForDisplaySet(displaySet) {\n      const images = displaySet.images;\n      const imageIds = [];\n\n      if (!images) {\n        return imageIds;\n      }\n\n      displaySet.images.forEach(instance => {\n        const NumberOfFrames = instance.NumberOfFrames;\n        if (NumberOfFrames > 1) {\n          // in multiframe we start at frame 1\n          for (let i = 1; i <= NumberOfFrames; i++) {\n            const imageId = this.getImageIdsForInstance({\n              instance,\n              frame: i,\n            });\n            imageIds.push(imageId);\n          }\n        } else {\n          const imageId = this.getImageIdsForInstance({ instance });\n          imageIds.push(imageId);\n        }\n      });\n\n      return imageIds;\n    },\n    getImageIdsForInstance({ instance, frame }) {\n      const { StudyInstanceUID, SeriesInstanceUID, SOPInstanceUID } = instance;\n      const storedInstance = DicomMetadataStore.getInstance(\n        StudyInstanceUID,\n        SeriesInstanceUID,\n        SOPInstanceUID\n      );\n\n      let imageId = storedInstance.url;\n\n      if (frame !== undefined) {\n        imageId += `&frame=${frame}`;\n      }\n\n      return imageId;\n    },\n    deleteStudyMetadataPromise() {\n      console.log('deleteStudyMetadataPromise not implemented');\n    },\n  };\n  return IWebApiDataSource.create(implementation);\n}\n\nexport { createDicomLocalApi };\n","import { IWebApiDataSource } from '@ohif/core';\nimport { createDicomWebApi } from '../DicomWebDataSource/index';\n\n/**\n * This datasource is initialized with a url that returns a JSON object with a\n * dicomWeb datasource configuration array present in a \"servers\" object.\n *\n * Only the first array item is parsed, if there are multiple items in the\n * dicomWeb configuration array\n *\n */\nfunction createDicomWebProxyApi(\n  dicomWebProxyConfig,\n  UserAuthenticationService\n) {\n  const { name } = dicomWebProxyConfig;\n  let dicomWebDelegate = undefined;\n\n  const implementation = {\n    initialize: async ({ params, query }) => {\n      let studyInstanceUIDs = [];\n\n      // there seem to be a couple of variations of the case for this parameter\n      const queryStudyInstanceUIDs =\n        query.get('studyInstanceUIDs') || query.get('studyInstanceUids');\n      if (!queryStudyInstanceUIDs) {\n        throw new Error(`No studyInstanceUids in request for '${name}'`);\n      }\n\n      const url = query.get('url');\n\n      if (!url) {\n        throw new Error(`No url for '${name}'`);\n      } else {\n        const response = await fetch(url);\n        let data = await response.json();\n        if (!data.servers?.dicomWeb?.[0]) {\n          throw new Error('Invalid configuration returned by url');\n        }\n\n        dicomWebDelegate = createDicomWebApi(\n          data.servers.dicomWeb[0],\n          UserAuthenticationService\n        );\n        studyInstanceUIDs = queryStudyInstanceUIDs.split(';');\n      }\n      return studyInstanceUIDs;\n    },\n    query: {\n      studies: {\n        search: params => dicomWebDelegate.query.studies.search(params),\n      },\n      series: {\n        search: (...args) => dicomWebDelegate.query.series.search(...args),\n      },\n      instances: {\n        search: (studyInstanceUid, queryParameters) =>\n          dicomWebDelegate.query.instances.search(\n            studyInstanceUid,\n            queryParameters\n          ),\n      },\n    },\n    retrieve: {\n      directURL: (...args) => dicomWebDelegate.retrieve.directURL(...args),\n      series: {\n        metadata: (...args) =>\n          dicomWebDelegate.retrieve.series.metadata(...args),\n      },\n    },\n    store: {\n      dicom: (...args) => dicomWebDelegate.store(...args),\n    },\n    deleteStudyMetadataPromise: (...args) =>\n      dicomWebDelegate.deleteStudyMetadataPromise(...args),\n    getImageIdsForDisplaySet: (...args) =>\n      dicomWebDelegate.getImageIdsForDisplaySet(...args),\n    getImageIdsForInstance: (...args) =>\n      dicomWebDelegate.getImageIdsForInstance(...args),\n  };\n  return IWebApiDataSource.create(implementation);\n}\n\nexport { createDicomWebProxyApi };\n","// TODO: Pull in IWebClientApi from @ohif/core\n// TODO: Use constructor to create an instance of IWebClientApi\n// TODO: Use existing DICOMWeb configuration (previously, appConfig, to configure instance)\n\nimport { createDicomWebApi } from './DicomWebDataSource/index.js';\nimport { createDicomJSONApi } from './DicomJSONDataSource/index.js';\nimport { createDicomLocalApi } from './DicomLocalDataSource/index.js';\nimport { createDicomWebProxyApi } from './DicomWebProxyDataSource/index.js';\n\n/**\n *\n */\nfunction getDataSourcesModule() {\n  return [\n    {\n      name: 'dicomweb',\n      type: 'webApi',\n      createDataSource: createDicomWebApi,\n    },\n    {\n      name: 'dicomwebproxy',\n      type: 'webApi',\n      createDataSource: createDicomWebProxyApi,\n    },\n    {\n      name: 'dicomjson',\n      type: 'jsonApi',\n      createDataSource: createDicomJSONApi,\n    },\n    {\n      name: 'dicomlocal',\n      type: 'localApi',\n      createDataSource: createDicomLocalApi,\n    },\n  ];\n}\n\nexport default getDataSourcesModule;\n","import React, { useEffect, useState } from 'react';\nimport classnames from 'classnames';\n\nexport default function Toolbar({ servicesManager }) {\n  const { toolbarService } = servicesManager.services;\n  const [toolbarButtons, setToolbarButtons] = useState([]);\n  const [buttonState, setButtonState] = useState({\n    primaryToolId: '',\n    toggles: {},\n    groups: {},\n  });\n\n  // Could track buttons and state separately...?\n  useEffect(() => {\n    const { unsubscribe: unsub1 } = toolbarService.subscribe(\n      toolbarService.EVENTS.TOOL_BAR_MODIFIED,\n      () => setToolbarButtons(toolbarService.getButtonSection('primary'))\n    );\n    const { unsubscribe: unsub2 } = toolbarService.subscribe(\n      toolbarService.EVENTS.TOOL_BAR_STATE_MODIFIED,\n      () => setButtonState({ ...toolbarService.state })\n    );\n\n    return () => {\n      unsub1();\n      unsub2();\n    };\n  }, [toolbarService]);\n\n  return (\n    <>\n      {toolbarButtons.map((toolDef, index) => {\n        const { id, Component, componentProps } = toolDef;\n        // TODO: ...\n\n        // isActive if:\n        // - id is primary?\n        // - id is in list of \"toggled on\"?\n        let isActive;\n        if (componentProps.type === 'toggle') {\n          isActive = buttonState.toggles[id];\n        }\n        // Also need... to filter list for splitButton, and set primary based on most recently clicked\n        // Also need to kill the radioGroup button's magic logic\n        // Everything should be reactive off these props, so commands can inform ToolbarService\n\n        // These can... Trigger toolbar events based on updates?\n        // Then sync using useEffect, or simply modify the state here?\n        return (\n          // The margin for separating the tools on the toolbar should go here and NOT in each individual component (button) item.\n          // This allows for the individual items to be included in other UI components where perhaps alternative margins are desired.\n          <div key={id} className={classnames('mr-1')}>\n            <Component\n              id={id}\n              {...componentProps}\n              bState={buttonState}\n              isActive={isActive}\n              onInteraction={args => toolbarService.recordInteraction(args)}\n              servicesManager={servicesManager}\n            />\n          </div>\n        );\n      })}\n    </>\n  );\n}\n","import React, { useEffect, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { useNavigate } from 'react-router-dom';\nimport { useTranslation } from 'react-i18next';\nimport { useLocation } from 'react-router';\n\nimport {\n  SidePanel,\n  ErrorBoundary,\n  UserPreferences,\n  AboutModal,\n  Header,\n  useModal,\n  LoadingIndicatorProgress,\n} from '@ohif/ui';\nimport i18n from '@ohif/i18n';\nimport {\n  ServicesManager,\n  HangingProtocolService,\n  hotkeys,\n  CommandsManager,\n} from '@ohif/core';\nimport { useAppConfig } from '@state';\nimport Toolbar from '../Toolbar/Toolbar';\n\nconst { availableLanguages, defaultLanguage, currentLanguage } = i18n;\n\nfunction ViewerLayout({\n  // From Extension Module Params\n  extensionManager,\n  servicesManager,\n  hotkeysManager,\n  commandsManager,\n  // From Modes\n  viewports,\n  ViewportGridComp,\n  leftPanels = [],\n  rightPanels = [],\n  leftPanelDefaultClosed = false,\n  rightPanelDefaultClosed = false,\n}): React.FunctionComponent {\n  const [appConfig] = useAppConfig();\n  const navigate = useNavigate();\n  const location = useLocation();\n\n  const onClickReturnButton = () => {\n    const { pathname } = location;\n    const dataSourceIdx = pathname.indexOf('/', 1);\n    // const search =\n    //   dataSourceIdx === -1\n    //     ? undefined\n    //     : `datasources=${pathname.substring(dataSourceIdx + 1)}`;\n\n    // Todo: Handle parameters in a better way.\n    const query = new URLSearchParams(window.location.search);\n    const configUrl = query.get('configUrl');\n\n    const searchQuery = new URLSearchParams();\n    if (dataSourceIdx !== -1) {\n      searchQuery.append('datasources', pathname.substring(dataSourceIdx + 1));\n    }\n\n    if (configUrl) {\n      searchQuery.append('configUrl', configUrl);\n    }\n\n    navigate({\n      pathname: '/',\n      search: decodeURIComponent(searchQuery.toString()),\n    });\n  };\n\n  const { t } = useTranslation();\n  const { show, hide } = useModal();\n\n  const [showLoadingIndicator, setShowLoadingIndicator] = useState(\n    appConfig.showLoadingIndicator\n  );\n\n  const { hangingProtocolService } = servicesManager.services;\n\n  const { hotkeyDefinitions, hotkeyDefaults } = hotkeysManager;\n  const versionNumber = process.env.VERSION_NUMBER;\n  const commitHash = process.env.COMMIT_HASH;\n\n  const menuOptions = [\n    {\n      title: t('Header:About'),\n      icon: 'info',\n      onClick: () =>\n        show({\n          content: AboutModal,\n          title: 'About OHIF Viewer',\n          contentProps: { versionNumber, commitHash },\n        }),\n    },\n    {\n      title: t('Header:Preferences'),\n      icon: 'settings',\n      onClick: () =>\n        show({\n          title: t('UserPreferencesModal:User Preferences'),\n          content: UserPreferences,\n          contentProps: {\n            hotkeyDefaults: hotkeysManager.getValidHotkeyDefinitions(\n              hotkeyDefaults\n            ),\n            hotkeyDefinitions,\n            currentLanguage: currentLanguage(),\n            availableLanguages,\n            defaultLanguage,\n            onCancel: () => {\n              hotkeys.stopRecord();\n              hotkeys.unpause();\n              hide();\n            },\n            onSubmit: ({ hotkeyDefinitions, language }) => {\n              i18n.changeLanguage(language.value);\n              hotkeysManager.setHotkeys(hotkeyDefinitions);\n              hide();\n            },\n            onReset: () => hotkeysManager.restoreDefaultBindings(),\n            hotkeysModule: hotkeys,\n          },\n        }),\n    },\n  ];\n\n  if (appConfig.oidc) {\n    menuOptions.push({\n      title: t('Header:Logout'),\n      icon: 'power-off',\n      onClick: async () => {\n        navigate(\n          `/logout?redirect_uri=${encodeURIComponent(window.location.href)}`\n        );\n      },\n    });\n  }\n\n  /**\n   * Set body classes (tailwindcss) that don't allow vertical\n   * or horizontal overflow (no scrolling). Also guarantee window\n   * is sized to our viewport.\n   */\n  useEffect(() => {\n    document.body.classList.add('bg-black');\n    document.body.classList.add('overflow-hidden');\n    return () => {\n      document.body.classList.remove('bg-black');\n      document.body.classList.remove('overflow-hidden');\n    };\n  }, []);\n\n  const getComponent = id => {\n    const entry = extensionManager.getModuleEntry(id);\n\n    if (!entry) {\n      throw new Error(\n        `${id} is not a valid entry for an extension module, please check your configuration or make sure the extension is registered.`\n      );\n    }\n\n    let content;\n    if (entry && entry.component) {\n      content = entry.component;\n    } else {\n      throw new Error(\n        `No component found from extension ${id}. Check the reference string to the extension in your Mode configuration`\n      );\n    }\n\n    return { entry, content };\n  };\n\n  const getPanelData = id => {\n    const { content, entry } = getComponent(id);\n\n    return {\n      id: entry.id,\n      iconName: entry.iconName,\n      iconLabel: entry.iconLabel,\n      label: entry.label,\n      name: entry.name,\n      content,\n    };\n  };\n\n  useEffect(() => {\n    const { unsubscribe } = hangingProtocolService.subscribe(\n      HangingProtocolService.EVENTS.PROTOCOL_CHANGED,\n\n      // Todo: right now to set the loading indicator to false, we need to wait for the\n      // hangingProtocolService to finish applying the viewport matching to each viewport,\n      // however, this might not be the only approach to set the loading indicator to false. we need to explore this further.\n      () => {\n        setShowLoadingIndicator(false);\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, [hangingProtocolService]);\n\n  const getViewportComponentData = viewportComponent => {\n    const { entry } = getComponent(viewportComponent.namespace);\n\n    return {\n      component: entry.component,\n      displaySetsToDisplay: viewportComponent.displaySetsToDisplay,\n    };\n  };\n\n  const leftPanelComponents = leftPanels.map(getPanelData);\n  const rightPanelComponents = rightPanels.map(getPanelData);\n  const viewportComponents = viewports.map(getViewportComponentData);\n\n  // @ts-ignore\n  return (\n    <div>\n      <Header\n        menuOptions={menuOptions}\n        isReturnEnabled={!!appConfig.showStudyList}\n        onClickReturnButton={onClickReturnButton}\n        WhiteLabeling={appConfig.whiteLabeling}\n      >\n        <ErrorBoundary context=\"Primary Toolbar\">\n          <div className=\"relative flex justify-center\">\n            <Toolbar servicesManager={servicesManager} />\n          </div>\n        </ErrorBoundary>\n      </Header>\n      <div\n        className=\"bg-black flex flex-row items-stretch w-full overflow-hidden flex-nowrap relative\"\n        style={{ height: 'calc(100vh - 52px' }}\n      >\n        <React.Fragment>\n          {showLoadingIndicator && (\n            <LoadingIndicatorProgress className=\"h-full w-full bg-black\" />\n          )}\n          {/* LEFT SIDEPANELS */}\n          {leftPanelComponents.length ? (\n            <ErrorBoundary context=\"Left Panel\">\n              <SidePanel\n                side=\"left\"\n                activeTabIndex={leftPanelDefaultClosed ? null : 0}\n                tabs={leftPanelComponents}\n                servicesManager={servicesManager}\n              />\n            </ErrorBoundary>\n          ) : null}\n          {/* TOOLBAR + GRID */}\n          <div className=\"flex flex-col flex-1 h-full\">\n            <div className=\"flex items-center justify-center flex-1 h-full overflow-hidden bg-black relative\">\n              <ErrorBoundary context=\"Grid\">\n                <ViewportGridComp\n                  servicesManager={servicesManager}\n                  viewportComponents={viewportComponents}\n                  commandsManager={commandsManager}\n                />\n              </ErrorBoundary>\n            </div>\n          </div>\n          {rightPanelComponents.length ? (\n            <ErrorBoundary context=\"Right Panel\">\n              <SidePanel\n                side=\"right\"\n                activeTabIndex={rightPanelDefaultClosed ? null : 0}\n                tabs={rightPanelComponents}\n                servicesManager={servicesManager}\n              />\n            </ErrorBoundary>\n          ) : null}\n        </React.Fragment>\n      </div>\n    </div>\n  );\n}\n\nViewerLayout.propTypes = {\n  // From extension module params\n  extensionManager: PropTypes.shape({\n    getModuleEntry: PropTypes.func.isRequired,\n  }).isRequired,\n  commandsManager: PropTypes.instanceOf(CommandsManager),\n  servicesManager: PropTypes.instanceOf(ServicesManager),\n  // From modes\n  leftPanels: PropTypes.array,\n  rightPanels: PropTypes.array,\n  leftPanelDefaultClosed: PropTypes.bool.isRequired,\n  rightPanelDefaultClosed: PropTypes.bool.isRequired,\n  /** Responsible for rendering our grid of viewports; provided by consuming application */\n  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,\n};\n\nexport default ViewerLayout;\n","import React, { useState, useEffect, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { StudyBrowser, useImageViewer, useViewportGrid } from '@ohif/ui';\nimport { utils } from '@ohif/core';\n\nconst { sortStudyInstances, formatDate } = utils;\n\n/**\n *\n * @param {*} param0\n */\nfunction PanelStudyBrowser({\n  servicesManager,\n  getImageSrc,\n  getStudiesForPatientByMRN,\n  requestDisplaySetCreationForStudy,\n  dataSource,\n}) {\n  const {\n    hangingProtocolService,\n    displaySetService,\n    uiNotificationService,\n  } = servicesManager.services;\n  // Normally you nest the components so the tree isn't so deep, and the data\n  // doesn't have to have such an intense shape. This works well enough for now.\n  // Tabs --> Studies --> DisplaySets --> Thumbnails\n  const { StudyInstanceUIDs } = useImageViewer();\n  const [\n    { activeViewportIndex, viewports },\n    viewportGridService,\n  ] = useViewportGrid();\n  const [activeTabName, setActiveTabName] = useState('primary');\n  const [expandedStudyInstanceUIDs, setExpandedStudyInstanceUIDs] = useState([\n    ...StudyInstanceUIDs,\n  ]);\n  const [studyDisplayList, setStudyDisplayList] = useState([]);\n  const [displaySets, setDisplaySets] = useState([]);\n  const [thumbnailImageSrcMap, setThumbnailImageSrcMap] = useState({});\n  const isMounted = useRef(true);\n\n  const onDoubleClickThumbnailHandler = displaySetInstanceUID => {\n    let updatedViewports = [];\n    const viewportIndex = activeViewportIndex;\n    try {\n      updatedViewports = hangingProtocolService.getViewportsRequireUpdate(\n        viewportIndex,\n        displaySetInstanceUID\n      );\n    } catch (error) {\n      console.warn(error);\n      uiNotificationService.show({\n        title: 'Thumbnail Double Click',\n        message:\n          'The selected display sets could not be added to the viewport.',\n        type: 'info',\n        duration: 3000,\n      });\n    }\n\n    viewportGridService.setDisplaySetsForViewports(updatedViewports);\n  };\n\n  // ~~ studyDisplayList\n  useEffect(() => {\n    // Fetch all studies for the patient in each primary study\n    async function fetchStudiesForPatient(StudyInstanceUID) {\n      // current study qido\n      const qidoForStudyUID = await dataSource.query.studies.search({\n        studyInstanceUid: StudyInstanceUID,\n      });\n\n      let qidoStudiesForPatient = qidoForStudyUID;\n\n      // try to fetch the prior studies based on the patientID if the\n      // server can respond.\n      try {\n        qidoStudiesForPatient = await getStudiesForPatientByMRN(\n          qidoForStudyUID\n        );\n      } catch (error) {\n        console.warn(error);\n      }\n\n      const mappedStudies = _mapDataSourceStudies(qidoStudiesForPatient);\n      const actuallyMappedStudies = mappedStudies.map(qidoStudy => {\n        return {\n          studyInstanceUid: qidoStudy.StudyInstanceUID,\n          date: formatDate(qidoStudy.StudyDate),\n          description: qidoStudy.StudyDescription,\n          modalities: qidoStudy.ModalitiesInStudy,\n          numInstances: qidoStudy.NumInstances,\n        };\n      });\n\n      setStudyDisplayList(prevArray => {\n        const ret = [...prevArray];\n        for (const study of actuallyMappedStudies) {\n          if (\n            !prevArray.find(\n              it => it.studyInstanceUid === study.studyInstanceUid\n            )\n          ) {\n            ret.push(study);\n          }\n        }\n        return ret;\n      });\n    }\n\n    StudyInstanceUIDs.forEach(sid => fetchStudiesForPatient(sid));\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [StudyInstanceUIDs, getStudiesForPatientByMRN]);\n\n  // // ~~ Initial Thumbnails\n  useEffect(() => {\n    const currentDisplaySets = displaySetService.activeDisplaySets;\n    currentDisplaySets.forEach(async dSet => {\n      const newImageSrcEntry = {};\n      const displaySet = displaySetService.getDisplaySetByUID(\n        dSet.displaySetInstanceUID\n      );\n      const imageIds = dataSource.getImageIdsForDisplaySet(displaySet);\n      const imageId = imageIds[Math.floor(imageIds.length / 2)];\n\n      // TODO: Is it okay that imageIds are not returned here for SR displaySets?\n      if (imageId) {\n        // When the image arrives, render it and store the result in the thumbnailImgSrcMap\n        newImageSrcEntry[dSet.displaySetInstanceUID] = await getImageSrc(\n          imageId\n        );\n        if (isMounted.current) {\n          setThumbnailImageSrcMap(prevState => {\n            return { ...prevState, ...newImageSrcEntry };\n          });\n        }\n      }\n    });\n    return () => {\n      isMounted.current = false;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // ~~ displaySets\n  useEffect(() => {\n    // TODO: Are we sure `activeDisplaySets` will always be accurate?\n    const currentDisplaySets = displaySetService.activeDisplaySets;\n    const mappedDisplaySets = _mapDisplaySets(\n      currentDisplaySets,\n      thumbnailImageSrcMap\n    );\n    sortStudyInstances(mappedDisplaySets);\n\n    setDisplaySets(mappedDisplaySets);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [thumbnailImageSrcMap]);\n\n  // ~~ subscriptions --> displaySets\n  useEffect(() => {\n    // DISPLAY_SETS_ADDED returns an array of DisplaySets that were added\n    const SubscriptionDisplaySetsAdded = displaySetService.subscribe(\n      displaySetService.EVENTS.DISPLAY_SETS_ADDED,\n      data => {\n        const { displaySetsAdded } = data;\n        displaySetsAdded.forEach(async dSet => {\n          const newImageSrcEntry = {};\n          const displaySet = displaySetService.getDisplaySetByUID(\n            dSet.displaySetInstanceUID\n          );\n          const imageIds = dataSource.getImageIdsForDisplaySet(displaySet);\n          const imageId = imageIds[Math.floor(imageIds.length / 2)];\n\n          // TODO: Is it okay that imageIds are not returned here for SR displaysets?\n          if (imageId) {\n            // When the image arrives, render it and store the result in the thumbnailImgSrcMap\n            newImageSrcEntry[dSet.displaySetInstanceUID] = await getImageSrc(\n              imageId,\n              dSet.initialViewport\n            );\n            if (isMounted.current) {\n              setThumbnailImageSrcMap(prevState => {\n                return { ...prevState, ...newImageSrcEntry };\n              });\n            }\n          }\n        });\n      }\n    );\n\n    // TODO: Will this always hold _all_ the displaySets we care about?\n    // DISPLAY_SETS_CHANGED returns `DisplaySerService.activeDisplaySets`\n    const SubscriptionDisplaySetsChanged = displaySetService.subscribe(\n      displaySetService.EVENTS.DISPLAY_SETS_CHANGED,\n      changedDisplaySets => {\n        const mappedDisplaySets = _mapDisplaySets(\n          changedDisplaySets,\n          thumbnailImageSrcMap\n        );\n        setDisplaySets(mappedDisplaySets);\n      }\n    );\n\n    return () => {\n      SubscriptionDisplaySetsAdded.unsubscribe();\n      SubscriptionDisplaySetsChanged.unsubscribe();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const tabs = _createStudyBrowserTabs(\n    StudyInstanceUIDs,\n    studyDisplayList,\n    displaySets\n  );\n\n  // TODO: Should not fire this on \"close\"\n  function _handleStudyClick(StudyInstanceUID) {\n    const shouldCollapseStudy = expandedStudyInstanceUIDs.includes(\n      StudyInstanceUID\n    );\n    const updatedExpandedStudyInstanceUIDs = shouldCollapseStudy\n      ? // eslint-disable-next-line prettier/prettier\n        [\n          ...expandedStudyInstanceUIDs.filter(\n            stdyUid => stdyUid !== StudyInstanceUID\n          ),\n        ]\n      : [...expandedStudyInstanceUIDs, StudyInstanceUID];\n\n    setExpandedStudyInstanceUIDs(updatedExpandedStudyInstanceUIDs);\n\n    if (!shouldCollapseStudy) {\n      const madeInClient = true;\n      requestDisplaySetCreationForStudy(\n        displaySetService,\n        StudyInstanceUID,\n        madeInClient\n      );\n    }\n  }\n\n  const activeDisplaySetInstanceUIDs =\n    viewports[activeViewportIndex]?.displaySetInstanceUIDs;\n\n  return (\n    <StudyBrowser\n      tabs={tabs}\n      servicesManager={servicesManager}\n      activeTabName={activeTabName}\n      onDoubleClickThumbnail={onDoubleClickThumbnailHandler}\n      activeDisplaySetInstanceUIDs={activeDisplaySetInstanceUIDs}\n      expandedStudyInstanceUIDs={expandedStudyInstanceUIDs}\n      onClickStudy={_handleStudyClick}\n      onClickTab={clickedTabName => {\n        setActiveTabName(clickedTabName);\n      }}\n    />\n  );\n}\n\nPanelStudyBrowser.propTypes = {\n  servicesManager: PropTypes.object.isRequired,\n  dataSource: PropTypes.shape({\n    getImageIdsForDisplaySet: PropTypes.func.isRequired,\n  }).isRequired,\n  getImageSrc: PropTypes.func.isRequired,\n  getStudiesForPatientByMRN: PropTypes.func.isRequired,\n  requestDisplaySetCreationForStudy: PropTypes.func.isRequired,\n};\n\nexport default PanelStudyBrowser;\n\n/**\n * Maps from the DataSource's format to a naturalized object\n *\n * @param {*} studies\n */\nfunction _mapDataSourceStudies(studies) {\n  return studies.map(study => {\n    // TODO: Why does the data source return in this format?\n    return {\n      AccessionNumber: study.accession,\n      StudyDate: study.date,\n      StudyDescription: study.description,\n      NumInstances: study.instances,\n      ModalitiesInStudy: study.modalities,\n      PatientID: study.mrn,\n      PatientName: study.patientName,\n      StudyInstanceUID: study.studyInstanceUid,\n      StudyTime: study.time,\n    };\n  });\n}\n\nfunction _mapDisplaySets(displaySets, thumbnailImageSrcMap) {\n  const thumbnailDisplaySets = [];\n  const thumbnailNoImageDisplaySets = [];\n\n  displaySets\n    .filter(ds => !ds.excludeFromThumbnailBrowser)\n    .forEach(ds => {\n      const imageSrc = thumbnailImageSrcMap[ds.displaySetInstanceUID];\n      const componentType = _getComponentType(ds.Modality);\n\n      const array =\n        componentType === 'thumbnail'\n          ? thumbnailDisplaySets\n          : thumbnailNoImageDisplaySets;\n\n      array.push({\n        displaySetInstanceUID: ds.displaySetInstanceUID,\n        description: ds.SeriesDescription || '',\n        seriesNumber: ds.SeriesNumber,\n        modality: ds.Modality,\n        seriesDate: ds.SeriesDate,\n        seriesTime: ds.SeriesTime,\n        numInstances: ds.numImageFrames,\n        countIcon: ds.countIcon,\n        StudyInstanceUID: ds.StudyInstanceUID,\n        componentType,\n        imageSrc,\n        dragData: {\n          type: 'displayset',\n          displaySetInstanceUID: ds.displaySetInstanceUID,\n          // .. Any other data to pass\n        },\n      });\n    });\n\n  return [...thumbnailDisplaySets, ...thumbnailNoImageDisplaySets];\n}\n\nconst thumbnailNoImageModalities = [\n  'SR',\n  'SEG',\n  'SM',\n  'RTSTRUCT',\n  'RTPLAN',\n  'RTDOSE',\n];\n\nfunction _getComponentType(Modality) {\n  if (thumbnailNoImageModalities.includes(Modality)) {\n    // TODO probably others.\n    return 'thumbnailNoImage';\n  }\n\n  return 'thumbnail';\n}\n\n/**\n *\n * @param {string[]} primaryStudyInstanceUIDs\n * @param {object[]} studyDisplayList\n * @param {string} studyDisplayList.studyInstanceUid\n * @param {string} studyDisplayList.date\n * @param {string} studyDisplayList.description\n * @param {string} studyDisplayList.modalities\n * @param {number} studyDisplayList.numInstances\n * @param {object[]} displaySets\n * @returns tabs - The prop object expected by the StudyBrowser component\n */\nfunction _createStudyBrowserTabs(\n  primaryStudyInstanceUIDs,\n  studyDisplayList,\n  displaySets\n) {\n  const primaryStudies = [];\n  const recentStudies = [];\n  const allStudies = [];\n\n  studyDisplayList.forEach(study => {\n    const displaySetsForStudy = displaySets.filter(\n      ds => ds.StudyInstanceUID === study.studyInstanceUid\n    );\n    const tabStudy = Object.assign({}, study, {\n      displaySets: displaySetsForStudy,\n    });\n\n    if (primaryStudyInstanceUIDs.includes(study.studyInstanceUid)) {\n      primaryStudies.push(tabStudy);\n    } else {\n      // TODO: Filter allStudies to dates within one year of current date\n      recentStudies.push(tabStudy);\n      allStudies.push(tabStudy);\n    }\n  });\n\n  const tabs = [\n    {\n      name: 'primary',\n      label: 'Primary',\n      studies: primaryStudies,\n    },\n    {\n      name: 'recent',\n      label: 'Recent',\n      studies: recentStudies,\n    },\n    {\n      name: 'all',\n      label: 'All',\n      studies: allStudies,\n    },\n  ];\n\n  return tabs;\n}\n","/**\n * @param {*} cornerstone\n * @param {*} imageId\n */\nfunction getImageSrcFromImageId(cornerstone, imageId) {\n  return new Promise((resolve, reject) => {\n    const canvas = document.createElement('canvas');\n    cornerstone.utilities\n      .loadImageToCanvas({ canvas, imageId })\n      .then(imageId => {\n        resolve(canvas.toDataURL());\n      })\n      .catch(reject);\n  });\n}\nexport default getImageSrcFromImageId;\n","async function getStudiesForPatientByMRN(dataSource, qidoForStudyUID) {\n  if (qidoForStudyUID && qidoForStudyUID.length && qidoForStudyUID[0].mrn) {\n    return dataSource.query.studies.search({\n      patientId: qidoForStudyUID[0].mrn,\n    });\n  }\n  console.log('No mrn found for', qidoForStudyUID);\n  return qidoForStudyUID;\n}\n\nexport default getStudiesForPatientByMRN;\n","function requestDisplaySetCreationForStudy(\n  dataSource,\n  displaySetService,\n  StudyInstanceUID,\n  madeInClient\n) {\n  // TODO: is this already short-circuited by the map of Retrieve promises?\n  if (\n    displaySetService.activeDisplaySets.some(\n      displaySet => displaySet.StudyInstanceUID === StudyInstanceUID\n    )\n  ) {\n    return;\n  }\n\n  dataSource.retrieve.series.metadata({ StudyInstanceUID, madeInClient });\n}\n\nexport default requestDisplaySetCreationForStudy;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n//\nimport PanelStudyBrowser from './PanelStudyBrowser';\nimport getImageSrcFromImageId from './getImageSrcFromImageId';\nimport getStudiesForPatientByMRN from './getStudiesForPatientByMRN';\nimport requestDisplaySetCreationForStudy from './requestDisplaySetCreationForStudy';\n\n/**\n * Wraps the PanelStudyBrowser and provides features afforded by managers/services\n *\n * @param {object} params\n * @param {object} commandsManager\n * @param {object} extensionManager\n */\nfunction WrappedPanelStudyBrowser({\n  commandsManager,\n  extensionManager,\n  servicesManager,\n}) {\n  // TODO: This should be made available a different way; route should have\n  // already determined our datasource\n  const dataSource = extensionManager.getDataSources()[0];\n  const _getStudiesForPatientByMRN = getStudiesForPatientByMRN.bind(\n    null,\n    dataSource\n  );\n  const _getImageSrcFromImageId = _createGetImageSrcFromImageIdFn(\n    extensionManager\n  );\n  const _requestDisplaySetCreationForStudy = requestDisplaySetCreationForStudy.bind(\n    null,\n    dataSource\n  );\n\n  return (\n    <PanelStudyBrowser\n      servicesManager={servicesManager}\n      dataSource={dataSource}\n      getImageSrc={_getImageSrcFromImageId}\n      getStudiesForPatientByMRN={_getStudiesForPatientByMRN}\n      requestDisplaySetCreationForStudy={_requestDisplaySetCreationForStudy}\n    />\n  );\n}\n\n/**\n * Grabs cornerstone library reference using a dependent command from\n * the @ohif/extension-cornerstone extension. Then creates a helper function\n * that can take an imageId and return an image src.\n *\n * @param {func} getCommand - CommandManager's getCommand method\n * @returns {func} getImageSrcFromImageId - A utility function powered by\n * cornerstone\n */\nfunction _createGetImageSrcFromImageIdFn(extensionManager) {\n  const utilities = extensionManager.getModuleEntry(\n    '@ohif/extension-cornerstone.utilityModule.common'\n  );\n\n  try {\n    const { cornerstone } = utilities.exports.getCornerstoneLibraries();\n    return getImageSrcFromImageId.bind(null, cornerstone);\n  } catch (ex) {\n    throw new Error('Required command not found');\n  }\n}\n\nWrappedPanelStudyBrowser.propTypes = {\n  commandsManager: PropTypes.object.isRequired,\n  extensionManager: PropTypes.object.isRequired,\n  servicesManager: PropTypes.object.isRequired,\n};\n\nexport default WrappedPanelStudyBrowser;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { useTranslation } from 'react-i18next';\n\nimport { Button, ButtonGroup } from '@ohif/ui';\n\nfunction ActionButtons({ onExportClick, onCreateReportClick }) {\n  const { t } = useTranslation('MeasurementTable');\n\n  return (\n    <React.Fragment>\n      <ButtonGroup color=\"black\" size=\"inherit\">\n        <Button className=\"px-2 py-2 text-base\" onClick={onExportClick}>\n          {t('Export CSV')}\n        </Button>\n        <Button className=\"px-2 py-2 text-base\" onClick={onCreateReportClick}>\n          {t('Create Report')}\n        </Button>\n      </ButtonGroup>\n    </React.Fragment>\n  );\n}\n\nActionButtons.propTypes = {\n  onExportClick: PropTypes.func,\n  onCreateReportClick: PropTypes.func,\n};\n\nActionButtons.defaultProps = {\n  onExportClick: () => alert('Export'),\n  onCreateReportClick: () => alert('Create Report'),\n};\n\nexport default ActionButtons;\n","/* eslint-disable react/display-name */\nimport React from 'react';\nimport { Dialog, Input, Select } from '@ohif/ui';\n\nexport const CREATE_REPORT_DIALOG_RESPONSE = {\n  CANCEL: 0,\n  CREATE_REPORT: 1,\n};\n\nexport default function createReportDialogPrompt(\n  uiDialogService,\n  { extensionManager }\n) {\n  return new Promise(function(resolve, reject) {\n    let dialogId = undefined;\n\n    const _handleClose = () => {\n      // Dismiss dialog\n      uiDialogService.dismiss({ id: dialogId });\n      // Notify of cancel action\n      resolve({\n        action: CREATE_REPORT_DIALOG_RESPONSE.CANCEL,\n        value: undefined,\n        dataSourceName: undefined,\n      });\n    };\n\n    /**\n     *\n     * @param {string} param0.action - value of action performed\n     * @param {string} param0.value - value from input field\n     */\n    const _handleFormSubmit = ({ action, value }) => {\n      uiDialogService.dismiss({ id: dialogId });\n      switch (action.id) {\n        case 'save':\n          resolve({\n            action: CREATE_REPORT_DIALOG_RESPONSE.CREATE_REPORT,\n            value: value.label,\n            dataSourceName: value.dataSourceName,\n          });\n          break;\n        case 'cancel':\n          resolve({\n            action: CREATE_REPORT_DIALOG_RESPONSE.CANCEL,\n            value: undefined,\n            dataSourceName: undefined,\n          });\n          break;\n      }\n    };\n\n    const dataSourcesOpts = Object.keys(extensionManager.dataSourceMap)\n      .filter(ds => {\n        const configuration =\n          extensionManager.dataSourceDefs[ds]?.configuration;\n        const supportsStow =\n          configuration?.supportsStow ?? configuration?.wadoRoot;\n        return supportsStow;\n      })\n      .map(ds => {\n        return {\n          value: ds,\n          label: ds,\n          placeHolder: ds,\n        };\n      });\n\n    dialogId = uiDialogService.create({\n      centralize: true,\n      isDraggable: false,\n      content: Dialog,\n      useLastPosition: false,\n      showOverlay: true,\n      contentProps: {\n        title: 'Create Report',\n        value: {\n          label: '',\n          dataSourceName: extensionManager.activeDataSource,\n        },\n        noCloseButton: true,\n        onClose: _handleClose,\n        actions: [\n          { id: 'cancel', text: 'Cancel', type: 'primary' },\n          { id: 'save', text: 'Save', type: 'secondary' },\n        ],\n        // TODO: Should be on button press...\n        onSubmit: _handleFormSubmit,\n        body: ({ value, setValue }) => {\n          const onChangeHandler = event => {\n            event.persist();\n            setValue(value => ({ ...value, label: event.target.value }));\n          };\n          const onKeyPressHandler = event => {\n            if (event.key === 'Enter') {\n              uiDialogService.dismiss({ id: dialogId });\n              resolve({\n                action: CREATE_REPORT_DIALOG_RESPONSE.CREATE_REPORT,\n                value: value.label,\n              });\n            }\n          };\n          return (\n            <>\n              {dataSourcesOpts.length > 1 && (\n                <Select\n                  closeMenuOnSelect={true}\n                  className=\"mr-2 bg-black border-primary-main\"\n                  options={dataSourcesOpts}\n                  placeholder={\n                    dataSourcesOpts.find(\n                      option => option.value === value.dataSourceName\n                    ).placeHolder\n                  }\n                  value={value.dataSourceName}\n                  onChange={evt => {\n                    setValue(v => ({ ...v, dataSourceName: evt.value }));\n                  }}\n                  isClearable={false}\n                />\n              )}\n              <Input\n                autoFocus\n                label=\"Enter the report name\"\n                labelClassName=\"text-white text-[14px] leading-[1.2]\"\n                className=\"bg-black border-primary-main\"\n                type=\"text\"\n                value={value.label}\n                onChange={onChangeHandler}\n                onKeyPress={onKeyPressHandler}\n                required\n              />\n            </>\n          );\n        },\n      },\n    });\n  });\n}\n","import React from 'react';\nimport { DicomMetadataStore } from '@ohif/core';\n\n/**\n *\n * @param {*} servicesManager\n * @param {*} dataSource\n * @param {*} measurements\n * @param {*} options\n * @returns {string[]} displaySetInstanceUIDs\n */\nasync function createReportAsync(\n  servicesManager,\n  commandsManager,\n  dataSource,\n  measurements,\n  options\n) {\n  const {\n    displaySetService,\n    uiNotificationService,\n    uiDialogService,\n  } = servicesManager.services;\n  const loadingDialogId = uiDialogService.create({\n    showOverlay: true,\n    isDraggable: false,\n    centralize: true,\n    // TODO: Create a loading indicator component + zeplin design?\n    content: Loading,\n  });\n\n  try {\n    const naturalizedReport = await commandsManager.runCommand(\n      'storeMeasurements',\n      {\n        measurementData: measurements,\n        dataSource,\n        additionalFindingTypes: ['ArrowAnnotate'],\n        options,\n      },\n      'CORNERSTONE_STRUCTURED_REPORT'\n    );\n\n    // The \"Mode\" route listens for DicomMetadataStore changes\n    // When a new instance is added, it listens and\n    // automatically calls makeDisplaySets\n    DicomMetadataStore.addInstances([naturalizedReport], true);\n\n    const displaySetInstanceUID = displaySetService.getMostRecentDisplaySet();\n\n    uiNotificationService.show({\n      title: 'Create Report',\n      message: 'Measurements saved successfully',\n      type: 'success',\n    });\n\n    return [displaySetInstanceUID];\n  } catch (error) {\n    uiNotificationService.show({\n      title: 'Create Report',\n      message: error.message || 'Failed to store measurements',\n      type: 'error',\n    });\n  } finally {\n    uiDialogService.dismiss({ id: loadingDialogId });\n  }\n}\n\nfunction Loading() {\n  return <div className=\"text-primary-active\">Loading...</div>;\n}\n\nexport default createReportAsync;\n","const MIN_SR_SERIES_NUMBER = 4700;\n\nexport default function getNextSRSeriesNumber(displaySetService) {\n  const activeDisplaySets = displaySetService.getActiveDisplaySets();\n  const srDisplaySets = activeDisplaySets.filter(ds => ds.Modality === 'SR');\n  const srSeriesNumbers = srDisplaySets.map(ds => ds.SeriesNumber);\n  const maxSeriesNumber = Math.max(...srSeriesNumbers, MIN_SR_SERIES_NUMBER);\n\n  return maxSeriesNumber + 1;\n}\n","import { DisplaySetService, Types } from '@ohif/core';\n\nimport getNextSRSeriesNumber from './getNextSRSeriesNumber';\n\n/**\n * Find an SR having the same series description.\n * This is used by the store service in order to store DICOM SR's having the\n * same Series Description into a single series under consecutive instance numbers\n * That way, they are all organized as a set and could have tools to view\n * \"prior\" SR instances.\n *\n * @param SeriesDescription - is the description to look for\n * @param displaySetService - the display sets to search for DICOM SR in\n * @returns SeriesMetadata from a DICOM SR having the same series description\n */\nexport default function findSRWithSameSeriesDescription(\n  SeriesDescription: string,\n  displaySetService: DisplaySetService\n): Types.SeriesMetadata {\n  const activeDisplaySets = displaySetService.getActiveDisplaySets();\n  const srDisplaySets = activeDisplaySets.filter(ds => ds.Modality === 'SR');\n  const sameSeries = srDisplaySets.find(\n    ds => ds.SeriesDescription === SeriesDescription\n  );\n  if (sameSeries) {\n    console.log('Storing to same series', sameSeries);\n    const { instance } = sameSeries;\n    const {\n      SeriesInstanceUID,\n      SeriesDescription,\n      SeriesDate,\n      SeriesTime,\n      SeriesNumber,\n      Modality,\n    } = instance;\n    return {\n      SeriesInstanceUID,\n      SeriesDescription,\n      SeriesDate,\n      SeriesTime,\n      SeriesNumber,\n      Modality,\n      InstanceNumber: sameSeries.instances.length + 1,\n    };\n  }\n\n  const SeriesNumber = getNextSRSeriesNumber(displaySetService);\n  return { SeriesDescription, SeriesNumber };\n}\n","import React, { useEffect, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { utils, ServicesManager } from '@ohif/core';\nimport { MeasurementTable, Dialog, Input, useViewportGrid } from '@ohif/ui';\nimport ActionButtons from './ActionButtons';\nimport debounce from 'lodash.debounce';\n\nimport createReportDialogPrompt, {\n  CREATE_REPORT_DIALOG_RESPONSE,\n} from './createReportDialogPrompt';\nimport createReportAsync from '../Actions/createReportAsync';\nimport findSRWithSameSeriesDescription from '../utils/findSRWithSameSeriesDescription';\n\nconst { downloadCSVReport } = utils;\n\nexport default function PanelMeasurementTable({\n  servicesManager,\n  commandsManager,\n  extensionManager,\n}): React.FunctionComponent {\n  const [viewportGrid, viewportGridService] = useViewportGrid();\n  const { activeViewportIndex, viewports } = viewportGrid;\n  const {\n    measurementService,\n    uiDialogService,\n    uiNotificationService,\n    displaySetService,\n  } = (servicesManager as ServicesManager).services;\n  const [displayMeasurements, setDisplayMeasurements] = useState([]);\n\n  useEffect(() => {\n    const debouncedSetDisplayMeasurements = debounce(\n      setDisplayMeasurements,\n      100\n    );\n    // ~~ Initial\n    setDisplayMeasurements(_getMappedMeasurements(measurementService));\n\n    // ~~ Subscription\n    const added = measurementService.EVENTS.MEASUREMENT_ADDED;\n    const addedRaw = measurementService.EVENTS.RAW_MEASUREMENT_ADDED;\n    const updated = measurementService.EVENTS.MEASUREMENT_UPDATED;\n    const removed = measurementService.EVENTS.MEASUREMENT_REMOVED;\n    const cleared = measurementService.EVENTS.MEASUREMENTS_CLEARED;\n    const subscriptions = [];\n\n    [added, addedRaw, updated, removed, cleared].forEach(evt => {\n      subscriptions.push(\n        measurementService.subscribe(evt, () => {\n          debouncedSetDisplayMeasurements(\n            _getMappedMeasurements(measurementService)\n          );\n        }).unsubscribe\n      );\n    });\n\n    return () => {\n      subscriptions.forEach(unsub => {\n        unsub();\n      });\n      debouncedSetDisplayMeasurements.cancel();\n    };\n  }, []);\n\n  async function exportReport() {\n    const measurements = measurementService.getMeasurements();\n\n    downloadCSVReport(measurements, measurementService);\n  }\n\n  async function clearMeasurements() {\n    measurementService.clearMeasurements();\n  }\n\n  async function createReport(): Promise<any> {\n    // filter measurements that are added to the active study\n    const activeViewport = viewports[activeViewportIndex];\n    const measurements = measurementService.getMeasurements();\n    const displaySet = displaySetService.getDisplaySetByUID(\n      activeViewport.displaySetInstanceUIDs[0]\n    );\n    const trackedMeasurements = measurements.filter(\n      m => displaySet.StudyInstanceUID === m.referenceStudyUID\n    );\n\n    if (trackedMeasurements.length <= 0) {\n      uiNotificationService.show({\n        title: 'No Measurements',\n        message: 'No Measurements are added to the current Study.',\n        type: 'info',\n        duration: 3000,\n      });\n      return;\n    }\n\n    const promptResult = await createReportDialogPrompt(uiDialogService, {\n      extensionManager,\n    });\n\n    if (promptResult.action === CREATE_REPORT_DIALOG_RESPONSE.CREATE_REPORT) {\n      const dataSources = extensionManager.getDataSources(\n        promptResult.dataSourceName\n      );\n      const dataSource = dataSources[0];\n\n      const SeriesDescription =\n        // isUndefinedOrEmpty\n        promptResult.value === undefined || promptResult.value === ''\n          ? 'Research Derived Series' // default\n          : promptResult.value; // provided value\n\n      // Re-use an existing series having the same series description to avoid\n      // creating too many series instances.\n      const options = findSRWithSameSeriesDescription(\n        SeriesDescription,\n        displaySetService\n      );\n\n      return createReportAsync(\n        servicesManager,\n        commandsManager,\n        dataSource,\n        trackedMeasurements,\n        options\n      );\n    }\n  }\n\n  const jumpToImage = ({ uid, isActive }) => {\n    measurementService.jumpToMeasurement(viewportGrid.activeViewportIndex, uid);\n\n    onMeasurementItemClickHandler({ uid, isActive });\n  };\n\n  const onMeasurementItemEditHandler = ({ uid, isActive }) => {\n    const measurement = measurementService.getMeasurement(uid);\n    //Todo: why we are jumping to image?\n    // jumpToImage({ id, isActive });\n\n    const onSubmitHandler = ({ action, value }) => {\n      switch (action.id) {\n        case 'save': {\n          measurementService.update(\n            uid,\n            {\n              ...measurement,\n              ...value,\n            },\n            true\n          );\n        }\n      }\n      uiDialogService.dismiss({ id: 'enter-annotation' });\n    };\n\n    uiDialogService.create({\n      id: 'enter-annotation',\n      centralize: true,\n      isDraggable: false,\n      showOverlay: true,\n      content: Dialog,\n      contentProps: {\n        title: 'Annotation',\n        noCloseButton: true,\n        value: { label: measurement.label || '' },\n        body: ({ value, setValue }) => {\n          const onChangeHandler = event => {\n            event.persist();\n            setValue(value => ({ ...value, label: event.target.value }));\n          };\n\n          const onKeyPressHandler = event => {\n            if (event.key === 'Enter') {\n              onSubmitHandler({ value, action: { id: 'save' } });\n            }\n          };\n          return (\n            <Input\n              label=\"Enter your annotation\"\n              labelClassName=\"text-white text-[14px] leading-[1.2]\"\n              autoFocus\n              id=\"annotation\"\n              className=\"bg-black border-primary-main\"\n              type=\"text\"\n              value={value.label}\n              onChange={onChangeHandler}\n              onKeyPress={onKeyPressHandler}\n            />\n          );\n        },\n        actions: [\n          // temp: swap button types until colors are updated\n          { id: 'cancel', text: 'Cancel', type: 'primary' },\n          { id: 'save', text: 'Save', type: 'secondary' },\n        ],\n        onSubmit: onSubmitHandler,\n      },\n    });\n  };\n\n  const onMeasurementItemClickHandler = ({ uid, isActive }) => {\n    if (!isActive) {\n      const measurements = [...displayMeasurements];\n      const measurement = measurements.find(m => m.uid === uid);\n\n      measurements.forEach(m => (m.isActive = m.uid !== uid ? false : true));\n      measurement.isActive = true;\n      setDisplayMeasurements(measurements);\n    }\n  };\n\n  return (\n    <>\n      <div\n        className=\"overflow-x-hidden overflow-y-auto ohif-scrollbar\"\n        data-cy={'measurements-panel'}\n      >\n        <MeasurementTable\n          title=\"Measurements\"\n          servicesManager={servicesManager}\n          data={displayMeasurements}\n          onClick={jumpToImage}\n          onEdit={onMeasurementItemEditHandler}\n        />\n      </div>\n      <div className=\"flex justify-center p-4\">\n        <ActionButtons\n          onExportClick={exportReport}\n          onClearMeasurementsClick={clearMeasurements}\n          onCreateReportClick={createReport}\n        />\n      </div>\n    </>\n  );\n}\n\nPanelMeasurementTable.propTypes = {\n  servicesManager: PropTypes.instanceOf(ServicesManager).isRequired,\n};\n\nfunction _getMappedMeasurements(measurementService) {\n  const measurements = measurementService.getMeasurements();\n\n  const mappedMeasurements = measurements.map((m, index) =>\n    _mapMeasurementToDisplay(m, index, measurementService.VALUE_TYPES)\n  );\n\n  return mappedMeasurements;\n}\n\n/**\n * Map the measurements to the display text.\n * Adds finding and site inforamtion to the displayText and/or label,\n * and provides as 'displayText' and 'label', while providing the original\n * values as baseDisplayText and baseLabel\n */\nfunction _mapMeasurementToDisplay(measurement, index, types) {\n  const {\n    displayText: baseDisplayText,\n    uid,\n    label: baseLabel,\n    type,\n    selected,\n    findingSites,\n    finding,\n  } = measurement;\n\n  const firstSite = findingSites?.[0];\n  const label = baseLabel || finding?.text || firstSite?.text || '(empty)';\n  let displayText = baseDisplayText || [];\n  if (findingSites) {\n    const siteText = [];\n    findingSites.forEach(site => {\n      if (site?.text !== label) siteText.push(site.text);\n    });\n    displayText = [...siteText, ...displayText];\n  }\n  if (finding && finding?.text !== label) {\n    displayText = [finding.text, ...displayText];\n  }\n\n  return {\n    uid,\n    label,\n    baseLabel,\n    measurementType: type,\n    displayText,\n    baseDisplayText,\n    isActive: selected,\n    finding,\n    findingSites,\n  };\n}\n","import vtkPolyData from \"@kitware/vtk.js/Common/DataModel/PolyData\";\n\nclass PolyDataExtractor {\n    constructor(polyData) {\n        console.assert(polyData.getLinks(), 'PolyDataExtractor: No links built for polydata');\n        this.polyData = polyData;\n        this.visitedCells = new Array(polyData.getNumberOfCells()).fill(false);\n        this.visitedPoints = new Array(polyData.getNumberOfPoints()).fill(false);\n    }\n\n    _extractGroup = (neighborIds) => {\n        const cellGroup = [];\n        const pointGroup = [];\n        this.visitedCells[neighborIds[0]] = true;\n\n        // Iterate over cells (breadth-first search)\n        while (neighborIds.length > 0) {\n            const currentCellId = neighborIds.shift();\n            cellGroup.push(currentCellId);\n\n            // Iterate over cell points\n            const pointIds = this.polyData.getCellPoints(currentCellId).cellPointIds;\n            for (const pointId of pointIds) {\n                if (!this.visitedPoints[pointId]) {\n                    this.visitedPoints[pointId] = true;\n                    pointGroup.push(pointId);\n\n                    // Add unvisited cells to the queue\n                    for (const neighborCellId of this.polyData.getPointCells(pointId)) {\n                        if (!this.visitedCells[neighborCellId]) {\n                            this.visitedCells[neighborCellId] = true;\n                            neighborIds.push(neighborCellId);\n                        }\n                    }\n                }\n            }\n        }\n\n        return [cellGroup, pointGroup]\n    }\n\n    _buildExtractedPolyData = (cellGroup, pointGroup) => {\n        const pBuffer = []; // Points\n        const tBuffer = []; // Cells\n        const pointIdMap = {};\n        // Map former point IDs to new point IDs\n        pointGroup.forEach((pointId, idx) => {\n            pointIdMap[pointId] = idx;\n            const points = this.polyData.getPoints().getPoint(pointId);\n            pBuffer.push(...points);\n        });\n        for (const cellId of cellGroup) {\n            const pointIds = this.polyData.getCellPoints(cellId).cellPointIds;\n            const newPointIds = pointIds.map(pointId => pointIdMap[pointId]);\n            tBuffer.push(3);\n            tBuffer.push(...newPointIds);\n        }\n\n        const extractedPolyData = vtkPolyData.newInstance();\n        extractedPolyData.getPoints().setData(new Float32Array(pBuffer), 3);\n        extractedPolyData.getPolys().setData(new Uint32Array(tBuffer));\n        extractedPolyData.getPolys().setNumberOfComponents(4);\n\n        return extractedPolyData;\n    }\n\n    extractGroups = () => {\n        const cellGroups = [];\n        const pointGroups = [];\n        const extractedPolyDatas = [];\n        for (let cellId = 0; cellId < this.polyData.getNumberOfCells(); cellId++) {\n            if (!this.visitedCells[cellId]) {\n                const [cellGroup, pointGroup] = this._extractGroup([cellId]);\n                const extractedPolyData = this._buildExtractedPolyData(cellGroup, pointGroup);\n                extractedPolyDatas.push(extractedPolyData);\n            }\n        }\n\n        return extractedPolyDatas;\n    }\n\n}\n\nexport default PolyDataExtractor;\n","import vtkPolyData from \"@kitware/vtk.js/Common/DataModel/PolyData\";\nimport vtkMath from \"@kitware/vtk.js/Common/Core/Math\";\nconst math = require('mathjs');\n\nclass Quadric {\n    constructor(points) {\n        // Quadric matrix in format (A, b, c). A is a 3x3 matrix, b is a Vector3 and c a constant\n        // This represents the 10 coefficients of a 4x4 quadric matrix that can be computed using\n        // the cartesian coefficients of a plane or with its normal vector and its centroid\n        const n = this.getNormal(points);\n        const p = this.getCentroid(points);\n\n        // Coefficients of symmetric 3x3 matrix: a11, a12, a13, a22, a23, a33\n        this.Axx = n[0] * n[0];\n        this.Axy = n[0] * n[1];\n        this.Axz = n[0] * n[2];\n        this.Ayy = n[1] * n[1];\n        this.Ayz = n[1] * n[2];\n        this.Azz = n[2] * n[2];\n\n        const vx = this.Axx * p[0] + this.Axy * p[1] + this.Axz * p[2];\n        const vy = this.Axy * p[0] + this.Ayy * p[1] + this.Ayz * p[2];\n        const vz = this.Axz * p[0] + this.Ayz * p[1] + this.Azz * p[2];\n        this.bx = -vx;\n        this.by = -vy;\n        this.bz = -vz;\n\n        this.c = math.dot(p, [vx, vy, vz]);\n    }\n\n    add = (quadric) => {\n        this.Axx += quadric.Axx;\n        this.Axy += quadric.Axy;\n        this.Axz += quadric.Axz;\n        this.Ayy += quadric.Ayy;\n        this.Ayz += quadric.Ayz;\n        this.Azz += quadric.Azz;\n        this.bx += quadric.bx;\n        this.by += quadric.by;\n        this.bz += quadric.bz;\n        this.c += quadric.c;\n\n        return this;\n    }\n\n    getCentroid = (points) => {\n        // Get the center point of a triangle\n        const [p0, p1, p2] = points;\n        return [\n            (p0[0] + p1[0] + p2[0]) / 3,\n            (p0[1] + p1[1] + p2[1]) / 3,\n            (p0[2] + p1[2] + p2[2]) / 3\n        ];\n    }\n\n    getNormal = (points) => {\n        // Get the normal vector of a triangle\n        // This is obtained by normalizing the cross-product of vectors p1-p0 and p2-p0\n        const [p0, p1, p2] = points;\n        let p10 = new Array(3);\n        let p20 = new Array(3);\n        let n = new Array(3);\n\n        vtkMath.subtract(p1, p0, p10);\n        vtkMath.subtract(p2, p0, p20);\n        vtkMath.cross(p10, p20, n);\n        vtkMath.normalize(n);\n\n        return n;\n    }\n\n    // Computes the error cost over a point p\n    // Return p.T@A@p + 2*p.T@b + c\n    evaluate = (point) => {\n        const x = this.Axx * point[0] + this.Axy * point[1] + this.Axz * point[2];\n        const y = this.Axy * point[0] + this.Ayy * point[1] + this.Ayz * point[2];\n        const z = this.Axz * point[0] + this.Ayz * point[1] + this.Azz * point[2];\n        const error = (point[0] * x + point[1] * y + point[2] * z)\n            + 2 * (point[0] * this.bx + point[1] * this.by + point[2] * this.bz) + this.c;\n\n        return error;\n    }\n\n    optimalPoint = (v_) => {\n        // The computation of optimal point for quadric Q_ corresponds to doing -A.inv()@b\n        let a11 = this.Azz * this.Ayy - this.Ayz * this.Ayz;\n        let a12 = this.Axz * this.Ayz - this.Azz * this.Axy;\n        let a13 = this.Axy * this.Ayz - this.Axz * this.Ayy;\n        let a22 = this.Azz * this.Axx - this.Axz * this.Axz;\n        let a23 = this.Axy * this.Axz - this.Axx * this.Ayz;\n        let a33 = this.Axx * this.Ayy - this.Axy * this.Axy;\n        let det = (this.Axx * a11) + (this.Axy * a12) + (this.Axz * a13);\n\n        // Check if the matrix is not singular (non invertible) or almost not singular (< epsilon)\n        if (math.abs(det) > 0.000000001) {\n            det = 1.0 / det;\n            a11 *= det;\n            a12 *= det;\n            a13 *= det;\n            a22 *= det;\n            a23 *= det;\n            a33 *= det;\n            // Return value is parameter v_\n            v_[0] = -(a11 * this.bx + a12 * this.by + a13 * this.bz);\n            v_[1] = -(a12 * this.bx + a22 * this.by + a23 * this.bz);\n            v_[2] = -(a13 * this.bx + a23 * this.by + a33 * this.bz);\n            return true;\n        } else {\n            // Cannot compute optimal point\n            // Needs to take the best point between the middle point and the ends\n            return false;\n        }\n    }\n}\n\nfunction VertexPairCost(v1Id, v2Id, cost, v_) {\n    this.v1Id = v1Id;\n    this.v2Id = v2Id;\n    this.cost = cost;\n    this.v_ = v_;\n}\n\nclass QuadricDecimator {\n    constructor(polyData, targetReduction = 0.5) {\n        console.log('QuadricDecimation: Init QuadricDecimator');\n        this.polyData = this.copy(polyData);\n        this.targetReduction = targetReduction;\n\n        this.points = this.polyData.getPoints();\n        if (!this.polyData.getLinks()) {\n            console.log('QuadricDecimation: Build Links');\n            this.polyData.buildLinks();\n        }\n        console.log('QuadricDecimation: Init Lines');\n        // Store lines in a different structure prevent function overload\n        this.lines = this.initLines();\n        //this.neighbors = this.initNeighbors();\n\n        console.log('QuadricDecimation: Init QMatrices');\n        this.qMatrices = this.initQuadricMatrices();\n        console.log('QuadricDecimation: Init PairCosts');\n        this.pairCosts = this.initPairCosts();\n        this.currentNumberOfCells = this.polyData.getNumberOfCells();\n        this.currentNumberOfPoints = this.polyData.getNumberOfPoints();\n    }\n\n    copy = (polyData) => {\n        const copy = vtkPolyData.newInstance();\n        copy.getPoints().setData(polyData.getPoints().getTuples(), 3);\n        copy.getPolys().setData(polyData.getPolys().getTuples());\n        copy.getPolys().setNumberOfComponents(4);\n\n        return copy;\n    }\n\n    setTargetReduction = (target_reduction) => {\n        this.target_reduction = target_reduction;\n    }\n\n    initLines = () => {\n        const lineSet = new Set();\n        for (let cellId = 0; cellId < this.polyData.getNumberOfCells(); cellId++) {\n            const pointIds = this.polyData.getCellPoints(cellId).cellPointIds;\n            const [pointId1, pointId2, pointId3] = pointIds.sort((a, b) => a - b);\n            lineSet.add(`${pointId1}-${pointId2}`);\n            lineSet.add(`${pointId1}-${pointId3}`);\n            lineSet.add(`${pointId2}-${pointId3}`);\n        }\n\n        const lines = Array.from(lineSet).sort((a, b) => {\n            const [id1A, id2A] = a.split('-').map(Number);\n            const [id1B, id2B] = b.split('-').map(Number);\n            return (id1A - id1B) || (id2A - id2B);\n        });\n\n        return lines;\n    }\n\n    initNeighbors = () => {\n        let neighbors = Array.from( { length: this.polyData.getNumberOfPoints() }, () => new Set());\n        for (const line of this.lines) {\n            const [pointId1, pointId2] = line.split('-').map(Number);\n            neighbors[pointId1].add(pointId2);\n            neighbors[pointId2].add(pointId1);\n        }\n\n        return neighbors;\n    }\n\n    initQuadricMatrices = () => {\n        // QuadricMatrices contains a 4-4 matrix of coefficients at each point\n        let quadricMatrices = Array.from({ length: this.polyData.getNumberOfPoints() });\n\n        // Loop over all cells to fill the Q matrices for all initial vertices\n        for (let cellId = 0; cellId < this.polyData.getNumberOfCells(); cellId++) {\n            const pointIds = Array.from(this.polyData.getCellPoints(cellId).cellPointIds);\n            const points = pointIds.map(pointId => this.points.getPoint(pointId));\n\n            // Old method storing values in a 16 components\n            // p = [a b c d] represents the plane defined by the equation ax + by + cz + d = 0\n            // Kp = p@p^t = [[a,ab,ac,ad],[ab,b,bc,bd],[ac,bc,c,cd],[ad,bd,cd,d]]\n            /*const k = math.multiply(math.transpose([p]), [p]);\n            for (const pointId of pointIds) {\n                quadricMatrices[pointId] = math.add(quadricMatrices[pointId], k);\n            }*/\n\n            // New method storing same values in 10 components\n            const q = new Quadric(points);\n            for (const pointId of pointIds) {\n                if (!quadricMatrices[pointId]) {\n                    quadricMatrices[pointId] = q;\n                } else {\n                    quadricMatrices[pointId].add(q);\n                }\n            }\n        }\n\n        return quadricMatrices;\n    }\n\n    _computeQ_V_Cost = (pointId1, pointId2) => {\n        // Compute Q_\n        const q1 = this.qMatrices[pointId1];\n        const q2 = this.qMatrices[pointId2];\n        const q_ = q1.add(q2);\n\n\n        // Compute V_\n        let v_ = Array.from( {length: 3} );\n        let cost;\n        // Compute optimal point from Quadric Q_\n        if (q_.optimalPoint(v_)) {\n            cost = q_.evaluate(v_);\n        } else {\n            // Need to compare middle point with ends\n            const p1 = this.points.getPoint(pointId1);\n            const p2 = this.points.getPoint(pointId2);\n            const middlePoint = [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2, (p1[2] + p2[2]) / 2];\n            const errorP1 = q_.evaluate(p1);\n            const errorP2 = q_.evaluate(p2);\n            const errorMp = q_.evaluate(middlePoint);\n            if (errorP1 < errorP2 && errorP1 < errorMp) {\n                v_ = p1;\n                cost = errorP1;\n            } else if (errorP2 < errorMp) {\n                v_ = p2;\n                cost = errorP2;\n            } else {\n                v_ = middlePoint;\n                cost = errorMp;\n            }\n        }\n\n        return [q_, v_, cost];\n    }\n\n    initPairCosts = () => {\n        let pairCosts = Array.from({ length: this.lines.length }).fill(false);;\n        const nbPairs = this.lines.length;\n        console.log(`QuadricDecimation - vertex pairs: ${nbPairs}`);\n        this.lines.forEach((line, lineId) => {\n            const [pointId1, pointId2] = line.split('-').map(Number);\n            const [q_, v_, cost] = this._computeQ_V_Cost(pointId1, pointId2);\n            const pairCost = new VertexPairCost(Number(pointId1), Number(pointId2), cost, v_);\n            pairCosts[lineId] = pairCost;\n        });\n\n        return pairCosts;\n    }\n\n    buildMinHeap = () => {\n        const heapSize = this.pairCosts.length;\n\n        // Start from the last non-leaf node and heapify each node\n        for (let i = ~~(heapSize / 2) - 1; i >= 0; i--) {\n          this.heapify(i, heapSize);\n        }\n    }\n\n    heapify = (index, heapSize) => {\n        const costs = this.pairCosts;\n        const leftChildIndex = 2 * index + 1;\n        const rightChildIndex = 2 * index + 2;\n        let smallestIndex = index;\n\n        // Compare with left child\n        if (leftChildIndex < heapSize && costs[leftChildIndex].cost < costs[smallestIndex].cost) {\n          smallestIndex = leftChildIndex;\n        }\n\n        // Compare with right child\n        if (rightChildIndex < heapSize && costs[rightChildIndex].cost < costs[smallestIndex].cost) {\n          smallestIndex = rightChildIndex;\n        }\n\n        // If the smallest element is not the current root, or if it has the same cost,\n        // v1Id, and v2Id, swap them and recursively heapify\n        if (smallestIndex !== index) {\n            [costs[index], costs[smallestIndex]] = [costs[smallestIndex], costs[index]];\n            this.heapify(smallestIndex, heapSize);\n        }\n    }\n\n    extractMin = () => {\n        if (this.pairCosts.length === 0) {\n          return null; // Heap is empty\n        }\n\n        const minElement = this.pairCosts[0];\n\n        // Replace the root with the last element\n        this.pairCosts[0] = this.pairCosts.pop();\n\n        // Restore the heap property starting from the root\n        this.heapify(0, this.pairCosts.length);\n\n        return minElement;\n    }\n\n    _updateCells = (minPairCost) => {\n        const minV1Id = minPairCost.v1Id;\n        const minV2Id = minPairCost.v2Id;\n\n        // Remove cells with edge minV1-minV2\n        const neighborCells = this.polyData.getCellEdgeNeighbors(-1, minV1Id, minV2Id);\n        for (const cellId of neighborCells) {\n            // Remove reference from points to cell\n            const pointIds = this.polyData.getCellPoints(cellId).cellPointIds;\n            for (const pointId of pointIds) {\n                this.polyData.getLinks().removeCellReference(cellId, pointId);\n            }\n            this.polyData.getCells().deleteCell(cellId);\n            this.currentNumberOfCells--;\n            // Store IDs of deleted cells for reallocation\n            this.deletedCells[cellId] = true;\n        }\n\n        // Replace occurrences of minV2 with minV1\n        for (const cellId of this.polyData.getPointCells(minV2Id)) {\n            if (!this.deletedCells[cellId]) {\n                let pointIds = this.polyData.getCellPoints(cellId).cellPointIds;\n                pointIds = pointIds.map((pointId) => (pointId === minV2Id) ? minV1Id : pointId);\n                this.polyData.getPolys().setTuple(cellId, [3, ...pointIds]);\n\n                // Add reference to cell for minV1\n                if (!neighborCells.includes(cellId)) {\n                    this.polyData.getLinks().insertNextCellReference(minV1Id, cellId);\n                }\n            }\n        }\n    }\n\n    _updatePoints = (minPairCost) => {\n        const minV1Id = minPairCost.v1Id;\n        const minV2Id = minPairCost.v2Id;\n        const minV_ = minPairCost.v_;\n\n        // Update coordinates of v1 with v_, delete v2\n        this.points.setPoint(minV1Id, minV_[0], minV_[1], minV_[2]);\n\n        this.deletedPoints[minV2Id] = true;\n        this.polyData.getLinks().deletePoint(minV2Id);\n        --this.currentNumberOfPoints;\n    }\n\n    _updatePairCosts = (minPairCost) => {\n        const minV1Id = minPairCost.v1Id;\n        const minV2Id = minPairCost.v2Id;\n\n        // Update edges optimal contraction and cost\n        for (let pairId = 0; pairId < this.pairCosts.length; pairId++) {\n            const curV1Id = this.pairCosts[pairId].v1Id;\n            const curV2Id = this.pairCosts[pairId].v2Id;\n            // Update v_ and cost as minV1 got updated\n            if (curV1Id === minV1Id || curV2Id === minV1Id) {\n                const [newQ_, newV_, newCost] = this._computeQ_V_Cost(curV1Id, curV2Id);\n                this.pairCosts[pairId] = new VertexPairCost(curV1Id, curV2Id, newCost, newV_);\n            }\n            // Replace minV2 with minV1 as minV2 got removed, then update v_ and cost\n            else if (curV1Id === minV2Id || curV2Id === minV2Id) {\n                const otherVId = (curV1Id !== minV2Id)? curV1Id : curV2Id;\n                const [newV1Id, newV2Id] = [minV1Id, otherVId].sort((a, b) => a - b);\n                const [newQ_, newV_, newCost] = this._computeQ_V_Cost(newV1Id, newV2Id);\n                if (this.pairCosts.some(pairCost => pairCost.v1Id === newV1Id && pairCost.v2Id === newV2Id)) {\n                    // Remove element\n                    const lastIndex = this.pairCosts.length - 1;\n                    [this.pairCosts[pairId], this.pairCosts[lastIndex]] = [this.pairCosts[lastIndex], this.pairCosts[pairId]];\n                    this.pairCosts.pop();\n                    pairId--;\n                } else {\n                    this.pairCosts[pairId] = new VertexPairCost(newV1Id, newV2Id, newCost, newV_);\n                }\n            }\n        }\n    }\n\n    _removeDegenerate = (pointId) => {\n        // Remove degenerate cells\n        // TODO Some code duplicate\n        if (this.deletedPoints[pointId]) {\n            return;\n        }\n\n        for (const cellId of this.polyData.getPointCells(pointId)) {\n            const degenerateCellPointIds = this.polyData.getCellPoints(cellId).cellPointIds;\n            for (const degenerateCellPointId of degenerateCellPointIds) {\n                this.polyData.getLinks().removeCellReference(cellId, degenerateCellPointId);\n            }\n            this.polyData.getCells().deleteCell(cellId);\n            this.currentNumberOfCells--;\n            this.deletedCells[cellId] = true;\n        }\n\n        // Delete degenerate point\n        this.deletedPoints[pointId] = true;\n        this.polyData.getLinks().deletePoint(pointId);\n        --this.currentNumberOfPoints;\n\n        // Delete degenerate pairs\n        for (let pairId = 0; pairId < this.pairCosts.length; pairId++) {\n            let pairCost = this.pairCosts[pairId];\n            if (pairCost.v1Id === pointId || pairCost.v2Id === pointId) {\n                const lastIndex = this.pairCosts.length - 1;\n                [this.pairCosts[pairId], this.pairCosts[lastIndex]] = [this.pairCosts[lastIndex], this.pairCosts[pairId]];\n                this.pairCosts.pop();\n                pairId--;\n            }\n        }\n\n        // Remove neighbors\n        const pointNeighbors = Array.from(this.neighbors[pointId]);\n        for (const neighborPointId of pointNeighbors) {\n            this.neighbors[neighborPointId].delete(pointId);\n        }\n        this.neighbors[pointId].clear();\n        /*for (const neighborPointId of pointNeighbors) {\n            if (this.neighbors[neighborPointId].size < 3 || this.polyData.getPointCells(neighborPointId).length < 3) {\n                this._removeDegenerate(neighborPointId);\n            }\n        }*/\n    }\n\n    _updateNeighbors = (minPairCost) => {\n        const minV1Id = minPairCost.v1Id;\n        const minV2Id = minPairCost.v2Id;\n\n        const minV2Neighbors = Array.from(this.neighbors[minV2Id]);\n        // Remove references from points to minV2\n        for (const pointId of minV2Neighbors) {\n            this.neighbors[pointId].delete(minV2Id);\n            if (pointId !== minV1Id) {\n                this.neighbors[pointId].add(minV1Id);\n                this.neighbors[minV1Id].add(pointId);\n            }\n        }\n        this.neighbors[minV2Id].clear();\n        /*for (const pointId of minV2Neighbors) {\n            if (this.neighbors[pointId].size < 3 || this.polyData.getPointCells(pointId).length < 3) { // Degenerate Point\n                this._removeDegenerate(pointId);\n            }\n        }*/\n    }\n\n    decimate = () => {\n        if (this.targetReduction <= 0. || this.targetReduction >= 1.) {\n            return this.polyData;\n        }\n\n        const originalNumberOfCells = this.polyData.getNumberOfCells();\n        const originalNumberOfPoints = this.polyData.getNumberOfPoints();\n        const targetNumberOfCells = ~~(this.targetReduction * originalNumberOfCells);\n        this.deletedCells = Array.from({ length: originalNumberOfCells }).fill(false);\n        this.deletedPoints = Array.from({ length: originalNumberOfPoints }).fill(false);\n\n        this.buildMinHeap();\n        while (this.currentNumberOfCells > targetNumberOfCells) {\n            if ((originalNumberOfCells - this.currentNumberOfCells) % 100 === 0) {\n                console.log(`QuadricDecimation - cells destroyed: ${originalNumberOfCells - this.currentNumberOfCells}`\n                            + ` / ${originalNumberOfCells - targetNumberOfCells}`);\n            }\n            const minPairCost = this.extractMin();\n            this._updateCells(minPairCost);\n            this._updatePoints(minPairCost);\n            this._updatePairCosts(minPairCost);\n            //this._updateNeighbors(minPairCost);\n            this.buildMinHeap();\n        }\n\n        /*for (let pointId = 0; pointId < originalNumberOfPoints; pointId++) {\n            if (!this.deletedPoints[pointId] && this.polyData.getLinks().getLink(0).ncells < 3) {\n                this._removeDegenerate(pointId);\n            }\n        }*/\n\n        // TODO Reallocate points and polys\n        let pBuffer = [];\n        let tBuffer = [];\n        let pointMap = Array.from({ length: originalNumberOfPoints }).fill(-1);\n        /*let b = false;\n        while (!b) {\n            b = true;\n            for (let pointId = 0; pointId < originalNumberOfPoints; pointId++) {\n                if (!this.deletedPoints[pointId] && (this.neighbors[pointId].size < 3 || this.polyData.getPointCells(pointId).length < 3)) { // Degenerate Point\n                    b = false;\n                    console.log(originalNumberOfPoints)\n                    this._removeDegenerate(pointId);\n                }\n            }\n        }*/\n\n        let i = 0;\n        for (let pointId = 0; pointId < originalNumberOfPoints; pointId++) {\n            if (!this.deletedPoints[pointId]) {\n                pBuffer.push(...this.points.getPoint(pointId));\n                pointMap[pointId] = i;\n                i++;\n            }\n        }\n        for (let cellId = 0; cellId < originalNumberOfCells; cellId++) {\n            if (!this.deletedCells[cellId]) {\n                tBuffer.push(3);\n                let pointIds = this.polyData.getCellPoints(cellId).cellPointIds;\n                pointIds = pointIds.map(pointId => pointMap[pointId]);\n                tBuffer.push(...Array.from(pointIds));\n            }\n        }\n\n        const newPolyData = vtkPolyData.newInstance();\n        newPolyData.getPoints().setData(new Float32Array(pBuffer), 3)\n        newPolyData.getPolys().setData(new Uint32Array(tBuffer));\n        newPolyData.getPolys().setNumberOfComponents(4);\n\n        return newPolyData;\n    }\n}\n\nexport default QuadricDecimator;\n","// THIS FILE IS A MODIFIED COPY OF @kitware/vtk.js\nimport { m as macro } from '@kitware/vtk.js/macros2.js';\nimport vtkDataArray from '@kitware/vtk.js//Common/Core/DataArray.js';\nimport vtkEdgeLocator from '@kitware/vtk.js//Common/DataModel/EdgeLocator.js';\nimport vtkPolyData from '@kitware/vtk.js//Common/DataModel/PolyData.js';\nimport { l as normalize } from '@kitware/vtk.js/Common/Core/Math/index.js';\nimport vtkCaseTable from '@kitware/vtk.js/Filters/General/ImageMarchingCubes/caseTable.js';\n\nconst {\n  vtkErrorMacro,\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// imageMarchingCubes methods\n// ----------------------------------------------------------------------------\n\nfunction imageMarchingCubes(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('imageMarchingCubes');\n  const ids = [];\n  const voxelScalars = [];\n  const voxelGradients = [];\n  const voxelPts = [];\n  const edgeLocator = vtkEdgeLocator.newInstance();\n\n  // Retrieve scalars and voxel coordinates. i-j-k is origin of voxel.\n  publicAPI.getVoxelScalars = (i, j, k, slice, dims, origin, spacing, s) => {\n    // First get the indices for the voxel\n    ids[0] = k * slice + j * dims[0] + i; // i, j, k\n    ids[1] = ids[0] + 1; // i+1, j, k\n    ids[2] = ids[0] + dims[0]; // i, j+1, k\n    ids[3] = ids[2] + 1; // i+1, j+1, k\n    ids[4] = ids[0] + slice; // i, j, k+1\n    ids[5] = ids[4] + 1; // i+1, j, k+1\n    ids[6] = ids[4] + dims[0]; // i, j+1, k+1\n    ids[7] = ids[6] + 1; // i+1, j+1, k+1\n\n    // Now retrieve the scalars\n    for (let ii = 0; ii < 8; ++ii) {\n      voxelScalars[ii] = s[ids[ii]];\n    }\n  };\n\n  // Retrieve voxel coordinates. i-j-k is origin of voxel.\n  publicAPI.getVoxelPoints = (i, j, k, origin, spacing) => {\n    const x = origin[0] + i * spacing[0];\n    const y = origin[1] + j * spacing[1];\n    const z = origin[2] + k * spacing[2];\n\n    voxelPts[0] = [x, y, z];\n    voxelPts[1] = [x + spacing[0], y, z];\n    voxelPts[2] = [x, y + spacing[1], z];\n    voxelPts[3] = [x + spacing[0], y + spacing[1], z];\n    voxelPts[4] = [x, y, z + spacing[2]];\n    voxelPts[5] = [x + spacing[0], y, z + spacing[2]];\n    voxelPts[6] = [x, y + spacing[1], z + spacing[2]];\n    voxelPts[7] = [x + spacing[0], y + spacing[1], z + spacing[2]];\n  };\n\n  // Compute point gradient at i-j-k location\n  publicAPI.getPointGradient = (i, j, k, dims, slice, spacing, s, g) => {\n    let sp;\n    let sm;\n\n    // x-direction\n    if (i === 0) {\n      sp = s[i + 1 + j * dims[0] + k * slice];\n      sm = s[i + j * dims[0] + k * slice];\n      g[0] = (sm - sp) / spacing[0];\n    } else if (i === dims[0] - 1) {\n      sp = s[i + j * dims[0] + k * slice];\n      sm = s[i - 1 + j * dims[0] + k * slice];\n      g[0] = (sm - sp) / spacing[0];\n    } else {\n      sp = s[i + 1 + j * dims[0] + k * slice];\n      sm = s[i - 1 + j * dims[0] + k * slice];\n      g[0] = 0.5 * (sm - sp) / spacing[0];\n    }\n\n    // y-direction\n    if (j === 0) {\n      sp = s[i + (j + 1) * dims[0] + k * slice];\n      sm = s[i + j * dims[0] + k * slice];\n      g[1] = (sm - sp) / spacing[1];\n    } else if (j === dims[1] - 1) {\n      sp = s[i + j * dims[0] + k * slice];\n      sm = s[i + (j - 1) * dims[0] + k * slice];\n      g[1] = (sm - sp) / spacing[1];\n    } else {\n      sp = s[i + (j + 1) * dims[0] + k * slice];\n      sm = s[i + (j - 1) * dims[0] + k * slice];\n      g[1] = 0.5 * (sm - sp) / spacing[1];\n    }\n\n    // z-direction\n    if (k === 0) {\n      sp = s[i + j * dims[0] + (k + 1) * slice];\n      sm = s[i + j * dims[0] + k * slice];\n      g[2] = (sm - sp) / spacing[2];\n    } else if (k === dims[2] - 1) {\n      sp = s[i + j * dims[0] + k * slice];\n      sm = s[i + j * dims[0] + (k - 1) * slice];\n      g[2] = (sm - sp) / spacing[2];\n    } else {\n      sp = s[i + j * dims[0] + (k + 1) * slice];\n      sm = s[i + j * dims[0] + (k - 1) * slice];\n      g[2] = 0.5 * (sm - sp) / spacing[2];\n    }\n  };\n\n  // Compute voxel gradient values. I-j-k is origin point of voxel.\n  publicAPI.getVoxelGradients = (i, j, k, dims, slice, spacing, scalars) => {\n    const g = [];\n    publicAPI.getPointGradient(i, j, k, dims, slice, spacing, scalars, g);\n    voxelGradients[0] = g\n    publicAPI.getPointGradient(i + 1, j, k, dims, slice, spacing, scalars, g);\n    voxelGradients[1] = g\n    publicAPI.getPointGradient(i, j + 1, k, dims, slice, spacing, scalars, g);\n    voxelGradients[2] = g\n    publicAPI.getPointGradient(i + 1, j + 1, k, dims, slice, spacing, scalars, g);\n    voxelGradients[3] = g\n    publicAPI.getPointGradient(i, j, k + 1, dims, slice, spacing, scalars, g);\n    voxelGradients[4] = g\n    publicAPI.getPointGradient(i + 1, j, k + 1, dims, slice, spacing, scalars, g);\n    voxelGradients[5] = g\n    publicAPI.getPointGradient(i, j + 1, k + 1, dims, slice, spacing, scalars, g);\n    voxelGradients[6] = g\n    publicAPI.getPointGradient(i + 1, j + 1, k + 1, dims, slice, spacing, scalars, g);\n    voxelGradients[7] = g\n\n  };\n\n  publicAPI.produceTriangles = (cValMin, cValMax, i, j, k, extent, slice, dims, origin, spacing, scalars, points, tris, normals) => {\n    const CASE_MASK = [1, 2, 4, 8, 16, 32, 64, 128];\n    const VERT_MAP = [0, 1, 3, 2, 4, 5, 7, 6];\n    const xyz = new Float32Array(3);\n    const n = new Float32Array(3);\n    let pId;\n    publicAPI.getVoxelScalars(i, j, k, slice, dims, origin, spacing, scalars);\n\n    let index = 0;\n    for (let idx = 0; idx < 8; idx++) {\n      const scalar = voxelScalars[VERT_MAP[idx]];\n      if (scalar > cValMin && scalar < cValMax) {\n        index |= CASE_MASK[idx]; // eslint-disable-line no-bitwise\n      }\n    }\n\n    const voxelTris = vtkCaseTable.getCase(index);\n\n    if (voxelTris[0] < 0) {\n      return; // No voxel coordinates to process\n    }\n\n    publicAPI.getVoxelPoints(i + extent[0], j + extent[2], k + extent[4], origin, spacing);\n\n    if (model.computeNormals) {\n      publicAPI.getVoxelGradients(i, j, k, dims, slice, spacing, scalars);\n    }\n\n    for (let idx = 0; voxelTris[idx] >= 0; idx += 3) {\n      tris.push(3);\n      for (let eid = 0; eid < 3; eid++) {\n        const edgeVerts = vtkCaseTable.getEdge(voxelTris[idx + eid]);\n        pId = undefined;\n\n        if (model.mergePoints) {\n          pId = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])?.value;\n        }\n\n        if (pId === undefined) {\n          const cVal = (voxelScalars[edgeVerts[0]] <= cValMin || voxelScalars[edgeVerts[1]] <= cValMin) ? cValMin : cValMax;\n          const t = (cVal - voxelScalars[edgeVerts[0]]) / (voxelScalars[edgeVerts[1]] - voxelScalars[edgeVerts[0]]);\n          const x0 = voxelPts[edgeVerts[0]];\n          const x1 = voxelPts[edgeVerts[1]];\n\n          xyz[0] = x0[0] + t * (x1[0] - x0[0]);\n          xyz[1] = x0[1] + t * (x1[1] - x0[1]);\n          xyz[2] = x0[2] + t * (x1[2] - x0[2]);\n\n          pId = points.length / 3;\n          points.push(xyz[0], xyz[1], xyz[2]);\n\n          if (model.computeNormals) {\n            const n0 = voxelGradients[edgeVerts[0]];\n            const n1 = voxelGradients[edgeVerts[1]];\n\n            n[0] = n0[0] + t * (n1[0] - n0[0]);\n            n[1] = n0[1] + t * (n1[1] - n0[1]);\n            n[2] = n0[2] + t * (n1[2] - n0[2]);\n            normalize(n);\n            normals.push(n[0], n[1], n[2]);\n          }\n\n          if (model.mergePoints) {\n            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);\n          }\n        }\n        tris.push(pId);\n      }\n    }\n  };\n\n  publicAPI.requestData = (inData, outData) => {\n    const input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    console.time('mcubes');\n\n    // Retrieve output and volume data\n    const origin = input.getOrigin();\n    const spacing = input.getSpacing();\n    const dims = input.getDimensions();\n    const s = input.getPointData().getScalars().getData();\n\n    // Points - dynamic array\n    const pBuffer = [];\n\n    // Cells - dynamic array\n    const tBuffer = [];\n\n    // Normals\n    const nBuffer = [];\n\n    // Loop over all voxels, determine case and process\n    const extent = input.getExtent();\n    const slice = dims[0] * dims[1];\n    for (let k = 0; k < dims[2] - 1; ++k) {\n      for (let j = 0; j < dims[1] - 1; ++j) {\n        for (let i = 0; i < dims[0] - 1; ++i) {\n          publicAPI.produceTriangles(model.contourValue, model.contourValueMax, i, j, k, extent, slice, dims, origin, spacing, s, pBuffer, tBuffer, nBuffer);\n        }\n      }\n    }\n    edgeLocator.initialize();\n\n    // Update output\n    const polydata = vtkPolyData.newInstance();\n    polydata.getPoints().setData(new Float32Array(pBuffer), 3);\n    polydata.getPolys().setData(new Uint32Array(tBuffer));\n    polydata.getPolys().setNumberOfComponents(4);\n    if (model.computeNormals) {\n      const nData = new Float32Array(nBuffer);\n      const normals = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: nData,\n        name: 'Normals'\n      });\n      polydata.getPointData().setNormals(normals);\n    }\n    outData[0] = polydata;\n    vtkDebugMacro('Produced output');\n    console.timeEnd('mcubes');\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  contourValue: 0,\n  contourValueMax: 4096,\n  computeNormals: false,\n  mergePoints: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['contourValue', 'contourValueMax', 'computeNormals', 'mergePoints']);\n\n  // Object specific methods\n  macro.algo(publicAPI, model, 1, 1);\n  imageMarchingCubes(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'imageMarchingCubes');\n\n// ----------------------------------------------------------------------------\n\nvar imageMarchingCubes$1 = {\n  newInstance,\n  extend\n};\n\nexport { imageMarchingCubes$1 as default, extend, newInstance };\n","import React, { useMemo, useEffect, useRef, useState, useCallback } from 'react';\nimport { Button, Icon, useViewportGrid, useImageViewer } from '@ohif/ui';\nimport { CheckBox } from '@ohif/ui';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkImageMarchingCubes from '@kitware/vtk.js/Filters/General/ImageMarchingCubes.js';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport vtkOutlineFilter from '@kitware/vtk.js/Filters/General/OutlineFilter';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport vtkImageCropFilter from '@kitware/vtk.js/Filters/General/ImageCropFilter';\nimport vtkImageReslice from '@kitware/vtk.js/Imaging/Core/ImageReslice';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport PolyDataExtractor from './Edition3DUtils/extractCellGroupsFromPolydata.js';\nimport QuadricDecimator from './Edition3DUtils/quadricDecimation.js';\nimport vtkSTLWriter from '@kitware/vtk.js/IO/Geometry/STLWriter';\nimport { FormatTypes } from '@kitware/vtk.js/IO/Geometry/STLWriter/Constants.js';\nimport vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction.js';\nimport vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction.js';\n// TODO Optimized code for marchingCubes\nimport imageMarchingCubes from './Edition3DUtils/ImageMarchingCubes.js';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData.js';\nconst _ = require('lodash');\n\nexport default function Edition3DPanel({\n    commandsManager,\n    extensionManager,\n    servicesManager,\n}): React.FunctionComponent {\n    const [percentileValues, setPercentileValues] = useState(new Array(100).fill(0));\n    const [cTPercentile, setCTPercentile] = useState('50');\n    const [ctValue, setCtValue] = useState('0');\n    const [reductionPercentile, setReductionPercentile] = useState('50');\n    const [skinThreshold, setSkinThreshold] = useState('20');\n    const [boneThreshold, setBoneThreshold] = useState('450');\n    const [toothThreshold, setToothThreshold] = useState('1200');\n    const isFirstRender = useRef(true);\n\n    // @ts-ignore\n    const [\n        { viewports },\n        viewportGridService,\n    ] = useViewportGrid();\n    const {\n        cornerstoneViewportService,\n        hangingProtocolService,\n        uiNotificationService,\n    } = servicesManager.services;\n\n    const seededRandom = (seed: number) => {\n        let value = seed % 2147483647;\n        return () => {\n            value = (value * 16807) % 2147483647;\n            return value / 2147483647;\n        };\n    }\n    const myRandom = seededRandom(42);\n\n    /*const computeHistogram = () => {\n        const firstVp = cornerstoneViewportService.getCornerstoneViewportByIndex(0);\n        const imageData = firstVp.getImageData().imageData;\n        const scalars = imageData.getPointData().getScalars().getData()\n\n        const histogram = new Array(3596).fill(0);\n        for (const value of scalars) {\n            if (value >= -500) {\n                histogram[value - 500] += 1;\n            }\n        }\n        const nbValues = histogram.reduce((a, b) => a + b)\n        const percentStep = nbValues / 100\n\n        let curPercentile = 1;\n        let cumulatedSum = 0;\n        histogram.forEach((value, index) => {\n            cumulatedSum += value;\n            while (cumulatedSum > percentStep * curPercentile) {\n                percentileValues[curPercentile] = index - 500;\n                curPercentile += 1;\n            }\n        });\n    }*/\n\n    useEffect(() => {\n        // Change view to default\n        const state = viewportGridService.getState();\n        console.log('STATE', state);\n        console.log('HP', hangingProtocolService.getActiveProtocol());\n        if (hangingProtocolService.getActiveProtocol().protocol.id !== 'mprAnd3DVolumeViewport') {\n            commandsManager.runCommand('toggleHangingProtocol', {\n                protocolId: 'mprAnd3DVolumeViewport',\n                stageIndex: 0,\n            });\n        }\n    }, []);\n\n    useEffect(() => {\n        // TODO display when switching between Panoramic and 3D Edition\n        if (isFirstRender.current) {\n            isFirstRender.current = false;\n            return;\n        }\n\n        const vp = viewports.find(vp => vp.viewportOptions.viewportType === 'volume3d');\n        console.assert(vp, 'UseEffect Threshold: Could not find \"volume3d\" viewport');\n        viewportGridService.setActiveViewportIndex(vp.viewportIndex);\n\n        const cornerstoneVP = cornerstoneViewportService.getCornerstoneViewport(vp.id);\n        const actorEntries = cornerstoneVP.getActors();\n        if (!actorEntries || !actorEntries.length) {\n            uiNotificationService.show({\n                title: `Edition 3D export`,\n                message: `No actor on 3d viewport`,\n                type: 'error',\n                duration: 3000,\n              });\n            return;\n        }\n        const ctfun = vtkColorTransferFunction.newInstance();\n        ctfun.addRGBPoint(-1000, 0, 0, 0);\n        ctfun.addRGBPoint(+skinThreshold, 1, 0, 0.031);\n        ctfun.addRGBPoint(+boneThreshold, 1, 0.458, 0.105);\n        ctfun.addRGBPoint(+toothThreshold, 1, 0.882, 0.207);\n        ctfun.addRGBPoint(3095, 1, 1, 1);\n\n        const ofun = vtkPiecewiseFunction.newInstance();\n        ofun.addPoint(-1000, 0);\n        ofun.addPoint(+skinThreshold, 0.05);\n        ofun.addPoint(+boneThreshold, 0.3);\n        ofun.addPoint(+toothThreshold, 1);\n        ofun.addPoint(3095, 1)\n\n        actorEntries.forEach(obj => {\n            const actor = obj.actor;\n            actor.getProperty().setRGBTransferFunction(0, ctfun);\n            actor.getProperty().setScalarOpacity(0, ofun);\n        });\n        getEnabledElement(cornerstoneVP.element).viewport.render();\n    }, [skinThreshold, boneThreshold, toothThreshold]);\n\n    const focusOn = async() => {\n        // Focus on viewport index 1, which is volume3D (if layout 2x2)\n        // If length <= 1, means that focus is on and need to de-focus\n        const vp3dIndex = viewports.findIndex(vp => vp.viewportOptions.viewportType === 'volume3d');\n        console.assert(vp3dIndex != -1, 'FocusOn: Could not find \"volume3d\" viewport');\n\n        const activeViewportIndex = (viewports.length > 1) ? vp3dIndex : 0;\n        await viewportGridService.setActiveViewportIndex(activeViewportIndex);\n\n        //Call to layout 1x1 on volume3d viewport\n        commandsManager.runCommand('toggleOneUpCustom', {});\n    };\n\n    const exportSTL = () => {\n        // TODO Cache currently not filled\n        // Get STL from actor in volume3d viewport\n        const vp = viewports.find(vp => vp.viewportOptions.viewportType === 'volume3d');\n        console.assert(vp, 'Export STL: Could not find \"volume3d\" viewport');\n        const cornerstoneVP = cornerstoneViewportService.getCornerstoneViewport(vp.id);\n        const actorEntries = cornerstoneVP.getActors();\n        if (!actorEntries || !actorEntries.length) {\n            uiNotificationService.show({\n                title: `Edition 3D export`,\n                message: `STL needs to be generated`,\n                type: 'info',\n                duration: 3000,\n              });\n            return;\n        }\n        for (const actorEntry of actorEntries) {\n            const { uid: actorUID, actor } = actorEntry;\n            if (actorUID === 'outline') {\n                continue;\n            }\n\n            const polyData = actor.getMapper().getInputData();\n            const fileContents = vtkSTLWriter.writeSTL(polyData, FormatTypes.BINARY);\n            const blob = new Blob([fileContents], { type: 'text/plain;charset=utf-8' });\n            const a = window.document.createElement('a');\n            a.href = window.URL.createObjectURL(blob);\n            a.download = `${actorUID}STL.stl`;\n            a.text = `Download ${actorUID} STL`;\n            document.body.appendChild(a);\n            a.click();\n            console.log(`${actorUID} polygons successfully exported`);\n        };\n    };\n\n    const _dropPoints = (imageData, keepRatio = 0.5) => {\n        const originalData = imageData.getPointData().getScalars();\n\n        const mask = new Float32Array(originalData.getNumberOfTuples());\n        for (let i = 0; i < mask.length; i++) {\n            mask[i] = myRandom() < keepRatio ? 1 : 0;\n        }\n        const maskedData = originalData.getData().map((value, index) => value * mask[index]);\n        const maskedDataArray = vtkDataArray.newInstance({\n            numberOfComponents: originalData.getNumberOfComponents(),\n            values: maskedData,\n            name: originalData.getName(),\n        });\n        const maskedImageData = vtkImageData.newInstance();\n        maskedImageData.setDimensions(imageData.getDimensions());\n        maskedImageData.getPointData().setScalars(maskedDataArray);\n\n        return maskedImageData;\n    };\n\n    const _interpolatePoints = (imageData, resizeScale = 0.5) => {\n        const inputReslice = vtkImageReslice.newInstance();\n        inputReslice.setInputData(imageData);\n        const inputDimensions = imageData.getDimensions();\n        const outputDimensions = [\n            inputDimensions[0] * resizeScale,\n            inputDimensions[1] * resizeScale,\n            inputDimensions[2] * resizeScale,\n        ];\n        const outputSpacing = [\n            imageData.getSpacing()[0] * (inputDimensions[0] / outputDimensions[0]),\n            imageData.getSpacing()[1] * (inputDimensions[1] / outputDimensions[1]),\n            imageData.getSpacing()[2] * (inputDimensions[2] / outputDimensions[2]),\n        ];\n        inputReslice.setOutputSpacing(outputSpacing);\n        inputReslice.setOutputExtent([\n            0, outputDimensions[0] - 1,\n            0, outputDimensions[1] - 1,\n            0, outputDimensions[2] - 1,\n        ]);\n\n        return inputReslice.getOutputData();\n    };\n\n    const _displayMarchingCubes = (actorEntries) => {\n        const vp = viewports.find(vp => vp.viewportOptions.viewportType === 'volume3d');\n        console.assert(vp, 'DisplayMarchingCubes: Could not find \"volume3d\" viewport');\n\n        viewportGridService.setActiveViewportIndex(vp.viewportIndex);\n        const cornerstoneVP = cornerstoneViewportService.getCornerstoneViewport(vp.id);\n\n        cornerstoneVP.setActors(actorEntries);\n\n        const cornestoneRenderer = cornerstoneVP.getRenderer();\n        cornestoneRenderer.getRenderWindow().setNumberOfLayers(2);\n        cornestoneRenderer.setUseDepthPeeling(true);\n        cornestoneRenderer.setOcclusionRatio(0.1);\n        cornestoneRenderer.setMaximumNumberOfPeels(100);\n        cornestoneRenderer.getActiveCamera().setParallelProjection(true);\n        cornestoneRenderer.resetCamera();\n\n        getEnabledElement(cornerstoneVP.element).viewport.render();\n    };\n\n    const marchingCubes = () => {\n        // TODO handle early click\n        const firstVp = cornerstoneViewportService.getCornerstoneViewportByIndex(0);\n        let imageData = firstVp.getImageData().imageData;\n\n        // Create a mask to randomly select points\n        const vp = viewports.find(vp => vp.viewportOptions.viewportType === 'volume3d');\n        console.assert(vp, 'MarchingCubes: Could not find \"volume3d\" viewport');\n\n        viewportGridService.setActiveViewportIndex(vp.viewportIndex);\n\n        // -------------------- PREPROCESSING --------------------\n        console.log('Marching cubes - Preprocessing');\n\n        // Reduce number of points, method 1\n        // imageData = dropPoints(imageData, 0.15)\n\n        // Reduce number of points, method 2\n        // imageData = interpolatePoints(imageData, 0.15)\n\n        let actorEntries = [];\n\n        const contourValue = ctValue;\n        const contourType = (contourValue < skinThreshold) ? 'airways' :\n                            (contourValue < boneThreshold) ? 'skin' :\n                            (contourValue < toothThreshold) ? 'bones' :\n                            'teeth';\n\n        if (contourType == 'airways') {\n            // By cropping, we ensure the polygon mesh is done on the inner airways and not on the ambient air\n            const imageDataCopy = vtkImageData.newInstance();\n            imageDataCopy.shallowCopy(imageData);\n\n            const cropFilter = vtkImageCropFilter.newInstance();\n            cropFilter.setCroppingPlanes([0, 400, 50, 400, 75, 280]);\n            cropFilter.setInputData(imageDataCopy);\n            imageData = cropFilter.getOutputData()\n        }\n\n        // -------------------- MESHING --------------------\n        console.log(`Marching cubes - Processing ${contourType}`);\n\n        const polyExtractor = imageMarchingCubes.newInstance({\n            contourValue: contourValue,\n            //contourValueMax: 1200,\n            computeNormals: false,\n            mergePoints: true,\n        });\n        polyExtractor.setInputData(imageData);\n        const polySTL = polyExtractor.getOutputData();\n        polySTL.buildLinks();\n\n        const polyMapper = vtkMapper.newInstance();\n        polyMapper.setInputData(polySTL);\n        const polys = vtkActor.newInstance();\n        polys.setMapper(polyMapper);\n\n        if (contourType == 'airways') {\n        polys.getProperty().setDiffuseColor(myRandom(), myRandom(), myRandom());\n        } else if (contourType == 'skin') {\n            polys.getProperty().setDiffuseColor(0.88, 0.55, 0.55);\n        } else if (contourType == 'bones') {\n            polys.getProperty().setDiffuseColor(0.9, 0.85, 0.77);\n        } else if (contourType == 'teeth') {\n            polys.getProperty().setDiffuseColor(1, 1, 1);\n        }\n        polys.getProperty().setOpacity(1);\n        polys.getProperty().setBackfaceCulling(true);\n        // actorEntries.push({ uid: contourType, actor: polys });\n\n        // -------------------- AIRWAYS SEPARATION --------------------\n        console.log('Marching cubes - Separating airways');\n\n        // Divide skin in separated polys according to linking\n        const allPolys = new PolyDataExtractor(polySTL).extractGroups();\n\n        // Sort polys according to their size\n        const polysSize = allPolys.map((p, i) => ({ index: i, size: p.getNumberOfCells() }));\n        polysSize.sort((p1, p2) => p2.size - p1.size);\n\n        //Select the N biggest polys EXCEPT the first one (skin surface) TODO\n        const N = 10; // TODO\n        const idxs = Array.from({ length: N }, (value, index) => index);\n        const polysMaxSizeIndexes = idxs.map(i => polysSize[i]);\n\n        const selectedPolys = polysMaxSizeIndexes.map(obj => allPolys[obj.index]);\n\n        const targetReduction = Number(reductionPercentile) / 100;\n        //Create actors from selected polys\n        selectedPolys.map((p, i) => {\n            let qPolys = p;\n            if (targetReduction > 0. && targetReduction < 1.) {\n                const quadricDecimator = new QuadricDecimator(p, targetReduction);\n                qPolys = quadricDecimator.decimate();\n            }\n\n            const mapper = vtkMapper.newInstance();\n            mapper.setInputData(qPolys);\n            const actor = vtkActor.newInstance();\n            actor.setMapper(mapper);\n\n            actor.getProperty().setColor(myRandom(), myRandom(), myRandom());\n            actor.getProperty().setOpacity(1);\n            actor.getProperty().setBackfaceCulling(false);\n            // actor.getProperty().setAmbient(1)\n\n            actorEntries.push({ uid: `airway_${i}`, actor: actor });\n        });\n\n        // -------------------- OUTLINE --------------------\n        const outlineData = vtkOutlineFilter.newInstance();\n        outlineData.setInputData(polys);\n        const mapOutline = vtkMapper.newInstance();\n        mapOutline.setInputConnection(outlineData.getOutputPort());\n        const outline = vtkActor.newInstance();\n        outline.setMapper(mapOutline);\n        outline.getProperty().setColor(1, 1, 0);\n        outline.getProperty().setOpacity(1);\n        actorEntries.push({ uid: 'outline', actor: outline });\n\n        // Display\n        console.log('Marching cubes - Display');\n        _displayMarchingCubes(actorEntries);\n    };\n    // @ts-ignore\n    return (\n        <div style={{ width: '100%', display: 'flex', flexDirection: 'column', justifyContent: 'space-evenly', height: '50%' }}>\n            <Button onClick={focusOn}>{\"Volume Zoom In / Out\"}</Button>\n            <p style={{ color: 'white', fontSize: 'larger' }}>{'Volume rendering'}</p>\n            <div style={{ display: 'inline-flex', width: '100%', justifyContent: 'flex-start' }}>\n                <p style={{ color: 'white' }}>{`Airway -> Skin threshold: ${skinThreshold}`}</p>\n            </div>\n            <input type=\"range\" min=\"-1000\" max={boneThreshold} value={skinThreshold} className=\"slider\" id=\"myRange\" step={\"1\"}\n                onChange={(e) => setSkinThreshold(e.target.value)}\n            />\n            <div style={{ display: 'inline-flex', width: '100%', justifyContent: 'flex-start' }}>\n                <p style={{ color: 'white' }}>{`Skin -> Bone threshold: ${boneThreshold}`}</p>\n            </div>\n            <input type=\"range\" min={skinThreshold} max={toothThreshold} value={boneThreshold} className=\"slider\" id=\"myRange\" step={\"1\"}\n                onChange={(e) => setBoneThreshold(e.target.value)}\n            />\n            <div style={{ display: 'inline-flex', width: '100%', justifyContent: 'flex-start' }}>\n                <p style={{ color: 'white' }}>{`Bone -> Tooth threshold: ${toothThreshold}`}</p>\n            </div>\n            <input type=\"range\" min={boneThreshold} max=\"3095\" value={toothThreshold} className=\"slider\" id=\"myRange\" step={\"1\"}\n                onChange={(e) => setToothThreshold(e.target.value)}\n            />\n            <p style={{ color: 'white', fontSize: 'larger' }}>{'Mesh rendering'}</p>\n            <div style={{ display: 'inline-flex', width: '100%', justifyContent: 'flex-start' }}>\n                <p style={{ color: 'white' }}>{`CT value for mesh: ${ctValue}`}</p>\n            </div>\n            <input type=\"range\" min=\"-1000\" max=\"3095\" value={ctValue} className=\"slider\" id=\"myRange\" step={\"1\"}\n                onChange={(e) => setCtValue(e.target.value)}\n            />\n            <div style={{ display: 'inline-flex', width: '100%', justifyContent: 'flex-start' }}>\n                <p style={{ color: 'white' }}>{`Target Reduction: ${reductionPercentile}%`}</p>\n            </div>\n            <input type=\"range\" min=\"0\" max=\"100\" value={reductionPercentile} className=\"slider\" id=\"myRange\" step={\"1\"}\n                onChange={(e) => setReductionPercentile(e.target.value)}\n            />\n            <Button onClick={marchingCubes}>{\"Marching cubes\"}</Button>\n            <Button onClick={exportSTL}>{\"Export STL\"}</Button>\n\n        </div>\n    );\n}\n","import {awrap} from \"@babel/runtime/helpers/regeneratorRuntime\";\n\nconst zeros = require('zeros')\n// const sharp = require('sharp')\n\nexport const dcmbufferToPng = async (metadata, invertRows = false) => {\n    let j;\n    let i;\n    var BitsAllocated = metadata.BitsAllocated\n    var BitsStored = metadata.BitsStored\n    var rows = metadata.Rows\n    var columns = metadata.Columns\n    var windowCenter = metadata.WindowCenter\n    var windowWidth = metadata.WindowWidth\n\n\n    let pixelArray;\n    let pixelData = metadata.PixelData;\n    if (BitsAllocated === 16)\n        pixelArray = new Int16Array(pixelData);//new Uint16Array(dataSet.byteArray.buffer, pixelDataElement.dataOffset, pixelDataElement.length / 2);\n    else\n        pixelArray = new Int8Array(pixelData);//new Uint8Array(dataSet.byteArray.buffer, pixelDataElement.dataOffset, pixelDataElement.length);\n    var res = zeros([rows, columns])\n    if(invertRows) {\n        for (i = 1; i <= rows; i++) {\n            for (j = 0; j < columns; j++) {\n                const valBef = pixelArray[i * columns + j];\n                let val = valBef\n                if (windowCenter && windowWidth) {\n                    if (val <= (windowCenter - 0.5 - (windowWidth - 1) / 2))\n                        val = 0\n                    else if (val > (windowCenter - 0.5 + (windowWidth - 1) / 2))\n                        val = 255\n                    else\n                        val = ~~(((val - (windowCenter - 0.5)) / (windowWidth - 1) + 0.5) * 255)\n                } else if (BitsAllocated === 16)\n                    val = ((val * 2 ** 8) / 2 ** BitsStored);\n                // console.log(`I : ${i} J : ${j} Pixel : ${valBef} Value : ${val}`)\n                res.set(rows - i, j, val)\n            }\n        }\n    }\n    else{\n        for (i = 0; i < rows; i++) {\n            for (j = 0; j < columns; j++) {\n                const valBef = pixelArray[i * columns + j];\n                let val = valBef\n                if (windowCenter && windowWidth) {\n                    if (val <= (windowCenter - 0.5 - (windowWidth - 1) / 2))\n                        val = 0\n                    else if (val > (windowCenter - 0.5 + (windowWidth - 1) / 2))\n                        val = 255\n                    else\n                        val = ~~(((val - (windowCenter - 0.5)) / (windowWidth - 1) + 0.5) * 255)\n                } else if (BitsAllocated === 16)\n                    val = ((val * 2 ** 8) / 2 ** BitsStored);\n                // console.log(`I : ${i} J : ${j} Pixel : ${valBef} Value : ${val}`)\n                res.set(i, j, val)\n            }\n        }\n    }\n\n    return {\n        buffer: res,\n        height: rows,\n        width: columns,\n        ext: 'png',\n    }\n}","const DEFAULT_OPTIONS = { order: 2, period: null };\n\n/**\n * Determine the coefficient of determination (r^2) of a fit from the observations\n * and predictions.\n *\n * @param {Array<Array<number>>} data - Pairs of observed x-y values\n * @param {Array<Array<number>>} results - Pairs of observed predicted x-y values\n *\n * @return {number} - The r^2 value, or NaN if one cannot be calculated.\n */\nfunction determinationCoefficient(data, results) {\n    const predictions = [];\n    const observations = [];\n\n    data.forEach((d, i) => {\n        if (d[1] !== null) {\n            observations.push(d);\n            predictions.push(results[i]);\n        }\n    });\n\n    const sum = observations.reduce((a, observation) => a + observation[1], 0);\n    const mean = sum / observations.length;\n\n    const ssyy = observations.reduce((a, observation) => {\n        const difference = observation[1] - mean;\n        return a + (difference * difference);\n    }, 0);\n\n    const sse = observations.reduce((accum, observation, index) => {\n        const prediction = predictions[index];\n        const residual = observation[1] - prediction[1];\n        return accum + (residual * residual);\n    }, 0);\n\n    return 1 - (sse / ssyy);\n}\n\n/**\n * Determine the solution of a system of linear equations A * x = b using\n * Gaussian elimination.\n *\n * @param {Array<Array<number>>} input - A 2-d matrix of data in row-major form [ A | b ]\n * @param {number} order - How many degrees to solve for\n *\n * @return {Array<number>} - Vector of normalized solution coefficients matrix (x)\n */\nfunction gaussianElimination(input, order) {\n    const matrix = input;\n    const n = input.length - 1;\n    const coefficients = [order];\n\n    for (let i = 0; i < n; i++) {\n        let maxrow = i;\n        for (let j = i + 1; j < n; j++) {\n            if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][maxrow])) {\n                maxrow = j;\n            }\n        }\n\n        for (let k = i; k < n + 1; k++) {\n            const tmp = matrix[k][i];\n            matrix[k][i] = matrix[k][maxrow];\n            matrix[k][maxrow] = tmp;\n        }\n\n        for (let j = i + 1; j < n; j++) {\n            for (let k = n; k >= i; k--) {\n                // TODO divide by zero\n                matrix[k][j] -= (matrix[k][i] * matrix[i][j]) / matrix[i][i];\n            }\n        }\n    }\n\n    for (let j = n - 1; j >= 0; j--) {\n        let total = 0;\n        for (let k = j + 1; k < n; k++) {\n            total += matrix[k][j] * coefficients[k];\n        }\n\n        coefficients[j] = (matrix[n][j] - total) / matrix[j][j];\n    }\n\n    return coefficients;\n}\n\n/**\n * Round a number to a precision, specificed in number of decimal places\n *\n * @param {number} number - The number to round\n * @param {number} precision - The number of decimal places to round to:\n *                             > 0 means decimals, < 0 means powers of 10\n *\n *\n * @return {number} - The number, rounded\n */\nfunction round(number, precision) {\n    const factor = 10 ** precision;\n    return Math.round(number * factor) / factor;\n}\n\n/**\n * The set of all fitting methods\n *\n * @namespace\n */\nexport const LSFMethods = {\n    polynomial(data, options) {\n        const lhs = [];\n        const rhs = [];\n        let a = 0;\n        let b = 0;\n        const len = data.length;\n        const k = options.order + 1;\n\n        for (let i = 0; i < k; i++) {\n            for (let l = 0; l < len; l++) {\n                if (data[l].y !== null) {\n                    a += (data[l].x ** i) * data[l].y;\n                }\n            }\n\n            lhs.push(a);\n            a = 0;\n\n            const c = [];\n            for (let j = 0; j < k; j++) {\n                for (let l = 0; l < len; l++) {\n                    if (data[l].y !== null) {\n                        b += data[l].x ** (i + j);\n                    }\n                }\n                c.push(b);\n                b = 0;\n            }\n            rhs.push(c);\n        }\n        rhs.push(lhs);\n\n        const coefficients = gaussianElimination(rhs, k).map(v => v);\n\n        const predict = x => coefficients.reduce((sum, coeff, power) => sum + (coeff * (x ** power)), 0);\n\n        const points = data.map(point => [point.x, predict(point.x)]);\n\n        let string = 'y = ';\n        for (let i = coefficients.length - 1; i >= 0; i--) {\n            if (i > 1) {\n                string += `${coefficients[i]}x^${i} + `;\n            } else if (i === 1) {\n                string += `${coefficients[i]}x + `;\n            } else {\n                string += coefficients[i];\n            }\n        }\n\n        return {\n            string,\n            points,\n            predict,\n            equation: [...coefficients].reverse(),\n            r2: determinationCoefficient(data, points),\n        };\n    },\n};\n","import React, {useEffect, useState} from 'react';\nimport {DicomMetadataStore} from '@ohif/core';\nimport {Button, useImageViewer, useViewportGrid} from '@ohif/ui'\nimport {applySmoothing, blurPanoramic, calculateNormalCurve, cubicSplineInterpolation, sharpen} from './PanoramicUtils/computePanoramicUtils.js'\nimport {ToolGroupManager, utilities as csToolsUtils} from '@cornerstonejs/tools';\nimport FileLoaderService from '../../../../platform/app/src/routes/Local/fileLoaderService.js'\nimport {dcmbufferToPng} from './PanoramicUtils/dcmbufferToPng.js'\nimport {LSFMethods} from './PanoramicUtils/computeDentalCurveUtils.js'\nimport {Enums, metaData, cache} from '@cornerstonejs/core';\nimport ProgressBar from \"@ramonak/react-progress-bar\";\n\nconst skmeans = require('skmeans')\n\ninterface BASE_POINT {\n    pointA: number[];\n    pointB: number[];\n    vectorDirector: number[];\n    computeDentalCurve: boolean;\n}\n\n//TODO: These should be a function parameter\n\nconst DENTASCAN_THICKNESS = 70;\nconst DENTAL_CURVE_THICKNESS = 40;\nconst DENTASCAN_THRESHOLD_VALUE = 1100\nconst AIP_THRESHOLD_VALUE = 70;\nconst TOLERANCE = 0.01;\nconst DENTAL_CURVES_STEP = 1;\nconst AXIAL_CURVES_STEP = 1;\nconst DENTAL_CURVE_AIP_STEP = 2;\nconst DENTAL_CURVE_AIP_THICKNESS = 40;\n\nfunction delay(time) {\n    return new Promise(resolve => setTimeout(resolve, time));\n}\n\nexport default function PanoramicGenerationPanel({\n                                           commandsManager,\n                                           extensionManager,\n                                           servicesManager\n                                       }): React.FunctionComponent {\n    // @ts-ignore\n    const { StudyInstanceUIDs } = useImageViewer();\n    // @ts-ignore\n    const [{ activeViewportIndex, viewports }, viewportGridService] = useViewportGrid();\n    const {\n        displaySetService,\n        cornerstoneViewportService,\n        hangingProtocolService,\n        toolGroupService,\n        measurementService,\n        uiNotificationService,\n        cornerstoneCacheService,\n        customizationService\n    } = servicesManager.services;\n\n    const {\n        displaySetInstanceUIDs,\n        displaySetOptions,\n        viewportOptions,\n    } = viewports[activeViewportIndex];\n\n    const [panelMetadata, setPanelMetadata] = useState({\n        update: false,\n        dentascanViewportData: undefined,\n        panoramicViewportData: undefined,\n        panoramic: {\n            width: 0,\n            height: 0,\n        }\n    });\n\n    //Progress bar for panoramic computation\n    const [isProcessingPanoramic, setIsProcessingPanoramic] = useState(false);\n    const [processingPourcent, setProcessingPourcent] = useState(0);\n\n    //Panoramic computation settings\n    const [numberBasePoints, setNumberBasePoints] = useState(11);\n    const [dicomDimensions, setDicomDimensions] = useState([400, 400, 400]);\n    const [panoramicDimensions, setPanoramicDimensions] = useState([400, 400]);\n\n    useEffect(() => {\n        /*const viewport = cornerstoneViewportService.getCornerstoneViewportByIndex(0);\n        const generalSeriesModule = metaData.get('generalSeriesModule', viewport.getCurrentImageId());\n        const displaySetCache = displaySetService.getDisplaySetCache();\n        const generalSeriesInstanceUID = generalSeriesModule.seriesInstanceUID;\n\n        const filterMap = (map, predicate) => {\n            const fmap = new Map()\n            map.forEach((value, key) => {\n                if (predicate(value, key)) fmap.set(key, value)\n            })\n            return fmap\n        }\n\n        //Check if panoramic has already been created and matches to the series uid. If so, set hanging protocol index to 1\n        let stageIndex = 0;\n        if (displaySetCache.find(value => value.seriesInstanceUID === generalSeriesInstanceUID + '.panoramic')) {\n            stageIndex = 2;\n            const previousPanoramicMetadata = cornerstoneCacheService.getPanoramicStateCache(generalSeriesModule.seriesInstanceUID);\n            setPanelMetadata({...previousPanoramicMetadata, update: !previousPanoramicMetadata.update});\n        } else if (displaySetCache.find(value => value.seriesInstanceUID === generalSeriesInstanceUID + '.contrasted')) {\n            stageIndex = 1;\n        }\n        commandsManager.runCommand('toggleHangingProtocol', { protocolId: 'panoramicViewport', stageIndex: stageIndex });*/\n\n        const viewport = cornerstoneViewportService.getCornerstoneViewportByIndex(0);\n        const generalSeriesModule = metaData.get('generalSeriesModule', viewport.getCurrentImageId());\n        const displaySetCache = displaySetService.getDisplaySetCache();\n        const generalSeriesInstanceUID = generalSeriesModule.seriesInstanceUID;\n\n        const filterMap = (map, predicate) => {\n            const fmap = new Map()\n            map.forEach((value, key) => {\n                if (predicate(value, key)) fmap.set(key, value)\n            })\n            return fmap\n        }\n\n        //Check if panoramic has already been created and matches to the series uid. If so, set hanging protocol index to 1\n        const filteredDSPanoramic = filterMap(displaySetCache, value => value.SeriesInstanceUID === generalSeriesInstanceUID + '.panoramic');\n        const filteredDSContrasted = filterMap(displaySetCache, value => value.SeriesInstanceUID === generalSeriesInstanceUID + '.contrasted');\n        // console.log('FDS', filteredDSPanoramic, displaySetService.getDisplaySetCache())\n        if (filteredDSPanoramic.size >= 1) {\n            commandsManager.runCommand('toggleHangingProtocol', {\n                protocolId: 'panoramicViewport',\n                stageIndex: 2\n            })\n            const previousPanoramicMetadata = cornerstoneCacheService.getPanoramicStateCache(generalSeriesModule.seriesInstanceUID)\n            setPanelMetadata({...previousPanoramicMetadata, update: !previousPanoramicMetadata.update})\n        } else if (filteredDSContrasted.size >= 1) {\n            commandsManager.runCommand('toggleHangingProtocol', {\n                protocolId: 'panoramicViewport',\n                stageIndex: 1\n            })\n        } else {\n            commandsManager.runCommand('toggleHangingProtocol', {\n                protocolId: 'panoramicViewport',\n                stageIndex: 0\n            })\n        }\n    }, [])\n\n    useEffect(() => {\n        //If panoramic is updating, processing is logically done, so we can turn off progress bar\n        setIsProcessingPanoramic(false)\n\n        //============================= DELETE ALL PREVIOUS DENTASCAN ANNOTATIONS =================//\n        const dentascanMeasurements = measurementService.getMeasurements()\n            .filter(m => {return m.toolName === \"ArrowAnnotate\"})\n\n        // Delete measurements that are not handmade (thus the interpolated line)\n        for (const pm of dentascanMeasurements) {\n            if (pm.metadata.dentascan) {\n                commandsManager.runCommand('deleteMeasurement', {\n                    uid: pm.uid\n                })\n            }\n        }\n\n        //================== DISPLAY DENTASCAN SECTION IN PANORAMIC AS ANNOTATION ===========================//\n        if (!panelMetadata.dentascanViewportData) return;\n\n        const viewport = cornerstoneViewportService.getCornerstoneViewportByIndex(1)\n        if (!viewport) {\n            return\n        }\n\n        const imageData = viewport.getImageData();\n\n        const pointUp = imageData.imageData.indexToWorld([panelMetadata.dentascanViewportData?.data.initialImageIndex, 0, 0])\n        const pointDown = imageData.imageData.indexToWorld([panelMetadata.dentascanViewportData?.data.initialImageIndex, panelMetadata.panoramic.height, 0])\n\n        //Get ArrowAnnotate instance in order to create new annotation indicating dentascan section on panoramic\n        const toolGroup = ToolGroupManager.getToolGroupForViewport(\n            viewport.id,\n            viewport.renderingEngineId\n        );\n        const arrowAnnotateInstance = toolGroup.getToolInstance(\"ArrowAnnotate\")\n        arrowAnnotateInstance.addNewDentascanAnnotation(viewport.element, [pointUp, pointDown], 'rgb(255, 255, 255)')\n\n\n        //================== DISPLAY WANTED DENTASCANS IN BOTTOM VIEWPORT ===========================//\n\n        csToolsUtils.jumpToSlice(cornerstoneViewportService.getCornerstoneViewportByIndex(2).element, {\n            imageIndex: panelMetadata.dentascanViewportData.data.initialImageIndex - 4,\n            debounceLoading: true,\n        });\n        csToolsUtils.jumpToSlice(cornerstoneViewportService.getCornerstoneViewportByIndex(3).element, {\n            imageIndex: panelMetadata.dentascanViewportData.data.initialImageIndex - 2,\n            debounceLoading: true,\n        });\n        csToolsUtils.jumpToSlice(cornerstoneViewportService.getCornerstoneViewportByIndex(4).element, {\n            imageIndex: panelMetadata.dentascanViewportData.data.initialImageIndex,\n            debounceLoading: true,\n        });\n        csToolsUtils.jumpToSlice(cornerstoneViewportService.getCornerstoneViewportByIndex(5).element, {\n            imageIndex: panelMetadata.dentascanViewportData.data.initialImageIndex + 2,\n            debounceLoading: true,\n        });\n        csToolsUtils.jumpToSlice(cornerstoneViewportService.getCornerstoneViewportByIndex(6).element, {\n            imageIndex: panelMetadata.dentascanViewportData.data.initialImageIndex + 4,\n            debounceLoading: true,\n        });\n\n        //Save state in cache to be retrieved if we reopen panoramic panel\n        const generalSeriesModule = metaData.get('generalSeriesModule', viewport.getCurrentImageId())\n        if (panelMetadata.panoramic.width !== 0) cornerstoneCacheService.setPanoramicStateCache(panelMetadata, generalSeriesModule.seriesInstanceUID)\n\n    }, [panelMetadata.update])\n\n    const loadMultipleBlobsInViewport = (metadata) => {\n        const options = {\n            prefilledValues:{\n                SeriesInstanceUID: metadata.SeriesInstanceUID,\n                SOPInstanceUID: Math.random()\n                    .toString(36)\n                    .substring(2, 10),\n                StudyInstanceUID: metadata.StudyInstanceUID,\n                FrameOfReferenceUID: Math.random()\n                    .toString(36)\n                    .substring(2, 10)\n            }\n        }\n        const pixelData = metadata.PixelData\n\n        return new Promise(async(resolve, reject) => {\n            const createDatasetPromise = new Promise((resolve, reject) => {\n                let datasetsStack = new Array(pixelData.length).fill(null);\n                pixelData.forEach(async(layerData, layerI) => {\n                    metadata.PixelData = layerData;\n                    // Height is always the same, but width can change\n                    if (metadata.Columns !== (layerData.length / metadata.Rows)) {\n                        metadata.Columns = layerData.length / metadata.Rows\n                    }\n                    const pngBuf = await dcmbufferToPng(metadata, true)\n\n                    const coloredBuffer = new Uint8ClampedArray(pngBuf.width * pngBuf.height * 4)\n                    const buffer = pngBuf.buffer.data\n                    let i = 0\n                    for (const p of buffer) {\n                        coloredBuffer[i] = p\n                        coloredBuffer[i + 1] = p\n                        coloredBuffer[i + 2] = p\n                        coloredBuffer[i + 3] = 255\n                        i += 4\n                    }\n\n                    // console.log('OBJ', pngBuf, coloredBuffer, coloredBuffer.length)\n                    const canvas = document.createElement('canvas');\n                    canvas.width = pngBuf.width;\n                    canvas.height = pngBuf.height;\n                    const imgData = new ImageData(new Uint8ClampedArray(coloredBuffer), pngBuf.width, pngBuf.height);\n                    canvas.getContext('2d').putImageData(imgData, 0, 0);\n                    canvas.toBlob(async(blob) => {\n                        const fileLoaderService = new FileLoaderService(blob)\n                        const imageId = fileLoaderService.addFile(blob)\n                        const img = await fileLoaderService.loadFile(blob, imageId)\n\n                        const layerSopInstanceUID = `${options.prefilledValues.SOPInstanceUID}.${layerI + 1}`\n                        const dataset = await fileLoaderService.getDataset(img, imageId, {\n                            prefilledValues: {\n                                ...options.prefilledValues,\n                                SOPInstanceUID: layerSopInstanceUID,\n                                FrameNumber: layerI\n                            }\n                        })\n\n                        DicomMetadataStore.addInstance(dataset)\n                        datasetsStack[layerI] = dataset\n\n                        if (datasetsStack.length === pixelData.length &&\n                            !datasetsStack.includes(null))\n                            resolve(datasetsStack)\n                    })\n                })\n            })\n\n            const dsStack: any = await createDatasetPromise\n\n            const displaySetAdded = displaySetService.makeDisplaySets(dsStack)\n            const dataSource = extensionManager.getDataSource()[0]\n\n            const viewportData = await cornerstoneCacheService.createViewportData(\n                displaySetAdded,\n                {\n                    toolGroupId: 'mpr',\n                    viewportType: 'stack',\n                    initialImageOptions: {\n                        preset: 'middle',\n                    },\n                },\n                dataSource,\n                Math.floor(dsStack.length / 2)\n            )\n            resolve(viewportData)\n        })\n    }\n\n    const loadBlobInViewport = (metadata) => {\n        return new Promise(async(resolve, reject) => {\n            const pngBuf = await dcmbufferToPng(metadata);\n\n            const coloredBuffer = new Uint8ClampedArray(pngBuf.width * pngBuf.height * 4)\n            const buffer = pngBuf.buffer.data\n            let i = 0\n            for (const p of buffer) {\n                coloredBuffer[i] = p\n                coloredBuffer[i + 1] = p\n                coloredBuffer[i + 2] = p\n                coloredBuffer[i + 3] = 255\n                i += 4\n            }\n\n            // console.log('OBJ', pngBuf, coloredBuffer, coloredBuffer.length)\n            const canvas = document.createElement('canvas');\n            canvas.width = pngBuf.width;\n            canvas.height = pngBuf.height;\n            const imgData = new ImageData(new Uint8ClampedArray(coloredBuffer), pngBuf.width, pngBuf.height);\n            canvas.getContext('2d').putImageData(imgData, 0, 0);\n\n            canvas.toBlob(async (blob) => {\n                const fileLoaderService = new FileLoaderService(blob)\n                const imageId = fileLoaderService.addFile(blob)\n                const img = await fileLoaderService.loadFile(blob, imageId);\n\n                const dataset = await fileLoaderService.getDataset(img, imageId, {\n                    prefilledValues: {\n                        SeriesInstanceUID: metadata.SeriesInstanceUID,\n                        StudyInstanceUID: metadata.StudyInstanceUID\n                    }\n                });\n\n                console.log('DATASET', dataset)\n                DicomMetadataStore.addInstance(dataset)\n                const displaySetAdded = displaySetService.makeDisplaySets([dataset])\n                console.log('DSADDED', displaySetAdded)\n                const dataSource = extensionManager.getDataSource()[0]\n\n                const viewportData = await cornerstoneCacheService.createViewportData(\n                    displaySetAdded,\n                    {\n                        toolGroupId: 'mpr',\n                        viewportType: 'stack',\n                        initialImageOptions: {\n                            preset: 'middle',\n                        },\n                    },\n                    dataSource,\n                    undefined\n                );\n\n                console.log('VIEWPORT STACK DATA', viewportData)\n                hangingProtocolService.refreshStudyList()\n                resolve(viewportData)\n            })\n        })\n    }\n\n    const drawPanoramicLine = () => {\n        commandsManager.runCommand('setToolActive', {\n            toolName: 'ArrowAnnotate'\n        })\n    }\n\n    //Debug function to display image in canvas below application main canvas (cancel override-hidden-y)\n    const debugShowImage = (pixelArray, rows, columns) => {\n        return new Promise<HTMLCanvasElement>(async(resolve, reject) => {\n            //Get volume imageId\n            const indexZeroDisplaySet = displaySetService.getDisplaySetByUID(\n                cornerstoneViewportService.getViewportInfoByIndex(0).viewportData.data.displaySetInstanceUID\n            )\n            let imageId;\n            //If image is contrasted\n            if (indexZeroDisplaySet?.SeriesInstanceUID.includes('contrasted')) {\n                const baseVolumeSeriesUID = indexZeroDisplaySet.SeriesInstanceUID.replace('.contrasted', '')\n                const baseVolumeSeries = DicomMetadataStore.getSeries(indexZeroDisplaySet.StudyInstanceUID, baseVolumeSeriesUID)\n                imageId = baseVolumeSeries.instances[0].imageId\n            } else { //Else image at index 0 is image we want to get infos from\n                imageId = cornerstoneViewportService.getCornerstoneViewportByIndex(0).getCurrentImageId()\n            }\n\n            const voiLutModule = metaData.get('voiLutModule', imageId)\n            const imagePixelModule = metaData.get('imagePixelModule', imageId)\n            const metadata = {\n                BitsAllocated: imagePixelModule.bitsAllocated,\n                BitsStored: imagePixelModule.bitsStored,\n                Rows: rows,\n                Columns: columns,\n                WindowCenter: voiLutModule.windowCenter[0],\n                WindowWidth: voiLutModule.windowWidth[0],\n                PixelData: pixelArray\n            }\n            const pngBuf = await dcmbufferToPng(metadata);\n\n            const coloredBuffer = new Uint8ClampedArray(pngBuf.width * pngBuf.height * 4)\n            const buffer = pngBuf.buffer.data\n            let i = 0;\n            for (const p of buffer) {\n                coloredBuffer[i] = p\n                coloredBuffer[i + 1] = p\n                coloredBuffer[i + 2] = p\n                coloredBuffer[i + 3] = 255\n                i += 4\n            }\n            const canvas = document.createElement('canvas')\n            canvas.width = pngBuf.width\n            canvas.height = pngBuf.height\n            const imgData = new ImageData(new Uint8ClampedArray(coloredBuffer), pngBuf.width, pngBuf.height)\n            canvas.getContext('2d').putImageData(imgData, 0, 0)\n            document.body.appendChild(canvas)\n\n            console.info('[DEBUG] - Provided array displayed in document below main canvas !')\n            resolve(canvas)\n        })\n    }\n\n    //Debug function to display random selected points in bone cluster\n    const drawPoint = (context, x, y, label, color, size) => {\n        if (color == null) {\n            color = '#000';\n        }\n        if (size == null) {\n            size = 5;\n        }\n        var radius = 0.5 * size;\n        // to increase smoothing for numbers with decimal part\n        var pointX = Math.round(x - radius);\n        var pointY = Math.round(y - radius);\n        context.beginPath();\n        context.fillStyle = color;\n        context.fillRect(pointX, pointY, size, size);\n        context.fill();\n        if (label) {\n            var textX = Math.round(x);\n            var textY = Math.round(pointY - 5);\n            context.font = 'Italic 14px Arial';\n            context.fillStyle = color;\n            context.textAlign = 'center';\n            context.fillText(label, textX, textY);\n        }\n    }\n\n    //____________________________ FOR PANORAMIC COMPUTATION _________________________//\n\n    const getMax = (arr) => {\n        let len = arr.length;\n        let max = -Infinity;\n\n        while (len--) {\n            max = arr[len] > max ? arr[len] : max;\n        }\n        return max;\n    }\n\n    const derivative = (f, x, dx = 1e-5) => {\n        return (f(x + dx) - f(x)) / dx;\n    }\n\n    const getSlopeVector = (slope) => {\n        const [vx, vy] = [1, slope];\n        const vLength = Math.sqrt(1 + slope * slope);\n        return [vx / vLength, vy / vLength];\n    }\n\n    const getTangentVector = (f, x) => {\n        const tangentSlope = derivative(f, x);\n        return getSlopeVector(tangentSlope);\n    }\n\n    const getNormalVector = (f, x) => {\n        const tangentSlope = derivative(f, x);\n        const normalSlope = -1 / tangentSlope;\n        return getSlopeVector(normalSlope);\n    }\n\n    //Width becomes height, and height becomes width\n    const transposeImage = (arr, width, height) => {\n        const transposedArr = [];\n        for (let i = 0; i < width; i++) {\n            for (let j = 0; j < height; j++) {\n                transposedArr.push(arr[j * width + i]);\n            }\n        }\n        return transposedArr;\n    }\n\n    // Returns the scalar data projected on the sagital axis, using the max of values along X axis\n    const getSagitalDataMax = (scalarData, p) => {\n        const sagitalData = new Float32Array(p.layerHeight * p.nbLayers);\n        // Iterate over Y and Z axes\n        for (let k = 0; k < p.nbLayers; k++) {\n            for (let j = 0; j < p.layerHeight; j++) {\n                const voxelsYZ = new Float32Array(p.layerWidth);\n                for (let i = 0; i < p.layerWidth; i++) {\n                    // Fill an array through X axis to compute its max\n                    voxelsYZ[i] = scalarData[k * p.layerSize + j * p.layerWidth + i];\n                }\n                const voxelYZ = getMax(voxelsYZ);\n                sagitalData[k * p.layerHeight + j] = voxelYZ;\n            }\n        }\n\n        return sagitalData;\n    }\n\n    // Returns the scalar data projected on the coronal axis, using the max of values along X axis\n    const getCoronalDataMax = (scalarData, p) => {\n        const coronalData = new Float32Array(p.layerWidth * p.nbLayers);\n        // Iterate over Y and Z axes\n        for (let k = 0; k < p.nbLayers; k++) {\n            for (let j = 0; j < p.layerWidth; j++) {\n                const voxelsXZ = new Float32Array(p.layerHeight);\n                for (let i = 0; i < p.layerHeight; i++) {\n                    // Fill an array through X axis to compute its max\n                    voxelsXZ[i] = scalarData[k * p.layerSize + j * p.layerHeight + i];\n                }\n                const voxelXZ = getMax(voxelsXZ);\n                coronalData[k * p.layerHeight + j] = voxelXZ;\n            }\n        }\n\n        return coronalData;\n    }\n\n    // Returns the scalar data projected on the axial axis,\n    // using the mean values along Z axis between minLayer and maxLayer\n    const getAxialDataMean = (scalarData, minLayer, maxLayer, p) => {\n        const nbToothLayers = maxLayer - minLayer;\n\n        const axialData = new Float32Array(p.layerWidth * p.layerHeight);\n        // Iterate over X and Y axes\n        for (let i = 0; i < p.layerWidth; i++) {\n            for (let j = 0; j < p.layerHeight; j++) {\n                const voxelsXY = new Float32Array(nbToothLayers);\n                for (let k = 0; k < nbToothLayers; k++) {\n                    // Fill an array through Z axis to compute its mean\n                    voxelsXY[k] = scalarData[(minLayer + k) * p.layerSize + j * p.layerWidth + i];\n                }\n                const voxelXY = voxelsXY.reduce((a, b) => a + b, 0) / voxelsXY.length;\n                axialData[j * p.layerWidth + i] = voxelXY;\n            }\n        }\n\n        return axialData;\n    }\n\n    //Get dentascan section at abscissa i for a degree 2 polynomial fitting curve lsf.\n    //Length of normal is dentascanThickness\n    //Dicom of the dentascan desired is defined by its dicomDimensions and its scalarData\n    const getDentascanSection = (x, f, dicomData, p) => {\n        // Get normalized vector of normal at x\n        let [vxNormal, vyNormal] = getNormalVector(f, x);\n\n        // In order to prevent having a flipped normal vector,\n        // we need to determine if minPoint lies inside or outside the lsf curve\n        // We want minPoint to be the outer point and maxPoint to be the inner point\n        const y = f(x);\n        let minPoint = [x - DENTASCAN_THICKNESS / 2 * vxNormal,\n                        y - DENTASCAN_THICKNESS / 2 * vyNormal];\n        let maxPoint = [x + DENTASCAN_THICKNESS / 2 * vxNormal,\n                        y + DENTASCAN_THICKNESS / 2 * vyNormal];\n        // Swap minPoint and maxPoint and invert normal vectors if minPoint is inner\n        if (minPoint[1] >= f(minPoint[0])) {\n            [minPoint, maxPoint] = [maxPoint, minPoint];\n            [vxNormal, vyNormal] = [-vxNormal, -vyNormal];\n        }\n\n        //Get values of point along normal between min and max\n        const dentascanWidth = DENTASCAN_THICKNESS + 1\n        const dentascan = new Float32Array(dentascanWidth * p.nbLayers).fill(-1000);\n        for (let layer = 0; layer < p.nbLayers; layer++) {\n            for (let i = 0; i < dentascanWidth; i++) {\n                const xi = Math.round(minPoint[0] + i * vxNormal);\n                const yi = Math.round(minPoint[1] + i * vyNormal);\n                if (xi >= 0 && yi >= 0 && xi < p.layerWidth && yi < p.layerHeight) {\n                    const dicomIdx = layer * p.layerSize + yi * p.layerWidth + xi;\n                    dentascan[layer * dentascanWidth + i] = dicomData[dicomIdx];\n                }\n            }\n        }\n\n        return {\n            dentascan: dentascan,\n            width: dentascanWidth,\n            interval: [minPoint, maxPoint],\n            director: [vxNormal, vyNormal],\n            middlePoint: [x, y]\n        }\n    }\n\n    // I want to ensure that the polynomial does not diverge beyond the teeth zone.<\n    // The goal is to smooth out and converge the polynomial on the center outside the given interval while\n    // preserving its original behavior within the interval [minX, maxX].\n    // To achieve this, I use a modified function incorporating two sigmoid functions.>\n    const getDentalLiss = (f, minX, maxX) => {\n        const dentascanWidth = DENTASCAN_THICKNESS + 1;\n        //a1 and a2 are smoothing parameters.\n        const a1 = 0.1\n        const a2 = 0.1\n        //c0 is the convergeance on -inf, and c1 and +inf\n        const c0 = dentascanWidth / 2\n        const c1 = dentascanWidth / 2\n\n        return (layer) => {\n            const sigmoidLeft = 1 / (1 + Math.exp(-a1 * (layer - minX)));\n            const sigmoidRight = 1 / (1 + Math.exp(a2 * (layer - maxX)));\n            const originalDentalValue = f(layer);\n\n            return originalDentalValue * sigmoidLeft * sigmoidRight\n                + c0 * (1 - sigmoidLeft) + c1 * (1 - sigmoidRight);\n        }\n    }\n\n    const getDentalCurve = (dentascan, p) => {\n        const dentascanWidth = DENTASCAN_THICKNESS + 1\n\n        //Compute dental curve\n        //Dentascan is thresholded to get only bone area\n        const binarizedDentascan = dentascan.map(value => value > DENTASCAN_THRESHOLD_VALUE ? value : -1000)\n        //Transposed so that w => h and h => w. This allows us to LSF with a curve represented by an order 3 equation\n        const transposedBin = transposeImage(binarizedDentascan, dentascanWidth, p.nbLayers)\n        // Get the indexes of teeth zone and keep only indexes that are teeth (!= -1000)\n        let transposedOnlyTeethIndex = Array.from(transposedBin).map((value, idx) => value === -1000 ? null\n            : ({ x: idx % this.nbLayers, y: Math.floor(idx / this.nbLayers) })).filter(value => value);\n\n        // Add points along the center of the dentascan to reduce the deformation of the curve\n        for (let l = 0; l < p.nbLayers; l += 10) {\n            transposedOnlyTeethIndex.push({x: l, y: DENTASCAN_THICKNESS / 2});\n        }\n\n        //Curve fitting on a degree 3 polynomial\n        let lsfDentalCurve = LSFMethods.polynomial(transposedOnlyTeethIndex, {order: 3});\n        // TODO order should depend on error for the curve fitting\n\n        let lsfDentalLiss = (x) => DENTASCAN_THICKNESS / 2;\n        if (getMax(transposedBin) > -1000 && !lsfDentalCurve.equation.some((value) => isNaN(value))) {\n            // minX and maxX where value is not -1000\n            const minX = transposedBin.reduce((min, val, idx) =>\n                ((idx % p.nbLayers < min && val != -1000) ? idx % p.nbLayers : min), Infinity);\n            const maxX = transposedBin.reduce((max, val, idx) =>\n                ((idx % p.nbLayers > max && val != -1000) ? idx % p.nbLayers : max), -Infinity);\n            lsfDentalLiss = getDentalLiss(lsfDentalCurve.predict, minX, maxX);\n        }\n\n        return lsfDentalLiss;\n    }\n\n    const getDentalCurvesPointsXY = (dentascans, mode, p) => {\n        const nbDentalCurves = Math.floor(p.panoramicWidth / DENTAL_CURVES_STEP);\n        const nbAxialCurves = Math.floor(p.nbLayers / AXIAL_CURVES_STEP);\n\n        let dentalCurvesPoints;\n        if (mode === 'curveAIP') {\n            // Precompute the values\n            dentalCurvesPoints = new Float32Array(p.panoramicWidth * p.nbLayers);\n            dentascans.forEach((dentascan, idx) => {\n                const dentascanCurve = getDentalCurve(dentascan.dentascan, p);\n                for (let layer = 0; layer < p.nbLayers; layer++) {\n                    dentalCurvesPoints[idx * p.nbLayers + layer] = dentascanCurve.predict(layer);\n                }\n            });\n        }\n\n        const dentalCurvesPointsXY = new Array(nbDentalCurves * nbAxialCurves).fill(null);\n        for (let i = 0; i < nbDentalCurves; i++) {\n            const idx = DENTAL_CURVES_STEP * i;\n            const dentascan = dentascans[idx];\n            const [dentascanMinPoint, dentascanMaxPoint] = dentascan.interval;\n            const [dentascanVxNormal, dentascanVyNormal] = dentascan.director;\n            const idxInf = Math.max(idx - DENTAL_CURVE_AIP_THICKNESS / 2, 0);\n            const idxSup = Math.min(idx + DENTAL_CURVE_AIP_THICKNESS / 2, p.panoramicWidth - 1);\n\n            let dentalCurve;\n            if (mode === 'default') {\n                dentalCurve = getDentalCurve(dentascan.dentascan, p);\n\n            } else if (mode === 'valueMIP') {\n                let dentascansForMIP = [];\n                for (let j = idxInf; j <= idxSup; j += DENTAL_CURVE_AIP_STEP) {\n                    dentascansForMIP.push(dentascans[i].dentascan);\n                }\n                const dentascanMIP = new Float32Array(dentascan.length);\n                for (let j = 0; j < dentascan.length; j++) {\n                    dentascanMIP[j] = getMax(dentascansForMIP.map(dentascanScalar => dentascanScalar[j]));\n                }\n                dentalCurve = getDentalCurve(dentascanMIP, p);\n            }\n\n            for (let l = 0; l < nbAxialCurves; l++) {\n                const layer = AXIAL_CURVES_STEP * l;\n\n                let xPosInDentascan;\n                if (mode === 'curveAIP') {\n                    let xPosInDentascans = [];\n                    for (let j = idxInf; j <= idxSup; j += DENTAL_CURVE_AIP_STEP) {\n                        xPosInDentascans.push(dentalCurvesPoints[j * p.nbLayers + layer]);\n                    }\n                    xPosInDentascan = xPosInDentascans.reduce((a, b) => a + b, 0) / xPosInDentascans.length;\n                } else { // default or valueMIP\n                    xPosInDentascan = dentalCurve(layer);\n                }\n                if (xPosInDentascan < 0) {\n                    xPosInDentascan = 0;\n                } else if (xPosInDentascan > DENTASCAN_THICKNESS) {\n                    xPosInDentascan = DENTASCAN_THICKNESS;\n                }\n                const x = Math.round(dentascanMinPoint[0] + xPosInDentascan * dentascanVxNormal);\n                const y = Math.round(dentascanMinPoint[1] + xPosInDentascan * dentascanVyNormal);\n\n                dentalCurvesPointsXY[l * nbDentalCurves + i] = {x: x, y: y};\n            }\n        }\n\n        return dentalCurvesPointsXY;\n    }\n\n    //Dilate bone zone to eventually fill disconnections in dental zone\n    const dilate = (image, width, height, iterations) => {\n        const result = new Array(width * height).fill(-1000);\n\n        const getPixel = (x, y) => image[y * width + x] || 0;\n\n        for (let iteration = 0; iteration < iterations; iteration++) {\n            for (let y = 1; y < height - 1; y++) {\n                for (let x = 1; x < width - 1; x++) {\n                    const neighbors = [\n                        getPixel(x - 1, y - 1), getPixel(x, y - 1), getPixel(x + 1, y - 1),\n                        getPixel(x - 1, y), getPixel(x, y), getPixel(x + 1, y),\n                        getPixel(x - 1, y + 1), getPixel(x, y + 1), getPixel(x + 1, y + 1)\n                    ];\n\n                    result[y * width + x] = Math.max(...neighbors);\n                }\n            }\n\n            // Mettre  jour l'image pour la prochaine itration\n            for (let i = 0; i < width * height; i++) {\n                image[i] = result[i];\n            }\n        }\n\n        return result;\n    }\n\n    // TODO O(2n) algorithm\n    //Get spatial clusters in binarized image (groups of pixels connected between them)\n    const spatialClustering = (image, width, height) => {\n        const clusters = [];\n        const visited = new Array(width * height).fill(false);\n\n        const getNeighbors = (index) => {\n            const neighbors = [];\n            const x = index % width;\n            const y = Math.floor(index / width);\n\n            for (let i = Math.max(0, x - 1); i <= Math.min(width - 1, x + 1); i++) {\n                for (let j = Math.max(0, y - 1); j <= Math.min(height - 1, y + 1); j++) {\n                    const neighborIndex = j * width + i;\n                    neighbors.push(neighborIndex);\n                }\n            }\n\n            return neighbors;\n        };\n\n        const exploreCluster = (startIndex, cluster) => {\n            const queue = [startIndex];\n\n            while (queue.length > 0) {\n                const currentIndex = queue.shift();\n\n                if (!visited[currentIndex] && image[currentIndex] !== -1000) {\n                    visited[currentIndex] = true;\n                    cluster.push(currentIndex);\n\n                    const neighbors = getNeighbors(currentIndex);\n\n                    for (const neighborIndex of neighbors) {\n                        if (!visited[neighborIndex] && image[neighborIndex] !== -1000) {\n                            queue.push(neighborIndex);\n                        }\n                    }\n                }\n            }\n        };\n\n        for (let i = 0; i < width * height; i++) {\n            if (!visited[i] && image[i] !== -1000) {\n                const newCluster = [];\n                exploreCluster(i, newCluster);\n                clusters.push(newCluster);\n            }\n        }\n\n        return clusters;\n    }\n\n    //Computation of panoramic control points, which are points in the dental curve\n    //from where panoramic will be computed\n    const generatePanoramicControlPoints = async(debug=false) => {\n        // Delete measurements that are handmade (thus control points)\n        // (Handmade is true because of an old implem where control points were handmade, now they are not\n        // but it's a way to identify them)\n        const measurements = measurementService.getMeasurements()\n            .filter(m => {return m.toolName === \"ArrowAnnotate\"})\n\n        console.log('MEASUREMENTS', measurements)\n\n        let displaySetInstanceUID = cornerstoneViewportService.getViewportInfoByIndex(0).viewportData.data.displaySetInstanceUID;\n        for (const pm of measurements) {\n            if (pm.metadata.handmade && pm.displaySetInstanceUID === displaySetInstanceUID) {\n                commandsManager.runCommand('deleteMeasurement', {\n                    uid: pm.uid\n                })\n            }\n        }\n\n        //Get volume from where we want to compute control points from\n        const indexZeroDisplaySet = displaySetService.getDisplaySetByUID(\n            cornerstoneViewportService.getViewportInfoByIndex(0).viewportData.data.displaySetInstanceUID\n        )\n        let baseId;\n        let dicomDimensions;\n        let scalarData;\n        let isContrastAlreadyGenerated;\n        //If image is contrasted, volume we want to get infos from is not in viewport. We need to get infos from another way\n        if (indexZeroDisplaySet?.SeriesInstanceUID.includes('contrasted')) {\n            isContrastAlreadyGenerated = true\n            const baseVolumeSeriesUID = indexZeroDisplaySet.SeriesInstanceUID.replace('.contrasted', '')\n            const baseVolumeSeries = DicomMetadataStore.getSeries(indexZeroDisplaySet.StudyInstanceUID, baseVolumeSeriesUID)\n            baseId = baseVolumeSeries.instances[0].imageId\n            const baseVolume = cache.getVolumeContainingImageId(baseId)\n            scalarData = baseVolume.volume.scalarData\n            dicomDimensions = baseVolume.volume.dimensions\n        } else { //Else image at index 0 is image we want to get infos from\n            isContrastAlreadyGenerated = false\n            const imageData = cornerstoneViewportService.getCornerstoneViewportByIndex(0).getImageData()\n            baseId = cornerstoneViewportService.getCornerstoneViewportByIndex(0).getCurrentImageId()\n            scalarData = imageData.scalarData\n            dicomDimensions = imageData.dimensions\n        }\n        const [layerWidth, layerHeight, nbLayers] = dicomDimensions;\n        const parameters = {layerWidth: layerWidth, layerHeight: layerHeight, nbLayers: nbLayers, layerSize: layerWidth * layerHeight};\n\n        const coronalData = getCoronalDataMax(scalarData, parameters);\n\n        // We select the highest value cluster on coronal view with a K-means++\n        const skMeansCoronal = skmeans(coronalData, 6);\n        const {centroids:centroidsCoronal, idxs:idxsCoronal} = skMeansCoronal\n        const idxsMaxCoronal = centroidsCoronal.indexOf(Math.max(...centroidsCoronal))\n        //Find minimal and maximal layer where one pixel is not -1000\n        const firstIndex = idxsCoronal.findIndex((value) => value === idxsMaxCoronal);\n        const lastIndex = idxsCoronal.findLastIndex((value) => value === idxsMaxCoronal);\n        const [minLayer, maxLayer] = [Math.floor(firstIndex / layerHeight), Math.floor(lastIndex / layerHeight) + 1];\n        console.log('MINLAYER, MAXLAYER', minLayer, maxLayer);\n        console.log('CENTROIDS', centroidsCoronal);\n        // TODO assert minLayer !== maxLayer\n\n        const axialData = getAxialDataMean(scalarData, minLayer, maxLayer, parameters);\n\n        // Contrast is increased for the display\n        const minValue = axialData.reduce((minValue, val) => (val < minValue ? val : minValue), axialData[0]);\n        const maxValue = axialData.reduce((maxValue, val) => (val > maxValue ? val : maxValue), axialData[0]);\n        // TODO minValue !== maxValue\n        // Adjust contrast of image to enlight zone where control points should be placed\n        const axialDataContrasted = axialData.map(pixel => {\n            const normalizedPixel = (pixel - minValue) / (maxValue - minValue);\n            const contrastedPixel = Math.pow(normalizedPixel, 2);\n            return Math.round(contrastedPixel * (maxValue - minValue) + minValue);\n        });\n\n        //Load and display contrastedMean in Ohif since it's the image from where we can / will correct control points\n        const voiLutModule = metaData.get('voiLutModule', baseId)\n        const imagePixelModule = metaData.get('imagePixelModule', baseId)\n        const generalSeriesModule = metaData.get('generalSeriesModule', baseId)\n        const contrastedMetadata = {\n            SeriesInstanceUID: generalSeriesModule.seriesInstanceUID + '.contrasted',\n            StudyInstanceUID: generalSeriesModule.studyInstanceUID,\n            BitsAllocated: imagePixelModule.bitsAllocated,\n            BitsStored: imagePixelModule.bitsStored,\n            Rows: layerWidth,\n            Columns: layerHeight,\n            WindowCenter: voiLutModule.windowCenter[0],\n            WindowWidth: voiLutModule.windowWidth[0],\n            PixelData: axialDataContrasted\n        }\n\n        // If contrasted image is already generated (if we want to override already existing control points for example),\n        // we don't need to load contrasted image in cache and in viewport\n        if (!isContrastAlreadyGenerated) {\n            await loadBlobInViewport(contrastedMetadata);\n        }\n\n        // Refresh study list in hanging protocol module\n        hangingProtocolService.refreshStudyList()\n        const hpInfo = hangingProtocolService.getState();\n        if (hpInfo.stageIndex < 1) {\n            commandsManager.runCommand('toggleHangingProtocol', {\n                protocolId: 'panoramicViewport',\n                stageIndex: 1\n            })\n        }\n        // TODO delay choice\n        await delay(500);\n\n        //Update viewport since it has changed (from axial view to contrasted img)\n        const contrastedViewport = cornerstoneViewportService.getCornerstoneViewportByIndex(0)\n        const contrastedImageData = contrastedViewport.getImageData()\n\n        //K-means++ in contrasted image to isolate bone / jaw zone\n        const skMeansResult = skmeans(axialData, 5);\n        const {centroids, idxs} = skMeansResult\n        const maxClusterIdx = centroids.indexOf(getMax(centroids))\n\n        //Binarize array between max cluster (highest values meaning bone pixels) and other\n        const binarizedArray = axialData.map((value, idx) => idxs[idx] === maxClusterIdx ? value : -1000)\n\n        // const binarizedArrayDilated = dilate(binarizedArray, layerWidth, layerHeight, 5)\n        const binarizedArrayDilated = binarizedArray;\n\n        //Find equation of polynomial going through dental zone with the use of the biggest spatial cluster\n        //corresponding to our dental zone\n        const binarizedIdx = binarizedArray.map((value, idx) => value != -1000? idx: -1000);\n        const filteredIdx = binarizedIdx.filter((value) => value != -1000);\n        const binarizedXy = Array.from(filteredIdx).map(i => ({ x: i % layerWidth, y: Math.floor(i / layerWidth) }));\n\n        const lsf = LSFMethods.polynomial(binarizedXy, {order: 6});\n        const f = lsf.predict;\n\n        /*const spatialClusters = spatialClustering(binarizedArrayDilated, layerWidth, layerHeight);\n        spatialClusters.sort((sc1, sc2) => sc2.length - sc1.length);\n        //Indexes of biggest spatial cluster as X and Y values\n        const biggestSpatialClusterXy = spatialClusters[0].map(v => getCoordinatesFromIndex(v, layerWidth, layerHeight))\n        //LSF method to get best fitting parabola along pixels in square\n        const lsf = LSFMethods.polynomial(biggestSpatialClusterXy, {order: 6})\n        const f = lsf.predict;*/\n\n        //Find minimum and maximum of our binarized to determine where panoramic should start and where should end\n        //We want control points to start at right and left jaw, so we don't use biggestCluster in this case\n        //since it corresponds to the dental zone, not jaws\n        let minX = binarizedArrayDilated.reduce((min, val, idx) =>\n            (idx % layerWidth < min && val != -1000? idx % layerWidth : min), Infinity);\n        let maxX = binarizedArrayDilated.reduce((max, val, idx) =>\n            (idx % layerWidth > max && val != -1000? idx % layerWidth : max), -Infinity);\n\n        //Compute control points : points that determine piecewise linear curve function through f\n        //They also be the points drawn in Viewport so that user can modify if the curve is not correct\n        const controlPoints = []\n        const step = (maxX - minX) / (numberBasePoints - 1);\n        for (let x = minX; x < maxX + TOLERANCE; x += step) {\n            controlPoints.push([x, f(x)])\n        }\n\n        //Draw these control points in front on Viewport so that user can move them\n        //Transpose control points from volume basis to viewport canvas basis\n        const controlPointsInWorld = controlPoints.map(cp => contrastedImageData.imageData.indexToWorld([cp[0], cp[1], 0]))\n        //Get ArrowAnnotate instance in order to create new interpolated annotation\n        const toolGroup = ToolGroupManager.getToolGroupForViewport(\n            contrastedViewport.id,\n            contrastedViewport.renderingEngineId\n        );\n        const arrowAnnotateInstance = toolGroup.getToolInstance(\"ArrowAnnotate\")\n        console.log('Tool Group', toolGroup, arrowAnnotateInstance)\n        displaySetInstanceUID = cornerstoneViewportService.getViewportInfoByIndex(0).viewportData.data.displaySetInstanceUID;\n        for (const pm of measurements) {\n            if (pm.metadata.handmade && pm.displaySetInstanceUID === displaySetInstanceUID) {\n                arrowAnnotateInstance.removeArrowAnnotation(pm.uid);\n            }\n        }\n        arrowAnnotateInstance.addNewAnnotationWithMovablePoints(contrastedViewport.element, controlPointsInWorld, 'rgb(0, 255, 0)')\n\n        if (debug) {\n            let canvas = await debugShowImage(binarizedArray, layerWidth, layerHeight);\n            let ctx = canvas.getContext('2d')\n            for (let x = 0; x < nbLayers; x++) {\n                drawPoint(ctx, x, f(x), '', 'blue', 2);\n            }\n        }\n    }\n\n    // Control points that can be changed in front will be re-used to compute\n    // A new dental curve thus a new panoramic\n    const generatePanoramicFromControlPoints = async(debug=false) => {\n        //Get control points\n        const displaySetInstanceUID = cornerstoneViewportService.getViewportInfoByIndex(0).viewportData.data.displaySetInstanceUID\n        const controlPointsinViewport = measurementService.getMeasurements()\n            .filter(m => m.toolName === \"ArrowAnnotate\" && m.metadata.handmade && m.displaySetInstanceUID === displaySetInstanceUID)\n\n        if (controlPointsinViewport.length === 0) {\n            uiNotificationService.show({\n                title: `Panoramic Generation Error`,\n                message: `Generate control points first before initiating the computation of the panoramic.`,\n                type: 'error',\n                duration: 3000,\n            });\n            return\n        }\n\n        //If user is asking to regenerate panoramic and there already is one for this serie, delete the previous one\n        // Refresh study list in hanging protocol module\n        hangingProtocolService.refreshStudyList()\n        let hpInfo = hangingProtocolService.getState();\n        //If stage is 2, we already have a panoramic\n        if (hpInfo.stageIndex === 2) {\n            const panoramicViewportInfo = cornerstoneViewportService.getViewportInfoByIndex(1)\n            const dentascanViewportInfo = cornerstoneViewportService.getViewportInfoByIndex(2)\n            console.info('Deleting old panoramic display set...', panoramicViewportInfo.viewportData.data.displaySetInstanceUID)\n            console.info('Deleting old dentascan display set...', dentascanViewportInfo.viewportData.data.displaySetInstanceUID)\n            displaySetService.deleteDisplaySet(panoramicViewportInfo.viewportData.data.displaySetInstanceUID)\n            displaySetService.deleteDisplaySet(dentascanViewportInfo.viewportData.data.displaySetInstanceUID)\n            commandsManager.runCommand('toggleHangingProtocol', {\n                protocolId: 'panoramicViewport',\n                stageIndex: 1\n            })\n        }\n\n        //Display progress bar in front-end\n        setIsProcessingPanoramic(true)\n\n        //Get volume from where we want to compute panoramic on\n        const contrastedDisplaySet = displaySetService.getDisplaySetByUID(\n            cornerstoneViewportService.getViewportInfoByIndex(0).viewportData.data.displaySetInstanceUID\n        )\n        const baseVolumeSeriesUID = contrastedDisplaySet.SeriesInstanceUID.replace('.contrasted', '')\n        const baseVolumeSeries = DicomMetadataStore.getSeries(contrastedDisplaySet.StudyInstanceUID, baseVolumeSeriesUID)\n        const baseId = baseVolumeSeries.instances[0].imageId\n        const baseVolume = cache.getVolumeContainingImageId(baseId)\n        const scalarData = baseVolume.volume.scalarData\n        const dicomDimensions = baseVolume.volume.dimensions\n        const [layerWidth, layerHeight, nbLayers] = dicomDimensions\n        const layerSize = layerWidth * layerHeight\n        let parameters = {layerWidth: layerWidth, layerHeight: layerHeight, nbLayers: nbLayers, layerSize: layerSize};\n\n        //Get data from contrasted image\n        const contrastedViewport = cornerstoneViewportService.getCornerstoneViewportByIndex(0)\n        const contrastedData = contrastedViewport.getImageData()\n\n        //Regenerate points from annoted points in viewport\n        let controlPointsInVolume = controlPointsinViewport[0].points.map(point => {\n            const pointIndex = contrastedData.imageData.worldToIndex(point);\n            return { x: pointIndex[0], y: pointIndex[1] }\n        });\n        controlPointsInVolume.sort((p1, p2) => p1.x - p2.x)\n\n        //LSF method to get best fitting parabola along basePoints\n        const lsfDentalCurve = LSFMethods.polynomial(controlPointsInVolume, {order: 6});\n        const f = lsfDentalCurve.predict;\n\n        // For now we just have control points\n        // We need to regenerate base points, which are equitably distributed points between mix and max control points\n        const minX = controlPointsInVolume[0].x;\n        const maxX = controlPointsInVolume[numberBasePoints - 1].x;\n\n        // Iteration on normals to determine width of panoramic and array of offsets\n        // On each index representing a basePoints, the value represents the width value on the panoramic\n        // from where the corresponding basePoint begins.\n        // TODO\n\n        // Precompute nb steps\n        let dentascans = [getDentascanSection(minX, f, scalarData, parameters)];\n\n        // Compute panoramicWidth and build dentascans\n        let x = minX;\n        while (x < maxX) {\n            x += getTangentVector(f, x)[0];\n\n            const dentascan = getDentascanSection(x, f, scalarData, parameters);\n            dentascans.push(dentascan);\n        }\n        const panoramicWidth = dentascans.length;\n        console.log('PANORAMIC WIDTH', panoramicWidth)\n        parameters['panoramicWidth'] = panoramicWidth;\n\n\n        /*const [a, b, c] = lsfDentalCurve.equation;\n        const dfdx = a * x + b;\n        const fl = Math.sqrt(1 + dfdx * dfdx);\n        const flPrim = (x) => 1/(2*a)*(fl*dfdx + Math.log(fl+dfdx));\n        const panoramicWidth = flPrim(maxX) - flPrim(minX);*/ // TODO\n\n\n        // This promise take a base point and an offset\n        // It computes the dentascan corresponding to the offset and finishes\n        // This needs to be separated from buildPanoramicPromise as we will do a transformation on\n        // the dentascan curves consisting in recalculating the curves.\n        // TODO\n\n        // Compute the value of each dentascan at each layer in order to compute axial curves of each layer\n        const dentalCurvesPointsXY = getDentalCurvesPointsXY(dentascans, 'curveAIP', parameters);\n        const nbDentalCurves = Math.floor(panoramicWidth / DENTAL_CURVES_STEP);\n        const nbAxialCurves = Math.floor(nbLayers / AXIAL_CURVES_STEP);\n\n        //let axialCurvesPoints = new Array(nbAxialCurves * panoramicWidth).fill(null);\n        // Convert an array of long curves points to an array of axial curves points.\n        // The value inside newScalarData contains the x coordinate of the curve\n        for (let l = 0; l < nbAxialCurves; l++) {\n            break;\n            const layer = 1 * l;\n            const [inf, sup] = [Math.max(0, l), l + 1];\n            const coordinatesSlice = dentascanCurvesPoints.slice(inf * nbDentalCurves, sup * nbDentalCurves).filter(value => value);\n            const axialCurve = LSFMethods.polynomial(coordinatesSlice, {order: 6});\n            // TODO\n            for (let i = 0; i < panoramicWidth; i++) {\n                const dentascan = dentascans[i];\n                const middlePoint = dentascan.middlePoint;\n                // We want to find the point where an axial curve crosses a dental segment\n                // Having ax+bx+c the curve of the axial curve and dx + e the curve of the segment,\n                // This is solved by solving the equation ax + (b-d)x + (c-e) = 0\n                // Which admits two roots: -(b-d)-sqrt(delta)/2a and -(b-d)+sqrt(delta)/2a where delta is (b-d)-4a(c-e)\n                /*let [a_, b_, c_] = axialCurve.equation; // TODO\n                const [d_, e_] = dentascan.equation;\n                let xyAxial = null;\n                if (a_ != 0) {\n                    const [a, b, c] = [a_, b_ - d_, c_ - e_];\n                    const delta = b*b - 4*a*c;\n                    if (delta > 0) {\n                        // Two roots\n                        const root1 = (-b - Math.sqrt(delta)) / (2*a);\n                        const root2 = (-b + Math.sqrt(delta)) / (2*a);\n                        if (Math.abs(root1 - middlePoint[0]) < Math.abs(root2 - middlePoint[0])) {\n                            xyAxial = [root1, axialCurve.predict(root1)];\n                        } else {\n                            xyAxial = [root2, axialCurve.predict(root2)];\n                        }\n                    } else if (delta === 0) {\n                        const root = -b / (2*a)\n                        xyAxial = [root, axialCurve.predict(root)];\n                    }\n\n                }*//* else {\n                    const root = (e_ - c_) - (b_ - d_);\n                    xyAxial = [root, axialCurve.predict(root)];\n                }*/ // TODO\n                const [minX, minY] = dentascan.interval[0];\n                let xyAxial = null;\n                let costAxial = layerHeight; // Big value;\n                for (let i = 0; i < dentascan.width; i++) {\n                    const x = minX + i * dentascan.director[0];\n                    const yAxial = axialCurve.predict(x);\n                    const yDental = minY + i * dentascan.director[1];\n\n                    const cost = Math.abs(yAxial - yDental);\n                    if (cost < costAxial) {\n                        costAxial = cost;\n                        xyAxial = [x, yAxial];\n                    }\n                }\n                if (xyAxial) {\n                    let xPosInDentascan = Math.round(DENTASCAN_THICKNESS / 2 + (xyAxial[0] - middlePoint[0]) / dentascan.director[0]);\n                    const yPosInDentascan = layer;\n\n                    if (xPosInDentascan < 0) {\n                        xPosInDentascan = 0;\n                    }\n                    if (xPosInDentascan > DENTASCAN_THICKNESS) {\n                        xPosInDentascan = DENTASCAN_THICKNESS;\n                    }\n                    // Image is transposed\n                    // TODO : handle sigmoid curve on new dental curve\n                    axialCurvesPoints[i * nbAxialCurves + l] = {x: yPosInDentascan, y: xPosInDentascan};\n                }\n            }\n        } //TODO\n\n        //This promise take a base point and an offset\n        //It fills panoramicArray from basePoint to next basePoint\n        //Offset as explained earlier is the starting width of the base point\n        // TODO\n\n        //Init panoramic array\n        let panoramicNormalsIterative = new Float32Array(panoramicWidth * nbLayers).fill(-1000)\n\n        const panoramicDepth = DENTAL_CURVE_THICKNESS + 1;\n        // From start of base point to start of other base point, incremented by vector director between those two points\n        for (let i = 0; i < panoramicWidth; i++) {\n            let dentascan = dentascans[i];\n            const [dentascanMinPoint, dentascanMaxPoint] = dentascan.interval;\n            const [dentascanVxNormal, dentascanVyNormal] = dentascan.director;\n\n            //const coordinatesSlice = axialCurvesPoints.slice(i * nbAxialCurves, (i + 1) * nbAxialCurves).filter(value => value);\n            //const dentalCurve = LSFMethods.polynomial(coordinatesSlice, {order: 3});\n            for (let layer = 0; layer < nbLayers; layer++) {\n                // TODO\n                const pointXY = dentalCurvesPointsXY[Math.floor(layer / AXIAL_CURVES_STEP) * nbDentalCurves + Math.floor(i / DENTAL_CURVES_STEP)];\n                const [x, y] = [pointXY.x, pointXY.y];\n\n                //Get min and max point along normal of dentalCurve which length between the two is DENTAL_CURVE_THICKNESS\n                let minPoint = [x - DENTAL_CURVE_THICKNESS / 2 * dentascanVxNormal,\n                                y - DENTAL_CURVE_THICKNESS / 2 * dentascanVyNormal];\n                let maxPoint = [x + DENTAL_CURVE_THICKNESS / 2 * dentascanVxNormal,\n                                y + DENTAL_CURVE_THICKNESS / 2 * dentascanVyNormal];\n\n                const valuesAlongNormal = [];\n\n                //Get values of point along normal between min and max\n                for (let k = 0; k < panoramicDepth; k++) {\n                    const xk = Math.round(minPoint[0] + k * dentascanVxNormal);\n                    const yk = Math.round(minPoint[1] + k * dentascanVyNormal);\n                    // TODO\n                    let scalarValue = Math.floor((scalarData[layer * layerSize + yk * layerWidth + xk] + 1000) / 16) / 255;\n                    //let scalarValue = (scalarData[layer * layerSize + yk * layerWidth + xk] + 1000) / 16;\n                    //if (scalarValue >= 50) {\n                        //valuesAlongNormal.push(Math.exp(scalarValue / S));\n\n                    // Take data along normal vector where x and y are valid coordinates\n                    if (!isNaN(scalarValue)) {\n                        valuesAlongNormal.push(1 - 0.15 * (scalarValue * scalarValue * scalarValue));\n                    }\n                }\n\n                // Add mean of all values as value in panoramic result\n                // TODO\n                let absorption = valuesAlongNormal.reduce((a, b) => a * b, 1);\n                //let mean = valuesAlongNormal.reduce((a, b) => a + b, 0) / valuesAlongNormal.length;\n                //const max = getMax(valuesAlongNormal);\n                //panoramicNormalsIterative[panoramicWidth * (nbLayers - layer - 1) + i] = S * Math.log(mean) * 16 - 1000;\n                panoramicNormalsIterative[panoramicWidth * (nbLayers - layer - 1) + i] = (1 - absorption) * 255 * 16 - 1000;\n            }\n        }\n        // Post processing\n        let panoramicProcessed = new Array(panoramicWidth * nbLayers).fill(-1000);\n        const gImage = blurPanoramic(panoramicNormalsIterative, panoramicWidth, nbLayers);\n\n        for (let i = 0; i < panoramicWidth * nbLayers; i++) {\n            const image0 = panoramicNormalsIterative[i];\n            const gImage0 = gImage[i];\n            const alpha = 0.9;\n            panoramicProcessed[i] = alpha * image0 + (1 - alpha) * (image0 - gImage0);\n        }\n        /*const oldMin = Math.min(...panoramicNormalsIterative);\n        const oldMax = Math.max(...panoramicNormalsIterative);\n        const newMin = Math.min(...panoramicProcessed);\n        const newMax = Math.max(...panoramicProcessed);\n        const scalingFactor = (oldMax - oldMin) / (newMax - newMin);\n\n\n        // Rescale values\n        for (let i = 0; i < panoramicWidth * nbLayers; i++) {\n            panoramicProcessed[i] = Math.round((panoramicProcessed[i] - newMin) * scalingFactor + oldMin);\n        }*/\n\n\n        if (debug) {\n            for (let l = 0; l < nbLayers; l++) {\n                const scalarSlice = scalarData.slice(l * layerSize, (l + 1) * layerSize);\n                let canvas = await debugShowImage(scalarSlice, layerWidth, layerHeight)\n                let ctx = canvas.getContext('2d');\n                for (let i = 0; i < panoramicWidth; i++) {\n                    const dentascan = dentascans[i];\n                    const mp = dentascan.middlePoint;\n                    const [imin, imax] = dentascan.interval;\n                    drawPoint(ctx, mp[0], mp[1], '', 'purple', 2);\n                    drawPoint(ctx, imin[0], imin[1], '', 'purple', 2);\n                    drawPoint(ctx, imax[0], imax[1], '', 'purple', 2);\n\n                    let xPosInDentascan = dentalCurvesPointsXY[i * nbLayers + l];\n                    if (xPosInDentascan < 0) {\n                        xPosInDentascan = 0;\n                    }\n                    if (xPosInDentascan > DENTASCAN_THICKNESS) {\n                        xPosInDentascan = DENTASCAN_THICKNESS;\n                    }\n                    const [dentascanMinPoint, dentascanMaxPoint] = dentascan.interval;\n                    const [dentascanVxNormal, dentascanVyNormal] = dentascan.director;\n                    const xPt = Math.round(dentascanMinPoint[0] + xPosInDentascan * dentascanVxNormal);\n                    const yPt = Math.round(dentascanMinPoint[1] + xPosInDentascan * dentascanVyNormal);\n                    drawPoint(ctx, xPt, yPt, '', 'green', 2);\n\n                    /*const coordinatesSlice = axialCurvesPoints.slice(i * nbAxialCurves, (i + 1) * nbAxialCurves).filter(value => value);\n                    const xDental = Math.round(dentascanMinPoint[0] + coordinatesSlice[l].y * dentascanVxNormal);\n                    const yDental = Math.round(dentascanMinPoint[1] + coordinatesSlice[l].y * dentascanVyNormal);\n                    drawPoint(ctx, xDental, yDental, '', 'blue', 2);*/\n                }\n            }\n\n            // Debug step 2\n            /*for (let i = 0; i < nbDentalCurves; i++) {\n                const dentascan = dentascans[i];\n                const dentalLiss = getDentalCurve([dentascan]);\n\n                const dentascanData = transposeImage(dentascan.dentascan, dentascan.width, nbLayers);\n                let canvas = await debugShowImage(dentascanData, dentascan.width, nbLayers);\n                let ctx = canvas.getContext('2d');\n                for (let layer = 0; layer < nbLayers; layer+=20) {\n                    const y = dentalLiss.predict(layer);\n                    const minY = Math.round(y - DENTASCAN_THICKNESS / 2);\n                    const maxY = Math.round(y + DENTASCAN_THICKNESS / 2);\n                    for (let j = minY; j < maxY; j += 2) {\n                        drawPoint(ctx, layer, j, '', 'purple', 2);\n                    }\n                }\n                for (let layer = 0; layer < nbLayers; layer++) {\n                    drawPoint(ctx, layer, dentalLiss.predict(layer), '', 'purple', 2);\n                }\n            }*/\n\n            // Debug step 3\n            /*for (let l = 0; l < nbAxialCurves; l++) {\n                const layer = l * 1;\n                const scalarSlice = scalarData.slice(layer * layerSize, (layer + 1) * layerSize);\n                const [inf, sup] = [Math.max(0, l), l + 1];\n\n                let canvas = await debugShowImage(scalarSlice, layerWidth, layerHeight);\n                let ctx = canvas.getContext('2d');\n                for (let i = 0; i < panoramicWidth; i++) {\n                    const dentascan = dentascans[i];\n                    const [dentascanMinPoint, dentascanMaxPoint] = dentascan.interval;\n                    const [dentascanVxNormal, dentascanVyNormal] = dentascan.director;\n                    const point = axialCurvesPoints[i * nbAxialCurves + l];\n                    if (point) {\n                        const xPosInDentascan = point.y;\n                        const xDental = Math.round(dentascanMinPoint[0] + xPosInDentascan * dentascanVxNormal);\n                        const yDental = Math.round(dentascanMinPoint[1] + xPosInDentascan * dentascanVyNormal);\n                        drawPoint(ctx, xDental, yDental, '', 'purple', 3);\n                    }\n                }\n\n                let coordinatesSlice = dentascanCurvesPoints.slice(inf * nbDentalCurves, sup * nbDentalCurves).filter(value => value);\n                const axialCurve = LSFMethods.polynomial(coordinatesSlice, {order: 6});\n                for (let x = Math.min(...coordinatesSlice.map(p => p.x)); x <= Math.max(...coordinatesSlice.map(p => p.x)); x++) {\n                    const yTrue = lsfDentalCurve.predict(x);\n                    drawPoint(ctx, x, yTrue, '', 'green', 1);\n                    const yPred = axialCurve.predict(x);\n                    drawPoint(ctx, x, yPred, '', 'blue', 1);\n                }\n            }*/\n        }\n\n        //Array at start is filled with false\n        //When a promise at a specific basePoint is done, its index goes to true\n        //This array allows us to track state of the promises to display progress bar in front\n\n        //Recursive function to execute promises in array\n        //When promise at index x is done, update doneArray by putting true value and wait a bit\n        //to call recursively function of x + 1 index.\n\n        //Update progress value in front-end by getting each 250ms the number of true values in doneArray\n        //THIS WORKS ONLY WHEN PARENT FUNCTION IS CALLED WITH debug = false\n        /*const waitUntilArrayDone = (start) => {\n            return new Promise<void>((resolve, reject) => {\n                const waitForArray = (start) => {\n                    const completed = doneArray.filter(el => el).length\n                    const progress = (start + Math.round((completed * 100) / 2 / basePoints.length))\n                    setProcessingPourcent(progress)\n                    if (completed === basePoints.length) {\n                        return resolve();\n                    } else {\n                        setTimeout(() => waitForArray(start), 50)\n                    }\n                }\n                waitForArray(start)\n            })\n        }\n        //Wait until panoramic is completed\n        await waitUntilArrayDone(0)*/\n\n        console.log('DONE');\n        let sharpenedPanoramic = panoramicNormalsIterative;//sharpen(panoramicNormalsIterative, panoramicWidth, nbLayers)\n        //sharpenedPanoramic = applySmoothing(sharpenedPanoramic, panoramicWidth, nbLayers)\n\n        if (debug) {\n            debugShowImage(sharpenedPanoramic, nbLayers, panoramicWidth);\n        }\n\n        //Display panoramic in OHIF Viewport\n        const voiLutModule = metaData.get('voiLutModule', baseId);\n        const imagePixelModule = metaData.get('imagePixelModule', baseId);\n        const generalSeriesModule = metaData.get('generalSeriesModule', baseId);\n\n        if (!cornerstoneViewportService.getCornerstoneViewportByIndex(0)) {\n            uiNotificationService.show({\n                title: `Panoramic Generation Error`,\n                message: `No viewport detected.`,\n                type: 'error',\n                duration: 3000,\n            });\n            return;\n        }\n        const panoramicMetadata = {\n            SeriesInstanceUID: generalSeriesModule.seriesInstanceUID + '.panoramic',\n            StudyInstanceUID: generalSeriesModule.studyInstanceUID,\n            BitsAllocated: imagePixelModule.bitsAllocated,\n            BitsStored: imagePixelModule.bitsStored,\n            Rows: nbLayers,\n            Columns: panoramicWidth,\n            WindowCenter: voiLutModule.windowCenter[0],\n            WindowWidth: voiLutModule.windowWidth[0],\n            PixelData: sharpenedPanoramic\n        };\n        const panoramicViewportData = await loadBlobInViewport(panoramicMetadata);\n\n        const dentascanObject = {\n            SeriesInstanceUID: generalSeriesModule.seriesInstanceUID + '.dentascan',\n            StudyInstanceUID: generalSeriesModule.studyInstanceUID,\n            BitsAllocated: imagePixelModule.bitsAllocated,\n            BitsStored: imagePixelModule.bitsStored,\n            Rows: nbLayers,\n            Columns: -1,\n            WindowCenter: voiLutModule.windowCenter[0],\n            WindowWidth: voiLutModule.windowWidth[0],\n            PixelData: dentascans.map(dentascan => dentascan.dentascan) // TODO\n        };\n\n        const dentascansViewportData = await loadMultipleBlobsInViewport(dentascanObject)\n\n        // Refresh study list in hanging protocol module\n        hangingProtocolService.refreshStudyList()\n        hpInfo = hangingProtocolService.getState();\n        commandsManager.runCommand('toggleHangingProtocol', {\n                protocolId: 'panoramicViewport',\n                stageIndex: 2\n        });\n        setPanelMetadata({\n            ...panelMetadata,\n            update: !panelMetadata.update,\n            dentascanViewportData: dentascansViewportData,\n            panoramicViewportData: panoramicViewportData,\n            panoramic: {\n                width: panoramicWidth,\n                height: nbLayers\n            }\n        });\n        //Save state in cache to be retrieved if we reopen panoramic panel\n        cornerstoneCacheService.setPanoramicStateCache({\n            ...panelMetadata,\n            update: !panelMetadata.update,\n            dentascanViewportData: dentascansViewportData,\n            panoramicViewportData: panoramicViewportData,\n            panoramic: {\n                width: panoramicWidth,\n                height: nbLayers\n            }\n        }, generalSeriesModule.seriesInstanceUID);\n\n        console.log('DISPLAY SETS', displaySetService.getDisplaySetCache());\n    }\n\n    // @ts-ignore\n    return (\n        <div style={{width:'100%', height:'100%'}}>\n            <div style={{width:'100%', display:'flex', flexDirection:'column', height:'100%'}}>\n                <p style={{color:'white', fontWeight:'bold', marginBottom:'20px'}}>{'Panoramic Generation'}</p>\n                <p style={{color:'white', fontSize:'small', marginBottom:'10px'}}>{'1 - Generate control points from where panoramic will be computed with'}</p>\n                <Button onClick={() => {generatePanoramicControlPoints(true)}} style={{marginBottom:'20px'}}>{\"Generate Control Points\"}</Button>\n                <p style={{color:'white', fontSize:'small', marginBottom:'20px'}}>{'2 - Adjust the points as needed so that the green line fits best around the white area of the image (along the dental   . The points do not need to be evenly distributed. You can change brightness and contrast of the image to enlighten the white line with the Window Level tool in toolbar.'}</p>\n                <div style={{width:'90%', display:'flex', flexDirection:'column', marginBottom:'20px'}}>\n                    <p style={{color:'white', fontSize:'small', marginBottom:'10px'}}>{'3 - Once the points are well adjusted, you can modify some parameters but be careful : the lower the parameters are set, the faster the execution, but the quality of the panoramic view may be compromised.'}</p>\n                    <p style={{color:'#5ACCE6', fontSize:'smaller', marginBottom:'5px'}}>{'Steps of computation:'}</p>\n                    <div style={{width:\"100%\", display:'flex'}}>\n                        <input\n                            type=\"range\"\n                            id=\"dSection\"\n                            name=\"dSection\"\n                            value={`${Math.floor(numberBasePoints)}`}\n                            min=\"5\" max={\"45\"}\n                            style={{width:'70%', marginRight:'5%'}}\n                            onChange={(e) => {setNumberBasePoints(parseInt(e.target.value))}}\n                        />\n                        <p style={{color:'#5ACCE6', fontSize:'small', width:'25%'}}>{`${numberBasePoints}`}</p>\n                    </div>\n                </div>\n                <p style={{color:'white', fontSize:'small', marginBottom:'10px'}}>{'4 - Once the chosen parameters are good, you can initiate the computation'}</p>\n                <Button onClick={() => {generatePanoramicFromControlPoints(true)}} style={{marginBottom:'10px'}}>{\"Compute Panoramic\"}</Button>\n                {\n                    isProcessingPanoramic &&\n                    <div className={'w-full mt-[10px] mb-[20px]'}>\n                        <p style={{color:'white', fontSize:'small'}}>{'Creating panoramic...'}</p>\n                        <ProgressBar\n                            className={'w-full mt-[3px]'}\n                            bgColor={processingPourcent < 100 ? '#5ACCE6' : '#50C878'}\n                            completed={processingPourcent}\n                            transitionDuration={\"0.05s\"}\n                            transitionTimingFunction={\"linear\"}\n                        />\n                    </div>\n                }\n                { panelMetadata.panoramic?.width &&\n                    <div style={{width:'100%', display:'flex', flexDirection:'column', justifyContent:'space-evenly', height:'18%'}}>\n                        <p style={{color:'white', fontWeight:'bold'}}>{'Dentascan Editing'}</p>\n                        <p style={{color:'white', fontSize:'small', marginBottom:'10px'}}>{'5 - Scroll through the dentascans using this slider. The central dentascan is represented by the white line on the panoramic view.'}</p>\n                        <div style={{width:'90%', display:'flex', height:'10%', flexDirection:'row', justifyContent:'space-between'}}>\n                            <p style={{color:'white', fontSize:'smaller'}}>{'Section:'}</p>\n                            <input\n                                type=\"range\"\n                                id=\"dSection\"\n                                name=\"dSection\"\n                                value={`${Math.floor(panelMetadata.dentascanViewportData.data.initialImageIndex)}`}\n                                min=\"0\" max={`${panelMetadata.panoramic.width - 1}`}\n                                style={{width:'70%'}}\n                                onChange={(e) => {setPanelMetadata({\n                                    ...panelMetadata,\n                                    update: !panelMetadata.update,\n                                    dentascanViewportData: {\n                                        ...panelMetadata.dentascanViewportData,\n                                        data: {\n                                            ...panelMetadata.dentascanViewportData.data,\n                                            initialImageIndex: Math.floor(Number(e.target.value))\n                                        }\n                                    }\n                                })}}\n                            />\n                        </div>\n                    </div>\n                }\n            </div>\n        </div>\n    );\n}\n","export function antiAlias(imageData, width, height, intensity) {\n    const resultImageData = imageData.slice();\n\n    for (let y = 1; y < height - 1; y++) {\n        for (let x = 1; x < width - 1; x++) {\n            const index = y * width + x;\n            const gray =\n                (imageData[(y - 1) * width + x - 1] * intensity +\n                    imageData[(y - 1) * width + x] * intensity +\n                    imageData[(y - 1) * width + x + 1] * intensity +\n                    imageData[y * width + x - 1] * intensity +\n                    imageData[y * width + x] +\n                    imageData[y * width + x + 1] * intensity +\n                    imageData[(y + 1) * width + x - 1] * intensity +\n                    imageData[(y + 1) * width + x] * intensity +\n                    imageData[(y + 1) * width + x + 1] * intensity) /\n                1 + intensity * 8;\n\n            // Mettre  jour la valeur de pixel dans l'image rsultante\n            resultImageData[index] = gray;\n        }\n    }\n\n    return resultImageData;\n}\n\nexport function sharpen(imageData, width, height) {\n    // Crer une copie de l'image pour ne pas modifier l'original\n    const resultImageData = imageData.slice();\n\n    // Matrice de renforcement\n    const sharpenMatrix = [\n        [0, -1, 0],\n        [-1, 5, -1],\n        [0, -1, 0],\n    ];\n\n    const matrixSize = 3; // Taille de la matrice (3x3)\n\n    for (let y = 1; y < height - 1; y++) {\n        for (let x = 1; x < width - 1; x++) {\n            let sum = 0;\n\n            // Appliquer la matrice de renforcement aux pixels voisins\n            for (let i = 0; i < matrixSize; i++) {\n                for (let j = 0; j < matrixSize; j++) {\n                    const pixelX = x + j - 1;\n                    const pixelY = y + i - 1;\n                    const index = pixelY * width + pixelX;\n                    sum += imageData[index] * sharpenMatrix[i][j];\n                }\n            }\n\n            // S'assurer que la valeur est dans la plage [0, 255]\n            sum = Math.min(32767, Math.max(-32768, sum));\n\n            // Mettre  jour la valeur de pixel dans l'image rsultante\n            const index = y * width + x;\n            resultImageData[index] = sum;\n        }\n    }\n\n    return resultImageData;\n}\n\nexport function blurPanoramic(imageData, width, height) {\n    const resultImageData = imageData.slice();\n\n    const sigma = 0.8;\n    const gaussianBlur = (dist) => Math.exp(-dist / (2 * sigma * sigma)) / (2 * Math.PI * sigma * sigma);\n    const [g0, g1, g2] = [gaussianBlur(0), gaussianBlur(1), gaussianBlur(2)];\n\n    const kernel = [\n        [g2, g1, g2],\n        [g1, g0, g1],\n        [g2, g1, g2],\n    ];\n    const normalizeCoef = 1 / (g0 + 4 * g1 + 4 * g2);\n\n    const kernelSize = kernel.length;\n    const halfKernelSize = Math.floor(kernelSize / 2);\n\n    for (let y = halfKernelSize; y < height - halfKernelSize; y++) {\n        for (let x = halfKernelSize; x < width - halfKernelSize; x++) {\n            let sum = 0;\n            for (let ky = 0; ky < kernelSize; ky++) {\n                for (let kx = 0; kx < kernelSize; kx++) {\n                    const pixelX = x + kx - halfKernelSize;\n                    const pixelY = y + ky - halfKernelSize;\n                    const index = pixelY * width + pixelX;\n\n                    // Appliquer le noyau de convolution au pixel.\n                    sum += imageData[index] * kernel[ky][kx];\n                }\n            }\n\n            // Normaliser la somme en fonction de l'intensit.\n            sum *= normalizeCoef;\n\n            // Mettre  jour la valeur du pixel dans l'image rsultante.\n            resultImageData[y * width + x] = sum;\n        }\n    }\n\n    return resultImageData;\n}\n\nexport function applySmoothing(imageData, width, height) {\n    const resultImageData = imageData.slice();\n\n    const kernel = [\n        [0, 1, 0],\n        [0, 1, 0],\n        [0, 1, 0],\n    ]; // Noyau de convolution simple pour l'adoucissement.\n\n    const kernelSize = kernel.length;\n    const halfKernelSize = Math.floor(kernelSize / 2);\n\n    for (let y = halfKernelSize; y < height - halfKernelSize; y++) {\n        for (let x = halfKernelSize; x < width - halfKernelSize; x++) {\n            let sum = 0;\n\n            for (let ky = 0; ky < kernelSize; ky++) {\n                for (let kx = 0; kx < kernelSize; kx++) {\n                    const pixelX = x + kx - halfKernelSize;\n                    const pixelY = y + ky - halfKernelSize;\n                    const index = pixelY * width + pixelX;\n\n                    // Appliquer le noyau de convolution au pixel.\n                    sum += imageData[index] * kernel[ky][kx];\n                }\n            }\n\n            // Normaliser la somme en fonction de l'intensit.\n            sum /= 3;\n\n            // Mettre  jour la valeur du pixel dans l'image rsultante.\n            resultImageData[y * width + x] = sum;\n        }\n    }\n\n    return resultImageData;\n}\n\nexport function calculateNormalCurve(curve, ind, nbNormals) {\n    const norm = [];\n\n    if (curve.length <= 1 || ind < 0 || ind >= curve.length) {\n        // Gestion des cas spciaux o la normale ne peut pas tre calcule\n        return norm;\n    }\n\n    // Coordonnes du point \"p\"\n    const [px, py] = curve[ind];\n\n    // Calcul des tangentes aux points voisins\n    let [tx, ty] = [0, 0]; // Tangente au point \"p\"\n\n    if (ind > 10) {\n        const [prevX, prevY] = curve[ind - 10];\n        tx += px - prevX;\n        ty += py - prevY;\n    }\n\n    if (ind < curve.length - 10) {\n        const [nextX, nextY] = curve[ind + 10];\n        tx += nextX - px;\n        ty += nextY - py;\n    }\n\n    // Calcul de la normale (perpendiculaire  la tangente)\n    const magnitude = Math.sqrt(tx * tx + ty * ty);\n    if (magnitude === 0) {\n        // Gestion du cas o la tangente est nulle (point isol)\n        return norm;\n    }\n\n    const nx = -ty / magnitude; // Composante x de la normale\n    const ny = tx / magnitude; // Composante y de la normale\n\n    // Ajout du point \"p\" dans \"norm\"\n    norm.push([px, py]);\n\n    const stepSize = magnitude / (nbNormals / 2); // nbNormals points au total, y compris \"p\"\n    let currentX = px - nx * magnitude;\n    let currentY = py - ny * magnitude;\n\n    // Calcul des points quidistants sur la normale\n    for (let i = 0; i < nbNormals; i++) {\n        currentX += nx * stepSize;\n        currentY += ny * stepSize;\n        norm.push([currentX, currentY]);\n    }\n\n    return norm;\n}\n\nexport function cubicSplineInterpolation(arr, x) {\n    const n = arr.length;\n    let i = 0;\n\n    if (x >= arr[n - 1][0]) {\n        i = n - 2;\n    } else {\n        while (x > arr[i + 1][0]) {\n            i++;\n        }\n    }\n\n    const x1 = arr[i][0];\n    const x2 = arr[Math.min(i + 1, n - 1)][0];\n\n    const y0 = arr[Math.max(i - 1, 0)][1];\n    const y1 = arr[i][1];\n    const y2 = arr[Math.min(i + 1, n - 1)][1];\n    const y3 = arr[Math.min(i + 2, n - 1)][1];\n\n    const t = (x - x1) / (x2 - x1);\n    const t2 = t * t;\n    const t3 = t * t2;\n\n    const a = -0.5 * y0 + 1.5 * y1 - 1.5 * y2 + 0.5 * y3;\n    const b = y0 - 2.5 * y1 + 2 * y2 - 0.5 * y3;\n    const c = -0.5 * y0 + 0.5 * y2;\n    const d = y1;\n\n    const y = a * t3 + b * t2 + c * t + d;\n\n    return [x, y];\n}\n\nfunction linearInterpolationCoefficients(point1, point2) {\n    const [x1, y1] = point1;\n    const [x2, y2] = point2;\n\n    if (x1 === x2) {\n        throw new Error('Les deux points doivent avoir des coordonnes x diffrentes pour l\\'interpolation linaire.');\n    }\n\n    const a = (y2 - y1) / (x2 - x1);\n    const b = y1 - a * x1;\n\n    return [Math.round(a), Math.round(b)];\n}\n\n//Complete cubic spline interpolation in order to have linear interpolation in the beginning and in the end of the curve\nfunction completeInterpolation(interpolatedPoints, xMax){\n    const [a0, b0] = linearInterpolationCoefficients(interpolatedPoints[0], interpolatedPoints[10])\n    const [a1, b1] = linearInterpolationCoefficients(interpolatedPoints[interpolatedPoints.length - 10], interpolatedPoints[interpolatedPoints.length - 1])\n    const stepBegin = interpolatedPoints[0][0] / (xMax / 3)\n    const stepEnd = (xMax - interpolatedPoints[interpolatedPoints.length - 1][0]) / (xMax / 3)\n    for(let x = 0; x < interpolatedPoints[0][0]; x += stepBegin){\n        interpolatedPoints.push([x, a0 * x + b0])\n    }\n    interpolatedPoints.sort((a, b) => a[0] - b[0]);\n\n    for(let x = interpolatedPoints[interpolatedPoints.length - 1][0] + stepEnd; x < xMax; x += stepEnd){\n        interpolatedPoints.push([x, a1 * x + b1])\n    }\n\n    return  interpolatedPoints.map(p => {\n        return [p[0], p[1], 0]\n    })\n}\n","import React from 'react';\nimport {\n  WrappedPanelStudyBrowser,\n  PanelMeasurementTable,\n  Edition3DPanel,\n  PanoramicGenerationPanel\n} from './Panels';\nimport ActionButtons from \"./Panels/ActionButtons\";\n\n// TODO:\n// - No loading UI exists yet\n// - cancel promises when component is destroyed\n// - show errors in UI for thumbnails if promise fails\n\nfunction getPanelModule({\n  commandsManager,\n  extensionManager,\n  servicesManager,\n}) {\n  const wrappedMeasurementPanel = () => {\n    return (\n      <PanelMeasurementTable\n        commandsManager={commandsManager}\n        servicesManager={servicesManager}\n        extensionManager={extensionManager}\n      />\n    );\n  };\n\n  return [\n    {\n      name: 'seriesList',\n      iconName: 'group-layers',\n      iconLabel: 'Studies',\n      label: 'Studies',\n      component: WrappedPanelStudyBrowser.bind(null, {\n        commandsManager,\n        extensionManager,\n        servicesManager,\n      }),\n    },\n    {\n      name: 'measure',\n      iconName: 'tab-linear',\n      iconLabel: 'Measure',\n      label: 'Measurements',\n      secondaryLabel: 'Measurements',\n      component: wrappedMeasurementPanel,\n    },\n    {\n      name: 'volumeEditionPanel',\n      iconName: 'edition-3D',\n      iconLabel: '3D Edition',\n      label: '3D Edition',\n      component: Edition3DPanel.bind(null, {\n        commandsManager,\n        extensionManager,\n        servicesManager\n      }),\n    },\n    {\n      name: 'panoramicGenerationPanel',\n      iconName: 'panoramic',\n      iconLabel: 'Panoramic Generation',\n      label: 'Panoramic',\n      component: PanoramicGenerationPanel.bind(null, {\n        commandsManager,\n        extensionManager,\n        servicesManager\n      }),\n    },\n  ];\n}\n\nexport default getPanelModule;\n","import packageJson from '../package.json';\n\nconst id = packageJson.name;\n\nexport { id };\n","import { isImage } from '@ohif/core/src/utils/isImage';\nimport sopClassDictionary from '@ohif/core/src/utils/sopClassDictionary';\nimport ImageSet from '@ohif/core/src/classes/ImageSet';\nimport isDisplaySetReconstructable from '@ohif/core/src/utils/isDisplaySetReconstructable';\nimport { id } from './id';\n\nconst sopClassHandlerName = 'stack';\n\nconst isMultiFrame = instance => {\n  return instance.NumberOfFrames > 1;\n};\n\nconst makeDisplaySet = instances => {\n  const instance = instances[0];\n  const imageSet = new ImageSet(instances);\n\n  const {\n    value: isReconstructable,\n    averageSpacingBetweenFrames,\n  } = isDisplaySetReconstructable(instances);\n\n  // set appropriate attributes to image set...\n  imageSet.setAttributes({\n    displaySetInstanceUID: imageSet.uid, // create a local alias for the imageSet UID\n    SeriesDate: instance.SeriesDate,\n    SeriesTime: instance.SeriesTime,\n    SeriesInstanceUID: instance.SeriesInstanceUID,\n    StudyInstanceUID: instance.StudyInstanceUID,\n    SeriesNumber: instance.SeriesNumber || 0,\n    FrameRate: instance.FrameTime,\n    SOPClassUID: instance.SOPClassUID,\n    SeriesDescription: instance.SeriesDescription || '',\n    Modality: instance.Modality,\n    isMultiFrame: isMultiFrame(instance),\n    countIcon: isReconstructable ? 'icon-mpr' : undefined,\n    numImageFrames: instances.length,\n    SOPClassHandlerId: `${id}.sopClassHandlerModule.${sopClassHandlerName}`,\n    isReconstructable,\n    averageSpacingBetweenFrames: averageSpacingBetweenFrames || null,\n  });\n\n  // Sort the images in this series if needed\n  const shallSort = true; //!OHIF.utils.ObjectPath.get(Meteor, 'settings.public.ui.sortSeriesByIncomingOrder');\n  if (shallSort) {\n    imageSet.sortBy((a, b) => {\n      // Sort by InstanceNumber (0020,0013)\n      return (\n        (parseInt(a.InstanceNumber) || 0) - (parseInt(b.InstanceNumber) || 0)\n      );\n    });\n  }\n\n  // Include the first image instance number (after sorted)\n  /*imageSet.setAttribute(\n    'instanceNumber',\n    imageSet.getImage(0).InstanceNumber\n  );*/\n\n  /*const isReconstructable = isDisplaySetReconstructable(series, instances);\n\n  imageSet.isReconstructable = isReconstructable.value;\n\n  if (isReconstructable.missingFrames) {\n    // TODO -> This is currently unused, but may be used for reconstructing\n    // Volumes with gaps later on.\n    imageSet.missingFrames = isReconstructable.missingFrames;\n  }*/\n\n  return imageSet;\n};\n\nconst isSingleImageModality = modality => {\n  return modality === 'CR' || modality === 'MG' || modality === 'DX';\n};\n\nfunction getSopClassUids(instances) {\n  const uniqueSopClassUidsInSeries = new Set();\n  instances.forEach(instance => {\n    uniqueSopClassUidsInSeries.add(instance.SOPClassUID);\n  });\n  const sopClassUids = Array.from(uniqueSopClassUidsInSeries);\n\n  return sopClassUids;\n}\n\n/**\n * Basic SOPClassHandler:\n * - For all Image types that are stackable, create\n *   a displaySet with a stack of images\n *\n * @param {Array} sopClassHandlerModules List of SOP Class Modules\n * @param {SeriesMetadata} series The series metadata object from which the display sets will be created\n * @returns {Array} The list of display sets created for the given series object\n */\nfunction getDisplaySetsFromSeries(instances) {\n  // If the series has no instances, stop here\n  if (!instances || !instances.length) {\n    throw new Error('No instances were provided');\n  }\n\n  const displaySets = [];\n  const sopClassUids = getSopClassUids(instances);\n\n  // Search through the instances (InstanceMetadata object) of this series\n  // Split Multi-frame instances and Single-image modalities\n  // into their own specific display sets. Place the rest of each\n  // series into another display set.\n  const stackableInstances = [];\n  instances.forEach(instance => {\n    // All imaging modalities must have a valid value for sopClassUid (x00080016) or rows (x00280010)\n    if (!isImage(instance.SOPClassUID) && !instance.Rows) {\n      return;\n    }\n\n    let displaySet;\n\n    if (isMultiFrame(instance)) {\n      displaySet = makeDisplaySet([instance]);\n\n      displaySet.setAttributes({\n        sopClassUids,\n        isClip: true,\n        numImageFrames: instance.NumberOfFrames,\n        instanceNumber: instance.InstanceNumber,\n        acquisitionDatetime: instance.AcquisitionDateTime,\n      });\n      displaySets.push(displaySet);\n    } else if (isSingleImageModality(instance.Modality)) {\n      displaySet = makeDisplaySet([instance]);\n      displaySet.setAttributes({\n        sopClassUids,\n        instanceNumber: instance.InstanceNumber,\n        acquisitionDatetime: instance.AcquisitionDateTime,\n      });\n      displaySets.push(displaySet);\n    } else {\n      stackableInstances.push(instance);\n    }\n  });\n\n  if (stackableInstances.length) {\n    const displaySet = makeDisplaySet(stackableInstances);\n    displaySet.setAttribute('studyInstanceUid', instances[0].StudyInstanceUID);\n    displaySet.setAttributes({\n      sopClassUids,\n    });\n    displaySets.push(displaySet);\n  }\n\n  return displaySets;\n}\n\nconst sopClassUids = [\n  sopClassDictionary.ComputedRadiographyImageStorage,\n  sopClassDictionary.DigitalXRayImageStorageForPresentation,\n  sopClassDictionary.DigitalXRayImageStorageForProcessing,\n  sopClassDictionary.DigitalMammographyXRayImageStorageForPresentation,\n  sopClassDictionary.DigitalMammographyXRayImageStorageForProcessing,\n  sopClassDictionary.DigitalIntraOralXRayImageStorageForPresentation,\n  sopClassDictionary.DigitalIntraOralXRayImageStorageForProcessing,\n  sopClassDictionary.CTImageStorage,\n  sopClassDictionary.EnhancedCTImageStorage,\n  sopClassDictionary.LegacyConvertedEnhancedCTImageStorage,\n  sopClassDictionary.UltrasoundMultiframeImageStorage,\n  sopClassDictionary.MRImageStorage,\n  sopClassDictionary.EnhancedMRImageStorage,\n  sopClassDictionary.EnhancedMRColorImageStorage,\n  sopClassDictionary.LegacyConvertedEnhancedMRImageStorage,\n  sopClassDictionary.UltrasoundImageStorage,\n  sopClassDictionary.UltrasoundImageStorageRET,\n  sopClassDictionary.SecondaryCaptureImageStorage,\n  sopClassDictionary.MultiframeSingleBitSecondaryCaptureImageStorage,\n  sopClassDictionary.MultiframeGrayscaleByteSecondaryCaptureImageStorage,\n  sopClassDictionary.MultiframeGrayscaleWordSecondaryCaptureImageStorage,\n  sopClassDictionary.MultiframeTrueColorSecondaryCaptureImageStorage,\n  sopClassDictionary.XRayAngiographicImageStorage,\n  sopClassDictionary.EnhancedXAImageStorage,\n  sopClassDictionary.XRayRadiofluoroscopicImageStorage,\n  sopClassDictionary.EnhancedXRFImageStorage,\n  sopClassDictionary.XRay3DAngiographicImageStorage,\n  sopClassDictionary.XRay3DCraniofacialImageStorage,\n  sopClassDictionary.BreastTomosynthesisImageStorage,\n  sopClassDictionary.BreastProjectionXRayImageStorageForPresentation,\n  sopClassDictionary.BreastProjectionXRayImageStorageForProcessing,\n  sopClassDictionary.IntravascularOpticalCoherenceTomographyImageStorageForPresentation,\n  sopClassDictionary.IntravascularOpticalCoherenceTomographyImageStorageForProcessing,\n  sopClassDictionary.NuclearMedicineImageStorage,\n  sopClassDictionary.VLEndoscopicImageStorage,\n  sopClassDictionary.VideoEndoscopicImageStorage,\n  sopClassDictionary.VLMicroscopicImageStorage,\n  sopClassDictionary.VideoMicroscopicImageStorage,\n  sopClassDictionary.VLSlideCoordinatesMicroscopicImageStorage,\n  sopClassDictionary.VLPhotographicImageStorage,\n  sopClassDictionary.VideoPhotographicImageStorage,\n  sopClassDictionary.OphthalmicPhotography8BitImageStorage,\n  sopClassDictionary.OphthalmicPhotography16BitImageStorage,\n  sopClassDictionary.OphthalmicTomographyImageStorage,\n  sopClassDictionary.VLWholeSlideMicroscopyImageStorage,\n  sopClassDictionary.PositronEmissionTomographyImageStorage,\n  sopClassDictionary.EnhancedPETImageStorage,\n  sopClassDictionary.LegacyConvertedEnhancedPETImageStorage,\n  sopClassDictionary.RTImageStorage,\n  sopClassDictionary.EnhancedUSVolumeStorage,\n];\n\nfunction getSopClassHandlerModule() {\n  return [\n    {\n      name: sopClassHandlerName,\n      sopClassUids,\n      getDisplaySetsFromSeries,\n    },\n  ];\n}\n\nexport default getSopClassHandlerModule;\n","import React from 'react';\n\nexport default function ToolbarDivider() {\n  return (\n    <span className=\"self-center w-4 h-8 mx-2 border-l border-common-dark\" />\n  );\n}\n","import React, { useEffect, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { LayoutSelector as OHIFLayoutSelector, ToolbarButton } from '@ohif/ui';\n\nimport { ServicesManager } from '@ohif/core';\n\nfunction LayoutSelector({\n  rows,\n  columns,\n  className,\n  servicesManager,\n  ...rest\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n\n  const {\n    hangingProtocolService,\n    toolbarService,\n  } = (servicesManager as ServicesManager).services;\n\n  const closeOnOutsideClick = () => {\n    if (isOpen) {\n      setIsOpen(false);\n    }\n  };\n\n  useEffect(() => {\n    const { unsubscribe } = hangingProtocolService.subscribe(\n      hangingProtocolService.EVENTS.PROTOCOL_CHANGED,\n      evt => {\n        const { protocol } = evt;\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, [hangingProtocolService]);\n\n  useEffect(() => {\n    window.addEventListener('click', closeOnOutsideClick);\n    return () => {\n      window.removeEventListener('click', closeOnOutsideClick);\n    };\n  }, [isOpen]);\n\n  const onInteractionHandler = () => setIsOpen(!isOpen);\n  const DropdownContent = isOpen ? OHIFLayoutSelector : null;\n\n  const onSelectionHandler = props => {\n    toolbarService.recordInteraction({\n      interactionType: 'action',\n      commands: [\n        {\n          commandName: 'setViewportGridLayout',\n          commandOptions: { ...props },\n          context: 'DEFAULT',\n        },\n      ],\n    });\n  };\n\n  return (\n    <ToolbarButton\n      id=\"Layout\"\n      label=\"Grid Layout\"\n      icon=\"tool-layout\"\n      onInteraction={onInteractionHandler}\n      className={className}\n      rounded={rest.rounded}\n      dropdownContent={\n        DropdownContent !== null && (\n          <DropdownContent\n            rows={rows}\n            columns={columns}\n            onSelection={onSelectionHandler}\n          />\n        )\n      }\n      isActive={isOpen}\n      type=\"toggle\"\n    />\n  );\n}\n\nLayoutSelector.propTypes = {\n  rows: PropTypes.number,\n  columns: PropTypes.number,\n  onLayoutChange: PropTypes.func,\n  servicesManager: PropTypes.instanceOf(ServicesManager),\n};\n\nLayoutSelector.defaultProps = {\n  rows: 3,\n  columns: 3,\n  onLayoutChange: () => {},\n};\n\nexport default LayoutSelector;\n","import { SplitButton } from '@ohif/ui';\n\nexport default SplitButton;\n","import { Types } from '@ohif/ui';\nimport { Menu, SelectorProps, MenuItem, ContextMenuProps } from './types';\n\ntype ContextMenuItem = Types.ContextMenuItem;\n\n/**\n * Finds menu by menu id\n *\n * @returns Menu having the menuId\n */\nexport function findMenuById(menus: Menu[], menuId?: string): Menu {\n  if (!menuId) {\n    return;\n  }\n\n  return menus.find(menu => menu.id === menuId);\n}\n\n/**\n * Default finding menu method.  This method will go through\n * the list of menus until it finds the first one which\n * has no selector, OR has the selector, when applied to the\n * check props, return true.\n * The selectorProps are a set of provided properties which can be\n * passed into the selector function to determine when to display a menu.\n * For example, a selector function of:\n * `({displayset}) => displaySet?.SeriesDescription?.indexOf?.('Left')!==-1\n * would match series descriptions containing 'Left'.\n *\n * @param {Object[]} menus List of menus\n * @param {*} subProps\n * @returns\n */\nexport function findMenuDefault(\n  menus: Menu[],\n  subProps: Record<string, unknown>\n): Menu {\n  if (!menus) {\n    return null;\n  }\n  return menus.find(\n    menu => !menu.selector || menu.selector(subProps.selectorProps)\n  );\n}\n\n/**\n * Finds the menu to be used for different scenarios:\n * This will first look for a subMenu with the specified subMenuId\n * Next it will look for the first menu whose selector returns true.\n *\n * @param menus - List of menus\n * @param props - root props\n * @param menuIdFilter - menu id identifier (to be considered on selection)\n *      This is intended to support other types of filtering in the future.\n */\nexport function findMenu(\n  menus: Menu[],\n  props?: Types.IProps,\n  menuIdFilter?: string\n) {\n  const { subMenu } = props;\n\n  function* findMenuIterator() {\n    yield findMenuById(menus, menuIdFilter || subMenu);\n    yield findMenuDefault(menus, props);\n  }\n\n  const findIt = findMenuIterator();\n\n  let current = findIt.next();\n  let menu = current.value;\n\n  while (!current.done) {\n    menu = current.value;\n\n    if (menu) {\n      findIt.return();\n    }\n    current = findIt.next();\n  }\n\n  console.log('Menu chosen', menu?.id || 'NONE');\n\n  return menu;\n}\n\n/**\n * Returns the menu from a list of possible menus, based on the actual state of component props and tool data nearby.\n * This uses the findMenu command above to first find the appropriate\n * menu, and then it chooses the actual contents of that menu.\n * A menu item can be optional by implementing the 'selector',\n * which will be called with the selectorProps, and if it does not return true,\n * then the item is excluded.\n *\n * Other menus can be delegated to by setting the delegating value to\n * a string id for another menu.  That menu's content will replace the\n * current menu item (only if the item would be included).\n *\n * This allows single id menus to be chosen by id, but have varying contents\n * based on the delegated menus.\n *\n * Finally, for each item, the adaptItem call is made.  This allows\n * items to modify themselves before being displayed, such as\n * incorporating additional information from translation sources.\n * See the `test-mode` examples for details.\n *\n * @param selectorProps\n * @param {*} event event that originates the context menu\n * @param {*} menus List of menus\n * @param {*} menuIdFilter\n * @returns\n */\nexport function getMenuItems(\n  selectorProps: SelectorProps,\n  event: Event,\n  menus: Menu[],\n  menuIdFilter?: string\n): MenuItem[] | void {\n  // Include both the check props and the ...check props as one is used\n  // by the child menu and the other used by the selector function\n  const subProps = { selectorProps, event };\n\n  const menu = findMenu(menus, subProps, menuIdFilter);\n\n  if (!menu) {\n    return undefined;\n  }\n\n  if (!menu.items) {\n    console.warn('Must define items in menu', menu);\n    return [];\n  }\n\n  let menuItems = [];\n  menu.items.forEach(item => {\n    const { delegating, selector, subMenu } = item;\n\n    if (!selector || selector(selectorProps)) {\n      if (delegating) {\n        menuItems = [\n          ...menuItems,\n          ...getMenuItems(selectorProps, event, menus, subMenu),\n        ];\n      } else {\n        const toAdd = adaptItem(item, subProps);\n        menuItems.push(toAdd);\n      }\n    }\n  });\n\n  return menuItems;\n}\n\n/**\n * Returns item adapted to be consumed by ContextMenu component\n * and then goes through the item to add action behaviour for clicking the item,\n * making it compatible with the default ContextMenu display.\n *\n * @param {Object} item\n * @param {Object} subProps\n * @returns a MenuItem that is compatible with the base ContextMenu\n *    This requires having a label and set of actions to be called.\n */\nexport function adaptItem(\n  item: MenuItem,\n  subProps: ContextMenuProps\n): ContextMenuItem {\n  const newItem: ContextMenuItem = {\n    ...item,\n    value: subProps.selectorProps?.value,\n  };\n\n  if (item.actionType === 'ShowSubMenu' && !newItem.iconRight) {\n    newItem.iconRight = 'chevron-menu';\n  }\n  if (!item.action) {\n    newItem.action = (itemRef, componentProps) => {\n      const { event = {} } = componentProps;\n      const { detail = {} } = event;\n      newItem.element = detail.element;\n\n      componentProps.onClose();\n      const action = componentProps[`on${itemRef.actionType || 'Default'}`];\n      if (action) {\n        action.call(componentProps, newItem, itemRef, subProps);\n      } else {\n        console.warn('No action defined for', itemRef);\n      }\n    };\n  }\n\n  return newItem;\n}\n","import * as ContextMenuItemsBuilder from './ContextMenuItemsBuilder';\nimport ContextMenu from '../../../../platform/ui/src/components/ContextMenu/ContextMenu';\nimport { CommandsManager, ServicesManager, Types } from '@ohif/core';\nimport { Menu, MenuItem, Point, ContextMenuProps } from './types';\n\n/**\n * The context menu controller is a helper class that knows how\n * to manage context menus based on the UI Customization Service.\n * There are a few parts to this:\n *    1. Basic controls to manage displaying and hiding context menus\n *    2. Menu selection services, which use the UI customization service\n *       to choose which menu to display\n *    3. Menu item adapter services to convert menu items into displayable and actionable items.\n *\n * The format for a menu is defined in the exported type MenuItem\n */\nexport default class ContextMenuController {\n  commandsManager: CommandsManager;\n  services: Types.Services;\n  menuItems: Menu[] | MenuItem[];\n\n  constructor(\n    servicesManager: ServicesManager,\n    commandsManager: CommandsManager\n  ) {\n    this.services = servicesManager.services as Obj;\n    this.commandsManager = commandsManager;\n  }\n\n  closeContextMenu() {\n    this.services.uiDialogService.dismiss({ id: 'context-menu' });\n  }\n\n  /**\n   * Figures out which context menu is appropriate to display and shows it.\n   *\n   * @param contextMenuProps - the context menu properties, see ./types.ts\n   * @param viewportElement - the DOM element this context menu is related to\n   * @param defaultPointsPosition - a default position to show the context menu\n   */\n  showContextMenu(\n    contextMenuProps: ContextMenuProps,\n    viewportElement,\n    defaultPointsPosition\n  ): void {\n    if (!this.services.uiDialogService) {\n      console.warn('Unable to show dialog; no UI Dialog Service available.');\n      return;\n    }\n\n    const { event, subMenu, menuId, menus, selectorProps } = contextMenuProps;\n\n    console.log('Getting items from', menus);\n    const items = ContextMenuItemsBuilder.getMenuItems(\n      selectorProps || contextMenuProps,\n      event,\n      menus,\n      menuId\n    );\n\n    this.services.uiDialogService.dismiss({ id: 'context-menu' });\n    this.services.uiDialogService.create({\n      id: 'context-menu',\n      isDraggable: false,\n      preservePosition: false,\n      preventCutOf: true,\n      defaultPosition: ContextMenuController._getDefaultPosition(\n        defaultPointsPosition,\n        event?.detail,\n        viewportElement\n      ),\n      event,\n      content: ContextMenu,\n\n      // This naming is part of hte uiDialogService convention\n      // Clicking outside simpy closes the dialog box.\n      onClickOutside: () =>\n        this.services.uiDialogService.dismiss({ id: 'context-menu' }),\n\n      contentProps: {\n        items,\n        selectorProps,\n        menus,\n        event,\n        subMenu,\n        eventData: event?.detail,\n\n        onClose: () => {\n          this.services.uiDialogService.dismiss({ id: 'context-menu' });\n        },\n\n        /**\n         * Displays a sub-menu, removing this menu\n         * @param {*} item\n         * @param {*} itemRef\n         * @param {*} subProps\n         */\n        onShowSubMenu: (item, itemRef, subProps) => {\n          if (!itemRef.subMenu) {\n            console.warn('No submenu defined for', item, itemRef, subProps);\n            return;\n          }\n          this.showContextMenu(\n            {\n              ...contextMenuProps,\n              menuId: itemRef.subMenu,\n            },\n            viewportElement,\n            defaultPointsPosition\n          );\n        },\n\n        // Default is to run the specified commands.\n        onDefault: (item, itemRef, subProps) => {\n          this.commandsManager.run(item, {\n            ...selectorProps,\n            ...itemRef,\n            subProps,\n          });\n        },\n      },\n    });\n  }\n\n  static getDefaultPosition = (): Point => {\n    return {\n      x: 0,\n      y: 0,\n    };\n  };\n\n  static _getEventDefaultPosition = eventDetail => ({\n    x: eventDetail && eventDetail.currentPoints.client[0],\n    y: eventDetail && eventDetail.currentPoints.client[1],\n  });\n\n  static _getElementDefaultPosition = element => {\n    if (element) {\n      const boundingClientRect = element.getBoundingClientRect();\n      return {\n        x: boundingClientRect.x,\n        y: boundingClientRect.y,\n      };\n    }\n\n    return {\n      x: undefined,\n      y: undefined,\n    };\n  };\n\n  static _getCanvasPointsPosition = (points = [], element) => {\n    const viewerPos = ContextMenuController._getElementDefaultPosition(element);\n\n    for (let pointIndex = 0; pointIndex < points.length; pointIndex++) {\n      const point = {\n        x: points[pointIndex][0] || points[pointIndex]['x'],\n        y: points[pointIndex][1] || points[pointIndex]['y'],\n      };\n      if (\n        ContextMenuController._isValidPosition(point) &&\n        ContextMenuController._isValidPosition(viewerPos)\n      ) {\n        return {\n          x: point.x + viewerPos.x,\n          y: point.y + viewerPos.y,\n        };\n      }\n    }\n  };\n\n  static _isValidPosition = (source): boolean => {\n    return (\n      source && typeof source.x === 'number' && typeof source.y === 'number'\n    );\n  };\n\n  /**\n   * Returns the context menu default position. It look for the positions of: canvasPoints (got from selected), event that triggers it, current viewport element\n   */\n  static _getDefaultPosition = (canvasPoints, eventDetail, viewerElement) => {\n    function* getPositionIterator() {\n      yield ContextMenuController._getCanvasPointsPosition(\n        canvasPoints,\n        viewerElement\n      );\n      yield ContextMenuController._getEventDefaultPosition(eventDetail);\n      yield ContextMenuController._getElementDefaultPosition(viewerElement);\n      yield ContextMenuController.getDefaultPosition();\n    }\n\n    const positionIterator = getPositionIterator();\n\n    let current = positionIterator.next();\n    let position = current.value;\n\n    while (!current.done) {\n      position = current.value;\n\n      if (ContextMenuController._isValidPosition(position)) {\n        positionIterator.return();\n      }\n      current = positionIterator.next();\n    }\n\n    return position;\n  };\n}\n","const defaultContextMenu = {\n  id: 'measurementsContextMenu',\n  customizationType: 'ohif.contextMenu',\n  menus: [\n    // Get the items from the UI Customization for the menu name (and have a custom name)\n    {\n      id: 'forExistingMeasurement',\n      selector: ({ nearbyToolData }) => !!nearbyToolData,\n      items: [\n        {\n          label: 'Delete curve',\n          commands: [\n            {\n              commandName: 'deleteMeasurement',\n            },\n          ],\n        },\n        {\n          label: 'Add comment',\n          commands: [\n            {\n              commandName: 'setMeasurementLabel',\n            },\n          ],\n        },\n        {\n          label: 'Validate curve',\n          commands: [\n            {\n              commandName: 'closeContextMenu'\n            }\n          ]\n        }\n      ],\n    },\n  ],\n};\n\nexport default defaultContextMenu;\n","import React, { useCallback, useEffect, useRef, useState } from 'react';\nimport { VariableSizeList as List } from 'react-window';\nimport classNames from 'classnames';\nimport debounce from 'lodash.debounce';\n\nconst lineHeightPx = 20;\nconst lineHeightClassName = `leading-[${lineHeightPx}px]`;\nconst rowVerticalPaddingPx = 10;\nconst rowBottomBorderPx = 1;\nconst rowVerticalPaddingStyle = { padding: `${rowVerticalPaddingPx}px 0` };\nconst rowStyle = {\n  borderBottomWidth: `${rowBottomBorderPx}px`,\n  ...rowVerticalPaddingStyle,\n};\n\nfunction ColumnHeaders({ tagRef, vrRef, keywordRef, valueRef }) {\n  return (\n    <div\n      className={classNames(\n        'flex flex-row w-full bg-secondary-dark ohif-scrollbar overflow-y-scroll'\n      )}\n      style={rowVerticalPaddingStyle}\n    >\n      <div className=\"px-3 w-4/24\">\n        <label\n          ref={tagRef}\n          className=\"flex flex-col flex-1 text-white text-lg pl-1 select-none\"\n        >\n          <span className=\"flex flex-row items-center focus:outline-none\">\n            Tag\n          </span>\n        </label>\n      </div>\n      <div className=\"px-3 w-2/24\">\n        <label\n          ref={vrRef}\n          className=\"flex flex-col flex-1 text-white text-lg pl-1 select-none\"\n        >\n          <span className=\"flex flex-row items-center focus:outline-none\">\n            VR\n          </span>\n        </label>\n      </div>\n      <div className=\"px-3 w-6/24\">\n        <label\n          ref={keywordRef}\n          className=\"flex flex-col flex-1 text-white text-lg pl-1 select-none\"\n        >\n          <span className=\"flex flex-row items-center focus:outline-none\">\n            Keyword\n          </span>\n        </label>\n      </div>\n      <div className=\"px-3 w-5/24 grow\">\n        <label\n          ref={valueRef}\n          className=\"flex flex-col flex-1 text-white text-lg pl-1 select-none\"\n        >\n          <span className=\"flex flex-row items-center focus:outline-none\">\n            Value\n          </span>\n        </label>\n      </div>\n    </div>\n  );\n}\n\nfunction DicomTagTable({ rows }) {\n  const listRef = useRef();\n  const canvasRef = useRef();\n\n  const [tagHeaderElem, setTagHeaderElem] = useState(null);\n  const [vrHeaderElem, setVrHeaderElem] = useState(null);\n  const [keywordHeaderElem, setKeywordHeaderElem] = useState(null);\n  const [valueHeaderElem, setValueHeaderElem] = useState(null);\n\n  // Here the refs are inturn stored in state to trigger a render of the table.\n  // This virtualized table does NOT render until the header is rendered because the header column widths are used to determine the row heights in the table.\n  // Therefore whenever the refs change (in particular the first time the refs are set), we want to trigger a render of the table.\n  const tagRef = elem => {\n    if (elem) {\n      setTagHeaderElem(elem);\n    }\n  };\n  const vrRef = elem => {\n    if (elem) {\n      setVrHeaderElem(elem);\n    }\n  };\n  const keywordRef = elem => {\n    if (elem) {\n      setKeywordHeaderElem(elem);\n    }\n  };\n  const valueRef = elem => {\n    if (elem) {\n      setValueHeaderElem(elem);\n    }\n  };\n\n  /**\n   * When new rows are set, scroll to the top and reset the virtualization.\n   */\n  useEffect(() => {\n    if (!listRef?.current) {\n      return;\n    }\n\n    listRef.current.scrollTo(0);\n    listRef.current.resetAfterIndex(0);\n  }, [rows]);\n\n  /**\n   * When the browser window resizes, update the row virtualization (i.e. row heights)\n   */\n  useEffect(() => {\n    const debouncedResize = debounce(\n      () => listRef.current.resetAfterIndex(0),\n      100\n    );\n\n    window.addEventListener('resize', debouncedResize);\n\n    return () => {\n      debouncedResize.cancel();\n      window.removeEventListener('resize', debouncedResize);\n    };\n  }, []);\n\n  const Row = useCallback(\n    ({ index, style }) => {\n      const row = rows[index];\n\n      return (\n        <div\n          style={{ ...style, ...rowStyle }}\n          className={classNames(\n            'hover:bg-secondary-main transition duration-300 bg-black flex flex-row w-full border-secondary-light items-center text-base break-all',\n            lineHeightClassName\n          )}\n          key={`DICOMTagRow-${index}`}\n        >\n          <div className=\"px-3 w-4/24\">{row[0]}</div>\n          <div className=\"px-3 w-2/24\">{row[1]}</div>\n          <div className=\"px-3 w-6/24\">{row[2]}</div>\n          <div className=\"px-3 w-5/24 grow\">{row[3]}</div>\n        </div>\n      );\n    },\n    [rows]\n  );\n\n  /**\n   * Whenever any one of the column headers is set, then the header is rendered.\n   * Here we chose the tag header.\n   */\n  const isHeaderRendered = useCallback(() => tagHeaderElem !== null, [\n    tagHeaderElem,\n  ]);\n\n  /**\n   * Get the item/row size. We use the header column widths to calculate the various row heights.\n   * @param index the row index\n   * @returns the row height\n   */\n  const getItemSize = useCallback(\n    index => {\n      const headerWidths = [\n        tagHeaderElem.offsetWidth,\n        vrHeaderElem.offsetWidth,\n        keywordHeaderElem.offsetWidth,\n        valueHeaderElem.offsetWidth,\n      ];\n\n      const context = canvasRef.current.getContext('2d');\n      context.font = getComputedStyle(canvasRef.current).font;\n\n      return rows[index]\n        .map((colText, index) => {\n          const colOneLineWidth = context.measureText(colText).width;\n          const numLines = Math.ceil(colOneLineWidth / headerWidths[index]);\n          return (\n            numLines * lineHeightPx +\n            2 * rowVerticalPaddingPx +\n            rowBottomBorderPx\n          );\n        })\n        .reduce((maxHeight, colHeight) => Math.max(maxHeight, colHeight));\n    },\n    [rows, keywordHeaderElem, tagHeaderElem, valueHeaderElem, vrHeaderElem]\n  );\n\n  return (\n    <div>\n      <canvas\n        style={{ visibility: 'hidden', position: 'absolute' }}\n        className=\"text-base\"\n        ref={canvasRef}\n      />\n      <ColumnHeaders\n        tagRef={tagRef}\n        vrRef={vrRef}\n        keywordRef={keywordRef}\n        valueRef={valueRef}\n      />\n      <div\n        className=\"m-auto relative border-2 border-black bg-black\"\n        style={{ height: '32rem' }}\n      >\n        {isHeaderRendered() && (\n          <List\n            ref={listRef}\n            height={500}\n            itemCount={rows.length}\n            itemSize={getItemSize}\n            width={'100%'}\n            className=\"ohif-scrollbar\"\n          >\n            {Row}\n          </List>\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport default DicomTagTable;\n","import dcmjs from 'dcmjs';\nimport moment from 'moment';\nimport React, { useState, useMemo, useEffect, useRef } from 'react';\nimport { classes } from '@ohif/core';\nimport { Icon, InputRange, Select, Typography } from '@ohif/ui';\nimport debounce from 'lodash.debounce';\nimport classNames from 'classnames';\n\nimport DicomTagTable from './DicomTagTable';\nimport './DicomTagBrowser.css';\n\nconst { ImageSet } = classes;\nconst { DicomMetaDictionary } = dcmjs.data;\nconst { nameMap } = DicomMetaDictionary;\n\nconst DicomTagBrowser = ({ displaySets, displaySetInstanceUID }) => {\n  // The column indices that are to be excluded during a filter of the table.\n  // At present the column indices are:\n  // 0: DICOM tag\n  // 1: VR\n  // 2: Keyword\n  // 3: Value\n  const excludedColumnIndicesForFilter: Set<number> = new Set([1]);\n\n  const [\n    selectedDisplaySetInstanceUID,\n    setSelectedDisplaySetInstanceUID,\n  ] = useState(displaySetInstanceUID);\n  const [instanceNumber, setInstanceNumber] = useState(1);\n  const [filterValue, setFilterValue] = useState('');\n\n  const onSelectChange = value => {\n    setSelectedDisplaySetInstanceUID(value.value);\n    setInstanceNumber(1);\n  };\n\n  const searchInputRef = useRef(null);\n\n  const activeDisplaySet = displaySets.find(\n    ds => ds.displaySetInstanceUID === selectedDisplaySetInstanceUID\n  );\n\n  const isImageStack = _isImageStack(activeDisplaySet);\n  const showInstanceList = isImageStack && activeDisplaySet.images.length > 1;\n\n  const displaySetList = useMemo(() => {\n    displaySets.sort((a, b) => a.SeriesNumber - b.SeriesNumber);\n    return displaySets.map(displaySet => {\n      const {\n        displaySetInstanceUID,\n        SeriesDate,\n        SeriesTime,\n        SeriesNumber,\n        SeriesDescription,\n        Modality,\n      } = displaySet;\n\n      /* Map to display representation */\n      const dateStr = `${SeriesDate}:${SeriesTime}`.split('.')[0];\n      const date = moment(dateStr, 'YYYYMMDD:HHmmss');\n      const displayDate = date.format('ddd, MMM Do YYYY');\n\n      return {\n        value: displaySetInstanceUID,\n        label: `${SeriesNumber} (${Modality}): ${SeriesDescription}`,\n        description: displayDate,\n      };\n    });\n  }, [displaySets]);\n\n  const rows = useMemo(() => {\n    let metadata;\n    if (isImageStack) {\n      metadata = activeDisplaySet.images[instanceNumber - 1];\n    } else {\n      metadata = activeDisplaySet.instance || activeDisplaySet;\n    }\n    const tags = getSortedTags(metadata);\n    return getFormattedRowsFromTags(tags, metadata);\n  }, [instanceNumber, selectedDisplaySetInstanceUID]);\n\n  const filteredRows = useMemo(() => {\n    if (!filterValue) {\n      return rows;\n    }\n\n    const filterValueLowerCase = filterValue.toLowerCase();\n    return rows.filter(row => {\n      return row.reduce((keepRow, col, colIndex) => {\n        if (keepRow) {\n          // We are already keeping the row, why do more work so return now.\n          return keepRow;\n        }\n\n        if (excludedColumnIndicesForFilter.has(colIndex)) {\n          return keepRow;\n        }\n\n        return keepRow || col.toLowerCase().includes(filterValueLowerCase);\n      }, false);\n    });\n  }, [rows, filterValue]);\n\n  const debouncedSetFilterValue = useMemo(() => {\n    return debounce(setFilterValue, 200);\n  }, []);\n\n  useEffect(() => {\n    return () => {\n      debouncedSetFilterValue?.cancel();\n    };\n  }, []);\n\n  return (\n    <div className=\"dicom-tag-browser-content\">\n      <div className=\"flex flex-row mb-6 items-center pl-1\">\n        <div className=\"flex flex-row items-center w-1/2\">\n          <Typography variant=\"subtitle\" className=\"mr-4\">\n            Series\n          </Typography>\n          <div className=\"grow mr-8\">\n            <Select\n              id=\"display-set-selector\"\n              isClearable={false}\n              onChange={onSelectChange}\n              options={displaySetList}\n              value={displaySetList.find(\n                ds => ds.value === selectedDisplaySetInstanceUID\n              )}\n              className=\"text-white\"\n            />\n          </div>\n        </div>\n        <div className=\"flex flex-row items-center w-1/2\">\n          {showInstanceList && (\n            <Typography variant=\"subtitle\" className=\"mr-4\">\n              Instance Number\n            </Typography>\n          )}\n          {showInstanceList && (\n            <div className=\"grow\">\n              <InputRange\n                value={instanceNumber}\n                key={selectedDisplaySetInstanceUID}\n                onChange={value => {\n                  setInstanceNumber(parseInt(value));\n                }}\n                minValue={1}\n                maxValue={activeDisplaySet.images.length}\n                step={1}\n                inputClassName=\"w-full\"\n                labelPosition=\"left\"\n                trackColor={'#3a3f99'}\n              />\n            </div>\n          )}\n        </div>\n      </div>\n      <div className=\"w-full h-1 bg-black\"></div>\n      <div className=\"flex flex-row my-3 w-1/2\">\n        {/* TODO - refactor the following into its own reusable component */}\n        <label className=\"relative block w-full mr-8\">\n          <span className=\"absolute inset-y-0 left-0 flex items-center pl-2\">\n            <Icon name=\"icon-search\"></Icon>\n          </span>\n          <input\n            ref={searchInputRef}\n            type=\"text\"\n            className=\"block bg-black w-full shadow transition duration-300 appearance-none border border-inputfield-main focus:border-inputfield-focus focus:outline-none disabled:border-inputfield-disabled rounded w-full py-2 px-9 text-base leading-tight placeholder:text-inputfield-placeholder\"\n            placeholder=\"Search metadata...\"\n            onChange={event => debouncedSetFilterValue(event.target.value)}\n            autoComplete=\"off\"\n          ></input>\n          <span className=\"absolute inset-y-0 right-0 flex items-center pr-2\">\n            <Icon\n              name=\"icon-clear-field\"\n              className={classNames(\n                'cursor-pointer',\n                filterValue ? '' : 'hidden'\n              )}\n              onClick={() => {\n                searchInputRef.current.value = '';\n                debouncedSetFilterValue('');\n              }}\n            ></Icon>\n          </span>\n        </label>\n      </div>\n      <DicomTagTable rows={filteredRows} />\n    </div>\n  );\n};\n\nfunction getFormattedRowsFromTags(tags, metadata) {\n  const rows = [];\n\n  tags.forEach(tagInfo => {\n    if (tagInfo.vr === 'SQ') {\n      rows.push([\n        `${tagInfo.tagIndent}${tagInfo.tag}`,\n        tagInfo.vr,\n        tagInfo.keyword,\n        '',\n      ]);\n\n      const { values } = tagInfo;\n\n      values.forEach((item, index) => {\n        const formatedRowsFromTags = getFormattedRowsFromTags(item, metadata);\n\n        rows.push([\n          `${item[0].tagIndent}(FFFE,E000)`,\n          '',\n          `Item #${index}`,\n          '',\n        ]);\n\n        rows.push(...formatedRowsFromTags);\n      });\n    } else {\n      if (tagInfo.vr === 'xs') {\n        try {\n          const tag = dcmjs.data.Tag.fromPString(tagInfo.tag).toCleanString();\n          const originalTagInfo = metadata[tag];\n          tagInfo.vr = originalTagInfo.vr;\n        } catch (error) {\n          console.error(\n            `Failed to parse value representation for tag '${tagInfo.keyword}'`\n          );\n        }\n      }\n      rows.push([\n        `${tagInfo.tagIndent}${tagInfo.tag}`,\n        tagInfo.vr,\n        tagInfo.keyword,\n        tagInfo.value,\n      ]);\n    }\n  });\n\n  return rows;\n}\n\nfunction getSortedTags(metadata) {\n  const tagList = getRows(metadata);\n\n  // Sort top level tags, sequence groups are sorted when created.\n  _sortTagList(tagList);\n\n  return tagList;\n}\n\nfunction getRows(metadata, depth = 0) {\n  // Tag, Type, Value, Keyword\n\n  const keywords = Object.keys(metadata);\n\n  let tagIndent = '';\n\n  for (let i = 0; i < depth; i++) {\n    tagIndent += '>';\n  }\n\n  if (depth > 0) {\n    tagIndent += ' '; // If indented, add a space after the indents.\n  }\n\n  const rows = [];\n  for (let i = 0; i < keywords.length; i++) {\n    let keyword = keywords[i];\n\n    if (keyword === '_vrMap') {\n      continue;\n    }\n\n    const tagInfo = nameMap[keyword];\n\n    let value = metadata[keyword];\n\n    if (tagInfo && tagInfo.vr === 'SQ') {\n      const sequenceAsArray = toArray(value);\n\n      // Push line defining the sequence\n\n      const sequence = {\n        tag: tagInfo.tag,\n        tagIndent,\n        vr: tagInfo.vr,\n        keyword,\n        values: [],\n      };\n\n      rows.push(sequence);\n\n      if (value === null) {\n        // Type 2 Sequence\n        continue;\n      }\n\n      sequenceAsArray.forEach(item => {\n        const sequenceRows = getRows(item, depth + 1);\n\n        if (sequenceRows.length) {\n          // Sort the sequence group.\n          _sortTagList(sequenceRows);\n          sequence.values.push(sequenceRows);\n        }\n      });\n\n      continue;\n    }\n\n    if (Array.isArray(value)) {\n      if (value.length > 0 && typeof value[0] != 'object') {\n        value = value.join('\\\\');\n      }\n    }\n\n    if (typeof value === 'number') {\n      value = value.toString();\n    }\n\n    if (typeof value !== 'string') {\n      if (value === null) {\n        value = ' ';\n      } else {\n        if (typeof value === 'object') {\n          if (value.InlineBinary) {\n            value = 'Inline Binary';\n          } else if (value.BulkDataURI) {\n            value = `Bulk Data URI`; //: ${value.BulkDataURI}`;\n          } else if (value.Alphabetic) {\n            value = value.Alphabetic;\n          } else {\n            console.warn(`Unrecognised Value: ${value} for ${keyword}:`);\n            console.warn(value);\n            value = ' ';\n          }\n        } else {\n          console.warn(`Unrecognised Value: ${value} for ${keyword}:`);\n          value = ' ';\n        }\n      }\n    }\n\n    // tag / vr/ keyword/ value\n\n    // Remove retired tags\n    keyword = keyword.replace('RETIRED_', '');\n    if (tagInfo) {\n      rows.push({\n        tag: tagInfo.tag,\n        tagIndent,\n        vr: tagInfo.vr,\n        keyword,\n        value,\n      });\n    } else {\n      // skip properties without hex tag numbers\n      const regex = /[0-9A-Fa-f]{6}/g;\n      if (keyword.match(regex)) {\n        const tag = `(${keyword.substring(0, 4)},${keyword.substring(4, 8)})`;\n        rows.push({\n          tag,\n          tagIndent,\n          vr: '',\n          keyword: 'Private Tag',\n          value,\n        });\n      }\n    }\n  }\n\n  return rows;\n}\n\nfunction _isImageStack(displaySet) {\n  return displaySet instanceof ImageSet;\n}\n\nfunction toArray(objectOrArray) {\n  return Array.isArray(objectOrArray) ? objectOrArray : [objectOrArray];\n}\n\nfunction _sortTagList(tagList) {\n  tagList.sort((a, b) => {\n    if (a.tag < b.tag) {\n      return -1;\n    }\n\n    return 1;\n  });\n}\n\nexport default DicomTagBrowser;\n","import { HangingProtocolService, StateSyncService, Types } from '@ohif/core';\n\nexport type ReturnType = {\n  hangingProtocolStageIndexMap: Record<string, Types.HangingProtocol.HPInfo>;\n  viewportGridStore: Record<string, unknown>;\n  displaySetSelectorMap: Record<string, string>;\n};\n\n/**\n * Calculates a set of state information for hanging protocols and viewport grid\n * which defines the currently applied hanging protocol state.\n * @param state is the viewport grid state\n * @param syncService is the state sync service to use for getting existing state\n * @returns Set of states that can be applied to the state sync to remember\n *   the current view state.\n */\nconst reuseCachedLayout = (\n  state,\n  hangingProtocolService: HangingProtocolService,\n  syncService: StateSyncService,\n  displaySetsCache: string[],\n): ReturnType => {\n  console.log('HP - REUSE CACHED LAYOUT', state, hangingProtocolService, syncService, displaySetsCache)\n  const { activeViewportIndex, viewports, layout } = state;\n  const hpInfo = hangingProtocolService.getState();\n  const { protocolId, stageIndex, activeStudyUID } = hpInfo;\n  const { protocol } = hangingProtocolService.getActiveProtocol();\n  const stage = protocol.stages[stageIndex];\n  const storeId = `${activeStudyUID}:${protocolId}:${stageIndex}`;\n  const syncState = syncService.getState();\n  const cacheId = `${activeStudyUID}:${protocolId}`;\n  const viewportGridStore = { ...syncState.viewportGridStore };\n  const hangingProtocolStageIndexMap = {\n    ...syncState.hangingProtocolStageIndexMap,\n  };\n  const displaySetSelectorMap = { ...syncState.displaySetSelectorMap };\n  const { rows, columns } = stage.viewportStructure.properties;\n  const custom =\n    stage.viewports.length !== state.viewports.length ||\n    state.layout.numRows !== rows ||\n    state.layout.numCols !== columns;\n\n  hangingProtocolStageIndexMap[cacheId] = hpInfo;\n\n  if (storeId && custom) {\n    viewportGridStore[storeId] = { ...state };\n  }\n\n  for (let idx = 0; idx < state.viewports.length; idx++) {\n    const viewport = state.viewports[idx];\n    const { displaySetOptions, displaySetInstanceUIDs } = viewport;\n    if (!displaySetOptions) continue;\n    for (let i = 0; i < displaySetOptions.length; i++) {\n      const displaySetUID = displaySetInstanceUIDs[i];\n      if (!displaySetUID || !displaySetsCache.includes(displaySetUID)) continue;\n      if (idx === activeViewportIndex && i === 0) {\n        displaySetSelectorMap[\n          `${activeStudyUID}:activeDisplaySet:0`\n        ] = displaySetUID;\n      }\n      if (displaySetOptions[i]?.id) {\n        displaySetSelectorMap[\n          `${activeStudyUID}:${displaySetOptions[i].id}:${displaySetOptions[i]\n            .matchedDisplaySetsIndex || 0}`\n        ] = displaySetUID;\n      }\n    }\n  }\n\n  return {\n    hangingProtocolStageIndexMap,\n    viewportGridStore,\n    displaySetSelectorMap,\n  };\n};\n\nexport default reuseCachedLayout;\n","import { StateSyncService, Types } from '@ohif/core';\n\n/**\n * This find or create viewport is paired with the reduce results from\n * below, and the action of this viewport is to look for previously filled\n * viewports, and to re-use by position id.  If there is no filled viewport,\n * then one can be re-used from the display set if it isn't going to be displayed.\n * @param hangingProtocolService - bound parameter supplied before using this\n * @param viewportsByPosition - bound parameter supplied before using this\n * @param viewportIndex - the index to retrieve\n * @param positionId - the current position on screen to retrieve\n * @param options - the set of options used, so that subsequent calls can\n *                  store state that is reset by the setLayout.\n *                  This class uses the options to store the already viewed\n *                  display sets, filling it initially with the pre-existing viewports.\n */\nexport const findOrCreateViewport = (\n  hangingProtocolService,\n  viewportsByPosition,\n  viewportIndex: number,\n  positionId: string,\n  options: Record<string, unknown>\n) => {\n  const byPositionViewport = viewportsByPosition?.[positionId];\n  if (byPositionViewport) return { ...byPositionViewport };\n  const { protocolId, stageIndex } = hangingProtocolService.getState();\n\n  // Setup the initial in display correctly for initial view/select\n  if (!options.inDisplay) {\n    options.inDisplay = [...viewportsByPosition.initialInDisplay];\n  }\n  // See if there is a default viewport for new views.\n  const missing = hangingProtocolService.getMissingViewport(\n    protocolId,\n    stageIndex,\n    options\n  );\n  if (missing) {\n    const displaySetInstanceUIDs = missing.displaySetsInfo.map(\n      it => it.displaySetInstanceUID\n    );\n    options.inDisplay.push(...displaySetInstanceUIDs);\n    return {\n      displaySetInstanceUIDs,\n      displaySetOptions: missing.displaySetsInfo.map(\n        it => it.displaySetOptions\n      ),\n      viewportOptions: {\n        ...missing.viewportOptions,\n      },\n    };\n  }\n  return {};\n};\n\n/**\n * Records the information on what viewports are displayed in which position.\n * Also records what instances from the existing positions are going to be in\n * view initially.\n * @param state is the viewport grid state\n * @param syncService is the state sync service to use for getting existing state\n * @returns Set of states that can be applied to the state sync to remember\n *   the current view state.\n */\nconst findViewportsByPosition = (\n  state,\n  { numRows, numCols },\n  syncService: StateSyncService\n): Record<string, Record<string, unknown>> => {\n  const { viewports } = state;\n  const syncState = syncService.getState();\n  const viewportsByPosition = { ...syncState.viewportsByPosition };\n  const initialInDisplay = [];\n\n  for (const viewport of viewports) {\n    if (viewport.positionId) {\n      const storedViewport = {\n        ...viewport,\n        viewportOptions: { ...viewport.viewportOptions },\n      };\n      viewportsByPosition[viewport.positionId] = storedViewport;\n      // The cache doesn't store the viewport options - it is only useful\n      // for remembering the type of viewport and UIDs\n      delete storedViewport.viewportId;\n      delete storedViewport.viewportOptions.viewportId;\n    }\n  }\n\n  for (let row = 0; row < numRows; row++) {\n    for (let col = 0; col < numCols; col++) {\n      const pos = col + row * numCols;\n      const positionId = viewports?.[pos]?.positionId || `${col}-${row}`;\n      const viewport = viewportsByPosition[positionId];\n      if (viewport?.displaySetInstanceUIDs) {\n        initialInDisplay.push(...viewport.displaySetInstanceUIDs);\n      }\n    }\n  }\n\n  // Store the initially displayed elements\n  viewportsByPosition.initialInDisplay = initialInDisplay;\n\n  return { viewportsByPosition };\n};\n\nexport default findViewportsByPosition;\n","import { ServicesManager, utils, Types } from '@ohif/core';\n\nimport {\n  ContextMenuController,\n  defaultContextMenu,\n} from './CustomizableContextMenu';\nimport DicomTagBrowser from './DicomTagBrowser/DicomTagBrowser';\nimport reuseCachedLayouts from './utils/reuseCachedLayouts';\nimport findViewportsByPosition, {\n  findOrCreateViewport as layoutFindOrCreate,\n} from './findViewportsByPosition';\n\nimport { ContextMenuProps } from './CustomizableContextMenu/types';\nimport { NavigateHistory } from './types/commandModuleTypes';\nimport { history } from '@ohif/app';\n\nconst { subscribeToNextViewportGridChange } = utils;\n\nexport type HangingProtocolParams = {\n  protocolId?: string;\n  stageIndex?: number;\n  activeStudyUID?: string;\n  stageId?: string;\n};\n\nexport type UpdateViewportDisplaySetParams = {\n  direction: number;\n  excludeNonImageModalities?: boolean;\n};\n\n/**\n * Determine if a command is a hanging protocol one.\n * For now, just use the two hanging protocol commands that are in this\n * commands module, but if others get added elsewhere this may need enhancing.\n */\nconst isHangingProtocolCommand = command =>\n  command &&\n  (command.commandName === 'setHangingProtocol' ||\n    command.commandName === 'toggleHangingProtocol');\n\nconst commandsModule = ({\n  servicesManager,\n  commandsManager,\n}: Types.Extensions.ExtensionParams): Types.Extensions.CommandsModule => {\n  const {\n    customizationService,\n    measurementService,\n    hangingProtocolService,\n    uiNotificationService,\n    viewportGridService,\n    displaySetService,\n    stateSyncService,\n    toolbarService,\n  } = (servicesManager as ServicesManager).services;\n\n  // Define a context menu controller for use with any context menus\n  const contextMenuController = new ContextMenuController(\n    servicesManager,\n    commandsManager\n  );\n\n  const actions = {\n    /**\n     * Show the context menu.\n     * @param options.menuId defines the menu name to lookup, from customizationService\n     * @param options.defaultMenu contains the default menu set to use\n     * @param options.element is the element to show the menu within\n     * @param options.event is the event that caused the context menu\n     * @param options.selectorProps is the set of selection properties to use\n     */\n    showContextMenu: (options: ContextMenuProps) => {\n      const {\n        menuCustomizationId,\n        element,\n        event,\n        selectorProps,\n        defaultPointsPosition = [],\n      } = options;\n\n      const optionsToUse = { ...options };\n\n      if (menuCustomizationId) {\n        Object.assign(\n          optionsToUse,\n          customizationService.get(menuCustomizationId, defaultContextMenu)\n        );\n      }\n\n      // TODO - make the selectorProps richer by including the study metadata and display set.\n      const { protocol, stage } = hangingProtocolService.getActiveProtocol();\n      optionsToUse.selectorProps = {\n        event,\n        protocol,\n        stage,\n        ...selectorProps,\n      };\n\n      contextMenuController.showContextMenu(\n        optionsToUse,\n        element,\n        defaultPointsPosition\n      );\n    },\n\n    /** Close a context menu currently displayed */\n    closeContextMenu: () => {\n      contextMenuController.closeContextMenu();\n    },\n\n    displayNotification: ({ text, title, type }) => {\n      uiNotificationService.show({\n        title: title,\n        message: text,\n        type: type,\n      });\n    },\n    clearMeasurements: () => {\n      measurementService.clear();\n    },\n\n    /**\n     * Toggles off all tools which contain a commandName of setHangingProtocol\n     * or toggleHangingProtocol, and which match/don't match the protocol id/stage\n     */\n    toggleHpTools: () => {\n      const {\n        protocol,\n        stageIndex: toggleStageIndex,\n        stage,\n      } = hangingProtocolService.getActiveProtocol();\n      const enableListener = button => {\n        if (!button.id) return;\n        const { commands, items } = button.props || button;\n        if (items) {\n          items.forEach(enableListener);\n        }\n        const hpCommand = commands?.find?.(isHangingProtocolCommand);\n        if (!hpCommand) return;\n        const { protocolId, stageIndex, stageId } = hpCommand.commandOptions;\n        const isActive =\n          (!protocolId || protocolId === protocol.id) &&\n          (stageIndex === undefined || stageIndex === toggleStageIndex) &&\n          (!stageId || stageId === stage.id);\n        toolbarService.setActive(button.id, isActive);\n      };\n      Object.values(toolbarService.getButtons()).forEach(enableListener);\n    },\n\n    /**\n     *  Sets the specified protocol\n     *    1. Records any existing state using the viewport grid service\n     *    2. Finds the destination state - this can be one of:\n     *       a. The specified protocol stage\n     *       b. An alternate (toggled or restored) protocol stage\n     *       c. A restored custom layout\n     *    3. Finds the parameters for the specified state\n     *       a. Gets the displaySetSelectorMap\n     *       b. Gets the map by position\n     *       c. Gets any toggle mapping to map position to/from current view\n     *    4. If restore, then sets layout\n     *       a. Maps viewport position by currently displayed viewport map id\n     *       b. Uses toggle information to map display set id\n     *    5. Else applies the hanging protocol\n     *       a. HP Service is provided displaySetSelectorMap\n     *       b. HP Service will throw an exception if it isn't applicable\n     * @param options - contains information on the HP to apply\n     * @param options.activeStudyUID - the updated study to apply the HP to\n     * @param options.protocolId - the protocol ID to change to\n     * @param options.stageId - the stageId to apply\n     * @param options.stageIndex - the index of the stage to go to.\n     * @param options.reset - flag to indicate if the HP should be reset to its original and not restored to a previous state\n     */\n    setHangingProtocol: ({\n      activeStudyUID = '',\n      protocolId,\n      stageId,\n      stageIndex,\n      reset = false,\n    }: HangingProtocolParams): boolean => {\n      try {\n        // Stores in the state the display set selector id to displaySetUID mapping\n        // Pass in viewportId for the active viewport.  This item will get set as\n        // the activeViewportId\n        const state = viewportGridService.getState();\n        const hpInfo = hangingProtocolService.getState();\n        const displaySetServiceCached = Array.from(displaySetService.getDisplaySetCache().entries()).map(e => {return e[0]})\n        const {\n          protocol: oldProtocol,\n        } = hangingProtocolService.getActiveProtocol();\n        const stateSyncReduce = reuseCachedLayouts(\n            state,\n            hangingProtocolService,\n            stateSyncService,\n            displaySetServiceCached\n        );\n        console.log('HP - STATE SYNC REDUCE', stateSyncReduce)\n        const {\n          hangingProtocolStageIndexMap,\n          viewportGridStore,\n          displaySetSelectorMap,\n        } = stateSyncReduce;\n\n        if (!protocolId) {\n          // Re-use the previous protocol id, and optionally stage\n          protocolId = hpInfo.protocolId;\n          if (stageId === undefined && stageIndex === undefined) {\n            stageIndex = hpInfo.stageIndex;\n          }\n        } else if (stageIndex === undefined && stageId === undefined) {\n          // Re-set the same stage as was previously used\n          const hangingId = `${activeStudyUID ||\n            hpInfo.activeStudyUID}:${protocolId}`;\n          stageIndex = hangingProtocolStageIndexMap[hangingId]?.stageIndex;\n        }\n\n        const useStageIdx =\n          stageIndex ??\n          hangingProtocolService.getStageIndex(protocolId, {\n            stageId,\n            stageIndex,\n          });\n\n        if (activeStudyUID) {\n          hangingProtocolService.setActiveStudyUID(activeStudyUID);\n        }\n\n        const storedHanging = `${\n          hangingProtocolService.getState().activeStudyUID\n        }:${protocolId}:${useStageIdx || 0}`;\n\n        const restoreProtocol = !reset && viewportGridStore[storedHanging];\n\n        if (\n          protocolId === hpInfo.protocolId &&\n          useStageIdx === hpInfo.stageIndex &&\n          !activeStudyUID\n        ) {\n          // Clear the HP setting to reset them\n          hangingProtocolService.setProtocol(protocolId, {\n            stageId,\n            stageIndex: useStageIdx,\n          });\n        } else {\n          //GO HERE\n          hangingProtocolService.setProtocol(protocolId, {\n            displaySetSelectorMap,\n            stageId,\n            stageIndex: useStageIdx,\n            restoreProtocol,\n          });\n          if (restoreProtocol) {\n            viewportGridService.set(viewportGridStore[storedHanging]);\n          }\n        }\n        // Do this after successfully applying the update\n        // Note, don't store the active display set - it is only needed while\n        // changing display sets.  This causes jump to measurement to fail on\n        // multi-study display.\n        delete displaySetSelectorMap[\n          `${activeStudyUID || hpInfo.activeStudyUID}:activeDisplaySet:0`\n        ];\n        stateSyncService.store(stateSyncReduce);\n        // This is a default action applied\n        actions.toggleHpTools(hangingProtocolService.getActiveProtocol());\n        // Send the notification about updating the state\n        if (protocolId !== hpInfo.protocolId) {\n          const { protocol } = hangingProtocolService.getActiveProtocol();\n          // The old protocol callbacks are used for turning off things\n          // like crosshairs when moving to the new HP\n          commandsManager.run(oldProtocol.callbacks?.onProtocolExit);\n          // The new protocol callback is used for things like\n          // activating modes etc.\n          commandsManager.run(protocol.callbacks?.onProtocolEnter);\n        }\n        return true;\n      } catch (e) {\n        actions.toggleHpTools(hangingProtocolService.getActiveProtocol());\n        uiNotificationService.show({\n          title: 'Apply Hanging Protocol',\n          message: 'The hanging protocol could not be applied.',\n          type: 'error',\n          duration: 3000,\n        });\n        return false;\n      }\n    },\n\n    toggleHangingProtocol: ({\n      protocolId,\n      stageIndex,\n    }: HangingProtocolParams): boolean => {\n      const {\n        protocol,\n        stageIndex: desiredStageIndex,\n        activeStudy,\n      } = hangingProtocolService.getActiveProtocol();\n      const { toggleHangingProtocol } = stateSyncService.getState();\n      const storedHanging = `${\n        activeStudy.StudyInstanceUID\n      }:${protocolId}:${stageIndex | 0}`;\n      if (\n        protocol.id === protocolId &&\n        (stageIndex === undefined || stageIndex === desiredStageIndex)\n      ) {\n        // Toggling off - restore to previous state\n        const previousState = toggleHangingProtocol[storedHanging] || {\n          protocolId: 'default',\n        };\n        return actions.setHangingProtocol(previousState);\n      } else {\n        stateSyncService.store({\n          toggleHangingProtocol: {\n            ...toggleHangingProtocol,\n            [storedHanging]: {\n              protocolId: protocol.id,\n              stageIndex: desiredStageIndex,\n            },\n          },\n        });\n        //GO HERE\n        return actions.setHangingProtocol({\n          protocolId,\n          stageIndex,\n          reset: true,\n        });\n      }\n    },\n\n    deltaStage: ({ direction }) => {\n      const {\n        protocolId,\n        stageIndex: oldStageIndex,\n      } = hangingProtocolService.getState();\n      const { protocol } = hangingProtocolService.getActiveProtocol();\n      for (\n        let stageIndex = oldStageIndex + direction;\n        stageIndex >= 0 && stageIndex < protocol.stages.length;\n        stageIndex += direction\n      ) {\n        if (protocol.stages[stageIndex].status !== 'disabled') {\n          return actions.setHangingProtocol({\n            protocolId,\n            stageIndex,\n          });\n        }\n      }\n      uiNotificationService.show({\n        title: 'Change Stage',\n        message: 'The hanging protocol has no more applicable stages',\n        type: 'info',\n        duration: 3000,\n      });\n    },\n\n    /**\n     * Changes the viewport grid layout in terms of the MxN layout.\n     */\n    setViewportGridLayout: ({ numRows, numCols }) => {\n      const { protocol } = hangingProtocolService.getActiveProtocol();\n      const onLayoutChange = protocol.callbacks?.onLayoutChange;\n      if (commandsManager.run(onLayoutChange, { numRows, numCols }) === false) {\n        console.log(\n          'setViewportGridLayout running',\n          onLayoutChange,\n          numRows,\n          numCols\n        );\n        // Don't apply the layout if the run command returns false\n        return;\n      }\n\n      const completeLayout = () => {\n        const state = viewportGridService.getState();\n        const stateReduce = findViewportsByPosition(\n          state,\n          { numRows, numCols },\n          stateSyncService\n        );\n        const findOrCreateViewport = layoutFindOrCreate.bind(\n          null,\n          hangingProtocolService,\n          stateReduce.viewportsByPosition\n        );\n\n        viewportGridService.setLayout({\n          numRows,\n          numCols,\n          findOrCreateViewport,\n        });\n        stateSyncService.store(stateReduce);\n      };\n      // Need to finish any work in the callback\n      window.setTimeout(completeLayout, 0);\n    },\n\n    toggleOneUpCustom() {\n      const viewportGridState = viewportGridService.getState();\n      const { activeViewportIndex, viewports, layout } = viewportGridState;\n      const {\n        displaySetInstanceUIDs,\n        displaySetOptions,\n        viewportOptions,\n      } = viewports[activeViewportIndex];\n\n      console.log('DoubleClick - TOGGLE ONE UP', viewportOptions)\n      //Disable double click zoom for other volumes than 3d volume\n      // if(viewportOptions.toolGroupId !== 'volume3d'){\n      //   console.warn('DOUBLE_CLICK::EVENT::WARNING : Double click focus disabled for other window than 3D volume one')\n      //   return;\n      // }\n\n      if (layout.numCols === 1 && layout.numRows === 1) {\n        // The viewer is in one-up. Check if there is a state to restore/toggle back to.\n        const { toggleOneUpViewportGridStore } = stateSyncService.getState();\n\n        if (!toggleOneUpViewportGridStore.layout) {\n          return;\n        }\n        // There is a state to toggle back to. The viewport that was\n        // originally toggled to one up was the former active viewport.\n        const viewportIndexToUpdate =\n            toggleOneUpViewportGridStore.activeViewportIndex;\n\n        // Determine which viewports need to be updated. This is particularly\n        // important when MPR is toggled to one up and a different reconstructable\n        // is swapped in. Note that currently HangingProtocolService.getViewportsRequireUpdate\n        // does not support viewport with multiple display sets.\n        const updatedViewports =\n            displaySetInstanceUIDs.length > 1\n                ? []\n                : displaySetInstanceUIDs\n                    .map(displaySetInstanceUID =>\n                        hangingProtocolService.getViewportsRequireUpdate(\n                            viewportIndexToUpdate,\n                            displaySetInstanceUID\n                        )\n                    )\n                    .flat();\n\n        // This findOrCreateViewport returns either one of the updatedViewports\n        // returned from the HP service OR if there is not one from the HP service then\n        // simply returns what was in the previous state.\n        const findOrCreateViewport = (viewportIndex: number) => {\n          const viewport = updatedViewports.find(\n              viewport => viewport.viewportIndex === viewportIndex\n          );\n\n          return viewport\n              ? { viewportOptions, displaySetOptions, ...viewport }\n              : toggleOneUpViewportGridStore.viewports[viewportIndex];\n        };\n\n        const layoutOptions = viewportGridService.getLayoutOptionsFromState(\n            toggleOneUpViewportGridStore\n        );\n\n        // Restore the previous layout including the active viewport.\n        viewportGridService.setLayout({\n          numRows: toggleOneUpViewportGridStore.layout.numRows,\n          numCols: toggleOneUpViewportGridStore.layout.numCols,\n          activeViewportIndex: viewportIndexToUpdate,\n          layoutOptions,\n          findOrCreateViewport,\n        });\n      } else {\n        // We are not in one-up, so toggle to one up.\n\n        // Store the current viewport grid state so we can toggle it back later.\n        stateSyncService.store({\n          toggleOneUpViewportGridStore: viewportGridState,\n        });\n\n        // This findOrCreateViewport only return one viewport - the active\n        // one being toggled to one up.\n        const findOrCreateViewport = () => {\n          return {\n            displaySetInstanceUIDs,\n            displaySetOptions,\n            viewportOptions,\n          };\n        };\n\n        // Set the layout to be 1x1/one-up.\n        viewportGridService.setLayout({\n          numRows: 1,\n          numCols: 1,\n          findOrCreateViewport,\n        });\n\n        // Subscribe to ANY (i.e. manual and hanging protocol) layout changes so that\n        // any grid layout state to toggle to from one up is cleared. This is performed on\n        // a timeout to avoid clearing the state for the actual to one up change.\n        // Whenever the next layout change event is fired, the subscriptions are unsubscribed.\n        // const clearToggleOneUpViewportGridStore = () => {\n        //   const toggleOneUpViewportGridStore = {};\n        //   stateSyncService.store({\n        //     toggleOneUpViewportGridStore,\n        //   });\n        // };\n        //\n        // subscribeToNextViewportGridChange(\n        //     viewportGridService,\n        //     clearToggleOneUpViewportGridStore\n        // );\n      }\n    },\n\n    toggleOneUp() {\n      const viewportGridState = viewportGridService.getState();\n      const { activeViewportIndex, viewports, layout } = viewportGridState;\n      const {\n        displaySetInstanceUIDs,\n        displaySetOptions,\n        viewportOptions,\n      } = viewports[activeViewportIndex];\n\n      if (layout.numCols === 1 && layout.numRows === 1) {\n        // The viewer is in one-up. Check if there is a state to restore/toggle back to.\n        const { toggleOneUpViewportGridStore } = stateSyncService.getState();\n\n        if (!toggleOneUpViewportGridStore.layout) {\n          return;\n        }\n        // There is a state to toggle back to. The viewport that was\n        // originally toggled to one up was the former active viewport.\n        const viewportIndexToUpdate =\n          toggleOneUpViewportGridStore.activeViewportIndex;\n\n        // Determine which viewports need to be updated. This is particularly\n        // important when MPR is toggled to one up and a different reconstructable\n        // is swapped in. Note that currently HangingProtocolService.getViewportsRequireUpdate\n        // does not support viewport with multiple display sets.\n        const updatedViewports =\n          displaySetInstanceUIDs.length > 1\n            ? []\n            : displaySetInstanceUIDs\n                .map(displaySetInstanceUID =>\n                  hangingProtocolService.getViewportsRequireUpdate(\n                    viewportIndexToUpdate,\n                    displaySetInstanceUID\n                  )\n                )\n                .flat();\n\n        // This findOrCreateViewport returns either one of the updatedViewports\n        // returned from the HP service OR if there is not one from the HP service then\n        // simply returns what was in the previous state.\n        const findOrCreateViewport = (viewportIndex: number) => {\n          const viewport = updatedViewports.find(\n            viewport => viewport.viewportIndex === viewportIndex\n          );\n\n          return viewport\n            ? { viewportOptions, displaySetOptions, ...viewport }\n            : toggleOneUpViewportGridStore.viewports[viewportIndex];\n        };\n\n        const layoutOptions = viewportGridService.getLayoutOptionsFromState(\n          toggleOneUpViewportGridStore\n        );\n\n        // Restore the previous layout including the active viewport.\n        viewportGridService.setLayout({\n          numRows: toggleOneUpViewportGridStore.layout.numRows,\n          numCols: toggleOneUpViewportGridStore.layout.numCols,\n          activeViewportIndex: viewportIndexToUpdate,\n          layoutOptions,\n          findOrCreateViewport,\n        });\n      } else {\n        // We are not in one-up, so toggle to one up.\n\n        // Store the current viewport grid state so we can toggle it back later.\n        stateSyncService.store({\n          toggleOneUpViewportGridStore: viewportGridState,\n        });\n\n        // This findOrCreateViewport only return one viewport - the active\n        // one being toggled to one up.\n        const findOrCreateViewport = () => {\n          return {\n            displaySetInstanceUIDs,\n            displaySetOptions,\n            viewportOptions,\n          };\n        };\n\n        // Set the layout to be 1x1/one-up.\n        viewportGridService.setLayout({\n          numRows: 1,\n          numCols: 1,\n          findOrCreateViewport,\n        });\n\n        // Subscribe to ANY (i.e. manual and hanging protocol) layout changes so that\n        // any grid layout state to toggle to from one up is cleared. This is performed on\n        // a timeout to avoid clearing the state for the actual to one up change.\n        // Whenever the next layout change event is fired, the subscriptions are unsubscribed.\n        const clearToggleOneUpViewportGridStore = () => {\n          const toggleOneUpViewportGridStore = {};\n          stateSyncService.store({\n            toggleOneUpViewportGridStore,\n          });\n        };\n\n        subscribeToNextViewportGridChange(\n          viewportGridService,\n          clearToggleOneUpViewportGridStore\n        );\n      }\n    },\n\n    /**\n     * Exposes the browser history navigation used by OHIF. This command can be used to either replace or\n     * push a new entry into the browser history. For example, the following will replace the current\n     * browser history entry with the specified relative URL which changes the study displayed to the\n     * study with study instance UID 1.2.3. Note that as a result of using `options.replace = true`, the\n     * page prior to invoking this command cannot be returned to via the browser back button.\n     *\n     * navigateHistory({\n     *   to: 'viewer?StudyInstanceUIDs=1.2.3',\n     *   options: { replace: true },\n     * });\n     *\n     * @param historyArgs - arguments for the history function;\n     *                      the `to` property is the URL;\n     *                      the `options.replace` is a boolean indicating if the current browser history entry\n     *                      should be replaced or a new entry pushed onto the history (stack); the default value\n     *                      for `replace` is false\n     */\n    navigateHistory(historyArgs: NavigateHistory) {\n      history.navigate(historyArgs.to, historyArgs.options);\n    },\n\n    openDICOMTagViewer() {\n      const { activeViewportIndex, viewports } = viewportGridService.getState();\n      const activeViewportSpecificData = viewports[activeViewportIndex];\n      const { displaySetInstanceUIDs } = activeViewportSpecificData;\n\n      const displaySets = displaySetService.activeDisplaySets;\n      const { UIModalService } = servicesManager.services;\n\n      const displaySetInstanceUID = displaySetInstanceUIDs[0];\n      UIModalService.show({\n        content: DicomTagBrowser,\n        contentProps: {\n          displaySets,\n          displaySetInstanceUID,\n          onClose: UIModalService.hide,\n        },\n        title: 'DICOM Tag Browser',\n      });\n    },\n\n    /**\n     * Toggle viewport overlay (the information panel shown on the four corners\n     * of the viewport)\n     * @see ViewportOverlay and CustomizableViewportOverlay components\n     */\n    toggleOverlays: () => {\n      const overlays = document.getElementsByClassName('viewport-overlay');\n      for (let i = 0; i < overlays.length; i++) {\n        overlays.item(i).classList.toggle('hidden');\n      }\n    },\n\n    scrollActiveThumbnailIntoView: () => {\n      const { activeViewportIndex, viewports } = viewportGridService.getState();\n\n      if (\n        !viewports ||\n        activeViewportIndex < 0 ||\n        activeViewportIndex > viewports.length - 1\n      ) {\n        return;\n      }\n\n      const activeViewport = viewports[activeViewportIndex];\n      const activeDisplaySetInstanceUID =\n        activeViewport.displaySetInstanceUIDs[0];\n\n      const thumbnailList = document.querySelector('#ohif-thumbnail-list');\n\n      if (!thumbnailList) {\n        return;\n      }\n\n      const thumbnailListBounds = thumbnailList.getBoundingClientRect();\n\n      const thumbnail = document.querySelector(\n        `#thumbnail-${activeDisplaySetInstanceUID}`\n      );\n\n      if (!thumbnail) {\n        return;\n      }\n\n      const thumbnailBounds = thumbnail.getBoundingClientRect();\n\n      // This only handles a vertical thumbnail list.\n      if (\n        thumbnailBounds.top >= thumbnailListBounds.top &&\n        thumbnailBounds.top <= thumbnailListBounds.bottom\n      ) {\n        return;\n      }\n\n      thumbnail.scrollIntoView({ behavior: 'smooth' });\n    },\n\n    updateViewportDisplaySet: ({\n      direction,\n      excludeNonImageModalities,\n    }: UpdateViewportDisplaySetParams) => {\n      const nonImageModalities = [\n        'SR',\n        'SEG',\n        'SM',\n        'RTSTRUCT',\n        'RTPLAN',\n        'RTDOSE',\n      ];\n\n      // Sort the display sets as per the hanging protocol service viewport/display set scoring system.\n      // The thumbnail list uses the same sorting.\n      const dsSortFn = hangingProtocolService.getDisplaySetSortFunction();\n      const currentDisplaySets = [...displaySetService.activeDisplaySets];\n\n      currentDisplaySets.sort(dsSortFn);\n\n      const { activeViewportIndex, viewports } = viewportGridService.getState();\n\n      const { displaySetInstanceUIDs } = viewports[activeViewportIndex];\n\n      const activeDisplaySetIndex = currentDisplaySets.findIndex(displaySet =>\n        displaySetInstanceUIDs.includes(displaySet.displaySetInstanceUID)\n      );\n\n      let displaySetIndexToShow: number;\n\n      for (\n        displaySetIndexToShow = activeDisplaySetIndex + direction;\n        displaySetIndexToShow > -1 &&\n        displaySetIndexToShow < currentDisplaySets.length;\n        displaySetIndexToShow += direction\n      ) {\n        if (\n          !excludeNonImageModalities ||\n          !nonImageModalities.includes(\n            currentDisplaySets[displaySetIndexToShow].Modality\n          )\n        ) {\n          break;\n        }\n      }\n\n      if (\n        displaySetIndexToShow < 0 ||\n        displaySetIndexToShow >= currentDisplaySets.length\n      ) {\n        return;\n      }\n\n      const { displaySetInstanceUID } = currentDisplaySets[\n        displaySetIndexToShow\n      ];\n\n      let updatedViewports = [];\n\n      try {\n        updatedViewports = hangingProtocolService.getViewportsRequireUpdate(\n          activeViewportIndex,\n          displaySetInstanceUID\n        );\n      } catch (error) {\n        console.warn(error);\n        uiNotificationService.show({\n          title: 'Navigate Viewport Display Set',\n          message:\n            'The requested display sets could not be added to the viewport due to a mismatch in the Hanging Protocol rules.',\n          type: 'info',\n          duration: 3000,\n        });\n      }\n\n      viewportGridService.setDisplaySetsForViewports(updatedViewports);\n\n      setTimeout(() => actions.scrollActiveThumbnailIntoView(), 0);\n    },\n  };\n\n  const definitions = {\n    showContextMenu: {\n      commandFn: actions.showContextMenu,\n    },\n    closeContextMenu: {\n      commandFn: actions.closeContextMenu,\n    },\n    clearMeasurements: {\n      commandFn: actions.clearMeasurements,\n      storeContexts: [],\n      options: {},\n    },\n    displayNotification: {\n      commandFn: actions.displayNotification,\n      storeContexts: [],\n      options: {},\n    },\n    setHangingProtocol: {\n      commandFn: actions.setHangingProtocol,\n      storeContexts: [],\n      options: {},\n    },\n    toggleHangingProtocol: {\n      commandFn: actions.toggleHangingProtocol,\n      storeContexts: [],\n      options: {},\n    },\n    navigateHistory: {\n      commandFn: actions.navigateHistory,\n      storeContexts: [],\n      options: {},\n    },\n    nextStage: {\n      commandFn: actions.deltaStage,\n      storeContexts: [],\n      options: { direction: 1 },\n    },\n    previousStage: {\n      commandFn: actions.deltaStage,\n      storeContexts: [],\n      options: { direction: -1 },\n    },\n    setViewportGridLayout: {\n      commandFn: actions.setViewportGridLayout,\n      storeContexts: [],\n      options: {},\n    },\n    toggleOneUp: {\n      commandFn: actions.toggleOneUp,\n      storeContexts: [],\n      options: {},\n    },\n    toggleOneUpCustom: {\n      commandFn: actions.toggleOneUpCustom,\n      storeContexts: [],\n      options: {},\n    },\n    openDICOMTagViewer: {\n      commandFn: actions.openDICOMTagViewer,\n    },\n    updateViewportDisplaySet: {\n      commandFn: actions.updateViewportDisplaySet,\n      storeContexts: [],\n      options: {},\n    },\n  };\n\n  return {\n    actions,\n    definitions,\n    defaultContext: 'DEFAULT',\n  };\n};\n\nexport default commandsModule;\n","import { Types } from '@ohif/core';\n\n/**\n * This hanging protocol can be activated on the primary mode by directly\n * referencing it in a URL or by directly including it within a mode, e.g.:\n * `&hangingProtocolId=@ohif/mnGrid` added to the viewer URL\n * It is not included in the viewer mode by default.\n */\nconst hpMN: Types.HangingProtocol.Protocol = {\n  hasUpdatedPriorsInformation: false,\n  id: '@ohif/mnGrid',\n  description: 'Has various hanging protocol grid layouts',\n  name: '2x2',\n  protocolMatchingRules: [\n    {\n      id: 'OneOrMoreSeries',\n      weight: 25,\n      attribute: 'numberOfDisplaySetsWithImages',\n      constraint: {\n        greaterThan: 0,\n      },\n    },\n  ],\n  toolGroupIds: ['default'],\n  displaySetSelectors: {\n    defaultDisplaySetId: {\n      seriesMatchingRules: [\n        {\n          attribute: 'numImageFrames',\n          constraint: {\n            greaterThan: { value: 0 },\n          },\n        },\n        // This display set will select the specified items by preference\n        // It has no affect if nothing is specified in the URL.\n        {\n          attribute: 'isDisplaySetFromUrl',\n          weight: 10,\n          constraint: {\n            equals: true,\n          },\n        },\n      ],\n    },\n  },\n  defaultViewport: {\n    viewportOptions: {\n      viewportType: 'stack',\n      toolGroupId: 'default',\n      allowUnmatchedView: true,\n    },\n    displaySets: [\n      {\n        id: 'defaultDisplaySetId',\n        matchedDisplaySetsIndex: -1,\n      },\n    ],\n  },\n  stages: [\n    {\n      id: '2x2',\n      stageActivation: {\n        enabled: {\n          minViewportsMatched: 4,\n        },\n      },\n      viewportStructure: {\n        layoutType: 'grid',\n        properties: {\n          rows: 2,\n          columns: 2,\n        },\n      },\n      viewports: [\n        {\n          viewportOptions: {\n            toolGroupId: 'default',\n            allowUnmatchedView: true,\n          },\n          displaySets: [\n            {\n              id: 'defaultDisplaySetId',\n            },\n          ],\n        },\n        {\n          viewportOptions: {\n            toolGroupId: 'default',\n            allowUnmatchedView: true,\n          },\n          displaySets: [\n            {\n              matchedDisplaySetsIndex: 1,\n              id: 'defaultDisplaySetId',\n            },\n          ],\n        },\n        {\n          viewportOptions: {\n            toolGroupId: 'default',\n            allowUnmatchedView: true,\n          },\n          displaySets: [\n            {\n              matchedDisplaySetsIndex: 2,\n              id: 'defaultDisplaySetId',\n            },\n          ],\n        },\n        {\n          viewportOptions: {\n            toolGroupId: 'default',\n            allowUnmatchedView: true,\n          },\n          displaySets: [\n            {\n              matchedDisplaySetsIndex: 3,\n              id: 'defaultDisplaySetId',\n            },\n          ],\n        },\n      ],\n    },\n\n    // 3x1 stage\n    {\n      id: '3x1',\n      // Obsolete settings:\n      requiredViewports: 1,\n      preferredViewports: 3,\n      // New equivalent:\n      stageActivation: {\n        enabled: {\n          minViewportsMatched: 3,\n        },\n      },\n      viewportStructure: {\n        layoutType: 'grid',\n        properties: {\n          rows: 1,\n          columns: 3,\n        },\n      },\n      viewports: [\n        {\n          viewportOptions: {\n            toolGroupId: 'default',\n            allowUnmatchedView: true,\n          },\n          displaySets: [\n            {\n              id: 'defaultDisplaySetId',\n            },\n          ],\n        },\n        {\n          viewportOptions: {\n            toolGroupId: 'default',\n            allowUnmatchedView: true,\n          },\n          displaySets: [\n            {\n              id: 'defaultDisplaySetId',\n              matchedDisplaySetsIndex: 1,\n            },\n          ],\n        },\n        {\n          viewportOptions: {\n            toolGroupId: 'default',\n            allowUnmatchedView: true,\n          },\n          displaySets: [\n            {\n              id: 'defaultDisplaySetId',\n              matchedDisplaySetsIndex: 2,\n            },\n          ],\n        },\n      ],\n    },\n\n    // A 2x1 stage\n    {\n      id: '2x1',\n      requiredViewports: 1,\n      preferredViewports: 2,\n      stageActivation: {\n        enabled: {\n          minViewportsMatched: 2,\n        },\n      },\n      viewportStructure: {\n        layoutType: 'grid',\n        properties: {\n          rows: 1,\n          columns: 2,\n        },\n      },\n      viewports: [\n        {\n          viewportOptions: {\n            toolGroupId: 'default',\n            allowUnmatchedView: true,\n          },\n          displaySets: [\n            {\n              id: 'defaultDisplaySetId',\n            },\n          ],\n        },\n        {\n          viewportOptions: {\n            toolGroupId: 'default',\n            allowUnmatchedView: true,\n          },\n          displaySets: [\n            {\n              matchedDisplaySetsIndex: 1,\n              id: 'defaultDisplaySetId',\n            },\n          ],\n        },\n      ],\n    },\n\n    // A 1x1 stage - should be automatically activated if there is only 1 viewable instance\n    {\n      id: '1x1',\n      requiredViewports: 1,\n      preferredViewports: 1,\n      stageActivation: {\n        enabled: {\n          minViewportsMatched: 1,\n        },\n      },\n      viewportStructure: {\n        layoutType: 'grid',\n        properties: {\n          rows: 1,\n          columns: 1,\n        },\n      },\n      viewports: [\n        {\n          viewportOptions: {\n            toolGroupId: 'default',\n            allowUnmatchedView: true,\n          },\n          displaySets: [\n            {\n              id: 'defaultDisplaySetId',\n            },\n          ],\n        },\n      ],\n    },\n  ],\n  numberOfPriorsReferenced: -1,\n};\n\nexport default hpMN;\n","import hpMNGrid from './hpMNGrid';\n\nconst defaultProtocol = {\n  id: 'default',\n  locked: true,\n  // Don't store this hanging protocol as it applies to the currently active\n  // display set by default\n  // cacheId: null,\n  hasUpdatedPriorsInformation: false,\n  name: 'Default',\n  createdDate: '2021-02-23T19:22:08.894Z',\n  modifiedDate: '2023-04-01',\n  availableTo: {},\n  editableBy: {},\n  protocolMatchingRules: [],\n  toolGroupIds: ['default'],\n  // -1 would be used to indicate active only, whereas other values are\n  // the number of required priors referenced - so 0 means active with\n  // 0 or more priors.\n  numberOfPriorsReferenced: 0,\n  // Default viewport is used to define the viewport when\n  // additional viewports are added using the layout tool\n  defaultViewport: {\n    viewportOptions: {\n      viewportType: 'stack',\n      toolGroupId: 'default',\n      allowUnmatchedView: true,\n    },\n    displaySets: [\n      {\n        id: 'defaultDisplaySetId',\n        matchedDisplaySetsIndex: -1,\n      },\n    ],\n  },\n  displaySetSelectors: {\n    defaultDisplaySetId: {\n      // Matches displaysets, NOT series\n      seriesMatchingRules: [\n        // Try to match series with images by default, to prevent weird display\n        // on SEG/SR containing studies\n        {\n          attribute: 'numImageFrames',\n          constraint: {\n            greaterThan: { value: 0 },\n          },\n        },\n        // This display set will select the specified items by preference\n        // It has no affect if nothing is specified in the URL.\n        {\n          attribute: 'isSeriesUIDFromURL',\n          weight: 10,\n          constraint: {\n            equals: true,\n          },\n        },\n      ],\n      // Can be used to select matching studies\n      // studyMatchingRules: [],\n    },\n  },\n  stages: [\n    {\n      name: 'default',\n      viewportStructure: {\n        layoutType: 'grid',\n        properties: {\n          rows: 1,\n          columns: 1,\n        },\n      },\n      viewports: [\n        {\n          viewportOptions: {\n            viewportType: 'stack',\n            toolGroupId: 'default',\n            // This will specify the initial image options index if it matches in the URL\n            // and will otherwise not specify anything.\n            initialImageOptions: {\n              custom: 'sopInstanceLocation',\n            },\n            // Other options for initialImageOptions, which can be included in the default\n            // custom attribute, or can be provided directly.\n            //   index: 180,\n            //   preset: 'middle', // 'first', 'last', 'middle'\n            // },\n          },\n          displaySets: [\n            {\n              id: 'defaultDisplaySetId',\n            },\n          ],\n        },\n      ],\n      createdDate: '2021-02-23T18:32:42.850Z',\n    },\n  ],\n};\n\nfunction getHangingProtocolModule() {\n  return [\n    {\n      name: defaultProtocol.id,\n      protocol: defaultProtocol,\n    },\n    // Create a MxN hanging protocol available by default\n    {\n      name: hpMNGrid.id,\n      protocol: hpMNGrid,\n    },\n  ];\n}\n\nexport default getHangingProtocolModule;\n","import React from 'react';\nimport classnames from 'classnames';\nimport { useNavigate } from 'react-router-dom';\nimport { useAppConfig } from '@state';\n\nimport { Button } from '@ohif/ui';\n\nfunction DataSourceSelector() {\n  const [appConfig] = useAppConfig();\n  const navigate = useNavigate();\n\n  // This is frowned upon, but the raw config is needed here to provide\n  // the selector\n  const dsConfigs = appConfig.dataSources;\n\n  return (\n    <div style={{ width: '100%', height: '100%' }}>\n      <div className=\"h-screen w-screen flex justify-center items-center \">\n        <div className=\"py-8 px-8 mx-auto bg-secondary-dark drop-shadow-md space-y-2 rounded-lg\">\n          <img\n            className=\"block mx-auto h-14\"\n            src=\"./ohif-logo.svg\"\n            alt=\"OHIF\"\n          />\n          <div className=\"text-center space-y-2 pt-4\">\n            {dsConfigs\n              .filter(\n                it =>\n                  it.sourceName !== 'dicomjson' &&\n                  it.sourceName !== 'dicomlocal'\n              )\n              .map(ds => (\n                <div key={ds.sourceName}>\n                  <h1 className=\"text-white\">{ds.friendlyName}</h1>\n                  <Button\n                    className={classnames('font-bold', 'ml-2')}\n                    onClick={() => {\n                      navigate({\n                        pathname: '/',\n                        search: `datasources=${ds.sourceName}`,\n                      });\n                    }}\n                  >\n                    {ds.sourceName}\n                  </Button>\n                  <br />\n                </div>\n              ))}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default DataSourceSelector;\n","import OHIF from '@ohif/core';\n\nimport {\n  InstanceMetadata,\n  PhilipsPETPrivateGroup,\n} from '@cornerstonejs/calculate-suv/src/types';\n\nconst metadataProvider = OHIF.classes.MetadataProvider;\n\nexport default function getPTImageIdInstanceMetadata(\n  imageId: string\n): InstanceMetadata {\n  const dicomMetaData = metadataProvider.get('instance', imageId);\n\n  if (!dicomMetaData) {\n    throw new Error('dicom metadata are required');\n  }\n\n  if (\n    dicomMetaData.SeriesDate === undefined ||\n    dicomMetaData.SeriesTime === undefined ||\n    dicomMetaData.PatientWeight === undefined ||\n    dicomMetaData.CorrectedImage === undefined ||\n    dicomMetaData.Units === undefined ||\n    !dicomMetaData.RadiopharmaceuticalInformationSequence ||\n    dicomMetaData.RadiopharmaceuticalInformationSequence[0]\n      .RadionuclideHalfLife === undefined ||\n    dicomMetaData.RadiopharmaceuticalInformationSequence[0]\n      .RadionuclideTotalDose === undefined ||\n    dicomMetaData.DecayCorrection === undefined ||\n    dicomMetaData.AcquisitionDate === undefined ||\n    dicomMetaData.AcquisitionTime === undefined ||\n    (dicomMetaData.RadiopharmaceuticalInformationSequence[0]\n      .RadiopharmaceuticalStartDateTime === undefined &&\n      dicomMetaData.RadiopharmaceuticalInformationSequence[0]\n        .RadiopharmaceuticalStartTime === undefined)\n  ) {\n    throw new Error('required metadata are missing');\n  }\n\n  const instanceMetadata: InstanceMetadata = {\n    CorrectedImage: dicomMetaData.CorrectedImage,\n    Units: dicomMetaData.Units,\n    RadionuclideHalfLife:\n      dicomMetaData.RadiopharmaceuticalInformationSequence[0]\n        .RadionuclideHalfLife,\n    RadionuclideTotalDose:\n      dicomMetaData.RadiopharmaceuticalInformationSequence[0]\n        .RadionuclideTotalDose,\n    RadiopharmaceuticalStartDateTime:\n      dicomMetaData.RadiopharmaceuticalInformationSequence[0]\n        .RadiopharmaceuticalStartDateTime,\n    RadiopharmaceuticalStartTime:\n      dicomMetaData.RadiopharmaceuticalInformationSequence[0]\n        .RadiopharmaceuticalStartTime,\n    DecayCorrection: dicomMetaData.DecayCorrection,\n    PatientWeight: dicomMetaData.PatientWeight,\n    SeriesDate: dicomMetaData.SeriesDate,\n    SeriesTime: dicomMetaData.SeriesTime,\n    AcquisitionDate: dicomMetaData.AcquisitionDate,\n    AcquisitionTime: dicomMetaData.AcquisitionTime,\n  };\n\n  if (\n    dicomMetaData['70531000'] ||\n    dicomMetaData['70531000'] !== undefined ||\n    dicomMetaData['70531009'] ||\n    dicomMetaData['70531009'] !== undefined\n  ) {\n    const philipsPETPrivateGroup: PhilipsPETPrivateGroup = {\n      SUVScaleFactor: dicomMetaData['70531000'],\n      ActivityConcentrationScaleFactor: dicomMetaData['70531009'],\n    };\n    instanceMetadata.PhilipsPETPrivateGroup = philipsPETPrivateGroup;\n  }\n\n  if (dicomMetaData['0009100d'] && dicomMetaData['0009100d'] !== undefined) {\n    instanceMetadata.GEPrivatePostInjectionDateTime = dicomMetaData['0009100d'];\n  }\n\n  if (\n    dicomMetaData.FrameReferenceTime &&\n    dicomMetaData.FrameReferenceTime !== undefined\n  ) {\n    instanceMetadata.FrameReferenceTime = dicomMetaData.FrameReferenceTime;\n  }\n\n  if (\n    dicomMetaData.ActualFrameDuration &&\n    dicomMetaData.ActualFrameDuration !== undefined\n  ) {\n    instanceMetadata.ActualFrameDuration = dicomMetaData.ActualFrameDuration;\n  }\n\n  if (dicomMetaData.PatientSex && dicomMetaData.PatientSex !== undefined) {\n    instanceMetadata.PatientSex = dicomMetaData.PatientSex;\n  }\n\n  if (dicomMetaData.PatientSize && dicomMetaData.PatientSize !== undefined) {\n    instanceMetadata.PatientSize = dicomMetaData.PatientSize;\n  }\n\n  return instanceMetadata;\n}\n\nfunction convertInterfaceTimeToString(time): string {\n  const hours = `${time.hours || '00'}`.padStart(2, '0');\n  const minutes = `${time.minutes || '00'}`.padStart(2, '0');\n  const seconds = `${time.seconds || '00'}`.padStart(2, '0');\n\n  const fractionalSeconds = `${time.fractionalSeconds || '000000'}`.padEnd(\n    6,\n    '0'\n  );\n\n  const timeString = `${hours}${minutes}${seconds}.${fractionalSeconds}`;\n  return timeString;\n}\n\nfunction convertInterfaceDateToString(date): string {\n  const month = `${date.month}`.padStart(2, '0');\n  const day = `${date.day}`.padStart(2, '0');\n  const dateString = `${date.year}${month}${day}`;\n  return dateString;\n}\n\nexport { getPTImageIdInstanceMetadata };\n","import { DicomMetadataStore, classes } from '@ohif/core';\nimport { calculateSUVScalingFactors } from '@cornerstonejs/calculate-suv';\n\nimport getPTImageIdInstanceMetadata from './getPTImageIdInstanceMetadata';\nimport { utilities } from '@cornerstonejs/core';\nimport colormaps from '../../tmtv/src/utils/colormaps';\n\nconst { registerColormap } = utilities.colormap;\n\nconst metadataProvider = classes.MetadataProvider;\n\n/**\n *\n * @param {Object} servicesManager\n * @param {Object} configuration\n */\nexport default function init({ servicesManager, configuration = {} }): void {\n  const { stateSyncService } = servicesManager.services;\n  // Add\n  DicomMetadataStore.subscribe(\n    DicomMetadataStore.EVENTS.INSTANCES_ADDED,\n    handlePETImageMetadata\n  );\n\n  // If the metadata for PET has changed by the user (e.g. manually changing the PatientWeight)\n  // we need to recalculate the SUV Scaling Factors\n  DicomMetadataStore.subscribe(\n    DicomMetadataStore.EVENTS.SERIES_UPDATED,\n    handlePETImageMetadata\n  );\n\n  // viewportGridStore is a sync state which stores the entire\n  // ViewportGridService getState, by the keys `<activeStudyUID>:<protocolId>:<stageIndex>`\n  // Used to recover manual changes to the layout of a stage.\n  stateSyncService.register('viewportGridStore', { clearOnModeExit: true });\n\n  // displaySetSelectorMap stores a map from\n  // `<activeStudyUID>:<displaySetSelectorId>:<matchOffset>` to\n  // a displaySetInstanceUID, used to display named display sets in\n  // specific spots within a hanging protocol and be able to remember what the\n  // user did with those named spots between stages and protocols.\n  stateSyncService.register('displaySetSelectorMap', { clearOnModeExit: true });\n\n  // Stores a map from `<activeStudyUID>:${protocolId}` to the getHPInfo results\n  // in order to recover the correct stage when returning to a Hanging Protocol.\n  stateSyncService.register('hangingProtocolStageIndexMap', {\n    clearOnModeExit: true,\n  });\n\n  // Stores a map from the to be applied hanging protocols `<activeStudyUID>:<protocolId>`\n  // to the previously applied hanging protolStageIndexMap key, in order to toggle\n  // off the applied protocol and remember the old state.\n  stateSyncService.register('toggleHangingProtocol', { clearOnModeExit: true });\n\n  // Stores the viewports by `rows-cols` position so that when the layout\n  // changes numRows and numCols, the viewports can be remembers and then replaced\n  // afterwards.\n  stateSyncService.register('viewportsByPosition', { clearOnModeExit: true });\n}\n\nconst handlePETImageMetadata = ({ SeriesInstanceUID, StudyInstanceUID }) => {\n  const { instances } = DicomMetadataStore.getSeries(\n    StudyInstanceUID,\n    SeriesInstanceUID\n  );\n\n  const modality = instances[0].Modality;\n  if (modality !== 'PT') {\n    return;\n  }\n  const imageIds = instances.map(instance => instance.imageId);\n  const instanceMetadataArray = [];\n  imageIds.forEach(imageId => {\n    const instanceMetadata = getPTImageIdInstanceMetadata(imageId);\n    if (instanceMetadata) {\n      instanceMetadataArray.push(instanceMetadata);\n    }\n  });\n\n  if (!instanceMetadataArray.length) {\n    return;\n  }\n\n  // try except block to prevent errors when the metadata is not correct\n  let suvScalingFactors;\n  try {\n    suvScalingFactors = calculateSUVScalingFactors(instanceMetadataArray);\n  } catch (error) {\n    console.log(error);\n  }\n\n  if (!suvScalingFactors) {\n    return;\n  }\n\n  instanceMetadataArray.forEach((instanceMetadata, index) => {\n    metadataProvider.addCustomMetadata(\n      imageIds[index],\n      'scalingModule',\n      suvScalingFactors[index]\n    );\n  });\n\n  colormaps.forEach(registerColormap);\n};\n","import { Types } from '@ohif/core';\n\nimport getDataSourcesModule from './getDataSourcesModule.js';\nimport getLayoutTemplateModule from './getLayoutTemplateModule.js';\nimport getPanelModule from './getPanelModule';\nimport getSopClassHandlerModule from './getSopClassHandlerModule.js';\nimport getToolbarModule from './getToolbarModule';\nimport getCommandsModule from './commandsModule';\nimport getHangingProtocolModule from './getHangingProtocolModule';\nimport getStudiesForPatientByMRN from './Panels/getStudiesForPatientByMRN';\nimport getCustomizationModule from './getCustomizationModule';\nimport { id } from './id.js';\nimport preRegistration from './init';\nimport {\n  ContextMenuController,\n  CustomizableContextMenuTypes,\n} from './CustomizableContextMenu';\nimport * as dicomWebUtils from './DicomWebDataSource/utils';\n\nconst defaultExtension: Types.Extensions.Extension = {\n  /**\n   * Only required property. Should be a unique value across all extensions.\n   */\n  id,\n  preRegistration,\n  getDataSourcesModule,\n  getLayoutTemplateModule,\n  getPanelModule,\n  getHangingProtocolModule,\n  getSopClassHandlerModule,\n  getToolbarModule,\n  getCommandsModule,\n  getUtilityModule({ servicesManager }) {\n    return [\n      {\n        name: 'common',\n        exports: {\n          getStudiesForPatientByMRN,\n        },\n      },\n    ];\n  },\n\n  getCustomizationModule,\n};\n\nexport default defaultExtension;\n\nexport {\n  ContextMenuController,\n  CustomizableContextMenuTypes,\n  getStudiesForPatientByMRN,\n  dicomWebUtils,\n};\n","import ViewerLayout from './ViewerLayout';\n/*\n- Define layout for the viewer in mode configuration.\n- Pass in the viewport types that can populate the viewer.\n- Init layout based on the displaySets and the objects.\n*/\n\nexport default function({\n  servicesManager,\n  extensionManager,\n  commandsManager,\n  hotkeysManager,\n}) {\n  function ViewerLayoutWithServices(props) {\n    return ViewerLayout({\n      servicesManager,\n      extensionManager,\n      commandsManager,\n      hotkeysManager,\n      ...props,\n    });\n  }\n\n  return [\n    // Layout Template Definition\n    // TODO: this is weird naming\n    {\n      name: 'viewerLayout',\n      id: 'viewerLayout',\n      component: ViewerLayoutWithServices,\n    },\n  ];\n}\n","import { ToolbarButton } from '@ohif/ui';\nimport ToolbarDivider from './Toolbar/ToolbarDivider.tsx';\nimport ToolbarLayoutSelector from './Toolbar/ToolbarLayoutSelector.tsx';\nimport ToolbarSplitButton from './Toolbar/ToolbarSplitButton.tsx';\n\nexport default function getToolbarModule({ commandsManager, servicesManager }) {\n  return [\n    {\n      name: 'ohif.divider',\n      defaultComponent: ToolbarDivider,\n      clickHandler: () => {},\n    },\n    {\n      name: 'ohif.action',\n      defaultComponent: ToolbarButton,\n      clickHandler: () => {},\n    },\n    {\n      name: 'ohif.radioGroup',\n      defaultComponent: ToolbarButton,\n      clickHandler: () => {},\n    },\n    {\n      name: 'ohif.splitButton',\n      defaultComponent: ToolbarSplitButton,\n      clickHandler: () => {},\n    },\n    {\n      name: 'ohif.layoutSelector',\n      defaultComponent: ToolbarLayoutSelector,\n      clickHandler: (evt, clickedBtn, btnSectionName) => {},\n    },\n    {\n      name: 'ohif.toggle',\n      defaultComponent: ToolbarButton,\n      clickHandler: () => {},\n    },\n  ];\n}\n","import { CustomizationService } from '@ohif/core';\nimport React from 'react';\nimport DataSourceSelector from './Panels/DataSourceSelector';\n\n/**\n *\n * Note: this is an example of how the customization module can be used\n * using the customization module. Below, we are adding a new custom route\n * to the application at the path /custom and rendering a custom component\n * Real world use cases of the having a custom route would be to add a\n * custom page for the user to view their profile, or to add a custom\n * page for login etc.\n */\nexport default function getCustomizationModule() {\n  return [\n    {\n      name: 'helloPage',\n      value: {\n        id: 'customRoutes',\n        routes: [\n          {\n            path: '/custom',\n            children: () => (\n              <h1 style={{ color: 'white' }}>Hello Custom Route</h1>\n            ),\n          },\n        ],\n      },\n    },\n\n    // Example customization to list a set of datasources\n    {\n      name: 'datasources',\n      value: {\n        id: 'customRoutes',\n        routes: [\n          {\n            path: '/datasources',\n            children: DataSourceSelector,\n          },\n        ],\n      },\n    },\n\n    {\n      name: 'default',\n      value: [\n        /**\n         * Customization Component Type definition for overlay items.\n         * Overlay items are texts (or other components) that will be displayed\n         * on a Viewport Overlay, which contains the information panels on the\n         * four corners of a viewport.\n         *\n         * @definition of a overlay item using this type\n         * The value to be displayed is defined by\n         *  - setting DICOM image instance's property to this field,\n         *  - or defining contentF()\n         *\n         * {\n         *   id: string - unique id for the overlay item\n         *   customizationType: string - indicates customization type definition to this\n         *   label: string - Label, to be displayed for the item\n         *   title: string - Tooltip, for the item\n         *   color: string - Color of the text\n         *   condition: ({ instance }) => boolean - decides whether to display the overlay item or not\n         *   attribute: string - property name of the DICOM image instance\n         *   contentF: ({ instance, formatters }) => string | component,\n         * }\n         *\n         * @example\n         *  {\n         *    id: 'PatientNameOverlay',\n         *    customizationType: 'ohif.overlayItem',\n         *    label: 'PN:',\n         *    title: 'Patient Name',\n         *    color: 'yellow',\n         *    condition: ({ instance }) => instance && instance.PatientName && instance.PatientName.Alphabetic,\n         *    attribute: 'PatientName',\n         *    contentF: ({ instance, formatters: { formatPN } }) => `${formatPN(instance.PatientName.Alphabetic)} ${(instance.PatientSex ? '(' + instance.PatientSex + ')' : '')}`,\n         *  },\n         *\n         * @see CustomizableViewportOverlay\n         */\n        {\n          id: 'ohif.overlayItem',\n          content: function (props) {\n            if (this.condition && !this.condition(props)) return null;\n\n            const { instance } = props;\n            const value =\n              instance && this.attribute\n                ? instance[this.attribute]\n                : this.contentF && typeof this.contentF === 'function'\n                  ? this.contentF(props)\n                  : null;\n            if (!value) return null;\n\n            return (\n              <span\n                className=\"overlay-item flex flex-row\"\n                style={{ color: this.color || undefined }}\n                title={this.title || ''}\n              >\n                {this.label && (\n                  <span className=\"mr-1 shrink-0\">{this.label}</span>\n                )}\n                <span className=\"font-light\">{value}</span>\n              </span>\n            );\n          },\n        },\n\n        {\n          id: 'ohif.contextMenu',\n\n          /** Applies the customizationType to all the menu items.\n           * This function clones the object and child objects to prevent\n           * changes to the original customization object.\n           */\n          transform: function (customizationService: CustomizationService) {\n            // Don't modify the children, as those are copied by reference\n            const clonedObject = { ...this };\n            clonedObject.menus = this.menus.map(menu => ({ ...menu }));\n\n            for (const menu of clonedObject.menus) {\n              const { items: originalItems } = menu;\n              menu.items = [];\n              for (const item of originalItems) {\n                menu.items.push(customizationService.transform(item));\n              }\n            }\n            return clonedObject;\n          },\n        },\n      ],\n    },\n  ];\n}\n"],"names":["getString","getName","getModalities","DICOMWeb","processResults","qidoStudies","length","studies","forEach","qidoStudy","push","studyInstanceUid","date","time","accession","mrn","patientName","utils","formatPN","instances","Number","description","modalities","async","search","dicomWebClient","seriesInstanceUid","queryParameters","searchForStudies","undefined","queryParams","mapParams","params","options","commaSeparatedFields","join","supportsWildcard","withWildcard","value","parameters","PatientName","patientId","AccessionNumber","accessionNumber","StudyDescription","studyDescription","ModalitiesInStudy","modalitiesInStudy","limit","offset","fuzzymatching","supportsFuzzyMatching","includefield","startDate","endDate","StudyDate","today","Date","DD","String","getDate","padStart","MM","getMonth","todayStr","getFullYear","oldDateStr","studyUids","Array","isArray","replace","StudyInstanceUID","final","Object","keys","key","getImageId","instance","frame","config","thumbnail","url","renderingAttr","uri","baseWadoRsUri","SeriesInstanceUID","SOPInstanceUID","wadoRoot","buildInstanceWadoRsUri","buildInstanceFrameWadoRsUri","getWADORSImageId","wadouri","paramString","wadoUriRoot","buildInstanceWadoUrl","imageId","RetrieveMetadataLoader","constructor","client","studyInstanceUID","filters","sortCriteria","sortFunction","this","execLoad","preLoadData","preLoad","loadData","load","posLoad","runLoaders","loaders","result","loader","e","next","done","Error","configLoad","RetrieveMetadataLoaderSync","getOptions","seriesInstanceUID","getLoaders","retrieveSeriesMetadata","bind","retrieveStudyMetadata","RetrieveMetadataLoaderAsync","getPreLoaders","preLoaders","searchForSeries","naturalizeDataset","dcmjs","DicomMetaDictionary","naturalized","map","sortStudySeries","sortingCriteria","seriesSortCriteria","seriesInfoSortingCriteria","seriesAsyncLoader","seriesInstanceUIDList","freeze","hasNext","shift","makeSeriesAsyncLoader","s","promises","enableStudyLazyLoad","retrieveMetadataLoader","moduleName","StudyMetaDataPromises","Map","has","get","promise","Promise","resolve","reject","RetrieveMetadata","then","data","set","deleteStudyMetadataPromise","delete","StaticWadoClient","api","DICOMwebClient","qidoConfig","super","staticWado","searchResult","lowerParams","toLowerParams","filter","study","studyFilterKeys","filterItem","series","seriesFilterKeys","compareValues","desired","actual","find","item","actualItem","Alphabetic","indexOf","substring","compareDateRange","range","dash","start","end","sourceFilterMap","altKey","testValue","valueElem","vr","Value","entries","toLowerCase","studyinstanceuid","patientname","studydescription","studydate","modalitiesinstudy","accessionnumber","seriesinstanceuid","seriesnumber","modality","getDirectURL","singlepart","tag","defaultPath","defaultType","fetchPart","DirectRetrieveURL","InlineBinary","blob","b64toBlob","URL","createObjectURL","retrieveBulkData","arr","Blob","type","console","warn","BulkDataURI","hasQuery","hasAccept","fixBulkDataURI","dicomWebConfig","startsWith","origin","bulkDataURI","relativeResolution","DicomDict","denaturalizeDataset","ImplementationClassUID","ImplementationVersionName","EXPLICIT_VR_LITTLE_ENDIAN","metadataProvider","classes","MetadataProvider","createDicomWebApi","userAuthenticationService","qidoRoot","supportsReject","dicomWebConfigCopy","JSON","parse","stringify","headers","getAuthorizationHeader","errorInterceptor","errorHandler","getHTTPErrorHandler","wadoConfig","qidoDicomWebClient","wadoDicomWebClient","implementation","initialize","query","StudyInstanceUIDs","paramsStudyInstanceUIDs","queryStudyInstanceUIDs","splitComma","getAll","origParams","mappedParams","qidoSearch","qidoSeries","seriesNumber","seriesDate","formatDate","numSeriesInstances","processSeriesResults","seriesInStudy","call","retrieve","directURL","multipart","val","metadata","madeInClient","_retrieveSeriesMetadataAsync","_retrieveSeriesMetadataSync","store","dicom","dataset","request","ArrayBuffer","datasets","storeInstances","meta","FileMetaInformationVersion","_meta","MediaStorageSOPClassUID","SOPClassUID","MediaStorageSOPInstanceUID","TransferSyntaxUID","denaturalized","dicomDict","dict","write","naturalizedInstancesMetadata","seriesSummaryMetadata","instancesPerSeries","SeriesDescription","SeriesNumber","SeriesTime","ProtocolName","Modality","getImageIdsForInstance","addImageIdToUIDs","seriesMetadata","values","DicomMetadataStore","addSeriesMetadata","addInstances","seriesPromises","addRetrieveBulkData","enabled","ret","arrayBuffer","byteLength","aSeries","seriesDeliveredPromises","naturalizedInstances","index","wadoUri","all","getStudy","isLoaded","getImageIdsForDisplaySet","displaySet","images","imageIds","NumberOfFrames","getConfig","xhr","XMLHttpRequest","open","log","onreadystatechange","readyState","status","responseText","send","dcm4cheeReject","IWebApiDataSource","create","OHIF","mappings","_store","urls","getMetaDataByURL","metaData","findStudies","aStudy","createDicomJSONApi","dicomJsonConfig","name","response","fetch","json","studyInstanceUIDs","naturalizedDicom","param","mappedParam","NumInstances","Modalities","PatientID","StudyTime","debug","customSort","seriesSummary","numberOfSeries","obj","i","EVENTS","END_MODALITIES","SR","SEG","DOC","compareValue","v1","v2","def","seriesA","seriesB","instanceA","instanceB","modalityA","modalityB","isEndA","isEndB","createDicomLocalApi","dicomLocalConfig","StudyInstanceUIDsAsArray","sort","getStudyInstanceUIDs","numInstances","Set","add","firstInstance","from","SeriesDate","_broadcastEvent","SERIES_ADDED","isMultiframe","frameIndex","INSTANCES_ADDED","naturalizedReport","reportBlob","datasetToBlob","objectUrl","window","location","assign","getInstance","createDicomWebProxyApi","dicomWebProxyConfig","UserAuthenticationService","dicomWebDelegate","servers","dicomWeb","split","args","createDataSource","Toolbar","servicesManager","toolbarService","services","toolbarButtons","setToolbarButtons","useState","buttonState","setButtonState","primaryToolId","toggles","groups","useEffect","unsubscribe","unsub1","subscribe","TOOL_BAR_MODIFIED","getButtonSection","unsub2","TOOL_BAR_STATE_MODIFIED","state","React","toolDef","id","Component","componentProps","isActive","className","classnames","_extends","bState","onInteraction","recordInteraction","availableLanguages","defaultLanguage","currentLanguage","i18n","ViewerLayout","extensionManager","hotkeysManager","commandsManager","viewports","ViewportGridComp","leftPanels","rightPanels","leftPanelDefaultClosed","rightPanelDefaultClosed","appConfig","useAppConfig","navigate","useNavigate","useLocation","t","useTranslation","show","hide","useModal","showLoadingIndicator","setShowLoadingIndicator","hangingProtocolService","hotkeyDefinitions","hotkeyDefaults","menuOptions","title","icon","onClick","content","AboutModal","contentProps","versionNumber","process","commitHash","UserPreferences","getValidHotkeyDefinitions","onCancel","hotkeys","stopRecord","unpause","onSubmit","language","changeLanguage","setHotkeys","onReset","restoreDefaultBindings","hotkeysModule","oidc","encodeURIComponent","href","document","body","classList","remove","getComponent","entry","getModuleEntry","component","getPanelData","iconName","iconLabel","label","HangingProtocolService","PROTOCOL_CHANGED","leftPanelComponents","rightPanelComponents","viewportComponents","viewportComponent","namespace","displaySetsToDisplay","Header","isReturnEnabled","showStudyList","onClickReturnButton","pathname","dataSourceIdx","configUrl","URLSearchParams","searchQuery","append","decodeURIComponent","toString","WhiteLabeling","whiteLabeling","ErrorBoundary","context","style","height","LoadingIndicatorProgress","SidePanel","side","activeTabIndex","tabs","propTypes","PropTypes","isRequired","CommandsManager","ServicesManager","children","sortStudyInstances","PanelStudyBrowser","getImageSrc","getStudiesForPatientByMRN","requestDisplaySetCreationForStudy","dataSource","displaySetService","uiNotificationService","useImageViewer","activeViewportIndex","viewportGridService","useViewportGrid","activeTabName","setActiveTabName","expandedStudyInstanceUIDs","setExpandedStudyInstanceUIDs","studyDisplayList","setStudyDisplayList","displaySets","setDisplaySets","thumbnailImageSrcMap","setThumbnailImageSrcMap","isMounted","useRef","sid","qidoForStudyUID","qidoStudiesForPatient","error","actuallyMappedStudies","prevArray","it","fetchStudiesForPatient","activeDisplaySets","newImageSrcEntry","getDisplaySetByUID","dSet","displaySetInstanceUID","Math","floor","current","prevState","mappedDisplaySets","_mapDisplaySets","SubscriptionDisplaySetsAdded","DISPLAY_SETS_ADDED","displaySetsAdded","initialViewport","SubscriptionDisplaySetsChanged","DISPLAY_SETS_CHANGED","changedDisplaySets","primaryStudyInstanceUIDs","primaryStudies","recentStudies","allStudies","displaySetsForStudy","ds","tabStudy","includes","_createStudyBrowserTabs","activeDisplaySetInstanceUIDs","displaySetInstanceUIDs","StudyBrowser","onDoubleClickThumbnail","updatedViewports","viewportIndex","getViewportsRequireUpdate","message","duration","setDisplaySetsForViewports","onClickStudy","shouldCollapseStudy","updatedExpandedStudyInstanceUIDs","stdyUid","onClickTab","clickedTabName","thumbnailDisplaySets","thumbnailNoImageDisplaySets","excludeFromThumbnailBrowser","imageSrc","componentType","thumbnailNoImageModalities","_getComponentType","seriesTime","numImageFrames","countIcon","dragData","cornerstone","canvas","createElement","utilities","loadImageToCanvas","toDataURL","catch","some","WrappedPanelStudyBrowser","getDataSources","_getStudiesForPatientByMRN","_getImageSrcFromImageId","exports","getCornerstoneLibraries","getImageSrcFromImageId","ex","_createGetImageSrcFromImageIdFn","_requestDisplaySetCreationForStudy","ActionButtons","onExportClick","onCreateReportClick","ButtonGroup","color","size","Button","defaultProps","alert","CREATE_REPORT_DIALOG_RESPONSE","CANCEL","CREATE_REPORT","Loading","measurements","uiDialogService","loadingDialogId","showOverlay","isDraggable","centralize","runCommand","measurementData","additionalFindingTypes","getMostRecentDisplaySet","dismiss","MIN_SR_SERIES_NUMBER","findSRWithSameSeriesDescription","sameSeries","getActiveDisplaySets","InstanceNumber","srSeriesNumbers","max","getNextSRSeriesNumber","downloadCSVReport","PanelMeasurementTable","viewportGrid","measurementService","displayMeasurements","setDisplayMeasurements","debouncedSetDisplayMeasurements","debounce","_getMappedMeasurements","added","MEASUREMENT_ADDED","addedRaw","RAW_MEASUREMENT_ADDED","updated","MEASUREMENT_UPDATED","removed","MEASUREMENT_REMOVED","cleared","MEASUREMENTS_CLEARED","subscriptions","evt","unsub","cancel","onMeasurementItemClickHandler","uid","measurement","m","MeasurementTable","jumpToImage","jumpToMeasurement","onEdit","onMeasurementItemEditHandler","getMeasurement","onSubmitHandler","action","update","Dialog","noCloseButton","setValue","Input","labelClassName","autoFocus","onChange","event","persist","target","onKeyPress","actions","text","getMeasurements","onClearMeasurementsClick","clearMeasurements","activeViewport","trackedMeasurements","referenceStudyUID","promptResult","dialogId","dataSourcesOpts","dataSourceMap","configuration","dataSourceDefs","supportsStow","placeHolder","useLastPosition","dataSourceName","activeDataSource","onClose","_handleClose","_handleFormSubmit","Select","closeMenuOnSelect","placeholder","option","v","isClearable","required","createReportDialogPrompt","createReportAsync","types","displayText","baseDisplayText","baseLabel","selected","findingSites","finding","firstSite","siteText","site","measurementType","_mapMeasurementToDisplay","VALUE_TYPES","polyData","_extractGroup","neighborIds","cellGroup","pointGroup","visitedCells","currentCellId","pointIds","getCellPoints","cellPointIds","pointId","visitedPoints","neighborCellId","getPointCells","_buildExtractedPolyData","pBuffer","tBuffer","pointIdMap","idx","points","getPoints","getPoint","cellId","newPointIds","extractedPolyData","vtkPolyData","setData","Float32Array","getPolys","Uint32Array","setNumberOfComponents","extractGroups","extractedPolyDatas","getNumberOfCells","assert","getLinks","fill","getNumberOfPoints","math","require","Quadric","quadric","Axx","Axy","Axz","Ayy","Ayz","Azz","bx","by","bz","c","getCentroid","p0","p1","p2","getNormal","p10","p20","n","vtkMath","evaluate","point","x","y","z","optimalPoint","v_","a11","a12","a13","a22","a23","a33","det","abs","p","vx","vy","vz","dot","VertexPairCost","v1Id","v2Id","cost","targetReduction","copy","getTuples","setTargetReduction","target_reduction","initLines","lineSet","pointId1","pointId2","pointId3","a","b","id1A","id2A","id1B","id2B","initNeighbors","neighbors","line","lines","initQuadricMatrices","quadricMatrices","q","_computeQ_V_Cost","q1","qMatrices","q2","q_","middlePoint","errorP1","errorP2","errorMp","initPairCosts","pairCosts","nbPairs","lineId","pairCost","buildMinHeap","heapSize","heapify","costs","leftChildIndex","rightChildIndex","smallestIndex","extractMin","minElement","pop","_updateCells","minPairCost","minV1Id","minV2Id","neighborCells","getCellEdgeNeighbors","removeCellReference","getCells","deleteCell","currentNumberOfCells","deletedCells","setTuple","insertNextCellReference","_updatePoints","minV_","setPoint","deletedPoints","deletePoint","currentNumberOfPoints","_updatePairCosts","pairId","curV1Id","curV2Id","newQ_","newV_","newCost","otherVId","newV1Id","newV2Id","lastIndex","_removeDegenerate","degenerateCellPointIds","degenerateCellPointId","pointNeighbors","neighborPointId","clear","_updateNeighbors","minV2Neighbors","decimate","originalNumberOfCells","originalNumberOfPoints","targetNumberOfCells","pointMap","newPolyData","buildLinks","vtkErrorMacro","vtkDebugMacro","macro","DEFAULT_VALUES","contourValue","contourValueMax","computeNormals","mergePoints","extend","publicAPI","model","initialValues","arguments","algo","setGet","classHierarchy","ids","voxelScalars","voxelGradients","voxelPts","edgeLocator","vtkEdgeLocator","newInstance","getVoxelScalars","j","k","slice","dims","spacing","ii","getVoxelPoints","getPointGradient","g","sp","sm","getVoxelGradients","scalars","produceTriangles","cValMin","cValMax","extent","tris","normals","CASE_MASK","VERT_MAP","xyz","pId","scalar","voxelTris","vtkCaseTable","getCase","eid","edgeVerts","getEdge","isInsertedEdge","x0","x1","n0","n1","normalize","insertEdge","requestData","inData","outData","input","getOrigin","getSpacing","getDimensions","getPointData","getScalars","getData","nBuffer","getExtent","polydata","nData","vtkDataArray","numberOfComponents","setNormals","timeEnd","imageMarchingCubes","imageMarchingCubes$1","Edition3DPanel","percentileValues","setPercentileValues","cTPercentile","setCTPercentile","ctValue","setCtValue","reductionPercentile","setReductionPercentile","skinThreshold","setSkinThreshold","boneThreshold","setBoneThreshold","toothThreshold","setToothThreshold","isFirstRender","cornerstoneViewportService","myRandom","seed","seededRandom","getState","getActiveProtocol","protocol","protocolId","stageIndex","vp","viewportOptions","viewportType","setActiveViewportIndex","cornerstoneVP","getCornerstoneViewport","actorEntries","getActors","ctfun","vtkColorTransferFunction","addRGBPoint","ofun","vtkPiecewiseFunction","addPoint","actor","getProperty","setRGBTransferFunction","setScalarOpacity","getEnabledElement","element","viewport","render","width","display","flexDirection","justifyContent","vp3dIndex","findIndex","fontSize","min","step","marchingCubes","imageData","getCornerstoneViewportByIndex","getImageData","contourType","imageDataCopy","vtkImageData","shallowCopy","cropFilter","vtkImageCropFilter","setCroppingPlanes","setInputData","getOutputData","polyExtractor","polySTL","polyMapper","vtkMapper","polys","vtkActor","setMapper","setDiffuseColor","setOpacity","setBackfaceCulling","allPolys","PolyDataExtractor","polysSize","idxs","selectedPolys","qPolys","QuadricDecimator","mapper","setColor","outlineData","vtkOutlineFilter","mapOutline","setInputConnection","getOutputPort","outline","setActors","cornestoneRenderer","getRenderer","getRenderWindow","setNumberOfLayers","setUseDepthPeeling","setOcclusionRatio","setMaximumNumberOfPeels","getActiveCamera","setParallelProjection","resetCamera","_displayMarchingCubes","exportSTL","actorEntry","actorUID","getMapper","getInputData","fileContents","vtkSTLWriter","writeSTL","FormatTypes","BINARY","download","appendChild","click","zeros","dcmbufferToPng","invertRows","BitsAllocated","BitsStored","rows","Rows","columns","Columns","windowCenter","WindowCenter","windowWidth","WindowWidth","pixelArray","pixelData","PixelData","Int16Array","Int8Array","res","buffer","ext","determinationCoefficient","results","predictions","observations","d","mean","reduce","observation","ssyy","difference","sse","accum","prediction","residual","LSFMethods","polynomial","lhs","rhs","len","order","l","coefficients","matrix","maxrow","tmp","total","gaussianElimination","predict","sum","coeff","power","string","equation","reverse","r2","skmeans","DENTASCAN_THICKNESS","DENTAL_CURVE_THICKNESS","DENTASCAN_THRESHOLD_VALUE","TOLERANCE","DENTAL_CURVES_STEP","AXIAL_CURVES_STEP","DENTAL_CURVE_AIP_STEP","DENTAL_CURVE_AIP_THICKNESS","PanoramicGenerationPanel","toolGroupService","cornerstoneCacheService","customizationService","displaySetOptions","panelMetadata","setPanelMetadata","dentascanViewportData","panoramicViewportData","panoramic","isProcessingPanoramic","setIsProcessingPanoramic","processingPourcent","setProcessingPourcent","numberBasePoints","setNumberBasePoints","dicomDimensions","setDicomDimensions","panoramicDimensions","setPanoramicDimensions","generalSeriesModule","getCurrentImageId","displaySetCache","getDisplaySetCache","generalSeriesInstanceUID","filterMap","predicate","fmap","filteredDSPanoramic","filteredDSContrasted","previousPanoramicMetadata","getPanoramicStateCache","dentascanMeasurements","toolName","pm","dentascan","pointUp","indexToWorld","initialImageIndex","pointDown","ToolGroupManager","renderingEngineId","getToolInstance","addNewDentascanAnnotation","csToolsUtils","imageIndex","debounceLoading","setPanoramicStateCache","loadBlobInViewport","pngBuf","coloredBuffer","Uint8ClampedArray","imgData","ImageData","getContext","putImageData","toBlob","fileLoaderService","FileLoaderService","addFile","img","loadFile","getDataset","prefilledValues","addInstance","displaySetAdded","makeDisplaySets","getDataSource","viewportData","createViewportData","toolGroupId","initialImageOptions","preset","refreshStudyList","debugShowImage","indexZeroDisplaySet","getViewportInfoByIndex","baseVolumeSeriesUID","getSeries","voiLutModule","imagePixelModule","bitsAllocated","bitsStored","info","drawPoint","radius","pointX","round","pointY","beginPath","fillStyle","fillRect","textX","textY","font","textAlign","fillText","getMax","Infinity","derivative","f","dx","getSlopeVector","slope","vLength","sqrt","getTangentVector","tangentSlope","getDentascanSection","dicomData","vxNormal","vyNormal","getNormalVector","minPoint","maxPoint","dentascanWidth","nbLayers","layer","xi","yi","layerWidth","layerHeight","dicomIdx","layerSize","interval","director","getDentalCurve","transposedBin","transposeImage","transposedArr","transposedOnlyTeethIndex","lsfDentalCurve","lsfDentalLiss","isNaN","minX","maxX","getDentalLiss","c0","c1","sigmoidLeft","exp","sigmoidRight","generatePanoramicControlPoints","handmade","baseId","scalarData","isContrastAlreadyGenerated","baseVolume","cache","getVolumeContainingImageId","volume","dimensions","coronalData","getCoronalDataMax","voxelsXZ","voxelXZ","skMeansCoronal","centroids","centroidsCoronal","idxsCoronal","idxsMaxCoronal","firstIndex","findLastIndex","minLayer","maxLayer","axialData","getAxialDataMean","nbToothLayers","voxelsXY","voxelXY","minValue","maxValue","axialDataContrasted","pixel","normalizedPixel","contrastedPixel","pow","contrastedMetadata","setTimeout","contrastedViewport","contrastedImageData","skMeansResult","maxClusterIdx","binarizedArray","binarizedArrayDilated","filteredIdx","binarizedXy","controlPoints","controlPointsInWorld","cp","toolGroup","arrowAnnotateInstance","removeArrowAnnotation","addNewAnnotationWithMovablePoints","ctx","generatePanoramicFromControlPoints","controlPointsinViewport","hpInfo","panoramicViewportInfo","dentascanViewportInfo","deleteDisplaySet","contrastedDisplaySet","contrastedData","controlPointsInVolume","pointIndex","worldToIndex","dentascans","panoramicWidth","dentalCurvesPointsXY","getDentalCurvesPointsXY","mode","nbDentalCurves","nbAxialCurves","dentalCurvesPoints","dentascanCurve","dentascanMinPoint","dentascanMaxPoint","dentascanVxNormal","dentascanVyNormal","idxInf","idxSup","dentalCurve","dentascansForMIP","dentascanMIP","dentascanScalar","xPosInDentascan","xPosInDentascans","panoramicNormalsIterative","panoramicDepth","pointXY","valuesAlongNormal","xk","yk","scalarValue","absorption","panoramicProcessed","gImage","resultImageData","sigma","gaussianBlur","dist","PI","g0","g1","g2","kernel","normalizeCoef","kernelSize","halfKernelSize","ky","kx","blurPanoramic","image0","gImage0","alpha","scalarSlice","mp","imin","imax","xPt","yPt","sharpenedPanoramic","panoramicMetadata","dentascanObject","dentascansViewportData","random","FrameOfReferenceUID","createDatasetPromise","datasetsStack","layerData","layerI","layerSopInstanceUID","FrameNumber","dsStack","loadMultipleBlobsInViewport","fontWeight","marginBottom","marginRight","parseInt","ProgressBar","bgColor","completed","transitionDuration","transitionTimingFunction","secondaryLabel","wrappedMeasurementPanel","packageJson","sopClassHandlerName","isMultiFrame","makeDisplaySet","imageSet","ImageSet","isReconstructable","averageSpacingBetweenFrames","isDisplaySetReconstructable","setAttributes","FrameRate","FrameTime","SOPClassHandlerId","sortBy","isSingleImageModality","getDisplaySetsFromSeries","sopClassUids","uniqueSopClassUidsInSeries","getSopClassUids","stackableInstances","isImage","isClip","instanceNumber","acquisitionDatetime","AcquisitionDateTime","setAttribute","sopClassDictionary","ComputedRadiographyImageStorage","DigitalXRayImageStorageForPresentation","DigitalXRayImageStorageForProcessing","DigitalMammographyXRayImageStorageForPresentation","DigitalMammographyXRayImageStorageForProcessing","DigitalIntraOralXRayImageStorageForPresentation","DigitalIntraOralXRayImageStorageForProcessing","CTImageStorage","EnhancedCTImageStorage","LegacyConvertedEnhancedCTImageStorage","UltrasoundMultiframeImageStorage","MRImageStorage","EnhancedMRImageStorage","EnhancedMRColorImageStorage","LegacyConvertedEnhancedMRImageStorage","UltrasoundImageStorage","UltrasoundImageStorageRET","SecondaryCaptureImageStorage","MultiframeSingleBitSecondaryCaptureImageStorage","MultiframeGrayscaleByteSecondaryCaptureImageStorage","MultiframeGrayscaleWordSecondaryCaptureImageStorage","MultiframeTrueColorSecondaryCaptureImageStorage","XRayAngiographicImageStorage","EnhancedXAImageStorage","XRayRadiofluoroscopicImageStorage","EnhancedXRFImageStorage","XRay3DAngiographicImageStorage","XRay3DCraniofacialImageStorage","BreastTomosynthesisImageStorage","BreastProjectionXRayImageStorageForPresentation","BreastProjectionXRayImageStorageForProcessing","IntravascularOpticalCoherenceTomographyImageStorageForPresentation","IntravascularOpticalCoherenceTomographyImageStorageForProcessing","NuclearMedicineImageStorage","VLEndoscopicImageStorage","VideoEndoscopicImageStorage","VLMicroscopicImageStorage","VideoMicroscopicImageStorage","VLSlideCoordinatesMicroscopicImageStorage","VLPhotographicImageStorage","VideoPhotographicImageStorage","OphthalmicPhotography8BitImageStorage","OphthalmicPhotography16BitImageStorage","OphthalmicTomographyImageStorage","VLWholeSlideMicroscopyImageStorage","PositronEmissionTomographyImageStorage","EnhancedPETImageStorage","LegacyConvertedEnhancedPETImageStorage","RTImageStorage","EnhancedUSVolumeStorage","ToolbarDivider","LayoutSelector","rest","isOpen","setIsOpen","closeOnOutsideClick","addEventListener","removeEventListener","DropdownContent","OHIFLayoutSelector","ToolbarButton","onInteractionHandler","rounded","dropdownContent","onSelection","props","interactionType","commands","commandName","commandOptions","onLayoutChange","SplitButton","getMenuItems","selectorProps","menus","menuIdFilter","subProps","menu","subMenu","findIt","menuId","findMenuById","selector","findMenuDefault","findMenuIterator","return","findMenu","items","menuItems","delegating","toAdd","newItem","actionType","iconRight","itemRef","detail","adaptItem","ContextMenuController","closeContextMenu","showContextMenu","contextMenuProps","viewportElement","defaultPointsPosition","ContextMenuItemsBuilder","preservePosition","preventCutOf","defaultPosition","_getDefaultPosition","ContextMenu","onClickOutside","eventData","onShowSubMenu","onDefault","run","_ContextMenuController","getDefaultPosition","_getEventDefaultPosition","eventDetail","currentPoints","_getElementDefaultPosition","boundingClientRect","getBoundingClientRect","_getCanvasPointsPosition","viewerPos","_isValidPosition","source","canvasPoints","viewerElement","positionIterator","getPositionIterator","position","customizationType","nearbyToolData","rowVerticalPaddingStyle","padding","rowStyle","borderBottomWidth","ColumnHeaders","tagRef","vrRef","keywordRef","valueRef","classNames","ref","listRef","canvasRef","tagHeaderElem","setTagHeaderElem","vrHeaderElem","setVrHeaderElem","keywordHeaderElem","setKeywordHeaderElem","valueHeaderElem","setValueHeaderElem","scrollTo","resetAfterIndex","debouncedResize","Row","useCallback","row","isHeaderRendered","getItemSize","headerWidths","offsetWidth","getComputedStyle","colText","colOneLineWidth","measureText","ceil","maxHeight","colHeight","visibility","elem","List","itemCount","itemSize","nameMap","getFormattedRowsFromTags","tags","tagInfo","tagIndent","keyword","formatedRowsFromTags","Tag","fromPString","toCleanString","originalTagInfo","getRows","depth","keywords","sequenceAsArray","objectOrArray","sequence","sequenceRows","_sortTagList","regex","match","tagList","DicomTagBrowser","excludedColumnIndicesForFilter","selectedDisplaySetInstanceUID","setSelectedDisplaySetInstanceUID","setInstanceNumber","filterValue","setFilterValue","searchInputRef","activeDisplaySet","isImageStack","showInstanceList","displaySetList","useMemo","dateStr","moment","format","getSortedTags","filteredRows","filterValueLowerCase","keepRow","col","colIndex","debouncedSetFilterValue","Typography","variant","InputRange","inputClassName","labelPosition","trackColor","Icon","autoComplete","DicomTagTable","reuseCachedLayout","syncService","displaySetsCache","layout","activeStudyUID","stage","stages","storeId","syncState","cacheId","viewportGridStore","hangingProtocolStageIndexMap","displaySetSelectorMap","viewportStructure","properties","custom","numRows","numCols","displaySetUID","matchedDisplaySetsIndex","findOrCreateViewport","viewportsByPosition","positionId","byPositionViewport","inDisplay","initialInDisplay","missing","getMissingViewport","displaySetsInfo","findViewportsByPosition","storedViewport","viewportId","pos","subscribeToNextViewportGridChange","isHangingProtocolCommand","command","commandsModule","stateSyncService","contextMenuController","menuCustomizationId","optionsToUse","defaultContextMenu","displayNotification","toggleHpTools","toggleStageIndex","enableListener","button","hpCommand","stageId","setActive","getButtons","setHangingProtocol","reset","displaySetServiceCached","oldProtocol","stateSyncReduce","reuseCachedLayouts","hangingId","useStageIdx","getStageIndex","setActiveStudyUID","storedHanging","restoreProtocol","setProtocol","callbacks","onProtocolExit","onProtocolEnter","toggleHangingProtocol","desiredStageIndex","activeStudy","previousState","deltaStage","direction","oldStageIndex","setViewportGridLayout","completeLayout","stateReduce","layoutFindOrCreate","setLayout","toggleOneUpCustom","viewportGridState","toggleOneUpViewportGridStore","viewportIndexToUpdate","flat","layoutOptions","getLayoutOptionsFromState","toggleOneUp","clearToggleOneUpViewportGridStore","navigateHistory","historyArgs","history","to","openDICOMTagViewer","activeViewportSpecificData","UIModalService","toggleOverlays","overlays","getElementsByClassName","toggle","scrollActiveThumbnailIntoView","activeDisplaySetInstanceUID","thumbnailList","querySelector","thumbnailListBounds","thumbnailBounds","top","bottom","scrollIntoView","behavior","updateViewportDisplaySet","excludeNonImageModalities","nonImageModalities","dsSortFn","getDisplaySetSortFunction","currentDisplaySets","displaySetIndexToShow","definitions","commandFn","storeContexts","nextStage","previousStage","defaultContext","hasUpdatedPriorsInformation","protocolMatchingRules","weight","attribute","constraint","greaterThan","toolGroupIds","displaySetSelectors","defaultDisplaySetId","seriesMatchingRules","equals","defaultViewport","allowUnmatchedView","stageActivation","minViewportsMatched","layoutType","requiredViewports","preferredViewports","numberOfPriorsReferenced","defaultProtocol","locked","createdDate","modifiedDate","availableTo","editableBy","hpMNGrid","dsConfigs","dataSources","src","alt","sourceName","friendlyName","registerColormap","handlePETImageMetadata","instanceMetadataArray","instanceMetadata","dicomMetaData","PatientWeight","CorrectedImage","Units","RadiopharmaceuticalInformationSequence","RadionuclideHalfLife","RadionuclideTotalDose","DecayCorrection","AcquisitionDate","AcquisitionTime","RadiopharmaceuticalStartDateTime","RadiopharmaceuticalStartTime","philipsPETPrivateGroup","SUVScaleFactor","ActivityConcentrationScaleFactor","PhilipsPETPrivateGroup","GEPrivatePostInjectionDateTime","FrameReferenceTime","ActualFrameDuration","PatientSex","PatientSize","getPTImageIdInstanceMetadata","suvScalingFactors","calculateSUVScalingFactors","addCustomMetadata","colormaps","preRegistration","SERIES_UPDATED","register","clearOnModeExit","getDataSourcesModule","getLayoutTemplateModule","getPanelModule","getHangingProtocolModule","getSopClassHandlerModule","getToolbarModule","defaultComponent","clickHandler","ToolbarSplitButton","ToolbarLayoutSelector","clickedBtn","btnSectionName","getCommandsModule","getUtilityModule","getCustomizationModule","routes","path","DataSourceSelector","condition","contentF","transform","clonedObject","originalItems"],"sourceRoot":""}