{"version":3,"file":"8558.bundle.104df8f96368ed8d1a42.js","mappings":"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","sources":["webpack:///../../../extensions/cornerstone-dicom-rt/src/id.js","webpack:///../../../extensions/cornerstone-dicom-rt/src/loadRTStruct.js","webpack:///../../../extensions/cornerstone-dicom-rt/src/getSopClassHandlerModule.ts","webpack:///../../../extensions/cornerstone-dicom-rt/src/getCommandsModule.ts","webpack:///../../../extensions/cornerstone-dicom-rt/src/index.tsx"],"sourcesContent":["import packageJson from '../package.json';\r\n\r\nconst id = packageJson.name;\r\nconst SOPClassHandlerName = 'dicom-rt';\r\nconst SOPClassHandlerId = `${id}.sopClassHandlerModule.${SOPClassHandlerName}`;\r\n\r\nexport { id, SOPClassHandlerId, SOPClassHandlerName };\r\n","import dcmjs from 'dcmjs';\r\nconst { DicomMessage, DicomMetaDictionary } = dcmjs.data;\r\nconst dicomlab2RGB = dcmjs.data.Colors.dicomlab2RGB;\r\n\r\nasync function checkAndLoadContourData(instance, datasource) {\r\n  if (!instance || !instance.ROIContourSequence) {\r\n    return Promise.reject('Invalid instance object or ROIContourSequence');\r\n  }\r\n\r\n  const promisesMap = new Map();\r\n\r\n  for (const ROIContour of instance.ROIContourSequence) {\r\n    const referencedROINumber = ROIContour.ReferencedROINumber;\r\n    if (!ROIContour || !ROIContour.ContourSequence) {\r\n      promisesMap.set(referencedROINumber, [Promise.resolve([])]);\r\n      continue;\r\n    }\r\n\r\n    for (const Contour of ROIContour.ContourSequence) {\r\n      if (!Contour || !Contour.ContourData) {\r\n        return Promise.reject('Invalid Contour or ContourData');\r\n      }\r\n\r\n      const contourData = Contour.ContourData;\r\n\r\n      if (Array.isArray(contourData)) {\r\n        promisesMap.has(referencedROINumber)\r\n          ? promisesMap.get(referencedROINumber).push(Promise.resolve(contourData))\r\n          : promisesMap.set(referencedROINumber, [Promise.resolve(contourData)]);\r\n      } else if (contourData && contourData.BulkDataURI) {\r\n        const bulkDataURI = contourData.BulkDataURI;\r\n\r\n        if (!datasource || !datasource.retrieve || !datasource.retrieve.bulkDataURI) {\r\n          return Promise.reject('Invalid datasource object or retrieve function');\r\n        }\r\n\r\n        const bulkDataPromise = datasource.retrieve.bulkDataURI({\r\n          BulkDataURI: bulkDataURI,\r\n          StudyInstanceUID: instance.StudyInstanceUID,\r\n          SeriesInstanceUID: instance.SeriesInstanceUID,\r\n          SOPInstanceUID: instance.SOPInstanceUID,\r\n        });\r\n\r\n        promisesMap.has(referencedROINumber)\r\n          ? promisesMap.get(referencedROINumber).push(bulkDataPromise)\r\n          : promisesMap.set(referencedROINumber, [bulkDataPromise]);\r\n      } else {\r\n        return Promise.reject(`Invalid ContourData: ${contourData}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  const resolvedPromisesMap = new Map();\r\n  for (const [key, promiseArray] of promisesMap.entries()) {\r\n    resolvedPromisesMap.set(key, await Promise.allSettled(promiseArray));\r\n  }\r\n\r\n  instance.ROIContourSequence.forEach(ROIContour => {\r\n    try {\r\n      const referencedROINumber = ROIContour.ReferencedROINumber;\r\n      const resolvedPromises = resolvedPromisesMap.get(referencedROINumber);\r\n\r\n      if (ROIContour.ContourSequence) {\r\n        ROIContour.ContourSequence.forEach((Contour, index) => {\r\n          const promise = resolvedPromises[index];\r\n          if (promise.status === 'fulfilled') {\r\n            if (Array.isArray(promise.value) && promise.value.every(Number.isFinite)) {\r\n              // If promise.value is already an array of numbers, use it directly\r\n              Contour.ContourData = promise.value;\r\n            } else {\r\n              // If the resolved promise value is a byte array (Blob), it needs to be decoded\r\n              const uint8Array = new Uint8Array(promise.value);\r\n              const textDecoder = new TextDecoder();\r\n              const dataUint8Array = textDecoder.decode(uint8Array);\r\n              if (typeof dataUint8Array === 'string' && dataUint8Array.includes('\\\\')) {\r\n                Contour.ContourData = dataUint8Array.split('\\\\').map(parseFloat);\r\n              } else {\r\n                Contour.ContourData = [];\r\n              }\r\n            }\r\n          } else {\r\n            console.error(promise.reason);\r\n          }\r\n        });\r\n      }\r\n    } catch (error) {\r\n      console.error(error);\r\n    }\r\n  });\r\n}\r\n\r\nexport default async function loadRTStruct(extensionManager, rtStructDisplaySet, headers) {\r\n  const utilityModule = extensionManager.getModuleEntry(\r\n    '@ohif/extension-cornerstone.utilityModule.common'\r\n  );\r\n  const dataSource = extensionManager.getActiveDataSource()[0];\r\n  const { bulkDataURI } = dataSource.getConfig?.() || {};\r\n\r\n  const { dicomLoaderService } = utilityModule.exports;\r\n\r\n  // Set here is loading is asynchronous.\r\n  // If this function throws its set back to false.\r\n  rtStructDisplaySet.isLoaded = true;\r\n  let instance = rtStructDisplaySet.instance;\r\n\r\n  if (!bulkDataURI || !bulkDataURI.enabled) {\r\n    const segArrayBuffer = await dicomLoaderService.findDicomDataPromise(\r\n      rtStructDisplaySet,\r\n      null,\r\n      headers\r\n    );\r\n\r\n    const dicomData = DicomMessage.readFile(segArrayBuffer);\r\n    const rtStructDataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\r\n    rtStructDataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\r\n    instance = rtStructDataset;\r\n  } else {\r\n    await checkAndLoadContourData(instance, dataSource);\r\n  }\r\n\r\n  const { StructureSetROISequence, ROIContourSequence, RTROIObservationsSequence } = instance;\r\n\r\n  // Define our structure set entry and add it to the rtstruct module state.\r\n  const structureSet = {\r\n    StructureSetLabel: instance.StructureSetLabel,\r\n    SeriesInstanceUID: instance.SeriesInstanceUID,\r\n    ROIContours: [],\r\n    visible: true,\r\n    ReferencedSOPInstanceUIDsSet: new Set(),\r\n  };\r\n\r\n  for (let i = 0; i < ROIContourSequence.length; i++) {\r\n    const ROIContour = ROIContourSequence[i];\r\n    const { ContourSequence } = ROIContour;\r\n\r\n    if (!ContourSequence) {\r\n      continue;\r\n    }\r\n\r\n    const isSupported = false;\r\n\r\n    const ContourSequenceArray = _toArray(ContourSequence);\r\n\r\n    const contourPoints = [];\r\n    for (let c = 0; c < ContourSequenceArray.length; c++) {\r\n      const { ContourData, NumberOfContourPoints, ContourGeometricType, ContourImageSequence } =\r\n        ContourSequenceArray[c];\r\n\r\n      let isSupported = false;\r\n\r\n      const points = [];\r\n      for (let p = 0; p < NumberOfContourPoints * 3; p += 3) {\r\n        points.push({\r\n          x: ContourData[p],\r\n          y: ContourData[p + 1],\r\n          z: ContourData[p + 2],\r\n        });\r\n      }\r\n\r\n      switch (ContourGeometricType) {\r\n        case 'CLOSED_PLANAR':\r\n        case 'OPEN_PLANAR':\r\n        case 'POINT':\r\n          isSupported = true;\r\n\r\n          break;\r\n        default:\r\n          continue;\r\n      }\r\n\r\n      contourPoints.push({\r\n        numberOfPoints: NumberOfContourPoints,\r\n        points,\r\n        type: ContourGeometricType,\r\n        isSupported,\r\n      });\r\n\r\n      if (ContourImageSequence?.ReferencedSOPInstanceUID) {\r\n        structureSet.ReferencedSOPInstanceUIDsSet.add(\r\n          ContourImageSequence?.ReferencedSOPInstanceUID\r\n        );\r\n      }\r\n    }\r\n\r\n    _setROIContourMetadata(\r\n      structureSet,\r\n      StructureSetROISequence,\r\n      RTROIObservationsSequence,\r\n      ROIContour,\r\n      contourPoints,\r\n      isSupported\r\n    );\r\n  }\r\n  return structureSet;\r\n}\r\n\r\nfunction _setROIContourMetadata(\r\n  structureSet,\r\n  StructureSetROISequence,\r\n  RTROIObservationsSequence,\r\n  ROIContour,\r\n  contourPoints,\r\n  isSupported\r\n) {\r\n  const StructureSetROI = StructureSetROISequence.find(\r\n    structureSetROI => structureSetROI.ROINumber === ROIContour.ReferencedROINumber\r\n  );\r\n\r\n  const ROIContourData = {\r\n    ROINumber: StructureSetROI.ROINumber,\r\n    ROIName: StructureSetROI.ROIName,\r\n    ROIGenerationAlgorithm: StructureSetROI.ROIGenerationAlgorithm,\r\n    ROIDescription: StructureSetROI.ROIDescription,\r\n    isSupported,\r\n    contourPoints,\r\n    visible: true,\r\n  };\r\n\r\n  _setROIContourDataColor(ROIContour, ROIContourData);\r\n\r\n  if (RTROIObservationsSequence) {\r\n    // If present, add additional RTROIObservations metadata.\r\n    _setROIContourRTROIObservations(\r\n      ROIContourData,\r\n      RTROIObservationsSequence,\r\n      ROIContour.ReferencedROINumber\r\n    );\r\n  }\r\n\r\n  structureSet.ROIContours.push(ROIContourData);\r\n}\r\n\r\nfunction _setROIContourDataColor(ROIContour, ROIContourData) {\r\n  let { ROIDisplayColor, RecommendedDisplayCIELabValue } = ROIContour;\r\n\r\n  if (!ROIDisplayColor && RecommendedDisplayCIELabValue) {\r\n    // If ROIDisplayColor is absent, try using the RecommendedDisplayCIELabValue color.\r\n    ROIDisplayColor = dicomlab2RGB(RecommendedDisplayCIELabValue);\r\n  }\r\n\r\n  if (ROIDisplayColor) {\r\n    ROIContourData.colorArray = [...ROIDisplayColor];\r\n  }\r\n}\r\n\r\nfunction _setROIContourRTROIObservations(ROIContourData, RTROIObservationsSequence, ROINumber) {\r\n  const RTROIObservations = RTROIObservationsSequence.find(\r\n    RTROIObservations => RTROIObservations.ReferencedROINumber === ROINumber\r\n  );\r\n\r\n  if (RTROIObservations) {\r\n    // Deep copy so we don't keep the reference to the dcmjs dataset entry.\r\n    const { ObservationNumber, ROIObservationDescription, RTROIInterpretedType, ROIInterpreter } =\r\n      RTROIObservations;\r\n\r\n    ROIContourData.RTROIObservations = {\r\n      ObservationNumber,\r\n      ROIObservationDescription,\r\n      RTROIInterpretedType,\r\n      ROIInterpreter,\r\n    };\r\n  }\r\n}\r\n\r\nfunction _toArray(objOrArray) {\r\n  return Array.isArray(objOrArray) ? objOrArray : [objOrArray];\r\n}\r\n","import { utils } from '@ohif/core';\r\n\r\nimport { SOPClassHandlerId } from './id';\r\nimport loadRTStruct from './loadRTStruct';\r\n\r\nconst sopClassUids = ['1.2.840.10008.5.1.4.1.1.481.3'];\r\n\r\nconst loadPromises = {};\r\n\r\nfunction _getDisplaySetsFromSeries(\r\n  instances,\r\n  servicesManager: AppTypes.ServicesManager,\r\n  extensionManager\r\n) {\r\n  const instance = instances[0];\r\n\r\n  const {\r\n    StudyInstanceUID,\r\n    SeriesInstanceUID,\r\n    SOPInstanceUID,\r\n    SeriesDescription,\r\n    SeriesNumber,\r\n    SeriesDate,\r\n    SOPClassUID,\r\n    wadoRoot,\r\n    wadoUri,\r\n    wadoUriRoot,\r\n  } = instance;\r\n\r\n  const displaySet = {\r\n    Modality: 'RTSTRUCT',\r\n    loading: false,\r\n    isReconstructable: false, // by default for now since it is a volumetric SEG currently\r\n    displaySetInstanceUID: utils.guid(),\r\n    SeriesDescription,\r\n    SeriesNumber,\r\n    SeriesDate,\r\n    SOPInstanceUID,\r\n    SeriesInstanceUID,\r\n    StudyInstanceUID,\r\n    SOPClassHandlerId,\r\n    SOPClassUID,\r\n    referencedImages: null,\r\n    referencedSeriesInstanceUID: null,\r\n    referencedDisplaySetInstanceUID: null,\r\n    isDerivedDisplaySet: true,\r\n    isLoaded: false,\r\n    isHydrated: false,\r\n    structureSet: null,\r\n    sopClassUids,\r\n    instance,\r\n    wadoRoot,\r\n    wadoUriRoot,\r\n    wadoUri,\r\n    isOverlayDisplaySet: true,\r\n  };\r\n\r\n  let referencedSeriesSequence = instance.ReferencedSeriesSequence;\r\n  if (instance.ReferencedFrameOfReferenceSequence && !instance.ReferencedSeriesSequence) {\r\n    instance.ReferencedSeriesSequence = _deriveReferencedSeriesSequenceFromFrameOfReferenceSequence(\r\n      instance.ReferencedFrameOfReferenceSequence\r\n    );\r\n    referencedSeriesSequence = instance.ReferencedSeriesSequence;\r\n  }\r\n\r\n  if (!referencedSeriesSequence) {\r\n    throw new Error('ReferencedSeriesSequence is missing for the RTSTRUCT');\r\n  }\r\n\r\n  const referencedSeries = referencedSeriesSequence[0];\r\n\r\n  displaySet.referencedImages = instance.ReferencedSeriesSequence.ReferencedInstanceSequence;\r\n  displaySet.referencedSeriesInstanceUID = referencedSeries.SeriesInstanceUID;\r\n\r\n  const { displaySetService } = servicesManager.services;\r\n  const referencedDisplaySets = displaySetService.getDisplaySetsForSeries(\r\n    displaySet.referencedSeriesInstanceUID\r\n  );\r\n\r\n  if (!referencedDisplaySets || referencedDisplaySets.length === 0) {\r\n    // Instead of throwing error, subscribe to display sets added\r\n    const { unsubscribe } = displaySetService.subscribe(\r\n      displaySetService.EVENTS.DISPLAY_SETS_ADDED,\r\n      ({ displaySetsAdded }) => {\r\n        const addedDisplaySet = displaySetsAdded[0];\r\n        if (addedDisplaySet.SeriesInstanceUID === displaySet.referencedSeriesInstanceUID) {\r\n          displaySet.referencedDisplaySetInstanceUID = addedDisplaySet.displaySetInstanceUID;\r\n          unsubscribe();\r\n        }\r\n      }\r\n    );\r\n  } else {\r\n    const referencedDisplaySet = referencedDisplaySets[0];\r\n    displaySet.referencedDisplaySetInstanceUID = referencedDisplaySet.displaySetInstanceUID;\r\n  }\r\n\r\n  displaySet.load = ({ headers }) => _load(displaySet, servicesManager, extensionManager, headers);\r\n\r\n  return [displaySet];\r\n}\r\n\r\nfunction _load(rtDisplaySet, servicesManager: AppTypes.ServicesManager, extensionManager, headers) {\r\n  const { SOPInstanceUID } = rtDisplaySet;\r\n  const { segmentationService } = servicesManager.services;\r\n  if (\r\n    (rtDisplaySet.loading || rtDisplaySet.isLoaded) &&\r\n    loadPromises[SOPInstanceUID] &&\r\n    _segmentationExistsInCache(rtDisplaySet, segmentationService)\r\n  ) {\r\n    return loadPromises[SOPInstanceUID];\r\n  }\r\n\r\n  rtDisplaySet.loading = true;\r\n\r\n  // We don't want to fire multiple loads, so we'll wait for the first to finish\r\n  // and also return the same promise to any other callers.\r\n  loadPromises[SOPInstanceUID] = new Promise(async (resolve, reject) => {\r\n    if (!rtDisplaySet.structureSet) {\r\n      const structureSet = await loadRTStruct(extensionManager, rtDisplaySet, headers);\r\n\r\n      rtDisplaySet.structureSet = structureSet;\r\n    }\r\n\r\n    segmentationService\r\n      .createSegmentationForRTDisplaySet(rtDisplaySet)\r\n      .then(() => {\r\n        rtDisplaySet.loading = false;\r\n        resolve();\r\n      })\r\n      .catch(error => {\r\n        rtDisplaySet.loading = false;\r\n        reject(error);\r\n      });\r\n  });\r\n\r\n  return loadPromises[SOPInstanceUID];\r\n}\r\n\r\nfunction _deriveReferencedSeriesSequenceFromFrameOfReferenceSequence(\r\n  ReferencedFrameOfReferenceSequence\r\n) {\r\n  const ReferencedSeriesSequence = [];\r\n\r\n  ReferencedFrameOfReferenceSequence.forEach(referencedFrameOfReference => {\r\n    const { RTReferencedStudySequence } = referencedFrameOfReference;\r\n\r\n    RTReferencedStudySequence.forEach(rtReferencedStudy => {\r\n      const { RTReferencedSeriesSequence } = rtReferencedStudy;\r\n\r\n      RTReferencedSeriesSequence.forEach(rtReferencedSeries => {\r\n        const ReferencedInstanceSequence = [];\r\n        const { ContourImageSequence, SeriesInstanceUID } = rtReferencedSeries;\r\n\r\n        ContourImageSequence.forEach(contourImage => {\r\n          ReferencedInstanceSequence.push({\r\n            ReferencedSOPInstanceUID: contourImage.ReferencedSOPInstanceUID,\r\n            ReferencedSOPClassUID: contourImage.ReferencedSOPClassUID,\r\n          });\r\n        });\r\n\r\n        const referencedSeries = {\r\n          SeriesInstanceUID,\r\n          ReferencedInstanceSequence,\r\n        };\r\n\r\n        ReferencedSeriesSequence.push(referencedSeries);\r\n      });\r\n    });\r\n  });\r\n\r\n  return ReferencedSeriesSequence;\r\n}\r\n\r\nfunction _segmentationExistsInCache(\r\n  rtDisplaySet,\r\n  segmentationService: AppTypes.SegmentationService\r\n) {\r\n  // Todo: fix this\r\n  return false;\r\n  // This should be abstracted with the CornerstoneCacheService\r\n  const rtContourId = rtDisplaySet.displaySetInstanceUID;\r\n  const contour = segmentationService.getContour(rtContourId);\r\n\r\n  return contour !== undefined;\r\n}\r\n\r\nfunction getSopClassHandlerModule({ servicesManager, extensionManager }) {\r\n  return [\r\n    {\r\n      name: 'dicom-rt',\r\n      sopClassUids,\r\n      getDisplaySetsFromSeries: instances => {\r\n        return _getDisplaySetsFromSeries(instances, servicesManager, extensionManager);\r\n      },\r\n    },\r\n  ];\r\n}\r\n\r\nexport default getSopClassHandlerModule;\r\n","import { SegmentationRepresentations } from '@cornerstonejs/tools/enums';\r\n\r\nconst commandsModule = ({ commandsManager, servicesManager }: withAppTypes) => {\r\n  const services = servicesManager.services;\r\n  const { displaySetService, viewportGridService } = services;\r\n\r\n  const actions = {\r\n    hydrateRTSDisplaySet: ({ displaySet, viewportId }) => {\r\n      if (displaySet.Modality !== 'RTSTRUCT') {\r\n        throw new Error('Display set is not an RTSTRUCT');\r\n      }\r\n\r\n      const referencedDisplaySet = displaySetService.getDisplaySetByUID(\r\n        displaySet.referencedDisplaySetInstanceUID\r\n      );\r\n\r\n      // update the previously stored segmentationPresentation with the new viewportId\r\n      // presentation so that when we put the referencedDisplaySet back in the viewport\r\n      // it will have the correct segmentation representation hydrated\r\n      commandsManager.runCommand('updateStoredSegmentationPresentation', {\r\n        displaySet: displaySet,\r\n        type: SegmentationRepresentations.Contour,\r\n      });\r\n\r\n      // update the previously stored positionPresentation with the new viewportId\r\n      // presentation so that when we put the referencedDisplaySet back in the viewport\r\n      // it will be in the correct position zoom and pan\r\n      commandsManager.runCommand('updateStoredPositionPresentation', {\r\n        viewportId,\r\n        displaySetInstanceUID: referencedDisplaySet.displaySetInstanceUID,\r\n      });\r\n\r\n      viewportGridService.setDisplaySetsForViewport({\r\n        viewportId,\r\n        displaySetInstanceUIDs: [referencedDisplaySet.displaySetInstanceUID],\r\n      });\r\n    },\r\n  };\r\n\r\n  const definitions = {\r\n    hydrateRTSDisplaySet: {\r\n      commandFn: actions.hydrateRTSDisplaySet,\r\n      storeContexts: [],\r\n      options: {},\r\n    },\r\n  };\r\n\r\n  return {\r\n    actions,\r\n    definitions,\r\n    defaultContext: 'cornerstone-dicom-rt',\r\n  };\r\n};\r\n\r\nexport default commandsModule;\r\n","import { id } from './id';\r\nimport React from 'react';\r\nimport { Types } from '@ohif/core';\r\nimport getSopClassHandlerModule from './getSopClassHandlerModule';\r\nimport getCommandsModule from './getCommandsModule';\r\n\r\nconst Component = React.lazy(() => {\r\n  return import(/* webpackPrefetch: true */ './viewports/OHIFCornerstoneRTViewport');\r\n});\r\n\r\nconst OHIFCornerstoneRTViewport = props => {\r\n  return (\r\n    <React.Suspense fallback={<div>Loading...</div>}>\r\n      <Component {...props} />\r\n    </React.Suspense>\r\n  );\r\n};\r\n\r\n/**\r\n * You can remove any of the following modules if you don't need them.\r\n */\r\nconst extension: Types.Extensions.Extension = {\r\n  /**\r\n   * Only required property. Should be a unique value across all extensions.\r\n   * You ID can be anything you want, but it should be unique.\r\n   */\r\n  id,\r\n  getCommandsModule,\r\n\r\n  /**\r\n   * PanelModule should provide a list of panels that will be available in OHIF\r\n   * for Modes to consume and render. Each panel is defined by a {name,\r\n   * iconName, iconLabel, label, component} object. Example of a panel module\r\n   * is the StudyBrowserPanel that is provided by the default extension in OHIF.\r\n   */\r\n  getViewportModule({\r\n    servicesManager,\r\n    extensionManager,\r\n    commandsManager,\r\n  }: Types.Extensions.ExtensionParams) {\r\n    const ExtendedOHIFCornerstoneRTViewport = props => {\r\n      return (\r\n        <OHIFCornerstoneRTViewport\r\n          servicesManager={servicesManager}\r\n          extensionManager={extensionManager}\r\n          commandsManager={commandsManager}\r\n          {...props}\r\n        />\r\n      );\r\n    };\r\n\r\n    return [{ name: 'dicom-rt', component: ExtendedOHIFCornerstoneRTViewport }];\r\n  },\r\n  /**\r\n   * SopClassHandlerModule should provide a list of sop class handlers that will be\r\n   * available in OHIF for Modes to consume and use to create displaySets from Series.\r\n   * Each sop class handler is defined by a { name, sopClassUids, getDisplaySetsFromSeries}.\r\n   * Examples include the default sop class handler provided by the default extension\r\n   */\r\n  getSopClassHandlerModule,\r\n};\r\n\r\nexport default extension;\r\n"],"names":["id","packageJson","SOPClassHandlerId","DicomMessage","DicomMetaDictionary","dcmjs","dicomlab2RGB","Colors","async","loadRTStruct","extensionManager","rtStructDisplaySet","headers","utilityModule","getModuleEntry","dataSource","getActiveDataSource","bulkDataURI","getConfig","dicomLoaderService","exports","isLoaded","instance","enabled","datasource","ROIContourSequence","Promise","reject","promisesMap","Map","ROIContour","referencedROINumber","ReferencedROINumber","ContourSequence","Contour","ContourData","contourData","Array","isArray","has","get","push","resolve","set","BulkDataURI","retrieve","bulkDataPromise","StudyInstanceUID","SeriesInstanceUID","SOPInstanceUID","resolvedPromisesMap","key","promiseArray","entries","allSettled","forEach","resolvedPromises","index","promise","status","value","every","Number","isFinite","uint8Array","Uint8Array","dataUint8Array","TextDecoder","decode","includes","split","map","parseFloat","console","error","reason","checkAndLoadContourData","segArrayBuffer","findDicomDataPromise","dicomData","readFile","rtStructDataset","naturalizeDataset","dict","_meta","namifyDataset","meta","StructureSetROISequence","RTROIObservationsSequence","structureSet","StructureSetLabel","ROIContours","visible","ReferencedSOPInstanceUIDsSet","Set","i","length","isSupported","ContourSequenceArray","_toArray","contourPoints","c","NumberOfContourPoints","ContourGeometricType","ContourImageSequence","points","p","x","y","z","numberOfPoints","type","ReferencedSOPInstanceUID","add","_setROIContourMetadata","StructureSetROI","find","structureSetROI","ROINumber","ROIContourData","ROIName","ROIGenerationAlgorithm","ROIDescription","ROIDisplayColor","RecommendedDisplayCIELabValue","colorArray","_setROIContourDataColor","RTROIObservations","ObservationNumber","ROIObservationDescription","RTROIInterpretedType","ROIInterpreter","_setROIContourRTROIObservations","objOrArray","sopClassUids","loadPromises","_getDisplaySetsFromSeries","instances","servicesManager","SeriesDescription","SeriesNumber","SeriesDate","SOPClassUID","wadoRoot","wadoUri","wadoUriRoot","displaySet","Modality","loading","isReconstructable","displaySetInstanceUID","utils","guid","referencedImages","referencedSeriesInstanceUID","referencedDisplaySetInstanceUID","isDerivedDisplaySet","isHydrated","isOverlayDisplaySet","referencedSeriesSequence","ReferencedSeriesSequence","ReferencedFrameOfReferenceSequence","referencedFrameOfReference","RTReferencedStudySequence","rtReferencedStudy","RTReferencedSeriesSequence","rtReferencedSeries","ReferencedInstanceSequence","contourImage","ReferencedSOPClassUID","referencedSeries","_deriveReferencedSeriesSequenceFromFrameOfReferenceSequence","Error","displaySetService","services","referencedDisplaySets","getDisplaySetsForSeries","referencedDisplaySet","unsubscribe","subscribe","EVENTS","DISPLAY_SETS_ADDED","displaySetsAdded","addedDisplaySet","load","rtDisplaySet","segmentationService","createSegmentationForRTDisplaySet","then","catch","_load","name","getDisplaySetsFromSeries","commandsModule","commandsManager","viewportGridService","actions","hydrateRTSDisplaySet","viewportId","getDisplaySetByUID","runCommand","SegmentationRepresentations","setDisplaySetsForViewport","displaySetInstanceUIDs","definitions","commandFn","storeContexts","options","defaultContext","Component","React","OHIFCornerstoneRTViewport","props","fallback","getCommandsModule","getViewportModule","component","_extends","getSopClassHandlerModule"],"sourceRoot":""}