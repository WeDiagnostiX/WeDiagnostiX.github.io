{"version":3,"file":"571.bundle.7a56311f89cfde2dec44.js","mappings":"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","sources":["webpack:///../../../extensions/cornerstone-dicom-sr/src/viewports/OHIFCornerstoneSRViewport.tsx"],"sourcesContent":["import PropTypes from 'prop-types';\r\nimport React, { useCallback, useContext, useEffect, useState } from 'react';\r\nimport { useTranslation } from 'react-i18next';\r\nimport { ExtensionManager } from '@ohif/core';\r\n\r\nimport { setTrackingUniqueIdentifiersForElement } from '../tools/modules/dicomSRModule';\r\n\r\nimport { Icon, Tooltip, useViewportGrid, ViewportActionArrows } from '@ohif/ui';\r\nimport hydrateStructuredReport from '../utils/hydrateStructuredReport';\r\nimport { useAppConfig } from '@state';\r\nimport createReferencedImageDisplaySet from '../utils/createReferencedImageDisplaySet';\r\n\r\nconst MEASUREMENT_TRACKING_EXTENSION_ID = '@ohif/extension-measurement-tracking';\r\n\r\nconst SR_TOOLGROUP_BASE_NAME = 'SRToolGroup';\r\n\r\nfunction OHIFCornerstoneSRViewport(props: withAppTypes) {\r\n  const { children, dataSource, displaySets, viewportOptions, servicesManager, extensionManager } =\r\n    props;\r\n\r\n  const [appConfig] = useAppConfig();\r\n\r\n  const {\r\n    displaySetService,\r\n    cornerstoneViewportService,\r\n    measurementService,\r\n    viewportActionCornersService,\r\n  } = servicesManager.services;\r\n\r\n  const viewportId = viewportOptions.viewportId;\r\n\r\n  // SR viewport will always have a single display set\r\n  if (displaySets.length > 1) {\r\n    throw new Error('SR viewport should only have a single display set');\r\n  }\r\n\r\n  const srDisplaySet = displaySets[0];\r\n\r\n  const [viewportGrid, viewportGridService] = useViewportGrid();\r\n  const [measurementSelected, setMeasurementSelected] = useState(0);\r\n  const [measurementCount, setMeasurementCount] = useState(1);\r\n  const [activeImageDisplaySetData, setActiveImageDisplaySetData] = useState(null);\r\n  const [referencedDisplaySetMetadata, setReferencedDisplaySetMetadata] = useState(null);\r\n  const [element, setElement] = useState(null);\r\n  const { viewports, activeViewportId } = viewportGrid;\r\n\r\n  const { t } = useTranslation('Common');\r\n\r\n  // Optional hook into tracking extension, if present.\r\n  let trackedMeasurements;\r\n  let sendTrackedMeasurementsEvent;\r\n\r\n  const hasMeasurementTrackingExtension = extensionManager.registeredExtensionIds.includes(\r\n    MEASUREMENT_TRACKING_EXTENSION_ID\r\n  );\r\n\r\n  if (hasMeasurementTrackingExtension) {\r\n    const contextModule = extensionManager.getModuleEntry(\r\n      '@ohif/extension-measurement-tracking.contextModule.TrackedMeasurementsContext'\r\n    );\r\n\r\n    const tracked = useContext(contextModule.context);\r\n    trackedMeasurements = tracked?.[0];\r\n    sendTrackedMeasurementsEvent = tracked?.[1];\r\n  }\r\n  if (!sendTrackedMeasurementsEvent) {\r\n    // if no panels from measurement-tracking extension is used, this code will run\r\n    trackedMeasurements = null;\r\n    sendTrackedMeasurementsEvent = (eventName, { displaySetInstanceUID }) => {\r\n      measurementService.clearMeasurements();\r\n      const { SeriesInstanceUIDs } = hydrateStructuredReport(\r\n        { servicesManager, extensionManager, appConfig },\r\n        displaySetInstanceUID\r\n      );\r\n      const displaySets = displaySetService.getDisplaySetsForSeries(SeriesInstanceUIDs[0]);\r\n      if (displaySets.length) {\r\n        viewportGridService.setDisplaySetsForViewports([\r\n          {\r\n            viewportId: activeViewportId,\r\n            displaySetInstanceUIDs: [displaySets[0].displaySetInstanceUID],\r\n          },\r\n        ]);\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Store the tracking identifiers per viewport in order to be able to\r\n   * show the SR measurements on the referenced image on the correct viewport,\r\n   * when multiple viewports are used.\r\n   */\r\n  const setTrackingIdentifiers = useCallback(\r\n    measurementSelected => {\r\n      const { measurements } = srDisplaySet;\r\n\r\n      setTrackingUniqueIdentifiersForElement(\r\n        element,\r\n        measurements.map(measurement => measurement.TrackingUniqueIdentifier),\r\n        measurementSelected\r\n      );\r\n    },\r\n    [element, measurementSelected, srDisplaySet]\r\n  );\r\n\r\n  /**\r\n   * OnElementEnabled callback which is called after the cornerstoneExtension\r\n   * has enabled the element. Note: we delegate all the image rendering to\r\n   * cornerstoneExtension, so we don't need to do anything here regarding\r\n   * the image rendering, element enabling etc.\r\n   */\r\n  const onElementEnabled = evt => {\r\n    setElement(evt.detail.element);\r\n  };\r\n\r\n  const updateViewport = useCallback(\r\n    newMeasurementSelected => {\r\n      const { StudyInstanceUID, displaySetInstanceUID, sopClassUids } = srDisplaySet;\r\n\r\n      if (!StudyInstanceUID || !displaySetInstanceUID) {\r\n        return;\r\n      }\r\n\r\n      if (sopClassUids && sopClassUids.length > 1) {\r\n        // Todo: what happens if there are multiple SOP Classes? Why we are\r\n        // not throwing an error?\r\n        console.warn('More than one SOPClassUID in the same series is not yet supported.');\r\n      }\r\n\r\n      // if (!srDisplaySet.measurements || !srDisplaySet.measurements.length) {\r\n      //   return;\r\n      // }\r\n\r\n      _getViewportReferencedDisplaySetData(\r\n        srDisplaySet,\r\n        newMeasurementSelected,\r\n        displaySetService\r\n      ).then(({ referencedDisplaySet, referencedDisplaySetMetadata }) => {\r\n        setMeasurementSelected(newMeasurementSelected);\r\n        setActiveImageDisplaySetData(referencedDisplaySet);\r\n        setReferencedDisplaySetMetadata(referencedDisplaySetMetadata);\r\n\r\n        if (\r\n          referencedDisplaySet.displaySetInstanceUID ===\r\n          activeImageDisplaySetData?.displaySetInstanceUID\r\n        ) {\r\n          const { measurements } = srDisplaySet;\r\n\r\n          // it means that we have a new referenced display set, and the\r\n          // imageIdIndex will handle it by updating the viewport, but if they\r\n          // are the same we just need to use measurementService to jump to the\r\n          // new measurement\r\n          const csViewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\r\n\r\n          const imageIds = csViewport.getImageIds();\r\n\r\n          const imageIdIndex = imageIds.indexOf(measurements[newMeasurementSelected].imageId);\r\n\r\n          if (imageIdIndex !== -1) {\r\n            csViewport.setImageIdIndex(imageIdIndex);\r\n          }\r\n        }\r\n      });\r\n    },\r\n    [dataSource, srDisplaySet, activeImageDisplaySetData, viewportId]\r\n  );\r\n\r\n  const getCornerstoneViewport = useCallback(() => {\r\n    if (!activeImageDisplaySetData) {\r\n      return null;\r\n    }\r\n\r\n    const { component: Component } = extensionManager.getModuleEntry(\r\n      '@ohif/extension-cornerstone.viewportModule.cornerstone'\r\n    );\r\n\r\n    const { measurements } = srDisplaySet;\r\n    const measurement = measurements[measurementSelected];\r\n\r\n    if (!measurement) {\r\n      return null;\r\n    }\r\n\r\n    const initialImageIndex = activeImageDisplaySetData.images.findIndex(\r\n      image => image.imageId === measurement.imageId\r\n    );\r\n\r\n    return (\r\n      <Component\r\n        {...props}\r\n        // should be passed second since we don't want SR displaySet to\r\n        // override the activeImageDisplaySetData\r\n        displaySets={[activeImageDisplaySetData]}\r\n        // It is possible that there is a hanging protocol applying viewportOptions\r\n        // for the SR, so inherit the viewport options\r\n        // TODO: Ensure the viewport options are set correctly with respect to\r\n        // stack etc, in the incoming viewport options.\r\n        viewportOptions={{\r\n          ...viewportOptions,\r\n          toolGroupId: `${SR_TOOLGROUP_BASE_NAME}`,\r\n          // viewportType should not be required, as the stack type should be\r\n          // required already in order to view SR, but sometimes segmentation\r\n          // views set the viewport type without fixing the allowed display\r\n          viewportType: 'stack',\r\n          // The positionIds for the viewport aren't meaningful for the child display sets\r\n          positionIds: null,\r\n        }}\r\n        onElementEnabled={evt => {\r\n          props.onElementEnabled?.(evt);\r\n          onElementEnabled(evt);\r\n        }}\r\n        initialImageIndex={initialImageIndex}\r\n        isJumpToMeasurementDisabled={true}\r\n      ></Component>\r\n    );\r\n  }, [activeImageDisplaySetData, viewportId, measurementSelected]);\r\n\r\n  const onMeasurementChange = useCallback(\r\n    direction => {\r\n      let newMeasurementSelected = measurementSelected;\r\n\r\n      newMeasurementSelected += direction;\r\n      if (newMeasurementSelected >= measurementCount) {\r\n        newMeasurementSelected = 0;\r\n      } else if (newMeasurementSelected < 0) {\r\n        newMeasurementSelected = measurementCount - 1;\r\n      }\r\n\r\n      setTrackingIdentifiers(newMeasurementSelected);\r\n      updateViewport(newMeasurementSelected);\r\n    },\r\n    [measurementSelected, measurementCount, updateViewport, setTrackingIdentifiers]\r\n  );\r\n\r\n  /**\r\n   Cleanup the SR viewport when the viewport is destroyed\r\n   */\r\n  useEffect(() => {\r\n    const onDisplaySetsRemovedSubscription = displaySetService.subscribe(\r\n      displaySetService.EVENTS.DISPLAY_SETS_REMOVED,\r\n      ({ displaySetInstanceUIDs }) => {\r\n        const activeViewport = viewports.get(activeViewportId);\r\n        if (displaySetInstanceUIDs.includes(activeViewport.displaySetInstanceUID)) {\r\n          viewportGridService.setDisplaySetsForViewport({\r\n            viewportId: activeViewportId,\r\n            displaySetInstanceUIDs: [],\r\n          });\r\n        }\r\n      }\r\n    );\r\n\r\n    return () => {\r\n      onDisplaySetsRemovedSubscription.unsubscribe();\r\n    };\r\n  }, []);\r\n\r\n  /**\r\n   * Loading the measurements from the SR viewport, which goes through the\r\n   * isHydratable check, the outcome for the isHydrated state here is always FALSE\r\n   * since we don't do the hydration here. Todo: can't we just set it as false? why\r\n   * we are changing the state here? isHydrated is always false at this stage, and\r\n   * if it is hydrated we don't even use the SR viewport.\r\n   */\r\n  useEffect(() => {\r\n    const loadSR = async () => {\r\n      if (!srDisplaySet.isLoaded) {\r\n        await srDisplaySet.load();\r\n      }\r\n      const numMeasurements = srDisplaySet.measurements.length;\r\n      setMeasurementCount(numMeasurements);\r\n      updateViewport(measurementSelected);\r\n    };\r\n    loadSR();\r\n  }, [srDisplaySet]);\r\n\r\n  /**\r\n   * Hook to update the tracking identifiers when the selected measurement changes or\r\n   * the element changes\r\n   */\r\n  useEffect(() => {\r\n    const updateSR = async () => {\r\n    if (!srDisplaySet.isLoaded) {\r\n      await srDisplaySet.load();\r\n    }\r\n    if (!element || !srDisplaySet.isLoaded) {\r\n      return;\r\n    }\r\n    setTrackingIdentifiers(measurementSelected);\r\n    }\r\n    updateSR();\r\n  }, [measurementSelected, element, setTrackingIdentifiers, srDisplaySet]);\r\n\r\n  /**\r\n   * Todo: what is this, not sure what it does regarding the react aspect,\r\n   * it is updating a local variable? which is not state.\r\n   */\r\n  const [isLocked, setIsLocked] = useState(trackedMeasurements?.context?.trackedSeries?.length > 0);\r\n  useEffect(() => {\r\n    setIsLocked(trackedMeasurements?.context?.trackedSeries?.length > 0);\r\n  }, [trackedMeasurements]);\r\n\r\n  useEffect(() => {\r\n    viewportActionCornersService.setComponents([\r\n      {\r\n        viewportId,\r\n        id: 'viewportStatusComponent',\r\n        component: _getStatusComponent({\r\n          srDisplaySet,\r\n          viewportId,\r\n          isRehydratable: srDisplaySet.isRehydratable,\r\n          isLocked,\r\n          sendTrackedMeasurementsEvent,\r\n          t,\r\n        }),\r\n        indexPriority: -100,\r\n        location: viewportActionCornersService.LOCATIONS.topLeft,\r\n      },\r\n      {\r\n        viewportId,\r\n        id: 'viewportActionArrowsComponent',\r\n        index: 0,\r\n        component: (\r\n          <ViewportActionArrows\r\n            key=\"actionArrows\"\r\n            onArrowsClick={onMeasurementChange}\r\n          ></ViewportActionArrows>\r\n        ),\r\n        indexPriority: 0,\r\n        location: viewportActionCornersService.LOCATIONS.topRight,\r\n      },\r\n    ]);\r\n  }, [\r\n    isLocked,\r\n    onMeasurementChange,\r\n    sendTrackedMeasurementsEvent,\r\n    srDisplaySet,\r\n    t,\r\n    viewportActionCornersService,\r\n    viewportId,\r\n  ]);\r\n\r\n  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n  let childrenWithProps = null;\r\n\r\n  if (!activeImageDisplaySetData || !referencedDisplaySetMetadata) {\r\n    return null;\r\n  }\r\n\r\n  if (children && children.length) {\r\n    childrenWithProps = children.map((child, index) => {\r\n      return (\r\n        child &&\r\n        React.cloneElement(child, {\r\n          viewportId,\r\n          key: index,\r\n        })\r\n      );\r\n    });\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <div className=\"relative flex h-full w-full flex-row overflow-hidden\">\r\n        {getCornerstoneViewport()}\r\n        {childrenWithProps}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\nOHIFCornerstoneSRViewport.propTypes = {\r\n  displaySets: PropTypes.arrayOf(PropTypes.object),\r\n  viewportId: PropTypes.string.isRequired,\r\n  dataSource: PropTypes.object,\r\n  children: PropTypes.node,\r\n  viewportLabel: PropTypes.string,\r\n  viewportOptions: PropTypes.object,\r\n  servicesManager: PropTypes.object.isRequired,\r\n  extensionManager: PropTypes.instanceOf(ExtensionManager).isRequired,\r\n};\r\n\r\nasync function _getViewportReferencedDisplaySetData(\r\n  displaySet,\r\n  measurementSelected,\r\n  displaySetService\r\n) {\r\n  const { measurements } = displaySet;\r\n  const measurement = measurements[measurementSelected];\r\n\r\n  const { displaySetInstanceUID } = measurement;\r\n  if (!displaySet.keyImageDisplaySet) {\r\n    // Create a new display set, and preserve a reference to it here,\r\n    // so that it can be re-displayed and shown inside the SR viewport.\r\n    // This is only for ease of redisplay - the display set is stored in the\r\n    // usual manner in the display set service.\r\n    displaySet.keyImageDisplaySet = createReferencedImageDisplaySet(displaySetService, displaySet);\r\n  }\r\n\r\n  const referencedDisplaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\r\n\r\n  const image0 = referencedDisplaySet.images[0];\r\n  const referencedDisplaySetMetadata = {\r\n    PatientID: image0.PatientID,\r\n    PatientName: image0.PatientName,\r\n    PatientSex: image0.PatientSex,\r\n    PatientAge: image0.PatientAge,\r\n    SliceThickness: image0.SliceThickness,\r\n    StudyDate: image0.StudyDate,\r\n    SeriesDescription: image0.SeriesDescription,\r\n    SeriesInstanceUID: image0.SeriesInstanceUID,\r\n    SeriesNumber: image0.SeriesNumber,\r\n    ManufacturerModelName: image0.ManufacturerModelName,\r\n    SpacingBetweenSlices: image0.SpacingBetweenSlices,\r\n  };\r\n\r\n  return { referencedDisplaySetMetadata, referencedDisplaySet };\r\n}\r\n\r\nfunction _getStatusComponent({\r\n  srDisplaySet,\r\n  viewportId,\r\n  isRehydratable,\r\n  isLocked,\r\n  sendTrackedMeasurementsEvent,\r\n  t,\r\n}) {\r\n  const handleMouseUp = () => {\r\n    sendTrackedMeasurementsEvent('HYDRATE_SR', {\r\n      displaySetInstanceUID: srDisplaySet.displaySetInstanceUID,\r\n      viewportId,\r\n    });\r\n  };\r\n\r\n  const loadStr = t('LOAD');\r\n\r\n  // 1 - Incompatible\r\n  // 2 - Locked\r\n  // 3 - Rehydratable / Open\r\n  const state = isRehydratable && !isLocked ? 3 : isRehydratable && isLocked ? 2 : 1;\r\n  let ToolTipMessage = null;\r\n  let StatusIcon = null;\r\n\r\n  switch (state) {\r\n    case 1:\r\n      StatusIcon = () => <Icon name=\"status-alert\" />;\r\n\r\n      ToolTipMessage = () => (\r\n        <div>\r\n          This structured report is not compatible\r\n          <br />\r\n          with this application.\r\n        </div>\r\n      );\r\n      break;\r\n    case 2:\r\n      StatusIcon = () => <Icon name=\"status-locked\" />;\r\n\r\n      ToolTipMessage = () => (\r\n        <div>\r\n          This structured report is currently read-only\r\n          <br />\r\n          because you are tracking measurements in\r\n          <br />\r\n          another viewport.\r\n        </div>\r\n      );\r\n      break;\r\n    case 3:\r\n      StatusIcon = () => (\r\n        <Icon\r\n          className=\"text-aqua-pale\"\r\n          name=\"status-untracked\"\r\n        />\r\n      );\r\n\r\n      ToolTipMessage = () => <div>{`Click ${loadStr} to restore measurements.`}</div>;\r\n  }\r\n\r\n  const StatusArea = () => (\r\n    <div className=\"flex h-6 cursor-default text-sm leading-6 text-white\">\r\n      <div className=\"bg-customgray-100 flex min-w-[45px] items-center rounded-l-xl rounded-r p-1\">\r\n        <StatusIcon />\r\n        <span className=\"ml-1\">SR</span>\r\n      </div>\r\n      {state === 3 && (\r\n        <div\r\n          className=\"bg-primary-main hover:bg-primary-light ml-1 cursor-pointer rounded px-1.5 hover:text-black\"\r\n          // Using onMouseUp here because onClick is not working when the viewport is not active and is styled with pointer-events:none\r\n          onMouseUp={handleMouseUp}\r\n        >\r\n          {loadStr}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n\r\n  return (\r\n    <>\r\n      {ToolTipMessage && (\r\n        <Tooltip\r\n          content={<ToolTipMessage />}\r\n          position=\"bottom-left\"\r\n        >\r\n          <StatusArea />\r\n        </Tooltip>\r\n      )}\r\n      {!ToolTipMessage && <StatusArea />}\r\n    </>\r\n  );\r\n}\r\n\r\nexport default OHIFCornerstoneSRViewport;\r\n"],"names":["OHIFCornerstoneSRViewport","props","children","dataSource","displaySets","viewportOptions","servicesManager","extensionManager","appConfig","useAppConfig","displaySetService","cornerstoneViewportService","measurementService","viewportActionCornersService","services","viewportId","length","Error","srDisplaySet","viewportGrid","viewportGridService","useViewportGrid","measurementSelected","setMeasurementSelected","useState","measurementCount","setMeasurementCount","activeImageDisplaySetData","setActiveImageDisplaySetData","referencedDisplaySetMetadata","setReferencedDisplaySetMetadata","element","setElement","viewports","activeViewportId","t","useTranslation","trackedMeasurements","sendTrackedMeasurementsEvent","registeredExtensionIds","includes","contextModule","getModuleEntry","tracked","useContext","context","eventName","displaySetInstanceUID","clearMeasurements","SeriesInstanceUIDs","hydrateStructuredReport","getDisplaySetsForSeries","setDisplaySetsForViewports","displaySetInstanceUIDs","setTrackingIdentifiers","useCallback","measurements","setTrackingUniqueIdentifiersForElement","map","measurement","TrackingUniqueIdentifier","updateViewport","newMeasurementSelected","StudyInstanceUID","sopClassUids","console","warn","async","displaySet","keyImageDisplaySet","createReferencedImageDisplaySet","referencedDisplaySet","getDisplaySetByUID","image0","images","PatientID","PatientName","PatientSex","PatientAge","SliceThickness","StudyDate","SeriesDescription","SeriesInstanceUID","SeriesNumber","ManufacturerModelName","SpacingBetweenSlices","_getViewportReferencedDisplaySetData","then","csViewport","getCornerstoneViewport","imageIdIndex","getImageIds","indexOf","imageId","setImageIdIndex","component","Component","initialImageIndex","findIndex","image","React","_extends","toolGroupId","viewportType","positionIds","onElementEnabled","evt","detail","isJumpToMeasurementDisabled","onMeasurementChange","direction","useEffect","onDisplaySetsRemovedSubscription","subscribe","EVENTS","DISPLAY_SETS_REMOVED","activeViewport","get","setDisplaySetsForViewport","unsubscribe","isLoaded","load","numMeasurements","loadSR","updateSR","isLocked","setIsLocked","trackedSeries","setComponents","id","_getStatusComponent","isRehydratable","indexPriority","location","LOCATIONS","topLeft","index","ViewportActionArrows","key","onArrowsClick","topRight","childrenWithProps","child","className","handleMouseUp","loadStr","state","ToolTipMessage","StatusIcon","Icon","name","StatusArea","onMouseUp","Tooltip","content","position","propTypes","PropTypes","isRequired","viewportLabel","ExtensionManager"],"sourceRoot":""}