{"version":3,"file":"497.bundle.9cf4761de44eb5254393.js","mappings":"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","sources":["webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/getSvgDrawingHelper.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/draw.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/ToolModes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/ToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/createToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/destroy.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/destroyToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/getAllToolGroups.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/getToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/getToolGroupsWithToolName.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/PlanarFreehandROITool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/displayTools/SegmentationDisplayTool.ts","webpack:///../../../node_modules/lodash.get/index.js"],"sourcesContent":["import { state } from '../store';\r\nimport { getEnabledElement } from '@cornerstonejs/core';\r\nimport { SVGDrawingHelper } from '../types';\r\n\r\nconst VIEWPORT_ELEMENT = 'viewport-element';\r\n\r\n/**\r\n * Returns the SVG drawing helper for the given HTML element.\r\n * @param element - The HTML element to get the SVG drawing helper for.\r\n * @private\r\n */\r\nfunction getSvgDrawingHelper(element: HTMLDivElement): SVGDrawingHelper {\r\n  const enabledElement = getEnabledElement(element);\r\n  const { viewportId, renderingEngineId } = enabledElement;\r\n  const canvasHash = `${viewportId}:${renderingEngineId}`;\r\n  const svgLayerElement = _getSvgLayer(element);\r\n\r\n  // Reset touched\r\n  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\r\n    state.svgNodeCache[canvasHash][cacheKey].touched = false;\r\n  });\r\n\r\n  return {\r\n    svgLayerElement: svgLayerElement,\r\n    svgNodeCacheForCanvas: state.svgNodeCache,\r\n    getSvgNode: getSvgNode.bind(this, canvasHash),\r\n    appendNode: appendNode.bind(this, svgLayerElement, canvasHash),\r\n    setNodeTouched: setNodeTouched.bind(this, canvasHash),\r\n    clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash),\r\n  };\r\n}\r\n\r\n/**\r\n *\r\n * @param element\r\n * @private\r\n */\r\nfunction _getSvgLayer(element) {\r\n  const viewportElement = `.${VIEWPORT_ELEMENT}`;\r\n  const internalDivElement = element.querySelector(viewportElement);\r\n\r\n  // Using :scope to make sure the right svg layer is selected otherwise it\r\n  // may select one from a nested viewport (eg: AdvancedMagnifyTool).\r\n  const svgLayer = internalDivElement.querySelector(':scope > .svg-layer');\r\n\r\n  return svgLayer;\r\n}\r\n\r\nfunction getSvgNode(canvasHash, cacheKey) {\r\n  // If state has been reset\r\n  if (!state.svgNodeCache[canvasHash]) {\r\n    return;\r\n  }\r\n\r\n  if (state.svgNodeCache[canvasHash][cacheKey]) {\r\n    return state.svgNodeCache[canvasHash][cacheKey].domRef;\r\n  }\r\n}\r\n\r\nfunction appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {\r\n  // If state has been reset\r\n  if (!state.svgNodeCache[canvasHash]) {\r\n    return null;\r\n  }\r\n\r\n  state.svgNodeCache[canvasHash][cacheKey] = {\r\n    touched: true,\r\n    domRef: svgNode,\r\n  };\r\n\r\n  svgLayerElement.appendChild(svgNode);\r\n}\r\n\r\nfunction setNodeTouched(canvasHash, cacheKey) {\r\n  // If state has been reset\r\n  if (!state.svgNodeCache[canvasHash]) {\r\n    return;\r\n  }\r\n\r\n  if (state.svgNodeCache[canvasHash][cacheKey]) {\r\n    state.svgNodeCache[canvasHash][cacheKey].touched = true;\r\n  }\r\n}\r\n\r\nfunction clearUntouched(svgLayerElement, canvasHash) {\r\n  // If state has been reset\r\n  if (!state.svgNodeCache[canvasHash]) {\r\n    return;\r\n  }\r\n\r\n  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\r\n    const cacheEntry = state.svgNodeCache[canvasHash][cacheKey];\r\n\r\n    if (!cacheEntry.touched && cacheEntry.domRef) {\r\n      svgLayerElement.removeChild(cacheEntry.domRef);\r\n      delete state.svgNodeCache[canvasHash][cacheKey];\r\n    }\r\n  });\r\n}\r\n\r\nexport default getSvgDrawingHelper;\r\n","import getSvgDrawingHelper from './getSvgDrawingHelper';\r\n\r\nfunction draw(\r\n  element: HTMLDivElement,\r\n  fn: (svgDrawingElement: any) => any\r\n): void {\r\n  const svgDrawingHelper = getSvgDrawingHelper(element);\r\n\r\n  // Save...\r\n  fn(svgDrawingHelper);\r\n  // Restore...\r\n\r\n  svgDrawingHelper.clearUntouched();\r\n}\r\n\r\nexport default draw;\r\n","/**\r\n * ToolModes - This enum defines the 4 tool states which are available.\r\n */\r\nenum ToolModes {\r\n  /**\r\n   * Active:\r\n   * - Can be actively used by mouse/touch events mapped to its `ToolBinding`s.\r\n   * - Can add data if an annotation tool.\r\n   * - Can be passively interacted by grabbing a tool or its handles.\r\n   * - Renders data if the tool has a `renderAnnotation` method.\r\n   */\r\n  Active = 'Active',\r\n  /**\r\n   * Passive:\r\n   * - Can be passively interacted by grabbing a tool or its handles.\r\n   * - Renders data if the tool has a `renderAnnotation` method.\r\n   */\r\n  Passive = 'Passive',\r\n  /**\r\n   * Enabled:\r\n   * - Renders data if the tool has a `renderAnnotation` method.\r\n   */\r\n  Enabled = 'Enabled',\r\n  /**\r\n   * Disabled:\r\n   * - Annotation does not render.\r\n   */\r\n  Disabled = 'Disabled',\r\n}\r\n\r\nexport default ToolModes;\r\n","import { MouseBindings, ToolModes } from '../../enums';\r\nimport get from 'lodash.get';\r\nimport cloneDeep from 'lodash.clonedeep';\r\nimport {\r\n  triggerEvent,\r\n  eventTarget,\r\n  getRenderingEngine,\r\n  getRenderingEngines,\r\n  getEnabledElementByIds,\r\n  Settings,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport { Events } from '../../enums';\r\nimport {\r\n  ToolActivatedEventDetail,\r\n  ToolModeChangedEventDetail,\r\n} from '../../types/EventTypes';\r\nimport { ToolGroupManager, state } from '../index';\r\nimport {\r\n  IToolBinding,\r\n  IToolClassReference,\r\n  IToolGroup,\r\n  SetToolBindingsType,\r\n  ToolOptionsType,\r\n  ToolConfiguration,\r\n} from '../../types';\r\n\r\nimport { MouseCursor, SVGMouseCursor } from '../../cursors';\r\nimport { initElementCursor } from '../../cursors/elementCursor';\r\n\r\nconst { Active, Passive, Enabled, Disabled } = ToolModes;\r\n\r\nconst PRIMARY_BINDINGS = [{ mouseButton: MouseBindings.Primary }];\r\n\r\n/**\r\n * ToolGroup class which is a container for tools and their modes and states.\r\n * In Cornerstone3DTools, you need to create a tool group in order to use the\r\n * tools. ToolGroup is a way to share tool configuration, state (enabled, disabled, etc.)\r\n * across a set of viewports. Tools can set to be activated, enabled or disabled\r\n * in a toolGroup. You should not directly instantiate a ToolGroup. You need to use\r\n * ToolGroupManager helpers to create a new toolGroup or get a reference to an existing toolGroup.\r\n *\r\n * ```js\r\n * const toolGroup = csTools.ToolGroupManager.createToolGroup('toolGroupId')\r\n * ```\r\n */\r\nexport default class ToolGroup implements IToolGroup {\r\n  id: string;\r\n  viewportsInfo = [];\r\n  toolOptions = {};\r\n  currentActivePrimaryToolName: string | null = null;\r\n  prevActivePrimaryToolName: string | null = null;\r\n  /**\r\n   * Options used for restoring a tool\r\n   */\r\n  restoreToolOptions = {};\r\n  _toolInstances = {};\r\n\r\n  constructor(id: string) {\r\n    this.id = id;\r\n  }\r\n\r\n  /**\r\n   * Get the viewport IDs of all the viewports in the current viewport\r\n   * @returns An array of viewport IDs.\r\n   */\r\n  getViewportIds(): string[] {\r\n    return this.viewportsInfo.map(({ viewportId }) => viewportId);\r\n  }\r\n\r\n  /**\r\n   * Returns the toolGroup viewports info which is an array of {viewportId, renderingEngineId}\r\n   */\r\n  getViewportsInfo(): Array<Types.IViewportId> {\r\n    return this.viewportsInfo.slice();\r\n  }\r\n\r\n  /**\r\n   * Get the tool instance for a given tool name in the toolGroup\r\n   * @param toolName - The name of the tool.\r\n   * @returns A tool instance.\r\n   */\r\n  public getToolInstance(toolInstanceName: string) {\r\n    const toolInstance = this._toolInstances[toolInstanceName];\r\n    if (!toolInstance) {\r\n      console.warn(\r\n        `'${toolInstanceName}' is not registered with this toolGroup (${this.id}).`\r\n      );\r\n      return;\r\n    }\r\n\r\n    return toolInstance;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the tool instances associated with this tool group.\r\n   *\r\n   * @returns A record containing the tool instances, where the keys are the tool names and the values are the tool instances.\r\n   */\r\n  public getToolInstances(): Record<string, any> {\r\n    return this._toolInstances;\r\n  }\r\n\r\n  /**\r\n   * Check if a tool is already added to the tool group\r\n   * @param toolName - Tool name\r\n   * @returns True if the tool is already added or false otherwise\r\n   */\r\n  hasTool(toolName: string): boolean {\r\n    return !!this._toolInstances[toolName];\r\n  }\r\n\r\n  /**\r\n   * Add a tool to the tool group with the given tool name and tool configuration.\r\n   * Note that adding a tool to a tool group will not automatically set the tool\r\n   * to be active. You must call setToolActive or setToolPassive and other methods\r\n   * to set the tool to be active or passive or in other states.\r\n   *\r\n   * @param toolName - string\r\n   * @param configuration - Tool configuration objects and a custom statistics calculator if needed\r\n   */\r\n  addTool(toolName: string, configuration: ToolConfiguration = {}): void {\r\n    const toolDefinition = state.tools[toolName];\r\n    const hasToolName = typeof toolName !== 'undefined' && toolName !== '';\r\n    const localToolInstance = this.toolOptions[toolName];\r\n\r\n    if (!hasToolName) {\r\n      console.warn(\r\n        'Tool with configuration did not produce a toolName: ',\r\n        configuration\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (!toolDefinition) {\r\n      console.warn(\r\n        `'${toolName}' is not registered with the library. You need to use cornerstoneTools.addTool to register it.`\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (localToolInstance) {\r\n      console.warn(\r\n        `'${toolName}' is already registered for ToolGroup ${this.id}.`\r\n      );\r\n      return;\r\n    }\r\n\r\n    // Should these be renamed higher up, so we don't have to alias?\r\n    // Wrap in try-catch so 3rd party tools don't explode?\r\n    const { toolClass: ToolClass } = toolDefinition;\r\n\r\n    const toolProps = {\r\n      name: toolName,\r\n      toolGroupId: this.id,\r\n      configuration,\r\n    };\r\n\r\n    const instantiatedTool = new ToolClass(toolProps);\r\n\r\n    // API instead of directly exposing schema?\r\n    // Maybe not here, but feels like a \"must\" for any method outside of the ToolGroup itself\r\n    this._toolInstances[toolName] = instantiatedTool;\r\n  }\r\n\r\n  public addToolInstance(\r\n    toolName: string,\r\n    parentClassName: string,\r\n    configuration = {}\r\n  ): void {\r\n    let ToolClassToUse = state.tools[toolName]\r\n      ?.toolClass as IToolClassReference;\r\n\r\n    if (!ToolClassToUse) {\r\n      // get parent class constructor\r\n      const ParentClass = state.tools[parentClassName]\r\n        .toolClass as IToolClassReference;\r\n\r\n      // Todo: could not find a way to make this work with typescript\r\n      // @ts-ignore\r\n      class ToolInstance extends ParentClass {}\r\n      // @ts-ignore\r\n      ToolInstance.toolName = toolName;\r\n      // @ts-ignore\r\n      ToolClassToUse = ToolInstance;\r\n\r\n      state.tools[toolName] = {\r\n        toolClass: ToolInstance as IToolClassReference,\r\n      };\r\n    }\r\n\r\n    // add the tool to the toolGroup\r\n    // @ts-ignore\r\n    this.addTool(ToolClassToUse.toolName, configuration);\r\n  }\r\n\r\n  //   class InstanceTool extends parentClass;\r\n  // InstanceTool.constructor.toolName = name;\r\n  // addTool(InstanceTool,configuration)\r\n  /**\r\n   * Add a viewport to the ToolGroup. It accepts viewportId and optional\r\n   * renderingEngineId parameter. If renderingEngineId is not provided,\r\n   * it checks if cornerstone-core has more than one renderingEngine; If so,\r\n   * it will throw an error. If cornerstone-core has only one renderingEngine,\r\n   * it will use that renderingEngine.\r\n   *\r\n   * @param viewportId - The unique identifier for the viewport.\r\n   * @param renderingEngineId - The rendering engine to use.\r\n   */\r\n  public addViewport(viewportId: string, renderingEngineId?: string): void {\r\n    if (typeof viewportId !== 'string') {\r\n      throw new Error('viewportId must be defined and be a string');\r\n    }\r\n\r\n    const renderingEngines = getRenderingEngines();\r\n\r\n    if (!renderingEngineId && renderingEngines.length > 1) {\r\n      throw new Error(\r\n        'You must specify a renderingEngineId when there are multiple rendering engines.'\r\n      );\r\n    }\r\n\r\n    const renderingEngineUIDToUse = renderingEngineId || renderingEngines[0].id;\r\n\r\n    // Don't overwrite if it already exists\r\n    if (\r\n      !this.viewportsInfo.some(({ viewportId: vpId }) => vpId === viewportId)\r\n    ) {\r\n      this.viewportsInfo.push({\r\n        viewportId,\r\n        renderingEngineId: renderingEngineUIDToUse,\r\n      });\r\n    }\r\n\r\n    // Handle the newly added viewport's mouse cursor\r\n    const toolName = this.getActivePrimaryMouseButtonTool();\r\n\r\n    const runtimeSettings = Settings.getRuntimeSettings();\r\n    if (runtimeSettings.get('useCursors')) {\r\n      this.setViewportsCursorByToolName(toolName);\r\n    }\r\n\r\n    const eventDetail = {\r\n      toolGroupId: this.id,\r\n      viewportId,\r\n      renderingEngineId: renderingEngineUIDToUse,\r\n    };\r\n\r\n    triggerEvent(eventTarget, Events.TOOLGROUP_VIEWPORT_ADDED, eventDetail);\r\n  }\r\n\r\n  /**\r\n   * Removes viewport from the toolGroup. If only renderingEngineId is defined\r\n   * it removes all the viewports with the same renderingEngineId, if viewportId\r\n   * is also provided, it will remove that specific viewport from the ToolGroup.\r\n   *\r\n   * @param renderingEngineId - renderingEngine id\r\n   * @param viewportId - viewport id\r\n   */\r\n  public removeViewports(renderingEngineId: string, viewportId?: string): void {\r\n    const indices = [];\r\n\r\n    this.viewportsInfo.forEach((vpInfo, index) => {\r\n      let match = false;\r\n      if (vpInfo.renderingEngineId === renderingEngineId) {\r\n        match = true;\r\n\r\n        if (viewportId && vpInfo.viewportId !== viewportId) {\r\n          match = false;\r\n        }\r\n      }\r\n      if (match) {\r\n        indices.push(index);\r\n      }\r\n    });\r\n\r\n    if (indices.length) {\r\n      // Note: Traverse the array backwards, such that when we remove items we\r\n      // do not immediately mess up our loop indicies.\r\n      for (let i = indices.length - 1; i >= 0; i--) {\r\n        this.viewportsInfo.splice(indices[i], 1);\r\n      }\r\n    }\r\n\r\n    const eventDetail = {\r\n      toolGroupId: this.id,\r\n      viewportId,\r\n      renderingEngineId,\r\n    };\r\n\r\n    triggerEvent(eventTarget, Events.TOOLGROUP_VIEWPORT_REMOVED, eventDetail);\r\n  }\r\n\r\n  public setActiveStrategy(toolName: string, strategyName: string) {\r\n    const toolInstance = this._toolInstances[toolName];\r\n\r\n    if (toolInstance === undefined) {\r\n      console.warn(\r\n        `Tool ${toolName} not added to toolGroup, can't set tool configuration.`\r\n      );\r\n\r\n      return;\r\n    }\r\n\r\n    toolInstance.setActiveStrategy(strategyName);\r\n  }\r\n\r\n  setToolMode(\r\n    toolName: string,\r\n    mode: ToolModes,\r\n    options = {} as SetToolBindingsType\r\n  ): void {\r\n    if (!toolName) {\r\n      console.warn('setToolMode: toolName must be defined');\r\n      return;\r\n    }\r\n\r\n    if (mode === ToolModes.Active) {\r\n      this.setToolActive(\r\n        toolName,\r\n        options || this.restoreToolOptions[toolName]\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (mode === ToolModes.Passive) {\r\n      this.setToolPassive(toolName);\r\n      return;\r\n    }\r\n\r\n    if (mode === ToolModes.Enabled) {\r\n      this.setToolEnabled(toolName);\r\n      return;\r\n    }\r\n\r\n    if (mode === ToolModes.Disabled) {\r\n      this.setToolDisabled(toolName);\r\n      return;\r\n    }\r\n\r\n    console.warn('setToolMode: mode must be defined');\r\n  }\r\n\r\n  /**\r\n   * Set the tool mode on the toolGroup to be Active. This means the tool\r\n   * can be actively used by the defined bindings (e.g., Mouse primary click)\r\n   *\r\n   * - Can be actively used by mouse/touch events mapped to its `ToolBinding`s.\r\n   * - Can add data if an annotation tool.\r\n   * - Can be passively interacted by grabbing a tool or its handles.\r\n   * - Renders data if the tool has a `renderAnnotation` method.\r\n   *\r\n   * @param toolName - tool name\r\n   * @param toolBindingsOptions - tool bindings\r\n   */\r\n  public setToolActive(\r\n    toolName: string,\r\n    toolBindingsOptions = {} as SetToolBindingsType\r\n  ): void {\r\n    const toolInstance = this._toolInstances[toolName];\r\n\r\n    if (toolInstance === undefined) {\r\n      console.warn(\r\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\r\n      );\r\n\r\n      return;\r\n    }\r\n\r\n    if (!toolInstance) {\r\n      console.warn(\r\n        `'${toolName}' instance ${toolInstance} is not registered with this toolGroup, can't set tool mode.`\r\n      );\r\n      return;\r\n    }\r\n\r\n    const prevBindings: IToolBinding[] = this.toolOptions[toolName]\r\n      ? this.toolOptions[toolName].bindings\r\n      : [];\r\n\r\n    const newBindings = toolBindingsOptions.bindings\r\n      ? toolBindingsOptions.bindings\r\n      : [];\r\n\r\n    // combine the new bindings with the previous bindings to avoid duplicates\r\n    // it allows duplicated mouse buttons as long as they don't have same\r\n    // modifier keys.\r\n    const bindingsToUse = [...prevBindings, ...newBindings].reduce(\r\n      (unique, binding) => {\r\n        const TouchBinding = binding.numTouchPoints !== undefined;\r\n        const MouseBinding = binding.mouseButton !== undefined;\r\n\r\n        if (\r\n          !unique.some((obj) => hasSameBinding(obj, binding)) &&\r\n          (TouchBinding || MouseBinding)\r\n        ) {\r\n          unique.push(binding);\r\n        }\r\n        return unique;\r\n      },\r\n      []\r\n    );\r\n\r\n    // We should not override the bindings if they are already set\r\n    const toolOptions: ToolOptionsType = {\r\n      bindings: bindingsToUse,\r\n      mode: Active,\r\n    };\r\n\r\n    this.toolOptions[toolName] = toolOptions;\r\n    this._toolInstances[toolName].mode = Active;\r\n\r\n    // reset the mouse cursor if tool has left click binding\r\n    const runtimeSettings = Settings.getRuntimeSettings();\r\n    const useCursor = runtimeSettings.get('useCursors');\r\n\r\n    if (this._hasMousePrimaryButtonBinding(toolBindingsOptions) && useCursor) {\r\n      this.setViewportsCursorByToolName(toolName);\r\n    } else {\r\n      // reset to default cursor only if there is no other tool with primary binding\r\n      const activeToolIdentifier = this.getActivePrimaryMouseButtonTool();\r\n      if (!activeToolIdentifier && useCursor) {\r\n        const cursor = MouseCursor.getDefinedCursor('default');\r\n        this._setCursorForViewports(cursor);\r\n      }\r\n    }\r\n\r\n    // if it is a primary tool binding, we should store it as the previous primary tool\r\n    // so that we can restore it when the tool is disabled if desired\r\n    if (this._hasMousePrimaryButtonBinding(toolBindingsOptions)) {\r\n      if (this.prevActivePrimaryToolName === null) {\r\n        this.prevActivePrimaryToolName = toolName;\r\n      } else {\r\n        this.prevActivePrimaryToolName = this.currentActivePrimaryToolName;\r\n      }\r\n\r\n      this.currentActivePrimaryToolName = toolName;\r\n    }\r\n\r\n    if (typeof toolInstance.onSetToolActive === 'function') {\r\n      toolInstance.onSetToolActive();\r\n    }\r\n    this._renderViewports();\r\n\r\n    const eventDetail: ToolActivatedEventDetail = {\r\n      toolGroupId: this.id,\r\n      toolName,\r\n      toolBindingsOptions,\r\n    };\r\n\r\n    triggerEvent(eventTarget, Events.TOOL_ACTIVATED, eventDetail);\r\n    this._triggerToolModeChangedEvent(toolName, Active, toolBindingsOptions);\r\n  }\r\n\r\n  /**\r\n   * Set the tool mode on the toolGroup to be Passive.\r\n   *\r\n   * - Can be passively interacted by grabbing a tool or its handles.\r\n   * - Renders data if the tool has a `renderAnnotation` method.\r\n   *\r\n   * @param toolName - tool name\r\n   * @param options - Options used when setting the tool as passive\r\n   *  - removeAllBindings: only the primary button bindings are removed but\r\n   *  if this parameter is set to true all bindings are removed.\r\n   */\r\n  public setToolPassive(\r\n    toolName: string,\r\n    options?: { removeAllBindings?: boolean | IToolBinding[] }\r\n  ): void {\r\n    const toolInstance = this._toolInstances[toolName];\r\n\r\n    if (toolInstance === undefined) {\r\n      console.warn(\r\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\r\n      );\r\n\r\n      return;\r\n    }\r\n\r\n    // We should only remove the primary button bindings and keep\r\n    // the other ones (Zoom on right click)\r\n    const prevToolOptions = this.getToolOptions(toolName);\r\n    const toolOptions = Object.assign(\r\n      {\r\n        bindings: prevToolOptions ? prevToolOptions.bindings : [],\r\n      },\r\n      prevToolOptions,\r\n      {\r\n        mode: Passive,\r\n      }\r\n    );\r\n\r\n    const matchBindings = Array.isArray(options?.removeAllBindings)\r\n      ? options.removeAllBindings\r\n      : this.getDefaultPrimaryBindings();\r\n\r\n    // Remove the primary button bindings without modifiers, if they exist\r\n    toolOptions.bindings = toolOptions.bindings.filter(\r\n      (binding) =>\r\n        options?.removeAllBindings !== true &&\r\n        !matchBindings.some((matchBinding) =>\r\n          hasSameBinding(binding, matchBinding)\r\n        )\r\n      //(binding.mouseButton !== defaultMousePrimary || binding.modifierKey)\r\n    );\r\n    // If there are other bindings, set the tool to be active\r\n    let mode = Passive;\r\n    if (toolOptions.bindings.length !== 0) {\r\n      mode = Active;\r\n      toolOptions.mode = mode;\r\n    }\r\n\r\n    this.toolOptions[toolName] = toolOptions;\r\n    toolInstance.mode = mode;\r\n\r\n    if (typeof toolInstance.onSetToolPassive === 'function') {\r\n      toolInstance.onSetToolPassive();\r\n    }\r\n    this._renderViewports();\r\n\r\n    // It would make sense to use `toolInstance.mode` as mode when setting a tool\r\n    // as passive because it can still be actived in the end but `Passive` must\r\n    // be used when synchronizing ToolGroups so that other ToolGroups can take the\r\n    // same action (update tool bindings). Should the event have two different modes\r\n    // to handle this special case?\r\n    this._triggerToolModeChangedEvent(toolName, Passive);\r\n  }\r\n\r\n  /**\r\n   * Set the tool mode on the toolGroup to be Enabled.\r\n   *\r\n   * - Renders data if the tool has a `renderAnnotation` method..\r\n   *\r\n   * @param toolName - tool name\r\n   */\r\n  public setToolEnabled(toolName: string): void {\r\n    const toolInstance = this._toolInstances[toolName];\r\n\r\n    if (toolInstance === undefined) {\r\n      console.warn(\r\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\r\n      );\r\n\r\n      return;\r\n    }\r\n\r\n    const toolOptions = {\r\n      bindings: [],\r\n      mode: Enabled,\r\n    };\r\n\r\n    this.toolOptions[toolName] = toolOptions;\r\n    toolInstance.mode = Enabled;\r\n\r\n    if (typeof toolInstance.onSetToolEnabled === 'function') {\r\n      toolInstance.onSetToolEnabled();\r\n    }\r\n\r\n    this._renderViewports();\r\n    this._triggerToolModeChangedEvent(toolName, Enabled);\r\n  }\r\n\r\n  /**\r\n   * Set the tool mode on the toolGroup to be Disabled.\r\n   *\r\n   * - Annotation does not render.\r\n   *\r\n   * @param toolName - tool name\r\n   */\r\n  public setToolDisabled(toolName: string): void {\r\n    const toolInstance = this._toolInstances[toolName];\r\n\r\n    if (toolInstance === undefined) {\r\n      console.warn(\r\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\r\n      );\r\n\r\n      return;\r\n    }\r\n\r\n    const toolOptions = {\r\n      bindings: [],\r\n      mode: Disabled,\r\n    };\r\n\r\n    this.restoreToolOptions[toolName] = this.toolOptions[toolName];\r\n\r\n    this.toolOptions[toolName] = toolOptions;\r\n    toolInstance.mode = Disabled;\r\n\r\n    if (typeof toolInstance.onSetToolDisabled === 'function') {\r\n      toolInstance.onSetToolDisabled();\r\n    }\r\n    this._renderViewports();\r\n    this._triggerToolModeChangedEvent(toolName, Disabled);\r\n  }\r\n\r\n  /**\r\n   * Get the options for a given tool\r\n   * @param toolName - The name of the tool.\r\n   * @returns the tool options\r\n   */\r\n  public getToolOptions(toolName: string): ToolOptionsType {\r\n    const toolOptionsForTool = this.toolOptions[toolName];\r\n\r\n    if (toolOptionsForTool === undefined) {\r\n      return;\r\n    }\r\n\r\n    return toolOptionsForTool;\r\n  }\r\n\r\n  /**\r\n   * Find the name of the tool that is Active and has a primary button binding\r\n   * (Mouse primary click)\r\n   *\r\n   * @returns The name of the tool\r\n   */\r\n  public getActivePrimaryMouseButtonTool(): string {\r\n    return Object.keys(this.toolOptions).find((toolName) => {\r\n      const toolOptions = this.toolOptions[toolName];\r\n      return (\r\n        toolOptions.mode === Active &&\r\n        this._hasMousePrimaryButtonBinding(toolOptions)\r\n      );\r\n    });\r\n  }\r\n\r\n  public setViewportsCursorByToolName(\r\n    toolName: string,\r\n    strategyName?: string\r\n  ): void {\r\n    const cursor = this._getCursor(toolName, strategyName);\r\n\r\n    this._setCursorForViewports(cursor);\r\n  }\r\n\r\n  private _getCursor(toolName: string, strategyName?: string): MouseCursor {\r\n    let cursorName;\r\n    let cursor;\r\n\r\n    if (strategyName) {\r\n      // Try combinations with strategyName first:\r\n      // Try with toolName and toolInstanceName first.\r\n      cursorName = `${toolName}.${strategyName}`;\r\n\r\n      cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\r\n\r\n      if (cursor) {\r\n        return cursor;\r\n      }\r\n    }\r\n\r\n    // Try with toolName and toolInstanceName first.\r\n    cursorName = `${toolName}`;\r\n\r\n    cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\r\n\r\n    if (cursor) {\r\n      return cursor;\r\n    }\r\n\r\n    // Try with just toolName.\r\n    cursorName = toolName;\r\n\r\n    cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\r\n\r\n    if (cursor) {\r\n      return cursor;\r\n    }\r\n\r\n    return MouseCursor.getDefinedCursor('default');\r\n  }\r\n\r\n  _setCursorForViewports(cursor: MouseCursor): void {\r\n    this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\r\n      const enabledElement = getEnabledElementByIds(\r\n        viewportId,\r\n        renderingEngineId\r\n      );\r\n\r\n      if (!enabledElement) {\r\n        return;\r\n      }\r\n\r\n      const { viewport } = enabledElement;\r\n      initElementCursor(viewport.element, cursor);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set a configuration of a tool by the given toolName.\r\n   * Use overwrite as true in case you want to overwrite any existing configuration (be careful, depending on config change it might break the annotation flow).\r\n   */\r\n  public setToolConfiguration(\r\n    toolName: string,\r\n    configuration: ToolConfiguration,\r\n    overwrite?: boolean\r\n  ): boolean {\r\n    const toolInstance = this._toolInstances[toolName];\r\n    if (toolInstance === undefined) {\r\n      console.warn(\r\n        `Tool ${toolName} not present, can't set tool configuration.`\r\n      );\r\n      return false;\r\n    }\r\n\r\n    let _configuration;\r\n\r\n    if (overwrite) {\r\n      _configuration = configuration;\r\n    } else {\r\n      // We should not deep copy here, it is the job of the application to\r\n      // deep copy the configuration before passing it to the toolGroup, otherwise\r\n      // some strange appending behaviour happens for the arrays\r\n      _configuration = Object.assign(toolInstance.configuration, configuration);\r\n    }\r\n\r\n    toolInstance.configuration = _configuration;\r\n\r\n    if (typeof toolInstance.onSetToolConfiguration === 'function') {\r\n      toolInstance.onSetToolConfiguration();\r\n    }\r\n\r\n    this._renderViewports();\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Returns the default mouse primary button.\r\n   */\r\n  public getDefaultMousePrimary(): MouseBindings {\r\n    return MouseBindings.Primary;\r\n  }\r\n\r\n  /**\r\n   * Gets an array of bindings that is the full primary binding.\r\n   * Currently this is just the primary mouse button, but may be extended in the\r\n   * future to include touch or other binding types.\r\n   */\r\n  public getDefaultPrimaryBindings(): IToolBinding[] {\r\n    return PRIMARY_BINDINGS;\r\n  }\r\n\r\n  /**\r\n   * Get the configuration of tool. It returns only the config for the given path (in case exists).\r\n   * ConfigurationPath is the the path of the property to get separated by '.'.\r\n   *\r\n   * @example\r\n   * getToolConfiguration('LengthTool', 'firstLevel.secondLevel')\r\n   * // get from LengthTool instance the configuration value as being LengthToolInstance[configuration][firstLevel][secondLevel]\r\n   */\r\n  getToolConfiguration(toolName: string, configurationPath?: string): any {\r\n    if (this._toolInstances[toolName] === undefined) {\r\n      console.warn(\r\n        `Tool ${toolName} not present, can't set tool configuration.`\r\n      );\r\n      return;\r\n    }\r\n\r\n    const _configuration =\r\n      get(this._toolInstances[toolName].configuration, configurationPath) ||\r\n      this._toolInstances[toolName].configuration;\r\n\r\n    return cloneDeep(_configuration);\r\n  }\r\n\r\n  /**\r\n   * Gets the name of the previously active tool.\r\n   * @returns The name of the previously active tool.\r\n   */\r\n  public getPrevActivePrimaryToolName(): string {\r\n    return this.prevActivePrimaryToolName;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param newToolGroupId - Id of the new (clone) tool group\r\n   * @param fnToolFilter - Function to filter which tools from this tool group\r\n   * should be added to the new (clone) one. Example: only annotations tools\r\n   * can be filtered and added to the new tool group.\r\n   * @returns A new tool group that is a clone of this one\r\n   */\r\n  public clone(\r\n    newToolGroupId,\r\n    fnToolFilter: (toolName: string) => void = null\r\n  ): IToolGroup {\r\n    let toolGroup = ToolGroupManager.getToolGroup(newToolGroupId);\r\n\r\n    if (toolGroup) {\r\n      console.warn(`ToolGroup ${newToolGroupId} already exists`);\r\n      return toolGroup;\r\n    }\r\n\r\n    toolGroup = ToolGroupManager.createToolGroup(newToolGroupId);\r\n    fnToolFilter = fnToolFilter ?? (() => true);\r\n\r\n    Object.keys(this._toolInstances)\r\n      .filter(fnToolFilter)\r\n      .forEach((toolName) => {\r\n        const sourceToolInstance = this._toolInstances[toolName];\r\n        const sourceToolOptions = this.toolOptions[toolName];\r\n        const sourceToolMode = sourceToolInstance.mode;\r\n\r\n        toolGroup.addTool(toolName);\r\n\r\n        (toolGroup as unknown as ToolGroup).setToolMode(\r\n          toolName,\r\n          sourceToolMode,\r\n          {\r\n            bindings: sourceToolOptions.bindings ?? [],\r\n          }\r\n        );\r\n      });\r\n\r\n    return toolGroup;\r\n  }\r\n\r\n  /**\r\n   * Check if the tool binding is set to be primary mouse button.\r\n   * @param toolOptions - The options for the tool mode.\r\n   * @returns A boolean value.\r\n   */\r\n  private _hasMousePrimaryButtonBinding(toolOptions) {\r\n    const primaryBindings = this.getDefaultPrimaryBindings();\r\n    return toolOptions?.bindings?.some((binding) =>\r\n      primaryBindings.some((primary) => hasSameBinding(binding, primary))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * It re-renders the viewports in the toolGroup\r\n   */\r\n  private _renderViewports(): void {\r\n    this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\r\n      getRenderingEngine(renderingEngineId).renderViewport(viewportId);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Trigger ToolModeChangedEvent when changing the tool mode\r\n   * @param toolName - Tool name\r\n   * @param mode - Tool mode\r\n   * @param toolBindingsOptions - Binding options used when a tool is activated\r\n   */\r\n  private _triggerToolModeChangedEvent(\r\n    toolName: string,\r\n    mode: ToolModes,\r\n    toolBindingsOptions?: SetToolBindingsType\r\n  ): void {\r\n    const eventDetail: ToolModeChangedEventDetail = {\r\n      toolGroupId: this.id,\r\n      toolName,\r\n      mode,\r\n      toolBindingsOptions,\r\n    };\r\n\r\n    triggerEvent(eventTarget, Events.TOOL_MODE_CHANGED, eventDetail);\r\n  }\r\n}\r\n\r\n/**\r\n * Figure out if the two bindings are the same\r\n */\r\nfunction hasSameBinding(\r\n  binding1: IToolBinding,\r\n  binding2: IToolBinding\r\n): boolean {\r\n  if (binding1.mouseButton !== binding2.mouseButton) {\r\n    return false;\r\n  }\r\n  if (binding1.numTouchPoints !== binding2.numTouchPoints) {\r\n    return false;\r\n  }\r\n\r\n  return binding1.modifierKey === binding2.modifierKey;\r\n}\r\n","import { state } from '../index';\r\nimport ToolGroup from './ToolGroup';\r\nimport { IToolGroup } from '../../types';\r\n\r\n/**\r\n * Create a new tool group with the given name. ToolGroups are the new way\r\n * in Cornerstone3DTools to share tool configuration, state (enabled, disabled, etc.)\r\n * across a set of viewports.\r\n *\r\n * @param toolGroupId - The unique ID of the tool group.\r\n * @returns A reference to the tool group that was created.\r\n */\r\nfunction createToolGroup(toolGroupId: string): IToolGroup | undefined {\r\n  // Exit early if ID conflict\r\n  const toolGroupWithIdExists = state.toolGroups.some(\r\n    (tg) => tg.id === toolGroupId\r\n  );\r\n\r\n  if (toolGroupWithIdExists) {\r\n    console.warn(`'${toolGroupId}' already exists.`);\r\n    return;\r\n  }\r\n\r\n  const toolGroup = new ToolGroup(toolGroupId);\r\n\r\n  // Update state\r\n  state.toolGroups.push(toolGroup);\r\n\r\n  // Return reference\r\n  return toolGroup;\r\n}\r\n\r\nexport default createToolGroup;\r\n","// `BaseManager` or IManager interface for duplicate API between ToolGroup/Synchronizer?\r\nimport { state as csToolsState } from '../index';\r\nimport destroyToolGroup from './destroyToolGroup';\r\n\r\n// ToolGroups function entirely by their \"state\" being queried and leveraged\r\n// removing a ToolGroup from state is equivalent to killing it. Calling\r\n// destroyToolGroup() to make sure the SegmentationDisplayTools\r\n// have been removed from the toolGroup Viewports. //Todo: this makes more sense\r\n// to be based on events, but we don't have any toolGroup created/removed events\r\n\r\n/**\r\n * Destroy all tool groups\r\n */\r\nfunction destroy(): void {\r\n  const toolGroups = [...csToolsState.toolGroups];\r\n\r\n  for (const toolGroup of toolGroups) {\r\n    destroyToolGroup(toolGroup.id);\r\n  }\r\n\r\n  csToolsState.toolGroups = [];\r\n}\r\n\r\nexport default destroy;\r\n","import { state } from '../index';\r\nimport { removeSegmentationsFromToolGroup } from '../../stateManagement/segmentation';\r\nimport { segmentationRenderingEngine } from '../../utilities/segmentation/triggerSegmentationRender';\r\n// ToolGroups function entirely by their \"state\" being queried and leveraged\r\n// removing a ToolGroup from state is equivalent to killing it\r\n\r\n/**\r\n * Given a tool group Id, destroy the toolGroup. It will also cleanup all segmentations\r\n * associated with that tool group too\r\n *\r\n * @param toolGroupId - The Id of the tool group to be destroyed.\r\n */\r\nfunction destroyToolGroup(toolGroupId: string): void {\r\n  const toolGroupIndex = state.toolGroups.findIndex(\r\n    (tg) => tg.id === toolGroupId\r\n  );\r\n\r\n  if (toolGroupIndex > -1) {\r\n    segmentationRenderingEngine.removeToolGroup(toolGroupId);\r\n    // Todo: this should not happen here)\r\n    removeSegmentationsFromToolGroup(toolGroupId);\r\n    state.toolGroups.splice(toolGroupIndex, 1);\r\n  }\r\n}\r\n\r\nexport default destroyToolGroup;\r\n","import { state } from '../index';\r\nimport { IToolGroup } from '../../types';\r\n\r\n/**\r\n * Return the array of tool groups\r\n * @returns An array of tool groups.\r\n */\r\nfunction getAllToolGroups(): Array<IToolGroup> {\r\n  return state.toolGroups;\r\n}\r\n\r\nexport default getAllToolGroups;\r\n","import { state } from '../index';\r\nimport { IToolGroup } from '../../types';\r\n\r\n/**\r\n * Given a tool group Id, return the tool group\r\n * @param toolGroupId - The Id of the tool group to be retrieved.\r\n * @returns The tool group that has the same id as the tool group id that was\r\n * passed in.\r\n */\r\nfunction getToolGroup(toolGroupId: string): IToolGroup | undefined {\r\n  return state.toolGroups.find((s) => s.id === toolGroupId);\r\n}\r\n\r\nexport default getToolGroup;\r\n","import { state } from '../index';\r\nimport { IToolGroup } from '../../types';\r\nimport { ToolModes } from '../../enums';\r\n\r\nconst MODES = [ToolModes.Active, ToolModes.Passive, ToolModes.Enabled];\r\n\r\n/**\r\n * Returns the toolGroups that has the given toolName as active, passive\r\n * or enabled.\r\n * @param toolName - The name of the tool\r\n * @returns An array of tool groups.\r\n */\r\nfunction getToolGroupsWithToolName(toolName: string): IToolGroup[] | [] {\r\n  return state.toolGroups.filter(({ toolOptions }) => {\r\n    const toolGroupToolNames = Object.keys(toolOptions);\r\n\r\n    for (let i = 0; i < toolGroupToolNames.length; i++) {\r\n      if (toolName !== toolGroupToolNames[i]) {\r\n        continue;\r\n      }\r\n\r\n      /* filter out tools that don't have options */\r\n      if (!toolOptions[toolName]) {\r\n        continue;\r\n      }\r\n\r\n      if (MODES.includes(toolOptions[toolName].mode)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  });\r\n}\r\n\r\nexport default getToolGroupsWithToolName;\r\n","import {\r\n  CONSTANTS,\r\n  getEnabledElement,\r\n  VolumeViewport,\r\n  utilities as csUtils,\r\n} from '@cornerstonejs/core';\r\nimport type { Types } from '@cornerstonejs/core';\r\nimport { vec3 } from 'gl-matrix';\r\n\r\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\r\nimport { math, roundNumber } from '../../utilities';\r\nimport { polyline } from '../../utilities/math';\r\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\r\nimport throttle from '../../utilities/throttle';\r\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\r\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\r\nimport registerDrawLoop from './planarFreehandROITool/drawLoop';\r\nimport registerEditLoopCommon from './planarFreehandROITool/editLoopCommon';\r\nimport registerClosedContourEditLoop from './planarFreehandROITool/closedContourEditLoop';\r\nimport registerOpenContourEditLoop from './planarFreehandROITool/openContourEditLoop';\r\nimport registerOpenContourEndEditLoop from './planarFreehandROITool/openContourEndEditLoop';\r\nimport registerRenderMethods from './planarFreehandROITool/renderMethods';\r\nimport type {\r\n  EventTypes,\r\n  ToolHandle,\r\n  Annotation,\r\n  Annotations,\r\n  AnnotationStyle,\r\n  PublicToolProps,\r\n  ToolProps,\r\n  SVGDrawingHelper,\r\n  AnnotationRenderContext,\r\n} from '../../types';\r\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\r\nimport { drawLinkedTextBox } from '../../drawingSvg';\r\nimport { PlanarFreehandROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\r\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\r\nimport { PlanarFreehandROICommonData } from '../../utilities/math/polyline/planarFreehandROIInternalTypes';\r\n\r\nimport { getLineSegmentIntersectionsCoordinates } from '../../utilities/math/polyline';\r\nimport pointInShapeCallback from '../../utilities/pointInShapeCallback';\r\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\r\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\r\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\r\nimport calculatePerimeter from '../../utilities/contours/calculatePerimeter';\r\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\r\nimport { KeyboardBindings, ChangeTypes } from '../../enums';\r\n\r\nconst { pointCanProjectOnLine } = polyline;\r\nconst { EPSILON } = CONSTANTS;\r\n\r\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\r\n\r\n/**\r\n * PlanarFreehandROITool lets you draw annotations that define an arbitrarily drawn region.\r\n * You can use the PlanarFreehandROITool in all perpendicular views (axial, sagittal, coronal),\r\n * support for oblique views is possible, but not yet supported, due to the implementation of\r\n * `getSubPixelSpacingAndXYDirections`.\r\n *\r\n * The resulting annotation's data and metadata (the\r\n * state of the viewport while drawing was happening) will get added to the\r\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\r\n * or similar methods.\r\n *\r\n * PlanarFreehandROITool annotation can be smoothed on drawing completion. This is a configured based approach.\r\n * The smoothing process uses b-spline algorithm and consider 4 configurations properties:\r\n * - smoothing.smoothOnAdd: to tell whether it should be smoothed or not (for editing it is considered the property smoothOnEdit) (default: false)\r\n * - smoothing.smoothOnEdit: to tell whether it should be smoothed or not when editing (default: false)\r\n * - smoothing.knotsRatioPercentageOnAdd: percentage of points from Segment that are likely to be considered knots during smoothing (for editing it is considered the property knotsRatioPercentageOnEdit) ( default: 40)\r\n * - smoothing.knotsRatioPercentageOnEdit: same as knotsRatioPercentageOnAdd but applicable only when editing the tool (default: 40)\r\n *\r\n * So, with that said the smoothing might occur when:\r\n * - drawing is done (i.e mouse is released) and smoothing.smoothOnAdd is true. smoothing algorithm uses knotsRatioPercentageOnAdd\r\n * - edit drawing is done (i.e mouse is released) and smoothing.smoothOnEdit is true. smoothing algorithm uses knotsRatioPercentageOnEdit and its only applied to changed segment\r\n * smoothing does not occur when:\r\n * - smoothing.smoothOnAdd is false and drawing is completed\r\n * - smoothing.smoothOnEdit is false and edit is completed\r\n * - drawing still happening (editing or not)\r\n *\r\n * The result of smoothing will be removal of some of the outliers\r\n * Changing tool configuration (see below) you can fine-tune the smoothing process by changing knotsRatioPercentageOnAdd and knotsRatioPercentageOnEdit value, which smaller values produces a more agressive smoothing.\r\n * A smaller value of knotsRatioPercentageOnAdd/knotsRatioPercentageOnEdit produces a more aggressive smoothing.\r\n *\r\n * ```js\r\n * cornerstoneTools.addTool(PlanarFreehandROITool)\r\n *\r\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\r\n *\r\n * toolGroup.addTool(PlanarFreehandROITool.toolName)\r\n *\r\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\r\n *\r\n * toolGroup.setToolActive(PlanarFreehandROITool.toolName, {\r\n *   bindings: [\r\n *    {\r\n *       mouseButton: MouseBindings.Primary, // Left Click\r\n *     },\r\n *   ],\r\n * })\r\n *\r\n * // set smoothing aggressiveness while adding new annotation (ps: this does not change if smoothing is ON or OFF)\r\n * toolGroup.setToolConfiguration(PlanarFreehandROITool.toolName, {\r\n *   smoothing: { knotsRatioPercentageOnAdd: 30 },\r\n * });\r\n *\r\n * // set smoothing to be ON while editing only\r\n * toolGroup.setToolConfiguration(PlanarFreehandROITool.toolName, {\r\n *   smoothing: { smoothOnAdd: false, smoothOnEdit: true  },\r\n * });\r\n * ```\r\n *\r\n *\r\n * Read more in the Docs section of the website.\r\n */\r\n\r\nclass PlanarFreehandROITool extends ContourSegmentationBaseTool {\r\n  static toolName;\r\n\r\n  public touchDragCallback: any;\r\n  public mouseDragCallback: any;\r\n  _throttledCalculateCachedStats: any;\r\n  private commonData?: PlanarFreehandROICommonData;\r\n  isDrawing = false;\r\n  isEditingClosed = false;\r\n  isEditingOpen = false;\r\n\r\n  protected activateDraw: (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: PlanarFreehandROIAnnotation,\r\n    viewportIdsToRender: string[]\r\n  ) => void;\r\n  private activateClosedContourEdit: (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: PlanarFreehandROIAnnotation,\r\n    viewportIdsToRender: string[]\r\n  ) => void;\r\n  private activateOpenContourEdit: (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: PlanarFreehandROIAnnotation,\r\n    viewportIdsToRender: string[]\r\n  ) => void;\r\n  private activateOpenContourEndEdit: (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: PlanarFreehandROIAnnotation,\r\n    viewportIdsToRender: string[],\r\n    handle: ToolHandle | null\r\n  ) => void;\r\n  private cancelDrawing: (element: HTMLDivElement) => void;\r\n  private cancelClosedContourEdit: (element: HTMLDivElement) => void;\r\n  private cancelOpenContourEdit: (element: HTMLDivElement) => void;\r\n\r\n  private renderContour: (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper,\r\n    annotation: PlanarFreehandROIAnnotation\r\n  ) => void;\r\n  private renderContourBeingDrawn: (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper,\r\n    annotation: PlanarFreehandROIAnnotation\r\n  ) => void;\r\n  private renderClosedContourBeingEdited: (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper,\r\n    annotation: PlanarFreehandROIAnnotation\r\n  ) => void;\r\n  private renderOpenContourBeingEdited: (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper,\r\n    annotation: PlanarFreehandROIAnnotation\r\n  ) => void;\r\n\r\n  private renderPointContourWithMarker: (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: SVGDrawingHelper,\r\n    annotation: PlanarFreehandROIAnnotation\r\n  ) => void;\r\n\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      supportedInteractionTypes: ['Mouse', 'Touch'],\r\n      configuration: {\r\n        shadow: true,\r\n        preventHandleOutsideImage: false,\r\n        /**\r\n         * Specify which modifier key is used to add a hole to a contour. The\r\n         * modifier must be pressed when the first point of a new contour is added.\r\n         */\r\n        contourHoleAdditionModifierKey: KeyboardBindings.Shift,\r\n        alwaysRenderOpenContourHandles: {\r\n          // When true, always render end points when you have an open contour, rather\r\n          // than just rendering a line.\r\n          enabled: false,\r\n          // When enabled, use this radius to draw the endpoints whilst not hovering.\r\n          radius: 2,\r\n        },\r\n        allowOpenContours: true,\r\n        // Proximity in canvas coordinates used to join contours.\r\n        closeContourProximity: 10,\r\n        // The proximity at which we fallback to the simplest grabbing logic for\r\n        // determining what index of the contour to start editing.\r\n        checkCanvasEditFallbackProximity: 6,\r\n        // For closed contours, make them clockwise\r\n        // This can be useful if contours are compared between slices, eg for\r\n        // interpolation, and does not cause problems otherwise so defaulting to true.\r\n        makeClockWise: true,\r\n        // The relative distance that points should be dropped along the polyline\r\n        // in units of the image pixel spacing. A value of 1 means that nodes must\r\n        // be placed no closed than the image spacing apart. A value of 4 means that 4\r\n        // nodes should be placed within the space of one image pixel size. A higher\r\n        // value gives more finesse to the tool/smoother lines, but the value cannot\r\n        // be infinite as the lines become very computationally expensive to draw.\r\n        subPixelResolution: 4,\r\n        /**\r\n         * Smoothing is used to remove jagged irregularities in the polyline,\r\n         * as opposed to interpolation, which is used to create new polylines\r\n         * between existing polylines.\r\n         */\r\n        smoothing: {\r\n          smoothOnAdd: false,\r\n          smoothOnEdit: false, // used for edit only\r\n          knotsRatioPercentageOnAdd: 40,\r\n          knotsRatioPercentageOnEdit: 40,\r\n        },\r\n        /**\r\n         * Interpolation is the creation of new segmentations in between the\r\n         * existing segmentations/indices.  Note that this does not apply to\r\n         * ROI values, since those annotations are individual annotations, not\r\n         * connected in any way to each other, whereas segmentations are intended\r\n         * to be connected 2d + 1 dimension (time or space or other) volumes.\r\n         */\r\n        interpolation: {\r\n          enabled: false,\r\n          // Callback to update the annotation or perform other action when the\r\n          // interpolation is complete.\r\n          onInterpolationComplete: null,\r\n        },\r\n        /**\r\n         * The polyline may get processed in order to reduce the number of points\r\n         * for better performance and storage.\r\n         */\r\n        decimate: {\r\n          enabled: false,\r\n          /** A maximum given distance 'epsilon' to decide if a point should or\r\n           * shouldn't be added the resulting polyline which will have a lower\r\n           * number of points for higher `epsilon` values.\r\n           */\r\n          epsilon: 0.1,\r\n        },\r\n        displayOnePointAsCrosshairs: false,\r\n        calculateStats: true,\r\n        getTextLines: defaultGetTextLines,\r\n        statsCalculator: BasicStatsCalculator,\r\n      },\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n\r\n    // Register event loops and rendering logic, which are stored in different\r\n    // Files due to their complexity/size.\r\n    registerDrawLoop(this);\r\n    registerEditLoopCommon(this);\r\n    registerClosedContourEditLoop(this);\r\n    registerOpenContourEditLoop(this);\r\n    registerOpenContourEndEditLoop(this);\r\n    registerRenderMethods(this);\r\n\r\n    this._throttledCalculateCachedStats = throttle(\r\n      this._calculateCachedStats,\r\n      100,\r\n      { trailing: true }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Based on the current position of the mouse and the current image, creates\r\n   * a `PlanarFreehandROIAnnotation` and stores it in the annotationManager.\r\n   *\r\n   * @param evt - `EventTypes.NormalizedMouseEventType`\r\n   * @returns The `PlanarFreehandROIAnnotation` object.\r\n   */\r\n  addNewAnnotation = (\r\n    evt: EventTypes.InteractionEventType\r\n  ): PlanarFreehandROIAnnotation => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n    const enabledElement = getEnabledElement(element);\r\n    const { renderingEngine } = enabledElement;\r\n\r\n    const annotation = this.createAnnotation(\r\n      evt\r\n    ) as PlanarFreehandROIAnnotation;\r\n\r\n    this.addAnnotation(annotation, element);\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.activateDraw(evt, annotation, viewportIdsToRender);\r\n\r\n    evt.preventDefault();\r\n\r\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\r\n\r\n    return annotation;\r\n  };\r\n\r\n  /**\r\n   * Begins an edit of an open contour, when the mouse has selected a handle\r\n   * (end) of the open contour.\r\n   *\r\n   * @param evt - `EventTypes.MouseDownEventType`\r\n   * @param annotation - `PlanarFreehandROIAnnotation` annotation.\r\n   * @param handle - The handle index, 0 for the start and 1 for the end.\r\n   * @param interactionType - interaction type (mouse, touch)\r\n   */\r\n  handleSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: PlanarFreehandROIAnnotation,\r\n    handle: ToolHandle\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    this.activateOpenContourEndEdit(\r\n      evt,\r\n      annotation,\r\n      viewportIdsToRender,\r\n      handle\r\n    );\r\n  };\r\n\r\n  /**\r\n   * Edits the open or closed contour when the line is grabbed and dragged.\r\n   */\r\n  toolSelectedCallback = (\r\n    evt: EventTypes.InteractionEventType,\r\n    annotation: PlanarFreehandROIAnnotation\r\n  ): void => {\r\n    const eventDetail = evt.detail;\r\n    const { element } = eventDetail;\r\n\r\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\r\n      element,\r\n      this.getToolName()\r\n    );\r\n\r\n    if (annotation.data.contour.closed) {\r\n      this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\r\n    } else {\r\n      this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);\r\n    }\r\n\r\n    evt.preventDefault();\r\n  };\r\n\r\n  /**\r\n   * Returns if the canvas point is near the line of the given annotation in the\r\n   * provided element or not. A proximity is passed to the function to determine the\r\n   * proximity of the point to the annotation in number of pixels.\r\n   *\r\n   * @param element - HTML Element\r\n   * @param annotation - The `PlanarFreehandROIAnnotation`.\r\n   * @param canvasCoords - Canvas coordinates\r\n   * @param proximity - Proximity to tool to consider\r\n   * @returns Boolean, whether the canvas point is near tool\r\n   */\r\n  isPointNearTool = (\r\n    element: HTMLDivElement,\r\n    annotation: PlanarFreehandROIAnnotation,\r\n    canvasCoords: Types.Point2,\r\n    proximity: number\r\n  ): boolean => {\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    const { polyline: points } = annotation.data.contour;\r\n\r\n    // NOTE: It is implemented this way so that we do not double calculate\r\n    // points when number crunching adjacent line segments.\r\n    let previousPoint = viewport.worldToCanvas(points[0]);\r\n\r\n    for (let i = 1; i < points.length; i++) {\r\n      const p1 = previousPoint;\r\n      const p2 = viewport.worldToCanvas(points[i]);\r\n      const canProject = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);\r\n\r\n      if (canProject) {\r\n        return true;\r\n      }\r\n\r\n      previousPoint = p2;\r\n    }\r\n\r\n    if (!annotation.data.contour.closed) {\r\n      // Contour is open, don't check last point to first point.\r\n      return false;\r\n    }\r\n\r\n    // check last point to first point\r\n    const pStart = viewport.worldToCanvas(points[0]);\r\n    const pEnd = viewport.worldToCanvas(points[points.length - 1]);\r\n\r\n    return pointCanProjectOnLine(canvasCoords, pStart, pEnd, proximity);\r\n  };\r\n\r\n  public cancel = (element: HTMLDivElement): void => {\r\n    const isDrawing = this.isDrawing;\r\n    const isEditingOpen = this.isEditingOpen;\r\n    const isEditingClosed = this.isEditingClosed;\r\n\r\n    if (isDrawing) {\r\n      this.cancelDrawing(element);\r\n    } else if (isEditingOpen) {\r\n      this.cancelOpenContourEdit(element);\r\n    } else if (isEditingClosed) {\r\n      this.cancelClosedContourEdit(element);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @override We need to override this method as the tool doesn't always have\r\n   * `handles`, which means `filterAnnotationsForDisplay` fails inside\r\n   * `filterAnnotationsWithinSlice`.\r\n   */\r\n  public filterInteractableAnnotationsForElement(\r\n    element: HTMLDivElement,\r\n    annotations: Annotations\r\n  ): Annotations | undefined {\r\n    if (!annotations || !annotations.length) {\r\n      return;\r\n    }\r\n\r\n    const enabledElement = getEnabledElement(element);\r\n    const { viewport } = enabledElement;\r\n\r\n    let annotationsToDisplay;\r\n\r\n    if (viewport instanceof VolumeViewport) {\r\n      const camera = viewport.getCamera();\r\n\r\n      const { spacingInNormalDirection } =\r\n        csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\r\n\r\n      // Get data with same normal and within the same slice\r\n      annotationsToDisplay = this.filterAnnotationsWithinSlice(\r\n        annotations,\r\n        camera,\r\n        spacingInNormalDirection\r\n      );\r\n    } else {\r\n      // Use the default `filterAnnotationsForDisplay` utility, as the stack\r\n      // path doesn't require handles.\r\n      annotationsToDisplay = filterAnnotationsForDisplay(viewport, annotations);\r\n    }\r\n\r\n    return annotationsToDisplay;\r\n  }\r\n\r\n  /**\r\n   * Altered version of the `utilities.planar.filterAnnotationsWithinSlice`,\r\n   * which uses the polyline position rather than the handle. As the polyline is\r\n   * always present.\r\n   */\r\n  private filterAnnotationsWithinSlice(\r\n    annotations: Annotations,\r\n    camera: Types.ICamera,\r\n    spacingInNormalDirection: number\r\n  ): Annotations {\r\n    const { viewPlaneNormal } = camera;\r\n\r\n    const annotationsWithParallelNormals = annotations.filter(\r\n      (td: Annotation) => {\r\n        const annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\r\n\r\n        const isParallel =\r\n          Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\r\n          PARALLEL_THRESHOLD;\r\n\r\n        return annotationViewPlaneNormal && isParallel;\r\n      }\r\n    ) as PlanarFreehandROIAnnotation[];\r\n\r\n    // No in plane annotations.\r\n    if (!annotationsWithParallelNormals.length) {\r\n      return [];\r\n    }\r\n\r\n    // Annotation should be within the slice, which means that it should be between\r\n    // camera's focalPoint +/- spacingInNormalDirection.\r\n\r\n    const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\r\n    const { focalPoint } = camera;\r\n\r\n    const annotationsWithinSlice = [];\r\n\r\n    for (const annotation of annotationsWithParallelNormals) {\r\n      const data = annotation.data;\r\n      const point = data.contour.polyline[0];\r\n\r\n      if (!annotation.isVisible) {\r\n        continue;\r\n      }\r\n\r\n      // A = point\r\n      // B = focal point\r\n      // P = normal\r\n\r\n      // B-A dot P  => Distance in the view direction.\r\n      // this should be less than half the slice distance.\r\n\r\n      const dir = vec3.create();\r\n\r\n      vec3.sub(dir, focalPoint, point);\r\n\r\n      const dot = vec3.dot(dir, viewPlaneNormal);\r\n\r\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\r\n        annotationsWithinSlice.push(annotation);\r\n      }\r\n    }\r\n\r\n    return annotationsWithinSlice;\r\n  }\r\n\r\n  protected isContourSegmentationTool(): boolean {\r\n    // Disable contour segmentation behavior because it shall be activated only\r\n    // for PlanarFreehandContourSegmentationTool\r\n    return false;\r\n  }\r\n\r\n  protected createAnnotation(evt: EventTypes.InteractionEventType): Annotation {\r\n    const worldPos = evt.detail.currentPoints.world;\r\n    const contourAnnotation = super.createAnnotation(evt);\r\n\r\n    const onInterpolationComplete = (annotation) => {\r\n      // Clear out the handles because they aren't used for straight freeform\r\n      annotation.data.handles.points.length = 0;\r\n    };\r\n\r\n    const annotation = <PlanarFreehandROIAnnotation>csUtils.deepMerge(\r\n      contourAnnotation,\r\n      {\r\n        data: {\r\n          contour: {\r\n            polyline: [<Types.Point3>[...worldPos]],\r\n          },\r\n          label: '',\r\n          cachedStats: {},\r\n        },\r\n        onInterpolationComplete,\r\n      }\r\n    );\r\n\r\n    return annotation;\r\n  }\r\n\r\n  protected getAnnotationStyle(context) {\r\n    // This method exists only because `super` cannot be called from\r\n    // _getRenderingOptions() which is in an external file.\r\n    return super.getAnnotationStyle(context);\r\n  }\r\n\r\n  protected renderAnnotationInstance(\r\n    renderContext: AnnotationRenderContext\r\n  ): boolean {\r\n    const { enabledElement, targetId, svgDrawingHelper } = renderContext;\r\n    const annotation = renderContext.annotation as PlanarFreehandROIAnnotation;\r\n\r\n    let renderStatus = false;\r\n    const { viewport, renderingEngine } = enabledElement;\r\n\r\n    const isDrawing = this.isDrawing;\r\n    const isEditingOpen = this.isEditingOpen;\r\n    const isEditingClosed = this.isEditingClosed;\r\n\r\n    if (!(isDrawing || isEditingOpen || isEditingClosed)) {\r\n      // No annotations are currently being modified, so we can just use the\r\n      // render contour method to render all of them\r\n      if (\r\n        this.configuration.displayOnePointAsCrosshairs &&\r\n        annotation.data.contour.polyline.length === 1\r\n      ) {\r\n        this.renderPointContourWithMarker(\r\n          enabledElement,\r\n          svgDrawingHelper,\r\n          annotation\r\n        );\r\n      } else {\r\n        this.renderContour(enabledElement, svgDrawingHelper, annotation);\r\n      }\r\n    } else {\r\n      // The active annotation will need special rendering treatment. Render all\r\n      // other annotations not being interacted with using the standard renderContour\r\n      // rendering path.\r\n      const activeAnnotationUID = this.commonData.annotation.annotationUID;\r\n\r\n      if (annotation.annotationUID === activeAnnotationUID) {\r\n        if (isDrawing) {\r\n          this.renderContourBeingDrawn(\r\n            enabledElement,\r\n            svgDrawingHelper,\r\n            annotation\r\n          );\r\n        } else if (isEditingClosed) {\r\n          this.renderClosedContourBeingEdited(\r\n            enabledElement,\r\n            svgDrawingHelper,\r\n            annotation\r\n          );\r\n        } else if (isEditingOpen) {\r\n          this.renderOpenContourBeingEdited(\r\n            enabledElement,\r\n            svgDrawingHelper,\r\n            annotation\r\n          );\r\n        } else {\r\n          throw new Error(\r\n            `Unknown ${this.getToolName()} annotation rendering state`\r\n          );\r\n        }\r\n      } else {\r\n        if (\r\n          this.configuration.displayOnePointAsCrosshairs &&\r\n          annotation.data.contour.polyline.length === 1\r\n        ) {\r\n          this.renderPointContourWithMarker(\r\n            enabledElement,\r\n            svgDrawingHelper,\r\n            annotation\r\n          );\r\n        } else {\r\n          this.renderContour(enabledElement, svgDrawingHelper, annotation);\r\n        }\r\n      }\r\n\r\n      // Todo: return boolean flag for each rendering route in the planar tool.\r\n      renderStatus = true;\r\n    }\r\n\r\n    if (!this.configuration.calculateStats) {\r\n      return;\r\n    }\r\n\r\n    this._calculateStatsIfActive(\r\n      annotation,\r\n      targetId,\r\n      viewport,\r\n      renderingEngine,\r\n      enabledElement\r\n    );\r\n\r\n    this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);\r\n\r\n    return renderStatus;\r\n  }\r\n\r\n  _calculateStatsIfActive(\r\n    annotation: PlanarFreehandROIAnnotation,\r\n    targetId: string,\r\n    viewport,\r\n    renderingEngine,\r\n    enabledElement\r\n  ) {\r\n    const activeAnnotationUID = this.commonData?.annotation.annotationUID;\r\n\r\n    if (\r\n      annotation.annotationUID === activeAnnotationUID &&\r\n      !this.commonData?.movingTextBox\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    if (!this.commonData?.movingTextBox) {\r\n      const { data } = annotation;\r\n      if (\r\n        !data.cachedStats[targetId] ||\r\n        data.cachedStats[targetId].areaUnit == null\r\n      ) {\r\n        data.cachedStats[targetId] = {\r\n          Modality: null,\r\n          area: null,\r\n          max: null,\r\n          mean: null,\r\n          stdDev: null,\r\n          areaUnit: null,\r\n        };\r\n\r\n        this._calculateCachedStats(\r\n          annotation,\r\n          viewport,\r\n          renderingEngine,\r\n          enabledElement\r\n        );\r\n      } else if (annotation.invalidated) {\r\n        this._throttledCalculateCachedStats(\r\n          annotation,\r\n          viewport,\r\n          renderingEngine,\r\n          enabledElement\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  private _calculateCachedStats = (\r\n    annotation,\r\n    viewport,\r\n    renderingEngine,\r\n    enabledElement\r\n  ) => {\r\n    const { data } = annotation;\r\n    const { cachedStats } = data;\r\n    const { polyline: points, closed } = data.contour;\r\n\r\n    const targetIds = Object.keys(cachedStats);\r\n\r\n    for (let i = 0; i < targetIds.length; i++) {\r\n      const targetId = targetIds[i];\r\n      const image = this.getTargetIdImage(targetId, renderingEngine);\r\n\r\n      // If image does not exists for the targetId, skip. This can be due\r\n      // to various reasons such as if the target was a volumeViewport, and\r\n      // the volumeViewport has been decached in the meantime.\r\n      if (!image) {\r\n        continue;\r\n      }\r\n\r\n      const { imageData, metadata } = image;\r\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\r\n\r\n      // Using an arbitrary start point (canvasPoint), calculate the\r\n      // mm spacing for the canvas in the X and Y directions.\r\n      const canvasPoint = canvasCoordinates[0];\r\n      const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\r\n      const deltaXPoint = viewport.canvasToWorld([\r\n        canvasPoint[0] + 1,\r\n        canvasPoint[1],\r\n      ]);\r\n      const deltaYPoint = viewport.canvasToWorld([\r\n        canvasPoint[0],\r\n        canvasPoint[1] + 1,\r\n      ]);\r\n\r\n      const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\r\n      const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\r\n\r\n      const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[0]);\r\n      worldPosIndex[0] = Math.floor(worldPosIndex[0]);\r\n      worldPosIndex[1] = Math.floor(worldPosIndex[1]);\r\n      worldPosIndex[2] = Math.floor(worldPosIndex[2]);\r\n\r\n      let iMin = worldPosIndex[0];\r\n      let iMax = worldPosIndex[0];\r\n\r\n      let jMin = worldPosIndex[1];\r\n      let jMax = worldPosIndex[1];\r\n\r\n      let kMin = worldPosIndex[2];\r\n      let kMax = worldPosIndex[2];\r\n\r\n      for (let j = 1; j < points.length; j++) {\r\n        const worldPosIndex = csUtils.transformWorldToIndex(\r\n          imageData,\r\n          points[j]\r\n        );\r\n        worldPosIndex[0] = Math.floor(worldPosIndex[0]);\r\n        worldPosIndex[1] = Math.floor(worldPosIndex[1]);\r\n        worldPosIndex[2] = Math.floor(worldPosIndex[2]);\r\n        iMin = Math.min(iMin, worldPosIndex[0]);\r\n        iMax = Math.max(iMax, worldPosIndex[0]);\r\n\r\n        jMin = Math.min(jMin, worldPosIndex[1]);\r\n        jMax = Math.max(jMax, worldPosIndex[1]);\r\n\r\n        kMin = Math.min(kMin, worldPosIndex[2]);\r\n        kMax = Math.max(kMax, worldPosIndex[2]);\r\n      }\r\n\r\n      const worldPosIndex2 = csUtils.transformWorldToIndex(\r\n        imageData,\r\n        points[1]\r\n      );\r\n      worldPosIndex2[0] = Math.floor(worldPosIndex2[0]);\r\n      worldPosIndex2[1] = Math.floor(worldPosIndex2[1]);\r\n      worldPosIndex2[2] = Math.floor(worldPosIndex2[2]);\r\n\r\n      const { scale, areaUnits } = getCalibratedLengthUnitsAndScale(\r\n        image,\r\n        () => {\r\n          const polyline = data.contour.polyline;\r\n          const numPoints = polyline.length;\r\n          const projectedPolyline = new Array(numPoints);\r\n\r\n          for (let i = 0; i < numPoints; i++) {\r\n            projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\r\n          }\r\n\r\n          const {\r\n            maxX: canvasMaxX,\r\n            maxY: canvasMaxY,\r\n            minX: canvasMinX,\r\n            minY: canvasMinY,\r\n          } = math.polyline.getAABB(projectedPolyline);\r\n\r\n          const topLeftBBWorld = viewport.canvasToWorld([\r\n            canvasMinX,\r\n            canvasMinY,\r\n          ]);\r\n\r\n          const topLeftBBIndex = csUtils.transformWorldToIndex(\r\n            imageData,\r\n            topLeftBBWorld\r\n          );\r\n\r\n          const bottomRightBBWorld = viewport.canvasToWorld([\r\n            canvasMaxX,\r\n            canvasMaxY,\r\n          ]);\r\n\r\n          const bottomRightBBIndex = csUtils.transformWorldToIndex(\r\n            imageData,\r\n            bottomRightBBWorld\r\n          );\r\n\r\n          return [topLeftBBIndex, bottomRightBBIndex];\r\n        }\r\n      );\r\n      let area = polyline.getArea(canvasCoordinates) / scale / scale;\r\n      // Convert from canvas_pixels ^2 to mm^2\r\n      area *= deltaInX * deltaInY;\r\n\r\n      // Expand bounding box\r\n      const iDelta = 0.01 * (iMax - iMin);\r\n      const jDelta = 0.01 * (jMax - jMin);\r\n      const kDelta = 0.01 * (kMax - kMin);\r\n\r\n      iMin = Math.floor(iMin - iDelta);\r\n      iMax = Math.ceil(iMax + iDelta);\r\n      jMin = Math.floor(jMin - jDelta);\r\n      jMax = Math.ceil(jMax + jDelta);\r\n      kMin = Math.floor(kMin - kDelta);\r\n      kMax = Math.ceil(kMax + kDelta);\r\n\r\n      const boundsIJK = [\r\n        [iMin, iMax],\r\n        [jMin, jMax],\r\n        [kMin, kMax],\r\n      ] as [Types.Point2, Types.Point2, Types.Point2];\r\n\r\n      const worldPosEnd = imageData.indexToWorld([iMax, jMax, kMax]);\r\n      const canvasPosEnd = viewport.worldToCanvas(worldPosEnd);\r\n\r\n      let curRow = 0;\r\n      let intersections = [];\r\n      let intersectionCounter = 0;\r\n      const pointsInShape = pointInShapeCallback(\r\n        imageData,\r\n        (pointLPS, pointIJK) => {\r\n          let result = true;\r\n          const point = viewport.worldToCanvas(pointLPS);\r\n          if (point[1] != curRow) {\r\n            intersectionCounter = 0;\r\n            curRow = point[1];\r\n            intersections = getLineSegmentIntersectionsCoordinates(\r\n              canvasCoordinates,\r\n              point,\r\n              [canvasPosEnd[0], point[1]]\r\n            );\r\n            intersections.sort(\r\n              (function (index) {\r\n                return function (a, b) {\r\n                  return a[index] === b[index]\r\n                    ? 0\r\n                    : a[index] < b[index]\r\n                    ? -1\r\n                    : 1;\r\n                };\r\n              })(0)\r\n            );\r\n          }\r\n          if (intersections.length && point[0] > intersections[0][0]) {\r\n            intersections.shift();\r\n            intersectionCounter++;\r\n          }\r\n          if (intersectionCounter % 2 === 0) {\r\n            result = false;\r\n          }\r\n          return result;\r\n        },\r\n        this.configuration.statsCalculator.statsCallback,\r\n        boundsIJK\r\n      );\r\n\r\n      const modalityUnitOptions = {\r\n        isPreScaled: isViewportPreScaled(viewport, targetId),\r\n        isSuvScaled: this.isSuvScaled(\r\n          viewport,\r\n          targetId,\r\n          annotation.metadata.referencedImageId\r\n        ),\r\n      };\r\n\r\n      const modalityUnit = getModalityUnit(\r\n        metadata.Modality,\r\n        annotation.metadata.referencedImageId,\r\n        modalityUnitOptions\r\n      );\r\n\r\n      const stats = this.configuration.statsCalculator.getStatistics();\r\n\r\n      cachedStats[targetId] = {\r\n        Modality: metadata.Modality,\r\n        area,\r\n        perimeter: calculatePerimeter(canvasCoordinates, closed),\r\n        mean: stats.mean?.value,\r\n        max: stats.max?.value,\r\n        stdDev: stats.stdDev?.value,\r\n        statsArray: stats.array,\r\n        pointsInShape: pointsInShape,\r\n        areaUnit: areaUnits,\r\n        modalityUnit,\r\n      };\r\n    }\r\n\r\n    triggerAnnotationModified(\r\n      annotation,\r\n      enabledElement.viewport.element,\r\n      ChangeTypes.StatsUpdated\r\n    );\r\n\r\n    annotation.invalidated = false;\r\n\r\n    return cachedStats;\r\n  };\r\n\r\n  private _renderStats = (\r\n    annotation,\r\n    viewport,\r\n    enabledElement,\r\n    svgDrawingHelper\r\n  ) => {\r\n    const { data } = <PlanarFreehandROIAnnotation>annotation;\r\n    const targetId = this.getTargetId(viewport);\r\n\r\n    const styleSpecifier: AnnotationStyle.StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\r\n    if (!options.visibility) {\r\n      return;\r\n    }\r\n\r\n    const textLines = this.configuration.getTextLines(data, targetId);\r\n    if (!textLines || textLines.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const canvasCoordinates = data.contour.polyline.map((p) =>\r\n      viewport.worldToCanvas(p)\r\n    );\r\n    if (!data.handles.textBox.hasMoved) {\r\n      const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\r\n\r\n      data.handles.textBox.worldPosition =\r\n        viewport.canvasToWorld(canvasTextBoxCoords);\r\n    }\r\n\r\n    const textBoxPosition = viewport.worldToCanvas(\r\n      data.handles.textBox.worldPosition\r\n    );\r\n\r\n    const textBoxUID = '1';\r\n    const boundingBox = drawLinkedTextBox(\r\n      svgDrawingHelper,\r\n      annotation.annotationUID ?? '',\r\n      textBoxUID,\r\n      textLines,\r\n      textBoxPosition,\r\n      canvasCoordinates,\r\n      {},\r\n      options\r\n    );\r\n\r\n    const { x: left, y: top, width, height } = boundingBox;\r\n\r\n    data.handles.textBox.worldBoundingBox = {\r\n      topLeft: viewport.canvasToWorld([left, top]),\r\n      topRight: viewport.canvasToWorld([left + width, top]),\r\n      bottomLeft: viewport.canvasToWorld([left, top + height]),\r\n      bottomRight: viewport.canvasToWorld([left + width, top + height]),\r\n    };\r\n  };\r\n}\r\n\r\nfunction defaultGetTextLines(data, targetId): string[] {\r\n  const cachedVolumeStats = data.cachedStats[targetId];\r\n  const {\r\n    area,\r\n    mean,\r\n    stdDev,\r\n    perimeter,\r\n    max,\r\n    isEmptyArea,\r\n    areaUnit,\r\n    modalityUnit,\r\n  } = cachedVolumeStats || {};\r\n\r\n  const textLines: string[] = [];\r\n\r\n  if (area) {\r\n    const areaLine = isEmptyArea\r\n      ? `Area: Oblique not supported`\r\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\r\n    textLines.push(areaLine);\r\n  }\r\n\r\n  if (mean) {\r\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\r\n  }\r\n\r\n  if (Number.isFinite(max)) {\r\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\r\n  }\r\n\r\n  if (stdDev) {\r\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\r\n  }\r\n\r\n  if (perimeter) {\r\n    textLines.push(`Perimeter: ${roundNumber(perimeter)} ${modalityUnit}`);\r\n  }\r\n\r\n  return textLines;\r\n}\r\n\r\nPlanarFreehandROITool.toolName = 'PlanarFreehandROI';\r\nexport default PlanarFreehandROITool;\r\n","import {\r\n  getEnabledElementByIds,\r\n  Types,\r\n  utilities as csUtils,\r\n} from '@cornerstonejs/core';\r\nimport Representations from '../../enums/SegmentationRepresentations';\r\nimport { config as segmentationConfig } from '../../stateManagement/segmentation';\r\nimport { setSegmentationVisibility } from '../../stateManagement/segmentation/config/segmentationVisibility';\r\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/segmentationState';\r\nimport { getToolGroup } from '../../store/ToolGroupManager';\r\nimport { PublicToolProps, ToolProps } from '../../types';\r\nimport { BaseTool } from '../base';\r\n\r\nimport {\r\n  SegmentationRepresentationConfig,\r\n  ToolGroupSpecificRepresentation,\r\n} from '../../types/SegmentationStateTypes';\r\nimport { surfaceDisplay } from './Surface';\r\nimport { contourDisplay } from './Contour';\r\nimport { labelmapDisplay } from './Labelmap';\r\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\r\nimport { addTool, state } from '../../store';\r\nimport PlanarFreehandContourSegmentationTool from '../annotation/PlanarFreehandContourSegmentationTool';\r\n\r\nconst planarContourToolName = PlanarFreehandContourSegmentationTool.toolName;\r\n/**\r\n * In Cornerstone3DTools, displaying of segmentations are handled by the SegmentationDisplayTool.\r\n * Generally, any Segmentation can be viewed in various representations such as\r\n * labelmap (3d), contours, surface etc. As of now, Cornerstone3DTools only implements\r\n * Labelmap representation.\r\n *\r\n * SegmentationDisplayTool works at ToolGroup level, and is responsible for displaying the\r\n * segmentation representation for ALL viewports of a toolGroup, this way we can support complex\r\n * scenarios for displaying segmentations.\r\n *\r\n * Current Limitations:\r\n * - Only supports rendering of the volumetric segmentations in 3D space. (StackViewport segmentations are not supported yet)\r\n * - Labelmap representation is the only supported representation for now.\r\n *\r\n * Similar to other tools in Cornerstone3DTools, the SegmentationDisplayTool should\r\n * be added to the CornerstoneTools by calling cornerstoneTools.addTool(SegmentationDisplayTool)\r\n * and a toolGroup should be created for it using the ToolGroupManager API, finally\r\n * viewports information such as viewportId and renderingEngineId should be provided\r\n * to the toolGroup and the SegmentationDisplayTool should be set to be activated.\r\n *\r\n *\r\n */\r\nclass SegmentationDisplayTool extends BaseTool {\r\n  static toolName;\r\n  constructor(\r\n    toolProps: PublicToolProps = {},\r\n    defaultToolProps: ToolProps = {\r\n      configuration: {},\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  onSetToolEnabled(): void {\r\n    const toolGroupId = this.toolGroupId;\r\n    const toolGroupSegmentationRepresentations =\r\n      getSegmentationRepresentations(toolGroupId);\r\n\r\n    if (\r\n      !toolGroupSegmentationRepresentations ||\r\n      toolGroupSegmentationRepresentations.length === 0\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    // for each segmentationData, make the visibility true\r\n    toolGroupSegmentationRepresentations.forEach(\r\n      (segmentationRepresentation) => {\r\n        setSegmentationVisibility(\r\n          toolGroupId,\r\n          segmentationRepresentation.segmentationRepresentationUID,\r\n          true\r\n        );\r\n      }\r\n    );\r\n  }\r\n\r\n  onSetToolDisabled(): void {\r\n    const toolGroupId = this.toolGroupId;\r\n    const toolGroupSegmentationRepresentations =\r\n      getSegmentationRepresentations(toolGroupId);\r\n\r\n    if (\r\n      !toolGroupSegmentationRepresentations ||\r\n      toolGroupSegmentationRepresentations.length === 0\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    // for each segmentationData, make the visibility false\r\n    toolGroupSegmentationRepresentations.forEach(\r\n      (segmentationRepresentation) => {\r\n        setSegmentationVisibility(\r\n          toolGroupId,\r\n          segmentationRepresentation.segmentationRepresentationUID,\r\n          false\r\n        );\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * It is used to trigger the render for each segmentations in the toolGroup.\r\n   * Based on the segmentation representation type, it will call the corresponding\r\n   * render function.\r\n   *\r\n   * @param toolGroupId - the toolGroupId\r\n   */\r\n  renderSegmentation = (toolGroupId: string): void => {\r\n    const toolGroup = getToolGroup(toolGroupId);\r\n\r\n    if (!toolGroup) {\r\n      return;\r\n    }\r\n\r\n    const toolGroupSegmentationRepresentations =\r\n      getSegmentationRepresentations(toolGroupId);\r\n\r\n    if (\r\n      !toolGroupSegmentationRepresentations ||\r\n      toolGroupSegmentationRepresentations.length === 0\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    // toolGroup Viewports\r\n    const toolGroupViewports = toolGroup.viewportsInfo.map(\r\n      ({ renderingEngineId, viewportId }) => {\r\n        const enabledElement = getEnabledElementByIds(\r\n          viewportId,\r\n          renderingEngineId\r\n        );\r\n\r\n        if (enabledElement) {\r\n          return enabledElement.viewport;\r\n        }\r\n      }\r\n    );\r\n\r\n    // Render each segmentationData, in each viewport in the toolGroup\r\n    const segmentationRenderList = toolGroupSegmentationRepresentations.map(\r\n      (representation: ToolGroupSpecificRepresentation) => {\r\n        const config = this._getMergedRepresentationsConfig(toolGroupId);\r\n\r\n        const viewportsRenderList = [];\r\n\r\n        const renderers = {\r\n          [Representations.Labelmap]: labelmapDisplay,\r\n          [Representations.Contour]: contourDisplay,\r\n          [Representations.Surface]: surfaceDisplay,\r\n        };\r\n\r\n        if (representation.type === SegmentationRepresentations.Contour) {\r\n          // if the representation is contour we need to make sure\r\n          // that the planarFreeHandTool is added to the toolGroup\r\n          this.addPlanarFreeHandToolIfAbsent(toolGroupId);\r\n        }\r\n\r\n        const display = renderers[representation.type];\r\n\r\n        for (const viewport of toolGroupViewports) {\r\n          const renderedViewport = display.render(\r\n            viewport as Types.IVolumeViewport,\r\n            representation,\r\n            config\r\n          );\r\n\r\n          viewportsRenderList.push(renderedViewport);\r\n        }\r\n        return viewportsRenderList;\r\n      }\r\n    );\r\n\r\n    Promise.allSettled(segmentationRenderList).then(() => {\r\n      // for all viewports in the toolGroup trigger a re-render\r\n      toolGroupViewports.forEach((viewport) => {\r\n        viewport.render();\r\n      });\r\n    });\r\n  };\r\n\r\n  addPlanarFreeHandToolIfAbsent(toolGroupId) {\r\n    // if it is contour we should check if the toolGroup and more importantly\r\n    // the cornerstoneTools have the planarFreeHandTool added\r\n    if (!(planarContourToolName in state.tools)) {\r\n      addTool(PlanarFreehandContourSegmentationTool);\r\n    }\r\n\r\n    const toolGroup = getToolGroup(toolGroupId);\r\n\r\n    // check if toolGroup has this tool\r\n    if (!toolGroup.hasTool(planarContourToolName)) {\r\n      toolGroup.addTool(planarContourToolName);\r\n      toolGroup.setToolPassive(planarContourToolName);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Merge the toolGroup specific configuration with the default global configuration\r\n   * @param toolGroupId\r\n   * @returns\r\n   */\r\n  _getMergedRepresentationsConfig(\r\n    toolGroupId: string\r\n  ): SegmentationRepresentationConfig {\r\n    const toolGroupConfig =\r\n      segmentationConfig.getToolGroupSpecificConfig(toolGroupId);\r\n    const globalConfig = segmentationConfig.getGlobalConfig();\r\n\r\n    // merge two configurations and override the global config\r\n    const mergedConfig = csUtils.deepMerge(globalConfig, toolGroupConfig);\r\n\r\n    return mergedConfig;\r\n  }\r\n}\r\n\r\nSegmentationDisplayTool.toolName = 'SegmentationDisplay';\r\nexport default SegmentationDisplayTool;\r\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n"],"names":["VIEWPORT_ELEMENT","getSvgNode","canvasHash","cacheKey","svgNodeCache","domRef","appendNode","svgLayerElement","svgNode","touched","appendChild","setNodeTouched","clearUntouched","Object","keys","forEach","cacheEntry","removeChild","element","enabledElement","getEnabledElement","viewportId","renderingEngineId","viewportElement","internalDivElement","querySelector","_getSvgLayer","svgNodeCacheForCanvas","bind","this","fn","svgDrawingHelper","ToolModes","Active","Passive","Enabled","Disabled","PRIMARY_BINDINGS","mouseButton","MouseBindings","Primary","ToolGroup","constructor","id","viewportsInfo","toolOptions","currentActivePrimaryToolName","prevActivePrimaryToolName","restoreToolOptions","_toolInstances","getViewportIds","map","getViewportsInfo","slice","getToolInstance","toolInstanceName","toolInstance","console","warn","getToolInstances","hasTool","toolName","addTool","configuration","toolDefinition","tools","hasToolName","localToolInstance","toolClass","ToolClass","instantiatedTool","name","toolGroupId","addToolInstance","parentClassName","ToolClassToUse","ParentClass","ToolInstance","addViewport","Error","renderingEngines","getRenderingEngines","length","renderingEngineUIDToUse","some","vpId","push","getActivePrimaryMouseButtonTool","Settings","getRuntimeSettings","get","setViewportsCursorByToolName","eventDetail","triggerEvent","eventTarget","Events","TOOLGROUP_VIEWPORT_ADDED","removeViewports","indices","vpInfo","index","match","i","splice","TOOLGROUP_VIEWPORT_REMOVED","setActiveStrategy","strategyName","undefined","setToolMode","mode","options","setToolDisabled","setToolEnabled","setToolPassive","setToolActive","toolBindingsOptions","bindings","reduce","unique","binding","TouchBinding","numTouchPoints","MouseBinding","obj","hasSameBinding","useCursor","_hasMousePrimaryButtonBinding","cursor","MouseCursor","getDefinedCursor","_setCursorForViewports","onSetToolActive","_renderViewports","TOOL_ACTIVATED","_triggerToolModeChangedEvent","prevToolOptions","getToolOptions","assign","matchBindings","Array","isArray","removeAllBindings","getDefaultPrimaryBindings","filter","matchBinding","onSetToolPassive","onSetToolEnabled","onSetToolDisabled","toolOptionsForTool","find","_getCursor","cursorName","SVGMouseCursor","getEnabledElementByIds","viewport","initElementCursor","setToolConfiguration","overwrite","_configuration","onSetToolConfiguration","getDefaultMousePrimary","getToolConfiguration","configurationPath","getPrevActivePrimaryToolName","clone","newToolGroupId","fnToolFilter","toolGroup","sourceToolInstance","sourceToolOptions","sourceToolMode","primaryBindings","primary","getRenderingEngine","renderViewport","TOOL_MODE_CHANGED","binding1","binding2","modifierKey","toolGroups","tg","toolGroupIndex","findIndex","removeToolGroup","removeSegmentationsFromToolGroup","s","MODES","toolGroupToolNames","includes","pointCanProjectOnLine","polyline","EPSILON","CONSTANTS","PARALLEL_THRESHOLD","PlanarFreehandROITool","toolProps","defaultToolProps","supportedInteractionTypes","shadow","preventHandleOutsideImage","contourHoleAdditionModifierKey","KeyboardBindings","Shift","alwaysRenderOpenContourHandles","enabled","radius","allowOpenContours","closeContourProximity","checkCanvasEditFallbackProximity","makeClockWise","subPixelResolution","smoothing","smoothOnAdd","smoothOnEdit","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","interpolation","onInterpolationComplete","decimate","epsilon","displayOnePointAsCrosshairs","calculateStats","getTextLines","defaultGetTextLines","statsCalculator","BasicStatsCalculator","super","isDrawing","isEditingClosed","isEditingOpen","addNewAnnotation","evt","detail","renderingEngine","annotation","createAnnotation","addAnnotation","viewportIdsToRender","getViewportIdsWithToolToRender","getToolName","activateDraw","preventDefault","handleSelectedCallback","handle","activateOpenContourEndEdit","toolSelectedCallback","data","contour","closed","activateClosedContourEdit","activateOpenContourEdit","isPointNearTool","canvasCoords","proximity","points","previousPoint","worldToCanvas","p1","p2","pStart","pEnd","cancel","cancelDrawing","cancelOpenContourEdit","cancelClosedContourEdit","_calculateCachedStats","cachedStats","targetIds","targetId","image","getTargetIdImage","imageData","metadata","canvasCoordinates","p","canvasPoint","originalWorldPoint","canvasToWorld","deltaXPoint","deltaYPoint","deltaInX","deltaInY","worldPosIndex","Math","floor","iMin","iMax","jMin","jMax","kMin","kMax","j","min","max","worldPosIndex2","scale","areaUnits","numPoints","projectedPolyline","maxX","canvasMaxX","maxY","canvasMaxY","minX","canvasMinX","minY","canvasMinY","math","topLeftBBWorld","topLeftBBIndex","bottomRightBBWorld","area","iDelta","jDelta","kDelta","ceil","boundsIJK","worldPosEnd","indexToWorld","canvasPosEnd","curRow","intersections","intersectionCounter","pointsInShape","pointLPS","pointIJK","result","point","getLineSegmentIntersectionsCoordinates","sort","a","b","shift","statsCallback","modalityUnitOptions","isPreScaled","isSuvScaled","referencedImageId","modalityUnit","Modality","stats","getStatistics","perimeter","mean","value","stdDev","statsArray","array","areaUnit","ChangeTypes","StatsUpdated","invalidated","_renderStats","getTargetId","styleSpecifier","getLinkedTextBoxStyle","visibility","textLines","handles","textBox","hasMoved","canvasTextBoxCoords","getTextBoxCoordsCanvas","worldPosition","textBoxPosition","boundingBox","drawLinkedTextBox","annotationUID","x","left","y","top","width","height","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","_throttledCalculateCachedStats","trailing","filterInteractableAnnotationsForElement","annotations","annotationsToDisplay","VolumeViewport","camera","getCamera","spacingInNormalDirection","filterAnnotationsWithinSlice","filterAnnotationsForDisplay","viewPlaneNormal","annotationsWithParallelNormals","td","annotationViewPlaneNormal","isParallel","abs","halfSpacingInNormalDirection","focalPoint","annotationsWithinSlice","isVisible","dir","dot","isContourSegmentationTool","worldPos","currentPoints","world","contourAnnotation","label","getAnnotationStyle","context","renderAnnotationInstance","renderContext","renderStatus","activeAnnotationUID","commonData","renderContourBeingDrawn","renderClosedContourBeingEdited","renderOpenContourBeingEdited","renderPointContourWithMarker","renderContour","_calculateStatsIfActive","movingTextBox","cachedVolumeStats","isEmptyArea","areaLine","roundNumber","Number","isFinite","planarContourToolName","SegmentationDisplayTool","renderSegmentation","getToolGroup","toolGroupSegmentationRepresentations","getSegmentationRepresentations","toolGroupViewports","segmentationRenderList","representation","config","_getMergedRepresentationsConfig","viewportsRenderList","renderers","Labelmap","Contour","Surface","type","addPlanarFreeHandToolIfAbsent","display","renderedViewport","render","Promise","allSettled","then","segmentationRepresentation","setSegmentationVisibility","segmentationRepresentationUID","toolGroupConfig","globalConfig","HASH_UNDEFINED","funcTag","genTag","reIsDeepProp","reIsPlainProp","reLeadingDot","rePropName","reEscapeChar","reIsHostCtor","freeGlobal","g","freeSelf","self","root","Function","uid","arrayProto","prototype","funcProto","objectProto","coreJsData","maskSrcKey","exec","IE_PROTO","funcToString","toString","hasOwnProperty","objectToString","reIsNative","RegExp","call","replace","Symbol","Map","getNative","nativeCreate","symbolProto","symbolToString","Hash","entries","clear","entry","set","ListCache","MapCache","assocIndexOf","key","other","baseGet","object","path","isSymbol","test","isKey","stringToPath","toKey","baseIsNative","isObject","func","pattern","tag","isFunction","e","isHostObject","toSource","getMapData","__data__","getValue","has","pop","memoize","string","baseToString","number","quote","resolver","TypeError","memoized","args","arguments","apply","cache","Cache","isObjectLike","module","exports","defaultValue"],"sourceRoot":""}